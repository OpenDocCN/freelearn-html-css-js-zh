- en: Beginning Your Microservice Journey
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始您的微服务之旅
- en: Microservices are one of the most tangible solutions in an enterprise to make
    quick, effective, and scalable applications. However, if they are not properly
    designed or understood, incorrect implementations and interpretations can lead
    to disastrous or irrecoverable failures. This chapter will begin our microservices
    journey by getting our hands dirty and diving deep into practical implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是企业中最具体的解决方案之一，可以快速、有效和可扩展地构建应用程序。然而，如果它们没有得到正确的设计或理解，错误的实施和解释可能导致灾难性或无法挽回的失败。本章将通过深入实际实施来开始我们的微服务之旅。
- en: The chapter will start with a description of shopping microservices, which we
    are going to develop throughout our journey. We will learn how to slice and dice
    a system into a connected set of microservices. We will design the overall architecture
    of our shopping cart microservices, define separation layers, add cache levels,
    and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将以对购物微服务的描述开始，这是我们将在整个旅程中开发的微服务。我们将学习如何将系统切分为一组相互连接的微服务。我们将设计购物车微服务的整体架构，定义分层，添加缓存级别等。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of shopping cart microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车微服务概述
- en: Architecture design of shopping cart microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车微服务的架构设计
- en: Implementation plan for shopping cart microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车微服务的实施计划
- en: Schema design and database selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式设计和数据库选择
- en: Microservice predevelopment aspects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务前期开发方面
- en: Developing some microservices for the shopping cart
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为购物车开发一些微服务
- en: Microservice design best practices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务设计最佳实践
- en: Overview of shopping cart microservices
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车微服务概述
- en: The most important aspect while working on a new system is its design. A poor
    initial design is always a leading cause of more challenges ahead. Rather than
    moaning later, solving errors, or applying patches to cover up a poor design,
    it is always wise not to rush through the design process, spend enough time, and
    have a flexible fool-proof design. This can only be achieved by understanding
    the requirements clearly. In this section, we will give a brief overview of shopping
    cart microservices; the problem we need to solve via microservices; and an overview
    of the business process, functional view, and deployment and design views.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理新系统时最重要的方面就是它的设计。一个糟糕的初始设计总是导致更多挑战的主要原因。与其之后抱怨、解决错误或应用补丁来掩盖糟糕的设计，总是明智的不要急于通过设计过程，花足够的时间，并拥有一个灵活的防错设计。这只能通过清楚地理解需求来实现。在本节中，我们将简要概述购物车微服务；我们需要通过微服务解决的问题；以及业务流程、功能视图、部署和设计视图的概述。
- en: Business process overview
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务流程概述
- en: 'The use case for our scenario is pretty straightforward. The following process
    diagram shows the end-to-end shopping process that we need to convert to microservices.
    The user adds an item to the cart, the inventory is updated, the user pays for
    the item, and then is able to check out. There are several validations involved,
    based on business rules. For example, if the user''s payment fails, then they
    should not be able to check out; if the inventory is not available, then the item
    should not be added to the cart and so on. Take a look at the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的场景用例非常简单明了。以下流程图显示了我们需要转换为微服务的端到端购物流程。用户将商品添加到购物车，更新库存，用户支付商品，然后可以结账。基于业务规则，涉及了几个验证。例如，如果用户的支付失败，那么他们就不应该能够结账；如果库存不可用，那么商品就不应该被添加到购物车等等。看一下以下流程图：
- en: '![](img/72153c1f-f798-4aa4-b08b-7663f60d4e55.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72153c1f-f798-4aa4-b08b-7663f60d4e55.png)'
- en: Business process overview
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 业务流程概述
- en: Functional view
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能视图
- en: 'Each business capability and its sub-capabilities are shown in a row, which
    essentially constitutes the shopping cart microservices. Some sub-capabilities
    are involved in more than one business capability and hence we need to manage
    some cross-cutting concerns. For example, an inventory service is used both as
    a separate process and when a person checks out a product. The following diagram
    shows the functional view of the shopping cart microservices:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个业务能力及其子能力都显示在一行中，这基本上构成了购物车微服务。一些子能力涉及到多个业务能力，因此我们需要管理一些横切关注点。例如，库存服务既用作独立流程，也用于用户结账产品。以下图显示了购物车微服务的功能视图：
- en: '![](img/193b2e4a-8d72-423a-8488-704770f5a066.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193b2e4a-8d72-423a-8488-704770f5a066.png)'
- en: Functional view
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 功能视图
- en: The diagram combines the business capabilities into one picture. For example,
    the inventory service states there are two sub-functions—add product details and
    add product quantity and inventory items. That summarizes the inventory service's
    objectives. Creating a functional view for our system gives us a clear understanding
    of all the business processes and related things involved in them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该图将业务能力结合成一张图片。例如，库存服务说明有两个子功能——添加产品详情和添加产品数量和库存项目。这总结了库存服务的目标。为我们的系统创建一个功能视图可以让我们清楚地了解所有涉及其中的业务流程和相关事项。
- en: Deployment view
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署视图
- en: 'The requirement for deployment is pretty straightforward. Based on demand,
    we need to add new services to support various business capabilities on the fly.
    Say, for example, right now the payment medium is **PayPal**, but it may happen
    in the future that we also need to support some local payment options, such as
    bank wallets. At that time, we should easily be able to add new microservices
    without disrupting the entire ecosystem. The following diagram shows the deployment
    view. Right now, there are two nodes (one master and one slave), but based on
    demand, the number of nodes may increase or decrease based on the business capabilities,
    a spike in traffic, and other requirements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的要求非常简单。根据需求，我们需要随时添加新的服务来支持各种业务能力。比如，现在支付方式是**PayPal**，但将来可能需要支持一些本地支付选项，比如银行钱包。那时，我们应该能够轻松地添加新的微服务，而不会破坏整个生态系统。以下图表显示了部署视图。现在有两个节点（一个主节点和一个从节点），但根据需求，节点的数量可能会根据业务能力、流量激增和其他要求而增加或减少：
- en: '![](img/35bb0ad2-fda8-42fe-b101-a7b43af015f7.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35bb0ad2-fda8-42fe-b101-a7b43af015f7.png)'
- en: Deployment view
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 部署视图
- en: In this section, we got a brief overview of our shopping cart microservice system.
    We understood its functional, business process, and deployment views. In the next
    section, we will see the architecture design of the shopping cart microservices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们简要概述了我们的购物车微服务系统。我们了解了它的功能、业务流程和部署视图。在下一节中，我们将看到购物车微服务的架构设计。
- en: Architecture design of our system
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们系统的架构设计
- en: In this section, we will look at the architectural aspects involved in distributed
    microservices. We will look at our overall architecture diagram, which we are
    going to make throughout the book, and look at aspects such as separating concerns,
    how to apply reactive patterns, and the microservice efficiency model. So, let's
    get started.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下分布式微服务涉及的架构方面。我们将看一下我们将在整本书中制作的整体架构图，并关注诸如分离关注点、如何应用反应式模式以及微服务效率模型等方面。所以，让我们开始吧。
- en: 'Now that we know our business requirements, let''s design our architecture.
    Based on our knowledge of microservices and other concepts from [Chapter 1](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml), *Debunking
    Microservices*, we have the final overall diagram, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的业务需求，让我们设计我们的架构。根据我们对微服务和其他概念的了解，我们有最终的整体图表，如下所示：
- en: '![](img/71920699-b87a-49d8-a2ca-fd95f8fa8931.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71920699-b87a-49d8-a2ca-fd95f8fa8931.png)'
- en: Microservice architecture
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构
- en: We will study components such as API Gateway, service registry, and discovery
    in much more detail in later chapters. Here, they are just mentioned as part of
    the overall view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中更详细地研究API网关、服务注册表和发现等组件。在这里，它们只是作为整体视图的一部分提到。
- en: Let's understand the key components in the preceding diagram to get a better
    idea of our architecture.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解前面图表中的关键组件，以更好地了解我们的架构。
- en: Different microservices
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的微服务
- en: 'If we understood our business requirements correctly, we will come up with
    the following business capabilities:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正确理解了我们的业务需求，我们将得出以下业务能力：
- en: Product catalog
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品目录
- en: Price catalog
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格目录
- en: Discounts
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折扣
- en: Invoice
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发票
- en: Payment
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付
- en: Inventory
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存
- en: Based on our business capabilities and single responsibility, we divided our
    microservices briefly into various smaller applications. In our design, we ensured
    that each business capability is implemented by a single microservice and we don't
    overload a microservice with more than one microservice. We briefly divided our
    entire system into various microservices, such as a shopping cart microservice,
    products microservice, payment microservice, consumer microservice, cache microservice,
    price calculations and suggestions microservice, and so on. The overall granular
    flow can be seen in the preceding diagram. Another important thing to notice is
    that each microservice has its separate data store. Different business capabilities
    have different needs. For example, when a person checks out a product, if the
    transaction failed, then all transactions such as adding a product to a customer's
    purchase item, deducting quantity from a product inventory, and so on should be
    rolled back. In this case, we need relational databases that can handle transactions,
    whereas in the case of products, our metadata constantly changes. Some products
    may have more features than other products. In such cases, having a fixed relational
    schema is not wise and we can go for NoSQL data stores.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的业务能力和单一责任，我们将我们的微服务简要地划分为各种较小的应用程序。在我们的设计中，我们确保每个业务能力由一个单独的微服务实现，我们不会将一个微服务过载超过一个微服务。我们将整个系统简要地划分为各种微服务，如购物车微服务、产品微服务、支付微服务、消费者微服务、缓存微服务、价格计算和建议微服务等。整体的细粒度流程可以在前面的图表中看到。另一个重要的事情是，每个微服务都有自己的数据存储。不同的业务能力有不同的需求。例如，当一个人结账时，如果交易失败，那么所有的交易，比如将产品添加到客户的购买项目中，从产品库存中扣除数量等，都应该被回滚。在这种情况下，我们需要能够处理事务的关系型数据库，而在产品的情况下，我们的元数据不断变化。一些产品可能比其他产品具有更多的功能。在这种情况下，拥有固定的关系模式是不明智的，我们可以选择NoSQL数据存储。
- en: At the time of writing this book, MongoDB 4.0 had not yet been introduced. It
    provides the following transactional plus NoSQL benefits in one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，MongoDB 4.0尚未推出。它提供了以下事务加NoSQL的优势。
- en: Cache microservice
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存微服务
- en: The next component that we are going to see is centralized cache storage. This
    microservice directly interacts with all microservices and we may use this service
    to cache our responses when needed. Often it may happen that a service goes down,
    and we may still preserve the application by showing cached data (things such
    as product information and metadata rarely change; we may cache them for a certain
    interval of time, thus preventing an extra database hop). Having a cache increases
    the performance and availability of the system, which ultimately leads to cost
    optimization. It provides a blazing fast user experience. As microservices are
    constantly moving, often they may not be reached. In such cases, it is always
    advantageous to have a cached response when reaching out to availability zones
    fails.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要看的是集中式缓存存储。这个微服务直接与所有微服务进行交互，我们可以使用这个服务在需要时缓存我们的响应。通常情况下，可能会出现一个服务停止运行，但我们仍然可以通过显示缓存数据来保留应用程序（例如产品信息和元数据很少改变；我们可以将它们缓存一段时间，从而避免额外的数据库访问）。拥有缓存可以提高系统的性能和可用性，最终导致成本优化。它提供了极快的用户体验。由于微服务不断移动，通常它们可能无法被访问。在这种情况下，当访问可用性区域失败时，拥有缓存响应总是有利的。
- en: Service registry and discovery
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表和发现
- en: At the start of the diagram, we included the service registry. This is a dynamic
    database maintained on the startup and shutdown events of all microservices. Services
    subscribe to the registry and listen for updates to know whether the service has
    gone down or not. The entire process is done through the service registry and
    discovery. The registrator updates the registry whenever a service goes down or
    goes up. This registry is cached on all clients who subscribe to the registry,
    so whenever a service needs to be interacted with, an address is fetched from
    this registry. We will look in detail at this process in [Chapter 6](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml),
    *Service Registry and Discovery*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表的开始，我们包括了服务注册表。这是一个动态数据库，记录了所有微服务的启动和关闭事件。服务订阅注册表并监听更新，以了解服务是否已经停止。整个过程通过服务注册表和发现完成。当服务停止或启动时，注册器会更新注册表。这个注册表被所有订阅注册表的客户端缓存，所以每当一个服务需要交互时，地址都是从这个注册表中获取的。我们将在《第6章》*服务注册表和发现*中详细讨论这个过程。
- en: Registrator
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Registrator
- en: The next component that we are going to look at, which is available alongside
    the cache, is the **Registrator** ([http://gliderlabs.github.io/registrator/latest/](http://gliderlabs.github.io/registrator/latest/)).
    The Registrator is a third-party service registration tool that basically watches
    for startup and shutdown events of microservices and, based on the output of those
    events, dynamically updates the centralized service registry. Different services
    can then directly communicate with the registry to get updated locations of services.
    The Registrator ensures that registration and deregistration code is not duplicated
    across systems. We will look at this in more detail in [Chapter 6](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml),
    *Service Registry and Discovery*, where we integrate the Registrator with the
    consul.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要看的是与缓存一起提供的**Registrator** ([http://gliderlabs.github.io/registrator/latest/](http://gliderlabs.github.io/registrator/latest/))。Registrator是一个第三方服务注册工具，基本上监视微服务的启动和关闭事件，并根据这些事件的输出动态更新集中式服务注册表。不同的服务可以直接与注册表通信，以获取服务的更新位置。Registrator确保注册和注销代码在系统中不会重复。我们将在《第6章》*服务注册表和发现*中更详细地讨论这个问题，其中我们将Registrator与consul集成。
- en: Logger
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录器
- en: One of the important aspects of any application is the logs. Analyzing any problem
    becomes very easy when appropriate logs are used. Hence, here we have a centralized
    logger microservice that is based on the famous Elastic framework. Logstash watches
    for log files and transforms them into appropriate JSON before pushing to Elasticsearch.
    We can visualize the logs through the Kibana dashboard. Each microservice will
    have its unique UUID or some log pattern configured. We will look at this in much
    more detail in [Chapter 9](90996850-1ced-4678-a297-3e1fee118eb9.xhtml), *Deployment,
    Logging, and Monitoring*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的一个重要方面是日志。当使用适当的日志时，分析任何问题变得非常容易。因此，这里我们有一个基于著名的Elastic框架的集中式日志记录器微服务。Logstash监视日志文件，并在推送到Elasticsearch之前将其转换为适当的JSON格式。我们可以通过Kibana仪表板可视化日志。每个微服务都将有其独特的UUID或一些日志模式配置。我们将在《第9章》*部署、日志记录和监控*中更详细地讨论这个问题。
- en: Gateway
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关
- en: This is the most important part and the starting point of our microservices.
    It is the central point where we will handle cross-cutting concerns, such as authentication,
    authorization, transformation, and so on. While creating different microservices
    on various servers, we usually abstract the information of hosts and ports from
    the client. The client just makes a request to the gateway and the gateway takes
    care of the rest by interacting with the service registry and load balancer and
    redirecting the request to the appropriate service. This is the most important
    part in a microservice and it should be made highly available.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们微服务的最重要部分和起点。这是我们将处理诸如身份验证、授权、转换等横切关注点的中心点。在不同服务器上创建不同的微服务时，我们通常会将主机和端口的信息从客户端中抽象出来。客户端只需向网关发出请求，网关通过与服务注册表和负载均衡器的交互，并将请求重定向到适当的服务，来处理其余的事情。这是微服务中最重要的部分，应该使其高度可用。
- en: After going through the architecture diagram, now let's understand some aspects
    related to the architecture that we will use later.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过架构图之后，现在让我们了解一些与架构相关的方面，这些方面我们以后会用到。
- en: Design aspects involved
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涉及的设计方面
- en: 'Before actually coding, we need to understand the *how* and *why*. Let''s say
    if I have to cut down a tree (PS: I am a nature lover and I don''t support this),
    instead of directly chopping it down, I would rather first sharpen the axe. We
    are going to do the same, sharpen our axe first. In this section, we are going
    to look at various aspects involved in designing microservices. We will look at
    what models of communication to go through, what is included in microservices,
    and what areas to take care of in order to achieve efficient microservice development.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际编码之前，我们需要了解“如何”和“为什么”。比方说，如果我必须砍树（PS：我是一个热爱大自然的人，我不支持这个），我宁愿先磨削斧头，而不是直接砍树。我们将做同样的事情，先磨削我们的斧头。在这一部分，我们将看看设计微服务所涉及的各个方面。我们将看看要经历哪些通信模型，微服务中包括什么，以及为了实现高效的微服务开发而需要注意的哪些方面。
- en: Microservice efficiency model
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务效率模型
- en: 'Based on the various needs and requirements, we have defined a microservice
    efficiency model. Any proper implementation of microservices must adhere to it
    and provide a standard set of functionalities, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据各种需求和要求，我们已经定义了微服务效率模型。任何微服务的适当实现必须遵守它并提供一套标准的功能，如下所示：
- en: Communication over HTTP and HTTP listeners
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP和HTTP监听器进行通信
- en: Message or socket listeners
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息或套接字监听器
- en: Storage capabilities
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储能力
- en: Proper business/technical capabilities definitions
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当的业务/技术能力定义
- en: Service endpoint definitions and communication protocols
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务端点定义和通信协议
- en: Service contacts
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务联系人
- en: Security services
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全服务
- en: Service documentation through tools such as Swagger
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Swagger等工具的服务文档
- en: 'In the following diagram, we have summarized our microservice efficiency model:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们总结了我们的微服务效率模型：
- en: '![](img/45ff4392-2534-40b5-9a86-b3c583c80c30.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45ff4392-2534-40b5-9a86-b3c583c80c30.png)'
- en: Microservice efficiency model
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务效率模型
- en: Let's now look at each of the four sections of the preceding diagram.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看前面图表的四个部分。
- en: Core functionalities
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心功能
- en: 'Core functionalities are part of the microservice itself. They include the
    following functionalities:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 核心功能是微服务本身的一部分。它们包括以下功能：
- en: '**Technical capabilities**: Any technical functionalities needed, such as interacting
    with the service registry, sending out events to an event queue, processing events,
    and so on, are involved here.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术能力：任何需要的技术功能，如与服务注册表交互，向事件队列发送事件，处理事件等，都涉及在这里。
- en: '**Business capabilities**: Microservices written to achieve a business capability
    or fulfill a business requirement.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务能力：编写微服务以实现业务能力或满足业务需求。
- en: '**HTTP listeners**: A part of the technical capability; here we define APIs
    for external consumers. While starting the server, an HTTP listener is started,
    eliminating any other needs.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP监听器：技术能力的一部分；在这里，我们为外部消费者定义API。在启动服务器时，将启动HTTP监听器，消除任何其他需求。
- en: '**Message listeners**: A part of event-based communication where the sender
    doesn''t worry whether the message listeners are implemented.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息监听器：事件驱动通信的一部分，发送方不必担心消息监听器是否已实现。
- en: '**API Gateway**: One point of communication for the end client. The API Gateway
    is the single place for handling any core concerns.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关：终端客户端的通信单一点。API网关是处理任何核心关注点的单一位置。
- en: '**Document storage or data storage**: Our data layer for the application. Based
    on our needs, we may use any of the available data stores.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档存储或数据存储：我们应用程序的数据层。根据我们的需求，我们可以使用任何可用的数据存储。
- en: Supporting efficiencies
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持效率
- en: 'These are solutions to help in achieving core microservice implementation.
    They include the following components:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是帮助实现核心微服务的解决方案。它们包括以下组件：
- en: '**Load balancer**: Anapplication load balancer to redirect based on changes
    in the server topology. It handles dynamic services going up or down.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡器：应用程序负载均衡器，根据服务器拓扑的变化进行重定向。它处理动态服务的上线或下线。
- en: '**Service registry**: A runtime environment for services if they go up or down
    to publish to. It maintains the active log of all services along with the available
    instances.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册表：服务的运行时环境，如果服务上线或下线，需要发布到其中。它维护所有服务的活动日志以及可用实例。
- en: '**Central logs**: A core centralized logging solution to observe logs all places,
    rather than individually opening containers and seeking logs there.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 中央日志：核心的集中式日志记录解决方案，以观察所有地方的日志，而不是单独打开容器并在那里寻找日志。
- en: '**Security**: Checking authentic client requests through common available mechanisms,
    such as OAuth, token-based, IP-based, and so on.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安全：通过常用的可用机制（如OAuth，基于令牌，基于IP等）检查真实的客户端请求。
- en: '**Testing**: Testing out the microservices and essentials, such as inter-microservice
    communication, scalability, and so on.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：测试微服务和基本功能，如微服务间通信，可伸缩性等。
- en: Infrastructure role
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施角色
- en: 'The following are the infrastructure expectations needed for efficient microservice
    implementation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现高效微服务所需的基础设施期望：
- en: '**Server layer**: An efficient mechanism to choose for deploying our microservice.
    Well-known options include Amazon EC2 instance, Red Hat OpenShift, or serverless.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器层：选择部署我们的微服务的有效机制。众所周知的选项包括亚马逊EC2实例，红帽OpenShift或无服务器。
- en: '**Container**: Dockerizing the application, so it can run easily on any OS
    without much fuss about installation.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器：将应用程序容器化，以便在任何操作系统上轻松运行，而无需安装太多。
- en: '**CI/CD**: A process to maintain easy deployment cycles.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD：维护简单部署周期的过程。
- en: '**Clustering**: Server load balancers to handle the load or spike in applications
    as required.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群：服务器负载均衡器，以处理应用程序中的负载或峰值。
- en: Governance
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 治理
- en: 'Processes and reference information to ease up our overall life cycle in application
    development include the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 流程和参考信息，以简化我们在应用程序开发中的整体生命周期，包括以下内容：
- en: '**Contract testing**: Testing out microservice expectations and actual outputs
    to make sure frequent changes don''t break anything'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合同测试**：测试微服务的期望和实际输出，以确保频繁的更改不会破坏任何东西'
- en: '**Scalablity**: Spawning new instances and removing those instances on demand
    to handle spikes in load'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：根据需求产生新实例并在需求减少时移除这些实例以处理负载峰值'
- en: '**Documentation**: Generating documentation to easily understand what someone
    is actually doing'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：生成文档以便轻松理解别人实际在做什么'
- en: In the next section, we will carve out an implementation plan for our microservice
    development.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将为我们的微服务开发制定一个实施计划。
- en: Implementation plan for shopping cart microservices
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车微服务的实施计划
- en: 'One of the key challenges in microservice development is fixing the scope of
    a microservice:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务开发中的一个关键挑战是确定微服务的范围：
- en: If a microservice is too big, you end up in monolithic hell and get stuck in
    a huge turnaround time, with difficulty adding new features and implementing bug
    fixes
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个微服务太大，你最终会陷入单体地狱，难以添加新功能和实施错误修复
- en: If a microservice is too small, either we end up with tight coupling among services
    or too much code duplication and resource consumption
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个微服务太小，要么我们会在服务之间出现紧密耦合，要么会出现过多的代码重复和资源消耗
- en: If a microservice size is right, but the bounded context isn't fixed, such as
    services sharing a database, it leads to higher coupling and dependencies
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果微服务的大小合适，但有界上下文并不固定，比如服务共享数据库，会导致更高的耦合和依赖
- en: In this section, we are going to devise an implementation plan for our shopping
    cart microservices. We will formulate a general workflow or plan and design our
    system according to the plan. We will also see what to do when our scope is not
    clear, and how to proceed in such cases to ultimately reach our microservices
    goal. We will look at how to potentially avoid the aforementioned loop holes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将为我们的购物车微服务制定一个实施计划。我们将制定一个通用的工作流程或计划，并根据计划设计我们的系统。我们还将看看当我们的范围不清晰时该怎么办，以及如何在这种情况下继续，最终达到我们的微服务目标。我们将看看如何潜在地避免上述的漏洞。
- en: What to do when the scope is not clear
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当范围不清晰时该怎么办
- en: 'Until now, we have designed our architectural plan based on scoping microservices,
    but that was when our requirements were pretty clear. We knew exactly what we
    had to make. But in most cases, you won''t have a similar scenario. You will either
    be migrating from a monolithic system to microservices or you will be engulfed
    in constantly changing requirements or business capabilities that are still evolving,
    or it may be that the complexities of technical capabilities could not be estimated
    at the primer stage, making it difficult for you to scope the microservices. The
    following section is for such scenarios where you can perform the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设计了基于微服务范围的架构计划，但那是在我们的需求非常明确的情况下。我们清楚地知道我们需要做什么。但在大多数情况下，你可能不会有类似的情景。你要么是从单体系统迁移到微服务，要么是被不断变化的需求或业务能力所困扰，或者可能是技术能力的复杂性在初期无法估计，使得确定微服务的范围变得困难。接下来的部分是针对这种情况的，你可以执行以下步骤：
- en: '**Dream big and start big**: Deciding the scope of microservices is always
    a huge task, as it defines the overall bounded context. If that is not decided
    clearly, we ultimately get stuck in monolithic hell. However, if the scope is
    narrowed down too much, it has its disadvantages too. You will suffer difficulties,
    as you will end up with data duplication between two microservices, unclear responsibility,
    and difficulty deploying services independently. Carving out microservices from
    existing microservices is much easier than managing too narrowly carved microservices.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**梦想大，从大开始**：决定微服务的范围总是一个巨大的任务，因为它定义了整体的有界上下文。如果这不明确，我们最终会陷入单体地狱。然而，如果范围过于狭窄，也有其缺点。你将遇到困难，因为你最终会在两个微服务之间出现数据重复，责任不清晰，以及难以独立部署服务。从现有微服务中划分出微服务要比管理范围过窄的微服务容易得多。'
- en: '**Separate out microservices from existing microservices**: Once you feel that
    a microservice is too big, you will need to start separating out the service.
    First of all, the scope needs to be decided for both the existing and new microservice
    based on business and technical capabilities. Anything pertaining to a new microservice
    goes into its own module. Then any communication between the existing modules
    is moved to common interfaces, such as HTTP API/event-based communication, and
    so on. Microservices can be planned for later development too; when in doubt,
    always create a separate module, so we can easily move it out.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从现有微服务中分离出微服务**：一旦你觉得一个微服务太大，你需要开始分离服务。首先，需要根据业务和技术能力为现有和新的微服务确定范围。任何与新微服务有关的内容都放入自己的模块。然后，现有模块之间的任何通信都移动到公共接口，比如HTTP
    API/基于事件的通信等等。微服务也可以计划以后开发；如果有疑问，总是创建一个单独的模块，这样我们可以轻松地将其移出去。'
- en: '**Identify technical capabilities**: A technical capability is anything that
    supports other microservices, such as listening to events emitted by event queues,
    registering to the service registry, and so on. Keeping the technical capability
    inside the same microservice can be a huge risk as it will soon lead to tight
    coupling and the same technical capability might be implemented by lots of other
    services too.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确定技术能力**：技术能力是支持其他微服务的任何东西，比如监听事件队列发出的事件，注册到服务注册表等等。将技术能力保留在同一个微服务中可能是一个巨大的风险，因为它很快会导致紧密耦合，同样的技术能力可能也会被许多其他服务实现。'
- en: '**Adherence standards for microservices based on business and technical capabilities**: Microservices
    adhere to fixed standards—self-sufficiency, resiliency, transparency, automation,
    and distribution. Each of the points can briefly be stated as:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于业务和技术能力的微服务遵循标准**：微服务遵循固定的标准——自给自足、弹性、透明、自动化和分布。每个点都可以简要陈述为：'
- en: A microservice serves a single business capability (modularity is the key thing).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务提供单一的业务能力（模块化是关键）。
- en: A microservice can be easily deployed individually. Each service would have
    its own build script and CI/CD pipeline. The common point would be the API Gateway
    and service registry.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务可以很容易地单独部署。每个服务都将有自己的构建脚本和CI/CD流水线。共同点将是API网关和服务注册表。
- en: You can easily find out the owners of microservices. They would be distributed
    and each team can own one microservice.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以很容易地找出微服务的所有者。它们将是分布式的，每个团队可以拥有一个微服务。
- en: A microservice can be replaced without much hassle. We will have common registration
    options via the service registry and discovery. Each of our services can be accessed
    via HTTP.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务可以很容易地被替换。我们将通过服务注册表和发现有共同的注册选项。我们的每个服务都可以通过HTTP访问。
- en: By following these steps, you will ultimately reach the microservice level,
    where each service will be serving a single business capability.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，最终将达到微服务级别，其中每个服务将提供单一的业务能力。
- en: Schema design and database selection
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式设计和数据库选择
- en: 'The main part of any application is its database selection. In this section,
    we will look at how to design our database for microservices, whether to keep
    it separate, to keep it shared, and which database to go to—SQL or NoSQL? We will
    look at how to categorize data stores based on data types and business capabilities.
    There are lots of options available. Microservices support polyglot persistence.
    The approach of selecting a particular data store based on business capabilities
    and needs is termed polyglot persistence. The following points discuss which database
    to refer to based on use cases:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的主要部分是其数据库选择。在本节中，我们将看看如何为微服务设计我们的数据库，是将其保持独立，还是共享，以及选择哪种数据库——SQL还是NoSQL？我们将根据数据类型和业务能力来分类数据存储。有很多选择。微服务支持多语言持久性。根据业务能力和需求选择特定数据存储的方法称为多语言持久性。以下几点讨论了基于用例选择哪种数据库：
- en: We can leverage Apache Cassandra to support tabular data, such as inventory
    data. It has options such as distributed consistency and lightweight transactions
    to support ACID transactions.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用Apache Cassandra来支持表格数据，例如库存数据。它具有分布式一致性和轻量级事务的选项，以支持ACID事务。
- en: We can leverage Redis to support cache data where the data model is simply a
    key-value pair. Read operations in Redis are super fast.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用Redis来支持缓存数据，其中数据模型只是一个键值对。Redis中的读操作非常快。
- en: We can leverage MongoDB to support product data stored in unstructured form
    with the ability to index on any particular field. A document-oriented database
    such as MongoDB has powerful options, such as an index in specific attributes
    to search faster.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用MongoDB来支持以非结构化形式存储的产品数据，并具有在任何特定字段上建立索引的能力。像MongoDB这样的面向文档的数据库具有强大的选项，比如在特定属性上建立索引以实现更快的搜索。
- en: We can leverage GraphQL to support complex relationships. GraphQL is extremely
    useful for many-to-many relationships, for example, our shopping cart recommendation
    system. Facebook uses GraphQL.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用GraphQL来支持复杂的关系。GraphQL对于多对多关系非常有用，例如我们的购物车推荐系统。Facebook使用GraphQL。
- en: We can use relational databases to support legacy systems or systems that require
    maintaining structured relational data. We use relational data where data doesn't
    change frequently.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用关系数据库来支持传统系统或需要维护结构化关系数据的系统。我们在数据不经常更改的地方使用关系数据。
- en: In this section, we will look into these points in detail and understand things
    such as how should the data layer be in a microservice. Then, we will look into
    types of databases and understand their advantages, disadvantages, and use cases.
    So, let's get started.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细了解这些要点，并了解微服务中数据层应该如何。然后，我们将了解数据库类型及其优缺点和用例。所以，让我们开始吧。
- en: How to segregate data between microservices
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在微服务之间划分数据
- en: The hardest thing about microservices is our data. Each microservice should
    maintain data by owning their individual database. Data must not be shared via
    a database. This rule helps us to eliminate a common case that leads to tight
    coupling between different microservices. If two microservices share the same
    database layer, and if the second service doesn't know about the first service
    changing the database schema, it will fail. Due to this, service owners need to
    be constantly in touch and this differs from our microservice path.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务最困难的是我们的数据。每个微服务都应该通过拥有自己的数据库来维护数据。数据不应通过数据库共享。这条规则有助于消除导致不同微服务之间紧密耦合的常见情况。如果两个微服务共享相同的数据库层，并且第二个服务不知道第一个服务更改了数据库模式，它将失败。由于这个原因，服务所有者需要保持不断联系，这与我们的微服务路径不同。
- en: 'Some of the questions that may come to our mind are how will the database stay
    in the microservice world? Will the services be sharing databases? If yes, then
    what would be the repercussions of shared data? Let''s answer these questions.
    We all know the phrase, *with ownership comes responsibility*. Similarly, if a
    service owns a data store, then it is solely responsible for keeping it up to
    date. Also, for optimal performance, the data that a microservice needs should
    be nearby or local, preferably within the microservice container itself, as microservices
    need to often interact with it. So far, we have learned about two principles for
    how to segregate data:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会想到一些问题，比如数据库在微服务世界中如何保持？服务是否会共享数据库？如果是的话，共享数据会有什么后果？让我们回答这些问题。我们都知道这句话，“拥有就意味着责任”。同样，如果一个服务拥有数据存储，那么它就是唯一负责保持其最新的。此外，为了实现最佳性能，微服务需要的数据应该是附近或本地的，最好是在微服务容器内部，因为微服务需要经常与其进行交互。到目前为止，我们已经了解了如何划分数据的两个原则：
- en: Data should be divided so that each microservice (fulfilling a certain business
    capability) should easily ensure that the database is up to date and not allow
    any other services direct access.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据应该被划分，以便每个微服务（满足某种业务能力）可以轻松确保数据库是最新的，并且不允许任何其他服务直接访问。
- en: Data relevant to that microservice should be in a nearby vicinity. Keeping it
    far away increases database costs plus network costs.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与该微服务相关的数据应该在附近。将其放得太远会增加数据库成本和网络成本。
- en: One of the general processes for segregating data is to build up a domain model
    comprising entities, objects, and aggregates. Let's say we have the following
    use cases—allowing a customer to search for a product, allowing a customer to
    buy a particular type of product, and allowing a customer to buy the product. 
    We have three functionalities—search, buy, and inventory. Each functionality has
    its own needs and so the product database is stored in the product catalog service,
    the inventory is stored differently, and the search service queries the product
    catalog service, and these results are cached.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据进行分离的一般过程之一是建立一个包含实体、对象和聚合的领域模型。假设我们有以下用例——允许客户搜索产品，允许客户购买特定类型的产品，以及允许客户购买产品。我们有三个功能——搜索、购买和库存。每个功能都有自己的需求，因此产品数据库存储在产品目录服务中，库存以不同的方式存储，搜索服务查询产品目录服务，这些结果被缓存。
- en: In this section, we will look at these rules in detail with an example, which
    will help us to decide where to keep a data layer and how it should be divided
    to give us maximum advantage.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个例子详细讨论这些规则，这将帮助我们决定在哪里保留数据层以及如何划分数据层以获得最大优势。
- en: Postulate 1 – data ownership should be regulated via business capabilities
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设1 - 数据所有权应通过业务能力进行规范
- en: One of the major ideas for deciding where data belongs in a microservice system
    is deciding on the basis of business capabilities. A microservice is just a service
    fulfilling a business capability that cannot be possible without having a data
    store. A business capability defines the contained region of the microservice.
    Everything that belongs to handling that capability should reside inside the microservice.
    For example, only one microservice should have a customer's personal details,
    comprising a delivery address, and email address. Another microservice can have
    a customer's purchase history and a third microservice can have customer preferences.
    The microservice responsible for the business capability is responsible for storing
    the data and keeping it up to date.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定数据在微服务系统中属于哪里的一个主要想法是基于业务能力进行决定。微服务只是满足业务能力的服务，而没有数据存储是不可能的。业务能力定义了微服务的包含区域。属于处理该能力的一切东西都应该驻留在微服务内部。例如，只有一个微服务应该拥有客户的个人详细信息，包括送货地址和电子邮件地址。另一个微服务可以拥有客户的购买历史，第三个微服务可以拥有客户的偏好。负责业务能力的微服务负责存储数据并保持其最新状态。
- en: Postulate 2 – replicate the database for speed and robustness
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设2 - 为了速度和鲁棒性而复制数据库
- en: The second factor at play when selecting where a piece of data should be stored
    in a microservice system is decided based on the scope or locality. There's a
    big change if the data store is in the vicinity of a microservice or far off,
    even though we are talking about the same data. A microservice can query its own
    database for data or a microservice can query another microservice for that same
    data. The latter, of course, will come with cons and tight dependencies. Looking
    in the local neighborhood is much faster than looking at different cities. Once
    you have decided on the scope of the data, you will realize that microservices
    need to talk to one another very often.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择在微服务系统中存储数据的位置时，第二个因素是基于范围或局部性来决定。即使我们谈论的是相同的数据，如果数据存储在微服务附近或远离微服务，都会有很大的变化。微服务可以查询自己的数据库获取数据，或者微服务可以查询另一个微服务获取相同的数据。后者当然会带来缺点和紧密的依赖关系。在本地邻域查找比在不同城市查找要快得多。一旦你决定了数据的范围，你会意识到微服务需要经常彼此交流。
- en: 'This kind of microservice often creates a very tight dependency, meaning we
    are stuck to the same old monolithic stuff. To loosen this, coupling a caching
    database or maintaining a cache store often comes in handy. You can cache responses
    as they are, or you can add a read model to expire cache after a certain time
    interval. The microservice that owns the local data should be in the best position
    to decide when a particular piece of code becomes invalid based on the business
    capability. HTTP cache headers should be used to control caching. Managing a cache
    is simply controlling the cache-control header. For example, the line `cache-control:
    private, max-age:3600` caches the response for 3,600 seconds.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '这种微服务通常会创建非常紧密的依赖关系，这意味着我们被困在同样的旧式单片系统中。为了解除这种依赖，耦合缓存数据库或者维护缓存存储通常会很有用。你可以将响应缓存下来，或者你可以添加一个读取模型来在一定时间间隔后使缓存失效。拥有本地数据的微服务应该处于最佳位置，根据业务能力来决定何时特定的代码变得无效。应该使用HTTP缓存头来控制缓存。管理缓存就是简单地控制缓存控制头。例如，`cache-control:
    private, max-age:3600`这一行将响应缓存3,600秒。'
- en: 'In the next section, we will look into how to select the best database based
    on the following criteria:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将根据以下标准来选择最佳数据库：
- en: How is my data? Is it a bunch of tables, a document, a key-value pair, or a
    graph?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的数据是什么？是一堆表、一个文档、一个键值对还是一个图？
- en: How much is my data write and read frequency? Do my write requests come randomly
    or are they evenly distributed in time? Is there a read-all-at-once scenario?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的数据写入和读取频率有多高？我的写入请求是随机的还是在时间上均匀分布的？是否存在一次性读取所有数据的情况？
- en: Are there more write operations or are there more read operations?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写操作多还是读操作多？
- en: How to choose a data store for your microservice
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何为你的微服务选择数据存储
- en: One of the most fundamental questions that pop up while designing microservices
    is *how does one choose the correct data store?* We will be talking about this
    in much more detail in the *Service* *state* section in [Chapter 7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml),
    *Service State and Interservice Communication*, but here, let's get our fundamentals
    right.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务时最基本的问题之一是*如何选择正确的数据存储？*我们将在[第7章](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml)的*服务状态和服务间通信*部分中更详细地讨论这个问题，但在这里，让我们先搞清楚基本原理。
- en: 'The first and foremost step in selecting any ideal data store is to find out
    the nature of our microservice data. Based on the nature of the data, we can briefly
    define the following categories:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 选择任何理想数据存储的首要步骤是找出我们微服务数据的性质。根据数据的性质，我们可以简要定义以下类别：
- en: '**Ephemeral or short-lived data**: A cache server is a classic example of short-lived
    data. It is a temporary store whose objective is to enhance the user experience
    by serving information in real time, thus avoiding frequent database calls. This
    is especially important where most of the operations are read intensive. Also,
    this store has no extra durability or security concerns as it does not have a
    master copy of the data. However, that being said, this should not be treated
    lightly as it has to be highly available. Failures can cause poor user experience
    and subsequently crash the main database as it won''t be able to handle such frequent
    calls. Examples of such data stores include Redis, Elasticsearch, and so on.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短暂或短暂的数据**：缓存服务器是短暂数据的经典示例。它是一个临时存储，其目标是通过实时提供信息来增强用户体验，从而避免频繁的数据库调用。这在大部分操作都是读取密集的情况下尤为重要。此外，此存储没有额外的耐久性或安全性问题，因为它没有数据的主要副本。然而，这不应被轻视，因为它必须具有高可用性。故障可能导致用户体验不佳，并随后使主数据库崩溃，因为它无法处理如此频繁的调用。此类数据存储的示例包括Redis、Elasticsearch等。'
- en: '**Transient or momentary data**: Data such as logs and messages usually come
    in bulk volume and frequency. Ingestion services process this information before
    passing it to the appropriate destinations. Such data stores need high frequency
    writes. Features such as time series data or JSON format are added advantages.
    The support requirements for transient data are higher as it is mostly used in
    event-based communications.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态或瞬时数据**：例如日志和消息等数据通常以大量和频率出现。摄取服务在将信息传递到适当的目的地之前处理这些信息。这种数据存储需要高频率的写入。时间序列数据或JSON格式等功能是额外的优势。瞬态数据的支持要求更高，因为它主要用于基于事件的通信。'
- en: '**Operational or functional data**: Operational data focuses on any information
    that is gathered from user sessions, such as user profiles, user shopping cart,
    wish lists, and so on. Being the primary data store, this kind of microservice
    provides better user experience with real-time feedback. For business continuity,
    this kinds of data must be retained. Here the durability, consistency, and availability
    requirements are very high. We can have any kind of data store as per our needs,
    providing any of the following structures—JSON, graph, key-value, relational,
    and so on.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运营或功能性数据**：运营数据侧重于从用户会话中收集的任何信息，例如用户配置文件、用户购物车、愿望清单等。作为主要数据存储，这种微服务提供了更好的用户体验和实时反馈。为了业务连续性，这种数据必须被保留。这种数据的耐久性、一致性和可用性要求非常高。根据我们的需求，我们可以根据需要提供以下任何一种结构的数据存储：JSON、图形、键值、关系等。'
- en: '**Transactional data**: Data gathered from a series of processes or transactions,
    such as payment processing, order management, must be stored in a database that
    supports ACID controls to avoid disasters (we will mostly use relational databases
    for transactional data). At the time of writing of this book, MongoDB 4.0, supporting
    transactional data, was still not available. Once generally available NoSQL data
    stores can be used even for transaction management.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务性数据**：从一系列流程或交易中收集的数据，例如支付处理、订单管理，必须存储在支持ACID控制以避免灾难的数据库中（我们将主要使用关系数据库来处理事务性数据）。在撰写本书时，仍然没有支持事务性数据的MongoDB
    4.0。一旦普遍可用，NoSQL数据存储甚至可以用于事务管理。'
- en: Design of product microservices
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品微服务的设计
- en: 'Based on our requirements, we can categorize data into the following various
    segments:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的需求，我们可以将数据分类为以下各种部分：
- en: '| **Microservice** | **Data store type** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **微服务** | **数据存储类型** |'
- en: '| Caching | Ephemeral (example: ELK) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 缓存 | 短暂（例如：ELK） |'
- en: '| User comments, ratings, feedback, and product top sellers | Transient |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 用户评论、评分、反馈和畅销产品 | 瞬态 |'
- en: '| Product catalog | Operational |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 产品目录 | 运营 |'
- en: '| Product search engine | Operational |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 产品搜索引擎 | 运营 |'
- en: '| Order processing | Transactional |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 订单处理 | 事务性 |'
- en: '| Order fulfillment | Transactional |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 订单履行 | 事务性 |'
- en: For our product catalog database, we will proceed with the following design.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的产品目录数据库，我们将按照以下设计进行。
- en: 'In the current chapter, we are going to go with the product catalog service,
    which requires us to use an operational data store. We will go with MongoDB. A
    product will have at least the following items—variant, price, hierarchy, vendor,
    feedback email, configurations, description, and so on. Instead of getting everything
    in a single document, we will use the following schema design:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前章节中，我们将使用产品目录服务，这要求我们使用运营数据存储。我们将使用MongoDB。产品至少包括以下项目：变体、价格、层次结构、供应商、反馈电子邮件、配置、描述等。我们将使用以下模式设计，而不是在单个文档中获取所有内容：
- en: '[PRE0]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some of the advantages of this schema design are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式设计的一些优点包括：
- en: It is easy to have a faceted search which returns results in quick milliseconds
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以进行快速毫秒级的分面搜索
- en: Each index will end with `_id`, making it useful for pagination
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个索引都将以“_id”结尾，使其对分页非常有用
- en: Efficient sorting can be done on various attributes
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对各种属性进行高效的排序
- en: Microservice predevelopment aspects
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务预开发方面
- en: In this section, we are going to look at some common development aspects that
    we will follow throughout the book. We will understand some common aspects, such
    as which HTTP message code to use, how to set up logging, which kinds of logging
    to keep, how to use PM2 options, and how to trace a request or attach a unique
    identifier to a microservice. So, let's get started.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解一些通常的开发方面，这些方面将贯穿整本书。我们将了解一些常见的方面，例如使用哪种HTTP消息代码，如何设置日志记录，保留哪些类型的日志记录，如何使用PM2选项，以及如何跟踪请求或附加唯一标识符到微服务。让我们开始吧。
- en: HTTP code
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP代码
- en: '**HTTP code** dominates standard API communication and are one of the general
    standards across any general-purpose API. It resolves common issues for any request
    that is made to the server, whether it is successful, whether it is producing
    a server error, and so on. HTTP resolves every single request with HTTP code with
    ranges that indicate the nature of the code. HTTP codes are standards ([http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html))
    based on various code and response actions are taken accordingly, so the concept
    of not reinventing the wheel essentially applies here. In this section, we will
    look at some of the standard code ranges along with their meanings.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP代码主导着标准API通信，并且是任何通用API的通用标准之一。它解决了向服务器发出的每个请求的常见问题，无论请求是否成功，是否产生服务器错误等等。HTTP使用代码范围来指示代码的性质。HTTP代码是基于各种代码和响应行为采取相应措施的标准（[http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)），因此在这里基本上适用于不重复造轮子的概念。在本节中，我们将看一些标准代码范围以及它们的含义。
- en: 1xx – informational
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1xx – 信息
- en: The **1xx** code provides primitive functionalities, such as operations happening
    in the background, switching protocols, or the state of the initial request. For
    example, `100 Continue` indicates that the server has received request headers
    and is now awaiting the request body, `101 Switching Protocols` indicates that
    the client has requested a protocol change from the server and the request has
    been approved, and `102` indicates that the operation is happening in the background
    and will take time to complete.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 1xx代码提供原始功能，例如后台操作、切换协议或初始请求的状态。例如，`100 Continue`表示服务器已收到请求头，并正在等待请求体，`101 Switching
    Protocols`表示客户端已请求从服务器更改协议，并且请求已获批准，`102`表示操作正在后台进行，需要一些时间来完成。
- en: 2xx – success
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2xx – 成功
- en: This is to indicate that a certain level of success has been achieved with information
    success code used in HTTP requests. It packages several responses into specific
    code. For example, `200 Ok` means that nothing went wrong and a GET or POST request
    was successful. `201 Created` means that a GET or POST request has been fulfilled
    and a new resource has been created for the client. `202 Accepted` means that
    a request has been accepted and is now being processed. `204 No Content` means
    that there is no content coming back from the server (very similar to `200`).
    `206 Partial Content` is usually used for paginated responses indicating there
    is more data to follow.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了指示在HTTP请求中使用了一定程度的成功信息成功代码。它将多个响应打包成特定代码。例如，`200 Ok`表示一切正常，GET或POST请求成功。`201
    Created`表示GET或POST请求已完成，并为客户端创建了一个新资源。`202 Accepted`表示请求已被接受并正在处理。`204 No Content`表示服务器没有返回内容（与`200`非常相似）。`206
    Partial Content`通常用于分页响应，表示还有更多数据要返回。
- en: 3xx – redirections
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3xx – 重定向
- en: The **3xx** range is all about the status of the resource or the endpoint. It
    indicates what additional actions must be taken to complete that request as the
    server is still accepting communication, but the endpoint contacted is not the
    correct point of entry in the system. The most common codes used are `301 Moved
    Permanently`, which indicates that future requests must be handled by different
    URIs, `302 Found`, which indicates a temporary redirect is needed for some reason,
    `303 See other`, which tells browsers to see another page, and `308 Permanent
    Redirect`, which indicates a permanent redirection for that resource (this is
    the same as `301`, but does not allow the HTTP method to change).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 3xx范围涉及资源或端点的状态。它指示必须采取哪些额外操作才能完成该请求，因为服务器仍然接受通信，但所联系的端点不是系统中的正确入口点。最常用的代码包括`301
    Moved Permanently`，表示未来的请求必须由不同的URI处理，`302 Found`，表示出于某种原因需要临时重定向，`303 See other`，告诉浏览器查看另一个页面，以及`308
    Permanent Redirect`，表示该资源的永久重定向（与`301`相同，但不允许HTTP方法更改）。
- en: 4xx – client errors
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4xx – 客户端错误
- en: This range of codes is the most well known due to the traditional `404 Not found`
    error, which is a well-known placeholder for URLs that are not properly formed.
    This range of codes indicates that there is something wrong with the request.
    Other well-known codes include `400 Bad Request` (a request that is syntactically
    incorrect), `401 Unauthorized` (lack of authentication from the client), and `403
    Forbidden` (the user does not have privileges). Another common code is `429 Too
    Many Requests`, which is used for rate-limiting requests to indicate that traffic
    from the particular client is rejected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这一范围的代码是最为人熟知的，因为传统的`404 Not found`错误是一个众所周知的占位符，用于表示URL格式不正确。这一范围的代码表示请求存在问题。其他众所周知的代码包括`400
    Bad Request`（语法错误的请求），`401 Unauthorized`（客户端缺乏身份验证），以及`403 Forbidden`（用户没有权限）。另一个常见的代码是`429
    Too Many Requests`，用于限制请求速率，表示特定客户端的流量被拒绝。
- en: 5xx – server errors
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5xx – 服务器错误
- en: This range of codes indicates that there has been a processing error on the
    server or there is something wrong in the server. Whenever a **5xx** code is issued,
    it states that there is some sort of problem in the server that cannot be fixed
    by the client and has to be handled accordingly. Some of the widely used codes
    are `500 Internal Server Error` (this indicates that an error has occurred in
    the server's software and no information is disclosed), `501 Not Implemented` (this
    indicates an endpoint that is not yet implemented, but is still being requested
    for), and `503 Service Unavailable` (this states that the server is down for some
    reason and is not able to process any more requests). On receiving `503`, appropriate
    actions must be taken to start the server again.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码范围表示服务器上发生了处理错误或服务器出现了问题。每当发出**5xx**代码时，它表示服务器出现了某种问题，客户端无法解决，必须相应地处理。一些广泛使用的代码包括`500
    Internal Server Error`（表示服务器软件发生错误，未披露任何信息），`501 Not Implemented`（表示尚未实现的端点，但仍在请求），以及`503
    Service Unavailable`（表示服务器由于某种原因宕机，无法处理更多请求）。收到`503`时，必须采取适当措施重新启动服务器。
- en: Why HTTP code is vital in microservices?
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么HTTP代码在微服务中至关重要？
- en: Microservices are fully distributed and constantly moving. Therefore, without
    any standard means of communication, we won't be able to trigger the corresponding
    fail-safe measure. For instance, if we implement the circuit breaker pattern,
    the circuit should know that whenever it receives the **5xx** series of code,
    it should keep the circuit open as the server is unavailable. Similarly, if it
    received `429`, then it should block the request from that particular client.
    The complete microservice ecosystem includes proxies, caches, RPCs, and other
    services for which HTTP is the common language. Based on the aforementioned code,
    they can take appropriate action accordingly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是完全分布式且不断移动的。因此，如果没有标准的通信手段，我们将无法触发相应的故障转移措施。例如，如果我们实现了断路器模式，断路器应该知道每当它收到**5xx**系列代码时，它应该保持断路器打开，因为服务器不可用。同样，如果它收到`429`，那么它应该阻止来自该特定客户端的请求。完整的微服务生态系统包括代理、缓存、RPC和其他服务，其中HTTP是共同的语言。根据上述代码，它们可以相应地采取适当的行动。
- en: In the next section, we will learn about logging aspects and how to handle logging
    in microservices.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习有关日志记录方面以及如何处理微服务中的日志记录。
- en: Auditing via logs
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过日志审计
- en: 'Until now, we have heard that microservices are distributed and services are
    constantly in flux. We need to keep track of all the services and the output that
    they throw. Using `console.log()` is a very bad practice as we won''t be able
    to keep track of all the services because `console.log()` doesn''t have a fixed
    format. Also, we need a stack trace whenever there is an error to debug the possible
    problem. To have distributed logging, we will use the `winston` module ([https://github.com/winstonjs/winston](https://github.com/winstonjs/winston)).
    It has various options, such as log levels, log formats, and so on. For each microservice,
    we will be passing a unique microservice ID, which will identify it when we aggregate
    the logs. For aggregation, we will use the famous ELK Stack, described in [Chapter
    9](90996850-1ced-4678-a297-3e1fee118eb9.xhtml), *Deployment, Logging, and Monitoring*.
    The following are various kinds of log, sorted in priority order, which are generally
    used:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们听说微服务是分布式的，服务不断变化。我们需要跟踪所有服务和它们产生的输出。使用`console.log()`是一个非常糟糕的做法，因为我们无法跟踪所有服务，因为`console.log()`没有固定的格式。此外，每当出现错误时，我们需要堆栈跟踪来调试可能的问题。为了进行分布式日志记录，我们将使用`winston`模块（[https://github.com/winstonjs/winston](https://github.com/winstonjs/winston)）。它具有各种选项，如日志级别、日志格式等。对于每个微服务，我们将传递一个唯一的微服务ID，这将在我们聚合日志时对其进行标识。对于聚合，我们将使用著名的ELK
    Stack，详见[第9章](90996850-1ced-4678-a297-3e1fee118eb9.xhtml)，*部署、日志记录和监控*。以下是按优先级排序的各种日志类型，通常使用：
- en: '**Fatal/emergency (0)**: This is the most catastrophic level, used when the
    system won''t be able to recover or function normally. This forces things like
    shutdown or some other heinous errors.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严重/紧急（0）：这是最灾难性的级别，当系统无法恢复或正常运行时使用。这会强制执行关机或其他严重错误。
- en: '**Alert (1)**: Upon receiving this severe log, actions must be taken immediately
    to prevent system shutdowns. The critical difference here is that the system is
    still usable.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报（1）：收到这个严重的日志后，必须立即采取行动以防止系统关闭。这里的关键区别在于系统仍然可用。
- en: '**Critical(2)**: Here, action needs not be taken immediately. This level includes 
    situations such as failure to connect to a socket, failure to get the latest chat
    message, and so on.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键（2）：在这里，不需要立即采取行动。此级别包括诸如无法连接到套接字、无法获取最新聊天消息等情况。
- en: '**Error(3)**: This is a problem that should be investigated. The Sys Admin
    has to be notified about it, but we don''t need to drag him out of bed as this
    is not an emergency. It is generally used to track overall quality.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误（3）：这是一个应该调查的问题。系统管理员必须被通知，但我们不需要把他从床上拽起来，因为这不是紧急情况。通常用于跟踪整体质量。
- en: '**Warning(4)**: This level is used when there might be an error or there might
    not be an error. Warning conditions are close to errors but they are not errors.
    They indicate potentially harmful situations or events that might possibly lead
    to an error.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告（4）：当可能存在错误或可能不存在错误时使用此级别。警告条件接近错误，但它们不是错误。它们指示可能有害的情况或事件，可能会导致错误。
- en: '**Notice(5)**: This level is a normal log, but with some significant conditions.
    As an example, you may get messages such as Caught SIGBUS attempting to dump core
    in ....'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知（5）：这个级别是一个正常的日志，但具有一些重要的条件。例如，您可能会收到诸如在...中捕获到SIGBUS尝试转储核心之类的消息。
- en: '**Info(6)**: This level is used for unnoticeable information, such as the server
    has been running for *x* hours and interesting runtime events. These logs are
    immediately visible on the console, as the purpose of these logs is to be conservative.
    These logs should be kept to the minimum.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Info(6)**: 这个级别用于不可察觉的信息，比如服务器已经运行了 *x* 小时和有趣的运行时事件。这些日志立即在控制台上可见，因为这些日志的目的是保守。这些日志应该保持最少。'
- en: '**Debug(7)**: This is used for detailed information on the flow through the
    system. It includes messages used for the sake of debugging, for example, something
    like Opening file... or Getting products for productId 47.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Debug(7)**: 这用于详细了解系统的流程。它包括用于调试的消息，例如，像“打开文件…”或“获取产品的产品ID 47”。'
- en: Logs need to be enabled. If you enable fatal logs, then all logs will be seen.
    If you enable info logs, then only info and debug logs will be seen. Logs for
    all levels have their custom method in Winston and we can add our own format.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 需要启用日志。如果启用了致命日志，那么所有日志都将被看到。如果启用了信息日志，那么只有信息和调试日志会被看到。所有级别的日志都有自己的 Winston
    自定义方法，我们可以添加我们自己的格式。
- en: PM2 process manager
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PM2 进程管理器
- en: Node.js is single threaded, meaning any use of a JavaScript `throw` statement
    will raise an exception that must be handled using the `try...catch` statements.
    Otherwise, the Node.js process will exit immediately, making it unavailable to
    process any further requests. As Node.js runs on single process uncaught exceptions,
    it needs to be handled carefully. If not, it will crash and bring down the whole
    application. So, the golden rule in Node.js is *if any exception bubbles out to
    the top without being handled, our application dies*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是单线程的，这意味着任何对 JavaScript `throw` 语句的使用都会引发一个必须使用 `try...catch` 语句处理的异常。否则，Node.js
    进程将立即退出，导致无法处理任何进一步的请求。由于 Node.js 运行在单进程未捕获异常上，需要小心处理。如果不处理，它将崩溃并导致整个应用程序崩溃。因此，在
    Node.js 中的黄金法则是 *如果任何异常未经处理冒泡到顶部，我们的应用程序就会死掉*。
- en: '**PM2** is a process manager designed to keep our service alive forever. It
    is a production process manager with a built-in load balancer and is the perfect
    candidate for microservices. PM2 comes in quite handy as it allows us to declare
    the behavior of each microservice with a simple JSON format. PM2 is an advanced
    task runner with built-in monitoring and zero downtime utilities. Scaling a PM2
    command is just a matter of typing the number of instances we want to spawn up
    or down. Starting a new process with PM2 will initiate a fork mode of the process
    and let the load balancer handle the rest. PM2 acts as a round robin between the
    main process and the process workers so that we can cope with the extra load at
    the same time. Some of the standard deployment features provided by PM2 are as
    follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**PM2** 是一个旨在永远保持我们服务运行的进程管理器。它是一个带有内置负载均衡器的生产进程管理器，是微服务的完美候选者。PM2 非常方便，因为它允许我们使用简单的
    JSON 格式声明每个微服务的行为。PM2 是一个带有内置监控和零停机工具的高级任务运行器。扩展 PM2 命令只是简单地输入我们想要生成或减少的实例数量。使用
    PM2 启动一个新进程将启动一个进程的分叉模式，并让负载均衡器处理其余部分。PM2 在主进程和进程工作线程之间进行轮询，以便我们可以同时处理额外的负载。PM2
    提供的一些标准部署功能如下：'
- en: '| `pm2 start <process_name>` | Starts a process in fork mode with auto-restart
    when the server goes down |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 start <process_name>` | 以分叉模式启动进程，并在服务器宕机时自动重启 |'
- en: '| `pm2 stop <process_name>` | Stops the PM2 process |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 stop <process_name>` | 停止 PM2 进程 |'
- en: '| `pm2 restart <process_name>` | Restarts a process with updated code |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 restart <process_name>` | 重新启动一个带有更新代码的进程 |'
- en: '| `pm2 reload <process_name>` | Reloads PM2 process with zero downtime |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 reload <process_name>` | 重新加载 PM2 进程，零停机时间 |'
- en: '| `pm2 start <process_name> -i max` | Starts a PM2 process in the max number
    of fork modes; that is, it will spawn the max number of instances based on the
    number of CPUs available |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 start <process_name> -i max` | 以最大分叉模式启动一个 PM2 进程；也就是说，它将根据可用的 CPU 数量生成最大数量的实例
    |'
- en: '| `pm2 monit` | Monitors a PM2 process |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 monit` | 监控一个 PM2 进程 |'
- en: '| `pm2 start ecosystem.config.js --env staging` | Starts a process, taking
    configurations from `ecosystem.config.js` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 start ecosystem.config.js --env staging` | 启动一个进程，使用 `ecosystem.config.js`
    中的配置 |'
- en: 'PM2 can also be used as a deployment tool or an advanced means for CI/CD. All
    you need to do is define your deployment script in the `ecosystem.config.js` file,
    as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: PM2 也可以用作部署工具或高级的 CI/CD 手段。你只需要在 `ecosystem.config.js` 文件中定义你的部署脚本，如下所示：
- en: '[PRE1]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, all we have to do is hit the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要输入以下命令：
- en: '[PRE2]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command acts as a local deployment tool. Adding things such as path, PEM
    file key, and so on are steps where we can connect to the server. Once connected
    to the server using the specified user, the PM2 process starts and we can run
    our application. The latest Git repository will be cloned and then PM2 will start
    the `dist/Index.js` file in the forever option.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令作为一个本地部署工具。添加路径、PEM 文件密钥等步骤是我们可以连接到服务器的步骤。一旦使用指定用户连接到服务器，PM2 进程就会启动，我们可以运行我们的应用程序。最新的
    Git 存储库将被克隆，然后 PM2 将在 forever 选项中启动 `dist/Index.js` 文件。
- en: Tracing requests
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追踪请求
- en: '**Tracing request** origins is very important, as sometimes we need to reconstruct
    the entire journey of the customer in our system. It provides useful information
    on the system, such as sources of latency. It also enables developers to observe
    how an individual request is being handled by searching across all aggregated
    logs with some unique microservice ID, or to find out the overall journey of the
    user by passing in a time frame. The following is a sample log generated through
    Winston:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪请求的来源非常重要，因为有时我们需要重构客户在我们系统中的整个旅程。它提供了有关系统的有用信息，例如延迟的来源。它还使开发人员能够观察如何通过搜索所有聚合日志来处理单个请求，使用一些唯一的微服务
    ID，或者通过传递时间范围来找出用户的整个旅程。以下是通过 Winston 生成的示例日志：
- en: '[PRE3]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All important data can be seen from the log. We will be using the ELK Stack
    for our log. ELK has huge advantages, as it combines the power of the following
    three tools—**Logstash** (configured to read logs or register events from a myriad
    of sources and send log events to multiple sources), **Kibana** (a configurable
    web dashboard that is used to query Elasticsearch for log information and present
    it to the user), and **Elasticsearch** (a search server based on Lucene, used
    to collect logs, parse them, and store them for later purposes, providing a RESTful
    service and schema-free JSON documents). It has the following advantages:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所有重要数据都可以从日志中看到。我们将使用ELK Stack进行日志记录。ELK具有巨大的优势，因为它结合了以下三个工具的功能——**Logstash**（配置为从各种来源读取日志或注册事件并将日志事件发送到多个来源）、**Kibana**（可配置的Web仪表板，用于查询Elasticsearch的日志信息并呈现给用户）和**Elasticsearch**（基于Lucene的搜索服务器，用于收集日志、解析日志并将其存储以供以后使用，提供RESTful服务和无模式的JSON文档）。它具有以下优势：
- en: Each instance of **Winston** is configured with ELK. Thus, our log service is
    externalized and the storing of our logs is centralized. Hence, there is a single
    data source where requests can be traced.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个**Winston**实例都配置了ELK。因此，我们的日志服务是外部化的，日志的存储是集中的。因此，有一个单一的数据源可以追踪请求。
- en: Due to the auto-schema definition and proper format of Winston, we have log-structured
    data. For example, if I want to query all the logs from `4:40` to `4.43`, I am
    just an Elasticsearch query away as I know that all my logs have a time component
    at a fixed level in JSON.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Winston的自动模式定义和正确格式，我们拥有日志结构化数据。例如，如果我想查询从`4:40`到`4.43`的所有日志，我只需通过Elasticsearch查询，因为我知道我的所有日志在JSON中的固定级别上都有时间组件。
- en: Winston log formats take care of creating and passing a correlational identifier
    across all the requests. Therefore, server-specific logs, if required, can be
    traced easily by querying that specific parameter.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Winston日志格式负责创建和传递跨所有请求的相关标识符。因此，如果需要，可以通过查询特定参数轻松追踪特定服务器的日志。
- en: Our logs are searchable through Elasticsearch. Elasticsearch provides Kibana
    as well as REST APIs, which can be called upon to look at any point in time through
    all the data in the data source. A lucene-based implementation helps to fetch
    results faster.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过Elasticsearch搜索我们的日志。Elasticsearch提供Kibana以及REST API，可以随时调用以查看数据源中的所有数据。基于Lucene的实现有助于更快地获取结果。
- en: The logging level can be changed on the fly in Winston. We can have various
    log levels and based on the priority of logs, the lower level of logs may or may
    not be seen. This is pretty helpful in solving production-level issues.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Winston中的日志级别可以在运行时更改。我们可以有各种日志级别，并根据日志的优先级，可能会或可能不会看到较低级别的日志。这在解决生产级别的问题时非常有帮助。
- en: In this section, we looked at logging and how it solves such problems as understanding
    customer behavior (how much time a customer spends on the page, how much time
    an action on each page took, what are some of the possible problems, and so on).
    In the next section, we will start developing shopping cart microservices.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看了日志记录以及它如何解决了解客户行为（客户在页面上花费多少时间，每个页面上的操作花费多少时间，可能存在的一些问题等）等问题。在下一节中，我们将开始开发购物车微服务。
- en: Developing some microservices for a shopping cart
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为购物车开发一些微服务
- en: 'In this section, we will develop some microservices for a shopping cart, uniquely
    identified by their business capabilities. So, let''s get a quick overview of
    our current problems before getting our hands dirty. The shopping cart monolithic
    was going well, but with the advent of digitalization, there was a huge increase
    in transaction volumes—300-500 times compared the original estimates. The end
    to end architecture was reviewed and it had the following limitations, based on
    which the microservice architecture was introduced:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为购物车开发一些微服务，这些微服务以其业务能力而独特标识。因此，在动手之前，让我们快速概述一下我们当前的问题。购物车单体应用程序进展顺利，但随着数字化的出现，交易量大幅增加——比原始估计增加了300-500倍。端到端架构经过审查，发现了以下限制，基于这些限制引入了微服务架构：
- en: '**Firmness and sturdiness**: The firmness of the system was greatly impacted
    due to errors and stuck threads, which forced the Node.js application server to
    not accept any new transactions and do a forceful restart. Memory allocation issues
    and database lock threads were major problems. Certain resource-intensive operations
    were impacting the entire application and the resource allocation pool was always
    consumed.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坚固性和稳固性**：由于错误和线程阻塞，系统的坚固性受到了很大的影响，这迫使Node.js应用服务器不接受任何新的事务并进行强制重启。内存分配问题和数据库锁线程是主要问题。某些资源密集型操作影响整个应用程序，资源分配池总是被消耗。'
- en: '**Deployment outages**: Due to adding more and more capabilities, the server
    outage window increased largely because of the server startup time. The large
    size of `node_modules` turned out to be the primary culprit. Since the entire
    application was packaged as a monolith, the entire application demanded to install
    the `node` modules again and again and then start our node-HTTP server.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署中断**：由于添加了越来越多的功能，服务器中断窗口大大增加，因为服务器启动时间增加。由于`node_modules`的大小，导致了这个问题。由于整个应用程序被打包为单体应用，整个应用程序需要一遍又一遍地安装`node`模块，然后启动我们的node-HTTP服务器。'
- en: '**Sharpness**: The complexity of code increased exponentially over time and
    so did the distribution of work. A tight coupling dependency was created among
    the teams. As a result, changes were harder to implement and deploy. Impact analysis
    became too complex to perform. As a result, it was like *fix one bug, 13 others
    come up*. Such complexity rose to a situation where the `node_modules` size was
    over 1 GB. Such complications eventually stopped **continuous integration** (**CI**)
    and unit test casing. Eventually, the quality of the product deteriorated.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锐度**：随着时间的推移，代码的复杂性呈指数增长，工作的分布也是如此。团队之间形成了紧密的耦合依赖关系。因此，实施和部署变得更加困难。影响分析变得过于复杂。结果就是，修复一个bug，就会出现13个其他bug。这样的复杂性导致`node_modules`的大小超过1GB。这样的复杂性最终停止了**持续集成**（**CI**）和单元测试。最终，产品的质量下降了。'
- en: Such situations and problems demanded an evolutionary approach. Such situations
    demanded a microservices development approach. In this section, we will look at
    the microservice setup approach, which will give us various advantages, such as
    selective service scaling, technological independence (easy migration to new technologies),
    containing faults, and so on.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的情况和问题需要一种进化的方法。这样的情况需要一种微服务开发方法。在这一部分，我们将看到微服务设置方法，这将给我们带来各种优势，比如选择性服务扩展、技术独立性（易于迁移到新技术）、容错等等。
- en: Itinerary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行程
- en: 'Let''s quickly go through the itinerary that we are going to perform in this
    exercise:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下我们将在本次练习中执行的行程：
- en: '**Development setup and prerequisite modules**: In this section, we will summarize
    the development tools and `npm` modules that we will use in the project. We will
    look at such prerequisites as application properties, custom middleware, dependency
    injection, and so on.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发设置和先决模块**：在这一部分，我们将总结项目中将使用的开发工具和`npm`模块。我们将关注应用程序属性、自定义中间件、依赖注入等先决条件。'
- en: '**Application directory configurations**: We will analyze the structure that
    we will use in other microservices and understand all the files that we will need
    and where to write the logic.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序目录配置**：我们将分析我们将在其他微服务中使用的结构，并了解我们将需要的所有文件以及在哪里编写逻辑。'
- en: '**Configuration files**: We will have a look at all the configuration files
    through which we can specify various settings, such as database hostname, port
    URL, and so on.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：我们将查看所有配置文件，通过这些文件我们可以指定各种设置，比如数据库主机名、端口URL等等。'
- en: '**Processing data**: We will briefly summarize code patterns and how they can
    support optimal developer output and make the developer''s life easier.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理数据**：我们将简要总结代码模式以及它们如何支持最佳开发者产出，并使开发者的生活更轻松。'
- en: '**Ready to serve**: We will analyze `package.json` and Docker files and see
    how we can use these two files to make our microservice ready to serve any service
    requests.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备服务**：我们将分析`package.json`和Docker文件，并看看如何使用这两个文件使我们的微服务准备好为任何服务请求提供服务。'
- en: So, let's get started with our itinerary.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始我们的行程。
- en: Development setup and prerequisite modules
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发设置和先决模块
- en: In this section, we will look at several aspects that we need to take care of
    while developing and creating our **Development Sandbox.** We will get an overview
    of all the node modules that we will use and the core aspects that each `node`
    module will satisfy. So, it's time to get our hands dirty.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到在开发和创建我们的**开发沙盒**时需要注意的几个方面。我们将概述将使用的所有node模块以及每个`node`模块将满足的核心方面。所以，现在是动手的时候了。
- en: 'Note: We saw how to write custom types in [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing
    up for the Journey*, for any node module that is not written in ES6\. We will
    leverage this for any module whose types are not available in the `DefinitelyTyped`
    repository.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们在[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)中看到了如何为任何不是用ES6编写的node模块编写自定义类型，为任何在`DefinitelyTyped`存储库中没有可用类型的模块利用这一点。
- en: Repository pattern
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储库模式
- en: In this section, we will understand the repository pattern, which gives us the
    power to have our code in a single place. TypeScript introduced generics (just
    like the feature in Java), which we are going to utilize to the full extent in
    our microservices. The repository pattern is one of the most widely used patterns
    to create an enterprise-level application. It enables us to directly work with
    data in the application by creating a new layer for database operations and business
    logic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将了解存储库模式，它赋予我们将代码放在一个地方的能力。TypeScript引入了泛型（就像Java中的特性），我们将充分利用这一点在我们的微服务中。存储库模式是创建企业级应用程序最广泛使用的模式之一。它使我们能够通过为数据库操作和业务逻辑创建一个新层直接在应用程序中处理数据。
- en: Combining generics and the repository pattern opens up countless advantages.
    Working with the JavaScript application, we need to deal with problems such as
    code sharing between applications and going modular. The generic repository pattern
    solves this by giving us the power to write an abstraction of data when we have
    one abstract class with generics (or many depending on the business capability)
    and reuse the implementation layer independent of the data model, passing only
    the types to someone's classes. When we talk about the repository pattern, it
    is a repository where we can keep all the operations of the database (CRUD) in
    one locality for any generic business entity. When you need to do the operation
    in the database, your application calls the repository methods, thus enabling
    transparency for whoever calls. Combining this with generics leads to one abstraction,
    one base class that has all the common methods. Our `EntityRepository` only extends
    the base class with all the implementations of the database operations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 结合泛型和存储库模式，可以带来无数的优势。在处理JavaScript应用程序时，我们需要解决诸如应用程序之间的代码共享和模块化等问题。泛型存储库模式通过在具有泛型的抽象类（或根据业务能力的多个抽象类）中给我们写入数据的抽象来解决这个问题，并且可以独立于数据模型重用实现层，只需将类型传递给某些类。当我们谈论存储库模式时，它是一个存储库，我们可以将数据库的所有操作（CRUD）集中在一个地方，适用于任何通用业务实体。当您需要在数据库中执行操作时，您的应用程序调用存储库方法，从而使调用者能够透明地进行调用。将这与泛型结合使用会导致一个抽象，一个具有所有常用方法的基类。我们的`EntityRepository`只扩展了具有所有数据库操作实现的基类。
- en: This pattern follows the open/closed principle, where the base class is open
    for extension but closed for modification.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式遵循开闭原则，其中基类对扩展开放但对修改关闭。
- en: 'It has various advantages, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它有各种优势，如下：
- en: It can be used as an extensibility measure where you just need to write one
    class for all common operations, such as CRUDs, when all other entities should
    have similar operations
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用作可扩展性措施，您只需为所有常见操作编写一个类，例如CRUD，当所有其他实体应具有类似操作时
- en: Business logic can be unit tested without touching the data access logic
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑可以在不触及数据访问逻辑的情况下进行单元测试
- en: The database layer can be reused
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库层可以被重用
- en: Database access code is centrally managed in order to implement any database
    access policies and, like caching, it is a walk in the park
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库访问代码是集中管理的，以实施任何数据库访问策略，就像缓存一样简单
- en: Configuring application properties
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序属性
- en: As per the twelve-factor standards (recall the, *Twelve-factor app of microservices*, section
    in [Chapter 1](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml), *Debunking Microservices*),
    one code base should suffice for multiple environments, such as QA, dev, production,
    and so on. Ensure that we have the application properties file in our application,
    where we can specify the environment name and environment-related stuff. Config
    ([https://www.npmjs.com/package/config](https://www.npmjs.com/package/config))
    is one such module, which helps you in organizing all configurations. This module
    just reads configurations files in the `./config` directory (it should be at the
    same level as `package.json`).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 根据十二要素标准（回想一下，*微服务的十二要素应用程序*，[第1章](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml)中的*揭秘微服务*），一个代码库应该适用于多个环境，如QA、开发、生产等。确保我们在应用程序中有应用程序属性文件，在其中可以指定环境名称和与环境相关的内容。Config（[https://www.npmjs.com/package/config](https://www.npmjs.com/package/config)）就是这样一个模块，它可以帮助您组织所有配置。此模块只需读取`./config`目录中的配置文件（它应该与`package.json`处于同一级别）。
- en: 'Salient features of config are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的显着特点如下：
- en: It can support formats such as YAML, YML, JSON, CSV, XML.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以支持YAML、YML、JSON、CSV、XML等格式。
- en: It can create one directory config parallel to `package.json` and inside it
    create one file, `default.ext` (here, `.ext` can be any of the aforementioned
    formats).
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以创建一个与`package.json`并行的config目录，并在其中创建一个文件`default.ext`（这里，`.ext`可以是前述格式之一）。
- en: 'To read from config files, just use the following lines of code:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从配置文件中读取，只需使用以下代码行：
- en: '[PRE4]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It has support for various config files, where a hierarchy is maintained for
    supporting various environments.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持各种配置文件，维护层次结构以支持各种环境。
- en: It even has support for multiple node instances; the perfect fit for microservices.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它甚至支持多个节点实例；非常适合微服务。
- en: Custom health module
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义健康模块
- en: Sometimes, adding new modules to the application causes the application to go
    out of order. We need custom health modules to actually keep watch on the service
    and alert us that the service is out of order (service discovery does exactly
    this, which we will look at in [Chapter 6](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml),
    *Service Registry and Discovery*). We will be using `express-ping` ([https://www.npmjs.com/package/express-ping](https://www.npmjs.com/package/express-ping))
    to find out the health of our node. By introducing this module in our middleware,
    we can expose a simple API that will tell us about its internal health to both
    operators and other applications.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，向应用程序添加新模块会导致应用程序失序。我们需要自定义健康模块来实际监视服务并警告我们服务失序（服务发现正是这样做的，我们将在[第6章](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml)中看到，*服务注册表和发现*）。我们将使用`express-ping`（[https://www.npmjs.com/package/express-ping](https://www.npmjs.com/package/express-ping)）来查看我们节点的健康状况。通过在我们的中间件中引入此模块，我们可以公开一个简单的API，告诉操作员和其他应用程序有关其内部健康状况的信息。
- en: 'Salient features of `express-ping` are as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`express-ping`的显着特点如下：'
- en: It is a zero configuration module, where just injecting this in the middleware
    will expose a health endpoint.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个零配置模块，只需将其注入中间件即可公开一个健康端点。
- en: 'To use this module, simply use the following lines of code:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用此模块，只需使用以下代码行：
- en: '[PRE5]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding just the previous LOCs will expose a `<url>/health` endpoint that we
    can use for health check purposes.We can add authorized access or even use middleware
    for our exposed `/ping` API, which is just plain old express:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅添加先前的LOCs将公开一个`<url>/health`端点，我们可以用于健康检查目的。我们可以添加授权访问，甚至使用中间件来使用我们公开的`/ping`
    API，这只是普通的express：
- en: '[PRE6]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This endpoint can be used anywhere just to check the health of the application.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此端点可用于任何地方，只需检查应用程序的健康状况。
- en: Dependency injection and inversion of control
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入和控制反转
- en: In this section, we will see how to use basic principles such as dependency
    injection and inversion of control. Coming from a Java background, I tend to use
    these principles in any application in order to make my development process smoother.
    Luckily, we have the exact modules matching our requirements. We will use `inversify`
    ([https://www.npmjs.com/package/inversify](https://www.npmjs.com/package/inversify))
    as the inversion of control container and `typedi` ([https://www.npmjs.com/package/typedi](https://www.npmjs.com/package/typedi))
    for dependency injection.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用基本原则，如依赖注入和控制反转。来自Java背景，我倾向于在任何应用程序中使用这些原则，以使我的开发过程更加顺畅。幸运的是，我们有与我们的要求完全匹配的模块。我们将使用`inversify`（[https://www.npmjs.com/package/inversify](https://www.npmjs.com/package/inversify)）作为控制反转容器，`typedi`（[https://www.npmjs.com/package/typedi](https://www.npmjs.com/package/typedi)）用于依赖注入。
- en: Inversify
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Inversify
- en: '**Inversion of control** (**IOC**) is about getting freedom, more flexibility,
    and less dependency on others. Say you are using a desktop computer, you are enslaved
    (or let''s say controlled). You have to sit before a screen and look at it, using
    the keyboard to type and mouse to navigate. Badly written software can enslave
    you similarly. If you replace your desktop with a laptop, then you have inverted
    control. You can easily take it and move around. So, now you can control where
    you are with your computer rather than the computer controlling it. IOC in software
    is very similar. Traditionally speaking, IOC is a design principle in which custom-written
    portions of the computer program receive the flow of control from a generic framework.We
    have `inversifyJS` available as an `npm` module. As per their official docs:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制反转**（**IOC**）是关于获得自由、更灵活，减少对他人的依赖。比如你正在使用一台台式电脑，你是被奴役的（或者说受控制）。你必须坐在屏幕前，使用键盘输入和鼠标导航。糟糕的软件也会让你类似地被奴役。如果你用笔记本电脑替换台式电脑，那么你就实现了控制反转。你可以轻松携带它并四处移动。所以，现在你可以控制你的电脑在哪里，而不是电脑控制它。软件中的IOC非常类似。传统上来说，IOC是一个设计原则，根据这个原则，计算机程序的自定义部分从一个通用框架中接收控制流。我们有`inversifyJS`作为`npm`模块可用。根据官方文档：'
- en: <q>*InversifyJS is a lightweight inversion of control container for TypeScript
    and JavaScript applications. An IOC container will use a class constructor to
    identify and inject its dependencies. It has a friendly API and encourages the
    usage of best OOP and IoC practices adhering to SOLID principles.*</q>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*InversifyJS是一种轻量级的TypeScript和JavaScript应用程序的控制反转容器。IOC容器将使用类构造函数来识别和注入其依赖项。它具有友好的API，并鼓励使用最佳的面向对象编程和IoC实践，遵循SOLID原则。*'
- en: Typedi
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Typedi
- en: Dependency injection is a means by which classes, components, and services specify
    which libraries they depend on. By simply injecting dependencies into a microservice,
    the service is empowered with the ability to reference dependencies directly,
    rather than looking them up in a service registry or using a service locator.
    The power to encapsulate any service, discover it, and distribute load is an extremely
    valuable addition to microservices. **Typedi** is a dependency injection tool
    for JavaScript and TypeScript. Using Typedi is very easy. All you do is create
    a container and start using dependency injection principles on that container.
    Typedi provides various annotations, such as `@Service`, `@Inject`, and more.
    You can even create your own custom decorators.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种类、组件和服务指定其依赖库的方式。通过简单地将依赖项注入到微服务中，服务就能够直接引用依赖项，而不是在服务注册表中查找它们或使用服务定位器。封装任何服务、发现它并分发负载的能力对于微服务来说是一个非常有价值的补充。**Typedi**是JavaScript和TypeScript的依赖注入工具。使用Typedi非常容易。你所要做的就是创建一个容器，并开始在该容器上使用依赖注入原则。Typedi提供各种注解，如`@Service`、`@Inject`等。你甚至可以创建自己的自定义装饰器。
- en: TypeORM
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeORM
- en: 'Inspired by frameworks such as hibernate and doctrine, the Entity Framework **TypeORM**
    ([https://www.npmjs.com/package/typeorm](https://www.npmjs.com/package/typeorm))
    is an ORM framework supporting active record and data mapper patterns, unlike
    all other JavaScript ORMs. This enables us to write high quality, loosely coupled,
    scalable, and maintainable applications in the most productive way ever. It has
    the following advantages:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 受hibernate和doctrine等框架的启发，Entity Framework **TypeORM**（[https://www.npmjs.com/package/typeorm](https://www.npmjs.com/package/typeorm)）是一个支持活动记录和数据映射器模式的ORM框架，不同于所有其他JavaScript
    ORM。这使我们能够以最高效的方式编写高质量、松散耦合、可扩展和可维护的应用程序。它具有以下优势：
- en: Uses multiple database connections
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个数据库连接
- en: Works with multiple database types
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于多种数据库类型
- en: Query caching
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询缓存
- en: Hooks, such as subscribers and listeners
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子，如订阅者和监听器
- en: Written in TypeScript
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用TypeScript编写
- en: Supports both the Data Mapper and Active Record patterns
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持数据映射器和活动记录模式
- en: Replication
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制
- en: Connection pooling
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接池
- en: Streaming raw results (reactive programming)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式原始结果（响应式编程）
- en: Eager and lazy relations
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 急切和懒惰的关系
- en: Supports SQL as well as NoSQL databases
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持SQL和NoSQL数据库
- en: Application directory configurations
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序目录配置
- en: 'The directory structure of this application focuses on our architectural approach
    based on separation of concerns. Each folder structure will have files specifically
    pertaining to the name of the folder. In the following screenshot, you can see
    the overall structure and detailed structure:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的目录结构侧重于基于关注点分离的架构方法。每个文件夹结构将具有专门与文件夹名称相关的文件。在下面的截图中，您可以看到整体结构和详细结构：
- en: '![](img/2795b24c-b3ae-493a-811d-b583cab39c49.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2795b24c-b3ae-493a-811d-b583cab39c49.png)'
- en: Configuration structure
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 配置结构
- en: In the preceding screenshot, you can see two folder structures. The first one
    is the high-level and overall folder structure highlighting important folders,
    whereas the second one is a detailed expanded view of the `src` folder. The folder
    structure follows the *separation of concerns* approach to eliminate code duplication
    and share singleton services between controllers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可以看到两个文件夹结构。第一个是高级和整体的文件夹结构，突出显示重要的文件夹，而第二个是`src`文件夹的详细扩展视图。文件夹结构遵循*关注点分离*的方法，以消除代码重复并在控制器之间共享单例服务。
- en: In computer science, **separation of concerns** (**SoC**) is a design principle
    for dividing a computer program into distinct sections or capabilities so that
    each section addresses a separate concern and is independent of the other. A concern
    is a set of information that affects the code of any application.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，**关注点分离**（**SoC**）是将计算机程序分成不同的部分或功能的设计原则，以便每个部分都处理一个单独的关注点，并且独立于其他部分。关注点是影响任何应用程序代码的一组信息。
- en: Let's understand our folder structure and the files it contains, and what concern
    the folder actually addresses.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们的文件夹结构及其包含的文件，以及该文件夹实际上解决的问题。
- en: src/data-layer
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: src/data-layer
- en: 'This folder is responsible for the overall organization of the data, its storage,
    and accessibility methods. Model definitions and iridium files can be found here.
    It has the following folders:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹负责数据的整体组织、存储和访问方法。模型定义和iridium文件可以在这里找到。它包括以下文件夹：
- en: '**Adapters**: This implements the setup of MongoDB connection methods for connecting
    to the MongoDB database and adding events on connected, error, open, disconnected,
    reconnected, and forced exit methods'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**：这实现了连接到MongoDB数据库的连接方法，并在连接、错误、打开、断开连接、重新连接和强制退出方法上添加事件'
- en: '**Data-abstracts**: This has both the schemas representing the structure of
    each MongoDB collection and the documents representing each set of data in the
    collection'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据抽象**：这里有表示每个MongoDB集合结构的模式和表示集合中每组数据的文档'
- en: '**Data-agents**: This has the query transactions against the data store for
    each MongoDB collection'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据代理**：这里有针对每个MongoDB集合的数据存储的查询事务'
- en: '**Model**: This has a TypeScript class representation of the data portrayed
    by the MongoDB document'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这里有一个由MongoDB文档描述的数据的TypeScript类表示'
- en: src/business-layer
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: src/business-layer
- en: 'This folder has the implementation of business logic and other resources that
    are needed by the service layer or the middleware layer, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹包含了服务层或中间件层所需的业务逻辑和其他资源的实现，如下所示：
- en: '**Security**: If we want some security or tokens at a particular microservice
    level, this is where we will add our authentication logic (generally, we don''t
    write the authentication layer at the individual service level). Rather, we write
    it at the API Gateway level, which we will see in [Chapter 5](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml), *Understanding
    API Gateway*. Here, we will write code for the service registration/deregistration,
    verification, internal security, microservices communicating with the service
    registry, the API Gateway, and so on.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：如果我们想在特定的微服务级别上添加一些安全性或令牌，这就是我们将添加我们的身份验证逻辑的地方（通常，我们不会在单个服务级别编写身份验证层）。相反，我们会在API网关级别编写它，我们将在[第5章](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml)中看到，*理解API网关*。在这里，我们将编写用于服务注册/注销、验证、内部安全、微服务与服务注册表、API网关等通信的代码。'
- en: '**Validators**: This will have schema and processing logic for validating data
    sent with API requests. We will write our class-validator ([https://www.npmjs.com/package/class-validator](https://www.npmjs.com/package/class-validator))
    schema here, together with some custom validation functions.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证器**：这里将包含用于验证API请求发送的数据的模式和处理逻辑。我们将在这里编写我们的class-validator ([https://www.npmjs.com/package/class-validator](https://www.npmjs.com/package/class-validator))
    模式，以及一些自定义验证函数。'
- en: src/service-layer
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: src/service-layer
- en: 'This folder includes the processes for establishing API endpoints in the form
    of routes, which will handle all responses to data requests. It has the following
    folders:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹包括建立API端点的过程，以路由的形式处理所有数据请求的响应。它包括以下文件夹：
- en: '`controllers`: This serves as a primer for processing any data requests associated
    with routes. The custom `controllers` are featured by `npm` module `routing-controllers`
    ([https://www.npmjs.com/package/routing-controllers](https://www.npmjs.com/package/routing-controllers))
    using in-built decorators, such as `@Get`, `@Put`, `@Delete`, `@Param`, and so
    on. These functions implement basic GET, POST, DELETE, and PUT methods for transacting
    with the database via the RESTful API. We can even have socket initialization
    code and more. We will use dependency injection to inject some services which
    will be used here.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`控制器`：这用作处理与路由相关的任何数据请求的基础。自定义`控制器`由`npm`模块`routing-controllers`（[https://www.npmjs.com/package/routing-controllers](https://www.npmjs.com/package/routing-controllers)）提供，使用内置装饰器，如`@Get`、`@Put`、`@Delete`、`@Param`等。这些函数实现了基本的GET、POST、DELETE和PUT方法，用于通过RESTful
    API与数据库进行交互。我们甚至可以有套接字初始化代码等。我们将使用依赖注入来注入一些服务，这些服务将在这里使用。'
- en: '`request`: This has TypeScript interfaces defining and showing the attributes
    that constitute each of the different kinds of request in the controller.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`请求`：这里有TypeScript接口定义和展示控制器中每种不同请求类型的属性。'
- en: '`response`: This has TypeScript interfaces defining and showing the attributes
    that constitute each of the different kinds of response in the controller.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`响应`：这里有TypeScript接口定义和展示控制器中每种不同响应类型的属性。'
- en: src/middleware
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: src/middleware
- en: 'This contains resources that have any server configuration, as well as a certain
    place to store any utility processes that can be shared across any application.
    We can have centralized configurations, such `aslogger`, `cache`, `elk`, and so
    on:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了任何服务器配置的资源，以及一个可以在整个应用程序中共享的某些实用程序过程的存储位置。我们可以有集中的配置，比如`logger`、`cache`、`elk`等等：
- en: '`common`: This has an instantiation of the logger module, which can be shared
    across the entire application. This module is based on `winston` ([https://www.npmjs.com/package/winston](https://www.npmjs.com/package/winston)).'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common`：这里有一个日志记录模块的实例化，可以在整个应用程序中共享。这个模块基于`winston` ([https://www.npmjs.com/package/winston](https://www.npmjs.com/package/winston))。'
- en: '`config`: This has vendor-specific implementations. We will have express configuration
    and express middleware defined here, as well as all the important configurations
    for organizing the REST API endpoints.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：这里有特定于供应商的实现。我们将在这里定义express配置和express中间件，以及组织REST API端点的所有重要配置。'
- en: '`custom-middleware`: This folder will have all our custom-written middleware,
    which we can utilize in any controller class or any particular method.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`custom-middleware`：这个文件夹将包含我们所有自定义的中间件，我们可以在任何控制器类或任何特定方法中使用它们。'
- en: In the next section, we will look at some of the configuration files that configure
    and define the application and determine how it will run. For example, the port
    on which it will run, the  port the database is connected to, the modules installed,
    the transpilation configuration, and so on.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看一些配置文件，这些文件配置和定义了应用程序，并确定它将如何运行。例如，它将运行在哪个端口，数据库连接到哪个端口，安装了哪些模块，编译配置等等。
- en: Configuration files
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: 'Let''s look at some of the configuration files that we will use throughout
    the project, and use them to govern the project in different environments or as
    per the use case:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些我们将在整个项目中使用的配置文件，并使用它们来管理不同环境下的项目或根据用例：
- en: '**`default.json`**: Node.js has an excellent module, `node-config`. You can
    find the `config` file in the `config` folder parallel to `package.json`. Here,
    you can have multiple configuration files that can be picked up based on environments.
    For example, `default.json` would be loaded first, followed by `{deployment}.json`,
    and so on. Here is a sample file:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`default.json`**：Node.js有一个很棒的模块，`node-config`。你可以在`package.json`旁边的`config`文件夹中找到`config`文件。在这里，你可以有多个配置文件，可以根据环境进行选择。例如，首先加载`default.json`，然后是`{deployment}.json`，依此类推。以下是一个示例文件：'
- en: '[PRE7]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**`src/Index.ts`**:This initializes our application, by making a new object
    of the application defined in the `middleware`/`config`/`application`. It imports
    reflected metadata that initializes our dependency injection container.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`src/Index.ts`**：这将通过创建一个在`middleware`/`config`/`application`中定义的应用程序的新对象来初始化我们的应用程序。它导入了反射元数据，初始化了我们的依赖注入容器。'
- en: '**`package.json`**: This serves as the manifest file in all of the Node.js
    application. It delineates the external libraries required for building the application
    in two sections, `dependencies` and `devDependencies`.  This provides a `scripts` tag
    that has external commands for building, running, and packaging the module.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`package.json`**：这在所有Node.js应用程序中作为清单文件。它将外部库分为两个部分，`dependencies`和`devDependencies`。这提供了一个`scripts`标签，其中包含用于构建、运行和打包模块的外部命令。'
- en: '`tsconfig.json`: This provides options for TypeScript when it performs the
    task of transpiling to JavaScript. For example, if we have `sourceMaps:true`,
    we will be able to debug TypeScript code via generated sourcemaps.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsconfig.json`：这为TypeScript提供了选项，当它执行转换为JavaScript的任务时。例如，如果我们有`sourceMaps:true`，我们将能够通过生成的sourcemaps调试TypeScript代码。'
- en: '`src/data-layer/adapters/MongoAccess.ts`: This will have a connection to the
    MongoDB database and various event handlers attached to various events of MongoDB,
    such as `open`, `connected`, `error`, `disconnected`, `reconnected`, and so on:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/data-layer/adapters/MongoAccess.ts`：这将连接到MongoDB数据库，并附加到MongoDB的各种事件的各种事件处理程序，比如`open`、`connected`、`error`、`disconnected`、`reconnected`等等：'
- en: '[PRE8]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`src/middleware/config/Express.ts`:This is where our express middleware resides.
    We will attach standard configurations, such as `helmet`, `bodyparser`, `cookieparser`,
    `cors origin`, and so on, and set up our `controllers` folder with the following:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/middleware/config/Express.ts`：这是我们的express中间件所在的地方。我们将附加标准配置，比如`helmet`、`bodyparser`、`cookieparser`、`cors
    origin`等等，并设置我们的`controllers`文件夹如下：'
- en: '[PRE9]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Processing data
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据
- en: 'As with most web servers that accept and process requests from clients, we
    have a very similar thing here. We just have granularized things at a macro level.
    The overall flow of the process is shown in the following diagram:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数接受并处理来自客户端的请求的Web服务器一样，我们在这里有一个非常相似的东西。我们只是在宏观层面上将事物细分。整个流程的概述如下图所示：
- en: '![](img/3cece010-b02d-4e55-916e-51149307de81.png)Processing data'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/3cece010-b02d-4e55-916e-51149307de81.png)处理数据'
- en: 'Let''s understand the process by taking any of the sample endpoints through
    each of the sections in the preceding diagram. You can find the whole sample in
    `chapter-4/products-catalog service`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将任何示例端点通过前面图表中的每个部分来理解该过程。你可以在`chapter-4/products-catalog service`中找到整个示例：
- en: 'An API request to put a specific product based on the attributes of the product
    is sent to the server, `http://localhost:8081/products/add-update-product`:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向服务器发送一个基于产品属性的特定产品的API请求，`http://localhost:8081/products/add-update-product`：
- en: '[PRE10]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The registered controllers with the `/products` path capture the request based
    on the `URI /products/`.  If a middleware is registered in `Express.ts`, it will
    get triggered first; otherwise, the controller method gets called. Registering
    a middleware is simple. Create a middleware class with the following code:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`/products`路径注册的控制器捕获基于`URI /products/`的请求。如果在`Express.ts`中注册了中间件，它将首先被触发；否则，将调用控制器方法。注册中间件很简单。创建一个中间件类，其中包含以下代码：
- en: '[PRE11]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To use this middleware in any controller, just make use of the `@UseBefore`
    and `@UseAfter` decorators on top of any method/controller.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在任何控制器中使用此中间件，只需在任何方法/控制器的顶部使用`@UseBefore`和`@UseAfter`装饰器。
- en: Since we want to execute some core logic (such as picking the response from
    the cache or logging), the `middleware` function gets executed first. This resides
    in `middleware/custom-middleware/MyMiddleWare.ts`. Using the `async` capabilities
    of Node.js, the method will do what is necessary and then proceed on to the next
    request with `next()`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想执行一些核心逻辑（例如从缓存中选择响应或记录），因此`middleware`函数首先执行。这位于`middleware/custom-middleware/MyMiddleWare.ts`中。使用Node.js的`async`功能，该方法将执行必要的操作，然后继续进行下一个请求，使用`next()`。
- en: In the custom middleware, we can have various checks; for example, we may want
    to expose the APIs only if there is a valid `ownerId` or only to authorized sellers.
    If the request does not have a valid `ownerId`, the request will no longer progress
    through the rest of the application, and we can throw an error indicating authenticity
    or an invalid `productId`. However, if the `ownerId` is valid, then the request
    will continue to progress through the routes. This is the role of `MyMiddleWare.ts`.
    The next part will go through the controllers.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自定义中间件中，我们可以进行各种检查；例如，我们可能只想在存在有效的`ownerId`时才公开API。如果请求没有有效的`ownerId`，则请求将不再通过应用程序的其余部分，并且我们可以抛出一个错误，指示真实性或无效的`productId`。但是，如果`ownerId`有效，则请求将继续通过路由进行。这是`MyMiddleWare.ts`的作用。接下来将介绍控制器的部分。
- en: 'The next part is the `@JsonControllers` defined by the decorators provided
    by routing controllers. We define our routing controller and post API for adding
    and updating a product:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是由路由控制器提供的装饰器定义的`@JsonControllers`。我们定义了我们的路由控制器和用于添加和更新产品的post API：
- en: '[PRE12]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will create a PUT request for `API <host:url>/products/add-update-product`.
    The `@Body` annotation will convert a cast of the request body to `IProductCreateRequest
    (src/service-layer/request/IProductRequest.ts`) in the variable request (as seen
    in the argument of the `addIpdateProduct` method), which will be available throughout
    the method. The `request` and `responses` folder contains the transformation of
    a various `request` and `response` objects.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为`API <host:url>/products/add-update-product`创建一个PUT请求。`@Body`注释将请求体的转换转换为`IProductCreateRequest
    (src/service-layer/request/IProductRequest.ts)`，并将其放入变量请求（如在`addIpdateProduct`方法的参数中所见），该变量将在整个方法中可用。`request`和`responses`文件夹包含各种`request`和`response`对象的转换。
- en: 'The first part of the controller is to validate the request. The validation
    and security logic will be inside the `src/business-layer` folder. Inside the
    `validator` folder, we will have `ProductValidationSchema.ts` and `ProductValidatorProcessor.ts`.
    Inside `ProductValidationSchema.ts`, add the validation schema rules (various
    validation messages through which we want to identify whether a request is correct
    or has junk data) using the `class-validator` ([https://www.npmjs.com/package/class-validator](https://www.npmjs.com/package/class-validator))
    inbuilt decorators, (`@MinLength,` `@MaxLength`, `@IsEmail`, and so on):'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器的第一部分是验证请求。验证和安全逻辑将位于`src/business-layer`文件夹中。在`validator`文件夹中，我们将有`ProductValidationSchema.ts`和`ProductValidatorProcessor.ts`。在`ProductValidationSchema.ts`中，使用`class-validator`（[https://www.npmjs.com/package/class-validator](https://www.npmjs.com/package/class-validator)）内置装饰器（`@MinLength,`
    `@MaxLength`, `@IsEmail`等）添加验证模式规则（通过这些验证消息，我们希望识别请求是否正确或是否包含垃圾数据）：
- en: '[PRE13]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will use these messages to validate our request object. In `ProductValidationProcessor.ts`,
    create a validator method that returns a consolidated array of messages:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用这些消息来验证我们的请求对象。在`ProductValidationProcessor.ts`中，创建一个验证器方法，返回一个合并的消息数组：
- en: '[PRE14]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `ProductsController.ts`, call the method. If there are errors in the request,
    the request will stop there and won''t propagate to the rest of the API. If the
    response is valid, then it will pass through the data agent to push the data to
    MongoDB:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductsController.ts`中，调用该方法。如果请求中存在错误，则请求将在那里停止，并且不会传播到API的其余部分。如果响应有效，则它将通过数据代理传递数据到MongoDB：
- en: '[PRE15]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the request is valid, the controller, `ProductController.ts`, calls the
    `ProductDataAgent.ts` method, `createNewProduct(..)`, in the data layer in order
    to put the data into MongoDB. Further more, based on the Mongoose schema definition,
    it will automatically maintain a duplication check entry:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当请求有效时，控制器`ProductController.ts`调用数据层中的`ProductDataAgent.ts`方法`createNewProduct(..)`，以将数据放入MongoDB。此外，基于Mongoose模式定义，它将自动维护重复检查条目：
- en: '[PRE16]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Controllers in the service layer not only provide access to the data layer through
    data agents used for negotiating queries against the data store, but they also
    provide an entry point of access to the business layer to process other business
    rules, such as validating product input. The `ProductDataAgent.ts` method returns
    the object returned by MongoDB. It also has other methods, such as `deleteProduct`,
    `findAllProducts`, `findProductByCategory`, and so on.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 服务层中的控制器不仅通过用于协商与数据存储的查询的数据代理提供对数据层的访问，而且还提供了访问业务层以处理其他业务规则的入口，例如验证产品输入。`ProductDataAgent.ts`方法返回MongoDB返回的对象。它还有其他方法，例如`deleteProduct`，`findAllProducts`，`findProductByCategory`等。
- en: 'After completing the transaction with the data store in `ProductDataAgent.ts`,
    a promise in the form of a vanilla object is returned to `ProductController.ts`,
    indicating a failure or success. When a successful product is added to a database,
    the object inserted along with MongoDB''s `ObjectID()` is returned. The data associated
    with the product is constructed as `ProductModel` and will be resolved as an `IProductResponse`
    to `ProductController.ts`:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`ProductDataAgent.ts`中的数据存储完成交易后，以普通对象的形式返回一个承诺给`ProductController.ts`，指示失败或成功。当成功将产品添加到数据库时，将返回插入的对象以及MongoDB的`ObjectID()`。与产品相关的数据构造为`ProductModel`，并将解析为`IProductResponse`到`ProductController.ts`：
- en: '[PRE17]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If some mishap occurs in the processing of the query in `ProductDataAgent.ts`,
    such as a broken connection to the data store, a result in the form of an error
    message will be returned. A similar error response will be thrown if an object
    with the same name already exists.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`ProductDataAgent.ts`中处理查询时发生了一些意外，比如与数据存储的连接中断，将返回一个错误消息形式的结果。如果同名对象已经存在，将抛出类似的错误响应。
- en: This completes the example of how data flows through the application. Based
    on many backend applications and cross-cutting factors, this is designed in order
    to have a smooth flow and eliminate redundant code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了数据如何在应用程序中流动的示例。基于许多后端应用程序和交叉因素，这是为了实现流畅的流程并消除冗余代码而设计的。
- en: 'Similarly, this project will have other APIs, as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，该项目将具有其他API，如下所示：
- en: GET request to get all products
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过GET请求获取所有产品
- en: GET request to get products by ID
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ID获取产品的GET请求
- en: GET request to get products by product type
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过GET请求按产品类型获取产品
- en: DELETE request to delete a single product
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过DELETE请求删除单个产品
- en: Ready to serve (package.json and Docker)
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好提供服务（package.json和Docker）
- en: In this section, we will look at how to write scripts in `package.json` and
    then automate the whole thing using Docker.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何在`package.json`中编写脚本，然后使用Docker自动化整个过程。
- en: package.json
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: package.json
- en: 'Now that we know how data flows, let''s understand how to make it ready to
    serve. Install TypeScript and `rimraf` as dependencies and add the following inside
    the `scripts` tag:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道数据如何流动，让我们了解如何使其准备好提供服务。安装TypeScript和`rimraf`作为依赖项，并在`scripts`标签内添加以下内容：
- en: '[PRE18]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To run the entire process, execute the following command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行整个过程，请执行以下命令：
- en: '[PRE19]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will first delete the `dist` folder if it exists, and then, based on the
    `src` folder, it will transpile the folder and generate the `dist` folder. Once
    the `dist` is generated, we can run our server with `node ./dist/Index.js` and
    `npm run start` in combination.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这将首先删除`dist`文件夹（如果存在），然后基于`src`文件夹，它将转译文件夹并生成`dist`文件夹。一旦生成了`dist`，我们就可以使用`node
    ./dist/Index.js`和`npm run start`的组合来运行我们的服务器。
- en: 'In a later chapter, we will do more things here, including test coverage and
    generating the swagger documentation. Our build script should cover the following
    things:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将在这里做更多的事情，包括测试覆盖和生成swagger文档。我们的构建脚本应该涵盖以下内容：
- en: Generate documentation via `swagger-gen`
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`swagger-gen`生成文档
- en: Invoke `Express.ts`, which will have all routes configured along with middleware
    and dependency injection
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Express.ts`，其中将配置所有路由以及中间件和依赖注入
- en: The `tsc` command will transpile the TypeScript files into JavaScript files
    using the `"outputDirectory":"./dist"` attribute in `tsconfig.json` to identify
    where the JavaScript files should be placed
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “tsc”命令将使用“tsconfig.json”中的“outputDirectory”：“./dist”属性将TypeScript文件转译为JavaScript文件，以确定JavaScript文件应放置的位置
- en: SwaggerUI will generate the documentation, which will be available on the web
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SwaggerUI将生成文档，可在网络上使用
- en: 'Now, to test the API, create a product JSON of the following order and hit
    a POST request with the following payload:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要测试API，请创建以下顺序的产品JSON，并使用以下有效负载进行POST请求：
- en: '[PRE20]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will see a successful response with ResponseCode: 200 and MongoDB''s ObjectId.
    It will look something like this: "id": "5acac73b8bd4f146bcff9667".'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个成功的响应，响应代码为200，以及MongoDB的ObjectId。它看起来像这样：“id”：“5acac73b8bd4f146bcff9667”。
- en: This is the general approach to how we are going to write our microservice.
    It shows us more behavior on separation of control, how it can be achieved using
    TypeScript, and some enterprise design patterns. Thin controllers that lie in
    the service layer rely on references to the business layer and data layer for
    implementing the process with which we can eliminate redundant code and enable
    the sharing of services between controllers. Similarly, you can write countless
    services based on the same approach. Say you want to write a payment microservice,
    you can use the `typeorm` module for SQL operations and have the same code structure.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将如何编写我们的微服务的一般方法。它向我们展示了控制分离的更多行为，以及如何使用TypeScript和一些企业设计模式来实现它，薄控制器位于服务层，依赖于业务层和数据层的引用，以实现可以消除冗余代码并使控制器之间共享服务的过程。同样，您可以基于相同的方法编写无数的服务。假设您想编写一个支付微服务，您可以使用`typeorm`模块进行SQL操作，并具有相同的代码结构。
- en: Docker
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: Now that our application is up and running, let's containerize it, so we can
    push our image to anyone. Containers such as Docker help us to package an entire
    application including the libraries, dependencies, environment, and anything else
    needed by the application to run. Containers are helpful as they isolate the application
    from the infrastructure so we can easily run it on different platforms without
    the need to worry about the system on which we are running.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序已经启动运行，让我们将其容器化，这样我们就可以将我们的镜像推送给任何人。诸如Docker之类的容器帮助我们打包整个应用程序，包括库、依赖项、环境以及应用程序运行所需的任何其他内容。容器很有用，因为它们将应用程序与基础架构隔离开来，这样我们就可以轻松地在不同平台上运行它，而不必担心我们正在运行的系统。
- en: 'Our objectives are as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标如下：
- en: Spin up a working version of our product catalog microservice, Mongo microservice,
    just by running `docker-compose up`
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`docker-compose up`来启动我们的产品目录微服务的工作版本，Mongo微服务
- en: The Docker workflow should be what we are using the Node.js workflow that includes
    transpiling, and serving the `dist` folder
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker工作流应该是我们使用包括转译和服务“dist”文件夹的Node.js工作流
- en: Use data containers for initializing MongoDB
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据容器初始化MongoDB
- en: 'So, let''s get started. We will create our `container` file and write starting
    scripts inside it by performing the following steps. You can find the source in
    the `Chapter 4/products-catalog -with-docker` folder:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧。我们将创建我们的`container`文件，并通过执行以下步骤在其中编写启动脚本。您可以在`Chapter 4/products-catalog
    -with-docker`文件夹中找到源代码：
- en: 'First, create the `.dockerignore` file to ignore things that we don''t want
    in our built container:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建`.dockerignore`文件以忽略我们不希望出现在构建容器中的内容：
- en: '[PRE21]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we will write our `Dockerfile`. An image is made up of a set of layers
    and instructions that we define in our `Dockerfile`. We will initialize our Node.js
    application code here:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写我们的`Dockerfile`。镜像由我们在`Dockerfile`中定义的一组层和指令组成。我们将在这里初始化我们的Node.js应用程序代码。
- en: '[PRE22]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are done with the Node.js part. Now, we need to configure our MongoDB. We
    will use `docker compose`, a tool for running multiple container applications,
    which will spin up our application and run it. Let''s add a `docker-compose.yml`
    file for adding our MongoDB:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了Node.js部分。现在，我们需要配置我们的MongoDB。我们将使用`docker compose`，这是一个用于运行多个容器应用程序的工具，它将启动并运行我们的应用程序。让我们添加一个`docker-compose.yml`文件来添加我们的MongoDB：
- en: '[PRE23]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running multiple containers inside a single container is not possible as such.
    We would be leveraging the Docker Compose up tool ([https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)) ,which
    can be downloaded by running `sudo curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-$(uname
    -s)-$(uname -m) -o/usr/local/bin/docker-compose`. We will look at `docker compose`
    in [Chapter 9](90996850-1ced-4678-a297-3e1fee118eb9.xhtml), *Deployment, Logging,
    and Monitoring*.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个容器内运行多个容器是不可能的。我们将利用Docker Compose up工具（[https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)），可以通过运行`sudo
    curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-$(uname
    -s)-$(uname -m) -o/usr/local/bin/docker-compose`来下载。我们将在[第9章](90996850-1ced-4678-a297-3e1fee118eb9.xhtml)中查看`docker
    compose`，*部署、日志和监控*。
- en: 'Breaking up this file shows us the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 分解此文件后，我们看到以下内容：
- en: We have a service called `app`, which adds a container for the product-catalog
    service.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为`app`的服务，为产品目录服务添加了一个容器。
- en: We instruct Docker to restart the container automatically if it fails.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们指示Docker在容器自动失败时重新启动容器。
- en: To build the app service (our TypeScript Node.js application), we need to tell
    the location of our `Dockerfile` where it can find build instructions. The `build
    ./` command tells Docker that the `Dockerfile` is at the same level as `docker-compose.yml`.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应用程序服务（我们的TypeScript Node.js应用程序），我们需要告诉`Dockerfile`的位置，它可以找到构建说明。`build ./`命令告诉Docker，`Dockerfile`与`docker-compose.yml`在同一级别。
- en: We map the host and the container port (here we have kept both the same).
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们映射主机和容器端口（这里我们保持两者相同）。
- en: We have added another service, Mongo, which pulls the standard Mongo image from
    the Docker Hub registry.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经添加了另一个服务Mongo，它从Docker Hub注册表中拉取标准的Mongo镜像。
- en: Next, we define a data directory by mounting `/data/db` and the local data directory
    `/data`.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们通过挂载`/data/db`和本地数据目录`/data`来定义数据目录。
- en: This will have an advantage similar to when we start a new container. Docker
    compose will use the volume of previous containers and thus ensure there is no
    data loss.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将具有类似于启动新容器时的优势。Docker compose将使用先前容器的卷，从而确保没有数据丢失。
- en: Finally, we link the app container to the Mongo container.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将应用程序容器链接到Mongo容器。
- en: Port `3000:8081` is basically telling us that the Node.js service exposed to
    the outside container world can be accessed at port `3000`, whereas internally
    the application runs on port `8081`.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口`3000:8081`基本上告诉我们，Node.js服务暴露给外部容器世界可以在端口`3000`访问，而在内部应用程序在端口`8081`上运行。
- en: 'Now, just open up a terminal at the parent level and hit the following command:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需在父级别打开终端并输入以下命令：
- en: '[PRE24]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will spin up two containers and aggregate the logs of both containers.
    We have now successfully Dockerized our application.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动两个容器并聚合两个容器的日志。我们现在已经成功地将我们的应用程序Docker化。
- en: '5\. Running `docker-compose up` will give you an error that it can''t connect
    to MongoDB. What could we have done wrong? We are running multiple containers
    via the `docker-compose` option. Mongo runs inside its own container; hence, it
    is not accessible via `localhost:27017`. We need to change our connection URL
    to point it to the Docker service rather than the localhost. Change the following
    line in `default.json` from:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 运行`docker-compose up`将给出一个错误，无法连接到MongoDB。我们可能做错了什么？我们通过`docker-compose`选项运行多个容器。Mongo在其自己的容器内运行；因此，它无法通过`localhost:27017`访问。我们需要更改我们的连接URL，将其指向Docker服务而不是localhost。在`default.json`中更改以下行：
- en: '[PRE25]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 6\. Now, run `docker-compose` up and you will be able to successfully get the
    service up and running.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 现在，运行`docker-compose` up，您将能够成功地启动和运行服务。
- en: By dockerizing our microservice, we have completed the development and build
    cycle. In the next section, we will quickly recap what we have done so far, before
    moving on to the next topic, *Microservice best practices*.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的微服务Docker化，我们已经完成了开发和构建周期。在下一节中，我们将快速回顾我们到目前为止所做的工作，然后转向下一个主题，*微服务最佳实践*。
- en: Synopsis
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: 'In this section, we will have a quick look at some of the modules that we used
    and describe their purpose:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速查看我们使用的一些模块，并描述它们的目的：
- en: '| `routing-controllers` | Has various options and is based on ES6\. It has
    lots of decorators, such as `@GET`, `@POST`, and `@PUT`, which help us to design
    configuration-free services. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `routing-controllers` | 具有各种选项，基于ES6。它有许多装饰器，如`@GET`，`@POST`和`@PUT`，可以帮助我们设计无需配置的服务。
    |'
- en: '| `config` | Config module from which we can write various files based on different
    environments, thus helping us to adhere to the twelve-factor app. |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `config` | 从中我们可以根据不同环境编写各种文件的配置模块，从而帮助我们遵守十二要素应用程序。 |'
- en: '| `typedi` | Used as a dependency injection container. We can then use it to
    inject services (`@Service`) into any controller. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `typedi` | 用作依赖注入容器。然后我们可以使用它将服务（`@Service`）注入到任何控制器中。 |'
- en: '| `winston` | Used for the logging module. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `winston` | 用于日志记录模块。 |'
- en: '| `typeORM` | Module written in TypeScript for dealing with relational databases.
    |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `typeORM` | 用TypeScript编写的用于处理关系数据库的模块。 |'
- en: '| `mongoose` | Popular Mongoose ORM module for dealing with MongoDB. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `mongoose` | 用于处理MongoDB的流行Mongoose ORM模块。 |'
- en: '| `cors` | To enable CORS support for our microservices. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `cors` | 为我们的微服务启用CORS支持。 |'
- en: '| `class-validator` | Used to validate any input requests based on our configured
    rules. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `class-validator` | 用于根据我们配置的规则验证任何输入请求。 |'
- en: Similarly, based on this folder structure and modules, we can create any number
    of microservices supporting any databases. Now that we have a clear understanding
    of how to design a microservice, in the next section we will look at some microservice
    design best practices.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，基于这个文件夹结构和模块，我们可以创建支持任何数据库的任意数量的微服务。现在我们已经清楚了如何设计微服务，在下一节中我们将看一些微服务设计最佳实践。
- en: Microservice design best practices
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务设计最佳实践
- en: Now that we have developed some microservices, it's time to learn about some
    patterns and some design decisions involved around them. To get a broader perspective,
    we will look at what a microservice should handle and what it shouldn't. A number
    of factors need to be considered while designing microservices, keeping best practices
    in mind. Microservices are solely designed on the principle of single responsibility.
    We need to define boundaries and contain our microservices. The following sections
    cover all the factors and design principles that need to be considered for efficiently
    developing microservices.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开发了一些微服务，是时候了解一些围绕它们的模式和设计决策。为了获得更广泛的视角，我们将看看微服务应该处理什么，以及不应该处理什么。在设计微服务时需要考虑许多因素，要牢记最佳实践。微服务完全是基于单一责任原则设计的。我们需要定义边界并包含我们的微服务。以下部分涵盖了需要考虑的所有因素和设计原则，以便有效地开发微服务。
- en: Setting up proper microservice scope
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立适当的微服务范围
- en: 'One of the most important decisions relating to designing microservices is
    the microservice size. Size and scope can have a huge impact on microservice design.
    While comparing to traditional approaches, we can say there should be one REST
    endpoint per any container or any component that performs a single responsibility.
    Our microservices should be domain-driven, where each service is bound to the
    specific context in that domain and will be dealing with a specific business capability.
    A business capability can be defined as something or anything that is being done
    to contribute to achieving business goals. In our shopping cart microservice system,
    payment, adding to the cart, recommending a product, and dispatching a product
    are different business capabilities. Each different business capability should
    be implemented by a separate microservice. If we go with this model, we will end
    up in our microservices list with a product catalog service, price catalog service,
    invoice service, payment service, and so on. Each of the technical capabilities,
    if any, should be bundled as separate microservices. Technical capabilities don''t
    directly contribute to achieving business goals, but rather serve as a simplification
    to support other services. An example includes the integration service. The main
    points that we should adhere to can be summarized as:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 设计微服务的一个最重要的决定是微服务的大小。大小和范围对微服务设计有很大影响。与传统方法相比，我们可以说每个容器或执行单一责任的任何组件应该有一个REST端点。我们的微服务应该是面向领域的，其中每个服务都与该领域中的特定上下文绑定，并将处理特定的业务能力。业务能力可以定义为为实现业务目标而做出的贡献。在我们的购物车微服务系统中，付款、加入购物车、推荐产品和发货是不同的业务能力。每个不同的业务能力应该由一个单独的微服务实现。如果我们采用这种模式，我们将在我们的微服务列表中得到产品目录服务、价格目录服务、发票服务、付款服务等。如果有的话，每个技术能力应该作为单独的微服务捆绑在一起。技术能力不直接为实现业务目标做出贡献，而是作为支持其他服务的简化。一个例子包括集成服务。我们应该遵守的主要要点可以总结为：
- en: Microservices should be responsible for a single capability (be it technical
    or business)
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务应该负责单一的能力（无论是技术还是业务）
- en: Microservices should be individually deployable and scalable
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务应该可以单独部署和扩展
- en: Microservices should be easily maintainable by a small team and should be replaceable
    at any point in time
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务应该由一个小团队轻松维护，并且可以随时替换
- en: Self-governing functions
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我管理的功能
- en: Another important factor while scoping microservices is deciding when to pull
    out the function. If the function is self-sustaining, that is, it has very few
    dependencies on external functions, it processes a given output and gives out
    some output. It can then be taken as a microservice boundary and kept as a separate
    microservice. Common examples are caching, encryption, authorization, authentication,
    and so on. Our shopping cart has numerous such examples. For example, it can be
    a central log service, or a price calculation microservice that takes in various
    inputs, such as product name, customer discounts, and so on, and then calculates
    the price of the product after applying promotional discounts, if any.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定微服务范围时的另一个重要因素是决定何时提取功能。如果功能是自给自足的，即它对外部功能的依赖很少，它处理给定的输出并产生一些输出。那么它可以被视为微服务边界，并作为单独的微服务保留。常见的例子包括缓存、加密、授权、认证等。我们的购物车有许多这样的例子。例如，它可以是一个中央日志服务，或者是一个价格计算微服务，接受各种输入，如产品名称、客户折扣等，然后根据促销折扣计算产品的价格。
- en: Polyglot architecture
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言架构
- en: One of the key requirements that gave birth to microservices is support for
    a polyglot architecture. Various business capabilities need different treatment.
    The principle of "one rule applies everywhere" doesn't work anymore. Different
    technologies, architectures, and approaches are needed to handle all business
    and technological capabilities. When we are scoping microservices, this is another
    key factor to take care of. For example, in our shopping microservice system,
    a product search microservice doesn't need relational databases, but adding to
    the cart and the payment service need ACID compliance, as handling transactions
    there is a very niche requirement.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多语言架构是产生微服务的一个关键需求。不同的业务能力需要不同的处理方式。"一刀切"的原则不再适用。需要不同的技术、架构和方法来处理所有的业务和技术能力。当我们规划微服务时，这是另一个需要注意的关键因素。例如，在我们的购物微服务系统中，产品搜索微服务不需要关系数据库，但是添加到购物车和支付服务需要ACID兼容性，因为在那里处理交易是一个非常独特的需求。
- en: Size of independent deployable component
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立可部署组件的大小
- en: A distributed microservice ecosystem will take full advantage of currently increasing
    CI/CD processes for automation. Automating various steps, such as integration,
    delivery, deployment, unit testing, scaling, and code coverage and then creating
    a deployable unit makes life easier. If we include too many things in a single
    microservices container, it will pose some huge challenge, as there are a lot
    of processes involved, such as installing dependencies, automatic file copying
    or downloading the source from Git, building, deploying, and then starting up.
    With increasing complexity in the microservice, the size of the microservice will
    increase, which soon increases the trouble in managing it. A well-designed microservice
    makes sure that deployment units remain manageable.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式微服务生态系统将充分利用当前不断增长的CI/CD流程进行自动化。自动化各种步骤，如集成、交付、部署、单元测试、扩展和代码覆盖，然后创建可部署单元，可以让生活更轻松。如果我们在一个单一的微服务容器中包含太多东西，那将带来巨大的挑战，因为涉及到很多过程，比如安装依赖项、自动文件复制或从Git下载源代码、构建、部署，然后启动。随着微服务的复杂性增加，微服务的大小将增加，这很快会增加管理的麻烦。一个设计良好的微服务可以确保部署单元保持可管理性。
- en: Distributing and scaling services whenever required
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据需要分发和扩展服务
- en: While designing microservices, it is important to breakup microservices based
    on various parameters, such as in-depth analysis of which business capabilities
    are most sought after, a division of services based on ownership, loosely coupled
    architecture, and so on. Microservices designed with this division are effective
    in the long run as we can easily scale out any service on demand and isolate our
    failure points. In our product microservices, approximately 60% of the requests
    would be search based. In this case, our search microservice container has to
    run separately so it can scale separately when needed. Elasticsearch or Redis
    can be introduced on top of this microservice, which would give better response
    times. This will have various advantages, such as cost reduction, effective use
    of resources, business benefits, cost optimizations, and so on.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务时，根据各种参数对微服务进行分解是很重要的，比如对业务能力的深入分析，基于所有权的服务划分，松散耦合的架构等等。以这种方式设计的微服务在长期内是有效的，因为我们可以根据需求轻松扩展任何服务，并隔离我们的故障点。在我们的产品微服务中，大约60%的请求将基于搜索。在这种情况下，我们的搜索微服务容器必须单独运行，以便在需要时单独扩展。Elasticsearch或Redis可以在这个微服务之上引入，这将提供更好的响应时间。这将带来各种优势，比如成本降低，资源的有效利用，业务利益，成本优化等等。
- en: Being Agile
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷
- en: With dynamically changing requirements, the Agile methodology of development
    has been adopted everywhere. One of the important considerations in scoping out
    microservices is developing in such a way that each team can develop different
    parts of the pie. Each of the team builds different microservices and then we
    construct the full pie. For example, in our shopping cart microservices, we can
    have one recommendation service that specifically targets an audience based on
    their preferences and history. This can be developed keeping users' tracking history,
    browser history, and more in mind, which can result in a complex algorithm. This
    is why it will be developed as a separate microservice, which can be handled by
    separate teams.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 随着需求的动态变化，敏捷开发方法已经被广泛采用。在规划微服务时，一个重要的考虑因素是以每个团队可以开发饼图的不同部分的方式进行开发。每个团队构建不同的微服务，然后我们构建完整的饼图。例如，在我们的购物车微服务中，我们可以有一个推荐服务，专门针对用户的偏好和历史来定位受众。这可以通过考虑用户的跟踪历史、浏览器历史等来开发，这可能导致复杂的算法。这就是为什么它将作为一个单独的微服务开发，可以由不同的团队处理。
- en: Single business capability handler
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一业务能力处理程序
- en: Drifting away a bit from the traditional single responsibility principle, a
    single microservice should handle a single business capability or technical capability.
    One microservice should not perform multiple responsibilities. Based on the pattern
    of design, a business capability can be divided into more than one microservice.
    For example, in our shopping cart microservices in inventory management, we may
    introduce a CQRS pattern to achieve some quality attributes, where our reads and
    writes would be spread across different service containers. When each service
    is mapped to a bounded context, handling a single business capability, it is much
    easier to manage them. Each service may exist as separate products, targeting
    a specific community. They should be reusable, easily deployable, and so on.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的单一责任原则有些偏离，一个微服务应该处理一个业务能力或技术能力。一个微服务不应该承担多个责任。根据设计模式，一个业务能力可以被划分为多个微服务。例如，在我们的购物车微服务中的库存管理中，我们可以引入CQRS模式来实现一些质量属性，其中我们的读写将分布在不同的服务容器中。当每个服务映射到一个有界上下文，处理一个业务能力时，更容易管理它们。每个服务可以作为单独的产品存在，针对特定的社区。它们应该是可重用的，易于部署等等。
- en: Adapting to shifting needs
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应不断变化的需求
- en: Microservices should be designed so that they can be easily detached from the
    system with the minimum amount of rewrites. This enables us to easily add experimental
    features. For example, in our shopping cart microservices, we may add a product
    ranking service based on the feedback received. If the service doesn't work out
    or the business capability is not achieved, this service can be thrown out or
    easily replaced with another service. Scoping microservices here plays an important
    role, as a minimum viable product can be made and then, on top of it, features
    can be added or removed as per the requirements.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该被设计成可以很容易地从系统中分离出来，而不需要进行大量的重写。这使我们可以很容易地添加实验性功能。例如，在我们的购物车微服务中，我们可以根据收到的反馈添加一个产品排名服务。如果服务不起作用或者业务能力没有达到预期，这个服务可以被抛弃或者很容易地替换为另一个服务。在这里，微服务的范围起着重要的作用，因为可以制作一个最小可行产品，然后根据需求添加或删除功能。
- en: Handling dependencies and coupling
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理依赖和耦合
- en: Another important factor in scoping out services is dependencies and the coupling
    a service introduces. Dependencies in microservices have to be evaluated to make
    sure that tight coupling is not introduced in the system. To avoid a high-coupled
    system, decompose the system into business/technical/functional capabilities and
    create a functional dependency tree. Having too many request-response calls, cyclical
    dependencies, and so on are some of the factors that may break a microservice.
    Another important aspect in designing robust microservices is to have event-driven
    architecture; that is, instead of waiting for a response, a microservice should
    react upon receiving an event.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定服务范围的另一个重要因素是服务的依赖和引入的耦合。必须评估微服务中的依赖关系，以确保系统中没有引入紧密耦合。为了避免高度耦合的系统，将系统分解为业务/技术/功能能力，并创建功能依赖树。过多的请求-响应调用、循环依赖等因素可能会破坏微服务。设计健壮的微服务的另一个重要方面是具有事件驱动架构；也就是说，微服务应该在接收到事件后立即做出反应，而不是等待响应。
- en: Deciding the number of endpoints in a microservice
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定微服务中端点的数量
- en: While this may seem an important point in consideration for designing microservices,
    it is not at all a design consideration. A microservice container may host one
    or many endpoints. A more important consideration is bounding the microservice.
    Based on the business or technical capabilities, there may be only one endpoint,
    whereas in many cases there could be more than one endpoint in a microservice.
    For example, going back to our shopping cart services for our inventory management
    where we introduced a CQRS pattern, we have separate read and write services,
    each containing single endpoints. Another example can be a polyglot architecture,
    where we have multiple endpoints in order to have communication between various
    microservices. We usually break services into containers based on our deployment
    and scaling needs. For our checkout service, all services are connected and use
    the same relational database. In this case, there is no need to separate out these
    into different microservices.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来是设计微服务时需要考虑的重要点，但实际上并不是设计考虑的一部分。微服务容器可以承载一个或多个端点。更重要的考虑是微服务的边界。根据业务或技术能力，可能只有一个端点，而在许多情况下，一个微服务可能有多个端点。例如，回到我们的购物车服务和库存管理中引入了CQRS模式，我们有单独的读和写服务，每个包含单个端点。另一个例子可以是多语言体系结构，我们可以有多个端点以便在各种微服务之间进行通信。我们通常根据部署和扩展的需求将服务分解为容器。对于我们的结账服务，所有服务都连接并使用相同的关系数据库。在这种情况下，没有必要将它们分解为不同的微服务。
- en: Communication styles between microservices
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务之间的通信风格
- en: Another important factor to be considered while designing microservices is the
    communication style between microservices. There can be a synchronous mode (sending
    requests, receiving responses) or an asynchronous mode of communication (fire
    and forget). Both modes have their own pros and cons and have their specific use
    cases where they can be used. In order to have a scalable microservice, a combination
    of both approaches is needed. Apart from this, nowadays "being real-time" is the
    new trend. Socket-based communication promotes real-time communication. Yet another
    way of dividing communication styles is based on the number of receivers. For
    a single receiver, we have a command-based pattern (CQRS, as seen in earlier chapters).
    For more than one receiver, we have an event-driven architecture that is based
    on the principle of the publish and subscribe pattern, where in-service buses
    are used.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务时需要考虑的另一个重要因素是微服务之间的通信方式。可以有同步模式（发送请求，接收响应）或异步通信模式（发送并忘记）。这两种模式都有各自的优缺点，以及它们可以使用的特定用例。为了拥有可扩展的微服务，需要结合这两种方法。除此之外，现在“实时性”是新的趋势。基于套接字的通信促进了实时通信。另一种划分通信风格的方式是基于接收者的数量。对于单个接收者，我们有基于命令的模式（如前几章中所见的CQRS）。对于多个接收者，我们有基于事件驱动架构，它基于发布和订阅模式的原则，其中使用服务总线。
- en: Specifying and testing the microservices contract
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定和测试微服务契约
- en: A contract can be defined as a set of agreements (protocol, request body, address,
    and so on) between the consumer and the provider, which helps to smooth the interactions
    that take place between them. Microservices should be designed so that they can
    be independently deployed, without any dependencies on one another. To achieve
    this complete independence, each microservice should have well written, versioned,
    and defined contracts, which all its clients (other microservices) must adhere
    to. Introducing breaking changes at any time might be a problem as clients may
    require previous versions of the contract. Only after appropriate communication
    should a contract be put out of service or turned down. Some best practices include
    deploying new versions side by side and including versioning in your API. For
    example, `/product-service/v1`, then `/product-service/v2`. Using **consumer-driven
    contracts** (**CDCs**) is one of the modern ways to test microservices, as compared
    to integration tests. Further, in this book, we will be using Pact JS to test
    our contracts ([Chapter 8](a7273aa2-2981-4013-8d5f-dbee87462d35.xhtml), *Testing,
    Debugging, and Documenting*).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 合同可以被定义为消费者和提供者之间的一组协议、请求体、地址等协议，这有助于平滑地进行它们之间的交互。微服务应该被设计成可以独立部署，而不依赖于彼此。为了实现这种完全的独立性，每个微服务都应该有良好编写、版本化和定义的合同，所有它的客户（其他微服务）都必须遵守。在任何时候引入破坏性变化可能会成为一个问题，因为客户可能需要合同的先前版本。只有在适当的沟通之后，才能停用或关闭合同。一些最佳实践包括并行部署新版本，并在API中包含版本信息。例如，`/product-service/v1`，然后`/product-service/v2`。使用**消费者驱动的合同**（**CDCs**）是测试微服务的现代方式之一，与集成测试相比。此外，在本书中，我们将使用Pact
    JS来测试我们的合同（[第8章](a7273aa2-2981-4013-8d5f-dbee87462d35.xhtml)，*测试、调试和文档*）。
- en: Number of microservices in a container
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器中微服务的数量
- en: 'Containerizing your microservice is one of the most recommended ways for deploying
    microservices. Containers provide agility in your system and it streamlines the
    development and testing experience. Containers are portable across any infrastructure
    and can be easily deployed on AWS too. Deciding on the number of microservices
    that a container can contain is vital and is dependent upon various factors such
    as container capacity, memory, selective scaling, resource requirements, traffic
    volume per service, and so on. Based on these facts, we can decide whether deployments
    can be brought together or not. Even if services are brought together, it has
    to be ensured that these services are run independently and they are not sharing
    anything. Selective scaling is also one of the crucial factors in deciding on
    the number of microservices in a container. It should be such that deployments
    are self-managed, an example being AWS Lambda. The following are the available patterns
    and the limitations of each of the patterns:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的微服务容器化是部署微服务的最推荐方式之一。容器为您的系统提供了灵活性，并简化了开发和测试体验。容器在任何基础设施上都是可移植的，并且也可以轻松地部署在AWS上。决定容器中可以包含多少微服务是至关重要的，并且取决于各种因素，例如容器容量、内存、选择性扩展、资源需求、每个服务的流量量等。基于这些事实，我们可以决定是否可以将部署合并在一起。即使服务被合并在一起，也必须确保这些服务是独立运行的，它们不共享任何东西。选择性扩展也是决定容器中微服务数量的关键因素之一。它应该是这样的，即部署是自管理的，例如AWS
    Lambda。以下是可用的模式和每种模式的限制：
- en: '**Service instance per virtual machine**:Here, you package each service as
    a virtual machine image (traditional approach), such as an Amazon EC2 EMI. Here,
    each service is a separate VM that is launched in a separate VM image:'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个虚拟机一个服务实例**：在这里，您将每个服务打包为虚拟机镜像（传统方法），例如Amazon EC2 EMI。在这里，每个服务都是一个单独的VM，它在单独的VM镜像中启动：'
- en: '**Limitations**:'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**：'
- en: Less efficient resource utilization
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源利用效率低
- en: You pay for entire VM; therefore, if you are not utilizing the entire VM, you
    are paying charges for nothing
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要为整个VM付费；因此，如果您没有利用整个VM，您将为无用的费用付费
- en: Deploying a new version on a service is very slow
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务上部署新版本非常慢
- en: Managing multiple VMs soon becomes a huge pain and a time-consuming activity
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理多个VM很快就会成为一个巨大的痛苦和耗时的活动
- en: '**Service instance per container**:Here, each service runs on its own container.
    Containers are one portable virtualization technique. They have their own root
    filesystem and portable namespaces. You can limit their CPU resources and memory.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个容器一个服务实例**：在这里，每个服务都在自己的容器上运行。容器是一种便携式的虚拟化技术。它们有自己的根文件系统和便携式命名空间。您可以限制它们的CPU资源和内存。'
- en: '**Limitations**:'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**：'
- en: A container is not as mature as a VM
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器不像VM那样成熟
- en: Handling spikes in the load is an extra added task
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理负载的激增是一个额外的任务
- en: Monitoring the VM infrastructure and container infrastructure is again an added
    task
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控VM基础设施和容器基础设施又是一个额外的任务
- en: '**Serverless**:One of the latest "worry free trends" is the serverless architecture,
    where you package a microservice, package it as a ZIP, and deploy it to serverless
    platforms, such as AWS Lambda. You are just billed for each request based on the
    time taken and memory consumed. For example, a Lambda function is stateless.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无服务器**：最新的“无忧趋势”之一是无服务器架构，您可以将微服务打包为ZIP文件，并部署到无服务器平台，如AWS Lambda。您只需根据所用时间和内存消耗对每个请求进行计费。例如，Lambda函数是无状态的。'
- en: '**Limitations:**'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**：'
- en: This approach is not feasible for long-term running services. An example can
    be where a service is dependent on another service or a third-party broker.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法不适用于长期运行的服务。一个例子是一个服务依赖于另一个服务或第三方代理。
- en: Requests must complete in less than 300 seconds.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求必须在300秒内完成。
- en: Services must be stateless, as each separate instance is run for each request.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务必须是无状态的，因为每个单独的实例都是为每个请求运行的。
- en: Services must start quickly or else they will be timed out.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务必须快速启动，否则它们将超时。
- en: Services must be run in one of the supported languages. For example, AWS Lambda
    supports Java, Node.js, and Python.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务必须在支持的语言中运行。例如，AWS Lambda支持Java、Node.js和Python。
- en: Data sources and rule engine among microservices
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的数据源和规则引擎
- en: Another important factor is applying a rules engine and deciding upon data sources
    in our distributed system. Rules are an essential part of any system as they help
    us to govern the entire system. Many organizations use a centralized rules engine
    or workflow processes following the BPMN standards example, Drools. An embedded
    rule engine can either be placed within the service or can be external to the
    service based on usage. If there are complex rules, a central authoring repository
    with an embedded engine would be the best choice. Since it is centrally distributed,
    there can be technology dependencies, rules running rules within some application
    server boundaries, and so on.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要因素是应用规则引擎，并在我们的分布式系统中决定数据源。规则是任何系统的重要部分，因为它们帮助我们管理整个系统。许多组织使用集中式规则引擎或遵循BPMN标准示例的工作流程，比如Drools。嵌入式规则引擎可以放置在服务内部，也可以根据使用情况放置在服务外部。如果存在复杂规则，具有嵌入式引擎的中央编写存储库将是最佳选择。由于它是集中分布的，可能存在技术依赖性，规则在某些应用服务器边界内运行规则等。
- en: '**Business Process Modeling Notations** (**BPMN**) are standardized notations
    with the objective of creating visual models of any business or any organizational
    process. Often in business capabilities, we need a definitive workflow that may
    change as per requirements. We never hardcode any processes or write our own engine
    and leverage BPMN tools for it.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 业务流程建模符号（BPMN）是标准化符号，其目标是创建任何业务或组织流程的可视模型。在业务能力中，我们经常需要一个明确定义的工作流程，可以根据需求进行更改。我们从不硬编码任何流程或编写自己的引擎，而是利用BPMN工具进行操作。
- en: Just like the rules engine, deciding on data stores among microservices is also
    crucial. Transactional boundaries should be set up within our defined business
    capabilities. For example, in our shopping cart microservices, at the checkout
    we need to maintain transactions and we can go with RDBMS as a data source to
    ensure integrity and follow ACID principles. However, product catalog databases
    don't have any transactions and we can use NoSQL databases for them.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 就像规则引擎一样，在微服务中决定数据存储也是至关重要的。事务边界应该在我们定义的业务能力内设置。例如，在我们的购物车微服务中，在结账时，我们需要维护事务，并且我们可以选择关系型数据库作为数据源，以确保完整性并遵循ACID原则。然而，产品目录数据库没有任何事务，我们可以为其使用NoSQL数据库。
- en: Summary
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we began designing our microservices for the shopping cart
    services. We analyzed our requirements based on technical, functional, and business
    capabilities, which are the primary drivers in scoping microservices. We designed
    our schema, analyzed our microservice structure, and ran it on Docker. Finally,
    we looked at some of the best practices for microservice design and learned how
    to scope microservices based on our business capabilities.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始为购物车服务设计我们的微服务。我们根据技术、功能和业务能力分析了我们的需求，这些是微服务范围的主要驱动因素。我们设计了我们的模式，分析了我们的微服务结构，并在Docker上运行了它。最后，我们研究了一些微服务设计的最佳实践，并学习了如何根据我们的业务能力来确定微服务的范围。
- en: In the next chapter, we are going to learn how to introduce a gateway to our
    microservices and understand the problem a gateway solves. We are going to see
    how API Gateway solves centralized concerns in distributed systems. We will get
    acquainted with some API Gateway design patterns and design our gateway for the
    shopping cart microservices.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何向我们的微服务引入网关，并了解网关解决的问题。我们将看到API网关如何解决分布式系统中的集中式问题。我们将熟悉一些API网关设计模式，并为购物车微服务设计我们的网关。
