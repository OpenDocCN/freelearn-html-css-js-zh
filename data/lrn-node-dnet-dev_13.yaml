- en: Chapter 13. Creating JavaScript Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章. 创建 JavaScript 包
- en: So far we have built up a web application, making use of various npm packages
    along the way. These packages include libraries such as Express and command-line
    tools such as Gulp. Now we'll look at how to go about creating packages of our
    own.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个网络应用程序，在创建过程中使用了各种 npm 包。这些包包括 Express 这样的库和 Gulp 这样的命令行工具。现在我们将看看如何创建我们自己的包。
- en: 'In this chapter we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Explore the different module systems available for JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索可用于 JavaScript 的不同模块系统
- en: Create our own JavaScript library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己的 JavaScript 库
- en: Write JavaScript that can run on both the client and server-side
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可以在客户端和服务器端运行的 JavaScript
- en: Create a command-line tool in JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 JavaScript 命令行工具
- en: Release a new npm package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布一个新的 npm 包
- en: Use Node.js modules in the browser environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器环境中使用 Node.js 模块
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code examples in this chapter are independent of everything we've done so
    far.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例与我们迄今为止所做的一切都是独立的。
- en: Writing universal modules
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写通用模块
- en: We have already written many of our own modules as part of our application.
    We can also write library modules for use in other applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了许多自己的模块作为我们应用程序的一部分。我们还可以编写库模块供其他应用程序使用。
- en: When writing code for use by others, it's worth considering in what contexts
    it will be useful. Some libraries are only useful in specific environments. For
    example, Express is server-specific and jQuery is browser-specific. But many modules
    provide functionality that would be useful in any environment, for example, utility
    modules such as the `uuid` module we've used elsewhere in this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当为他人编写代码时，考虑它在什么环境中有用是值得的。一些库仅在特定环境中有用。例如，Express 是服务器特定的，jQuery 是浏览器特定的。但许多模块提供在任何环境中都很有用的功能，例如，我们在这本书的其他地方使用的
    `uuid` 模块等实用模块。
- en: Let's look at writing a module to work in multiple environments. We'll need
    to support more than just Node.js-style modules. We'll also need to support client-side
    module systems such as RequireJS. Recall from [Chapter 4](part0025.xhtml#aid-NQU21
    "Chapter 4. Introducing Node.js Modules"), *Introducing Node.js Modules*, that
    Node.js and RequireJS implement two different module standards (CommonJS and **Asynchronous**
    **Module Definition** (**AMD**), respectively). Our package may also be used client-side
    in a website with no module system in place.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写适用于多个环境的模块。我们需要支持不仅仅是 Node.js 风格的模块。我们还需要支持客户端模块系统，如 RequireJS。回顾 [第
    4 章](part0025.xhtml#aid-NQU21 "第 4 章. 介绍 Node.js 模块")，*介绍 Node.js 模块*，Node.js
    和 RequireJS 实现了两种不同的模块标准（分别是 CommonJS 和 **异步** **模块定义**（**AMD**））。我们的包也可能在没有任何模块系统的网站上作为客户端使用。
- en: As an example, let's create a module providing a simple `flatMap` method. This
    will work like `SelectMany` in .NET's LINQ. It will take an array and a function
    that returns a new array for each element. It will return a single array of the
    combined results.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个提供简单 `flatMap` 方法的模块。这将像 .NET 的 LINQ 中的 `SelectMany` 一样工作。它将接受一个数组和为每个元素返回一个新数组的函数。它将返回一个包含合并结果的单一数组。
- en: 'As a Node.js/CommonJS module, we could implement this as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Node.js/CommonJS 模块，我们可以这样实现：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Comparing Node.js and RequireJS
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较 Node.js 和 RequireJS
- en: 'Recall from [Chapter 4](part0025.xhtml#aid-NQU21 "Chapter 4. Introducing Node.js
    Modules"), *Introducing Node.js Modules*, that each module system provides the
    following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 [第 4 章](part0025.xhtml#aid-NQU21 "第 4 章. 介绍 Node.js 模块")，*介绍 Node.js 模块*，每个模块系统都提供以下功能：
- en: A way of declaring a module with a name and its own scope
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种声明具有名称和自身作用域的模块的方法
- en: A way of defining functionality provided by the module
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模块提供功能的方法
- en: A way of importing a module into another script
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块导入另一个脚本的方法
- en: Node.js implements the CommonJS module standard. Module names correspond to
    file paths and each file has its own scope. Modules define the functionality they
    provide using the `exports` alias. Modules are imported using the `require` function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 实现了 CommonJS 模块标准。模块名称对应文件路径，每个文件都有自己的作用域。模块使用 `exports` 别名定义它们提供的功能。模块通过
    `require` 函数导入。
- en: RequireJS is designed for the browser environment. In the browser there is no
    new scope per file (all script files execute in the same scope and can see the
    same variables). Also, modules must be loaded by network requests rather than
    from the local filesystem.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS 是为浏览器环境设计的。在浏览器中，每个文件没有新的作用域（所有脚本文件都在同一个作用域中执行，并且可以查看相同的变量）。此外，模块必须通过网络请求而不是从本地文件系统加载。
- en: 'RequireJS implements the AMD standard. AMD specifies two functions, which RequireJS
    adds to the top-level window object in the browser environment:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS 实现了 AMD 标准。AMD 指定了两个函数，RequireJS 将这两个函数添加到浏览器环境中的顶级 `window` 对象中：
- en: The `define` function allows new modules to be created by providing a name and
    a factory function for the module. The scope of the module will be the scope of
    its factory function. The functionality of the module is defined by the return
    value of the factory function.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`define` 函数允许通过提供模块名称和工厂函数来创建新的模块。模块的作用域将是其工厂函数的作用域。模块的功能由工厂函数的返回值定义。'
- en: The `require` function allows modules to be imported. Although this has the
    same name as the module import function in Node.js, it works very differently.
    Multiple module names can be specified for import (as an array). The require function
    is asynchronous and takes a callback to be executed when all the dependencies
    are loaded. This allows RequireJS to load modules efficiently in the browser environment.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require` 函数允许导入模块。尽管这个名字与 Node.js 中的模块导入函数相同，但它们的工作方式非常不同。可以指定多个模块名称进行导入（作为一个数组）。`require`
    函数是异步的，并接受一个回调函数，当所有依赖项都加载完成后执行。这允许 RequireJS 在浏览器环境中有效地加载模块。'
- en: Supporting the browser environment
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持浏览器环境
- en: 'For our module to work in the browser environment, we need to support the AMD
    standard so RequireJS can work. We also need to accommodate sites not using any
    module loader. We can achieve this by extending our module definition as follows,
    in `scripts/flatMap.js`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的模块在浏览器环境中工作，我们需要支持 AMD 标准，以便 RequireJS 可以工作。我们还需要适应不使用任何模块加载器的网站。我们可以通过以下方式扩展我们的模块定义来实现这一点，在
    `scripts/flatMap.js` 中：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the use of an anonymous function that is invoked straight away, called
    an **Immediately-Invoked** **Function Expression** (**IIFE**). This is a common
    way of creating an isolated scope in JavaScript environments without built-in
    modules.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用立即调用的匿名函数，称为**立即执行的函数表达式**（**IIFE**）。这是在具有内置模块的 JavaScript 环境中创建隔离作用域的常见方法。
- en: First, we check for the existence of an AMD-style `define` function (the existence
    of a `define.amd` property is also specified by the AMD standard). Note that the
    asynchronous nature of the `define` function means that we need to use a factory
    function to create our module. We provide a list of dependencies (empty in this
    case) and our factory function to the `define` function to create our module.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查 AMD 风格的 `define` 函数的存在（AMD 标准还指定了 `define.amd` 属性的存在）。请注意，`define` 函数的异步性质意味着我们需要使用工厂函数来创建我们的模块。我们将依赖项列表（在这种情况下为空）和我们的工厂函数提供给
    `define` 函数以创建我们的模块。
- en: If no AMD module system is present, we check for the CommonJS-style `module.exports`
    used by Node.js. Finally, if neither module system is present, we provide our
    module as a property on the `root` parameter. Our argument for this parameter
    is the `this` keyword evaluated in the global scope. In a browser, this will be
    the `window` object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 AMD 模块系统，我们将检查 Node.js 使用的 CommonJS 风格的 `module.exports`。最后，如果两个模块系统都不存在，我们将我们的模块作为
    `root` 参数的一个属性提供。我们为这个参数的论点是全局作用域中评估的 `this` 关键字。在浏览器中，这将是指 `window` 对象。
- en: Using AMD modules with RequireJS
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 RequireJS 与 AMD 模块
- en: Let's create a simple web page to check that our module works correctly with
    RequireJS. We'll also show how to use RequireJS with an external library, jQuery.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的网页来检查我们的模块是否与 RequireJS 正确工作。我们还将展示如何使用 RequireJS 与外部库 jQuery 一起使用。
- en: 'First we define an HTML file for the page:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为页面定义一个 HTML 文件：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that the only script tag on the page is for RequireJS itself. This script
    tag also has a data attribute indicating the entry point of our application. The
    path `scripts/main` tells RequireJS to load `scripts/main.js`, which contains
    the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，页面上唯一的脚本标签是用于 RequireJS 自身的。此脚本标签还有一个数据属性，指示我们应用程序的入口点。路径 `scripts/main`
    告诉 RequireJS 加载 `scripts/main.js`，它包含以下内容：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This script first configures RequireJS. The only `config` property specified
    here is the `path` property. The path for jQuery under the key `'jquery'` tells
    RequireJS how to resolve the `'jquery'` dependency. We don't need to specify a
    path for `flatMap.js` because we have saved it under the same directory as `main.js`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本首先配置 RequireJS。这里指定的唯一 `config` 属性是 `path` 属性。键 `'jquery'` 下的 jQuery 路径告诉
    RequireJS 如何解析 `'jquery'` 依赖项。我们不需要为 `flatMap.js` 指定路径，因为我们已经将它保存在与 `main.js`
    相同的目录下。
- en: Next we use the `require` function to load flatMap and jQuery and pass them
    into our main application function. In larger applications using RequireJS, this
    is usually a very short bootstrap function. The `main.js` file is also often the
    only place that you'll see a `require` call. Most of the application code is in
    modules declared with `define`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`require`函数加载flatMap和jQuery，并将它们传递到我们的主应用程序函数中。在较大的使用RequireJS的应用程序中，这通常是一个非常短的引导函数。`main.js`文件也是你通常会看到`require`调用的唯一地方。大多数应用程序代码都使用`define`声明的模块。
- en: 'As this is just a test of our library with RequireJS, we''ll put the rest of
    our application code inside our main application function. We use our flatMap
    module and jQuery to calculate and display word counts across all the text inputs.
    You can see this working by opening `index.html` in your browser:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个使用RequireJS测试我们库的例子，我们将把其余的应用程序代码放在我们的主应用程序函数中。我们使用我们的flatMap模块和jQuery来计算和显示所有文本输入的单词数。你可以在浏览器中打开`index.html`来查看这个功能：
- en: '![Using AMD modules with RequireJS](img/image00226.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![使用RequireJS与AMD模块](img/image00226.jpeg)'
- en: Isomorphic JavaScript
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同构JavaScript
- en: The `flatMap.js` example above is an implementation of the Universal Module
    Definition pattern. See [https://github.com/umdjs/umd](https://github.com/umdjs/umd)
    for annotated templates for this pattern. These templates also show how to declare
    dependencies between modules that follow this pattern.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`flatMap.js`示例是通用模块定义模式的实现。有关此模式的注释模板，请参阅[https://github.com/umdjs/umd](https://github.com/umdjs/umd)。这些模板还展示了如何声明遵循此模式的模块之间的依赖关系。
- en: More generally, writing code that achieves the same result both on the server
    and in the browser is referred to as **Isomorphic JavaScript**. See [http://isomorphic.net/](http://isomorphic.net/)
    for more explanation and examples of this principle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，编写在服务器和浏览器上都能达到相同结果的代码被称为**同构JavaScript**。有关更多解释和此原则的示例，请参阅[http://isomorphic.net/](http://isomorphic.net/)。
- en: Writing npm packages
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写npm包
- en: If you create some code that would be useful to others, you can distribute it
    as an npm package. To demonstrate this, we'll implement some slightly more complex
    functionality.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一些对他人有用的代码，你可以将其作为npm包分发。为了演示这一点，我们将实现一些稍微复杂的功能。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the example code for this section at [https://github.com/NodeJsForDevelopers/autotoc](https://github.com/NodeJsForDevelopers/autotoc).
    Note that, unlike previous chapters, there is not one per commit per heading.
    The listings in the rest of this section match the final version of the code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/NodeJsForDevelopers/autotoc](https://github.com/NodeJsForDevelopers/autotoc)找到本节示例代码。请注意，与之前的章节不同，这里没有每个提交每个标题的代码。本节其余部分的列表与代码的最终版本相匹配。
- en: 'We''re going to implement a tool for generating a **table of contents** (**ToC**)
    by crawling a website. To help with this, we''ll make use of a few other npm packages:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个通过爬取网站来生成**目录**（**ToC**）的工具。为此，我们将使用几个其他的npm包：
- en: '**request** provides an API for making HTTP requests, which is higher-level
    and much simpler to use than the build in the Node.js http module'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**request**提供了一个用于发起HTTP请求的API，它比Node.js内置的http模块更高级，使用起来也更简单'
- en: '**cheerio** provides jQuery-like HTML traversal outside of the browser environment'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cheerio**提供了在浏览器环境之外类似jQuery的HTML遍历功能'
- en: '**denodeify**, mentioned in [Chapter 8](part0048.xhtml#aid-1DOR02 "Chapter 8. Mastering
    Asynchronicity"), *Mastering Asynchronicity*, allows us to use the request library
    with promises instead of callbacks'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**denodeify**，在第8章[掌握异步编程](part0048.xhtml#aid-1DOR02 "第8章。掌握异步编程")中提到，允许我们使用带有承诺而不是回调的请求库'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's common for `npm` packages to depend on other packages in this way. But
    it is worth minimizing your package's dependencies if you want it to be appealing
    to other developers. Packages with many transitive dependencies can add a lot
    of bloat to applications, and make it harder for developers to be confident that
    they understand everything they are pulling into their application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`npm`包来说，依赖其他包是很常见的。但如果你想让你的包对其他开发者更有吸引力，那么最小化你的包的依赖是有意义的。具有许多传递性依赖的包可能会给应用程序添加很多冗余，并使开发者更难确信他们理解了他们应用到应用程序中的所有内容。
- en: 'The code for our module follows, as given in `autotoc.js`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块的代码如下，如`autotoc.js`中所示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s not important to understand every single line as we''re more interested
    in how it will be packaged. The important points are:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要理解每一行，因为我们更感兴趣的是它将被如何打包。重要的一点是：
- en: We load the starting page then follow links through to other pages and process
    these recursively to build up the entire ToC
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们加载起始页面，然后通过链接跳转到其他页面，并递归地处理这些页面以构建整个目录表（ToC）
- en: We only follow links to more specific URLs than the current page (that is, subpaths),
    so we don't get into infinite loops
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只跟随比当前页面更具体的 URL（即子路径）的链接，所以我们不会陷入无限循环
- en: At each level, we load all child pages in parallel and use `Promise.all` to
    combine the results
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个级别，我们并行加载所有子页面，并使用 `Promise.all` 来组合结果
- en: 'We''ll also add a simple module to print a ToC to the console, as given in
    `consolePrinter.js`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会添加一个简单的模块，将目录表（ToC）打印到控制台，如下所示 `consolePrinter.js`：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Defining an npm package
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 npm 包
- en: 'To define an npm package, we must add a file to act as the entry point to our
    package. This will just expose the inner modules appropriately, as given in `index.js`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个 npm 包，我们必须添加一个文件作为我们包的入口点。这将只适当地暴露内部模块，如下所示 `index.js`：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also need to add an npm `package.json` file to define our package''s metadata.
    To create this file, you can run `npm init` in the command line and follow the
    prompts. In our case, the resulting file looks like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个 npm `package.json` 文件来定义我们包的元数据。要创建此文件，你可以在命令行中运行 `npm init` 并按照提示操作。在我们的例子中，生成的文件如下所示：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've used `package.json` files before to specify dependencies for `npm install`.
    The other fields become much more important when publishing a package to `npm`.
    Note that we use the `main` property to specify our package's entry point. Actually,
    `index.js` is the default value, but specifying it explicitly makes this clearer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经使用过 `package.json` 文件来指定 `npm install` 的依赖项。当将包发布到 `npm` 时，其他字段变得尤为重要。注意，我们使用
    `main` 属性来指定我们包的入口点。实际上，`index.js` 是默认值，但明确指定可以使这更清晰。
- en: Publishing a package to npm
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将包发布到 npm
- en: 'Once we have defined our package''s metadata, publishing it to npm is very
    straightforward:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了包的元数据，将其发布到 npm 就非常直接：
- en: If you do not already have an npm account, create one by running `npm adduser`
    and specifying a username and password
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你还没有 npm 账户，可以通过运行 `npm adduser` 并指定用户名和密码来创建一个
- en: Log in using `npm login`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `npm login` 登录
- en: In the `root` folder of the package, run `npm publish`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包的 `root` 文件夹中，运行 `npm publish`
- en: 'That''s all we need to do! Our package will now appear in the global npm repository.
    We can make use of it by (in a new folder) running `npm install autotoc` and writing
    the following simple demo script as given in `demo.js`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们需要做的全部！我们的包现在将出现在全局 npm 仓库中。我们可以通过（在一个新文件夹中）运行 `npm install autotoc` 并编写以下简单的演示脚本（如下所示
    `demo.js`）来使用它：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running `node demo.js` at the command line produces the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中运行 `node demo.js` 产生以下输出：
- en: '![Publishing a package to npm](img/image00227.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![将包发布到 npm](img/image00227.jpeg)'
- en: Running automated clients on the web
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在网络上运行自动化客户端
- en: It's fine to run tools like this against your own website. There are many use
    cases for this kind of technique. For example, a script that spiders through an
    entire site and checks every page can be a useful integration/smoke test.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对自己的网站运行此类工具是可以的。这类技术有许多用例。例如，一个爬遍整个网站并检查每一页的脚本可以是一个有用的集成/烟雾测试。
- en: Use cases that involve crawling sites that you don't own require more care.
    Any public-facing site that you could visit in a browser, you could also access
    with an automated client like this. But issuing a large number of automated requests
    against the same host is undesirable. It could be considered poor etiquette at
    best or a **Denial of Service** (**DoS**) attack at worst.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及爬取你并不拥有的网站的用例需要更加小心。任何你可以在浏览器中访问的公开网站，你也可以使用像这样的自动化客户端访问。但是，对同一主机发出大量自动化请求是不受欢迎的。这最多被认为是不良礼仪，最坏的情况可能是
    **拒绝服务**（**DoS**）攻击。
- en: 'Clients should set an appropriate `User-Agent` HTTP header. Some servers might
    reject requests from clients that don''t specify a `User-Agent` or don''t appear
    to be a browser. By convention, crawlers should send a `User-Agent` including
    the word *bot* in the name and ideally a URL to find out more about the bot. The
    request library makes it easy to specify headers by passing in an options object.
    For example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应设置适当的 `User-Agent` HTTP 头部。一些服务器可能会拒绝没有指定 `User-Agent` 或看起来不是浏览器的客户端的请求。按照惯例，爬虫应发送包含单词
    *bot* 的 `User-Agent`，并理想情况下提供一个可以了解更多关于爬虫信息的 URL。请求库通过传递一个选项对象来轻松指定头部。例如：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Crawlers should also check for a `robots.txt` file for each website and respect
    any rules it contains. See [http://www.robotstxt.org/robotstxt.html](http://www.robotstxt.org/robotstxt.html)
    for more information.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 爬虫也应该检查每个网站的 `robots.txt` 文件，并尊重其中包含的任何规则。更多信息请见 [http://www.robotstxt.org/robotstxt.html](http://www.robotstxt.org/robotstxt.html)。
- en: Finally, legitimate crawlers of third-party websites should also rate-limit
    their requests to avoid overwhelming the server.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三方网站的合法爬虫也应该限制其请求的速率，以避免服务器过载。
- en: Releasing a standalone tool to npm
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布独立工具到 npm
- en: 'Some of the `npm` packages we''ve used so far in this book have been command-line
    tools rather than libraries, for example Gulp. Creating a command-line tool package
    is very straightforward. First, we need to define the script that we want people
    to be able to invoke from the command line, as given in `cli.js`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本书到目前为止使用的某些 `npm` 包是命令行工具而不是库，例如 Gulp。创建命令行工具包非常简单。首先，我们需要定义用户可以从命令行调用的脚本，如
    `cli.js` 中所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This looks much like our demo script from before, with a couple of differences:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与之前的演示脚本非常相似，但有几点不同：
- en: The line at the beginning of the script (called a **shebang line**, starting
    with `#!`) indicates to the OS that this script should be executed using Node.js
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本开头的一行（称为 **shebang 行**，以 `#!` 开头）指示操作系统使用 Node.js 来执行此脚本。
- en: The URL to crawl is taken from a command-line argument
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要爬取的 URL 来自命令行参数
- en: 'Now we just need to specify this script in our `package.json`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在 `package.json` 中指定这个脚本：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To publish our updated package, we first need to update our version number.
    You can update this in the package directly or use the `npm` version command,
    for example
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布我们的更新包，我们首先需要更新我们的版本号。你可以在包中直接更新或在 `npm` 中使用版本命令，例如
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This automatically updates the version number to the next major/minor/patch
    version (as specified) and makes a new git commit with this change.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这会自动将版本号更新到下一个主/次/补丁版本（如指定），并创建一个新的 git 提交来反映这一变化。
- en: Since we are already logged into npm, we can now publish the new version of
    our package by running `npm publish` again.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在 npm 中登录，现在我们可以通过再次运行 `npm publish` 来发布我们包的新版本。
- en: 'We can now make use of our CLI tool as follows (in a new command prompt window):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以这样使用我们的 CLI 工具（在一个新的命令提示符窗口中）：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using Node.js modules in the browser
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中使用 Node.js 模块
- en: At the beginning of this chapter, we discussed creating universal modules that
    can run under Node.js or in the browser. There is another way that we can allow
    our code to run in both environments.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我们讨论了创建可以在 Node.js 或浏览器中运行的通用模块。我们还可以让我们的代码在这两种环境中运行。
- en: Browserify ([http://browserify.org/](http://browserify.org/)) allows you to
    make use of Node.js modules in the browser. It bundles up your code together with
    its dependencies. It also provides browser-compatible shims to emulate Node.js
    built-in modules.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify ([http://browserify.org/](http://browserify.org/)) 允许你在浏览器中使用 Node.js
    模块。它将你的代码及其依赖项打包在一起。它还提供了浏览器兼容的垫片来模拟 Node.js 内置模块。
- en: 'You can install Browserify via npm:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 npm 安装 Browserify：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Browserify is typically used to package applications. For example, if we wanted
    to package our demo usage of autotoc from the previous section, we could run:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify 通常用于打包应用程序。例如，如果我们想打包上一节中演示的 autotoc 使用，我们可以运行：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Browserify will create a single JavaScript file containing the code from `demo.js`,
    along with its dependencies and transitive dependencies. If we include this in
    an HTML page, we can now see it working in the browser console:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify 将创建一个包含 `demo.js` 代码及其依赖项和传递依赖项的单个 JavaScript 文件。如果我们将其包含在 HTML 页面中，现在我们可以在浏览器控制台中看到它的工作情况：
- en: '![Using Node.js modules in the browser](img/image00228.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![在浏览器中使用 Node.js 模块](img/image00228.jpeg)'
- en: 'You can also use Browserify to generate browser-compatible files for individual
    modules, following the Universal Module Definition pattern discussed earlier in
    this chapter. For example, to create a UMD version of our `autotoc.js` module
    from the previous section, we could run:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 Browserify 生成符合浏览器规范的独立模块文件，遵循本章前面讨论的通用模块定义模式。例如，为了从上一节创建 `autotoc.js`
    模块的 UMD 版本，我们可以运行：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We could now make use of this via RequireJS. Let''s create a simple application
    that uses autotoc together with jQuery to generate an HTML ToC. First we''ll need
    an HTML file to contain our application and include RequireJS, as given in `browser/index.html`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以利用 RequireJS 来使用它。让我们创建一个简单的应用程序，该应用程序使用 autotoc 与 jQuery 一起生成 HTML 目录。首先我们需要一个
    HTML 文件来包含我们的应用程序并包含 RequireJS，如 `browser/index.html` 中所示：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can implement our application itself, as given in `browser/scripts/main.js`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现我们的应用程序本身，如 `browser/scripts/main.js` 中所示：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This results in the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Using Node.js modules in the browser](img/image00229.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![在浏览器中使用 Node.js 模块](img/image00229.jpeg)'
- en: Controlling Browserify's output
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制Browserify的输出
- en: Note that, by default, Browserify generates a bundle of your code and all of
    its dependencies. Including transitive dependencies, this can result in a very
    large file. The autotoc module is only 42 lines long, but the generated bundle
    is over 80,000 lines! Our application above includes both jQuery (via RequireJS)
    and a version of Cheerio (via Browserify). This is particularly wasteful, since
    much of Cheerio is a re-implementation of jQuery.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下，Browserify 会生成一个包含您的代码及其所有依赖项的包。包括传递依赖项，这可能导致一个非常大的文件。autotoc 模块只有
    42 行长，但生成的包却有超过 80,000 行！我们上面的应用程序包括 jQuery（通过 RequireJS）和 Cheerio 的一个版本（通过 Browserify）。这尤其浪费，因为
    Cheerio 的大部分是 jQuery 的重新实现。
- en: You can instruct Browserify to exclude specific modules and to exclude all external
    modules. This is particularly useful for third-party modules that follow the UMD
    pattern. These do not need to be *browserified* and can be excluded from the generated
    bundle. You can then load them separately in the browser, via an additional script
    tag or using RequireJS.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指示 Browserify 排除特定的模块以及排除所有外部模块。这对于遵循 UMD 模式的第三方模块尤其有用。这些模块不需要被 *browserified*，并且可以从生成的包中排除。然后您可以在浏览器中单独加载它们，通过额外的脚本标签或使用
    RequireJS。
- en: For more information on Browserify's usage options, see the official documentation
    at [https://github.com/substack/node-browserify#usage](https://github.com/substack/node-browserify#usage).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Browserify 使用选项的更多信息，请参阅官方文档[https://github.com/substack/node-browserify#usage](https://github.com/substack/node-browserify#usage)。
- en: Browserify provides a lot of flexibility for bundling modules in different ways.
    It is particularly useful when working on a single codebase with both server-side
    and client-side functionality. It allows you to write all of your code using Node.js-style
    modules and to easily share modules between the server and the client.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify 为以不同方式打包模块提供了很多灵活性。当在具有服务器端和客户端功能的单一代码库上工作时尤其有用。它允许您使用 Node.js 风格的模块编写所有代码，并轻松地在服务器和客户端之间共享模块。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have written a multi-environment module following the universal
    module definition pattern, created an npm package for a library and a command-line
    tool, and packaged Node.js code for the browser using Browserify.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们编写了一个遵循通用模块定义模式的跨环境模块，为库和命令行工具创建了一个 npm 包，并使用 Browserify 将 Node.js 代码打包到浏览器中。
- en: This demonstrates the flexibility of Node.js and the range of use cases for
    JavaScript and npm beyond just server-side code. In the final chapter, we'll look
    at the broader context around Node.js. We'll see some of the newer languages and
    upcoming language features for the platform and how Node.js interacts with other
    platforms like .NET.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了 Node.js 的灵活性和 JavaScript 以及 npm 在服务器端代码之外的用例范围。在最后一章中，我们将探讨 Node.js 的更广泛背景。我们将看到一些针对该平台的新语言和即将推出的语言特性，以及
    Node.js 如何与其他平台如 .NET 交互。
