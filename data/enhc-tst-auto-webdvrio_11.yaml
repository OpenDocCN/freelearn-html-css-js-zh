- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Echo Location – Skipping the Page Object Model
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回声定位 - 跳过页面对象模型
- en: 'So far, we have used the **Page Object Model** (**POM**) to encapsulate the
    UI elements and interactions with a page within an object. We can usually see
    our target objective *clearly* with the XPath or CSS locator, but consider the
    superheroes who get the job done blindly in the dark. While the POM has many merits,
    there are scenarios where finding objects by text alone, in the dark, based on
    some clues, can offer advantages:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用**页面对象模型**（**POM**）来封装页面内的UI元素和交互。我们通常可以用XPath或CSS定位器清楚地看到我们的目标目标，但考虑一下那些在黑暗中盲目完成任务的超人。虽然POM有很多优点，但在某些情况下，仅根据一些线索在黑暗中通过文本找到对象可以提供优势：
- en: '**Quick prototyping and simplified test creation**: For quick and dirty testing
    or prototyping, it might be overkill to establish a full-fledged POM of thousands
    of objects. In such cases, directly locating elements can speed up the initial
    test development process.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速原型设计和简化测试创建**：对于快速且简单的测试或原型设计，建立包含数千个对象的完整POM可能有些过度。在这种情况下，直接定位元素可以加快初始测试开发过程。'
- en: '**Handling elements with dynamic content**: In modern web applications, the
    content can be highly dynamic. Elements may not have fixed IDs, classes, or other
    attributes. Text content is often more stable in later releases behind the scenes
    in the DOM.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理动态内容的元素**：在现代Web应用程序中，内容可能非常动态。元素可能没有固定的ID、类或其他属性。文本内容在DOM背后的后期版本中通常更稳定。'
- en: '**Code readability**: Tests written with direct text queries can sometimes
    be more readable and self-explanatory. Anyone reading the test can understand
    the user interactions being mimicked, without needing to dive into the page objects
    to understand what each method does.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码可读性**：使用直接文本查询编写的测试有时可能更易读且更具自解释性。任何阅读测试的人都可以理解正在模拟的用户交互，而无需深入研究页面对象来了解每个方法的作用。'
- en: 'In this chapter, we''ll cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: A reduced code base
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少的代码库
- en: Automation in plain English
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纯英文进行自动化
- en: Getting a visible button, field, and list by name
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名称获取可见的按钮、字段和列表
- en: Getting a visible element from a collection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从集合中获取可见元素
- en: A reduced code base
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少的代码库
- en: Skipping the POM reduces the amount of code you have to maintain. This can be
    particularly beneficial in smaller projects or proof-of-concept implementations,
    where quick development is more important than long-term maintainability.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过POM减少了需要维护的代码量。这在小型项目或概念验证实现中尤其有益，在这些项目中，快速开发比长期可维护性更重要。
- en: While a “text-based” approach has its merits, it’s crucial to note that this
    is not a one-size-fits-all solution. It is intended to remain highly reliable,
    reducing the amount of maintenance required.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“基于文本”的方法有其优点，但重要的是要注意，这并不是一个一刀切解决方案。它的目的是保持高度可靠性，减少维护所需的数量。
- en: In this chapter, we will enhance our element location by passing just text.
    Which method is used will provide a clue as to the node types to return for consideration.
    What does it mean if we can just click `setValueAdv("First name", "Paul")` into
    the **First Name** field, or even select **2** from the **Number of** **Guests**
    list?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过仅传递文本来增强我们的元素定位。使用的方法将提供有关要考虑的节点类型的线索。如果我们只需将`setValueAdv("First name",
    "Paul")`点击到**名字**字段，或者甚至从**客人数量**列表中选择**2**，这意味着什么呢？
- en: We will enhance our three custom functions, allowing them to identify elements
    only based on a string. In addition to passing an object, a simple text string
    will be passed to the `clickAdv()`, `setValueAdv()`, and `selectAdv()` methods.
    This way, we can eliminate some of the page objects entirely.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将增强我们的三个自定义函数，使它们能够仅基于字符串识别元素。除了传递一个对象外，一个简单的文本字符串还将传递给`clickAdv()`、`setValueAdv()`和`selectAdv()`方法。这样，我们可以完全消除一些页面对象。
- en: 'This chapter covers the following main topics:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主要内容：
- en: Automation in plain English
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纯英文进行自动化
- en: Clicking a named button or link
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击一个命名的按钮或链接
- en: Entering text into a named field
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个命名的字段中输入文本
- en: Selecting an item from a named list
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个命名的列表中选择一个项目
- en: Chasing a rabbit hole more than three layers deep
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪超过三层深度的兔子洞
- en: Automation in plain English
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯英文进行自动化
- en: 'We will continue to further modify our custom methods by allowing two different
    types of classes to be passed. Our methods still support a `WebdriverIO WebElement`,
    but now, we will enhance them with a string. For example, let’s say we want to
    click the **HALLOWEEN PARTY** button at the top of the CandyMapper site. Consider
    this code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续进一步修改我们的自定义方法，允许传递两种不同类型的类。我们的方法仍然支持`WebdriverIO WebElement`，但现在，我们将通过字符串来增强它们。例如，假设我们想点击CandyMapper网站顶部的**万圣节派对**按钮。考虑以下代码：
- en: '![Figure 11.1 – A DevTools view of the HALLOWEEN PARTY link](img/B19395_11_1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – HALLOWEEN PARTY链接的DevTools视图](img/B19395_11_1.jpg)'
- en: Figure 11.1 – A DevTools view of the HALLOWEEN PARTY link
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – HALLOWEEN PARTY链接的DevTools视图
- en: 'Here is the POM approach to find the link:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是POM方法来查找链接：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By using the echo location superpower, this line of code could be smart enough
    to find the proper link with just this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用echo位置超级能力，这一行代码可以足够智能，只需这一行就能找到正确的链接：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you could enter an email into a field:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在字段中输入电子邮件：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You could also add a total of two guests to accompany you to the party:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加总共两名客人陪你参加派对：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we can enhance the method to split along a path that is either an object
    or a string; in this case, we can use our `getValidObject()` to return a collection
    of visible elements that contain the string. In addition, we can deduce the type
    of elements to seek, based on the verb of the action being called. `ClickAdv()`
    will look for buttons, links, and similar elements. `SetValue()` will look for
    input fields or `textarea` nodes. `SelectAdv()` will interact with lists.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以增强该方法，使其沿着一个路径分割，该路径可以是对象或字符串；在这种情况下，我们可以使用我们的`getValidObject()`来返回包含该字符串的可见元素集合。此外，我们可以根据被调用的动作的动词推断要查找的元素类型。`ClickAdv()`将查找按钮、链接和类似元素。`SetValue()`将查找输入字段或`textarea`节点。`SelectAdv()`将与列表交互。
- en: Quick tip
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提示
- en: While we could extend this to our `assertAdv()` function, it is not recommended.
    The problem is that the `assertAdv()` function with a string would need a lot
    more context. It would be nearly impossible to determine whether we are validating
    a button state, a field value, a list item, or some displayed text. It is better
    to keep this simple and just confirm that the text we seek is visible on the page
    and highlight all potential matches. For anything else, just pass the `WebElement`
    class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将此扩展到我们的`assertAdv()`函数，但这是不建议的。问题是带有字符串的`assertAdv()`函数需要更多的上下文。几乎不可能确定我们是在验证按钮状态、字段值、列表项或某些显示的文本。最好是保持简单，只确认我们寻求的文本在页面上是可见的，并突出所有潜在的匹配项。对于其他任何内容，只需传递`WebElement`类。
- en: Our first step is to extend a code path that will interact with both `WebElement`
    and a string in the `clickAdv()` method. This same process will apply to the `getValidElement()`
    function, which we’ll do in the following section. Lastly, the `SetValueAdv()`
    and `Selectadv()` functions will be modified with their relative sections in `getValidElement()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是扩展一个代码路径，该路径将在`clickAdv()`方法中与`WebElement`和字符串交互。这个过程将适用于`getValidElement()`函数，我们将在下一节中这样做。最后，`SetValueAdv()`和`Selectadv()`函数将使用`getValidElement()`中的相关部分进行修改。
- en: Getting a named button
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取命名的按钮
- en: 'In each of the three custom functions, we will extend the element types that
    are passed to include strings like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个自定义函数中的每一个，我们将扩展传递给元素的类型，包括这样的字符串：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If a string is passed, we will use it to identify a valid element of the type
    passed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了一个字符串，我们将使用它来识别传递的类型的有效元素：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we provide a clue that this element will be a button. The same
    will be done next for returning a field to set a value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供了一个线索，这个元素将是一个按钮。接下来，我们将以相同的方式返回一个设置值的字段。
- en: Getting a named input field
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取命名的输入字段
- en: 'The same will be modified for `setValueAdv` in a similar fashion. However,
    we will instruct `getValidElement` to seek out an input or `textarea` field class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将以类似的方式修改`setValueAdv`。然而，我们将指示`getValidElement`寻找输入或`textarea`字段类：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As with the last two functions, we will extend `selectAdv()` with a final clue
    string.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与最后两个函数一样，我们将使用一个最终的线索字符串来扩展`selectAdv()`。
- en: Getting a named list
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取命名的列表
- en: 'Finally, `selectAdv()` will be modified as well. The types of elements that
    might match will be listed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`selectAdv()`也将被修改。可能匹配的元素类型将被列出：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that these three methods are updated, we need to enhance the `getValidElement()`
    method to return an element that fits each verb type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些三种方法都已更新，我们需要增强`getValidElement()`方法，使其返回适合每种动词类型的元素。
- en: Getting a visible button by name
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过名称获取可见按钮
- en: 'The first enhancement in the `getValidElement()` method is to allow a string
    to be passed, as with the three preceding methods:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`getValidElement()` 方法的第一项改进是允许传递一个字符串，就像前三个方法一样：'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first check that we can perform is to see whether there are *any* elements
    that might match what we seek. In this case, we can leverage both an XPath and
    a CSS locator for a second time. This XPath locator will seek any node that contains
    the text passed to the method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行的第一项检查是查看是否有任何元素可能匹配我们想要寻找的内容。在这种情况下，我们可以再次利用 XPath 和 CSS 定位器。这个 XPath
    定位器将寻找包含传递给方法的文本的任何节点：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If there are no elements returned, a second attempt will be done with a CSS
    selector using the `href` property. This property often contains the text string
    in a lowercase set, oriented by dashes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有返回元素，将进行第二次尝试，使用 CSS 选择器并利用 `href` 属性。这个属性通常包含以连字符为导向的小写文本字符串：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we have three types of elements to sort through. Let us deal with each
    one separately, starting with a button for a click:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有三种类型的元素需要处理。让我们分别处理每一个，从点击按钮开始：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If this returns no matching element, we can try this case-insensitive approach:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这仍然没有返回匹配的元素，我们可以尝试这个不区分大小写的方案：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we have a good shot at finding a button based solely on a string passed
    into the function. Let us do the same for input fields and text areas.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有很好的机会仅基于传递给函数的字符串找到按钮。让我们也以相同的方式处理输入字段和文本区域。
- en: Getting a visible field by name
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过名称获取可见字段
- en: 'Next, we have to gather a collection of fields:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须收集一系列字段：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If there are no matches, we will take a second shot at finding text areas relative
    to a label:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配项，我们将再次尝试找到与标签相关的文本区域：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, we will do the same for a collection of lists.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将对一系列列表执行相同的操作。
- en: Getting a visible list by name
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过名称获取可见列表
- en: 'Next, we will try to find a list element based on the text:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试根据文本找到列表元素：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If no `Select` element matches either of these, then we take a final shot by
    searching for a combo box relative to a label:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `Select` 元素与这些匹配，我们将通过搜索与标签相关的组合框进行最后的尝试：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are not done quite yet. The collection of elements returned must be filtered
    for visibility.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。必须对返回的元素集合进行过滤以确定其可见性。
- en: Getting a visible element from a collection
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从集合中获取可见元素
- en: 'Now that we have a collection of potential elements, we will parse through
    them to find the first one that is visible:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一系列潜在元素，我们将解析它们以找到第一个可见的元素：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, we have made an educated guess as to which element is being
    referenced. All we need to do is return the element to be interacted with from
    the calling method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们已经对被引用的元素做出了合理的猜测。我们只需要从调用方法中返回要交互的元素：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, you might see ways to further identify collections, We encourage
    you to modify the two or three sample locators to work with your particular framework,
    but...
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你可能看到了进一步识别集合的方法，我们鼓励你修改两个或三个示例定位器以适应你特定的框架，但...
- en: Beware the endless rabbit hole!
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小心无底洞！
- en: As we come to the end of this section, you may have noticed that we have given
    no more than three examples to dynamically locate multiple nodes by text. And
    for good reason. You might spend hours trying to find a fifth or sixth template
    that will return the perfect collection of elements. We recommend limiting the
    search to just three attempts. It is just not worth the time to go deeper down
    this rabbit hole, reducing accuracy and slowing the result search time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接近本节的结尾时，你可能已经注意到我们没有给出超过三个示例来动态地通过文本定位多个节点。而且有很好的理由。你可能会花费数小时试图找到第五个或第六个模板，它将返回完美的元素集合。我们建议将搜索限制在三次尝试之内。深入这个兔子洞不值得，这会降低准确性并减慢结果搜索时间。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we demonstrated how to dynamically locate elements using just
    a string, much like how a superhero uses their keen senses to pinpoint villains
    just by their silhouette. We employed a clue from each action, narrowing down
    the pool of potential elements to those pertinent to the requested action, akin
    to a superhero zeroing in on their target. Lastly, we established a boundary on
    the number of attempts to identify a valid element, similar to how a superhero
    might limit their efforts in a search before changing tactics.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何仅使用字符串动态定位元素，就像超级英雄利用敏锐的感官仅凭轮廓就能定位恶棍一样。我们利用每个动作的线索，缩小潜在元素的范围，只关注与请求的动作相关的元素，就像超级英雄锁定目标一样。最后，我们为识别有效元素尝试的次数设定了上限，这类似于超级英雄在改变策略之前可能会限制他们的搜索努力。
- en: In the next chapter, we will explore expanding our testing to multiple environments,
    paralleling how a superhero adapts to different challenges in various suburbs
    of Metropolis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将我们的测试扩展到多个环境，类似于超级英雄如何适应大都会不同郊区的各种挑战。
