- en: Chapter 1. Building a Simple Blog
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 构建一个简单的博客
- en: We're going to begin by assuming that your experience in Backbone is very minimal;
    in fact, even if you've never used Backbone before, you should still be able to
    follow along just fine. The application we're going to build in this chapter is
    a very simple blog. As blogs go, it's going to have very few features; there will
    be posts that viewers can read and make comments on. However, it will introduce
    you to every major feature in the Backbone library, get you comfortable with the
    vocabulary, and how these features work together in general.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设您在 Backbone 方面的经验非常有限；实际上，即使您以前从未使用过 Backbone，您也应该能够很好地跟随。在本章中，我们将构建一个非常简单的博客应用程序。作为一个博客，它将具有非常少的功能；将会有供观众阅读和评论的帖子。然而，它将向您介绍
    Backbone 库中的每个主要功能，让您熟悉词汇，并了解这些功能通常是如何一起工作的。
- en: 'By the end of this chapter, you''ll know how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将知道如何：
- en: Use Backbone's model, collection, and view components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Backbone 的模型、集合和视图组件
- en: Create a Backbone router that controls everything the user sees on the screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Backbone 路由器来控制用户在屏幕上看到的所有内容
- en: Program the server side with Node.js (and Express.js) to create a backend for
    our Backbone app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node.js（以及 Express.js）编程服务器端以创建我们 Backbone 应用的后端
- en: So let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们开始吧！
- en: Setting up the application
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置应用程序
- en: Every application has to be set up, so we'll begin with that. Create a folder
    for your project—I'll call mine `simpleBlog`—and inside that, create a file named
    `package.json`. If you've used Node.js before, you know that the `package.json`
    file describes the project; lists the project home page, repository, and other
    links; and (most importantly for us) outlines the dependencies for the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都需要设置，因此我们将从这里开始。为您的项目创建一个文件夹——我将称之为 `simpleBlog`——然后在其中创建一个名为 `package.json`
    的文件。如果您之前使用过 Node.js，您知道 `package.json` 文件描述了项目；列出项目主页、仓库和其他链接；并且（对我们来说最重要的是）概述了应用程序的依赖项。
- en: 'Here''s what the `package.json` file looks like:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `package.json` 文件的样子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: 'This is a pretty bare-bones `package.json` file, but it has all the important
    bits. The `name`, `description`, and `version` properties should be self-explanatory.
    The `dependencies` object lists all the npm packages that this project needs to
    run: the key is the name of the package and the value is the version. Since we''re
    building an ExpressJS backend, we''ll need the `express` package. The `ejs` package
    is for our server-side templates and `bourne` is our database (more on this one
    later).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当基础的 `package.json` 文件，但它包含了所有重要的部分。`name`、`description` 和 `version` 属性应该是自解释的。`dependencies`
    对象列出了此项目运行所需的所有 npm 包：键是包的名称，值是版本。由于我们正在构建 ExpressJS 后端，我们需要 `express` 包。`ejs`
    包用于我们的服务器端模板，而 `bourne` 是我们的数据库（关于这一点稍后会有更多介绍）。
- en: 'The `devDependencies` property is similar to the `dependencies` property, except
    that these packages are only required for someone working on the project. They
    aren''t required to just use the project. For example, a build tool and its components,
    such as Grunt, would be development dependencies. We want to use a package called
    `nodemon`. This package is really handy when building a Node.js backend: we can
    have a command line that runs the `nodemon server.js` command in the background
    while we edit `server.js` in our editor. The `nodemon` package will restart the
    server whenever we save changes to the file. The only problem with this is that
    we can''t actually run the `nodemon server.js` command on the command line, because
    we''re going to install `nodemon` as a local package and not a global process.
    This is where the `scripts` property in our `package.json` file comes in: we can
    write simple script, almost like a command-line alias, to start `nodemon` for
    us. As you can see, we''re creating a script called `start`, and it runs `nodemon
    server.js`. On the command line, we can run `npm start`; npm knows where to find
    the `nodemon` binary and can start it for us.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`devDependencies` 属性与 `dependencies` 属性类似，但不同的是，这些包仅对在项目上工作的人是必需的。它们不是使用项目所必需的。例如，构建工具及其组件，如
    Grunt，将是开发依赖项。我们想要使用一个名为 `nodemon` 的包。这个包在构建 Node.js 后端时非常方便：我们可以在编辑器中编辑 `server.js`
    的同时，在后台运行 `nodemon server.js` 命令。`nodemon` 包会在我们保存文件更改时重启服务器。唯一的问题是，我们实际上不能在命令行上运行
    `nodemon server.js` 命令，因为我们打算将 `nodemon` 作为本地包安装，而不是全局进程。这就是我们的 `package.json`
    文件中的 `scripts` 属性发挥作用的地方：我们可以编写简单的脚本，几乎就像命令行别名一样，为我们启动 `nodemon`。正如你所看到的，我们创建了一个名为
    `start` 的脚本，它运行 `nodemon server.js`。在命令行中，我们可以运行 `npm start`；npm 知道在哪里找到 `nodemon`
    二进制文件，并为我们启动它。'
- en: 'So, now that we have a `package.json` file, we can install the dependencies
    we''ve just listed. On the command line, change to the current directory to the
    project directory, and run the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有了 `package.json` 文件，我们可以安装我们刚刚列出的依赖项。在命令行中，切换到当前目录到项目目录，并运行以下命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You'll see that all the necessary packages will be installed. Now we're ready
    to begin writing the code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到所有必要的包都将被安装。现在我们准备好开始编写代码了。
- en: Starting with the server
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器开始
- en: I know you're probably eager to get started with the actual Backbone code, but
    it makes more sense for us to start with the server code. Remember, good Backbone
    apps will have strong server-side components, so we can't ignore the backend completely.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你可能迫不及待地想要开始实际的 Backbone 代码，但对我们来说，从服务器代码开始更合理。记住，好的 Backbone 应用程序将拥有强大的服务器端组件，所以我们不能完全忽略后端。
- en: 'We''ll begin by creating a `server.js` file in our project directory. Here''s
    how that begins:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的项目目录中创建一个 `server.js` 文件。以下是它的开始部分：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you''ve used Node.js, you know that the `require` function can be used to
    load Node.js components (`path`) or npm packages (`express` and `bourne`). Now
    that we have these packages in our application, we can begin using them as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过 Node.js，你就知道可以使用 `require` 函数来加载 Node.js 组件（`path`）或 npm 包（`express`
    和 `bourne`）。现在我们已经在我们的应用程序中有了这些包，我们可以开始如下使用它们：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first variable here is `app`. This is our basic Express application object,
    which we get when we call the `express` function. We'll be using it a lot in this
    file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个变量是 `app`。这是我们基本的 Express 应用程序对象，当我们调用 `express` 函数时就会得到它。我们将在文件中大量使用它。
- en: 'Next, we''ll create two `Bourne` objects. As I said earlier, `Bourne` is the
    database we''ll use in our projects in this book. This is a simple database that
    I wrote specifically for this book. To keep the server side as simple as possible,
    I wanted to use a document-oriented database system, but I wanted something serverless
    (for example, SQLite), so you didn''t have to run both an application server and
    a database server. What I came up with, `Bourne`, is a small package that reads
    from and writes to a JSON file; the path to that JSON file is the parameter we
    pass to the constructor function. It''s definitely not good for anything bigger
    than a small learning project, but it should be perfect for this book. In the
    real world, you can use one of the excellent document-oriented databases. I recommend
    MongoDB: it''s really easy to get started with, and has a very natural API. Bourne
    isn''t a drop-in replacement for MongoDB, but it''s very similar. You can check
    out the simple documentation for Bourne at [https://github.com/andrew8088/bourne](https://github.com/andrew8088/bourne).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建两个`Bourne`对象。正如我之前所说的，`Bourne`是我们将在本书的项目中使用的数据库。这是一个专门为本书编写的简单数据库。为了尽可能简化服务器端，我想使用文档数据库系统，但我想使用无服务器（例如，SQLite）的，这样您就不必同时运行应用程序服务器和数据库服务器。我想出的，`Bourne`，是一个小包，它从JSON文件中读取并写入；该JSON文件的路径是我们传递给构造函数的参数。它绝对不适合比小型学习项目更大的任何东西，但应该非常适合这本书。在现实世界中，您可以使用优秀的文档数据库之一。我推荐MongoDB：它很容易入门，并且有一个非常自然的API。Bourne不是MongoDB的直接替代品，但它非常相似。您可以在[Bourne的简单文档](https://github.com/andrew8088/bourne)中查看。
- en: 'So, as you can see here, we need two databases: one for our blog posts and
    one for comments (unlike most databases, Bourne has only one table or collection
    per database, hence the need for two).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如您在这里可以看到的，我们需要两个数据库：一个用于我们的博客文章，另一个用于评论（与大多数数据库不同，Bourne每个数据库只有一个表或集合，因此需要两个）。
- en: 'The next step is to write a little configuration for our application:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们的应用编写一些配置：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a very minimal configuration for an Express app, but it''s enough for
    our usage here. We''re adding two layers of middleware to our application; they
    are "mini-programs" that the HTTP requests that come to our application will run
    through before getting to our custom functions (which we have yet to write). We
    add two layers here: the first is `express.json()`, which parses the JSON requests
    bodies that Backbone will send to the server; the second is `express.static()`,
    which will statically serve files from the path given as a parameter. This allows
    us to serve the client-side JavaScript files, CSS files, and images from the `public`
    folder.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的Express应用配置，但对我们这里的用途来说已经足够了。我们在应用中添加了两层中间件；它们是“小程序”，HTTP请求在到达我们自定义函数（我们尚未编写）之前将运行通过。我们在这里添加了两层：第一层是`express.json()`，它解析Backbone将发送到服务器的JSON请求体；第二层是`express.static()`，它将从作为参数给出的路径静态服务文件。这允许我们从`public`文件夹中提供客户端JavaScript文件、CSS文件和图像。
- en: You'll notice that both these middleware pieces are passed to `app.use()`, which
    is the method we call to choose to use these pieces.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这两个中间件组件都被传递给`app.use()`，这是我们用来选择使用这些组件的方法。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You'll notice that we're using the `path.join()` method to create the path to
    our public assets folder, instead of just doing `__dirname` and `'public'`. This
    is because Microsoft Windows requires the separating slashes to be backslashes.
    The `path.join()` method will get it right for whatever operating system the code
    is running on. Oh, and `__dirname` (two underscores at the beginning) is just
    a variable for the path to the directory this script is in.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们正在使用`path.join()`方法来创建公共资产文件夹的路径，而不是简单地使用`__dirname`和`'public'`。这是因为Microsoft
    Windows需要分隔符为反斜杠。`path.join()`方法将正确处理代码运行的任何操作系统。哦，还有`__dirname`（开头有两个下划线）只是一个变量，表示此脚本所在的目录路径。
- en: 'The next step is to create a route method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个路由方法：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Express, we can create a route calling a method on the app that corresponds
    to the desired HTTP verb (get, post, put, and delete). Here, we're calling `app.get()`
    and we pass two parameters to it. The first is the route; it's the portion of
    the URL that will come after your domain name. In our case, we're using an asterisk,
    which is a catchall; it will match any route that begins with a forward slash
    (which will be all routes). This will match every GET request made to our application.
    If an HTTP request matches the route, then a function, which is the second parameter,
    will be called.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 中，我们可以创建一个路由，该路由调用与所需 HTTP 动词（get、post、put 和 delete）相对应的方法。这里，我们调用
    `app.get()` 并向其传递两个参数。第一个是路由；它是域名之后的部分 URL。在我们的例子中，我们使用了一个星号，这是一个通配符；它将匹配以正斜杠开始的任何路由（即所有路由）。这将匹配对应用程序发出的每个
    GET 请求。如果 HTTP 请求与路由匹配，那么第二个参数，即一个函数，将被调用。
- en: This function takes two parameters; the first is the request object from the
    client and the second is the response object that we'll use to send our response
    back. These are often abbreviated to `req` and `res`, but that's just a convention,
    you could call them whatever you want.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数；第一个是来自客户端的请求对象，第二个是我们将用来发送响应的响应对象。这些通常被简称为 `req` 和 `res`，但这只是一种约定，你可以随意命名它们。
- en: 'So, we''re going to use the `res.render` method, which will render a server-side
    template. Right now, we''re passing a single parameter: the path to the template
    file. Actually, it''s only part of the path, because Express assumes by default
    that templates are kept in a directory named `views`, a convention we''ll be using.
    Express can guess the template package to use based on the file extension; that''s
    why we don''t have to select EJS as the template engine anywhere. If we had values
    that we want to interpolate into our template, we would pass a JavaScript object
    as the second parameter. We''ll come back and do this a little later.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用 `res.render` 方法，该方法将在服务器端渲染模板。现在，我们传递了一个单一参数：模板文件的路径。实际上，这仅仅是路径的一部分，因为
    Express 默认假设模板保存在名为 `views` 的目录中，这是我们将会使用的约定。Express 可以根据文件扩展名猜测要使用的模板包；这就是为什么我们不需要在任何地方选择
    EJS 作为模板引擎。如果我们有想要插入到模板中的值，我们将作为第二个参数传递一个 JavaScript 对象。我们稍后会回来做这件事。
- en: 'Finally, we can start up our application; I''ll choose to use the port `3000`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以启动我们的应用程序；我将选择使用端口 `3000`：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We'll be adding a lot more to our `server.js` file later, but this is what we'll
    start with. Actually, at this point, you can run `npm start` on the command line
    and open up `http://localhost:3000` in a browser. You'll get an error because
    we haven't made the view template file yet, but you can see that our server is
    working.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将在 `server.js` 文件中添加更多内容，但这是我们开始的起点。实际上，在这个阶段，你可以在命令行中运行 `npm start` 并在浏览器中打开
    `http://localhost:3000`。你会得到一个错误，因为我们还没有创建视图模板文件，但你可以看到我们的服务器正在运行。
- en: Creating the template
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模板
- en: All web applications will have templates of some kind. Most Backbone applications
    will be heavy on the frontend templates. However, we will need a single server-side
    template, so let's build that.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网络应用程序都将有一些类型的模板。大多数 Backbone 应用程序将在前端模板上投入大量精力。然而，我们需要一个单独的服务器端模板，所以让我们构建它。
- en: While you can choose from different template engines, many folks (and subsequently,
    tutorials) use Jade ([http://jade-lang.com/](http://jade-lang.com/)), which is
    like a Node.js version of the Ruby template engine Haml ([http://haml.info/](http://haml.info/)).
    However, as you already know, we're using EJS ([https://github.com/visionmedia/ejs](https://github.com/visionmedia/ejs)),
    which is similar to Ruby's ERB. Basically, we're writing regular HTML with template
    variables inside `<%=` `%>` tags.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以选择不同的模板引擎，但许多人（以及随后的教程）使用 Jade ([http://jade-lang.com/](http://jade-lang.com/))，这是
    Node.js 版本的 Ruby 模板引擎 Haml ([http://haml.info/](http://haml.info/))。然而，正如你已经知道的，我们正在使用
    EJS ([https://github.com/visionmedia/ejs](https://github.com/visionmedia/ejs))，它与
    Ruby 的 ERB 类似。基本上，我们是在 `<%=` `%>` 标签内写入带有模板变量的常规 HTML。
- en: 'As we saw earlier, Express will be looking for an `index.ejs` file in the `views`
    folder, so let''s create that and put the following code inside it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，Express 将在 `views` 文件夹中寻找一个 `index.ejs` 文件，所以让我们创建这个文件，并在其中放入以下代码：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At this point, if you still have the server running (remember `npm start` on
    the command line), you should be able to load `http://localhost:3000` without
    getting an error. The page will be blank, but you should be able to view the source
    and see the HTML code that we just wrote. That's a good sign; it means we're successfully
    sending stuff from the server to the client.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你还在运行服务器（记得命令行中的`npm start`），你应该能够加载`http://localhost:3000`而不会出现错误。页面将会是空的，但你应该能够查看源代码并看到我们刚刚编写的HTML代码。这是一个好兆头；这意味着我们成功地将东西从服务器发送到了客户端。
- en: Adding the public folder
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加公共文件夹
- en: Since Backbone is a frontend library, it's something we'll need to be serving
    to the client. We've set up our Express app to statically serve the files in our
    `public` directory, and added several script tags to the `index.ejs` file, but
    we haven't created these things yet.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Backbone是一个前端库，我们需要向客户端提供它。我们已经设置了Express应用来静态地提供`public`目录中的文件，并在`index.ejs`文件中添加了几个脚本标签，但我们还没有创建这些内容。
- en: 'So, create a directory named `public` in your project directory. Now download
    the latest versions of Underscore ([http://underscorejs.org](http://underscorejs.org)),
    Backbone ([http://backbonejs.org](http://backbonejs.org)), and jQuery ([http://jquery.com](http://jquery.com))
    and put them in this folder. It''s very likely that newer versions of these libraries
    have come out since this book was written. Since updates to these projects could
    change the way they work, it''s best to stick to the following versions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在你的项目目录中创建一个名为`public`的目录。现在下载Underscore的最新版本([http://underscorejs.org](http://underscorejs.org))、Backbone([http://backbonejs.org](http://backbonejs.org))和jQuery([http://jquery.com](http://jquery.com))，并将它们放入这个文件夹。这本书写完之后，这些库的新版本很可能已经发布。由于这些项目的更新可能会改变它们的工作方式，最好坚持以下版本：
- en: 'Backbone: Version 1.1.2'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Backbone: 版本 1.1.2'
- en: 'Underscore: Version 1.6.0'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Underscore: 版本 1.6.0'
- en: 'jQuery: Version 2.0.3'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jQuery: 版本 2.0.3'
- en: I will mention here that we're including Underscore and jQuery because Backbone
    depends on them. Actually, it only really depends on Underscore, but including
    jQuery does give us a few extra features that we'll be happy to have. If you need
    to support older versions of Internet Explorer, you'll also want to include the
    `json2.js` library ([https://github.com/douglascrockford/JSON-js](https://github.com/douglascrockford/JSON-js)),
    and switch to a version of jQuery 1 (jQuery 2 doesn't support older versions of
    IE).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里要提到的是，我们包括了Underscore和jQuery，因为Backbone依赖于它们。实际上，它主要依赖于Underscore，但包括jQuery确实给了我们一些额外的特性，我们会很高兴拥有。如果你需要支持旧版本的Internet
    Explorer，你还将需要包括`json2.js`库([https://github.com/douglascrockford/JSON-js](https://github.com/douglascrockford/JSON-js))，并切换到jQuery
    1版本（jQuery 2不支持旧版本的IE）。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Everything up to this point will be the same for each of the applications we
    are going to build in this book. In the downloaded files for this book, you can
    start each chapter by copying the template folder and working from there.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将要在本书中构建的每个应用都将使用相同的设置。在本书的下载文件中，你可以通过复制模板文件夹并从那里开始来开始每一章。
- en: Beginning the Backbone code
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写Backbone代码
- en: Once you have these three files in the `public` folder, you're ready to create
    the `app.js` file. In most of our Backbone applications, this is where the major
    portion of the work is going to be done. Now that everything else is in place,
    we can begin the app-specific code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在`public`文件夹中有这三个文件，你就可以开始创建`app.js`文件了。在我们大多数的Backbone应用中，大部分的工作将会在这里完成。现在其他所有东西都已经就绪，我们可以开始编写应用特定的代码。
- en: Creating a model and collection
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型和集合
- en: 'When building a Backbone app, the first thing I like to think about is this:
    what data will I be working with? This is my first question because Backbone is
    very much a data-driven library: almost everything the user will see and work
    will in some way be related to a piece of data. This is especially true in the
    simple blog we''re creating; every view will either be for viewing data (such
    as posts) or creating data (such as comments). The individual pieces of data that
    your application will work on (such as titles, dates, and text) will be grouped
    into what are usually called **models**: the posts and comments in our blog, the
    events in a calendar app, or the contacts in an address book. You get the idea.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Backbone应用时，我最先喜欢思考的是这个：我将处理哪些数据？这是我的第一个问题，因为Backbone是一个非常数据驱动的库：用户将看到和工作的几乎所有内容都会以某种方式与数据相关。这在我们在创建的简单博客中尤其如此；每个视图要么是用于查看数据（如帖子），要么是用于创建数据（如评论）。你的应用程序将处理的数据的各个部分（如标题、日期和文本）通常会被组合成所谓的**模型**：我们博客中的帖子、日历应用中的事件或地址簿中的联系人。你明白了。
- en: 'To start with, our blog will have a single model: the post. So, we create the
    appropriate Backbone model and collection classes. The code snippet for our model
    is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的博客将有一个单一模型：帖子。因此，我们创建了适当的Backbone模型和集合类。我们的模型代码片段如下：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's actually a lot going on in these five lines. First, all the main Backbone
    components are properties of the global variable `Backbone`. Each of these components
    is a class. JavaScript does not actually have proper classes; the prototype-backed
    functions pass for classes in JavaScript. They also have an extend method, which
    allows us to create subclasses. We pass an object to this `extend` method, and
    all properties or methods inside that object will become part of the new class
    we're creating, along with the properties and methods that make up the class we're
    extending.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这五行代码实际上有很多内容。首先，所有主要的Backbone组件都是全局变量`Backbone`的属性。这些组件中的每一个都是一个类。JavaScript实际上并没有真正的类；基于原型的函数在JavaScript中充当类的角色。它们还有一个`extend`方法，这允许我们创建子类。我们向这个`extend`方法传递一个对象，该对象内部的所有属性或方法都将成为我们正在创建的新类的一部分，以及我们正在扩展的类的属性和方法。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I want to mention early in the book that a lot of the similar code you see between
    Backbone apps is just convention. That's one of the reasons I love Backbone so
    much; there's a strong set of conventions to use, but you can totally work outside
    that box just as easily. Throughout the book, I'm going to do my best to show
    you not only the common conventions, but also how to break them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在本书的早期就提到，你会在Backbone应用之间看到很多类似的代码，这仅仅是惯例。这也是我喜欢Backbone的原因之一；有一套强大的惯例可以使用，但你完全可以轻松地跳出这个框。在整个书中，我将尽我所能向你展示不仅常见的惯例，还有如何打破它们。
- en: 'In this code, we''re creating a model class and a collection class. We actually
    don''t need to extend the model class at all for now; just a basic Backbone model
    will do. However, for the collection class, we''ll add two properties. First,
    we need to associate this collection with the appropriate model. We do this because
    a collection instance is basically just a glorified array for a bunch of model
    instances. The second property is `url`: this is the location of the collection
    on the server. What this means is that if we do a GET request to `/posts`, we''ll
    get back a JSON array of the posts in our database. This also means that we will
    be able to send a POST request to `/posts` and store a new post in our database.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个模型类和一个集合类。目前我们实际上根本不需要扩展模型类；一个基本的Backbone模型就足够了。然而，对于集合类，我们将添加两个属性。首先，我们需要将这个集合与适当的模型关联起来。我们这样做是因为集合实例基本上就是一个模型实例的华丽数组。第二个属性是`url`：这是集合在服务器上的位置。这意味着如果我们向`/posts`发起GET请求，我们将得到数据库中所有帖子的JSON数组。这也意味着我们可以向`/posts`发送POST请求并将新帖子存储到我们的数据库中。
- en: 'At this point, now that we have our data-handling classes on the frontend,
    I''d like to head back to the `server.js` file to create the routes required by
    our collection. So, in the file, add the following piece of code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，现在我们已经在前端有了数据处理类，我想回到`server.js`文件中创建我们集合所需的路由。所以，在文件中，添加以下代码片段：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First off, I'll mention that it's important that this call to `app.get` goes
    above our `/*` route. This is because of the fact that Express sends the requests
    through our routes sequentially and stops (by default, anyway) when it finds a
    matching one. Since `/posts` will match both `/posts` and `/*`, we need to make
    sure it hits the `/posts` route first.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我要提到，这个`app.get`调用必须在我们之前的`/*`路由之上。这是因为Express按顺序通过我们的路由发送请求，并在找到匹配项时停止（默认情况下是这样的）。由于`/posts`将匹配`/posts`和`/*`，我们需要确保它首先命中`/posts`路由。
- en: Next, you'll recall our `posts` database instance, which we made earlier. Here,
    we're calling its `find` method with only a callback, which will pass the callback
    an array of all the records in the database. Then, we can use the response object's
    `json` method to send that array back as JSON (the `Content-Type` header will
    be `application/json`). That's it!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你会想起我们之前创建的`posts`数据库实例。在这里，我们只使用回调调用它的`find`方法，这将传递一个包含数据库中所有记录的数组给回调。然后，我们可以使用响应对象的`json`方法将这个数组作为JSON发送回去（`Content-Type`头将是`application/json`）。就这样！
- en: 'While we''re here in the `server.js` file, we add the POST method for the same
    route: this is where the post data will come in from the browser and be saved
    to our database. The following is the code snippet for the `post()` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`server.js`文件中时，我们为相同的路由添加了POST方法：这是浏览器中的帖子数据将进入并保存到我们的数据库的地方。以下是为`post()`方法提供的代码片段：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `req` object has a body property, which is the JSON data that represents
    our post data. We can insert it directly into the `posts` database. When Backbone
    saves a model to the server in this way, it expects the response to be the model
    it sent with an ID added to it. Our database will add the ID for us and pass the
    updated model to the callback, so we only have to send it as a response to the
    browser, just as we did when sending all the posts in the previous method using
    `res.json`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`req`对象有一个`body`属性，它代表我们的帖子数据。我们可以直接将其插入到`posts`数据库中。当Backbone以这种方式将模型保存到服务器时，它期望响应是它发送的模型，并添加了一个ID。我们的数据库会为我们添加ID，并将更新后的模型传递给回调，所以我们只需要将其作为响应发送给浏览器，就像我们在使用`res.json`发送所有帖子时的上一个方法一样。'
- en: 'Of course, this isn''t very useful without a form to add posts to the database,
    right? We''ll build a form to create new posts soon, but for now we can manually
    add a post to the `simpleBlogPosts.json` file; this file may not exist yet because
    we haven''t written any data, so you''ll have to create it. Just make sure the
    file you create has the right name, that is, the same name as the parameter we
    passed to the `Bourne` constructor in our `server.js` file. I''m going to put
    the following code in that file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有表单来向数据库添加帖子这并不是很有用，对吧？我们很快就会构建一个表单来创建新的帖子，但现在我们可以手动将一个帖子添加到`simpleBlogPosts.json`文件中；这个文件可能还不存在，因为我们还没有写入任何数据，所以你必须创建它。只需确保你创建的文件有正确的名称，即与我们在`server.js`文件中传递给`Bourne`构造函数的参数相同的名称。我将在该文件中放入以下代码：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, you can make the `content` field longer; you get the idea. This is
    the JSON field that will be sent to our `Posts` collection instance and become
    a set of the `Post` model instance (in this case, a set of only one).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使`content`字段更长；你明白了这个意思。这是将被发送到我们的`Posts`集合实例的JSON字段，并成为一组`Post`模型实例（在这种情况下，仅有一个实例）。
- en: Performing a quick and dirty test
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行快速而简单的测试
- en: 'We''ve actually written enough code at this point to test things out. Head
    to `http://localhost:3000` in your browser and pop open a JavaScript console;
    I prefer Chrome and the Developer tools but use whatever you want. Now try the
    following lines:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了足够的代码来测试这些功能。在你的浏览器中转到`http://localhost:3000`，打开一个JavaScript控制台；我更喜欢Chrome和开发者工具，但你可以使用任何你想要的。现在尝试以下行：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can create a `Posts` collection instance; as you can see, it''s empty by
    default. We can load the data from the server by running the following line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`Posts`集合实例；正如你所见，它默认是空的。我们可以通过运行以下行从服务器加载数据：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A collection instance''s `fetch` method will send a GET request to the server
    (in fact, if your in-browser tools allow you to see a network request, you''ll
    see a GET request to `/posts`). It will merge the models that it receives from
    the server with the ones already in the collection. Give a second to get a response
    and then run the following lines:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 集合实例的`fetch`方法将向服务器发送一个GET请求（实际上，如果你的浏览器工具允许你查看网络请求，你会看到一个到`/posts`的GET请求）。它将合并从服务器接收到的模型与集合中已有的模型。给一点时间来获取响应，然后运行以下行：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Every collection instance has a `get` method; we pass it an ID and it will return
    the model instance with that ID (note that this is the `id` field from the database,
    and not the index number in the collection). Then, each model instance has a `get`
    method that we can use to get properties.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合实例都有一个 `get` 方法；我们传递一个 ID，它将返回具有该 ID 的模型实例（注意，这是数据库中的 `id` 字段，而不是集合中的索引号）。然后，每个模型实例都有一个
    `get` 方法，我们可以用它来获取属性。
- en: Writing some views
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一些视图
- en: In simple applications like the one we're creating in this chapter, most of
    the Backbone code that we write will be in views. I think it's fair to say that
    views can be the most challenging part of a Backbone app, because there are so
    many ways that almost everything can be done.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们本章创建的简单应用中，我们编写的 Backbone 代码的大部分将位于视图中。我认为可以说视图是 Backbone 应用中最具挑战性的部分，因为几乎可以做任何事情都有很多种方式。
- en: 'It''s important to understand that a `Backbone.View` instance and a screen
    full of web apps aren''t the same thing. One view in the browser may actually
    be many Backbone views. The first view that we want to create is a list of all
    the posts; these will be links to individual post pages. We could do this in two
    ways: as one big view or as multiple smaller views put together. In this instance,
    we''re going to be using multiple views. Here''s how we''ll break it down: each
    list item will be generated by its own view instance. Then, the wrapper around
    the list items will be another view. You can picture it as looking something like
    this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解一个 `Backbone.View` 实例和满屏的 Web 应用并不是同一回事。浏览器中的一个视图实际上可能是许多 Backbone 视图。我们想要创建的第一个视图是所有帖子的列表；这些将是链接到单个帖子页面的链接。我们可以用两种方式来做这件事：作为一个大视图或者作为多个较小视图的组合。在这个例子中，我们将使用多个视图。下面是如何分解的：每个列表项将由其自己的视图实例生成。然后，列表项周围的包装器将是另一个视图。你可以想象它看起来像这样：
- en: '![Writing some views](img/6997OS_01_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![编写一些视图](img/6997OS_01_04.jpg)'
- en: The PostListView class
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帖子列表视图类
- en: 'Let''s start with the child views. We''ll call this `PostListView` class. Naming
    views can be a little tricky. Often, we''ll have a view for the collection and
    a view for the model, and we''ll just append `View` to the end of their names,
    for example, `PostView` and `PostsView`. However, a model or collection will have
    multiple views. The one we''re about to write is to list our models. That''s why
    we''re calling it `PostListView`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从子视图开始。我们将这个类命名为 `PostListView`。视图的命名可能有点棘手。通常，我们会为集合和模型各有一个视图，我们只需在它们的名称末尾添加
    `View`，例如，`PostView` 和 `PostsView`。然而，一个模型或集合将会有多个视图。我们即将编写的视图是用来列出我们的模型。这就是为什么我们称之为
    `PostListView`：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Just like `Backbone.Model` and `Backbone.Collection`, we create a view class
    by extending `Backbone.View`. We have three properties in the extending object
    that make up our `PostListView`. The first one to look at is the `template` property;
    this property holds the template that our view will render. There are plenty of
    ways to create a template; in this case, we''re using the Underscore''s `template`
    function; we pass a string to `_.template`, and it returns a function which we
    can use to generate the correct HTML. Take a look at this template string: it''s
    regular HTML with variables placed within double curly braces.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `Backbone.Model` 和 `Backbone.Collection` 一样，我们通过扩展 `Backbone.View` 来创建一个视图类。在扩展对象中有三个属性组成了我们的
    `PostListView`。首先看看 `template` 属性；这个属性持有视图将要渲染的模板。创建模板有很多种方法；在这种情况下，我们使用 Underscore
    的 `template` 函数；我们向 `_.template` 传递一个字符串，它返回一个函数，我们可以用它来生成正确的 HTML。看看这个模板字符串：它是带有双大括号内变量的常规
    HTML。
- en: 'Next, let''s look at the `render` method. By convention, this is the method
    that we call to actually render the view. Every view instance has a property named
    `el`. This is the base element for the view instance: all other elements for this
    view go inside it. By default, this is a `div` element, but we''ve set the `tagName`
    property to `li`, which means we''ll get a list item instead. By the way, there''s
    also a `$el` property, which is a jQuery object wrapping the `el` property; this
    only works if we have jQuery included in our application.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `render` 方法。按照惯例，这是我们调用以实际渲染视图的方法。每个视图实例都有一个名为 `el` 的属性。这是视图实例的基本元素：这个视图的所有其他元素都放在它里面。默认情况下，这是一个
    `div` 元素，但我们已经将 `tagName` 属性设置为 `li`，这意味着我们将得到一个列表项。顺便说一句，还有一个 `$el` 属性，它是一个包装
    `el` 属性的 jQuery 对象；这只有在我们的应用程序中包含 jQuery 时才有效。
- en: 'So, inside our `render` function, we need to fill in this element. In this
    case, we''ll do that by assigning the `innerHTML` property. To get the HTML output,
    we use the template we just wrote. That''s a function, so we call it, and pass
    `this.model.toJSON()`. The `this.model` portion comes from when we instantiate
    this view: we''ll pass it a model. Every model has a `toJSON` method, which returns
    a raw object with just the attributes of the model. Since our model will have
    the `id` and `title` attributes, passing this to our template function will return
    a string with those values interpolated into the template string we wrote.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的 `render` 函数内部，我们需要填充这个元素。在这种情况下，我们将通过分配 `innerHTML` 属性来完成这个操作。为了获取 HTML
    输出，我们使用我们刚刚编写的模板。这是一个函数，所以我们需要调用它，并传递 `this.model.toJSON()`。`this.model` 部分来自我们实例化这个视图的时候：我们将传递一个模型。每个模型都有一个
    `toJSON` 方法，它返回一个只包含模型属性的原始对象。由于我们的模型将具有 `id` 和 `title` 属性，将这些传递给我们的模板函数将返回一个字符串，其中包含我们在模板字符串中写入的值。
- en: We end our `render` function by returning the view instance. Again, this is
    just convention. Because of this, we can use the convention where we get the element
    for this view via `view.render().el` ; this will render the view and then get
    the `el` property. Of course, there's no reason you couldn't return `this.el`
    directly from render.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过返回视图实例来结束 `render` 函数。再次强调，这只是一个约定。正因为如此，我们可以使用这样的约定：通过 `view.render().el`
    获取这个视图的元素；这将渲染视图并获取 `el` 属性。当然，没有理由我们不能直接从 `render` 中返回 `this.el`。
- en: 'There''s one more thing to address here, but it''s about Underscore and not
    Backbone. If you''ve used the Underscore''s `template` function before, you know
    that curly braces aren''t its normal delimiters. I''ve switched from the default
    `<%=` `%>` delimiters, because those are the delimiters for our server-side template
    engine. To change Underscore''s delimiters, just add the following code snippet
    to the top of our `app.js` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一件事需要解决，但它与 Underscore 和 Backbone 有关。如果你之前使用过 Underscore 的 `template` 函数，你知道花括号不是它的正常定界符。我已经从默认的
    `<%=` `%>` 定界符切换过来，因为那些是我们服务器端模板引擎的定界符。要更改 Underscore 的定界符，只需将以下代码片段添加到我们的 `app.js`
    文件顶部：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, you realize that we could make the delimiters whatever we want, as
    long as a regular expression can match it. I like the curly braces.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你意识到我们可以将定界符设置为任何我们想要的，只要正则表达式可以匹配它。我喜欢花括号。
- en: The PostsListView class
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`PostsListView` 类'
- en: 'Now that we have the view for our list items, we need the parent view that
    wraps those list items:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了列表项的视图，我们需要包裹这些列表项的父视图：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As views go, this is pretty simple, but we can learn a few new things from it.
    First, you'll notice that our template doesn't actually use any variables, so
    there's no reason for us to actually use a template. We could directly assign
    that HTML string as `this.el.innerHTML`; however, I like to do the little template
    dance anyway because I might change the template string to include some variables
    in the future.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就视图而言，这很简单，但我们可以从中学习一些新东西。首先，你会注意到我们的模板实际上没有使用任何变量，所以我们实际上没有必要使用模板。我们可以直接将那个
    HTML 字符串赋值给 `this.el.innerHTML`；然而，我喜欢做这个小模板舞步，因为将来我可能需要将模板字符串改为包含一些变量。
- en: 'Notice the second line of the `render` function: we''re finding an `ul` element;
    the same `ul` element that we just made as a child element of our root element,
    `this.el`. However, instead of using `this.el`, we''re using `this.$el`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `render` 函数的第二行：我们正在查找一个 `ul` 元素；就是我们刚刚作为根元素 `this.el` 的子元素创建的那个 `ul` 元素。然而，我们不是使用
    `this.el`，而是使用 `this.$el`。
- en: Next, we're looping over each item in the collection that we'll associate with
    this view (when we instantiate it). For each post in the collection, we will create
    a new `PostListView` class. We pass it an `options` object, which assigns the
    view's model as the current post. Then, we render the view and return the view's
    element. This is then appended to our `ul` object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们正在遍历我们将与这个视图关联的集合中的每个项目（当我们实例化它时）。对于集合中的每个帖子，我们将创建一个新的 `PostListView`
    类。我们传递一个 `options` 对象，将视图的模型设置为当前帖子。然后，我们渲染视图并返回视图的元素。然后，我们将这个元素附加到我们的 `ul` 对象上。
- en: We'll end by returning the view object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以返回视图对象结束。
- en: Using our views
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的视图
- en: 'We''re almost ready to actually display some content in the browser. Our first
    stop is back in the `server.js` file. We need to send the array of posts from
    the database to our `index.ejs` template. We do this by using the following code
    snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好在浏览器中实际显示一些内容了。我们的第一步是回到 `server.js` 文件。我们需要将数据库中的帖子数组发送到我们的 `index.ejs`
    模板。我们通过以下代码片段来完成这个操作：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Just as we do in the `/posts` route, we call `posts.find`. Once we get the results
    back, we render the view as before. But this time, we pass an object of values
    that we want to be able to use inside the template. In this case, that's only
    the posts. We have to run the results through `JSON.stringify`, because we can't
    serve an actual JavaScript object to the browser; we need a string representation
    (the JSON form) of the object.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`/posts`路由中所做的那样，我们调用`posts.find`。一旦我们得到结果，我们就像之前一样渲染视图。但这次，我们传递一个包含我们想要在模板内部使用的值的对象。在这种情况下，那就是帖子。我们必须通过`JSON.stringify`运行结果，因为我们不能向浏览器提供实际的JavaScript对象；我们需要对象的字符串表示形式（JSON形式）。
- en: 'Now, in the `index.ejs` file of the `views` folder, we can use these posts.
    Create a new script tag under the other ones we created before. This time, it
    will be an inline script:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`views`文件夹的`index.ejs`文件中，我们可以使用这些帖子。在之前创建的其他脚本标签下创建一个新的脚本标签。这次，它将是一个内联脚本：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line creates our posts collection; notice our use of the template
    tags. This is how to interpolate our `posts` array into the template. There's
    no typo there by the way; you might have expected an opening tag of `<%=`, but
    that opening tag will escape any possible characters in the string, which wrecks
    the quotes in our JSON code. So, we use `<%-`, which doesn't escape characters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建我们的帖子集合；请注意我们使用模板标签的方式。这就是如何将我们的`posts`数组插入到模板中。顺便说一句，那里没有打字错误；你可能期望有一个`<%=`的打开标签，但那个打开标签会转义字符串中的任何可能的字符，这会破坏我们JSON代码中的引号。所以我们使用`<%-`，它不会转义字符。
- en: The next line should be pretty straightforward. We're using jQuery to find our
    main element and appending the element of a new `PostsListView` instance. In the
    `options` object, we'll set the collection for this view. We then render it and
    find the element to append.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行应该是相当直接的。我们使用jQuery找到我们的主元素，并附加一个新`PostsListView`实例的元素。在`options`对象中，我们将为此视图设置集合。然后我们渲染它并找到要附加的元素。
- en: 'Now, make sure your server is running, and go to `http://localhost:3000` in
    the browser. You should see the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，确保你的服务器正在运行，然后在浏览器中转到`http://localhost:3000`。你应该会看到以下截图：
- en: '![Using our views](img/6997OS_01_01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![使用我们的视图](img/6997OS_01_01.jpg)'
- en: You're using the three main Backbone components—collection, models, and views—to
    create a mini-application! That's great, but we've only just got started.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用Backbone的三个主要组件——集合、模型和视图——来创建一个迷你应用程序！那太棒了，但我们才刚刚开始。
- en: Creating a router
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个路由器
- en: 'Go ahead and click on the link that we''ve just rendered. You''ll find that
    the URL changes and the page refreshes, but the content is still the same. This
    is because of a choice we''ve made in how our application works, that is, we made
    a catchall route that matches every GET request to our server. This means that
    `/`, `/posts/1`, and `/not/a/meaningful/link` show us the same content. This is
    what''s often called a **single-page** web application, that is, as much as possible
    is done on the client side, with JavaScript doing the heavy lifting, and not a
    different language on the server. With this kind of application, the whole thing
    could work off a single URL that never changes. However, this makes it hard to
    bookmark parts of the application. So, we want to make sure our application uses
    good URLs. To do this, we need to create a Backbone router as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 勇敢地点击我们刚刚渲染的链接。你会发现URL会改变，页面也会刷新，但内容仍然是相同的。这是因为我们在应用程序的工作方式上做出了一个选择，即我们创建了一个通配符路由，它匹配我们服务器的每个GET请求。这意味着`/`、`/posts/1`和`/not/a/meaningful/link`会显示相同的内容。这通常被称为**单页**Web应用程序，也就是说，尽可能多的操作是在客户端完成的，JavaScript负责繁重的工作，而服务器上不使用不同的语言。使用这种应用程序，整个应用程序可以仅使用一个永远不会改变的URL来运行。然而，这使得很难保存应用程序的部分。因此，我们想要确保我们的应用程序使用良好的URL。为此，我们需要创建一个如下所示的Backbone路由器：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s the first version of our `PostRouter`. You should see a familiar pattern
    as we begin: we extend the component `Backbone.Router`. The next important piece
    is the `initialize` method. We never add one of these to our model, collection,
    or views, but they can all take an `initialize` method. This is the constructor
    function for our router. In good old Backbone convention, we expect to get a single
    `options` parameter. We''ll expect this object to have two properties: `posts`
    and `main`. These should be the posts collection and the `div#main` element, respectively.
    We''ll assign these as properties on our router instance.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`PostRouter`的第一个版本。当我们开始时，你应该看到一个熟悉的模式：我们扩展了组件`Backbone.Router`。下一个重要的部分是`initialize`方法。我们从未在我们的模型、集合或视图中添加这样的方法，但它们都可以有一个`initialize`方法。这是我们的路由器的构造函数。按照古老的Backbone约定，我们期望得到一个单一的`options`参数。我们期望这个对象有两个属性：`posts`和`main`。这些应该是帖子集合和`div#main`元素，分别。我们将这些分配为路由器实例的属性。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, the `initialize` function isn't the constructor function. It's
    a function that is called by the constructor function. To completely replace the
    default behavior, write a method called `constructor`, not `initialize`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`initialize`函数不是构造函数。它是一个由构造函数调用的函数。要完全替换默认行为，写一个名为`constructor`的方法，而不是`initialize`。
- en: The next important part is the `routes` object. In this object, the keys are
    routes and the values are the router methods to call when those routes are used.
    So, the same page will be loaded from the server, but then the client-side router
    will look at exactly what URL was requested and show the right content.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的部分是`routes`对象。在这个对象中，键是路由，值是当使用这些路由时要调用的路由器方法。所以，相同的页面将从服务器加载，然后客户端路由器将查看确切请求了哪个URL，并显示正确的内容。
- en: The first route is an empty string; this is the `/` route (but it's best practice
    not to include the slash in the front, so that the router will work with both
    hash URLs and the pushState API). When we load that route, we'll run the router's
    `index` function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条路由是一个空字符串；这是`/`路由（但最佳实践是在前面不包含斜杠，这样路由器就可以同时与hash URL和pushState API一起工作）。当我们加载这个路由时，我们将运行路由器的`index`函数。
- en: So what does this function do? It should look familiar; it's like what we put
    in our `index.ejs` file as a quick test. It creates our `PostsListView` instance
    and puts it on the page. Notice that we're using the `this.posts` and `this.main`
    properties that we just created.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数做什么？它看起来很熟悉；它就像我们在`index.ejs`文件中作为快速测试放入的内容。它创建我们的`PostsListView`实例并将其放在页面上。注意，我们正在使用我们刚刚创建的`this.posts`和`this.main`属性。
- en: The other route we're creating here is `/posts/:id`, which runs the `singlePost`
    function. The colon-label portion of that route will catch the content after that
    slash and pass it to the route method as a parameter. Right now, all we're doing
    in the `singlePost` method is logging a message to the console, but there's more
    to come.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的另一个路由是`/posts/:id`，它运行`singlePost`函数。该路由的冒号标签部分将捕获斜杠后面的内容，并将其作为参数传递给路由方法。目前，我们在`singlePost`方法中做的只是向控制台记录一条消息，但还有更多内容要来。
- en: 'Now that we''ve written a router, we need to start using it. You know that
    inline script in the `index.ejs` file? Replace its content with the following
    code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了一个路由器，我们需要开始使用它。你知道`index.ejs`文件中的内联脚本吗？用以下代码替换其内容：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once again, we''re creating the `posts` collection and the references to the
    main `<div>` element. This time, however, they''re properties of the router. We
    actually don''t have to do anything with the router instance, just create it.
    However, we do have to start the history tracking: that''s what the last line
    does. Remember, we''re using a single-page app, so our URLs are not actual routes
    on the server. This used to be done with a hash in the URL, but the better and
    more modern way to do this is with the `pushState` API, which is a browser API
    that let''s you change the URL in the browser''s address bar without actually
    changing the contents of the page. So, that''s what we do with the `options` object,
    where we set `pushState` to `true`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们正在创建`posts`集合和主`<div>`元素的引用。然而，这一次，它们是路由器的属性。实际上，我们不需要对路由器实例做任何事情，只需创建它。但是，我们必须开始历史跟踪：这就是最后一行所做的事情。记住，我们正在使用单页应用，所以我们的URL不是服务器上的实际路由。这曾经是通过URL中的hash来完成的，但现在更好的、更现代的方法是使用`pushState`
    API，这是一个浏览器API，允许你在不实际更改页面内容的情况下更改浏览器地址栏中的URL。所以，这就是我们在`options`对象中所做的，我们将`pushState`设置为`true`。
- en: If you browse your way over to `http://localhost:3000/`, you'll see our post
    listing. Now, click on the post link, and well, the page still reloads. However,
    on the new link, you see no page content but a line logged to the console. So,
    the router is working but it isn't stopping the reload. When the page reloads,
    the router sees the new route and runs the right method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览到`http://localhost:3000/`，你会看到我们的帖子列表。现在，点击帖子链接，嗯，页面仍然重新加载。然而，在新链接上，你看到没有页面内容，但控制台中有一条日志记录。所以，路由器正在工作，但它没有停止重新加载。当页面重新加载时，路由器看到新的路由并运行正确的方法。
- en: 'So the question now is, how do we keep the page from refreshing, but still
    change the URL? To do this, we have to prevent the default behavior of the link
    that we clicked on. To do this, we need to add the following pieces to our `PostListView`
    (in the `app.js` file):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们如何防止页面刷新，但仍然改变URL？为了做到这一点，我们必须阻止我们点击的链接的默认行为。为了做到这一点，我们需要将以下几部分添加到我们的`PostListView`（在`app.js`文件中）：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `events` property is important here, as it handles any DOM events that happen
    within the base element of our view. The keys in this object should follow the
    pattern `eventName selector`. Of course, `eventName` can be any DOM event. The
    selector should be a string that jQuery can match. Part of the beauty of this
    selector is that it only matches elements within this view, so you often don't
    have to make it very specific. In our case, just `'a'` is good enough.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`events`属性在这里很重要，因为它处理在视图的基本元素中发生的任何DOM事件。此对象中的键应遵循`eventName selector`模式。当然，`eventName`可以是任何DOM事件。选择器应该是一个jQuery可以匹配的字符串。这个选择器的一部分美在于它只匹配此视图内的元素，所以你通常不需要让它非常具体。在我们的例子中，只需`''a''`就足够了。'
- en: 'The value of each `events` property is the name of the method to call when
    this event occurs. The next step is to write this method as another property of
    this same view; it gets the jQuery event object as a parameter. Inside the `handleClick`
    method, we''re calling `e.preventDefault` to keep the default behavior from happening.
    Since this is an anchor element, the default behavior is switching to the linked-to
    page. Instead, we perform that navigation inside our Backbone application: that''s
    the next line.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`events`属性的值是在此事件发生时调用的方法的名称。下一步是将此方法作为此视图的另一个属性编写；它接收jQuery事件对象作为参数。在`handleClick`方法内部，我们调用`e.preventDefault`以阻止默认行为发生。由于这是一个锚点元素，默认行为是切换到链接到的页面。相反，我们在我们的Backbone应用程序内部执行此导航：这就是下一行。
- en: What we're doing here isn't a completely good idea, but it will work for now.
    We're referencing the `postRouter` variable, which isn't created in this file;
    in fact, it's created after this file is loaded on the client. We can get away
    with this because this function won't be called until after the `postRouter` variable
    is created. However, in a more serious application, we would probably want better
    code decoupling. However, for our skill level, this is okay.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的事情并不是一个完全好的主意，但暂时可以工作。我们正在引用`postRouter`变量，这个变量不是在这个文件中创建的；实际上，它是在这个文件在客户端加载后创建的。我们可以这样做到这一点，因为此函数只有在`postRouter`变量创建之后才会被调用。然而，在一个更严肃的应用程序中，我们可能希望有更好的代码解耦。然而，对于我们的技术水平来说，这是可以接受的。
- en: 'We''re calling the router''s `navigate` method. The first parameter is the
    route to navigate to: we get this from the anchor element. We also pass an `options`
    object, which sets `trigger` to `true`. If we don''t trigger the navigation, the
    URL will change in the browser''s location bar, but nothing else will change.
    Since we are triggering the navigation, the appropriate router method will be
    called, if one exists. One does in our case, `singlePost`, so you should see our
    message printed to the JavaScript console in the browser.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在调用路由器的`navigate`方法。第一个参数是要导航到的路由：我们从这个锚点元素中获取这个值。我们还传递一个`options`对象，将`trigger`设置为`true`。如果我们不触发导航，浏览器地址栏中的URL将会改变，但其他什么都不会改变。由于我们正在触发导航，如果存在适当的路由方法，它将被调用。在我们的例子中，有一个`singlePost`方法，所以你应该在浏览器的JavaScript控制台中看到我们的消息被打印出来。
- en: Viewing a post
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看帖子
- en: 'Now that we have the right URL for a post page, let''s make a view for individual
    posts:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了帖子页面的正确URL，让我们为单个帖子创建一个视图：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This view should mark an important milestone in your Backbone education: you
    understand most of the conventions that you''re looking at in this code. You should
    recognize all the properties of the view, as well as most of the method content.
    I want to point out here there''s much more convention going on than you may realize.
    For example, the `template` property is only ever referred to inside the `render`
    method, so you could call it something different, or put it inside the `render`
    method, as shown in the following line of code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图应该标志着你在Backbone学习中的一个重要里程碑：你理解了你在代码中看到的大多数约定。你应该认识到视图的所有属性，以及大多数方法的内容。我想在这里指出，比你可能意识到的有更多的约定在进行。例如，`template`属性仅在`render`方法内部引用，所以你可以给它取一个不同的名字，或者像以下代码行所示，将其放在`render`方法内部：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Even the `render` method is only used by us when rendering the view. It's convention
    to call it `render`, but really, nothing will break if you don't. Backbone never
    calls it internally.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是`render`方法，也只有在渲染视图时我们才使用它。将其称为`render`是一种约定，但如果你不这样做，实际上并不会有什么问题。Backbone内部永远不会调用它。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You might wonder why we follow these Backbone conventions if we don't have to.
    I think it's partly because they are very sensible defaults, and because it makes
    reading other people's Backbone code much easier. However, another good reason
    to do it is because there are many third-party Backbone components that depend
    on these conventions. When using them, conventions become expectations that are
    required for things to work.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果我们不必这样做，为什么我们还要遵循这些Backbone约定。我认为部分原因是因为它们是非常合理的默认值，并且因为这让阅读其他人的Backbone代码变得容易得多。然而，这样做的一个很好的理由是，有许多第三方Backbone组件依赖于这些约定。当使用它们时，约定变成了必须满足的期望，以便事物能够正常工作。
- en: 'However, there are a few things in this view that will be new to you. First,
    instead of putting the template text in a string that gets passed directly to
    `_.template`, we''re putting it in the `index.ejs` file and using jQuery to pull
    it in. This is something you''ll see often; it''s handy to do because most applications
    will have larger templates, and it''s hard to manage a lot of HTML in JavaScript
    strings. So, put the following code in your `index.ejs` file related to your "actual"
    script tags:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个视图中有一些事情对你来说可能是新的。首先，我们不是将模板文本直接放在一个字符串中传递给`_.template`，而是将其放在`index.ejs`文件中，并使用jQuery将其拉入。这将是常见的一种做法；这样做很方便，因为大多数应用程序都会有更大的模板，而在JavaScript字符串中管理大量的HTML是很困难的。所以，在你的`index.ejs`文件中，与你的“实际”脚本标签相关的地方，放入以下代码：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's important to give your script tag a `type` attribute, so the browser doesn't
    try to execute it as JavaScript. What that type is doesn't really matter; I use
    `text/template`. We also give it an `id` attribute, so we can reference it from
    the JavaScript code. Then, in our JavaScript code, we use jQuery to get the element,
    and then get its content using the `html` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的脚本标签中添加一个`type`属性是很重要的，这样浏览器就不会尝试将其作为JavaScript执行。这个`type`的具体值并不重要；我使用`text/template`。我们还给它添加了一个`id`属性，这样我们就可以从JavaScript代码中引用它。然后，在我们的JavaScript代码中，我们使用jQuery获取元素，然后使用`html`方法获取其内容。
- en: The other different piece of this view is that we're not passing `this.model.toJSON()`
    directly to the `render` method. Instead, we're saving it to the `model` variable,
    so that we can format the `pubDate` property. When stored as JSON, dates aren't
    very pretty. We use a few built-in `Date` methods to fix this up and reassign
    it to the model. Then, we pass the updated `model` object to the `render` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图的另一个不同之处在于，我们没有直接将`this.model.toJSON()`传递给`render`方法。相反，我们将它保存到`model`变量中，这样我们就可以格式化`pubDate`属性。当作为JSON存储时，日期看起来并不美观。我们使用一些内置的`Date`方法来修复这个问题，并将其重新分配给模型。然后，我们将更新的`model`对象传递给`render`方法。
- en: 'If you''re wondering why we''re using `events` and `handleClick` to override
    the anchor action again, notice the **All Posts** link in our template; this will
    be displayed above our post content. However, I hope you notice the flaw in this
    pattern: this will sabotage all links that might be in the content of our post,
    which might lead outside our blog. This is another reason why, as I said earlier,
    this pattern of view-changing isn''t that great; we''ll look at improvements on
    this in future chapters.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我们再次使用`events`和`handleClick`来覆盖锚点动作，请注意我们模板中的**所有帖子**链接；这将在我们的帖子内容上方显示。然而，我希望你能注意到这个模式的缺陷：这将破坏我们帖子内容中可能存在的所有链接，这可能会导致链接跳出我们的博客。这也是为什么，正如我之前所说的，这种视图更改的模式并不那么好；我们将在未来的章节中探讨改进。
- en: 'Now that we''ve created this view, we can update the `singlePost` method in
    our router:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了视图，我们可以更新我们的路由器中的 `singlePost` 方法：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Instead of just logging the ID to the console, we find the post with that ID
    in our `this.posts` collection. Then, we create a `PostView` instance, giving
    it that post as a model. Finally, we replace the content of the `this.main` element
    with the rendered content of the post view.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是仅仅将ID记录到控制台，而是在我们的 `this.posts` 集合中找到具有该ID的帖子。然后，我们创建一个 `PostView` 实例，将其作为模型传递给它。最后，我们用帖子视图的渲染内容替换
    `this.main` 元素的内容。
- en: 'If you do a simple click-through test now, you should be able to go to our
    home page, click on the post''s title, and see this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在进行简单的点击测试，你应该能够访问我们的主页，点击帖子的标题，并看到以下内容：
- en: '![Viewing a post](img/6997OS_01_02.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![查看帖子](img/6997OS_01_02.jpg)'
- en: You should be congratulated! You've just built a complete Backbone application
    (albeit an application with an extremely low level of functionality but an application
    nonetheless).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该感到自豪！你刚刚构建了一个完整的Backbone应用程序（尽管功能极低，但毕竟是一个应用程序）。
- en: Creating new posts
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新帖子
- en: 'Now that we can show posts, let''s create a form to make new posts. It''s important
    to realize that we''re just going to create a form. There''s no user account and
    no authentication, just a form that anyone could use to make new posts. We''ll
    start with the template, which we''ll put in the `index.ejs` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够显示帖子了，让我们创建一个表单来创建新帖子。重要的是要认识到我们只是创建一个表单。没有用户账户和认证，只有一个任何人都可以用来创建新帖子的表单。我们将从模板开始，将其放在
    `index.ejs` 文件中：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It''s a very basic form, but it will do. So now, we need to create our view;
    use the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的表单，但足够用了。所以现在，我们需要创建我们的视图；使用以下代码：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It''s pretty big, but you should be able to understand most of it. We start
    by making the view a `<form>` element through the `tagName` property. We fetch
    the template we just created in the `template` property. In the `initialize` method,
    we take a `Posts` collection as an option and assign it as a property, much like
    we did in the router. In the `events` property, we listen for a click event on
    the button. When that happens, we call the `createPost` method. Rendering this
    view is pretty simple. Actually, the real complexity here is in the `createPost`
    method, but even that is pretty simple. We create a `postAttrs` object that has
    all the properties of our post: the content and the text from the form and a date
    that we add.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它相当大，但你应该能够理解大部分内容。我们首先通过 `tagName` 属性将视图设置为 `<form>` 元素。我们在 `template` 属性中获取我们刚刚创建的模板。在
    `initialize` 方法中，我们接受一个 `Posts` 集合作为选项并将其分配为一个属性，就像我们在路由器中做的那样。在 `events` 属性中，我们监听按钮的点击事件。当发生这种情况时，我们调用
    `createPost` 方法。渲染这个视图相当简单。实际上，这里的真正复杂性在于 `createPost` 方法，但即使那样也很简单。我们创建一个包含我们帖子所有属性的
    `postAttrs` 对象：表单的内容和文本以及我们添加的日期。
- en: 'After creating this `postAttrs` object, we pass it to the `Posts` collection''s
    `create` method. This is a convenience method, really, that creates the `Post`
    model instance, saves it to the server, and adds it to the collection. If we wanted
    to do this "manually", we''d do something similar to the following lines of code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这个 `postAttrs` 对象之后，我们将其传递给 `Posts` 集合的 `create` 方法。这实际上是一个便利方法，它会创建 `Post`
    模型实例，将其保存到服务器，并将其添加到集合中。如果我们想“手动”完成这个操作，我们会做类似以下代码的事情：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Every Backbone model constructor takes an object, which is a hash of attributes.
    We can add that model to the collection using the `add` method. Then, every model
    instance has a `save` method, which sends the model to the server.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Backbone模型构造函数都接受一个对象，这是一个属性哈希。我们可以使用 `add` 方法将那个模型添加到集合中。然后，每个模型实例都有一个 `save`
    方法，它将模型发送到服务器。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In this case, it''s important to add the model to the collection before saving
    it, because our model class doesn''t know the server route to POST to on its own.
    If we wanted to be able to save model instances that aren''t in a collection,
    we''d have to give the model class a `urlRoot` property:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在保存之前将模型添加到集合中很重要，因为我们的模型类本身不知道要POST到服务器的服务器路由。如果我们想能够保存不在集合中的模型实例，我们必须给模型类一个
    `urlRoot` 属性：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, we navigate back to the home page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导航回主页。
- en: 'The next step is to add a new route to the router. In the `routes` property
    of the router class, add the following line:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为路由器添加一个新路由。在路由器类的 `routes` 属性中，添加以下行：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we add the `newPost` method, which is very simple:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加 `newPost` 方法，它非常简单：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That's all! Like I said, this isn't how you'd really do blog posting in a proper
    blog, but it shows us how to send model data back to the server.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！就像我说的，这并不是在合适的博客中真正进行博客发布的方式，但它展示了我们如何将模型数据发送回服务器。
- en: Adding comments
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加评论
- en: Let's take things one step further, shall we? Let's add some (very primitive)
    commenting functionality.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，添加一些（非常原始的）评论功能。
- en: 'Once again, we should start by thinking about the data. It''s obvious, in this
    case: our basic data object, if you will, is the comment. However, we also need
    to think about how our data needs to interact with other data in the application,
    that is, every post that we have needs to be able to have multiple comments connected
    to it. Backbone doesn''t have any conventions for inter-model-and-collection relationships,
    so we''ll come up with something on our own.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们应该从考虑数据开始。在这种情况下很明显：我们的基本数据对象，如果你愿意的话，就是评论。然而，我们还需要考虑我们的数据如何与其他应用程序中的数据交互，也就是说，我们拥有的每个帖子都需要能够连接多个评论。Backbone
    没有任何关于模型和集合之间关系的约定，所以我们将自己想出一些方法。
- en: 'We start with model and collection, as shown in the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从模型和集合开始，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You remember the `initialize` function, right? This will run when we instantiate
    the collection. Conventionally, it takes two parameters: an array of models and
    an options object. We''ll expect a collection of comments to be related to a single
    post, and we get that post as an option.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得 `initialize` 函数吗？当我们实例化集合时，它将会运行。传统上，它接受两个参数：一个模型数组和一个选项对象。我们期望一个评论集合与单个帖子相关联，并且我们将通过选项获取该帖子。
- en: In our `Posts` collection, `url` was a string property; however, it can also
    be a function that returns a string if we need a more dynamic URL. This is exactly
    what we need for our `Comments` collection because the URL is dependent upon the
    post. As you can see, the server location of a collection of comments is the URL
    for the post, plus `/comments`. So, for a post with ID 1, it's `/posts/1/comments`.
    For a post with ID 42, it's `/posts/42/comments`, and so on.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Posts` 集合中，`url` 是一个字符串属性；然而，如果需要更动态的 URL，它也可以是一个返回字符串的函数。这正是我们为 `Comments`
    集合所需要的，因为 URL 依赖于帖子。正如你所看到的，评论集合的服务器位置是帖子的 URL 加上 `/comments`。因此，对于 ID 为 1 的帖子，它是
    `/posts/1/comments`。对于 ID 为 42 的帖子，它是 `/posts/42/comments`，依此类推。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `url` method on a model instance checks to see whether our model class has
    the property `urlRoot`; if so, it will use that. Otherwise, it uses its collection's
    `url` property. In either case, it will append its `id` property to the `url`
    property to get its own unique URL.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 模型实例上的 `url` 方法会检查我们的模型类是否有 `urlRoot` 属性；如果有，它将使用该属性。否则，它将使用其集合的 `url` 属性。在任何情况下，它都会将其
    `id` 属性附加到 `url` 属性上，以获取其自己的唯一 URL。
- en: 'The next step is to loosely connect the `Comments` collection to the `Post`
    model. We need to add an `initialize` method to our `Post` model as shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将 `Comments` 集合松散地连接到 `Post` 模型。我们需要在我们的 `Post` 模型中添加一个 `initialize` 方法，如下所示：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'I say "loosely" because there''s no actual relation here between a post and
    its own comments (apart from setting `post: this` in the `options` object, which
    helps set the current URL); all this does is create a new `Comments` collection
    whenever a post is created. It''s important to realize that this `comments` property
    is not like the other properties of a model. To be specific, it''s a regular JavaScript
    property of the object, but not an attribute of the post model itself. We can''t
    get it with the model''s `get` method.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '我说“松散地”，是因为这里实际上没有帖子与其评论之间的实际关系（除了在 `options` 对象中设置 `post: this` 以帮助设置当前 URL
    之外）；所有这些只是每当创建帖子时创建一个新的 `Comments` 集合。重要的是要意识到这个 `comments` 属性与其他模型属性不同。具体来说，它是对象的常规
    JavaScript 属性，而不是帖子模型本身的属性。我们无法使用模型的 `get` 方法来获取它。'
- en: Serving comments
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供评论服务
- en: 'The next step is to prepare the server to send and receive comments. Sending
    comments to the client is actually pretty; see here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是准备服务器以发送和接收评论。向客户端发送评论实际上相当简单；请参见这里：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Just like in the Backbone router routes, we can use colon-target-style tokens
    in our Express routes to take a variable. However, instead of showing up as function
    parameters, we can get them as a subproperty of the request object `req.param`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 Backbone 路由的路由中一样，我们可以在 Express 路由中使用冒号目标风格的标记来获取变量。然而，这些变量不会以函数参数的形式出现，而是作为请求对象
    `req.param` 的一个子属性来获取。
- en: We're using the `comments` database object we created previously. The database
    has a `find` method, which takes a query object as the first parameter. In this
    case, we just want to find all comment records that have a `postId` property that
    matches the `id` parameter from the URL. Since the `id` parameter is a string,
    we'll need to use `parseInt` to convert it to a number. When we get the records,
    we'll send them back as JSON, just like we did with the posts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用我们之前创建的`comments`数据库对象。数据库有一个`find`方法，它接受一个查询对象作为第一个参数。在这种情况下，我们只想找到所有具有匹配URL中`id`参数的`postId`属性的评论记录。由于`id`参数是一个字符串，我们需要使用`parseInt`将其转换为数字。当我们得到记录时，我们将它们作为JSON发送回，就像我们处理帖子一样。
- en: 'What about saving comments? These will be POSTed back to the server as the
    request body, and they''re POSTed to the same URL, you can see in the following
    code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于保存评论呢？这些评论将作为请求体POST回服务器，并且它们被POST到相同的URL，你可以在下面的代码中看到：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since we're parsing the request body as JSON (see the middleware we added),
    we can insert it directly into our database. In our callback, we're taking a `result`
    parameter and sending it back to the client as JSON. This is important, because
    the `id` property on Backbone models should be set on the server. Our database
    does this automatically, so the result we send back is the same object we received
    with a new `id` property. This is the response Backbone expects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在将请求体解析为JSON（参见我们添加的中间件），我们可以直接将其插入到我们的数据库中。在我们的回调中，我们取一个`result`参数并将其作为JSON发送回客户端。这是很重要的，因为Backbone模型上的`id`属性应该在服务器上设置。我们的数据库会自动完成这个操作，所以发送回的结果是我们接收到的同一个对象，但有一个新的`id`属性。这是Backbone期望的响应。
- en: Comment views
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评论视图
- en: Now, we're ready to create the comment views. This could be done in many ways,
    but we're going to do it with three view classes. The first is to display individual
    comments. The second is the form to create new comments. The third wraps these
    two views and adds some important functionality.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建评论视图。这可以通过许多方式完成，但我们将使用三个视图类来完成。第一个是显示单个评论。第二个是创建新评论的表单。第三个将这两个视图包装起来并添加一些重要的功能。
- en: 'The first is the simplest, so let''s start with it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是最简单的，所以我们从这里开始：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''re formatting the date, as we did previously, for posts. Also, we''re once
    again putting the template content in a script tag. Here''s the script tag that
    goes in the `index.ejs` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在格式化日期，就像之前一样，用于帖子。同时，我们再次将模板内容放在一个脚本标签中。这是要放入`index.ejs`文件的脚本标签：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Pretty straightforward, isn't it?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 很直接，不是吗？
- en: 'Next up is the `CommentFormView` class. This is the form that viewers will
    use to add a comment to post. We''ll start with the template this time by using
    the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`CommentFormView`类。这是观众将用来向帖子添加评论的表单。这次我们将从以下代码开始使用模板：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Nothing too special: a textbox for the name, a text area for the text, and
    a submit button. A very basic form, you''ll agree. Now we have the class itself:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别的：一个用于名称的文本框，一个用于文本的文本区域，以及一个提交按钮。一个非常基本的表单，你同意。现在我们有了类本身：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This form view is long, but pretty similar to the other form, the one for creating
    posts. The `tagName` property sets the view's base element to a form. Since the
    comments this form makes need to be related to a post, we set the post as a property
    via the `options` object in the `initialize` method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单视图很长，但与另一个表单非常相似，即创建帖子的表单。`tagName`属性将视图的基本元素设置为表单。由于这个表单创建的评论需要与帖子相关联，我们在`initialize`方法中通过`options`对象设置帖子为一个属性。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of creating a `post` property on this view, we could use the `model`
    property. As you may have noticed, this is a specially-named property that gets
    assigned automatically when it's part of the `options` object (so we wouldn't
    need an `initialize` method). However, that property is usually the model that
    is displayed in this view. Since that's not what we're using here, I prefer to
    make a custom property, so someone reading this code wouldn't misunderstand the
    purpose of the post model in this view.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，我们不是创建一个`post`属性，而是可以使用`model`属性。正如你可能已经注意到的，这是一个特殊命名的属性，当它是`options`对象的一部分时，会自动分配（因此我们不需要`initialize`方法）。然而，这个属性通常是显示在这个视图中的模型。由于我们在这里不是使用这个，我更喜欢创建一个自定义属性，这样阅读这段代码的人就不会误解这个视图中的帖子模型的目的。
- en: 'Of course, we''ll need to capture the `click` event on the **Submit** button.
    When that happens, the `submitComment` method will be run. The first portion of
    this method is simple; we''re getting the values from the textbox and text area.
    Then, we''re putting together a `commentAttrs` object with four properties: the
    ID of the post this comment belongs to, the name of the commenter, the text, and
    the date and time of the comment''s creation (right now).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要捕获**提交**按钮的`click`事件。当发生这种情况时，将运行`submitComment`方法。这个方法的前一部分很简单；我们从文本框和文本区域获取值。然后，我们创建一个具有四个属性的`commentAttrs`对象：这个评论所属帖子的ID、评论者的名字、文本以及评论的创建日期和时间（目前）。
- en: After creating this `commentAttrs` object, we pass it to the post's comment
    collection's `create` method, just as we did in the `PostFormView`. The final
    line in the `submitComment` method is a built-in DOM method that resets the form;
    it clears all fields.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这个`commentAttrs`对象之后，我们将其传递给帖子的评论集合的`create`方法，就像我们在`PostFormView`中所做的那样。`submitComment`方法中的最后一行是一个内置的DOM方法，用于重置表单；它清除所有字段。
- en: 'The last view is `CommentsView`, which pulls these two view classes together,
    as shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个视图是`CommentsView`，它将这两个视图类组合在一起，如下所示：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Just like `CommentFormView`, this view will be given a `Post` instance when
    it's created. In the `render` method, we first append a heading to the view element,
    and then we render and append our comment form. All this should look relatively
    familiar, but the rest is new. The second-last line in `render` calls the `fetch`
    method of the post's comments collection. This makes a GET request to the server
    and fills the collection with the comments that are returned from the server.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`CommentFormView`一样，当它被创建时，这个视图将获得一个`Post`实例。在`render`方法中，我们首先将一个标题追加到视图元素，然后渲染并追加我们的评论表单。所有这些都应该看起来相对熟悉，但其余的都是新的。`render`方法中的倒数第二行调用了帖子的评论集合的`fetch`方法。这向服务器发送一个GET请求，并用从服务器返回的评论填充集合。
- en: 'Now, look back at the `initialize` method; the last line is the first we''ve
    seen of Backbone''s event capabilities. As we perform different tasks and call
    different methods of Backbone objects, different events are triggered, and we
    can listen for those events and react when they occur. In this case, we''re listening
    for the comment collection''s `add` event. This event occurs whenever we add a
    new model to this collection. If you think about the code we''ve written, you''ll
    see that there are two places where we add models to this collection:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾一下`initialize`方法；最后一行是我们第一次看到的Backbone的事件能力。当我们执行不同的任务和调用Backbone对象的不同的方法时，会触发不同的事件，我们可以监听这些事件并在它们发生时做出反应。在这种情况下，我们正在监听评论集合的`add`事件。这个事件发生在我们向这个集合添加新模型时。如果你思考一下我们编写的代码，你会看到有两个地方我们向这个集合添加模型：
- en: When calling `comments.create` in the `submitComment` method in `CommentFormView`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在`CommentFormView`的`submitComment`方法中调用`comments.create`时
- en: When calling `comments.fetch` in the `render` method in this view
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在这个视图的`render`方法中调用`comments.fetch`时
- en: 'So, whenever a model is added to our collection, we want to call the `this.addComment`
    method. Notice that we''re passing a third parameter to the `on` method: `this`.
    This is the context for the function we want to call. By default, there will be
    no value for `this` inside functions called by the `on` method, so we want to
    tell it to use this view instance as context.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当我们将一个模型添加到我们的集合中时，我们希望调用`this.addComment`方法。请注意，我们在`on`方法中传递了第三个参数：`this`。这是我们要调用的函数的上下文。默认情况下，在由`on`方法调用的函数内部，`this`将没有值，因此我们希望告诉它使用这个视图实例作为上下文。
- en: The `addComment` method takes the freshly-added comment as a parameter (the
    collections object and an `options` object are also passed to functions that are
    responding to an `add` event, but we don't need them here). We can then create
    a `CommentView` instance for this model and append its element to our view element.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`addComment`方法接受新添加的评论作为参数（集合对象和`options`对象也传递给响应`add`事件的函数，但在这里我们不需要它们）。然后我们可以为这个模型创建一个`CommentView`实例，并将其元素追加到我们的视图元素中。'
- en: 'Well, it''s all there now. You can go ahead and give it a try, that is, load
    a post page and add a few comments. Each time, you should see the comment appear
    below the form. Then, if you refresh the page, the comments you made will again
    appear under the post. You might notice a little delay in the loading of the comments.
    This is because we aren''t loading them with the initial page load. Instead, they
    are loaded during the rendering of `CommentsView`. Granted, this is milliseconds
    after the page load, but you might see a quick flash. You will see the following
    on your screen:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在一切都准备好了。你可以继续尝试，也就是说，加载一个帖子页面并添加一些评论。每次，你应该看到评论出现在表单下方。然后，如果你刷新页面，你做出的评论将再次出现在帖子下方。你可能注意到评论加载有一点延迟。这是因为我们并没有在页面初始加载时加载它们。相反，它们是在
    `CommentsView` 渲染期间加载的。当然，这只是在页面加载后的毫秒级，但你可能会看到短暂的闪烁。你将在屏幕上看到以下内容：
- en: '![Comment views](img/6997OS_01_03.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![评论查看](img/6997OS_01_03.jpg)'
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This brings us to the end of the first chapter. If you hadn't dug into Backbone
    much before this, I hope that you're starting to feel comfortable with the basics
    of the library.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们结束了第一章。如果你在这之前并没有深入挖掘 Backbone，我希望你现在开始对库的基本知识感到舒适。
- en: In this chapter, we looked briefly at all the main components of Backbone. We
    saw how models and collections are the homes for our data records, and how they
    drive the web application. We made a handful of views, some to display individual
    model instances, some to display a collection, and some to display other page
    components or wrap other views. We created a router and used it to direct almost
    all the traffic on our web application. We even got a little taste of Backbone's
    robust events API.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要地回顾了 Backbone 的所有主要组件。我们看到了模型和集合是如何成为我们的数据记录的家，以及它们如何驱动网络应用。我们创建了一些视图，一些用于显示单个模型实例，一些用于显示集合，还有一些用于显示其他页面组件或包装其他视图。我们创建了一个路由器，并使用它来引导我们网络应用上的几乎所有流量。我们甚至尝到了
    Backbone 强大的事件 API 的一点点味道。
- en: Besides the nitty-gritty of the Backbone API, I hope you picked up some of the
    bigger ideas. One of these is the `options` object, as almost every Backbone component
    constructor function takes an `options` object as the final parameter, and many
    functions that interact with the server do as well. There are some magic property
    names—such as `model` or `collection`—that Backbone handles automatically, but
    you can also pass your own options and work with them inside the classes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Backbone API 的细节之外，我希望你还能掌握一些更大的想法。其中之一是 `options` 对象，因为几乎每个 Backbone 组件构造函数都将
    `options` 对象作为最后一个参数，许多与服务器交互的函数也是如此。有一些魔法属性名——例如 `model` 或 `collection`——Backbone
    会自动处理，但你也可以传递自己的选项并在类内部处理它们。
- en: The other big takeaway from this chapter is the balance between convention and
    choice when coding. Compared to the other similar libraries, Backbone is incredibly
    light and flexible and enforces very few coding patterns. The good part is that
    the few conventions that Backbone does strongly support are actually really great
    ideas that it makes sense to follow. Of course, it's just one programmer's opinion,
    but I've found that Backbone engenders an almost perfect balance of convention
    to follow and freedom to code however you want. We'll learn more about this balance
    when we build a photo-sharing application in the next chapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的另一个重要收获是在编码时如何在传统和选择之间取得平衡。与其他类似的库相比，Backbone 非常轻量级和灵活，并且强制执行的编码模式非常少。好处是
    Backbone 强烈支持的少数传统实际上是非常棒的想法，值得遵循。当然，这只是程序员的个人观点，但我发现 Backbone 在遵循传统和自由编码之间的平衡几乎是完美的。当我们下一章构建一个照片分享应用时，我们将了解更多关于这种平衡的内容。
