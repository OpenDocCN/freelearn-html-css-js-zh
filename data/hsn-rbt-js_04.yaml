- en: Bringing in Input with Buttons
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按钮输入
- en: We've now explored digital and PWM output in Johnny-Five, but that's only half
    of the story. There is so much you can do with input devices in robotics projects,
    allowing either user input or observations of the world surrounding your projects
    to affect the outputs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在Johnny-Five中探讨了数字和PWM输出，但这只是故事的一半。在机器人项目中使用输入设备可以做很多事情，允许用户输入或观察项目周围的世界来影响输出。
- en: We're going to start with a user-input device—buttons. We're also going to talk
    about how the Raspberry Pi handles digital inputs, and build buttons into our
    previous project that allows users to stop the rainbow color cycle, and advance
    the color themselves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从用户输入设备——按钮开始。我们还将讨论树莓派如何处理数字输入，并将按钮构建到我们之前的项目中，允许用户停止彩虹颜色循环，并自行推进颜色。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using inputs in robotics projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在机器人项目中使用输入
- en: The Johnny-Five sensor and button objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Johnny-Five传感器和按钮对象
- en: Wiring up buttons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接按钮
- en: Adding buttons to our RGB LED project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将按钮添加到我们的RGB LED项目中
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You'll need your Pi, with the RGB LED from the  [Chapter 3](c7b761b9-d526-4998-8ec4-375debe53806.xhtml), *Building
    Interactive Projects with RGB LED* project wired up, along with the GPIO expander
    board.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要你的树莓派，以及从[第3章](c7b761b9-d526-4998-8ec4-375debe53806.xhtml)，“使用RGB LED构建交互式项目”项目中连接好的RGB
    LED，以及GPIO扩展板。
- en: Using inputs in robotics projects
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在机器人项目中使用输入
- en: You can do a lot with output devices in robotics projects, but the possibilities
    become endless when you add inputs. Whether they are user-controlled inputs, such
    as buttons and potentiometers, or environmental sensors that measure things such
    as ambient light or air quality, input devices can add a new dimension to any
    robotics project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在机器人项目中使用输出设备做很多事情，但当你添加输入时，可能性变得无穷无尽。无论是用户控制的输入，如按钮和电位计，还是测量环境光线或空气质量等环境传感器的输入，输入设备可以为任何机器人项目增添新的维度。
- en: Digital versus analog input
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字输入与模拟输入的比较
- en: 'Much like with digital and PWM output, there are two types of input devices:
    digital and analog. Digital inputs are either on or off: buttons are a prime example
    of this. Analog inputs give a different level of voltage of signal depending on
    what they are sensing; a photoresistor, for example, puts out higher voltage signals
    when the ambient light is high, and lower when it is darker.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数字和PWM输出一样，有两种类型的输入设备：数字和模拟。数字输入要么开启要么关闭：按钮是这种类型的典型例子。模拟输入根据它们所感应的内容提供不同级别的电压或信号；例如，光敏电阻在环境光线高时输出较高的电压信号，而在光线暗时输出较低的电压信号。
- en: In order to read data from analog devices, you'll need a pin that can accept
    an analog input. But as we saw in the last chapter, all of the GPIO pins on the
    Raspberry Pi are digital. Luckily, there are ways to get around this limitation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从模拟设备读取数据，你需要一个可以接受模拟输入的引脚。但正如我们在上一章中看到的，树莓派上的所有GPIO引脚都是数字的。幸运的是，有方法可以绕过这个限制。
- en: How to handle analog input with the Raspberry Pi
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用树莓派处理模拟输入
- en: 'There are two ways to go about obtaining analog sensor data on the Raspberry
    Pi: adding a GPIO expander that has analog pins, or using sensors that make use
    of digital signaling to communicate analog data.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派上获取模拟传感器数据有两种方法：添加具有模拟引脚的GPIO扩展器，或使用利用数字信号来通信模拟数据的传感器。
- en: Analog GPIO expanders
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟GPIO扩展器
- en: These boards act almost exactly like the GPIO expansion board we used in [Chapter
    3](c7b761b9-d526-4998-8ec4-375debe53806.xhtml),*Building Interactive Projects
    with RGB LED*, except instead of adding PWM output pins, they add analog input
    pins. These boards also usually utilize an I²C interface to communicate with the
    Raspberry Pi. However, I usually find these boards unnecessary, because many sensors
    that collect more than one channel of data (such as an accelerometer) already
    utilize I²C or other digital interfaces, and the few sensors that collect one
    channel of data can be found with these digital interfaces on board.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些板几乎与我们在[第3章](c7b761b9-d526-4998-8ec4-375debe53806.xhtml)，“使用RGB LED构建交互式项目”中使用的GPIO扩展板完全一样，除了它们不是添加PWM输出引脚，而是添加模拟输入引脚。这些板通常还使用I²C接口与树莓派通信。然而，我通常发现这些板是不必要的，因为许多收集多个通道数据的传感器（如加速度计）已经使用I²C或其他数字接口，而收集单个通道数据的少数传感器可以在板上的这些数字接口中找到。
- en: Using input devices with digital interfaces
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用具有数字接口的输入设备
- en: This is the way we'll go in our projects. Devices like these use protocols such
    as UART, SPI, and I²C that allow devices that only have digital GPIO to receive
    analog data. In the materials for each project, the devices included will not
    require analog input pins.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们项目中的做法。这些设备使用UART、SPI和I²C等协议，允许只有数字GPIO的设备接收模拟数据。在每个项目的材料中，所包含的设备不需要模拟输入引脚。
- en: How Johnny-Five handles input
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Johnny-Five如何处理输入
- en: So we've gotten a glimpse of the way Johnny-Five uses events via the board `ready` event.
    If you've ever programmed with C and Arduino, you may be familiar with the event
    loop style of program—a loop runs forever and checks the state of the input devices,
    then responds accordingly. You may also be aware of interrupt-driven programming,
    where a change in a hardware pin causes the code to jump to a specific function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经通过板`ready`事件了解了Johnny-Five如何使用事件。如果你曾经用C和Arduino编程，你可能熟悉事件循环风格的程序——一个循环永远运行并检查输入设备的状态，然后相应地做出反应。你可能也了解中断驱动的编程，其中硬件引脚的变化会导致代码跳转到特定函数。
- en: Johnny-Five code is closer to the interrupt style; events drive nearly all Johnny-Five
    projects. This has several benefits; you can keep your code organized by event
    type, and make sure each piece of functionality fires only when it needs to, without
    having to deal with programming your own hardware interrupt routines.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five的代码更接近中断风格；事件驱动几乎所有的Johnny-Five项目。这有几个好处；你可以通过事件类型来组织你的代码，并确保每个功能只在需要时触发，无需处理自己的硬件中断例程。
- en: When a Johnny-Five project receives input from a sensor or device, it fires
    a `data` event. But what if you only want to run a function when the environment
    changes? The `change` event is for you. We'll look more at the exact event types
    and when they fire in a later section, but for now keep in mind that events are
    how you'll capture the data of your sensors and input devices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当Johnny-Five项目从传感器或设备接收输入时，它会触发一个`data`事件。但如果你只想在环境变化时运行函数怎么办？`change`事件就是为你准备的。我们将在稍后的章节中更详细地探讨确切的事件类型和它们何时触发，但在此期间请记住，事件是捕捉你的传感器和输入设备数据的方式。
- en: The structure of a typical Johnny-Five project
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 典型Johnny-Five项目的结构
- en: A Johnny-Five project consists of a few key sections and building blocks that
    make it really easy to read through an example. Let's go through an example here
    to see more.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five项目由几个关键部分和构建块组成，这使得阅读示例变得非常容易。让我们通过一个示例来了解更多。
- en: The beginning – including libraries and creating our board object
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始——包括库和创建我们的板对象
- en: 'This section sets the stage for us by bringing in the Johnny-Five. The following
    code snippet tells it we''re using a Raspberry Pi, and constructs the appropriate
    board objects. If you''re using other `npm` modules, like the `color` module we
    used in [Chapter 3](c7b761b9-d526-4998-8ec4-375debe53806.xhtml),*Building Interactive
    Projects with RGB LED*, you''d use `require` to bring them in here as well, as
    shown:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过引入Johnny-Five为我们搭建了舞台。以下代码片段告诉它我们正在使用树莓派，并构建相应的板对象。如果你正在使用其他`npm`模块，例如我们在第3章中使用的`color`模块，你将使用`require`将它们也引入这里，如下所示：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The board ready event handler
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 板就绪事件处理器
- en: 'Everything else that we do in a Johnny-Five project, besides the header, goes
    inside this event handler. This handler, as shown here, means our board is ready
    to read and write to GPIO pins, and any code run outside this event handler that
    manipulates GPIO is not guaranteed to work and may cause strange behavior:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Johnny-Five项目中，除了头文件之外的所有其他内容都放在这个事件处理器中。这个处理器，如这里所示，意味着我们的板已准备好读取和写入GPIO引脚，并且任何在事件处理器外部运行的、操作GPIO的代码可能无法保证工作，并可能导致异常行为：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Constructing our component objects
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的组件对象
- en: 'The first thing I do inside the board ready event handler is set up Johnny-Five
    objects for all of the components of my projects. It''s easier to wire up a project
    from the code if all of the component types and pins are in the same place in
    the code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在板就绪事件处理器内部，我做的第一件事是为我项目的所有组件设置Johnny-Five对象。如果所有组件类型和引脚都在代码的同一位置，那么从代码中连接项目会更容易：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Input event handlers and output device manipulation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入事件处理器和输出设备操作
- en: 'This is where the fun happens, we wait for input and manipulate outputs accordingly!
    This will watch for a button connected to `P1–8` to be pressed, then turn on an
    LED. But how would we turn the LED off when the button is released? For that,
    we''re going to take another look at the Johnny-Five documentation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是有趣的部分，我们等待输入并相应地操作输出！这将监视连接到`P1–8`的按钮被按下，然后点亮一个LED。但是，当按钮释放时，我们如何关闭LED？为此，我们将再次查看Johnny-Five文档：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Johnny-Five button object
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Johnny-Five按钮对象
- en: Before we program our button project, let's take a good look at the Johnny-Five
    button object, so we know what events to look for, and what information the constructor
    wants from us.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编程按钮项目之前，让我们仔细看看Johnny-Five按钮对象，以便我们知道要寻找哪些事件，以及构造函数需要我们从我们这里得到哪些信息。
- en: The button object
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮对象
- en: 'When we look at the button''s parameters section, there is only one required
    parameter, pin. So we''ll need to remember what pin to which we hook the signal
    from the button, but other than that, the defaults will serve us nicely:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看按钮的参数部分时，只有一个必需的参数，即引脚（pin）。因此，我们需要记住将信号连接到哪个引脚，但除此之外，默认值将很好地为我们服务：
- en: '`invert`: Defaults to false, and inverts the up and down values. We''d like
    to keep this false, as we''re wiring the button to not require inversion.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invert`：默认为false，并反转上和下值。我们希望保持这个false，因为我们焊接的按钮不需要反转。'
- en: '`isPullup`: Tells boards with pull-up resistors tied to their GPIO pins to
    initialize this button with the pull-up enabled. We''re going to wire our own
    resistor, so this can stay the default false.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPullup`：告诉将上拉电阻连接到其GPIO引脚的板初始化此按钮时上拉已启用。我们将自己焊接电阻，所以这个可以保持默认的false。'
- en: '`isPulldown`: Similar to `isPullup`, but with pull-down resistors. Leave this
    false as we are wiring our own pull-down resistor.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPulldown`：与`isPullup`类似，但带有下拉电阻。由于我们将自己焊接下拉电阻，所以请将其保留为false。'
- en: '`holdtime`: This is the number of milliseconds a button must be held down before
    the hold event is fired. The default of 500 milliseconds will do fine for us here.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holdtime`：这是按钮必须按下多少毫秒后才会触发保持事件。在这里，默认的500毫秒将足够好。'
- en: There's also a special section called `collection`, which details how you can
    control several buttons with the same object. It's an interesting design, and
    while we won't explore it for our two-button project, a good bonus project would
    be to refactor it to use the buttons `collection` object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`collection`的特殊部分，它详细说明了如何使用同一个对象控制多个按钮。这是一个有趣的设计，虽然我们不会在我们的双按钮项目中探索它，但一个很好的附加项目是将它重构为使用按钮的`collection`对象。
- en: Button events
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮事件
- en: 'There are three events that the button object uses, and each of them can be
    used on a single instance of a button object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮对象使用三个事件，并且每个事件都可以用于单个按钮对象的实例：
- en: '`press`, `down`: These are the same event, and they fire when the button has
    been pressed'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`press`，`down`：这些是相同的事件，当按钮被按下时它们会被触发'
- en: '`release`, `up`: These events fire when the button is released'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release`，`up`：当按钮释放时，这些事件被触发'
- en: '`hold`: This event fires when the button is held down for longer than the threshold
    set in the `holdtime` parameter in the constructor'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hold`：当按钮按下时间超过构造函数中`holdtime`参数设置的阈值时，此事件被触发'
- en: If you've dealt with hardware before, you might be worried about button event
    `noise`; multiple events firing on one button press or release, release events
    when the button hasn't been pressed, and so on. Johnny-Five has baked debouncing
    into the button object, so there's no need to worry about noisy buttons!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前处理过硬件，你可能会担心按钮事件的`噪声`；一个按钮按下或释放时触发多个事件，按钮未按下时释放事件，等等。Johnny-Five已经将去抖动功能集成到按钮对象中，因此无需担心噪声按钮！
- en: Wiring up buttons
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 焊接按钮
- en: 'We''re going to add buttons to the project from the previous chapter, to allow
    users to change the way the RGB LED works by pressing buttons. When you look at
    a button, you see four prongs. While there are four prongs, there are only two
    input/outputs to a button—one where electricity goes in, and one where it goes
    out when the button is pressed. This is because a button essentially controls
    the flow of electricity. When the button is not pressed, the contacts are not
    connected and electricity cannot flow, and when pressed, a conductor bridges the
    two sides and electricity flows. This is how we will use the button as an input
    device: a high signal means the button is pressed, a low signal means it isn''t.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在上一章的项目中添加按钮，以便用户可以通过按按钮来改变RGB LED的工作方式。当你看一个按钮时，你会看到四个触须。虽然按钮有四个触须，但按钮只有两个输入/输出——一个电流入的地方，一个当按钮被按下时电流出的地方。这是因为按钮本质上控制着电流的流动。当按钮没有被按下时，触点没有连接，电流无法流动，而当按下时，导体桥接两侧，电流就可以流动。这就是我们将如何使用按钮作为输入设备：高信号表示按钮被按下，低信号表示没有被按下。
- en: Putting a button on a breadboard
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在面包板上放置按钮
- en: 'Take your button and observe the metal prongs on the bottom. Usually, the two
    pairs curve towards the inside of the button. There is one in and out on each
    side, and each pair with the same curve has one of each. Keep this in mind when
    placing it on the breadboard, shown in the following image:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 拿起你的按钮，观察底部的金属触须。通常，两对触须向按钮内部弯曲。每边都有一个进出，每对具有相同弯曲方向的触须中都有一个。放置在面包板上时，请记住这一点，如下面的图片所示：
- en: '![](img/b131c0d4-93f1-465d-bcaa-73d885ecb681.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b131c0d4-93f1-465d-bcaa-73d885ecb681.png)'
- en: When you're placing a button on the breadboard, you'll want to make sure that
    the button crosses the trough in the middle of the breadboard in order to prevent
    a short.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在面包板上放置按钮时，你想要确保按钮跨越面包板中间的凹槽，以防止短路。
- en: Once you've placed the button into the breadboard, make sure it's well-seated,
    and that none of the prongs have curled up into themselves instead of going into
    the breadboard socket. If one has, use needle-nose pliers to straighten it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将按钮放入面包板，确保它放置得很好，并且没有触须卷曲到自身而不是进入面包板插座。如果有，使用尖嘴钳将其拉直。
- en: Now that you've got your button on the breadboard, it's time to wire it to your
    Pi.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将按钮放置在面包板上，是时候将其连接到你的Pi上了。
- en: Using a pull-down resistor
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用下拉电阻
- en: So the question is, how are we going to get three wires into a device with two
    leads? We're going to use what's called a pull-down resistor to tie an input to
    the side of the button not connected to power. When the button is pressed, electricity
    will flow through the resistor into the signal wire, and we'll use a digital input
    pin on the Pi to detect that as a button press.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以问题是，我们如何将三根线连接到只有两个引脚的设备上？我们将使用所谓的下拉电阻将输入连接到未连接到电源的按钮一侧。当按钮被按下时，电流将通过电阻流入信号线，我们将使用Pi的数字输入引脚来检测这作为按钮按下。
- en: To do this, wire one side of your button to a 5V power pin on the cobbler. On
    the other side, place a 10K ohm resistor that bridges to another row of the breadboard,
    and in that row place a wire to bridge to a GPIO pin on the cobbler. Then, in
    the second row of the button, below the resistor, place a wire bridging to a GND
    pin on the cobbler.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，将按钮的一侧连接到面包板上的5V电源引脚。在另一侧，放置一个10K欧姆的电阻，将其连接到面包板的另一行，并在该行放置一根线，将其连接到面包板上的GPIO引脚。然后，在按钮的第二行，在电阻下方放置一根线，将其连接到面包板上的GND引脚。
- en: The resistor prevents the Pi from shorting when the button is pressed, which
    will cause your Pi to temporarily cease functioning and, if left for too long,
    will cause irreparable damage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻防止了当按钮被按下时Pi短路，这会导致你的Pi暂时停止工作，如果时间过长，将会造成不可修复的损坏。
- en: A short circuit, or short, is when the power and ground of a circuit are connected
    without a load (like our resistor) in between, which causes a lot of issues. To
    learn more, check out the *Further reading* section of this chapter, or any introduction
    to an electronics book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 短路，或短路，是指电路的电源和地之间没有负载（如我们的电阻）连接，这会导致很多问题。要了解更多信息，请查看本章的“进一步阅读”部分，或任何电子学入门书籍。
- en: Adding buttons to our RGB LED project
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加按钮到我们的RGB LED项目
- en: Now that we know how buttons work and how to wire one up to the Pi, let's add
    two buttons to our RGB LED project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了按钮的工作原理以及如何将其连接到Pi，让我们将两个按钮添加到我们的RGB LED项目中。
- en: Wiring everything up
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接所有线路
- en: Before we wire up our buttons, we're going to need to do some housekeeping on
    our current wiring setup.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们连接按钮之前，我们需要对我们的当前布线设置做一些整理。
- en: Using the power and ground side rails
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用电源和地线侧轨
- en: From here on, we'll be needing more access to power and GND pins, and we don't
    want a ton of really long wires criss-crossing our projects. So the first thing
    we'll do is a little hardware refactoring.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将需要更多访问电源和GND引脚，我们不希望有很多很长的线在我们的项目中交错。所以我们将首先进行一些硬件重构。
- en: Take the RGB LED ground off the cobbler row.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从排线中取出RGB LED的地线。
- en: Take the VCC and GND from the GPIO expander off the 5V and GND cobbler rows.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GPIO扩展器的5V和GND排线中取出VCC和GND。
- en: Place a wire between the 5V row of the cobbler and the outer long row (if there's
    one marked red and one blue, use red).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在排线的5V排和外部长排（如果有标记为红色和蓝色的，使用红色）之间放置一根线。
- en: Place a wire between a GND pin of the cobbler and the other outer row.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在排线和另一个外排之间放置一根线。
- en: Plug the RGB LED ground into the side rail you linked to the GND on the cobbler.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RGB LED的地线插入到连接到排线GND的侧轨。
- en: 'Plug the GND from the GPIO expander into the side rail linked to GND on the
    cobbler, and the VCC into the side rail linked to 5V on the cobbler, as shown
    in the following diagram:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下图所示，将GPIO扩展器的GND插入到连接到排线GND的侧轨，将VCC插入到连接到排线5V的侧轨。
- en: '![](img/ea36319f-bb5a-41f2-898c-1bafe7fa91e1.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea36319f-bb5a-41f2-898c-1bafe7fa91e1.png)'
- en: Wiring up the buttons
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接按钮
- en: 'Now that we''ve sorted out our power and ground rails, let''s place buttons.
    For both of the two buttons:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了电源和地线，让我们放置按钮。对于这两个按钮：
- en: Place the button on the breadboard as outlined in the last section, bridging
    the gap in the center of the breadboard.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照上一节所述，将按钮放置在面包板上，连接面包板中心的间隙。
- en: Wire one side of the button to the side rail connected to the 5V pin on the
    cobbler.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的一侧连接到连接到排线5V引脚的侧轨。
- en: Place a 10K ohm resistor on the other side, bridging to an empty rail.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一侧放置一个10K欧姆电阻，连接到一个空轨。
- en: Wire the side of the button with the resistor to the side rail linked to GND
    on the cobbler. Make sure the resistor is in between the button and the link to
    ground!
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将带有电阻的按钮侧连接到连接到排线GND的侧轨。确保电阻在按钮和接地连接之间！
- en: 'Wire the other end of the resistors to a pin on the cobbler; use #5 for button
    1 and #6 for button 2, as shown in the next diagram:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电阻的另一端连接到排线上的一个引脚；如下一图所示，使用#5为按钮1，#6为按钮2：
- en: '![](img/b2cc4051-e57e-44d5-adb5-686c5f6bf6a9.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2cc4051-e57e-44d5-adb5-686c5f6bf6a9.png)'
- en: And now you're ready to write some code!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你就可以编写一些代码了！
- en: Button 1 – stop and start rainbow
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮1 – 停止和启动彩虹
- en: Before we set up our buttons, we're going to refactor our rainbow-cycle program
    a bit to accommodate the new functionality of the buttons.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置按钮之前，我们将对彩虹循环程序进行一些重构，以适应按钮的新功能。
- en: Refactoring the rainbow cycle
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构彩虹循环
- en: 'We''re going to refactor the rainbow cycle to do the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构彩虹循环以执行以下操作：
- en: Look at a scoped variable to see if the color should keep changing on a timed
    interval or not (for the stop and start button)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看作用域变量，以查看颜色是否应该在定时间隔内继续改变（用于停止和启动按钮）
- en: Break the code that changes the RGB LED to the next color into its own function
    (for the next color button)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将改变RGB LED到下一个颜色的代码拆分成自己的函数（用于下一个颜色按钮）
- en: 'Let''s take a look at the refactor:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看重构：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re going to make `button1` stop and start the cycle through rainbow colors.
    To do this, we''ll need to:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使`button1`停止和启动彩虹颜色的循环。为此，我们需要做的是：
- en: Construct a button object to represent our button in the code
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个按钮对象来在代码中表示我们的按钮
- en: Watch for the `press` event from the Johnny-Five button object API
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听Johnny-Five按钮对象API的`press`事件
- en: Add a variable called `cycleOn` that can be set to true or false, and have the
    loop that changes the color use to either change the color or not
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`cycleOn`的可变变量，可以设置为true或false，并让改变颜色的循环使用它来决定是否改变颜色
- en: We're also going to pull the logic for changing the color out in preparation
    for our next button
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将把改变颜色的逻辑提取出来，为下一个按钮做准备
- en: 'Let''s add it to the beginning of our board ready handler:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到我们的板子准备处理器的开头：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Load this on your Pi, run it with `sudo node rainbow-pause-button.js`, and see
    what happens when you press the button a few times!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Pi上加载这个程序，使用`sudo node rainbow-pause-button.js`运行它，看看按按钮几次会发生什么！
- en: Button 2 – next color
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮2 – 下一个颜色
- en: 'Now we''ll add a second button and press handler to make the second advance
    the color when it is pressed:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加第二个按钮和按下处理程序，以便在按下时第二个按钮将颜色前进到数组中的下一个颜色：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, when you press the second button, the color of the LED will advance to
    the next color in the array.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你按下第二个按钮时，LED的颜色将前进到数组中的下一个颜色。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter brought together user inputs and output—an RGB LED. We learned
    how to use input events in Johnny-Five to manipulate output devices, which is
    the core of most Johnny-Five projects, and learned how to use multiple inputs
    (buttons) to achieve different effects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章汇集了用户输入和输出——RGB LED。我们学习了如何在Johnny-Five中使用输入事件来操作输出设备，这是大多数Johnny-Five项目的核心，并学习了如何使用多个输入（按钮）来实现不同的效果。
- en: Questions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What events are available to the Johnny-Five button object?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Johnny-Five按钮对象有哪些事件可用？
- en: Can the Raspberry Pi use analog input devices?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树莓派可以使用模拟输入设备吗？
- en: How will we use sensors with the Pi?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将如何使用Pi与传感器一起使用？
- en: Why are there no events for the `RGB.LED` object?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`RGB.LED`对象没有事件？
- en: Further reading
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**More about analog input pins**: [https://learn.sparkfun.com/tutorials/analog-to-digital-conversion](https://learn.sparkfun.com/tutorials/analog-to-digital-conversion)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于模拟输入引脚的更多信息**：[https://learn.sparkfun.com/tutorials/analog-to-digital-conversion](https://learn.sparkfun.com/tutorials/analog-to-digital-conversion)'
- en: '**More about pull-up resistors**: [https://learn.sparkfun.com/tutorials/pull-up-resistors](https://learn.sparkfun.com/tutorials/pull-up-resistors)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于上拉电阻的更多信息**：[https://learn.sparkfun.com/tutorials/pull-up-resistors](https://learn.sparkfun.com/tutorials/pull-up-resistors)'
