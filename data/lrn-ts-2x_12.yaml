- en: Frontend Development with Angular and TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular和TypeScript进行前端开发
- en: In this chapter, we are going to learn how to develop a frontend web application
    with Angular and TypeScript. Just like in the previous chapter, we are going to
    try to use the backend Node.js application that we previously implemented. The
    application that we are going to develop is a clone of the frontend application
    that we developed in the previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Angular和TypeScript开发前端网页应用程序。就像在上一章一样，我们将尝试使用我们之前实现的后端Node.js应用程序。我们将开发的应用程序是上一章中开发的前端应用程序的克隆。
- en: The features and styling of the application will be identical. However, the
    implementation will present some significant differences because we are going
    to use Angular instead of React as our frontend application development framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的功能和样式将保持一致。然而，实现方式将呈现一些显著差异，因为我们打算使用Angular而不是React作为我们的前端应用程序开发框架。
- en: We are not going to go through the requirements of the application that we are
    going to implement in this chapter because we have covered them already in the
    preceding chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本章中详细介绍我们将要实现的应用程序的需求，因为我们已经在上一章中讨论过了。
- en: Working with Angular
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular进行工作
- en: Angular is a library that allows us to implement web user interfaces. In this
    chapter, we are going to create a small frontend application using Angular.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个库，允许我们实现网页用户界面。在本章中，我们将使用Angular创建一个小型前端应用程序。
- en: As we learned in the preceding chapter, the JavaScript environment in Node.js
    and a web browser are quite different. The browser environment doesn't support
    modules natively and loading time is one of the major factors that influence the
    performance of a frontend application, which explains the need for a module bundler
    like webpack when we are working on a frontend web application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章所学，Node.js中的JavaScript环境和网页浏览器环境相当不同。浏览器环境不支持原生的模块，加载时间也是影响前端应用程序性能的主要因素之一，这就是为什么我们在开发前端网页应用程序时需要像webpack这样的模块打包器。
- en: 'In this chapter, we are going to use Webpack just as we have been doing throughout
    this book. We are going to use the following Webpack configuration. It is almost
    identical to the configuration used in the preceding chapter, but we have introduced
    a few modifications:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将像本书中一直做的那样使用Webpack。我们将使用以下Webpack配置。它与上一章中使用的配置几乎相同，但我们做了一些修改：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have introduced the `CommonChunkPlugin`. This plugin is used to identify
    pieces of code that repeat or that match a given rule. When a piece of code matches
    a condition, it is extracted from the main application bundle and is added to
    a second bundle named `vendor`. In this case, we are going to move all the pieces
    of code located under the `node_modules` folder to the vendor bundle, which means
    that we are going to end up with two bundles, one for the application and one
    for the third-party libraries:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了`CommonChunkPlugin`。此插件用于识别重复或匹配给定规则的代码片段。当代码片段满足条件时，它将从主应用程序包中提取并添加到名为`vendor`的第二个包中。在这种情况下，我们将所有位于`node_modules`文件夹下的代码片段移动到供应商包中，这意味着我们将最终得到两个包，一个用于应用程序，一个用于第三方库：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have also introduced an additional application entry point. We import the
    `zone.js` module. This module is a polyfill for the Zones API, which is a mechanism
    for intercepting and keeping track of asynchronous work. Zones are defined as
    follows in the Zone.js documentation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还引入了一个额外的应用程序入口点。我们导入`zone.js`模块。这个模块是Zones API的polyfill，它是一种拦截和跟踪异步工作的机制。在Zone.js文档中，区域被定义为如下：
- en: '"A Zone is a global object which is configured with rules about how to intercept
    and keep track of the asynchronous callbacks. Zone has these responsibilities:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “区域是一个全局对象，它配置了如何拦截和跟踪异步回调的规则。区域有以下职责：
- en: Intercept asynchronous task scheduling
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截异步任务调度
- en: Wrap callbacks for error-handling and zone tracking across async operations
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步操作中包装回调以进行错误处理和区域跟踪
- en: Provide a way to attach data to zones
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 提供将数据附加到区域的方法
- en: Provide a context-specific last frame error handling
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 提供特定上下文的最后帧错误处理
- en: (Intercept blocking methods)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: （拦截阻塞方法）
- en: In its simplest form, a Zone allows one to intercept the scheduling and calling
    of asynchronous operations, and execute additional code before as well as after
    the asynchronous task."
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，一个Zone允许拦截异步操作的调度和调用，并在异步任务之前以及之后执行额外的代码。
- en: 'We need Zone.js because it is one of the dependencies of Angular. The rest
    of the Webpack configuration doesn''t present any other major differences:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要Zone.js，因为它是Angular的依赖之一。Webpack配置的其余部分没有其他重大差异：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Please refer to [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*, to learn more about webpack.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第9章](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)，*自动化你的开发工作流程*，以了解更多关于webpack的信息。
- en: About the sample application
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于示例应用程序
- en: In this chapter, we are going to implement the same application that we implemented
    in the preceding chapter one more time. However, we will use Angular instead of
    React and MobX as our application development framework. We will try to implement
    a copy of the application as close as possible, to enable us to compare both frameworks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次实现前一章中实现的应用程序。然而，我们将使用Angular而不是React和MobX作为我们的应用程序开发框架。我们将尝试尽可能接近地实现应用程序的副本，以便我们能够比较这两个框架。
- en: The application is included in the companion source code and it is a very small
    web application that allows us to manage a database of movies and actors. We will
    not explain the features of the application in detail here because we already
    explained them in the preceding chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序包含在配套源代码中，它是一个非常小的Web应用程序，允许我们管理电影和演员的数据库。我们在这里不会详细解释应用程序的功能，因为我们已经在前一章中解释过了。
- en: Please refer to [Chapter 11](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml), *Frontend
    Development with React and TypeScript*, to learn more about the application features
    and requirements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第11章](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml)，*使用React和TypeScript进行前端开发*，以了解更多关于应用程序的功能和需求。
- en: Please refer to the companion source code to have access to the entire source
    code of the application as well as its configuration, including things like the
    entire `package.json` file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅配套源代码，以获取应用程序的完整源代码及其配置，包括整个`package.json`文件等。
- en: Serving an Angular application with Node.js
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js提供Angular应用程序
- en: Just like we did in the preceding chapter, we need to configure Node.js to server
    the files of our frontend web application. We use the Express static middleware
    to implement this feature just like we did in the preceding chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前一章中所做的那样，我们需要配置Node.js来提供我们的前端Web应用程序的文件。我们使用Express静态中间件来实现这一功能，就像我们在前一章中所做的那样。
- en: Please refer to [Chapter 11](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml), *Frontend
    Development with React and TypeScript*, to learn more about the Express static
    middleware. In particular, please refer to the *Serving React applications with
    Node.js* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第11章](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml)，*使用React和TypeScript进行前端开发*，以了解更多关于Express静态中间件的信息。特别是，请参阅*使用Node.js提供React应用程序*部分。
- en: Bootstrapping an Angular application
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导Angular应用程序
- en: 'The entry point of the frontend application is in the `web/frontend/main.ts`
    file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用程序的入口点在`web/frontend/main.ts`文件中：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use the `platformBrowserDynamic` module to bootstrap our application. We
    do this by invoking the `bootstrapModule` method and passing the main module in
    our application as an argument. We will learn more about modules in the following
    section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`platformBrowserDynamic`模块来引导我们的应用程序。我们通过调用`bootstrapModule`方法并传递我们的应用程序中的主模块作为参数来实现这一点。我们将在下一节中了解更多关于模块的内容。
- en: 'In this section, we are going to focus on the `platformBrowserDynamic` module.
    The `platform-browser-dynamic` module can be installed using `npm` as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注`platformBrowserDynamic`模块。可以使用以下方式使用`npm`安装`platform-browser-dynamic`模块：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use `platformBrowserDynamic` because we expect our application to be executed
    in a browser environment. An Angular application can also be executed in a server-side
    environment like Node.js, but it requires a slightly different bootstrapping configuration.
    Executing an Angular application in Node.js can be used to improve the initial
    loading time of the application. We will not cover this topic in this chapter
    because it is an advanced feature and the purpose of this chapter is just to introduce
    Angular.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`platformBrowserDynamic`是因为我们期望我们的应用程序在浏览器环境中执行。Angular应用程序也可以在Node.js这样的服务器端环境中执行，但这需要稍微不同的引导配置。在Node.js中执行Angular应用程序可以用来提高应用程序的初始加载时间。我们不会在本章中介绍这个主题，因为它是一个高级特性，而本章的目的只是介绍Angular。
- en: Please refer to the documentation at [https://angular.io/guide/universal](https://angular.io/guide/universal)
    if you wish to learn more about server-side rendering with Angular.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Angular服务器端渲染的信息，请参阅[https://angular.io/guide/universal](https://angular.io/guide/universal)文档。
- en: Working with NgModules
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与NgModules一起工作
- en: 'In the preceding section, we used a module named `AppModule` to bootstrap our
    Angular application. The `AppModule` is in the `web/frontend/app.module.ts` file
    and its content looks as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了一个名为`AppModule`的模块来引导我们的Angular应用程序。`AppModule`位于`web/frontend/app.module.ts`文件中，其内容如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `AppModule` is the entry point of our application, and it provides access
    to every other element in the application. The Angular documentation defines a
    module as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppModule`是应用程序的入口点，它提供了访问应用程序中其他所有元素的方法。Angular文档将模块定义为如下：'
- en: '"An NgModule is a class marked by the @NgModule decorator. @NgModule takes
    a metadata object that describes how to compile a component''s template and how
    to create an injector at runtime. It identifies the module''s own components,
    directives, and pipes, making some of them public, through the exports property,
    so that external components can use them. @NgModule can also add service providers
    to the application dependency injectors.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NgModule`装饰器标记了一个类。@NgModule接受一个元数据对象，该对象描述了如何编译组件的模板以及如何在运行时创建注入器。它识别模块自己的组件、指令和管道，通过`exports`属性使其中一些公开，以便外部组件可以使用它们。@NgModule还可以向应用程序依赖注入器添加服务提供者。'
- en: Modules are a great way to organize an application and extend it with capabilities
    from external libraries. Angular libraries are NgModules, such as FormsModule,
    HttpClientModule, and RouterModule. Many third-party libraries are available as
    NgModules. NgModules consolidate components, directives, and pipes into cohesive
    blocks of functionality, each focused on a feature area, application business
    domain, workflow, or common collection of utilities."
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是组织应用程序和通过外部库扩展其功能的一种很好的方式。Angular库是NgModules，例如FormsModule、HttpClientModule和RouterModule。许多第三方库也作为NgModules提供。NgModules将组件、指令和管道整合成功能块，每个块都专注于一个功能区域、应用程序业务领域、工作流程或常见的实用工具集合。
- en: A module allows us to group features; we can group all the elements (components,
    services, and so on) required for certain feature into a module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 模块允许我们将功能分组；我们可以将某些功能所需的所有元素（组件、服务等）组合到一个模块中。
- en: 'The `@NgModule` decorator allows us to set up certain settings. The following
    list defines the purpose of some of the fields used by the application included
    in the companion source code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NgModule`装饰器允许我们设置某些设置。以下列表定义了伴随源代码中包含的应用程序使用的某些字段的用途：'
- en: The `bootstrap` field is used to declare which component must be the root component
    during the bootstrapping process
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap`字段用于声明在引导过程中必须作为根组件的组件'
- en: The `declarations` field is used to declare which components are going to be
    used within the Angular templates
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declarations`字段用于声明在Angular模板中将使用哪些组件'
- en: The `imports` field is used to make other components available within the module
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imports`字段用于在模块内部使其他组件可用'
- en: The `exports` field is used to make components available to other modules
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports`字段用于使组件对其他模块可用'
- en: The `providers` field is used to configure the dependency injection bindings
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`providers`字段用于配置依赖注入绑定'
- en: It is important to clarify that Angular's `@NgModule` imports/exports and ES6
    import/export modules are entirely different concepts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 需要明确指出，Angular的`@NgModule`导入/导出和ES6导入/导出模块是完全不同的概念。
- en: Please refer to the documentation at [https://angular.io/guide/ngmodules](https://angular.io/guide/ngmodules)
    to learn more about modules.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://angular.io/guide/ngmodules](https://angular.io/guide/ngmodules)中的文档，以了解更多关于模块的信息。
- en: Working with Angular components
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Angular 组件一起工作
- en: In this section, we are going to learn how to work with components. We are going
    to learn how to work to implement components and routing, as well as other concepts
    such as how to implement dependency injection in an Angular application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用组件。我们将学习如何实现组件和路由，以及其他概念，例如如何在 Angular 应用程序中实现依赖注入。
- en: Our first component
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个组件
- en: 'In this section, we are going to look at our first Angular component. Earlier
    in this chapter, we learned how to bootstrap an Angular application, and we used
    the `AppModule`. Later, we learned that the `AppModule` uses the `AppComponent`
    as the root component of our application. We will now look at the `AppComponent`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看我们的第一个 Angular 组件。在本章的早期部分，我们学习了如何引导 Angular 应用程序，并使用了 `AppModule`。后来，我们了解到
    `AppModule` 使用 `AppComponent` 作为我们应用程序的根组件。现在，我们将查看 `AppComponent`：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, in Angular, a component is a class decorated with the `@Component`
    decorator. The `@Component` decorator takes some settings.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在 Angular 中，组件是一个带有 `@Component` 装饰器的类。`@Component` 装饰器接受一些设置。
- en: 'In this case, we use the `selector` setting to declare the name used to reference
    this component within a template. The `AppComponent` is the root component in
    our application; this means that it must be displayed as the root element in our
    `index.html` page. We can achieve this by adding a reference to the selector of
    our component in our `index.html` page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `selector` 设置来声明在模板中引用此组件时使用的名称。`AppComponent` 是我们应用程序的根组件；这意味着它必须作为我们的
    `index.html` 页面的根元素显示。我们可以通过在我们的 `index.html` 页面中添加对组件选择器的引用来实现这一点：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the page loads it will display Loading... within the `<app-root>` DOM element
    at first. As soon as the vendor and main bundle files are loaded, the Angular
    application will be executed, and the `bootstrap` function will render the template
    of the `AppComponent` within the `<app-root>` DOM element, which will cause the
    `Loading...` label to disappear.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，它将在 `<app-root>` DOM 元素中首先显示“加载中...”。一旦加载了供应商和主包文件，Angular 应用程序将被执行，`bootstrap`
    函数将在 `<app-root>` DOM 元素中渲染 `AppComponent` 的模板，这将导致“加载中...”标签消失。
- en: We use the `template` setting to define the output that we wish to be generated
    when the component is rendered. In this case, the template is rendering another
    component that uses `app-layout` as its selector. We defined the template in-line,
    but it is also possible to define the template in a separate HTML file and reference
    it by using the `templateUrl` setting.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `template` 设置来定义当组件渲染时希望生成的输出。在这种情况下，模板正在渲染另一个使用 `app-layout` 作为其选择器的组件。我们内联定义了模板，但也可以在单独的
    HTML 文件中定义模板，并通过使用 `templateUrl` 设置来引用它。
- en: It is important to note that we can only use a component in a template if both
    components have been configured correctly within an `NgModule`, as explained in
    the preceding section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只能在模板中使用组件，前提是这两个组件都在 `NgModule` 中正确配置，正如前文所述。
- en: Sometimes the components will use additional settings; we will not explain all
    the available settings in this chapter because our goal is only to provide a basic
    introduction to Angular.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时组件将使用额外的设置；我们不会在本章中解释所有可用的设置，因为我们的目标只是提供一个基本的 Angular 介绍。
- en: It is also interesting to mention that, in Angular, a component is always a
    class. In React, it was possible to implement a component as a function or as
    a class, but in Angular components are always classes, which means that there
    are no functional stateless components in Angular.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，在 Angular 中，组件始终是一个类。在 React 中，可以以函数或类的形式实现组件，但在 Angular 中组件始终是类，这意味着
    Angular 中没有无状态的函数式组件。
- en: Please refer to the documentation at [https://angular.io/guide/architecture-components](https://angular.io/guide/architecture-components)
    to learn more about Angular components.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://angular.io/guide/architecture-components](https://angular.io/guide/architecture-components)中的文档，以了解更多关于
    Angular 组件的信息。
- en: Components and directives
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件和指令
- en: 'The existing Angular literature contains a lot of references to what are known
    as directives. Sometimes directives are mentioned as something that can be used
    together with components as if they were the same thing. The truth is that components
    are a kind of directive. The following has been extracted from the official Angular
    documentation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的Angular文献中包含许多关于被称为指令的内容的引用。有时，指令被提及为可以与组件一起使用，好像它们是同一件事。事实是，组件是一种指令。以下内容摘自官方Angular文档：
- en: 'There are three kinds of directives in Angular:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中有三种类型的指令：
- en: '*Components-directives with a template.*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件：具有模板的指令。*'
- en: '*Structural directives-change the DOM layout by adding and removing DOM elements.*'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构指令：通过添加和删除DOM元素来改变DOM布局。*'
- en: '*Attribute directives-change the appearance or behavior of an element, component,
    or another directive.*'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性指令：改变元素、组件或另一个指令的外观或行为。*'
- en: We are not going to learn how to create custom attribute directives in this
    chapter. However, is it important to understand that components are a kind of
    directive.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中不会学习如何创建自定义属性指令。然而，了解组件是一种指令是很重要的。
- en: Please refer to the documentation at [https://angular.io/guide/attribute-directives](https://angular.io/guide/attribute-directives)
    to learn more about directives.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://angular.io/guide/attribute-directives](https://angular.io/guide/attribute-directives)中的文档以了解更多关于指令的信息。
- en: Data binding
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: 'In Angular, we use data binding to coordinate the application''s state with
    the content rendered on screen. Angular supports three kinds of binding, distinguished
    by the direction of data flow:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们使用数据绑定来协调应用程序的状态与屏幕上渲染的内容。Angular支持三种类型的绑定，根据数据流的方向进行区分：
- en: '| **Data direction** | **Syntax** | **Type** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **数据方向** | **语法** | **类型** |'
- en: '| One-way from data source'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '| 从数据源单向'
- en: to view target | `{{expression}} [target]="expression"` |
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到视图目标 | `{{expression}} [target]="expression"` |
- en: Interpolation
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值
- en: Property
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Attribute
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Class
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Style
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| One-way from view target'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| 从视图目标单向'
- en: to data source | `(target)="statement"` | Event |
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到数据源 | `(target)="statement"` | 事件 |
- en: '| Two-way | `[(target)]="expression"` | Two-way |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 双向 | `[(target)]="expression"` | 双向 |'
- en: Binding types other than interpolation have a target name to the left of the
    equals sign, surrounded by punctuation (`[]` and `()`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了插值之外的其他绑定类型在等号左侧有一个目标名称，周围有标点符号（`[]`和`()`）。
- en: Please refer to the documentation at [https://angular.io/guide/template-syntax](https://angular.io/guide/template-syntax)
    to learn more about the data binding syntax.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://angular.io/guide/template-syntax](https://angular.io/guide/template-syntax)中的文档以了解更多关于数据绑定语法的知识。
- en: Working with @Attribute and @Input
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@Attribute和@Input一起工作
- en: 'In the preceding section, we learned that the `AppComponent` renders the `AppLayout`
    component. In this section, we are going to look at the `AppLayout`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到`AppComponent`渲染了`AppLayout`组件。在本节中，我们将探讨`AppLayout`：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Layout` component uses the `app-layout` selector and declares an inline
    template. The template uses two other components with the `app-header` and `router-outlet` selectors.
    We will ignore the component with the `router-outlet` selector for now because
    we will learn more about it later, in the *Working with the Angular router* section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Layout`组件使用`app-layout`选择器并声明了一个内联模板。该模板使用了具有`app-header`和`router-outlet`选择器的另外两个组件。我们现在将忽略具有`router-outlet`选择器的组件，因为我们将在后面的*使用Angular路由*部分中了解更多关于它的内容。'
- en: Let's focus on the component with the selector `app-header` for now. As we can
    see in the preceding code snippet, some arguments are passed to the `HeaderComponent`.
    However, not all the arguments are passed in the same manner.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时关注具有选择器`app-header`的组件。正如我们可以在前面的代码片段中看到的那样，一些参数被传递给了`HeaderComponent`。然而，并非所有参数都以相同的方式传递。
- en: 'We have some arguments passed as follows (one-way data binding from data source
    to view target):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些按以下方式传递的参数（从数据源到视图目标的单向数据绑定）：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, we are passing the string value primary as what is known as an
    attribute. We also have some arguments passed as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将字符串值primary作为属性传递。我们还有一些按以下方式传递的参数：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, we are binding the value of the property `appRoutes` and passing
    it to the `AppHeader` component. This means that any changes to the `appRoutes`
    value will trigger the `AppHeader` component to be re-rendered.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将属性`appRoutes`的值绑定并传递给`AppHeader`组件。这意味着`appRoutes`值的任何更改都将触发`AppHeader`组件的重新渲染。
- en: 'We will now look at the `AppHeader` component to see how attributes and inputs
    are defined:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看 `AppHeader` 组件，看看如何定义属性和输入：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `HeaderComponent` takes some attributes, which are defined with the `@Attribute`
    decorator. The `HeaderComponent` also takes one input, which is defined with the
    `@Input` decorator:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeaderComponent` 接受一些属性，这些属性使用 `@Attribute` 装饰器定义。`HeaderComponent` 还接受一个输入，该输入使用
    `@Input` 装饰器定义：'
- en: The `@Input` decorator is used to pass values into the component or to pass
    data from one component to another (typically parent to child)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input` 装饰器用于将值传递到组件中，或将数据从一个组件传递到另一个组件（通常是父到子）'
- en: The `@Attribute` directory is used to retrieve the constant value of an attribute
    available in the host element of the component, and it must be used with a parameter
    of a component's constructor
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Attribute` 目录用于检索组件主元素中可用的属性的常量值，并且它必须与组件构造函数的参数一起使用'
- en: Using structural directives
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构化指令
- en: 'In the preceding section, we looked at the `HeaderComponent`. However, we skipped
    some details about its template. The `HeaderComponent` uses what is known as a
    structural directive:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了 `HeaderComponent`。然而，我们跳过了一些关于其模板的细节。`HeaderComponent` 使用所谓的结构化指令：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Structural directives are responsible for HTML layout. They shape or reshape
    the DOM's structure, typically by adding, removing, or manipulating elements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化指令负责 HTML 布局。它们塑造或重塑 DOM 的结构，通常是通过添加、删除或操作元素。
- en: Please refer to the documentation at [https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)
    to learn more about structural directives.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)
    上的文档，了解结构化指令的更多信息。
- en: Using the <ng-content> directive
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `<ng-content>` 指令
- en: 'We can use the `ng-content` directive to <indexentry content="Angular components:
    directive, using">render the child of a component. For example, the following
    component can be used to define a row in <indexentry content=" directive:using">the
    application''s layout. However, when we define the `RowComponent`, we don''t know
    which content will be placed into the row. We use the `ng-content` directive to
    refer the yet to be known child component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用 `ng-content` 指令来 <indexentry content="Angular components: directive,
    using">渲染组件的子元素。例如，以下组件可以用来在 <indexentry content=" directive:using">应用程序布局中定义一行。然而，当我们定义
    `RowComponent` 时，我们不知道哪些内容将被放入行中。我们使用 `ng-content` 指令来引用尚未知的子组件：'
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `RowComponent` can then be used within a template as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`RowComponent` 可以在模板中使用，如下所示：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Working with @Output and EventEmitter
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 @Output 和 EventEmitter 一起工作
- en: 'In Angular, we can handle user events using a property whose value is an event
    emitter. The property must be decorated with the `@Output` decorator as demonstrated
    by the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，我们可以使用一个值是事件发射器的属性来处理用户事件。该属性必须使用 `@Output` 装饰器进行装饰，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our template, we have linked an event with one of the methods in the component
    as follows (one-way data binding from view target to data source):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板中，我们已将一个事件与组件中的一个方法链接起来，如下所示（从视图目标到数据源的单向数据绑定）：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `onEdit` method will receive an event object that allows access to the target
    (the DOM element that started the event). We can use the event target to access
    the attributes of the DOM element.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`onEdit` 方法将接收一个事件对象，该对象允许访问目标（触发事件的 DOM 元素）。我们可以使用事件目标来访问 DOM 元素的属性。'
- en: 'Finally, we invoke the `emit` method of our output to pass some data to the
    parent component as output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用输出的 `emit` 方法来将一些数据作为输出传递给父组件：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the parent component can set one of its methods as the event handler
    for the `onChange` output as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，父组件可以将其方法之一设置为 `onChange` 输出的事件处理器，如下所示：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Please refer to the documentation at [https://angular.io/guide/component-interaction](https://angular.io/guide/component-interaction)
    to learn more about event handlers in Angular.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://angular.io/guide/component-interaction](https://angular.io/guide/component-interaction)
    上的文档，了解 Angular 中事件处理器的更多信息。
- en: Working with the component's host
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与组件的主元素一起工作
- en: 'In this section, we are going to demonstrate how we can use the `host` setting
    in our components to control how the component host is rendered. When a component
    is rendered, Angular will always create a DOM element that matches the name of
    the component selector. This DOM element is known as the host. For example, take
    a look at the following component:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示如何使用组件中的`host`设置来控制组件宿主的渲染方式。当组件被渲染时，Angular 将始终创建一个与组件选择器名称匹配的 DOM
    元素。这个 DOM 元素被称为宿主。例如，看一下以下组件：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It can be consumed by other components as:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以被其他组件消费，如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, it will be rendered as:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它将被渲染为：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, there is an additional DOM node. Sometimes, having an additional
    node can lead to some layout issues and it would be much better if we could control
    how the host is rendered to achieve the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一个额外的 DOM 节点。有时，额外的节点可能会导致一些布局问题，如果我们能够控制宿主渲染以实现以下输出，那就更好了：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can achieve this by using the `host` setting when we declare a component:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在声明组件时使用`host`设置来实现这一点：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Working with the Angular router
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Angular 路由一起工作
- en: 'Earlier in this chapter, we mentioned a component known as the `router-outlet`.
    The component was used by the `Layout` component as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们提到了一个名为`router-outlet`的组件。该组件被`Layout`组件如下使用：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, this component was not defined by us because it is defined by the
    `@angular/router` npm module. In order to use the module, we must import it and
    declare a `NgModule` that exports `RouteModule`. We must also declare the configuration
    for the router. The configuration is a map or a dictionary that links a given
    path with a given component:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个组件不是我们定义的，因为它是由`@angular/router` npm 模块定义的。为了使用该模块，我们必须导入它并声明一个导出`RouteModule`的`NgModule`。我们还必须声明路由的配置。配置是一个将给定路径与给定组件关联的映射或字典：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When the browser URL matches one of the paths in the router configuration,
    the corresponding component is rendered into the `router-outlet` component:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器 URL 与路由配置中的路径之一匹配时，相应的组件将被渲染到`router-outlet`组件中：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can trigger a change in the URL using a `routerLink`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`routerLink`触发 URL 的变化：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have provided the path that we wish to navigate to and the CSS class to be
    used when the link is active. When we click on a router link, the browser URL
    will change, and the router will render the matching component under the `router-outlet`
    component.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了我们希望导航到的路径以及当链接处于活动状态时要使用的 CSS 类。当我们点击路由链接时，浏览器 URL 将会改变，并且路由器将在`router-outlet`组件下渲染匹配的组件。
- en: Angular component life cycle hooks
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 组件生命周期钩子
- en: 'Angular allows us to declare multiple component life cycle hooks. For example,
    in the companion source code, the `Movie` component extends the `OnInit` interface,
    which declares the `ngOnInit` method. The `ngOnInit` method is one of the available
    component life cycle hooks in Angular:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 允许我们声明多个组件生命周期钩子。例如，在伴随源代码中，`Movie`组件扩展了`OnInit`接口，该接口声明了`ngOnInit`方法。`ngOnInit`方法是
    Angular 中可用的组件生命周期钩子之一：
- en: The `constructor` of the component class is called before any other component
    life cycle hook. The constructor is the best place to inject dependencies.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件类的构造函数在调用任何其他组件生命周期钩子之前被调用。构造函数是注入依赖的最佳位置。
- en: The `ngOnInit` method is invoked immediately after the constructor and after
    the `ngOnChange` is triggered for the first time, which is the perfect time for
    initialization work.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnInit`方法在构造函数之后以及`ngOnChange`第一次触发后立即被调用，这是初始化工作的完美时机。'
- en: The `ngOnChanges` method is invoked first when the value of a bound property
    changes. It executes every time the value of an input property changes.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当绑定属性的值发生变化时，`ngOnChanges`方法首先被调用。它会在输入属性的值每次变化时执行。
- en: The `ngDestroy` method is invoked just before the instance of the component
    is finally destroyed. It is the perfect place to clean a component  (for example,
    canceling background tasks).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件实例最终被销毁之前，将调用`ngDestroy`方法。这是清理组件（例如，取消后台任务）的完美位置。
- en: There are more life cycle hooks available, but they are out of the scope of
    this book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的生命周期钩子可用，但它们超出了本书的范围。
- en: Please refer to the Angular documentation at [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)
    to learn more about all the available life cycle hooks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 Angular 文档[https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)，以了解所有可用的生命周期钩子。
- en: Working with services
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与服务一起工作
- en: In Angular, it is a common practice to use a service to interact with a REST
    API or with other resources, such as the localStorage API. The class below defines
    a service named `MovieService`, which can be used to send HTTP requests to the
    backend Node.js application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，使用服务与REST API或其他资源（如localStorage API）交互是一种常见的做法。下面的类定义了一个名为`MovieService`的服务，它可以用来向后端Node.js应用程序发送HTTP请求。
- en: A service is just a class, and it doesn't require any special decorators. However,
    the following code snippet uses the `@Injectable` decorator because it is going
    to be injected into the `MovieComponent`. We will learn more about dependency
    injection later, in the *Dependency injection in Angular* section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 服务只是一个类，它不需要任何特殊的装饰器。然而，以下代码片段使用了`@Injectable`装饰器，因为它将被注入到`MovieComponent`中。我们将在*Angular中的依赖注入*部分学习更多关于依赖注入的内容。
- en: 'The following methods perform some HTTP requests to the server using the Fetch
    API. There is a method to fetch all movies from the movies REST API:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法使用Fetch API对服务器执行一些HTTP请求。有一个方法可以从电影REST API获取所有电影：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is also a method to create a new movie:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个方法可以创建一个新的电影：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There is also a method to delete a movie:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个方法可以删除电影：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the following section, we will learn how the movie service is consumed by
    the `Movie` component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习电影服务是如何被`Movie`组件消费的。
- en: Smart components and dumb components
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能组件和哑组件
- en: The Angular components don't draw a clear separation between properties and
    states like React does, but we can still use the same mental model. A component
    renders some data. If the data is mutated by the component, we are talking about
    a smart component. If the component only reads the data, we are talking about
    a dumb component.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件不像React那样在属性和状态之间划清界限，但我们可以仍然使用相同的思维模型。一个组件渲染一些数据。如果数据被组件修改，我们谈论的是智能组件。如果组件只读取数据，我们谈论的是哑组件。
- en: Just like we did in the React example, we have organized our project using multiple
    directories in a way that allows us to have very clear differentiation between
    smart and dumb components. The `components` directory contains only dumb components
    while the `pages` directory contains smart components.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在React示例中所做的那样，我们通过使用多个目录组织我们的项目，以便我们可以非常清晰地区分智能组件和哑组件。`components`目录只包含哑组件，而`pages`目录包含智能组件。
- en: In Angular, the dumb components, most of the time, don't require life cycle
    hooks, and they also don't require services. On the other hand, the smart components
    will most likely require some services.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，大多数情况下，哑组件不需要生命周期钩子，它们也不需要服务。另一方面，智能组件很可能需要一些服务。
- en: 'The following code snippet declares a smart component named `MoviePages`. In
    our Angular application, the pages are smart components and the components are
    simply dumb components:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为`MoviePages`的智能组件。在我们的Angular应用程序中，页面是智能组件，而组件仅仅是哑组件：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The component renders a list of movies:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件渲染电影列表：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This component also renders a modal window that allows us to create a movie:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件还渲染一个模态窗口，允许我们创建一个电影：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This component also renders a modal window that allows us to confirm that we
    wish to delete a movie from the database:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件还渲染一个模态窗口，允许我们确认我们希望从数据库中删除电影：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `MoviesPageComponent` is a smart component. As we can see in the following
    code snippet, it holds and manages the entire state required for all the dumb
    components used in its template:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoviesPageComponent`是一个智能组件。正如我们可以在以下代码片段中看到的那样，它持有并管理在其模板中使用的所有哑组件所需的所有状态：'
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `MovieService` is injected into the component. We can ignore the details
    about this for now because it will be explained in the following section:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`MovieService`被注入到组件中。我们现在可以忽略这方面的细节，因为将在下一节中解释：'
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We then use the `ngOnInit` event hook to trigger the initial data fetching:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ngOnInit`事件钩子来触发初始数据获取：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After declaring the properties, the constructor, and the `ngOnInit` event of
    the component, we are going to declare some methods. As you can see in the following
    code snippet, these methods are used to mutate the state of the application:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明属性、构造函数和组件的`ngOnInit`事件之后，我们将声明一些方法。正如您可以在以下代码片段中看到的那样，这些方法用于修改应用程序的状态：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding chapter, we learned the basics about the MobX architecture.
    There are some significant differences between the MobX architecture and the Angular
    architecture:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了关于MobX架构的基本知识。MobX架构与Angular架构之间存在一些显著差异：
- en: In MobX, the application state belongs to the `Store`. The smart component talks
    to the `Store` via actions. The `Store` is the entity that ultimately mutates
    the state, not the smart component.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MobX中，应用程序状态属于`Store`。智能组件通过动作与`Store`通信。`Store`是最终修改状态的实体，而不是智能组件。
- en: In Angular, the application state belongs to the smart component, which is the
    entity that ultimately mutates the state.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中，应用程序状态属于智能组件，这是最终修改状态的实体。
- en: In Angular, we used a service to perform the Ajax calls; on the other hand,
    in MobX, we performed the Ajax calls inside the `Store`. This is a minor difference
    because we can create a service in MobX to perform the Ajax calls. The `Store`
    could then talk to the service. The key takeaway here is the difference in state
    management.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们使用服务来执行Ajax调用；另一方面，在MobX中，我们在`Store`内部执行Ajax调用。这个区别很小，因为我们可以在MobX中创建一个服务来执行Ajax调用。然后`Store`可以与该服务通信。这里的关键点是状态管理的差异。
- en: 'The following methods use the `MovieService` to perform some Ajax calls and
    to mutate the state of the `MovieComponent`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法使用`MovieService`执行一些Ajax调用并修改`MovieComponent`的状态：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Dependency injection in Angular
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的依赖注入
- en: 'Dependency injection in Angular requires us to define some unique identifiers
    using the `InjectionToken` class. Injection tokens are unique identifiers used
    to represent a type at runtime. The concept of `InjectionToken` in Angular is
    very similar to the concept of symbols in InversifyJS:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的依赖注入要求我们使用`InjectionToken`类定义一些唯一的标识符。注入令牌是用于在运行时表示类型的唯一标识符。Angular中`InjectionToken`的概念与InversifyJS中的符号概念非常相似：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After creating an `InjectionToken`, we must decorate the class that we wish
    to inject with the `@injectable` decorator, as demonstrated by the following code
    snippet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`InjectionToken`之后，我们必须使用`@injectable`装饰器装饰我们希望注入的类，如下面的代码片段所示：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We also must declare a binding between the `InjectionToken` and an implementation
    of the type that it represents. This can be achieved using the `providers` setting
    when we declare an `NgModule` as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在`InjectionToken`和它所代表的类型实现之间声明一个绑定。这可以通过在声明`NgModule`时使用`providers`设置来实现，如下所示：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code snippet binds the `InjectionToken MOVIE_SERVICE` to the
    implementation `MovieService`. Finally, we can use the `@Inject` decorator to
    declare a dependency in one of our Angular components:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将`InjectionToken MOVIE_SERVICE`绑定到`MovieService`实现。最后，我们可以使用`@Inject`装饰器在我们的一些Angular组件中声明一个依赖项：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Please refer to the documentation at [https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection)
    to learn more about dependency injection in Angular.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection)中的文档，以了解更多关于Angular中依赖注入的信息。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned the basic principles of component-based web
    development and how to use Angular. We learned how to bootstrap an Angular application,
    how to implement routing, and how to create components.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了基于组件的Web开发的基本原则以及如何使用Angular。我们学习了如何启动Angular应用程序，如何实现路由，以及如何创建组件。
- en: We also learned how to implement dumb and smart components as well as how to
    work with services and implement dependency injection.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何实现哑组件和智能组件，以及如何与服务和实现依赖注入一起工作。
- en: In the next chapter, we are going to learn about application performance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于应用程序性能的内容。
