- en: Chapter 2. Development Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。开发模式
- en: Developing is just great. It gives you a sense of freedom to create new things.
    This is true for almost every language—a freedom to create something in your own
    way. This means that there are good ways and not-so-good ways to do the same task.
    A developer, during the course of their life, will face different problems with
    similar solutions and will adopt patterns. For some problems, they will know the
    patterns they are using; for others, they will be using patterns that they probably
    don't even know.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开发真的很棒。它给了你创造新事物的自由感。这对几乎每种语言都是真实的——以自己的方式创建东西的自由。这意味着有好的方法和不那么好的方法来完成相同的任务。在他们的生涯中，开发人员将面临不同的问题，这些问题有相似的解决方案，并且会采用模式。对于一些问题，他们会知道他们正在使用的模式；对于其他问题，他们可能会使用甚至不知道的模式。
- en: Some patterns directly increase performance, and others do it indirectly because
    of an architecture pattern that is able to scale. Creating high-performance applications
    involves knowing every bit of running code, which results in knowing the patterns
    used across an application. Sometimes, they're unintentional. At other times,
    they are enforced because of the benefits of a specific pattern. Patterns are
    everywhere, from the creation of objects to the interaction between objects and
    first-class services of an application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有些模式直接提高性能，而其他模式则间接提高性能，因为它们是能够扩展的架构模式。创建高性能应用程序涉及了解每一行运行的代码，这意味着了解应用程序中使用的模式。有时，它们是无意的。在其他时候，它们是强制性的，因为特定模式的好处。模式无处不在，从对象的创建到对象之间的交互以及应用程序的一流服务。
- en: Similarly, there are patterns specific to languages and platforms. This is because
    the compiler or interpreter handles some pieces of code better than others. Sometimes,
    it is because it's designed and targeted for best performance on the most common
    scenarios. At other times, it's just because of how the language treats some entities,
    such as functions, types of variables, or some loops. Because of all this, knowing
    how the interpreter treats some code patterns is important.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，不同的语言和平台有特定的模式。这是因为编译器或解释器处理某些代码片段比其他更好。有时，这是因为它是设计和针对最常见情况的最佳性能。在其他时候，这仅仅是因为语言如何处理某些实体，比如函数、变量类型或某些循环。因此，了解解释器如何处理某些代码模式是很重要的。
- en: What are patterns?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模式？
- en: Patterns are not libraries or classes. They're concepts—reusable solutions to
    common programming problems, tested and optimized for specific use cases. As they're
    just concepts meant to solve specific problems, they have to be implemented in
    your language. Every pattern has its advantages and disadvantages, and choosing
    a wrong pattern for a problem can cause you a big headache.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 模式不是库或类。它们是概念——可重用的解决常见编程问题的解决方案，经过测试和优化以适用于特定用例。由于它们只是旨在解决特定问题的概念，因此它们必须在您的语言中实现。每种模式都有其优点和缺点，选择错误的模式可能会给您带来很大的麻烦。
- en: Patterns can speed up the development process because they provide well-tested
    and well-proven development paradigms. Reusing patterns helps prevent issues and
    improves code readability between developers who are familiar with them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以加快开发过程，因为它们提供了经过充分测试和验证的开发范例。重用模式有助于防止问题，并提高熟悉它们的开发人员之间的代码可读性。
- en: Patterns have a lot of importance in high-performance applications. Sometimes,
    in order to achieve some flexibility, patterns introduce a new level of indirection
    in the code, which may reduce performance. You should choose when to introduce
    a pattern and know when that introduction will hurt the performance metric that
    you're targeting.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模式在高性能应用程序中非常重要。有时，为了实现一些灵活性，模式会在代码中引入新的间接层，这可能会降低性能。您应该选择何时引入模式，并知道引入模式会对您的性能指标造成何种影响。
- en: 'Knowing good patterns is essential in order to avoid the opposite—anti-patterns.
    An anti-pattern is a solution to a recurring problem that is both ineffective
    and counterproductive. Anti-patterns are not specific patterns but more like common
    errors. They are seen by the majority of mature developers/community as strategies
    that you shouldn''t use. Some of the most common and frequent anti-patterns seen
    are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 了解好的模式是非常重要的，以避免相反的—反模式。反模式是一种对重复问题的解决方案，既无效又适得其反。反模式不是特定的模式，而更像是常见的错误。它们被大多数成熟的开发人员/社区视为不应该使用的策略。以下是一些最常见和频繁出现的反模式：
- en: '**Repeating yourself**: Don''t repeat excessive parts of the code. Lean back,
    look at the big picture, and refactor it. Some developers tend to look at this
    refactoring as a complexity of the application, but it can actually make your
    application simpler. If you think you won''t be able to understand the simplicity
    of your refactoring, don''t forget to add a couple of introductory comments to
    the code.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复自己**：不要重复过多的代码部分。放松一下，看看整体情况，然后重构它。一些开发人员倾向于将这种重构视为应用程序的复杂性，但实际上它可以使您的应用程序更简单。如果您认为自己无法理解重构的简单性，请不要忘记在代码中添加一些介绍性注释。'
- en: '**Golden hammer or silver bullet**: Specifically in the Node.js ecosystem,
    and thanks to NPM, there are literally thousands of modules available out there.
    Don''t reinvent the wheel. Invest your time in using the most common modules for
    your needs, and avoid recreating them.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金榔头还是银子弹**：特别是在Node.js生态系统中，多亏了NPM，那里有成千上万的模块可供使用。不要重复造轮子。花时间使用最常见的模块来满足您的需求，避免重新创建它们。'
- en: '**Coding by exception**: Your code should handle all types of common errors.
    If the application is well planned, this accidental complexity should be avoided,
    as it won''t bring anything new to the application. Avoid coding for every type
    of error, handle the most common ones, and default to the most general error.
    This does not mean that you shouldn''t record the error in your backend. Do this
    so that you can analyze it later, but avoid handling all types of errors. This
    decreases your code maintenance.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常编码**：您的代码应该处理所有类型的常见错误。如果应用程序经过良好规划，这种意外复杂性应该可以避免，因为它不会为应用程序带来任何新的东西。避免为每种类型的错误编写代码，处理最常见的错误，并默认为最一般的错误。这并不意味着您不应该在后端记录错误。这样做是为了以后分析，但要避免处理所有类型的错误。这会减少您的代码维护。'
- en: '**Programming by accident**: Don''t program by trial and error. Success in
    this method is pure luck and a question of odds. This is something you should
    really avoid. Programming by accident can make your code work in some cases, but
    have erroneous behavior in unplanned situations.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偶然编程**：不要通过试错来编程。这种方法的成功纯粹是运气和概率的问题。这是您真正应该避免的事情。偶然编程可能会使您的代码在某些情况下工作，但在未经计划的情况下会出现错误行为。'
- en: Node.js patterns
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js模式
- en: Because of the structure and API model of the Node.js platform, some patterns
    are more biased or natural. The most obvious are the event-driven and the event
    stream patterns. They're not enforced but strongly engrained in the core API,
    and you're forced to use it in some parts of your application, so it's better
    to know how they work individually, how they work together, and how you can benefit
    from them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node.js平台的结构和API模型，某些模式更倾向或更自然。最明显的是事件驱动和事件流模式。它们并不是强制性的，但在核心API中非常根深蒂固，您在应用程序的某些部分被迫使用它，因此最好了解它们如何单独工作，如何共同工作以及如何从中受益。
- en: 'Using the core API, you can access the filesystem, for example, to read a file
    with a single method and a callback; or you can request a read stream and then
    check the data and end events or pipe the stream to somewhere else. This is very
    useful when, say, you don''t want to look at the file and just want to serve it
    to a client. This architecture was designed to work for core modules such as `http`
    and `net`. Similarly, when listening for client connections, you''ll have to listen
    for a connection event (unless you have defined a connection listener during socket
    creation) and then listen for data and end events for each connection. Remember
    not to ignore error events as they trigger exceptions if not listened and will
    force your application to stop. Events are the core feature of the Node.js platform:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用核心API，您可以访问文件系统，例如，使用单个方法和回调来读取文件；或者您可以请求读取流，然后检查数据和结束事件，或将流传输到其他位置。当您不想查看文件，只想将其提供给客户端时，这非常有用。这种架构旨在为`http`和`net`等核心模块工作。同样，当监听客户端连接时，您将不得不监听连接事件（除非在创建套接字时定义了连接监听器），然后为每个连接监听数据和结束事件。记住不要忽略错误事件，因为如果不监听，它们会触发异常，并强制您的应用程序停止。事件是Node.js平台的核心特性：
- en: Streams are also present, and one might think they're two distinct things, but
    they're not. Every stream is an extension of an event emitter. In the most basic
    form, a stream is a process of emitting data events with content from some kind
    of buffer. Events, streams, and buffers together make a very good example of an
    event-driven architecture—a pattern that goes very well with the JavaScript language.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流也存在，并且有人可能认为它们是两种不同的东西，但实际上它们并不是。每个流都是事件发射器的扩展。在最基本的形式中，流是从某种缓冲区发出数据事件的过程。事件、流和缓冲区共同构成了一个非常好的事件驱动架构的例子——这种模式非常适合JavaScript语言。
- en: Streams of different types might be connected to each other, especially when
    sharing common data and end events. It's very common to use an `fs` stream and
    pipe it to an `http` stream. This usability enables the developer to avoid unnecessary
    memory allocations in the application and just pass the task to the platform.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的流可能会相互连接，特别是在共享公共数据和结束事件时。非常常见的是使用`fs`流并将其传输到`http`流。这种可用性使开发人员能够避免在应用程序中进行不必要的内存分配，只需将任务传递给平台。
- en: Events enable a loose coupling between application components, enabling it to
    change and evolve without a strict connection between the components emitting
    events and the ones listening to them. As a downside, there are some edge cases
    to look out for, such as losing an emitted event because we were not listening,
    or leaking memory because of forgetting to stop listening for events that no longer
    exist.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件使应用程序组件之间实现了松散耦合，使其能够在组件发出事件和监听事件之间没有严格的连接的情况下进行更改和演变。不足之处是，有一些边缘情况需要注意，例如因为我们没有监听而丢失了发出的事件，或者因为忘记停止监听不再存在的事件而导致内存泄漏。
- en: Buffers are objects that you should use when manipulating data that might get
    broken with strings because of the string encoding. They're used by the platform
    to read files and write data to sockets. Many string manipulation functions are
    available for buffers to use.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区是您在处理可能因为字符串编码而破坏的数据时应该使用的对象。它们被平台用于读取文件和将数据写入套接字。对于缓冲区，有许多字符串操作函数可供使用。
- en: Types of patterns
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式类型
- en: Your application won't be using only the core API. In a complex application,
    you will be using a lot of other modules, some made by you and others that you
    simply downloaded. Patterns exist everywhere in your application. When you use
    a module and you need to create a different interface, you would be using the
    adapter pattern, a structural pattern. If you need to extend the module you just
    downloaded with a couple of functionality methods, you can use the decorator pattern,
    another structural pattern. When the downloaded module might need some complex
    information to initialize, you may want to use the Factory pattern, a creational
    pattern. If your application evolves and this initialization needs more flexibility,
    you'll be using the Builder pattern, another creational pattern. If your application
    accesses relational data, you might have to use the Active Record pattern. If
    you use some kind of software framework, you might be using the MVC pattern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序不仅仅使用核心API。在一个复杂的应用程序中，你将会使用许多其他模块，有些是你自己制作的，有些是你简单地下载的。模式存在于你的应用程序的各个地方。当你使用一个模块并且需要创建一个不同的接口时，你将会使用适配器模式，这是一种结构模式。如果你需要扩展刚刚下载的模块以添加一些功能方法，你可以使用装饰器模式，另一种结构模式。当下载的模块可能需要一些复杂的信息来初始化时，你可能会想要使用工厂模式，这是一种创建模式。如果你的应用程序发展并且这种初始化需要更多的灵活性，你将会使用建造者模式，另一种创建模式。如果你的应用程序访问关系数据，你可能需要使用活动记录模式。如果你使用某种软件框架，你可能会使用MVC模式。
- en: Many developers don't notice that they're using some of these patterns. It's
    important to know them and especially to know the problems that some patterns
    have in some contexts. In order to be able to analyze and test these patterns,
    they're categorized into several types. Let's see some of these types and some
    of the most common patterns for every type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员并没有注意到他们正在使用一些这些模式。了解它们，特别是了解某些模式在某些情境中存在的问题是很重要的。为了能够分析和测试这些模式，它们被分类为几种类型。让我们看看一些这些类型和每种类型中一些最常见的模式。
- en: Architectural patterns
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构模式
- en: 'An architectural pattern is the pattern that is usually implemented inside
    software frameworks. These solve common problems found across most applications.
    They avoid code duplication by creating some kind of layer to common broader problems.
    This image is a description of the Front Controller:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 架构模式是通常在软件框架内实现的模式。这些模式解决了大多数应用程序中发现的常见问题。它们通过创建某种层来解决常见的更广泛的问题，避免了代码重复。这张图片是对前端控制器的描述：
- en: '![Architectural patterns](img/4183_02_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![架构模式](img/4183_02_01.jpg)'
- en: The **Front Controller** pattern, most commonly seen in web applications, is
    the case where a unique controller handles all incoming requests. This is achieved
    by having a single entry point that loads common libraries, such as data access
    and session management, and then loads the specific controller for each request.
    This is a very common practice, as the alternative—having several entry points
    for different actions—would substantially increase and duplicate code, making
    the application more complex to manage and maintain.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端控制器**模式，在Web应用程序中最常见，是一个唯一的控制器处理所有传入的请求的情况。这是通过有一个单一的入口点来实现的，该入口点加载常见的库，如数据访问和会话管理，然后为每个请求加载特定的控制器。这是一个非常常见的做法，因为另一种选择——为不同的操作有多个入口点——会大大增加和重复代码，使应用程序更加复杂和难以管理和维护。'
- en: Present in most frameworks, this pattern allows your application to grow with
    different modules without duplicating unnecessary code. It has a central point
    that can handle many common tasks, such as database access, session management,
    access logging and error logging, generic access, authorization and accounting,
    and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数框架中，这种模式允许你的应用程序通过不重复不必要的代码来增长不同的模块。它有一个中心点，可以处理许多常见的任务，如数据库访问、会话管理、访问日志和错误日志、通用访问、授权和会计等。
- en: This pattern is essential in any well-structured application, as it substantially
    reduces repeated code by forcing a common part of your application to run first
    and perform every check that you need. It can also increase security; if you find
    any breach, it's easier to seal a single entry point than multiple entry points.
    Using a central point where your application can use all kinds of performance
    methods to give a better feeling of a responsive application also increases overall
    performance. The following image is a description of the MVC
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在任何良好结构的应用程序中都是必不可少的，因为它通过强制应用程序的一个公共部分首先运行并执行你需要的每个检查，大大减少了重复的代码。它还可以增加安全性；如果发现任何漏洞，封闭一个单一的入口点比多个入口点更容易。使用一个中心点，你的应用程序可以使用各种性能方法来提供更好的响应感，也可以增加整体性能。下面的图片是对MVC的描述
- en: '![Architectural patterns](img/4183_02_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![架构模式](img/4183_02_02.jpg)'
- en: 'The **Model-View-Controller** (**MVC**) pattern is a pattern that divides an
    application component into three parts: a model, a view, and a controller (hence
    the name). The model is your data structure, or your information logic. This can
    be, for example, one or more tables in a relational database. The view is a visual
    representation, usually the user interface. It can be graphical or text-based.
    It''s a representation of your model in a way that the user can see and manipulate.
    The controller is the part responsible for actually manipulating your model—sometimes
    directly updating the view—as per the actions in the view made by the user.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）模式是一种将应用程序组件分为三个部分的模式：模型、视图和控制器（因此得名）。模型是你的数据结构，或者你的信息逻辑。例如，这可以是关系数据库中的一个或多个表。视图是一种视觉表示，通常是用户界面。它可以是图形的或基于文本的。它是你的模型的一种表示方式，用户可以看到并操作。控制器是实际上负责操作你的模型的部分，有时直接更新视图，根据用户在视图中的操作。'
- en: There are many variations of this pattern and you should choose the one that
    fits your task and language best. Some of these variations are **Model-View-ViewModel**
    (**MVVM**) and **Model-View-Adapter** (**MVA**), which try to decouple the view
    from the model, causing the model to be not necessarily aware of the view. This
    makes it possible to have several views of the same model.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式有许多变体，你应该选择最适合你的任务和语言的那种。其中一些变体是**Model-View-ViewModel**（**MVVM**）和**Model-View-Adapter**（**MVA**），它们试图将视图与模型解耦，使模型不一定要意识到视图的存在。这样就可以拥有同一模型的多个视图。
- en: The main purpose of this pattern is to clearly separate what the user sees (the
    view, or the design) from the programming logic (the model). This is important
    in order for designers to be able to change the view without affecting the logic.
    Also, developers can fix the logic without breaking the design. This pattern is
    essential if you consider yourself at least an intermediate developer. This is
    because, more than a pattern, it is considered an essential practice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的主要目的是清晰地将用户所见（视图或设计）与编程逻辑（模型）分开。这对于设计师能够更改视图而不影响逻辑非常重要。同时，开发人员可以修复逻辑而不破坏设计。如果你认为自己至少是一名中级开发人员，那么这种模式是必不可少的。因为它不仅仅是一种模式，更被认为是一种必要的实践。
- en: '![Architectural patterns](img/4183_02_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![架构模式](img/4183_02_03.jpg)'
- en: The **Active Record** pattern is an abstraction layer used to access relational
    databases by providing a simple data object. Manipulating this object can trigger
    changes in the database without the developer needing to know what type of database
    is behind the application. Normally, a table or view in the database is mapped
    to a class, and instances are mapped to rows. Usually, foreign keys are handled
    by referencing instances. Logic can be given to the data objects for common application
    tasks, for example, to calculate a full name based on two different table columns,
    such as the first name and last name. This, altogether, gives a better approach
    to the business logic, making it possible to have your data as well as an extra
    layer on the top extending it to match the projected behavior of the application.
    The pattern is normally used in **object-relational mapping** (**ORM**) libraries
    that extend the functionalities to new levels. An example of this is the possibility
    to have two or more different places of your application referencing the same
    row in the database and (without knowing) having the same referenced data object.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Active Record**模式是一个用于访问关系数据库的抽象层，它提供了一个简单的数据对象。操作这个对象可以触发数据库的更改，而开发人员不需要知道应用背后的数据库类型。通常，数据库中的表或视图被映射到一个类，实例被映射到行。通常，外键由引用实例处理。逻辑可以赋予数据对象常见的应用任务，例如，根据两个不同的表列（如名字和姓氏）计算全名。所有这些都为业务逻辑提供了更好的方法，使得你可以拥有你的数据以及在顶部扩展它以匹配应用的预期行为的额外层。这种模式通常用于扩展功能到新水平的**对象关系映射**（**ORM**）库中。其中一个例子是可能在应用的两个或更多不同位置引用数据库中的同一行，并且（不知情地）拥有相同的引用数据对象。'
- en: This pattern is criticized mainly because of two aspects. The first is that
    there is an abstraction layer between application and data, which can decrease
    performance substantially and improve memory leaks in data-intensive applications.
    Another aspect is the testability; the tight coupling between the data object
    and database makes it difficult to have a real database for proper testing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式主要因为两个方面受到批评。首先是应用和数据之间存在一个抽象层，这可能会大幅降低性能，并在数据密集型应用中增加内存泄漏。另一个方面是可测试性；数据对象和数据库之间的紧密耦合使得很难为适当的测试使用真实数据库。
- en: '![Architectural patterns](img/4183_02_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![架构模式](img/4183_02_04.jpg)'
- en: The **Service Locator** pattern is the concept of abstracting access to a service
    by the use of a central registry, called the service locator, that allows services
    to register and get to know each other's access methods. Although this pattern
    involves adding an extra layer between the components of an application, it can
    give adaptation and scalability to it.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务定位器**模式是通过使用一个称为服务定位器的中央注册表来抽象访问服务的概念，这个注册表允许服务注册并了解彼此的访问方法。尽管这种模式涉及在应用程序的组件之间添加一个额外的层，但它可以为应用程序提供适应性和可扩展性。'
- en: There are a couple of advantages to this approach, the most important being
    the possibility to adapt to the workload. The service locator can control access
    to the registered services and, if you have several instances of the same service
    spread across servers, this locator can rotate access to every one of the instances,
    making it possible to add more instances of the same service and handle more load.
    Another great advantage is the possibility to unregister services and register
    new ones with better performance or bug fixes, giving you the possibility to keep
    zero downtime.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些优势，最重要的是适应工作负载的可能性。服务定位器可以控制对注册服务的访问，如果你在多台服务器上有同一服务的多个实例，这个定位器可以轮流访问每一个实例，从而可以添加更多实例并处理更多负载。另一个重要的优势是可以注销服务并注册新的具有更好性能或错误修复的服务，从而使你可以保持零停机时间。
- en: Not everything is good news, however; there are some disadvantages that have
    to be weighted. The service locator can potentially become a single point of failure,
    which is something that no one wants. Security is also important, and service
    registration must be handled with caution to prevent outsiders from hijacking
    the registry. Also, as services are decoupled from the service locator and the
    application, they act as black boxes and it might get harder to handle errors
    and recover from them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非一切都是好消息；有一些不利之处需要权衡。服务定位器可能成为单点故障的潜在来源，这是没有人想要的。安全性也很重要，服务注册必须谨慎处理，以防止外部人员劫持注册表。此外，由于服务与服务定位器和应用程序解耦，它们就像黑匣子一样，可能更难处理错误并从中恢复。
- en: '![Architectural patterns](img/4183_02_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![架构模式](img/4183_02_05.jpg)'
- en: The **Event-driven** pattern is a pattern that promotes production and consumption
    of events. This architecture forces the programming logic to react to events.
    An event is a state change, for example, when a network connection is established,
    data arrives, or a file handle is closed. An object that needs to be notified
    of an event (called a consumer) registers (listens) for an event in an appropriate
    event emitter object (the producer). When this object detects state changes related
    to it, it notifies (emits) the events to the consumers.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动模式是一种促进事件的生产和消费的模式。这种架构强制编程逻辑对事件做出反应。事件是状态变化，例如，当建立网络连接时，数据到达，或文件句柄关闭时。需要通知事件的对象（称为消费者）在适当的事件发射器对象（生产者）中注册（监听）事件。当该对象检测到与其相关的状态变化时，它会通知（发出）事件给消费者。
- en: Events can have data information. For example, if a file reader object is an
    event emitter, it will probably notify consumers when the respective file is opened,
    when it has data from the file (whether it is complete or not), when the file
    is closed (no more data), and if any error occurs eventually (no access permission
    or filesystem being two examples). The data event could eventually get the file
    itself and the error event should get the associated error.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以包含数据信息。例如，如果文件阅读器对象是一个事件发射器，它可能会在相应文件被打开时通知消费者，当它从文件中获取数据时（无论是否完整），当文件关闭时（没有更多数据），以及最终发生任何错误时（无访问权限或文件系统是两个例子）。数据事件最终可能会获取文件本身，错误事件应该获取相关的错误。
- en: Building applications around this pattern usually makes them more responsive
    because these systems are, by design, targeted at unpredictable and asynchronous
    environments, which exist in the case of any system that uses the network or the
    filesystem. This architecture is extremely loosely coupled, as an event can be
    almost anything and anywhere, making this pattern scalable and distributable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕这种模式构建应用程序通常使它们更具响应性，因为这些系统是针对不可预测和异步环境设计的，这种环境存在于使用网络或文件系统的任何系统中。这种架构非常松散耦合，因为事件几乎可以是任何东西，任何地方，使得这种模式具有可扩展性和可分发性。
- en: Frameworks with this pattern normally allow developers to create their own products,
    the event emitters, with custom events and data, extending the core functionality
    and making it possible to make the entire application event-driven.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这种模式的框架通常允许开发人员创建自己的产品，即事件发射器，具有自定义事件和数据，扩展核心功能，并使整个应用程序成为事件驱动。
- en: Creational patterns
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模式
- en: 'Creational patterns are the patterns that developers use when creating new
    data or objects. These patterns give your application the flexibility to choose
    when to instantiate new objects or reuse current ones. In this type of pattern,
    you can find some of the patterns that are described as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模式是开发人员在创建新数据或对象时使用的模式。这些模式使您的应用程序具有灵活性，可以选择何时实例化新对象或重用当前对象。在这种类型的模式中，您可以找到一些如下所述的模式：
- en: '![Creational patterns](img/4183_02_07.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![创建模式](img/4183_02_07.jpg)'
- en: The **Factory** method pattern is used to abstract the application from specific
    classes. It is used to create new objects. In this pattern, a method is called,
    a new (or reused) object is returned, and the logic of the creation (if needed)
    is handled by another subclass. This pattern is specifically useful when the component
    that needs to create the new object might not have all of the necessary information
    (for example, database information) Another use case is when this object is reused
    across components, the code necessary to create the object might be too complex,
    and duplication of many pieces of code may be required. Again, a database connection
    or another data information service access is a good case for this pattern.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法模式用于将应用程序与特定类抽象化。它用于创建新对象。在这种模式中，调用一个方法，返回一个新的（或重用的）对象，并且创建的逻辑（如果需要）由另一个子类处理。当需要创建新对象的组件可能没有所有必要的信息（例如数据库信息）时，这种模式特别有用。另一个用例是当这个对象在组件之间被重复使用时，创建对象所需的代码可能太复杂，可能需要重复许多代码片段。再次，数据库连接或另一个数据信息服务访问是这种模式的一个很好的案例。
- en: The **Lazy initialization** pattern is when you delay the creation of an object
    or the calculation of a complex expression. This is also called lazy loading.
    This pattern is usually seen with the factory method when you save an instance
    after you call some factory function so that you can later return that very instance
    when the function is called again. This is another way of getting a singleton.![Creational
    patterns](img/4183_02_06.jpg)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟初始化模式是指延迟创建对象或计算复杂表达式。这也被称为延迟加载。当您在调用某个工厂函数后保存一个实例，以便在再次调用该函数时可以返回该实例时，通常会出现这种模式。这是获取单例的另一种方式。![创建模式](img/4183_02_06.jpg)
- en: The **Singleton** pattern is used when a single object instance is required
    or desired for your application to work efficiently. This pattern is usually made
    in the class itself, where the developer of the class creates a method to create
    a new instance, and if an instance was previously created, it is returned instead.
    It can also appear inside the Factory pattern, where the application might have
    a library for creating a database connection pool and would prefer that all the
    modules use the same pool instead of creating new ones. This is especially important
    for web applications where you want to avoid connecting to the database every
    time a request comes in. It is also used, for example, in the Active Record pattern,
    when the same row is needed by several components, and instead of returning different
    objects, the same object is returned.![Creational patterns](img/4183_02_08.jpg)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**模式用于应用程序需要单个对象实例以实现高效运行的情况。这种模式通常在类本身中创建，其中类的开发者创建一个方法来创建一个新实例，如果先前已创建实例，则返回该实例。它也可以出现在工厂模式中，应用程序可能有一个用于创建数据库连接池的库，并且希望所有模块使用相同的池而不是创建新的。这对于Web应用程序尤为重要，因为您希望避免每次请求时连接到数据库。例如，在Active
    Record模式中也会使用，当多个组件需要相同的行时，而不是返回不同的对象，返回相同的对象。'
- en: The **Builder** pattern is a class that is responsible for creating new instances
    of other classes. This is similar to the Factory method pattern—more flexible
    but also more complex. A developer normally starts with the factory pattern and
    it evolves into this pattern. This is especially useful when abstracting a class
    with several constructing combinations, for example, when constructing a database
    query.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建造者**模式是负责创建其他类的新实例的类。这类似于工厂方法模式，更灵活但也更复杂。开发人员通常从工厂模式开始，然后演变为这种模式。这在抽象一个具有多种构造组合的类时特别有用，例如构造数据库查询时。'
- en: The classes behind the builder are usually complex, and the builder sometimes
    addresses this complexity by exposing simpler methods and evolving as the need
    arrives. It's a good pattern, where you can cascade or chain the methods to create
    a more fluent interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者背后的类通常很复杂，建造者有时通过暴露更简单的方法来解决这种复杂性，并随着需求的到来而不断发展。这是一个很好的模式，可以级联或链接方法以创建更流畅的接口。
- en: '![Creational patterns](img/4183_02_09.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![创建型模式](img/4183_02_09.jpg)'
- en: In the **Object pool** pattern, a set of objects, called the pool, is kept ready
    for use by other components. This pattern is usually associated with connection
    pools and other operations that might involve significant initialization time.
    Usually, such pools are initialized at a lower value (reduced pool size) and grow
    as per the demand to a higher or limit value.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**对象池**模式中，一组对象（称为池）被其他组件准备好供使用。这种模式通常与连接池和可能涉及重要初始化时间的其他操作相关联。通常，这些池以较低的值（减少的池大小）初始化，并根据需求增长到更高或限制值。
- en: This pattern is frequently used in database connections, as they may be expensive
    to create, considering connecting and authenticating. Always keeping a few connections
    alive drastically reduces the initialization time and improves performance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式经常用于数据库连接中，因为创建连接可能很昂贵，考虑到连接和认证。始终保持一些连接活动会大大减少初始化时间并提高性能。
- en: Structural patterns
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构型模式
- en: 'Another type of pattern is the structural type. In this type, there are patterns
    that help in relationships and communication between components. These are commonly
    used to connect third-party modules together as a common interface. Examples of
    this type are described as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的模式是结构型模式。在这种类型中，有助于组件之间的关系和通信的模式。这些通常用于将第三方模块连接在一起作为一个公共接口。此类型的示例描述如下：
- en: '![Structural patterns](img/4183_02_10.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![结构型模式](img/4183_02_10.jpg)'
- en: The **Adapter** pattern is the most common pattern, where two components that
    are not compatible are connected by a common interface. One rule to distinguish
    this pattern from similar patterns is that the adapter that connects the two components
    should not have any logic and should only allow the two interfaces to connect
    in a new common interface.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**模式是最常见的模式，用于连接两个不兼容的组件，通过一个公共接口连接。一个区分这种模式与类似模式的规则是，连接两个组件的适配器不应具有任何逻辑，只允许两个接口连接到一个新的公共接口。'
- en: This pattern shows up when you have two interfaces and one needs to be refactored,
    and the interface will change the methods. While you don't have to refactor the
    other interface, you'll need an adapter to keep your application running.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式出现在你有两个接口并且需要重构其中一个接口，接口将改变方法。虽然你不必重构另一个接口，但你需要一个适配器来保持应用程序运行。
- en: '![Structural patterns](img/4183_02_11.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![结构型模式](img/4183_02_11.jpg)'
- en: 'The **Composite** pattern is used when a group of objects or a single object
    should be treated and accessed in the same way. This pattern should be used when
    components don''t know when accessing a group of objects or an individual object.
    It is particularly useful when the complexity of code that is meant to treat the
    two variations are: an element or a set of elements is not much. Examples of this
    pattern appear in jQuery and other libraries that treat groups of elements the
    same as a single element.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**模式用于当一组对象或单个对象应该以相同的方式对待和访问时。当组件不知道何时访问一组对象或单个对象时，应该使用这种模式。当意图处理两种变化的代码复杂性不大时，这种模式特别有用。这种模式在jQuery和其他将一组元素与单个元素视为相同的库中经常出现。'
- en: An easy way of creating this pattern is by always assuming a group of objects.
    If the interface supports a group, it should be fairly easy to check the input
    and convert a single object into a group of objects before continuing. In this
    way, the user of the interface won't need to care about it. It's always a good
    pattern when you make your interfaces more tolerant to user input.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式
- en: '![Structural patterns](img/4183_02_12.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: 当你用一个更容易使用和理解的接口包装一个复杂的库时，就会使用外观模式。有时候库变得非常灵活，有许多不同的选项，当你创建一个不那么灵活但更简单的接口到一个复杂的库时就会使用这种模式。
- en: The **Decorator** pattern is used when a functionality is added to an object
    without affecting the behavior of other objects of the same class. It is actually
    the base of prototypal inheritance, which is a fundamental principle of JavaScript.
    This is achieved by wrapping the object in another class, saving a reference to
    it, and adding the new functionality to the new class. You use this when a module
    you want to use does not have all of the functionality you want, and you decide
    to wrap it and give extra methods. This is an extension, or the next step, of
    the Adapter pattern. It's common that you find a module that almost fits your
    needs, but then you realize that there are one or two missing features, so instead
    of looking for another module (maybe because you're used to it already), you just
    decorate the first.![Structural patterns](img/4183_02_13.jpg)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The **Facade** pattern is in place when you wrap a complex library in an interface
    easier to use and understand. Sometimes libraries become very versatile with many
    different options and this pattern is used when you create a less versatile but
    simpler interface to a complex library.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者模式创建了一个抽象层，称为中介者，它处理与多个类的通信。随着应用程序变得复杂，需要一个中介者来降低类之间通信的复杂性。这个中介者封装了与所有类的通信，通过保持对象不直接相互交互来减少依赖性和降低耦合。如果你的应用程序是模块化的，不同的模块可以在运行时加载，这可以被称为你的内部API。
- en: This pattern appears when a couple of repeating or complex tasks are common
    and you decide that it's better to have an interface to do it. It's not an adapter
    pattern since it's not an interface change; it's a simplified interface. You can
    see this if, for example, you have a class that understands and talks SMTP. You
    need to send an e-mail and prefer to have a single method to send a message than
    a log of complex methods of the original class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式出现在一对重复或复杂任务很常见的情况下，你决定最好有一个接口来完成它。这不是一个适配器模式，因为它不是一个接口改变；它是一个简化的接口。例如，如果你有一个理解和使用SMTP的类。你需要发送一封电子邮件，而且更喜欢有一个单一的方法来发送消息，而不是原始类的一系列复杂方法。
- en: '![Structural patterns](img/4183_02_14.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: 结构模式
- en: The **Proxy** pattern, normally used to simplify a more complex task, is a pattern
    where an object acts as a proxy to access something. It can be another object,
    a file, a folder, or some database information. This pattern is used, for example,
    to add a security layer to something else, as it can restrict how and when the
    application will access a specific resource. An example of this pattern is a REST
    interface to a service.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: Behavioral patterns
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理模式通常用于简化更复杂的任务，它是一个对象充当代理来访问某些东西的模式。它可以是另一个对象、一个文件、一个文件夹或一些数据库信息。例如，这种模式被用来为其他东西添加安全层，因为它可以限制应用程序访问特定资源的方式和时间。这种模式的一个例子是对服务的REST接口。
- en: 'Behavioral patterns are characterized by identifying communication patterns
    between objects. They classify kinds of behavior and how objects communicate.
    Some of the most common types are described as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式
- en: '![Behavioral patterns](img/4183_02_15.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: 中介者模式
- en: The **Mediator** pattern creates an abstraction layer, called the mediator,
    that handles communication with multiple classes. As your application becomes
    complex, the need for a mediator to lower the complexity of communication between
    classes arises. This mediator encapsulates communication with all the classes,
    reducing dependency and lowering coupling by keeping objects from interacting
    directly with each other. If your application is modular and different modules
    can be loaded at runtime, this can be called—kind of—your internal API.![Behavioral
    patterns](img/4183_02_16.jpg)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当向对象添加功能而不影响同一类的其他对象的行为时使用装饰器模式。这实际上是原型继承的基础，这是JavaScript的一个基本原则。通过将对象包装在另一个类中，保存对它的引用，并将新功能添加到新类中来实现。当你想要使用的模块没有你想要的所有功能时，你会使用这个模式，并决定包装它并提供额外的方法。这是适配器模式的扩展或下一步。通常你会发现一个几乎符合你需求的模块，但后来你意识到有一两个缺失的功能，所以你不是去寻找另一个模块（也许是因为你已经习惯了它），而是装饰第一个模块。
- en: The **Template** method pattern is used by several frameworks. It is usually
    a method that takes a set of options and compiles part of your information, leaving
    placeholders to some modifiable parts. This is used, for example, as a way of
    precompiling a graphic user interface view, leaving some placeholders, such as
    internationalization text, and eventually some code logic to be run later. This
    pattern is very effective when some part of the template doesn't change, reducing
    the time to compile from the template every time it's needed. This is also a typical
    example of **Inversion of Control**, where it's the template that can call parts
    of your application instead of your application calling the methods of the template.![Behavioral
    patterns](img/4183_02_17.jpg)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法模式被几个框架使用。通常是一个方法，它接受一组选项并编译您的信息的一部分，留下一些可修改部分的占位符。例如，这被用作预编译图形用户界面视图的一种方式，留下一些占位符，比如国际化文本，以及最终一些代码逻辑以便以后运行。当模板的某个部分不变时，这种模式非常有效，减少了每次需要时从模板编译的时间。这也是**控制反转**的典型例子，模板可以调用应用程序的部分，而不是应用程序调用模板的方法。
- en: The **Observer** pattern maintains a list of dependents, called observers, and
    notifies them of the changes by calling a method provided by each dependent. This
    is commonly called an event system, and it's used in event-driven architectures,
    such as Node.js. This pattern is very effective and useful in asynchronous programming.
    On the other hand, if not properly used, it can cause memory leakage when an event
    listener is not properly deregistered and the observer keeps a strong reference
    to it, preventing garbage collection from disposing it (the lapsed listener problem).
    This pattern is heavily used by the Node.js platform and it is essential that
    you embrace and understand it if you want to create a performant application.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式维护了一个被称为观察者的依赖列表，并通过调用每个依赖提供的方法来通知它们的变化。这通常被称为事件系统，并且在事件驱动架构中被使用，比如Node.js。这种模式在异步编程中非常有效和有用。另一方面，如果使用不当，当事件监听器没有正确注销并且观察者保持对其的强引用时，可能会导致内存泄漏，从而阻止垃圾回收对其进行处理（过期监听器问题）。这种模式被Node.js平台大量使用，如果您想创建一个高性能的应用程序，那么您必须接受并理解它。
- en: Event-driven architecture
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: Developing in Node.js is no different from other languages. You have some more
    or less native patterns, widely adopted and fully supported. One very common pattern
    is **event-driven architecture**. This pattern promotes production and consumption
    of events. This means that your code should be reactive to events instead of constantly
    trying to detect changes. Usually, many listeners can consume an event. There
    are some variations, such as having a way of stopping the event propagation or
    only allowing the first listener to consume the event, but normally all listeners
    will be able to consume all the events that they're listening to.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中开发与其他语言并无不同。您有一些更多或更少本地的模式，被广泛采用并得到充分支持。一个非常常见的模式是**事件驱动架构**。这种模式促进了事件的产生和消费。这意味着您的代码应该对事件做出反应，而不是不断尝试检测变化。通常，许多监听器可以消费一个事件。有一些变化，比如有一种停止事件传播的方法，或者只允许第一个监听器消费事件，但通常所有监听器都能消费他们正在监听的所有事件。
- en: This pattern is very effective when you need to communicate inside your application
    in a *one to many* module of your code, as it gives you a very lose coupling.
    This is specifically interesting in **service-oriented architecture** (**SOA**)
    as it ensures your application components (your services) remain loosely coupled
    and can be upgraded over time without affecting other services. Imagine you have
    an application with many services attached and a service called **Sessions**,
    responsible for managing user sessions, creating them, and destroying them. This
    service may eventually produce events when sessions change. In this way, other
    services may listen for the events and act accordingly. This means that a service
    that only wants to know when sessions are created can, for example, just listen
    for the create event, and another service that only needs to know when they're
    destroyed can listen only for that specific event. Other services can then be
    added without having to change much of your application. This is also good for
    somehow creating a boundary between services when, for example, you don't want
    to trust third-party services.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在代码的*一对多*模块内部进行通信时，这种模式非常有效，因为它给您提供了非常松散的耦合。这在**面向服务的架构**（**SOA**）中特别有趣，因为它确保您的应用程序组件（您的服务）保持松散耦合，并且可以随着时间的推移进行升级而不影响其他服务。想象一下，您有一个附加了许多服务的应用程序，还有一个名为**Sessions**的服务，负责管理用户会话，创建它们和销毁它们。当会话发生变化时，该服务可能会产生事件。这样，其他服务可以监听事件并相应地采取行动。这意味着只想知道会话何时创建的服务，例如，只需监听创建事件，而另一个只需要知道何时销毁的服务只需监听特定事件。其他服务可以添加而不必改变太多您的应用程序。这对于在某种程度上创建服务之间的边界也是有益的，例如，当您不想信任第三方服务时。
- en: There are some related patterns—sort of variations of this pattern. One widely
    used pattern is the publish-subscribe pattern. One widely used and very similar
    pattern is the publish-subscribe pattern. Instead of events, you have messages;
    instead of listeners, you have subscribers; and instead of event emitters, you
    have publishers. The main advantage of this pattern is that it's usually implemented
    to work using the network layer, and so it can be used by services to communicate
    with each other over the Internet. However, this pattern is actually not that
    simple and can get quite complex compared to Node.js core events, as it allows
    message filtering, in which subscribers can decide what kind of messages they
    want to receive based on message attributes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些相关的模式——这种模式的变体。一个广泛使用的模式是发布-订阅模式。一个广泛使用且非常相似的模式是发布-订阅模式。你有消息而不是事件；你有订阅者而不是监听器；你有发布者而不是事件发射器。这种模式的主要优势通常是实现为使用网络层工作，因此可以被服务用于通过互联网相互通信。然而，与Node.js核心事件相比，这种模式实际上并不那么简单，可能会变得相当复杂，因为它允许消息过滤，订阅者可以根据消息属性决定他们想要接收什么样的消息。
- en: Usually, this pattern involves a third element, which is responsible for accepting
    publisher messages and delivering them to subscribers. This element can possibly
    scale and allow a more distributed architecture. On the other hand, as it decouples
    publishers and subscribers, publishers can lose the ability to know who is subscribed
    to which channels. Also, be aware of the message delivery, because the network
    layer can introduce many complications and slow down your workflow. This is not
    something you would want to depend on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种模式涉及第三个元素，负责接受发布者的消息并将其传递给订阅者。这个元素可能会扩展并允许更分布式的架构。另一方面，由于解耦了发布者和订阅者，发布者可能会失去知道谁订阅了哪些频道的能力。此外，要注意消息传递，因为网络层可能会引入许多复杂性并减慢你的工作流程。这不是你想依赖的东西。
- en: 'An event-driven architecture allows you to create an application in which the
    flow of information is determined by events. This is great but there are two things
    you shouldn''t forget:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动的架构允许你创建一个应用程序，其中信息的流动由事件决定。这很棒，但有两件事情你不应该忘记：
- en: Be careful not to create a kind of deadlock when your flow is expecting an event
    and it's never triggered or you've registered to listening too late. Usually,
    this is not fatal to your application, usually, this is not fatal to your application
    as you're not blocked waiting for the event, but your application will be in an
    intermediate state from where it can't get out and will probably be leaking memory.
    From the user perspective, your application is failing.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的流程期望事件发生时，要小心不要创建一种死锁，而事件却从未触发，或者你注册监听的时间太晚了。通常情况下，这对你的应用程序并不致命，因为你并没有被阻塞在等待事件，但你的应用程序将处于一个中间状态，无法摆脱，并且可能会泄漏内存。从用户的角度来看，你的应用程序是失败的。
- en: Always handle errors gracefully; don't ignore them. Core modules such as `http`
    and `net` throw exceptions when you don't properly handle error events. This means
    that an uncaught exception will be triggered and your application will stop fatally.
    You're not listening and ignoring uncaught exceptions, right?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 始终要优雅地处理错误；不要忽视它们。核心模块如`http`和`net`在你没有正确处理错误事件时会抛出异常。这意味着将触发未捕获的异常，你的应用程序将会严重停止。你不会忽略未捕获的异常，对吧？
- en: Overall, this is a nice generic pattern that fits perfectly into the Node.js
    platform, and is very handy when you need to communicate between several parts
    of your application. Also, the language itself, JavaScript, handles this pattern
    quite well by supporting anonymous functions, called closures.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这是一个非常适合Node.js平台的通用模式，当你需要在应用程序的几个部分之间进行通信时非常方便。此外，JavaScript本身通过支持匿名函数（称为闭包）很好地处理了这种模式。
- en: Streams
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流
- en: You might have noticed that events and streams are somehow related in Node.js.
    This is not by accident; it helps make a great workflow that is simple to understand
    and adapt. Streams use events to inform consumers about the data available for
    consumption and when the data reaches an end.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在Node.js中，事件和流有一定的关联。这并非偶然；它有助于构建一个简单易懂且易于适应的工作流程。流使用事件通知消费者有可供消费的数据以及数据何时到达末尾。
- en: 'One way of looking at streams is to look as if they were Unix pipes ([https://en.wikipedia.org/wiki/Pipeline_(Unix)](https://en.wikipedia.org/wiki/Pipeline_(Unix))).
    The goal is to be as useful as piping data across commands to read data, process
    it, transform it, and then output it. Streams are a fast and easy interface for
    creating readable, writable, duplex, and transform streams. Let''s look at the
    different types of streams, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从流的角度来看，可以将其视为Unix管道（[https://en.wikipedia.org/wiki/Pipeline_(Unix)](https://en.wikipedia.org/wiki/Pipeline_(Unix)））。目标是像在命令之间传输数据一样有用，以读取数据、处理数据、转换数据，然后输出数据。流是一个快速且易于使用的接口，用于创建可读、可写、双工和转换流。让我们来看看不同类型的流，如下所示：
- en: '**readable**: This is, for example, a file parser that reads some kind of format,
    such as CSV, and emits data events for each line. This stream can be piped to
    other types of streams. A readable stream can be in flowing mode, which means
    that data is piped as it becomes available at the source, and the paused mode
    where data has to be fetched manually when needed (and if available).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**readable**：例如，这是一个文件解析器，读取某种格式（如CSV），并为每一行发出数据事件。这个流可以被传输到其他类型的流中。可读流可以处于流动模式，这意味着数据在源头可用时被传输，以及暂停模式，其中数据必须在需要时手动获取（如果可用的话）。'
- en: '**writable**: Writing to a file or responding to a client are examples of this
    type of stream. Other examples are data compression streams (`zlib`) and cipher
    streams (`crypto`). This stream writes data to the destination and informs of
    its progress. It can also handle what it''s called back pressure, when data is
    being written to the stream and it''s not being handled in the opposite side,
    forcing the stream to keep data in memory.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可写**：向文件写入或响应客户端是此类型流的示例。其他示例包括数据压缩流（`zlib`）和加密流（`crypto`）。此流将数据写入目的地并通知其进度。它还可以处理所谓的回压，即当数据被写入流中但在另一侧未被处理时，强制流将数据保留在内存中。'
- en: '**duplex**: This is both a readable and writable stream, as it handles both
    the source and the destination. Examples of this type are sockets and, again,
    compression and cipher streams, depending on the objective.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双工**：这既是可读流又是可写流，因为它处理源和目的地。此类型的示例包括套接字以及压缩和加密流，具体取决于目标。'
- en: '**transform**: This stream is an extension of a duplex stream where you perform
    some kind of data transformation between the source and the destination. Compressing
    data is a good example of this type, but so is converting data between different
    formats.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：此流是双工流的扩展，在源和目的地之间执行某种数据转换。压缩数据是此类型的一个很好的示例，但在不同格式之间转换数据也是如此。'
- en: Buffers
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲区
- en: Another important piece of the puzzle in the Node.js platform is the buffer.
    Since JavaScript strings are encoded in Unicode, binary data might get scrambled
    in the process. Buffers are an alternative to manipulating binary data. As a bonus,
    you get several methods to read and write numbers in different sizes, whether
    big or little endian.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js平台中，另一个重要的组成部分是缓冲区。由于JavaScript字符串是以Unicode编码的，二进制数据可能在处理过程中被破坏。缓冲区是处理二进制数据的替代方法。作为奖励，您可以获得多种不同大小的读写数字的方法，无论是大端还是小端。
- en: Because of binary compatibility, the core modules use buffers in stream data
    events. Streaming a file to a client or receiving a file from a client and writing
    it to the disk is as simple as piping streams. And they just work because they
    pass buffers to each other.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二进制兼容性，核心模块在流数据事件中使用缓冲区。将文件流式传输到客户端或从客户端接收文件并将其写入磁盘就像管道流一样简单。它们之间可以直接传递缓冲区，因此它们可以直接工作。
- en: Optimizations
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: Using patterns improves your application, as you use well-proven and well-tested
    concepts that help developers to better understand and eventually improve your
    code. But improving your code doesn't end here. There is another type of pattern
    that varies from language to language, and we call it optimization.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式可以改进您的应用程序，因为您使用了经过充分验证和经过充分测试的概念，这有助于开发人员更好地理解并最终改进您的代码。但是改进您的代码并不止于此。还有一种模式，它因语言而异，我们称之为优化。
- en: An optimization is a pattern that is not specific to any problem but specific
    to a code structure. The idea is to change the code to be more efficient or to
    use less memory or other types of resources while doing the same thing. The goal
    of an optimization is not to get simpler code or to make it more readable. It
    can be bigger but still readable. Don't optimize for the sake of optimizing and
    reducing your code readability.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是一种模式，不是特定于任何问题，而是特定于代码结构。其思想是改变代码以使其更有效或使用更少的内存或其他类型的资源来完成相同的事情。优化的目标不是使代码更简单或更易读。它可能更大，但仍然可读。不要为了优化而优化，降低代码的可读性。
- en: As Node.js uses the V8 engine as the language processor, we have to use V8-specific
    optimizations in the code. Some optimizations work across versions, others not
    so much and the effort of optimizing might be worthless. This is because V8 is
    constantly improving and Node.js platform ships new versions with every release,
    so an optimization that was good yesterday because of bad performance of V8 on
    some aspect might not be worthwhile tomorrow when V8 fixes that performance issue.
    Now let's take a look at some optimizations that are worth noting.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node.js使用V8引擎作为语言处理器，我们必须在代码中使用V8特定的优化。一些优化跨版本有效，而其他一些则不太有效，优化的努力可能是徒劳的。这是因为V8不断改进，Node.js平台在每次发布时都会发布新版本，因此昨天因为V8在某些方面性能不佳而好的优化，可能在V8解决了该性能问题后，明天就不值得了。现在让我们来看看一些值得注意的优化。
- en: Hidden types
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏类型
- en: 'JavaScript has dynamic type. This means that a variable has a type that is
    dynamic, and so it can change from, say, a number to a string and vice-versa.
    This feature is hard to optimize at compile time, and V8 has a feature called
    **hidden types** where it shares optimizations between objects of the same type.
    For example, when you create an object using the `new` keyword, if every instance
    of the object does not undergo changes in its prototype, they all share the same
    hidden type and will use the same optimized code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript具有动态类型。这意味着变量具有动态类型，因此它可以从数字变为字符串，反之亦然。这个特性在编译时很难优化，V8有一个称为**隐藏类型**的功能，它在相同类型的对象之间共享优化。例如，当您使用`new`关键字创建对象时，如果对象的每个实例在其原型中没有发生更改，它们都共享相同的隐藏类型，并且将使用相同的优化代码：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This might not be achievable for complex objects, but for simpler objects, you
    can enforce it by just setting the properties in the constructor and then sealing
    the object to avoid any more changes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂对象可能无法实现这一点，但对于简单对象，您可以通过在构造函数中设置属性，然后封闭对象以避免更多的更改来强制执行它。
- en: Numbers
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'Again, since JavaScript has dynamic type, the numbers can change the type.
    The compiler will try to infer the type, and as soon as it knows it, it will tag
    the variable to that type in order to be able to perform operations with other
    variables. Changing the type after that is possible but expensive, so it''s better
    to avoid changing number types. More specifically, avoid getting in and out of
    the 31-bit signed integers:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于JavaScript具有动态类型，数字可以改变类型。编译器将尝试推断类型，一旦知道类型，它将标记变量为该类型，以便能够与其他变量执行操作。在此之后改变类型是可能的，但代价高昂，因此最好避免改变数字类型。更具体地说，避免进出31位有符号整数：
- en: '[PRE1]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Arrays
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'Arrays can have a variable length; it is changeable over time. For handling
    this, the compiler has some internal types for each specific type of Array, and
    switching between these types is not desirable. Arrays should have contiguous
    keys, starting from zero. Avoid deleting elements in the middle and accessing
    elements you didn''t initialize before. Similar to numbers, you should keep your
    Array elements in the same type. Also, if you know the size of an Array, you should
    point it out in the constructor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的长度可以是可变的。为了处理这个问题，编译器为每种特定类型的数组都有一些内部类型，并且在这些类型之间切换是不可取的。数组应该具有连续的键，从零开始。避免删除中间的元素并访问您之前未初始化的元素。与数字类似，您应该保持数组元素的相同类型。此外，如果您知道数组的大小，应该在构造函数中指出：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this specific example, it would be better to initialize all the elements
    up front to allow the compiler to know the hidden type before creating it, instead
    of inferring it twice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，最好在创建之前初始化所有元素，以便编译器在创建之前知道隐藏的类型，而不是推断两次。
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Functions
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions inherit from objects, and so the hidden types apply here too. Polymorphic
    functions will degrade performance substantially. If you want the best performance
    possible, create a separate function for every constructor you need:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 函数继承自对象，因此隐藏类型在这里也适用。多态函数会大大降低性能。如果您希望获得最佳性能，请为您需要的每个构造函数创建一个单独的函数：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, some uses of `arguments` are a performance killer. Avoid reassigning
    them (for example, when undefined). Instead, use another variable. You should
    only use arguments to check arguments length and look at a valid index:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一些对`arguments`的使用会降低性能。避免重新分配它们（例如，当未定义时）。而是使用另一个变量。您应该只使用`arguments`来检查参数长度并查看有效的索引：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The for-in loops
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for-in循环
- en: 'There are some performance penalties when using evaluating code in runtime
    is another feature loop, and for the best performance possible, you should avoid
    it and use a normal `for` loop. The performance penalty comes from edge cases
    where the compiler just can''t optimize. Always use `Object.keys` to get a list
    of keys in an object and then iterate that list:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时评估代码时会有一些性能损失，另一个特性循环，为了获得最佳性能，应该避免使用普通的`for`循环。性能损失来自编译器无法优化的边缘情况。始终使用`Object.keys`来获取对象中的键列表，然后迭代该列表：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The infinite loops
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限循环
- en: You should never create an infinite loop (`while (true) {}` or `for (;;) {}`).
    This is a rule of even greater importance for performance code. It's very hard
    to optimize an infinite loop, and it is preferable to refactor your code and review
    your logic.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您永远不应该创建无限循环（`while (true) {}`或`for (;;) {}`）。这对性能代码来说是一个更重要的规则。无限循环很难优化，最好重构您的代码并审查您的逻辑。
- en: The try-catch blocks
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try-catch块
- en: The try-catch blocks are important in order to be able to capture exceptions,
    but in an asynchronous architecture, they can be a bit less important. The compiler
    has difficulty in optimizing the scope inside try-catch, so you should try to
    move as much of your code out of the statement as you can.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: try-catch块在捕获异常方面很重要，但在异步架构中，它们可能不那么重要。编译器很难优化try-catch内部的范围，因此您应该尽量将尽可能多的代码移出语句。
- en: Eval
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eval
- en: Eval is another feature avoidable at all costs, as any function scope with an
    `eval` call will make the function unoptimizable. Never use this feature unless
    you really need it, and if you need it, put it in the smallest function possible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Eval是另一个可以避免的特性，因为带有`eval`调用的任何函数作用域都将使函数无法优化。除非真的需要，否则永远不要使用这个特性，如果需要，就把它放在尽可能小的函数中。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)账户中下载示例代码文件，用于您购买的所有Packt
    Publishing图书。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，文件将直接通过电子邮件发送给您。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Developing should be a great experience. Performant applications require some
    restrictions on how they are designed and developed. Knowing most of the common
    patterns helps choose wise paths for your application and avoids some performance
    penalties in the future. However, patterns are not all, and a solid understanding
    of what's behind the Node.js platform really helps you reach a few levels up on
    the performance scale.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 开发应该是一种很棒的体验。高性能的应用程序需要对它们的设计和开发进行一些限制。了解大多数常见模式有助于为您的应用程序选择明智的路径，并避免未来的一些性能损失。然而，模式并不是全部，对Node.js平台背后的东西有很好的理解真的有助于您在性能方面达到更高的水平。
- en: Even after choosing good patterns and doing the best at developing using some
    of the optimizations tips described in this chapter, the application can perform
    poorly on some scenarios. Don't optimize unless you need it. Follow the patterns
    and the tips, but don't think excessively about it until you test your application
    performance and realize that you need to optimize it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 即使选择了良好的模式并在开发中尽力使用本章中描述的一些优化技巧，应用程序在某些情况下可能表现不佳。除非需要，否则不要进行优化。遵循模式和技巧，但在测试应用程序性能并意识到需要优化之前不要过分考虑。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID bentham@gmail.com 用户编号：2843974 ©2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他使用都需要版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
