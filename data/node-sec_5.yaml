- en: Chapter 5. Response Layer Vulnerabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。响应层漏洞
- en: The last interaction you will have with a user request is, of course, the response.
    The discussion here will focus on vulnerabilities and best practices for this
    portion of your application code. This will include **Cross-site Scripting** (**XSS**),
    some vectors for **Denial of Service** (**DoS**) attacks, and even HTTP headers
    that various browsers use for implementing specific security policies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您与用户请求的最后交互当然是响应。这里的讨论将集中在应用程序代码的这一部分的漏洞和最佳实践。这将包括**跨站脚本攻击**（**XSS**），一些**拒绝服务**（**DoS**）攻击的向量，甚至各种浏览器用于实施特定安全策略的HTTP标头。
- en: Cross-site Scripting (XSS)
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本攻击（XSS）
- en: Cross-site Scripting (XSS) is one of the more popular topics while dealing with
    web applications, as it is the default behavior of HTML/CSS/JavaScript in many
    respects. Specifically, XSS is an attack vector that is used to inject untrusted
    and likely malicious code into a web page. Usually, this is taken as an opportunity
    to inject JavaScript code into your page that now has access to just about anything
    the client has access to in that particular web page.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击（XSS）是处理Web应用程序时的一个更受欢迎的话题，因为在许多方面，这是HTML/CSS/JavaScript的默认行为。具体来说，XSS是一种攻击向量，用于向Web页面注入不受信任且可能恶意的代码。通常，这被视为向您的页面注入JavaScript代码的机会，该代码现在可以访问特定Web页面中客户端几乎可以访问的任何内容。
- en: By default, JavaScript is executed in a global scope in the browser, including
    code that was injected by an untrusted source. This is the same behavior that
    your own, trusted code has, making it a dangerous vector with many possibilities.
    The malicious script could find the user's session ID (usually in a cookie), and
    use AJAX to send that information to someone that can then hijack the user's session.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JavaScript在浏览器中以全局范围执行，包括由不受信任的来源注入的代码。这与您自己的受信任代码的行为相同，使其成为具有许多可能性的危险向量。恶意脚本可以找到用户的会话ID（通常在cookie中），并使用AJAX将该信息发送给可以劫持用户会话的人。
- en: 'The injection commonly comes from the user input that is not filtered or sanitized
    before being output to the browser. Consider the following example code:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注入通常来自未经过滤或消毒的用户输入，然后输出到浏览器。考虑以下示例代码：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This script creates a server that simply sends an HTML form that is submitted
    (via `GET`) to another page. The second route simply outputs the user's input
    value to the browser.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本创建了一个服务器，简单地发送一个HTML表单，该表单通过`GET`提交到另一个页面。第二个路由简单地将用户输入的值输出到浏览器。
- en: If the user inputs their name (like Dominic) everything is well, and the user
    sees **"Hello, Dominic"** on the next page. However, what if the user enters something
    else, like raw HTML? In this case, it just outputs the HTML alongside our own
    HTML, and the browser can't tell the difference.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入他们的名字（比如Dominic），一切都很好，用户在下一页上看到**"Hello, Dominic"**。但是，如果用户输入了其他内容，比如原始HTML呢？在这种情况下，它只是将HTML与我们自己的HTML一起输出，浏览器无法区分。
- en: If you enter `<script>alert('hello!');</script>` in that text field instead,
    when you open the next page, you'll see **"Hello,"** and the browser will trigger
    an alert with **"hello!"** in the box. This is a harmless example, but this vulnerability
    has a huge potential for damage. These attacks are accomplished through what is
    known as untrusted data, which could be raw user input, information stored in
    a database, or accessed via a remote data source. The untrusted data is then used
    by your application to construct some sort of command that is then executed. The
    danger comes when the command is manipulated to perform some action that was not
    the original intent of the developers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在该文本字段中输入`<script>alert('hello!');</script>`，那么当您打开下一个页面时，您将看到**"Hello,"**，并且浏览器将触发一个带有**"hello!"**的警报框。这只是一个无害的例子，但这种漏洞有巨大的潜在危害。这些攻击是通过所谓的不受信任的数据完成的，这些数据可能是原始用户输入，存储在数据库中的信息，或者通过远程数据源访问的信息。然后，您的应用程序使用这些不受信任的数据来构造某种命令，然后执行该命令。当命令被操纵以执行开发人员原始意图之外的某些操作时，危险就会出现。
- en: 'The prototypical example of this type of attack is a SQL injection, which is
    where the untrusted data is used to alter a SQL command. Consider the following
    code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型攻击的原型示例是SQL注入，其中不受信任的数据用于更改SQL命令。考虑以下代码：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Assume that the username variable comes from the user input, and the point
    is that it is an untrusted data as we have defined it. If the user enters something
    innocuous, like `''Dominic''`, then all is well, and the generated SQL looks like
    the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户名变量来自用户输入，重点是它是我们定义的不受信任的数据。如果用户输入了一些无害的东西，比如`'Dominic'`，那么一切都很好，生成的SQL看起来像以下代码：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What if someone enters something less harmless, like: `'''' OR 1=1`, then the
    generated SQL becomes like the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人输入了一些不那么无害的东西，比如：`'' OR 1=1`，那么生成的SQL就会变成以下样子：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This changes the meaning of the query entirely, rather than restricting to
    one user with a matching name, now every row is returned. This could be even more
    disastrous, consider the value: `''''; DROP TABLE users;`, it would generate a
    SQL like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全改变了查询的含义，而不是限制为具有匹配名称的一个用户，现在返回了每一行。这可能会更加灾难性，考虑值：`''; DROP TABLE users;`，它将生成以下SQL：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Without any additional access, the user has caused a devastating loss of data
    to our application, probably bringing the entire application down for all users.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何额外的访问权限，用户已经导致了我们应用程序的严重数据损失，可能会使所有用户无法使用整个应用程序。
- en: 'As it turns out, XSS is another type of injection attack, and the web browser
    and the HTML, CSS, and JavaScript that they execute, are optimized for these types
    of attacks. There are many different contexts within each of these languages that
    we need to be aware of. Consider the following template:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，XSS是另一种类型的注入攻击，Web浏览器和它们执行的HTML、CSS和JavaScript都针对这些类型的攻击进行了优化。我们需要了解每种语言中的许多不同上下文。考虑以下模板：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With our untrusted data, we could easily cause trouble by injecting additional
    HTML into this value, such as `<script>alert(''xss'');</script>`, which would
    generate the following HTML code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们不信任的数据，我们可以很容易地通过向该值注入额外的HTML来引起麻烦，比如`<script>alert('xss');</script>`，这将生成以下HTML代码：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The solution here is to use an HTML escaping on any untrusted data added to
    the page in this context. This technique turns characters that are important in
    HTML, such as angle brackets and quotes, into their corresponding HTML entity;
    preventing them from altering the structure of the HTML they are embedded within.
    The following table is an example of this conversion:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是在这个上下文中对任何添加到页面的不受信任的数据使用HTML转义。这种技术将HTML中重要的字符，比如尖括号和引号，转换为它们对应的HTML实体；防止它们改变嵌入其中的HTML结构。以下表格是这种转换的一个例子：
- en: '| Character | Entity |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 实体 |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Less than sign (`<`) | `&lt;` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 小于号 (`<`) | `&lt;` |'
- en: '| Greater than sign (`>`) | `&gt;` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 大于号 (`>`) | `&gt;` |'
- en: '| Double quote (`"`) | `&quot;` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 双引号 (`"`) | `&quot;` |'
- en: '| Single quote (`''`) | `''` `(&apos;` is not a valid HTML and should be avoided)
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 单引号 (`''`) | `''`（`&apos;`不是有效的HTML，应该避免使用） |'
- en: '| Ampersand (`&`) | `&amp;` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 和号 (`&`) | `&amp;` |'
- en: '| Forward slash (`/`) | `/` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 斜杠 (`/`) | `/` |'
- en: This method of escaping makes it harder for an attacker to alter the structure
    of your HTML, making this a very important technique for securing your web pages.
    However, different contexts will require further escaping techniques that we will
    address shortly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转义方法使得攻击者更难改变你的HTML结构，这是保护你的网页非常重要的技术。然而，不同的上下文将需要更多的转义技术，我们将很快讨论。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Many popular templating libraries include automatic HTML escaping by default,
    but some do not. This should be an important factor to you for choosing a template
    framework or library.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的模板库默认包括自动的HTML转义，但有些则不包括。这对于选择模板框架或库对你来说应该是一个重要因素。
- en: 'HTML attributes could be injected with other HTML meant to create a new context,
    such as closing the attribute and starting a new attribute. Further still, this
    injected HTML could be used to close the HTML tag, and inject more HTML in another
    context. Consider the following template:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: HTML属性可以被注入其他HTML，用于创建一个新的上下文，比如关闭属性并开始一个新的属性。更进一步，这个注入的HTML可以用来关闭HTML标签，并在另一个上下文中注入更多的HTML。考虑以下模板：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Consider the following injected value for height: `100 onload="javascript:alert(''XSS'');"`,
    which would generate the following HTML:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用于高度的注入值：`100 onload="javascript:alert('XSS');"`, 这将生成以下HTML：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The result is injected JavaScript code. HTML encoding as we used before is not
    enough in this particular context, as the preceding is still a perfectly valid
    HTML. In addition to HTML escaping as we mentioned before, you should require
    quotes around all HTML attributes, particularly when untrusted data is involved.
    To cover all cases, even unquoted attributes, you could encode all ASCII values
    below 256 to their HTML entity format or an available named entity like `&quot;`,
    if available).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是注入的JavaScript代码。在这种特定的上下文中，像我们之前使用的HTML编码是不够的，因为前面仍然是一个完全有效的HTML。除了我们之前提到的HTML转义，你应该要求在所有HTML属性周围加上引号，特别是当涉及到不受信任的数据时。为了涵盖所有情况，甚至是未引用的属性，你可以将所有ASCII值低于256编码为它们的HTML实体格式或可用的命名实体，比如`&quot;`。
- en: 'HTML attributes that involve URLs, such as `href` and `src`, are another context
    altogether that require their own encoding. Consider the following template:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及URL的HTML属性，比如`href`和`src`，是另一个需要自己编码的上下文。考虑以下模板：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the user enters the following data: `javascript:alert(''XSS'');`, then the
    following HTML is generated:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入以下数据：`javascript:alert('XSS');`，那么将生成以下HTML：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An HTML encoding is not applicable here, as the preceding is a valid HTML markup.
    Instead, a fully-qualified URL should be checked for unexpected protocols. Here,
    we used `javascript:`, which gets the browser to execute arbitrary code, behaving
    like the `eval()` function. Lastly, the output should be escaped via the built-in
    JavaScript function called `encodeURI()`, which escapes characters that are invalid
    in URLs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不适用HTML编码，因为前面是有效的HTML标记。相反，应该检查一个完全合格的URL是否包含意外的协议。在这里，我们使用了`javascript:`，这会让浏览器执行任意代码，就像`eval()`函数一样。最后，输出应该通过内置的JavaScript函数`encodeURI()`进行转义，该函数转义URL中无效的字符。
- en: 'The last example I will show here is partial URLs within attributes like the
    ones mentioned previously. Using the following template:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里展示的最后一个例子是在先前提到的属性中部分URL。使用以下模板：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `nextPage` variable is being used as a part of a URL, rather than being
    the URL itself. The `encodeURI()` function we mentioned earlier has a companion
    called `encodeURIComponent()`, which escapes more characters, because it is meant
    to encode a single query-string parameter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextPage`变量被用作URL的一部分，而不是URL本身。我们之前提到的`encodeURI()`函数有一个伴侣叫做`encodeURIComponent()`，它转义更多的字符，因为它是用来编码单个查询字符串参数的。'
- en: 'Another common anti-pattern is injecting JSON data into a page directly to
    share data between the server and client while rendering a page. Consider the
    following template:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的反模式是直接将JSON数据注入页面，以在渲染页面的同时在服务器和客户端之间共享数据。考虑以下模板：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This particular technique, while convenient, can allow for XSS attacks as well.
    Let's assume the `serverData` object has a single property called `username` that
    reflects the current user's name. Let's also assume that this value is able to
    be set by the user without any sort of filtering between the user's input and
    the display on the page (which of course should not happen).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的技术，虽然方便，也可能导致XSS攻击。假设`serverData`对象有一个名为`username`的属性，反映了当前用户的名字。还假设这个值可以由用户设置，而没有任何过滤，直接在用户输入和页面显示之间（当然不应该发生）。
- en: 'If the user changes his name to `</script><script>alert(''XSS'')</script>`
    then the output HTML would look like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户将他的名字改为`</script><script>alert('XSS')</script>`，那么输出的HTML将如下所示：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: According to the HTML specification, a `</` character (even within a JavaScript
    string, as we have here) will be interpreted as a closed tag, and the attacker
    has just created a brand new script tag that, like any other script tag, has full
    control over the page.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据HTML规范，`</`字符（即使在JavaScript字符串中，就像我们这里）将被解释为一个闭合标签，攻击者刚刚创建了一个全新的脚本标签，就像任何其他脚本标签一样，它对页面有完全控制权。
- en: 'Rather than simply trying to escape the JSON data directly, the best way to
    mitigate this problem is to inject your JSON data, using another method altogether:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与其直接尝试转义JSON数据，减轻这个问题的最佳方法是使用另一种方法来注入你的JSON数据：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method uses a script tag, with a predefined ID that we can use to retrieve
    it. When a browser encounters a script type it does not understand, it will simply
    not execute it, in addition to leaving it hidden from the user. The contents of
    this script tag will be an HTML-escaped version of our JSON, which ensures we
    have no context boundary crossing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用了一个带有预定义ID的脚本标签，我们可以用它来检索它。当浏览器遇到它不理解的脚本类型时，它将简单地不执行它，同时将其隐藏在用户面前。这个脚本标签的内容将是我们的JSON的HTML转义版本，这样可以确保我们没有上下文边界的交叉。
- en: Next, we use another script (preferably in an external file, but by no means
    required) with the code that finds the script element we defined, and retrieves
    its text content. By using the `textContent/innerText` property instead of `innerHTML`,
    we get additional escaping that the browser performs for us, just in case. Lastly,
    we run the JSON data through `JSON.parse` to actually perform the JSON decoding.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用另一个脚本（最好是外部文件，但绝不是必需的），其中包含查找我们定义的脚本元素并检索其文本内容的代码。通过使用`textContent/innerText`属性而不是`innerHTML`，我们得到了浏览器为我们执行的额外转义，以防万一。最后，我们通过`JSON.parse`运行JSON数据来实际执行JSON解码。
- en: While this method requires more fanfare, and is going to be a bit slower than
    the first example, it is going to be far more secure, which is a great trade-off
    to make.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法需要更多的宣传，而且比第一个例子要慢一些，但它会更安全，这是一个很好的权衡。
- en: These examples are by no means an exhaustive list, but they should illustrate
    the point that HTML, CSS, and JavaScript each have contexts that allow for various
    types of code injection. Never trust your user input, and make sure you use the
    appropriate escaping method depending on the context.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子绝不是一个详尽的列表，但它们应该说明HTML、CSS和JavaScript各自都有上下文，允许各种类型的代码注入。永远不要相信用户输入，并确保根据上下文使用适当的转义方法。
- en: The **Open Web Application Security Project** (**OWASP**) is a foundation that
    maintains a wiki ([http://www.owasp.org/](http://www.owasp.org/)) that specifically
    addresses security considerations for all web applications. They have articles
    on many attack vectors, including a more comprehensive checklist for preventing
    many more varieties of XSS attacks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放式Web应用安全项目**（**OWASP**）是一个维护维基（[http://www.owasp.org/](http://www.owasp.org/)）的基金会，专门针对所有Web应用程序的安全考虑。他们有关于许多攻击向量的文章，包括一个更全面的检查表，用于防止许多更多种类的XSS攻击。'
- en: Denial of Service
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拒绝服务
- en: A **Denial of Service** (**DoS**) attack can come in a variety of forms, but
    the main intent is to prevent users from having access to your application. One
    method is to flood your server with a large amount of requests, tying up your
    server's resources and preventing legitimate requests from being fulfilled.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**拒绝服务**（**DoS**）攻击可以采用各种形式，但主要目的是阻止用户访问你的应用程序。一种方法是向服务器发送大量请求，占用服务器的资源，阻止合法请求得到满足。'
- en: Request flooding typically targets multithreaded servers, like **Apache**. This
    is because the process of spawning a new thread for each request gives an easy-to-reach
    upper limit on the number of simultaneous requests. With Node.js platform's event
    loop, this particular type of attack is not usually as effective, although that's
    not to say that it is impossible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请求洪水通常针对多线程服务器，比如**Apache**。这是因为为每个请求生成一个新线程的过程为同时请求的数量提供了一个容易达到的上限。对于Node.js平台的事件循环，这种特定类型的攻击通常不那么有效，尽管这并不意味着它是不可能的。
- en: The event loop can still expose applications if used improperly, I cannot stress
    enough how important it is to understand how it works, while writing any Node.js
    application. The contract your application code has with the event loop is to
    always run as fast as possible. There is only one piece of your application running
    at once, so CPU-intensive can tie up resources as well. This applies in all cases,
    but I mention it in this chapter to specifically address your response handlers.
    Generally, receiving the request itself is less resource-intensive than performing
    the actions necessary to generate the appropriate response.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不正确使用事件循环，事件循环仍然可能会暴露应用程序，我无法强调理解它的重要性有多大，同时编写任何Node.js应用程序。你的应用程序代码与事件循环的约定是尽可能快地运行。一次只有一个应用程序的部分在运行，所以CPU密集型也可能占用资源。这适用于所有情况，但我在这一章中提到它是为了特别解决你的响应处理程序。
- en: As mentioned earlier, use streams whenever possible, especially while dealing
    with network requests or the filesystem. Dealing with large blobs of data can
    be time-consuming depending on how you are processing that data, the use of streams
    can break those large operations into many small chunks, allowing other requests
    to be satisfied in the process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，尽可能使用流，特别是在处理网络请求或文件系统时。处理大块数据可能是耗时的，取决于你如何处理这些数据，使用流可以将这些大操作分解成许多小块，从而在过程中满足其他请求。
- en: Security-related HTTP headers
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与安全相关的HTTP头
- en: There are some HTTP headers available that can help add some security to our
    web applications. We will be looking at a module called **helmet**, which is written
    as a collection of Connect/Express middleware that adds these headers depending
    on your configuration. We will examine each of the middleware functions that helmet
    includes, as well as a brief explanation of their effects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些可用的HTTP标头可以帮助我们的Web应用程序增加一些安全性。我们将看一下一个名为**头盔**的模块，它被编写为一个Connect/Express中间件的集合，根据您的配置添加这些标头。我们将检查头盔包括的每个中间件函数，以及它们的效果的简要解释。
- en: Content security policy
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容安全策略
- en: First, helmet supports setting headers for a newer security mechanism for HTML
    and web applications called **Content Security Policy** (**CSP**). XSS attacks
    circumvent the **Same-Origin Policy** (**SOP**) by using other methods to trick
    browsers into delivering harmful content.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，头盔支持为HTML和Web应用程序的一种新的安全机制设置标头，称为**内容安全策略**（**CSP**）。XSS攻击通过使用其他方法欺骗浏览器传递有害内容来规避**同源策略**（**SOP**）。
- en: For browsers that support this feature, you can restrict resources, such as
    images, frames, or fonts to be loaded via white-listed domains. This limits the
    impact of XSS attacks by hopefully preventing access to untrusted domains for
    loading malicious content.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持此功能的浏览器，您可以将资源（例如图像、框架或字体）限制为通过白名单域加载。这通过希望阻止访问不受信任的域加载恶意内容，从而限制了XSS攻击的影响。
- en: 'CSP is communicated to a browser via one or more `Content-Security-Policy`
    HTTP headers, such as:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: CSP通过一个或多个`Content-Security-Policy` HTTP标头传达给浏览器，例如：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This header will instruct the browser to require that all scripts load from
    the current domain only. Any scripts the browser detects coming from any other
    domains will be blocked outright.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此标头将指示浏览器要求所有脚本仅从当前域加载。浏览器检测到来自任何其他域的脚本将被直接阻止。
- en: 'A CSP header is constructed as a list of directives separated by semicolons.
    An example of a header that implements multiple CSP restrictions looks like the
    following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CSP标头是由分号分隔的一系列指令构成的。实现多个CSP限制的标头示例如下：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This header instructs the browser to restrict scripts to only the current domain
    (like our previous example), and forbids the use of frames (including iframes)
    and objects altogether.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此标头指示浏览器仅限制脚本到当前域（与我们之前的示例相同），并且完全禁止使用框架（包括iframes）和对象。
- en: Each directive is named `*-src`, and it is followed by a space-separated list
    of either predefined keywords (which must be wrapped in quotes) or domain URLs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指令都被命名为`*-src`，后面跟着一个以空格分隔的预定义关键字列表（必须用引号括起来）或域URL。
- en: 'The available keywords include the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的关键字包括以下内容：
- en: '`''self''`: This restricts script to the current domain'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''self''`：这将脚本限制为当前域'
- en: '`''none''`: This restricts all domains (none can be loaded at all)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''none''`：这限制了所有域（根本不能加载）'
- en: '`''unsafe-inline''`: This allows inline code (you are highly advised to avoid
    this, more discussion later)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''unsafe-inline''`：这允许内联代码（强烈建议避免，稍后讨论）'
- en: '`''unsafe-eval''`: This allows text-to-JavaScript mechanisms like `eval()`
    (also highly advised against)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''unsafe-eval''`：这允许文本到JavaScript的机制，如`eval()`（同样强烈不建议）'
- en: 'The following directives are available:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的指令包括以下内容：
- en: '`connect-src`: This restricts the domains that can be connected to via XHR
    and WebSockets'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect-src`：这限制了可以通过XHR和WebSockets连接的域'
- en: '`font-src`: This limits the domains that can be used to download font files'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font-src`：这限制了可以用于下载字体文件的域'
- en: '`frame-src`: This limits the domains that frames (including inline frames)
    can load'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame-src`：这限制了可以加载框架（包括内联框架）的域'
- en: '`img-src`: This limits the domains that images can be loaded from'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img-src`：这限制了可以从中加载图像的域'
- en: '`media-sr`: This limits the origins for video and audio'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media-sr`：这限制了视频和音频的来源'
- en: '`object-src`: This allows control over the origins for objects (for example,
    Flash)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object-src`：这允许控制对象的来源（例如Flash）'
- en: '`script-src`: This restricts the domains that scripts can be loaded from'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script-src`：这限制了可以从中加载脚本的域'
- en: '`style-src`: This limits the domains that stylesheets can be loaded from'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style-src`：这限制了可以从中加载样式表的域'
- en: '`default-src`: This acts as a shorthand for all the directives combined'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default-src`：这充当所有指令的缩写'
- en: Leaving out a directive leaves its policy wide open, (as is the default behavior)
    unless you specify the `default-src` directive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 省略指令会使其策略完全开放（这是默认行为），除非您指定`default-src`指令。
- en: 'Helmet can construct the headers for each supported User Agent (for example,
    browser) based on the configuration you pass to the middleware. By default, it
    will give the following CSP header:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 头盔可以根据您传递给中间件的配置为每个支持的用户代理（例如浏览器）构造标头。默认情况下，它将提供以下CSP标头：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a very strict policy, as it will only allow external resources to be
    loaded from the current domain, and nowhere else. In most cases, this is simply
    too restrictive, particularly if you are going to be using a CDN or allowing external
    services to communicate with your own.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常严格的策略，因为它只允许从当前域加载外部资源，而不允许从其他任何地方加载。在大多数情况下，这太过严格，特别是如果您要使用CDN或允许外部服务与您自己通信。
- en: 'You can configure helmet via the middleware definition function, by adding
    a property called `defaultPolicy` that contains your directives as an object hash,
    for example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过中间件定义函数来配置头盔，通过添加一个名为`defaultPolicy`的属性，其中包含您的指令作为对象哈希，例如：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will instruct helmet to send the following header:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示头盔发送以下标头：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will restrict scripts and images to the current domain as well as the domain
    [http://example.com/](http://example.com/).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将限制脚本和图像仅限于当前域以及域[http://example.com/](http://example.com/)。
- en: 'CSP also includes a reporting capability that you can use for auditing your
    own applications and detect vulnerabilities quickly. There is a `report-uri` directive
    just for this purpose, which tells the browser what URI to send a violation report
    to. Refer the following example code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: CSP还包括了一个报告功能，你可以用来审计自己的应用程序并快速检测漏洞。有一个专门用于此目的的`report-uri`指令，告诉浏览器发送违规报告的URI。参考以下示例代码：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the report is sent by the browser, it is a JSON document with the following
    structure:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器发送报告时，它是一个具有以下结构的JSON文档：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This report includes most of the information you should need to track down
    the violation, namely:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这份报告包括了大部分你需要追踪违规行为的信息，即：
- en: '`document-uri`: The page that the violation occurred on'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document-uri`：发生违规的页面'
- en: '`blocked-uri`: The violating resource'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blocked-uri`：违规资源'
- en: '`violated-directive`: The specific directive that was violated'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`violated-directive`：违反的具体指令'
- en: '`original-policy`: The page''s policy (the contents of the CSP header)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`original-policy`：页面的策略（CSP头的内容）'
- en: When first starting out with CSP, it may not be wise to set up a policy and
    start blocking right away. While you are in the process of detailing your application's
    policy, you can set up CSP to respect report-only mode.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当刚开始使用CSP时，可能不明智立即设置策略并开始阻止。在详细说明应用程序策略的过程中，你可以设置CSP以尊重报告模式。
- en: This allows you to set up a complete policy, and rather than blocking users
    right away, you can simply receive reports detailing violations. This gives you
    a way to fine-tune your policy before putting it into effect.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你设置完整的策略，而不是立即阻止用户，你可以简单地接收详细违规报告。这为你提供了在实施之前微调策略的方法。
- en: 'To enable report-only mode, you simply change the HTTP header name. Instead
    of what we''ve been using, you simply use `Content-Security-Policy-Report-Only`,
    leaving everything else the same:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用报告模式，你只需更改HTTP头部名称。不再使用我们一直在使用的，而是简单地使用`Content-Security-Policy-Report-Only`，其他一切保持不变：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In helmet, you enable report-only mode by including the `reportOnly` parameter
    in your configuration object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在helmet中，通过在配置对象中包含`reportOnly`参数来启用报告模式：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This sets up the same policy we used earlier, just with the addition of report-only
    mode.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了我们之前使用的相同策略，只是增加了报告模式。
- en: CSP is an excellent security mechanism that you should start using right away,
    despite browser support isn't entirely there. As of this writing, it is a **W3C
    Candidate Recommendation**, and browsers are expected to implement this feature
    at a rapid pace.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: CSP是一种出色的安全机制，你应该立即开始使用，尽管浏览器支持并不完全。截至本文撰写时，它是**W3C候选推荐**，预计浏览器将以快速的速度实现这一功能。
- en: HTTP Strict Transport Security (HSTS)
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP严格传输安全（HSTS）
- en: '**HTTP Strict Transport Security** (**HSTS**) is a mechanism that communicates
    to a user agent (for example, a web browser) that a particular application should
    only be accessed via HTTPS, because it is an encrypted communication. If your
    application ideally exists only over a secure connection, this allows you to officially
    declare it to the browser.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP严格传输安全**（HSTS）是一种机制，向用户代理（例如，Web浏览器）通信，特定应用程序应仅通过HTTPS访问，因为这是加密通信。如果你的应用程序理想情况下只存在于安全连接上，这允许你正式向浏览器声明。'
- en: 'There are only two parameters to this header, the `max-age` directive that
    tells the browser how long (in seconds) to respect the configuration, as well
    as the `includeSubDomains` directive that treats subdomains of the current domain
    in the same fashion. Like CSP, this is communicated via an HTTP header:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头部只有两个参数，`max-age`指令告诉浏览器要尊重配置的时间（以秒为单位），以及`includeSubDomains`指令以相同方式处理当前域的子域。与CSP一样，这是通过HTTP头部通信的：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This tells the browser, for around six months, that the current domain from
    now on should be accessed via HTTPS (even if the user accessed it via HTTP). This
    is the default configuration set by helmet, which is the simplest to implement:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉浏览器，大约六个月内，当前域从现在开始应该通过HTTPS访问（即使用户通过HTTP访问）。这是由helmet设置的默认配置，也是最简单的实现方式：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This sets up the middleware for HSTS using the previously stated configuration,
    the middleware definition function also takes two optional parameters. First,
    the `max-age` directive can be set as a number (which should be represented in
    seconds). Second, the `includeSubDomains` directive can be set as a simple Boolean
    value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用先前说明的配置设置了HSTS的中间件，中间件定义函数还接受两个可选参数。首先，`max-age`指令可以设置为一个数字（应以秒表示）。其次，`includeSubDomains`指令可以设置为一个简单的布尔值：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will set the following header:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置以下头部：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Browser support is not currently as complete as CSP, but is expected to proceed
    down that path. In the meantime, it is worth adding to your application's security
    detail.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器支持目前并不像CSP那样完整，但预计会朝着这个方向前进。与此同时，将其添加到应用程序的安全详细信息中是值得的。
- en: X-Frame-Options
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: X-Frame-Options
- en: This header controls whether or not a particular page is allowed to be loaded
    into either a `<frame>` or an `<iframe>` element. This is useful mainly to prevent
    malicious users from hijacking (or "clickjacking") your users, and thereby tricking
    them into performing actions they otherwise had no intention of doing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头部控制特定页面是否允许加载到`<frame>`或`<iframe>`元素中。这主要用于防止恶意用户劫持（或“点击劫持”）你的用户，从而欺骗他们执行他们本来没有打算执行的操作。
- en: 'This is communicated to the browser via another HTTP header, so when the browser
    loads a URL for a frame/iframe, it will check for this header to determine the
    course of action to take. The header looks like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过另一个HTTP头部通信给浏览器的，因此当浏览器加载一个框架/iframe的URL时，它将检查这个头部以确定采取的行动。头部看起来像下面这样：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we are using the value `DENY`, which is the default when configured via
    helmet. Other available options include `sameorigin`, which only allows the domain
    to be loaded in a frame when on the current domain. The last option is the `allow-from`
    option that allows you to specify a whitelist of URIs that can render the current
    page in a frame.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用值`DENY`，这是通过头盔配置时的默认值。其他可用选项包括`sameorigin`，它只允许在当前域上加载域。最后一个选项是`allow-from`选项，允许您指定可以在框架中呈现当前页面的URI白名单。
- en: 'In most cases, the default should work just fine, and you can set that up via
    helmet like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，默认设置应该工作得很好，您可以通过头盔这样设置：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This adds the header as we saw it previously displayed. To configure using
    the `sameorigin` option, use the following configuration:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加我们之前看到的标头。要使用`sameorigin`选项进行配置，请使用以下配置：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, this sets up the `allow-from` variant, which also gives you the second
    parameter for setting allowed URIs:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这将设置`allow-from`变体，还为您提供了设置允许的URI的第二个参数：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Browser support for this security mechanism is quite good, so it's safe to implement
    right away. The `allow-from` header is a caveat, which is not supported evenly,
    so make sure you research the specifics depending on your requirements before
    using it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种安全机制，浏览器支持非常好，因此可以立即实施。`allow-from`标头是一个警告，不是均匀支持的，因此在使用之前，请确保根据您的要求研究具体情况。
- en: X-XSS-Protection
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: X-XSS-Protection
- en: This next header is specific to Internet Explorer, and it enables the XSS filter.
    Rather than explain it myself, here is an explanation from the **Microsoft Developer
    Network** (**MSDN**).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个下一个标头是特定于Internet Explorer的，它启用了XSS过滤器。而不是我自己解释，这是来自**Microsoft Developer
    Network**（**MSDN**）的解释。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The XSS filter operates as an Internet Explorer 8 component with visibility
    into all requests/responses flowing through the browser. When the filter discovers
    likely XSS in a cross-site request, it identifies and neuters the attack if it
    is replayed in the server''s response. For further information please visit: [http://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: XSS过滤器作为Internet Explorer 8组件运行，可以查看浏览器中流动的所有请求/响应。当过滤器在跨站点请求中发现可能的XSS时，它会在服务器的响应中识别并中和攻击。有关更多信息，请访问：[http://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx)
- en: 'This featured is likely enabled by default, but in case the user has disabled
    it themselves or in some select zones, it can be enabled with a simple header
    that looks like the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能可能默认情况下已启用，但是如果用户自己禁用了它或在某些选择区域禁用了它，可以使用类似以下的简单标头来启用它：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By setting the header as 0, forces the XSS filter to be disabled, but that
    configuration is not exposed via helmet. In fact, it has no configuration at all,
    so its usage is as simple as:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将标头设置为0，强制禁用XSS过滤器，但该配置不通过头盔公开。实际上，它根本没有配置，因此其使用就像这样简单：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: X-Content-Type-Options
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: X-Content-Type-Options
- en: This is another header that puts a stop to a specific behavior in certain browsers
    (Internet Explorer and Google Chrome are currently the only browsers that support
    this). In this case, the browser will attempt to "sniff" (for example, guess)
    the MIME type of a returned resource, even if that resource sets a valid `Content-Type`
    header on its own.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个标头，它阻止某些浏览器的特定行为（目前只有Internet Explorer和Google Chrome支持此功能）。在这种情况下，即使资源本身设置了有效的`Content-Type`标头，浏览器也会尝试“嗅探”（例如，猜测）返回资源的MIME类型。
- en: This could allow the browser to be fooled into executing or rendering a file
    in a way that was unintended by the developers, causing potential security vulnerabilities
    depending upon a number of factors. The point is that your server's `Content-Type`
    header should be the only consideration the browser makes, rather than trying
    to guess on its own.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致浏览器被欺骗以执行或呈现开发人员意外的方式的文件，这取决于许多因素可能导致潜在的安全漏洞。关键是您的服务器的`Content-Type`标头应该是浏览器考虑的唯一因素，而不是试图自行猜测。
- en: 'Like the previous example, there is no real configuration available, and the
    following header will simply be added to your application:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，没有真正的配置可用，以下标头将简单地添加到您的应用程序中：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This header is configured with helmet via:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过头盔配置此标头：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Cache-Control
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cache-Control
- en: 'The last middleware that helmet provides is one for setting the `Cache-Control`
    header to `no-store` or `no-cache`. This prevents browsers from caching a given
    response. This middleware also has no configuration, and is included via:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 头盔提供的最后一个中间件是用于将`Cache-Control`标头设置为`no-store`或`no-cache`。这可以防止浏览器缓存给定的响应。这个中间件也没有配置，并且是通过以下方式包含的：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You would use this middleware and header to prevent the browser from storing
    and caching pages that may contain sensitive user information. However, the trade-off
    is that you could take a serious performance hit when applying it across the board.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用此中间件和标头来防止浏览器存储和缓存可能包含敏感用户信息的页面。然而，这样做的折衷是当在整体应用程序中应用时，您可能会遇到严重的性能问题。
- en: When it comes to static files and assets, such as style sheets and images, this
    header will only slow your site down, and likely adding no security benefits while
    doing so. Make sure to be careful how and where you apply this particular middleware
    within your overall application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理静态文件和资源（例如样式表和图像）时，此标头只会减慢您的站点速度，并且可能不会增加任何安全性好处。确保小心地在整体应用程序中如何以及何处应用此特定中间件。
- en: The helmet module is a quick way to add these useful security features to your
    application, which is enabled by the powerful middleware architecture that Connect
    has created. There's a lot to many of these security features that cannot be addressed
    here, and will likely change in the future, so it's best to become familiar with
    all of them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 头盔模块是向您的应用程序添加这些有用的安全功能的快速方法，这是由Connect创建的强大中间件架构启用的。有很多这些安全功能中的许多无法在这里解决，并且可能会在将来发生变化，因此最好熟悉它们所有。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at vulnerabilities that show up in the response phase
    of application processing, such as XSS and DoS. We also looked at ways to mitigate
    those specific problems, whether by defensive coding or using newer security standards
    and policies to our advantage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了在应用程序处理的响应阶段出现的漏洞，比如XSS和DoS。我们还研究了如何通过防御性编码或利用更新的安全标准和政策来减轻这些特定问题。
