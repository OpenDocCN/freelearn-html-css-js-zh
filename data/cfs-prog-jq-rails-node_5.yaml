- en: Chapter 5. CoffeeScript and Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. CoffeeScript 和 Node.js
- en: Ryan Dahl created Node.js in 2009\. His goal was to create a system with which
    one can write network server applications having high performance, using JavaScript.
    At that time, JavaScript was mostly run inside browsers, so a server-side framework
    needed some way to run JavaScript without it. Node uses Google's V8 JavaScript
    engine, originally written for the Chrome browser, but since it's a separate piece
    of software, it can run JavaScript code anywhere. Node.js lets you write JavaScript
    code that can be executed on the server. It can make full use of your operating
    system, databases, and other external network resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ryan Dahl 在 2009 年创建了 Node.js。他的目标是创建一个系统，使用户能够编写高性能的网络服务器应用程序，使用 JavaScript。当时，JavaScript
    主要在浏览器中运行，因此服务器端框架需要某种方式来运行 JavaScript 而不依赖浏览器。Node 使用了 Google 的 V8 JavaScript
    引擎，最初是为 Chrome 浏览器编写的，但由于它是一个独立的软件组件，它可以在任何地方运行 JavaScript 代码。Node.js 允许你编写可以在服务器上执行的
    JavaScript 代码。它可以充分利用你的操作系统、数据库和其他外部网络资源。
- en: Let's talk about some of the features of Node.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈 Node.js 的一些特性。
- en: Node is event-driven
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node 是事件驱动的
- en: The Node.js framework only allows non-blocking, asynchronous I/O. This means
    that any I/O operation that is accessing an external resource, such as the operating
    system, a database, or a network resource must happen asynchronously. This works
    by using events, or callbacks that are fired once the operation succeeds or fails.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 框架只允许非阻塞、异步 I/O。这意味着任何访问外部资源（如操作系统、数据库或网络资源）的 I/O 操作都必须异步进行。这是通过使用事件或回调来实现的，一旦操作成功或失败，就会触发回调。
- en: The benefit of this is that your application becomes much more scalable, because
    requests don't have to wait around for slow I/O operations to finish and can instead
    handle more incoming requests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的好处是，你的应用程序会变得更加可扩展，因为请求不需要等待缓慢的 I/O 操作完成，而是可以处理更多的传入请求。
- en: Similar frameworks do exist in other languages, such as **Twisted** and **Tornado**
    in Python, and **EventMachine** in Ruby. A big problem with these frameworks is
    that all I/O libraries they use must also be non-blocking. Often, one can end
    up accidentally using code that blocks an I/O operation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言中也有类似的框架，例如 Python 中的 **Twisted** 和 **Tornado**，以及 Ruby 中的 **EventMachine**。这些框架的一个大问题是它们所使用的所有
    I/O 库都必须是非阻塞的。常常会不小心使用到会阻塞 I/O 操作的代码。
- en: Node.js was built from the ground up with an event-driven philosophy and only
    allows non-blocking I/O, thus avoiding this problem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是从头开始构建的，具有事件驱动哲学，并且只允许非阻塞 I/O，从而避免了这个问题。
- en: Node is fast and scalable
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node 是快速和可扩展的
- en: The V8 JavaScript engine used by Node.js is highly optimized for performance,
    thus making Node.js applications very fast. The fact that Node is non-blocking
    will ensure that your applications will be able to handle many concurrent client
    requests without using a lot of system resources.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 使用的 V8 JavaScript 引擎在性能上高度优化，因此使得 Node.js 应用程序非常快。Node 非阻塞的事实将确保你的应用程序能够在不使用大量系统资源的情况下处理许多并发客户端请求。
- en: Node is not Rails
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node 不是 Rails
- en: Although Node and Rails are often used to build similar types of applications,
    they are in fact, quite different. Rails strives to be a full-stack solution to
    building web applications, whereas Node.js is more of a low-level system for writing
    any type of fast and scalable network application. It does not make a lot of assumptions
    on how your application should be structured at all, except for the fact that
    you'll use an event-based architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Node 和 Rails 经常被用来构建类似类型的应用程序，但它们实际上非常不同。Rails 努力成为构建 Web 应用程序的全栈解决方案，而 Node.js
    则更像是编写任何类型快速和可扩展网络应用的底层系统。它几乎不对你的应用程序结构做出任何假设，除了你将使用基于事件的架构。
- en: Because of this, Node developers often choose from a variety of frameworks and
    modules that have been built on top of Node for writing web applications, such
    as Express or Flatiron.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Node 开发者通常会从各种基于 Node 构建的框架和模块中选择，用于编写 Web 应用程序，例如 Express 或 Flatiron。
- en: Node and CoffeeScript
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node 和 CoffeeScript
- en: As we've seen before, CoffeeScript is available as an npm module. Therefore,
    writing Node.js applications with CoffeeScript couldn't be much easier. In fact,
    the `coffee` command that we discussed earlier will run `.coffee` scripts using
    Node by default. To get Node installed with CoffeeScript, see [Chapter 2](ch02.html
    "Chapter 2. Running CoffeeScript"), *Running CoffeeScript*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，CoffeeScript可以作为npm模块使用。因此，使用CoffeeScript编写Node.js应用程序非常简单。事实上，我们之前讨论的`coffee`命令默认会使用Node运行`.coffee`脚本。要安装带有CoffeeScript的Node，请参阅[第2章](ch02.html
    "第2章。运行CoffeeScript")，*运行CoffeeScript*。
- en: '"Hello World" in Node'
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '"Hello World"在Node中'
- en: 'Let''s write the simplest Node app we can using CoffeeScript. Create a file
    named `hello.coffee` and enter the following code in it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用CoffeeScript编写最简单的Node应用程序。创建一个名为`hello.coffee`的文件，并在其中输入以下代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This uses the `http` module of Node.js, which provides capabilities for building
    an HTTP server. The `require('http')` function will return an instance of the
    `http` module, which exports a `createServer` function. This function takes a
    `requestListener` argument, which is a function that will respond to client requests.
    In this case, we respond with an HTTP status code `200` and end the response with
    `Hello World` as the request body. Finally, we call the `listen` method on the
    returned server to start it up. When this method is called, the server will listen
    for and handle requests until we stop it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了Node.js的`http`模块，它提供了构建HTTP服务器的功能。`require('http')`函数将返回一个`http`模块的实例，该实例导出`createServer`函数。此函数接受一个`requestListener`参数，该参数是一个将响应用户请求的函数。在这种情况下，我们以HTTP状态码`200`响应，并以`Hello
    World`作为请求体结束响应。最后，我们调用返回服务器的`listen`方法来启动它。当调用此方法时，服务器将监听和处理请求，直到我们停止它。
- en: 'We can run this file with the coffee command, as shown in the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用coffee命令运行此文件，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can test our server by browsing to `http://localhost:8080/`. We should see
    a simple page with only the text as **Hello World**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过浏览到`http://localhost:8080/`来测试我们的服务器。我们应该看到一个只有文本的简单页面，内容为**Hello World**。
- en: Express
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express
- en: As you can see, Node out of the box is very low-level and bare-boned. Building
    web applications basically means writing a raw HTTP server. Luckily, a bunch of
    libraries has been developed over the last few years to help out with writing
    web applications on Node and to abstract away a lot of the low-level details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Node本身非常底层和简单。构建Web应用程序基本上意味着编写一个原始的HTTP服务器。幸运的是，在过去的几年中已经开发了许多库来帮助在Node上编写Web应用程序，并抽象出许多底层细节。
- en: Arguably, the most popular of these is **Express** ([http://expressjs.com/](http://expressjs.com/)).
    Similar to Rails, it has quite a lot of nice features that make it easier to perform
    common web application tasks, such as routing, rendering views, and hosting static
    resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最受欢迎的可能是**Express** ([http://expressjs.com/](http://expressjs.com/))。与Rails类似，它具有许多使执行常见Web应用程序任务（如路由、渲染视图和托管静态资源）更简单的优秀功能。
- en: In this chapter, we'll be writing a web application in Express using CoffeeScript.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用CoffeeScript在Express中编写一个Web应用程序。
- en: WebSocket
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket
- en: Since I would like to show off some of the scalability features of Node and
    the types of applications that it's normally used for, we'll be making use of
    another interesting modern web technology, known as **WebSocket**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我想展示一些Node的可扩展性功能以及它通常被用于的应用类型，我们将利用另一种有趣的现代网络技术，称为**WebSocket**。
- en: The WebSocket protocol is a standard for allowing raw, bi-directional, and full-duplex
    (simultaneous in both directions) TCP connections over the standard HTTP port
    **80**. This allows for a client and server to establish a long-running TCP connection
    with which the server can perform push operations, which has traditionally not
    been possible with HTTP. It is often used in applications where there needs to
    be lots of low-latency interaction between the client and server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议是一个标准，允许通过标准HTTP端口**80**进行原始、双向和全双工（双向同时）的TCP连接。这允许客户端和服务器建立长期运行的TCP连接，服务器可以通过该连接执行推送操作，这在传统HTTP中是不可能的。它通常用于需要客户端和服务器之间大量低延迟交互的应用程序。
- en: Jade
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jade
- en: Jade is a lightweight, markup templating language that lets you write elegant
    and short HTML in a syntax that closely resembles CoffeeScript. It uses quite
    a few features such as syntactical whitespace to reduce the number of keystrokes
    you need to write HTML documents. It is usually installed by default when you
    run Express, and we'll be using it in this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Jade 是一种轻量级的标记模板语言，它允许你使用与 CoffeeScript 非常相似的语法编写优雅且简短的 HTML。它使用了许多特性，如语法空白，以减少你编写
    HTML 文档所需的按键次数。通常情况下，当你运行 Express 时，它会默认安装，我们将在本书中使用它。
- en: Our application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的应
- en: In this chapter, we're going to build a collaborative to-do list application.
    This means that you'll be able to share your to-do list with other people in real
    time. One or more people will be able to add, complete, or remove to-do list items
    at the same time. Changes to the to-do list will be automatically propagated to
    all users. This is the type of application that Node is perfect for.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个协作式待办事项列表应用。这意味着你将能够实时与其他人共享你的待办事项列表。一个人或多人将能够同时添加、完成或删除待办事项列表项。待办事项列表的更改将自动传播到所有用户。这正是
    Node 完美适合的应用类型。
- en: Our Node.js code will consist of two distinct parts, the normal web application
    that will serve static HTML, CSS, and JavaScript, and a WebSocket server that
    handles the real-time updating of all the to-do list clients. Together with this,
    we'll have a jQuery-driven client that will look very similar to our application
    in [Chapter 3](ch03.html "Chapter 3. CoffeeScript and jQuery"), *CoffeeScript
    and jQuery*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Node.js 代码将包括两个不同的部分，一个是提供静态 HTML、CSS 和 JavaScript 的常规网络应用，另一个是处理所有待办事项列表客户端实时更新的
    WebSocket 服务器。与此相关，我们还将有一个由 jQuery 驱动的客户端，其外观将非常类似于我们的 [第 3 章](ch03.html "第 3
    章。CoffeeScript 和 jQuery") 应用。
- en: We'll use some of the assets (stylesheets and images) from our existing to-do
    list applications. We'll also re-use the client-side jQuery code from [Chapter
    3](ch03.html "Chapter 3. CoffeeScript and jQuery"), *CoffeeScript and jQuery*
    and tweak it to fit our application. If you weren't following along in the previous
    chapters, you should be able to just copy assets from the code for this chapter
    as needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些现有待办事项应用的资产（样式表和图片）。我们还将重用来自[第 3 章](ch03.html "第 3 章。CoffeeScript 和 jQuery")的客户端
    jQuery 代码，并对它进行调整以适应我们的应用。如果你没有跟随前面的章节，你应该能够根据需要从本章的代码中复制资产。
- en: Let's get started
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始吧
- en: 'To get going, we''ll do the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将执行以下步骤：
- en: Create a folder for our application.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的应用创建一个文件夹。
- en: Specify our app dependencies using a `package.json` file.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `package.json` 文件指定我们的应用依赖项。
- en: Install our dependencies.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装我们的依赖项。
- en: Create an `app.coffee` file.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `app.coffee` 文件。
- en: Run our app for the first time.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首次运行我们的应用。
- en: package.json
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: package.json
- en: 'Create a new folder named `todo`. Inside this folder, we''ll create a file
    with the name `package.json`. Add the following code to this file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 `todo` 的新文件夹中创建一个名为 `package.json` 的文件。将以下代码添加到该文件中：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a simple JSON file that serves as an application manifest and is used
    to tell npm which dependencies you rely on in your application. Here, we're using
    Express as our web framework and Jade as our templating language. Since we're
    going to use WebSocket, we'll pull in `socket.io`. We can also make sure that
    CoffeeScript is installed by adding it to our file. Lastly, we'll use `connect-assets`,
    a module that manages client-side assets in much the same way as the Rails asset
    pipeline.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 JSON 文件，用作应用清单，并用于告诉 npm 你在应用中依赖哪些依赖项。在这里，我们使用 Express 作为我们的网络框架，Jade
    作为我们的模板语言。由于我们将使用 WebSocket，我们将引入 `socket.io`。我们还可以通过将其添加到我们的文件中来确保 CoffeeScript
    已安装。最后，我们将使用 `connect-assets`，这是一个模块，以与 Rails 资产管道类似的方式管理客户端资产。
- en: When dealing with the Node.js framework, you'll notice that applications are
    often weaved together out of npm modules in this manner. A good place to look
    for npm modules is the Node toolbox site ([nodetoolbox.com](http://nodetoolbox.com)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 Node.js 框架时，你会注意到应用通常是以这种方式由 npm 模块编织而成的。寻找 npm 模块的好地方是 Node 工具箱网站 ([nodetoolbox.com](http://nodetoolbox.com))。
- en: Installing our modules
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装我们的模块
- en: 'To install the dependencies in our `package.json` file, navigate to the project
    folder on the command-line tool and run the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `package.json` 文件中的依赖项，在命令行工具中导航到项目文件夹，并运行以下命令：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If all went well, then we should now have all our project dependencies installed.
    To verify this or just to see what npm did, you can run the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，那么我们现在应该已经安装了所有项目依赖项。为了验证这一点或只是查看npm做了什么，你可以运行以下命令：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will output a list of installed modules with their dependencies in a tree-like
    format.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一个以树形格式显示的已安装模块及其依赖项的列表。
- en: Creating our app
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: 'All we need to run our application is to create a main, entry point file, which
    is used to hook up our Express application and specify our routes. In the root
    folder, create a file named `app.coffee`, and add the following code to it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的应用程序，我们只需要创建一个主、入口点文件，该文件用于连接我们的Express应用程序并指定我们的路由。在根文件夹中，创建一个名为`app.coffee`的文件，并将以下代码添加到其中：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This looks very similar to our "Hello World" example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们的“Hello World”示例非常相似。
- en: First, we load the Express module using the `require` function. Node modules
    are simple; each module corresponds to a single file. Each module can declare
    code, which will be exported when it is required. When you call `require`, and
    the module's name is not that of a native module or a file path, Node will automatically
    look for the file in the `node_modules` folder. This is of course where npm installs
    modules.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`require`函数加载Express模块。Node模块很简单；每个模块对应一个文件。每个模块可以声明代码，当它被导入时将被导出。当你调用`require`，并且模块的名称既不是原生模块也不是文件路径时，Node会自动在`node_modules`文件夹中查找该文件。这当然是npm安装模块的地方。
- en: On the next line, we create our Express app by calling the `express` function
    and assigning it to an `app` variable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们通过调用`express`函数并分配给`app`变量来创建我们的Express应用程序。
- en: We then create an index route for our application using the `get` method. We
    specify the path to be `'/'` and then pass in an anonymous function to handle
    the request. It takes two parameters, the `req` and `res` parameters. Right now,
    we just write `Hello Express` to the response and return.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`get`方法为我们的应用程序创建一个索引路由。我们指定路径为`'/'`，然后传递一个匿名函数来处理请求。它接受两个参数，即`req`和`res`参数。目前，我们只需将`Hello
    Express`写入响应并返回。
- en: We then start our app using the `listen` method and tell it to run on port `3000`.
    Lastly, we write to the standard output so that we'll know the app has started.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`listen`方法启动我们的应用程序，并告诉它在端口`3000`上运行。最后，我们将写入标准输出，这样我们就会知道应用程序已启动。
- en: As you can see, the Express magic comes in with setting up routes declaratively.
    With Express you can easily create routes by specifying an HTTP method, URL path,
    and a function to handle the request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Express的魔力在于声明性地设置路由。使用Express，你可以通过指定HTTP方法、URL路径和处理请求的函数来轻松创建路由。
- en: Running our application
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的应用程序
- en: 'Let''s run our application to see if everything worked. Inside our app folder,
    type the following on the command-line tool:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的应用程序，看看是否一切正常。在我们的应用程序文件夹中，在命令行工具中输入以下内容：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should see the output as **Listening on port 3000**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到输出为**监听端口3000**。
- en: Point your browser to `http://localhost:3000/`. You should see the text **Hello
    Express**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的浏览器指向`http://localhost:3000/`。你应该看到文本**Hello Express**。
- en: To stop the Node process on the command-line tool, just use *Ctrl* + *C*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在命令行工具中停止Node进程，只需使用*Ctrl* + *C*。
- en: Creating a view
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视图
- en: Similar to other web frameworks such as Rails, Express has the concepts of views,
    which let you separate your UI from your application using separate files. Usually,
    these are written using a templating language such as Jade. Let's create a view
    for our root action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与Rails等其他Web框架类似，Express有视图的概念，这允许你使用单独的文件将UI与应用程序分离。通常，这些是用Jade等模板语言编写的。让我们为我们的根操作创建一个视图。
- en: 'To do this, we''ll need to:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要：
- en: Create a `views` folder and add a Jade view file.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`views`文件夹并添加一个Jade视图文件。
- en: Configure our Express application to be aware of a folder where the views will
    be stored, and which templating library we're using.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置我们的Express应用程序以了解存储视图的文件夹以及我们正在使用的模板库。
- en: Change our index route to render our view.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的索引路由更改为渲染我们的视图。
- en: 'Let''s create a new folder in our project root called `views`. Inside this
    folder, we create a new file named `index.jade`. This is how it should look:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目根目录中创建一个新的文件夹，命名为`views`。在这个文件夹中，我们创建一个名为`index.jade`的新文件。它应该看起来像这样：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, Jade offers a very clean and terse syntax for normal HTML. You
    don't have enclosing tags in angle brackets. Similar to CoffeeScript, it also
    uses indentation to delimit blocks, so that you don't have to enter closing tags.
    The line `p= message` creates a `<p>` tag whose contents will be evaluated to
    be the value of the `message` field, which should be passed into our view options.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Jade为普通HTML提供了非常干净和简洁的语法。您不需要在尖括号中包含结束标签。类似于CoffeeScript，它也使用缩进来界定块，这样您就不需要输入结束标签。`p=
    message`行创建了一个`<p>`标签，其内容将被评估为`message`字段的值，这个值应该传递到我们的视图选项中。
- en: 'In our `app.coffee` file, we''ll add the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`app.coffee`文件中，我们将添加以下代码：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we set the `views` folder using the `set` function and assigning the `'views'`
    key. We use the `path` module that we included at the top of the file to create
    and join our current folder name to the `views` subfolder. `__dirname` is a global
    variable that refers to the currently working folder. We also set the view engine
    to `'jade'`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`set`函数设置`views`文件夹，并分配`'views'`键。我们使用文件顶部包含的`path`模块来创建和连接我们的当前文件夹名到`views`子文件夹。`__dirname`是一个全局变量，它指向当前工作文件夹。我们还设置了视图引擎为`'jade'`。
- en: Next up, we change our `get '/'` route to render the index template and pass
    in a hash of options, containing the message. This is the value that then gets
    rendered in our view.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的`get '/'`路由更改为渲染索引模板并传递一个包含消息的选项哈希。这是随后在视图中渲染的值。
- en: Once we run our application again and refresh the page, we should now see that
    our page has been updated with the new text.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们再次运行我们的应用程序并刷新页面，我们应该现在看到我们的页面已经更新为新的文本。
- en: node-supervisor
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: node-supervisor
- en: By now, you might be wondering if you'll need to restart our Node application
    each time we make a change to our code. Ideally in development, we would like
    our code to be reloaded automatically each time we make a change, similar to how
    it works in Rails.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道每次我们更改代码时是否需要重新启动我们的Node应用程序。理想情况下，在开发中，我们希望每次我们更改代码时，代码都能自动重新加载，就像在Rails中那样工作。
- en: 'Luckily, there is a neat, open source library that we can use that does exactly
    that: **node-supervisor** ([https://github.com/isaacs/node-supervisor](https://github.com/isaacs/node-supervisor)).
    We install it like any other npm module, we just make sure to pass the `-g` flag
    to install it globally, as shown in the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个整洁的开源库我们可以使用，它正好能做这件事：**node-supervisor** ([https://github.com/isaacs/node-supervisor](https://github.com/isaacs/node-supervisor))。我们像安装任何其他npm模块一样安装它，我们只是确保传递`-g`标志来全局安装，如下面的命令所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the terminal, you should now be able to run the supervisor by using the
    following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，你现在应该可以使用以下命令运行supervisor：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Keep this process running in a separate window. To see if this worked, let''s
    edit our message that gets sent to our view; the edited message is highlighted
    in the following code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在单独的窗口中保持此过程运行。为了检查是否成功，让我们编辑发送到视图的消息；编辑后的消息在下面的代码片段中被突出显示：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we now refresh our page, we'll see that it has been updated. From here on,
    we can make sure to keep the supervisor running and we shouldn't need to restart
    our Node process to make changes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在刷新我们的页面，我们会看到它已经被更新。从现在开始，我们可以确保supervisor在运行，我们不需要重新启动Node进程来做出更改。
- en: The to-do list view
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项列表视图
- en: 'Now let''s expand our view to look like our real to-do application. Edit the
    `index.jade` file to look like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们扩展我们的视图，使其看起来像我们的真实待办事项应用程序。编辑`index.jade`文件，使其看起来如下：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is some new Jade syntax that we haven''t seen before. Tag IDs are denoted
    by the `#` symbol, so `header#header` becomes `<header id="header">`. Tag attributes
    are specified within brackets, like so: `tag(name="value")`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们之前没有见过的新的Jade语法。标签ID由`#`符号表示，所以`header#header`变为`<header id="header">`。标签属性在方括号内指定，如下所示：`tag(name="value")`。
- en: 'Since we''re not using the `message` variable in our template anymore, we''ll
    remove it from our `render` call in the `app.coffee` file, as shown in the following
    code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再在模板中使用`message`变量，我们将从`app.coffee`文件中的`render`调用中移除它，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our page will now be updated, but it won't look too good. We'll use the same
    stylesheet that we used in the previous project to style our page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面现在将更新，但看起来可能不太好看。我们将使用在之前项目中使用的相同样式表来美化我们的页面。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Not working as expected?**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**未按预期工作？**'
- en: Remember to keep an eye on the output of the supervisor process to see if you
    have any syntax errors in your CoffeeScript or Jade template, especially if you're
    not seeing the expected output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记得关注supervisor进程的输出，看看你的CoffeeScript或Jade模板中是否有语法错误，尤其是如果你没有看到预期的输出。
- en: 'Before we use the stylesheet, we need to set up Express to serve static files
    for us. Modify the `app.coffee` file to look like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用样式表之前，我们需要设置Express为我们提供静态文件服务。修改`app.coffee`文件，使其看起来如下：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So what's happening in the previous code snippet? We've added support for serving
    static files in a single line, but how does this work? The answer lies in how
    Node uses middleware.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在之前的代码片段中发生了什么？我们在一行中添加了对静态文件服务的支持，但这是如何工作的？答案在于Node如何使用中间件。
- en: Middleware
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: The Express framework is built on top of a lower-level framework called **Connect**
    ([http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)). The
    basic idea of Connect is to provide middleware for web requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Express框架建立在名为**Connect**的底层框架之上（[http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)）。Connect的基本思想是提供用于Web请求的中间件。
- en: Middleware can be chained together to produce a web application stack. Each
    piece of middleware is only concerned in providing a small set of functionality
    by modifying the output response or the control flow of the request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以串联起来以生成一个Web应用程序堆栈。每个中间件部分只关心通过修改输出响应或请求的控制流来提供一小组功能。
- en: In our example, we tell our application to use the middleware created by the
    `express.static` function. This function will create a static file server for
    the provided file path.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们告诉应用程序使用由`express.static`函数创建的中间件。这个函数将为提供的文件路径创建一个静态文件服务器。
- en: Our stylesheet
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的样式表
- en: 'Create a folder named `public` with a subfolder named `css`. Save the stylesheet
    as `todo.css` in this folder. We still need to include the stylesheet in our `index`
    view. Add the following line—highlighted in the code snippet—to the `index.jade`
    file in the `views` folder:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`public`的文件夹，并在其中创建一个名为`css`的子文件夹。将样式表保存为`todo.css`在这个文件夹中。我们仍然需要在`index`视图中包含这个样式表。将以下行——代码片段中突出显示的内容——添加到`views`文件夹中的`index.jade`文件中：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once we have linked to our stylesheet, we should be able to refresh our view.
    It should now look much nicer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们链接了样式表，我们应该能够刷新我们的视图。现在它看起来应该会好很多。
- en: The client side
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: To make our to-do application work, we're going to copy the client-side jQuery
    code that we created in [Chapter 3](ch03.html "Chapter 3. CoffeeScript and jQuery"),
    *CoffeeScript and jQuery*. We're going to put it in a file named `todo.coffee`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的待办事项应用程序工作，我们将复制在[第3章](ch03.html "第3章。CoffeeScript和jQuery")中创建的客户端jQuery代码。我们将把它放在一个名为`todo.coffee`的文件中。
- en: Our next decision is, where shall we put this file? How will we compile and
    use its output in our application?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的决定是，我们应该把这个文件放在哪里？我们如何在应用程序中编译和使用它的输出？
- en: We could do the same thing as we did when we built our application in [Chapter
    3](ch03.html "Chapter 3. CoffeeScript and jQuery"), *CoffeeScript and jQuery*,
    that is, create a `src` folder containing the client-side offeeScript code, then
    compile it using the `coffee` command with the `--watch` flag. The outputted JavaScript
    could then go in our `public` folder where we can include it as normal. But this
    would mean we would have two separate background tasks running, the supervisor
    task for running our server and another for compiling our client-side code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。CoffeeScript和jQuery")中构建应用程序时做了同样的事情，即创建一个包含客户端offeeScript代码的`src`文件夹，然后使用带有`--watch`标志的`coffee`命令编译它。生成的JavaScript可以放入我们的`public`文件夹中，我们可以像通常一样包含它。但这意味着我们将有两个独立的后台任务在运行，一个是运行我们的服务器的supervisor任务，另一个是编译我们的客户端代码。
- en: Luckily there is a better way. You might recall that we had a reference to the
    `connect-assets` module in our `package.json` file. It provides us with an asset
    pipeline that is very similar to what you get in Rails. It will take care of compilation
    and dependency management transparently.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有更好的方法。你可能还记得我们在`package.json`文件中有一个对`connect-assets`模块的引用。它为我们提供了一个与Rails中得到的非常相似的资产管道。它将透明地处理编译和依赖关系管理。
- en: 'We''ll need to use the middleware in our `app.coffee` file, as highlighted
    in the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`app.coffee`文件中使用中间件，如下代码片段所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `connect-assets` module will, by default, use the `assets` folder to manage
    and serve assets from. Let''s create a folder named `assets/js` inside our root
    folder. We''ll create a new file in this folder named `todo.coffee`, containing
    the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect-assets`模块默认将使用`assets`文件夹来管理和提供资产。让我们在根文件夹中创建一个名为`assets/js`的文件夹。我们将在该文件夹中创建一个名为`todo.coffee`的新文件，包含以下代码：'
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you were following along in [Chapter 3](ch03.html "Chapter 3. CoffeeScript
    and jQuery"), *CoffeeScript and jQuery*, then this code should be familiar. It's
    our complete, client-side application that displays to-do items and creates, updates,
    and destroys items in `localStorage`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在跟随[第3章](ch03.html "第3章。CoffeeScript和jQuery")，那么这段代码应该很熟悉。这是我们完整的客户端应用程序，它显示待办事项，并在`localStorage`中创建、更新和销毁项目。
- en: To use this file in our HTML we still need to include a `script` tag. Since
    we're using jQuery, we'll also need to include the library in our HTML.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的HTML中使用此文件，我们仍然需要包含一个`script`标签。由于我们使用jQuery，我们还需要在HTML中包含库。
- en: 'Add the following code to the bottom of the `index.jade` file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`index.jade`文件的底部：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we include a link to jQuery using the Google CDN. We then use
    the `js` helper function, which is provided by `connect-assets`, to create a `script`
    tag that points to our compiled `todo.js` file (the `connect-assets` module will
    have compiled our CoffeeScript transparently). The `!=` notation is Jade's syntax
    for running a JavaScript function along with its result.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用Google CDN包含了jQuery的链接。然后我们使用由`connect-assets`提供的`js`辅助函数，创建一个指向我们编译的`todo.js`文件的`script`标签（`connect-assets`模块将透明地编译我们的CoffeeScript）。`!=`符号是Jade的语法，用于运行JavaScript函数及其结果。
- en: If all went well, we should be able to refresh the page and have a working,
    client-side page for our app. Try adding new items, marking items as complete,
    deleting items, and clearing completed items.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该能够刷新页面，并拥有一个工作状态良好的客户端页面，用于我们的应用。尝试添加新项目，标记项目为完成，删除项目，以及清除已完成的项目。
- en: Adding collaboration
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加协作
- en: Now we're ready to add collaboration to our to-do list application. We need
    to create a page where multiple users can connect to the same to-do list and can
    edit it simultaneously, seeing the results in real time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将协作添加到我们的待办事项列表应用程序中。我们需要创建一个页面，让多个用户可以连接到同一个待办事项列表，并可以同时编辑它，实时看到结果。
- en: We would like to support the idea of named lists, which you can join with others
    to collaborate on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望支持命名列表的概念，您可以通过它与他人协作。
- en: Before we dive into the functionality, let's tweak our UI a bit to support all
    of this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入功能之前，让我们稍微调整一下我们的UI，以支持所有这些功能。
- en: Creating the collaboration UI
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建协作UI
- en: First, we'll add an input field to specify a list name and a button to join
    the specified list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个输入字段来指定列表名称，以及一个按钮来加入指定的列表。
- en: 'Make the following changes (highlighted in the code snippet) to our `index.jade`
    file, which will add an `input` element and a `button` element to specify our
    list name and join it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的`index.jade`文件进行以下更改（代码片段中突出显示），这将添加一个`input`元素和一个`button`元素来指定我们的列表名称并加入它：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our page should now look like the page displayed in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面现在应该看起来像以下截图显示的页面：
- en: '![Creating the collaboration UI](img/9588_05_01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建协作UI](img/9588_05_01.jpg)'
- en: WebSocket on the client
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端的WebSocket
- en: Now let's add an event handler to connect to a room when the user clicks the
    **Join** button.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个事件处理程序，当用户点击**加入**按钮时连接到房间。
- en: 'In our `todo.coffee` file, we''ll add the following code to our `cacheElements`
    and `bindEvents` functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`todo.coffee`文件中，我们将在`cacheElements`和`bindEvents`函数中添加以下代码：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We grab the `join-list-name` input and `join` button elements and store them
    in two instance variables. We then set up the `click` handler on the `@$join`
    button to call a new function called `joinList` . Let''s go ahead and define this
    function now. Add it to the end of the class after the `bindEvents` function is
    defined:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取`join-list-name`输入和`join`按钮元素，并将它们存储在两个实例变量中。然后我们在`@$join`按钮上设置`click`处理程序，以调用一个名为`joinList`的新函数。让我们现在就定义这个函数。在`bindEvents`函数定义之后将其添加到类的末尾：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is where we start to use Socket.IO. The Socket.IO library comes in two
    parts: the client-side library for opening a WebSocket connection, making requests,
    and receiving responses, as well as the server-side node module for handling the
    requests.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们开始使用Socket.IO的地方。Socket.IO库分为两部分：客户端库用于打开WebSocket连接，发送请求，并接收响应，以及服务器端node模块用于处理请求。
- en: In the preceding code, the `joinList` function opens a new socket using the
    `io.connect` function and passing in the URL. It then uses the `on` function to
    pass a handler function that will run after the WebSocket connection has been
    made.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`joinList` 函数使用 `io.connect` 函数打开一个新的套接字，并传递 URL。然后它使用 `on` 函数传递一个处理函数，该函数将在
    WebSocket 连接建立后运行。
- en: The successful connection handler function will in turn use the `socket.emit`
    function, which allows us to send a custom message to the server using `joinList`
    as the identifier. We pass the value of the `@joinListName` input as its value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 成功连接处理函数将反过来使用 `socket.emit` 函数，这允许我们使用 `joinList` 作为标识符向服务器发送自定义消息。我们将 `@joinListName`
    输入的值作为其值传递。
- en: 'Before we can start implementing the server-side code, we still need to include
    a `script` tag to use the `socket.io` client library. Add the following highlighted
    `script` tag at the bottom of the `index.jade` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现服务器端代码之前，我们仍然需要包含一个 `script` 标签来使用 `socket.io` 客户端库。在 `index.jade` 文件的底部添加以下高亮的
    `script` 标签：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You might be wondering where this file comes from. Next, we'll set up the Socket.IO
    middleware in our `app.coffee` file. This will host the client-side library for
    us.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这个文件是从哪里来的。接下来，我们将在 `app.coffee` 文件中设置 Socket.IO 中间件。这将为我们托管客户端库。
- en: WebSocket on the server
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器上的 WebSocket
- en: We have our client-side code ready to make WebSocket requests; now we can move
    on to our Node backend. First, we'll need to set up our Socket.IO middleware.
    There is a small caveat to this, in that we cannot use Socket.IO as a middleware
    of the Express application directly, since Socket.IO expects a Node.js HTTP server
    and has no direct support for Express. Instead, we'll create a web server using
    the built-in Node.js HTTP module, passing our Express application as `requestListener`
    . We can then use the `listen` function in Socket.IO to connect to the server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了客户端代码来发送 WebSocket 请求；现在我们可以继续我们的 Node 后端。首先，我们需要设置我们的 Socket.IO 中间件。这里有一个小的注意事项，我们不能直接将
    Socket.IO 作为 Express 应用程序的中间件使用，因为 Socket.IO 期望一个 Node.js HTTP 服务器，并且没有直接支持 Express。相反，我们将使用内置的
    Node.js HTTP 模块创建一个网络服务器，并将我们的 Express 应用程序作为 `requestListener` 传递。然后我们可以使用 Socket.IO
    的 `listen` 函数连接到服务器。
- en: 'The following is how the code looks in our `app.coffee` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们 `app.coffee` 文件中的代码外观：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `io.sockets.on 'connection'` function handles the event when a client connects.
    Here, we log to the console that we're connected to and then set up the `joinList`
    message handler. Right now, we'll just log the value that we receive from the
    client to the console.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.sockets.on ''connection''` 函数处理客户端连接的事件。在这里，我们向控制台记录我们已连接的信息，然后设置 `joinList`
    消息处理程序。目前，我们只是将客户端发送给我们的值记录到控制台。'
- en: 'We should now be able to test connecting to a list. Refresh our to-do list
    home page and enter a list name to join. After you clicked the **Join** button,
    head over to our background supervisor task. You should see something similar
    to the following message:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够测试连接到一个列表。刷新我们的待办事项列表主页，并输入一个要加入的列表名称。点击 **加入** 按钮后，转到我们的后台管理任务。你应该会看到以下类似的消息：
- en: '**connected**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接**'
- en: '**Joining list Michael''s List**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**加入迈克尔列表**'
- en: It worked! We've successfully created a bi-directional WebSocket connection.
    We still haven't really joined a list so far, so let's go ahead and do that now.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我们已经成功创建了一个双向 WebSocket 连接。到目前为止，我们还没有真正加入一个列表，所以让我们现在就加入。
- en: Joining a list
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入列表
- en: To join a list, we'll use a feature of Socket.IO called **rooms** . It allows
    the Socket.IO server to segment its clients and emit messages to subsets of all
    the connected clients. On the server, we'll keep track of the to-do lists of each
    room and then tell the client to sync its local list when connected.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入一个列表，我们将使用 Socket.IO 的一个功能，称为 **rooms**。它允许 Socket.IO 服务器对客户端进行分段，并向所有已连接客户端的子集发送消息。在服务器上，我们将跟踪每个房间的待办事项列表，然后告诉客户端在连接时同步其本地列表。
- en: 'We''ll update the `app.coffee` file with the highlighted code shown in the
    following code snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `app.coffee` 文件中更新高亮显示的代码，如下所示：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We initialize the `@todos` instance variable to be an empty hash. It will hold
    the to-do lists for each room, using the list name as a key. In the `joinList`
    handler function, we set the `list` property of the `socket` variable to equal
    the list name that the client passed in.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化 `@todos` 实例变量为一个空哈希表。它将保存每个房间的待办事项列表，使用列表名称作为键。在 `joinList` 处理函数中，我们将
    `socket` 变量的 `list` 属性设置为客户端传递进来的列表名称。
- en: We then use the `socket.join` function that will join our list to a room with
    that name. If the room doesn't exist yet, it will be created. We then assign an
    empty array value to the item in `@todos` with the key equal to `list`. The `?=`
    operator will only assign the value on the right-hand side to the object on the
    left-hand side if it's `null`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`socket.join`函数将我们的列表加入到一个具有该名称的房间中。如果该房间尚不存在，它将被创建。然后，我们将一个空数组值分配给`@todos`中具有`list`键的项。`?=`运算符仅在左侧对象为`null`时将右侧的值分配给左侧对象。
- en: Lastly, we send a message to the client using the `socket.emit` function. The
    `syncItems` identifier will tell it to sync its local data with the to-do list
    items that we're passing it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`socket.emit`函数向客户端发送消息。`syncItems`标识符将告诉它同步其本地数据与传递给它的待办事项列表项。
- en: 'To handle the `syncItems` message, we''ll need to update the `todo.coffee`
    file with the following highlighted code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理`syncItems`消息，我们需要更新`todo.coffee`文件，如下所示的高亮代码：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After joining a list, we set up our client connection to handle the `syncItems`
    message. We expect to receive all the to-do items for the list that we have just
    joined. The `syncItems` function will clear all the current items in `localStorage`,
    add all the new items, and then display them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 加入列表后，我们设置客户端连接以处理`syncItems`消息。我们期望接收我们刚刚加入的列表的所有待办事项。`syncItems`函数将清除`localStorage`中的所有当前项，添加所有新项，然后显示它们。
- en: The UI
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 界面
- en: 'Lastly, let''s update our UI so that the user will know when they''ve joined
    a list and let them leave it. We''ll modify our `#footer div` tag as follows in
    our `index.jade` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新我们的UI，以便用户知道他们已经加入了一个列表，并允许他们离开它。我们将在`index.jade`文件中将以下修改应用于`#footer
    div`标签：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the previous markup, we've added two new sections to our `footer div` tag.
    Each section will either be hidden or visible depending on which state we are
    in, `connected` or `disconnected` from a list. The `connect` section is the same
    as before. The `disconnect` section will display which list you are currently
    connected to and has a **Leave** button.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的标记中，我们向`footer div`标签添加了两个新的部分。每个部分将根据我们处于哪种状态（连接到列表的`connected`或`disconnected`）而隐藏或显示。`connect`部分与之前相同。`disconnect`部分将显示您当前连接到的列表，并有一个**离开**按钮。
- en: Now we'll add code to our `todo.coffee` file to update the UI when a list is
    joined.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向`todo.coffee`文件添加代码以在加入列表时更新界面。
- en: 'First, we''ll cache the new elements in our `cacheElements` function, as highlighted
    in the following code snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`cacheElements`函数中缓存新元素，如下代码片段所示：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we''ll change the UI to display that we''re in a `connected` state when
    `syncItems` have been called (which gets fired by the server after successfully
    joining a list). We use the `@currentList` function, which we''ll set in the `joinList`
    function; add the code highlighted in the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改UI以在调用`syncItems`（在成功加入列表后由服务器触发）时显示我们处于`connected`状态。我们使用`@currentList`函数，我们将在`joinList`函数中设置它；在以下代码片段中添加高亮代码：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `displayConnected` function will just hide the `connect` section and show
    the `disconnect` section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayConnected`函数将仅隐藏`connect`部分并显示`disconnect`部分。'
- en: Leaving a list
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离开列表
- en: Leaving a list should be quite easy. We disconnect the current socket connection
    and then update the UI.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 离开列表应该相当简单。我们断开当前套接字连接，然后更新UI。
- en: 'To handle the `disconnect` action when a button is clicked, we add a handler
    in our `bindEvents` function, as shown in the following code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理按钮点击时的`disconnect`动作，我们在`bindEvents`函数中添加了一个处理程序，如下代码片段所示：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, the handler we''ve added will just call a `leaveList` function.
    We still need to implement it. Add the following two functions to the end of the
    class after the last function defined in our `TodoApp` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们添加的处理程序将仅调用一个`leaveList`函数。我们还需要实现它。将以下两个函数添加到`TodoApp`类中最后一个函数定义之后：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing it all
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试所有操作
- en: 'Now let''s test our list joining and leaving code. To see it all in action,
    follow these steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试我们的列表加入和离开代码。要看到所有操作，请按照以下步骤进行：
- en: Open `http://localhost:3000/` in your browser.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://localhost:3000/`。
- en: In the browser window, type a list name and hit **Join List**. The UI should
    update as expected.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，输入列表名称并点击**加入列表**。界面应该按预期更新。
- en: Once you've joined a list, add a few to-do items.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加入列表后，添加一些待办事项。
- en: Now open the site again, this time using a second browser. Since `localStorage`
    is unique to a browser, we do this to have a clean list of to-do items.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开网站，这次使用第二个浏览器。由于`localStorage`对每个浏览器都是唯一的，我们这样做是为了有一个干净的待办事项列表。
- en: Once again, type the same list name as you did in the other browser and hit
    **Join List**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，输入与另一个浏览器中相同的列表名称，然后点击**加入列表**。
- en: As the list is synced, you should now see the list items you've added in before
    showing up.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当列表同步时，您现在应该会看到之前添加的列表项出现在列表中。
- en: Lastly, disconnect from a list using the **Leave** button.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用**离开**按钮从列表中断开连接。
- en: '![Testing it all](img/9588_05_02.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![测试全部功能](img/9588_05_02.jpg)'
- en: Two lists synced from different browsers
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 来自不同浏览器的两个同步列表
- en: This is great! We can now see the power of WebSockets in action. Our client
    is notified when it should sync items without having to poll the server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！我们现在可以看到WebSocket的实际力量。当不需要轮询服务器时，客户端会收到同步项的通知。
- en: However, once we're connected to the list, we still cannot add new items to
    have them show up in all the other clients in the room. Let's implement that.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们连接到列表，我们仍然不能添加新项目，以便它们在所有其他客户端中显示。让我们来实现这一点。
- en: Adding to-do items to a shared list
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将待办事项添加到共享列表
- en: 'First, we''ll handle adding new items on the server. The best place to handle
    this would be in the existing `create` function for creating to-do items. Instead
    of just adding them to `localStorage`, we''ll also emit a message to the server
    telling it that a new to-do item has been created, and pass it as a parameter.
    Modify the `create` function to look like the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在服务器上处理添加新项目。处理此操作的最佳位置是在创建待办事项的现有`create`函数中。我们不仅将它们添加到`localStorage`，还会向服务器发出消息，告诉它已创建新的待办事项，并将其作为参数传递。将`create`函数修改如下代码：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We need to handle the `newItem` message on the server. We'll set up the code
    to do so when a client joins a list, in `app.coffee`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在服务器上处理`newItem`消息。我们将在`app.coffee`中设置代码，以便在客户端加入列表时执行此操作。
- en: 'Let''s modify the `joinList` event handler that we added before; add the highlighted
    code in the following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前添加的`joinList`事件处理器；在以下代码片段中添加高亮代码：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code snippet, we set up yet another `socket` event when a user joins
    a list. In this case, it's for the `newItem` event. We add the new to-do item
    to our `@todos` array using the `push` function. Then we emit a new `itemAdded`
    message to all the clients in the current list.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们设置了一个新的`socket`事件，当用户加入列表时。在这种情况下，它是针对`newItem`事件的。我们使用`push`函数将新的待办事项添加到我们的`@todos`数组中。然后，我们向当前列表中的所有客户端发出新的`itemAdded`消息。
- en: What will happen with this `itemAdded` message? You guessed it; it will get
    handled in the client again. This kind of back and forth messaging is very common
    in WebSocket applications and does take some getting used to. Don't fret though;
    it gets easier once you get the hang of it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`itemAdded`消息会发生什么？您猜对了；它将在客户端再次被处理。这种来回的消息传递在WebSocket应用程序中很常见，并且确实需要一些习惯。不过别担心；一旦掌握了技巧，就会变得容易。
- en: 'Meanwhile let''s handle the `itemAdded` event on the client. We also set up
    this code in our `joinList` method by adding the highlighted code in the following
    code snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，让我们在客户端处理`itemAdded`事件。我们还在`joinList`方法中设置了此代码，通过在以下代码片段中添加高亮代码：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We handle the `itemAdded` event by calling `localStorage.setObject` with the
    item ID and value. This will either create a new to-do item if it's not present
    in `localStorage`, or it will update the existing value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`localStorage.setObject`并传递项目ID和值来处理`itemAdded`事件。如果它不在`localStorage`中，这将创建一个新的待办事项；或者，它将更新现有的值。
- en: 'And that''s it! We should now be able to add items to all the clients in the
    list. To test it, we''ll follow similar steps to what we did earlier:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在应该能够向列表中的所有客户端添加项目。为了测试它，我们将遵循与之前类似的步骤：
- en: Open `http://localhost:3000/` in your browser.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://localhost:3000/`。
- en: In the browser window, type a list name and hit **Join List**. The UI should
    update as expected.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，输入一个列表名称并点击**加入列表**。UI应该按预期更新。
- en: Now open the site again, this time using a second browser.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次打开网站，这次使用第二个浏览器。
- en: Once again, type the same list name as you did in the other browser and hit
    **Join List**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，输入与另一个浏览器中相同的列表名称，然后点击**加入列表**。
- en: Add new to-do items in either browser. You'll see the to-do items appear in
    the other browser immediately.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任一浏览器中添加新的待办事项。您将立即在另一个浏览器中看到待办事项的出现。
- en: Wow! Isn't this impressive?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这不是很令人印象深刻吗？
- en: Removing to-do items from a shared list
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从共享列表中删除待办事项
- en: 'To remove to-do items from a shared list, we''ll follow a similar pattern to
    adding items. In the `destroy` function in `todo.coffee`, we''ll emit a `removeItem`
    message to our socket to let the server know that a item should be removed, as
    shown in the following code snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要从共享列表中删除待办事项，我们将遵循与添加项类似的模式。在 `todo.coffee` 中的 `destroy` 函数中，我们将向我们的套接字发送一个
    `removeItem` 消息，让服务器知道应该删除一个项，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once again, we set up the server-side code to handle this message by removing
    the item from the shared list in memory, and then notify all clients connected
    to the list that the item has been removed:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 再次设置服务器端代码来处理此消息，通过从内存中的共享列表中删除项，然后通知所有连接到列表的客户端该项已被删除：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `removeItem` socket event handler gets the ID of the to-do item to remove
    the task passed into it. It removes the to-do item from the list by assigning
    the current value of the shared list to a new value that we create using JavaScript's
    array `filter` function. This will select all the items that don't have the passed
    ID. It then calls `emit` on all the client socket connections in the shared list
    with the `itemRemoved` message.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeItem` 事件处理程序获取要删除的任务项的 ID。它通过将共享列表的当前值赋给一个使用 JavaScript 的数组 `filter`
    函数创建的新值来从列表中删除待办事项。这将选择所有没有传递 ID 的项。然后，它对共享列表中所有客户端套接字连接调用 `emit`，并传递 `itemRemoved`
    消息。'
- en: 'Lastly, we''ll need to handle the `itemRemoved` message in our client. Similar
    to when we added items, we''ll set this up in the `joinList` function in `todo.coffee`,
    as shown in the following code snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的客户端中处理 `itemRemoved` 消息。类似于添加项时，我们将在 `todo.coffee` 中的 `joinList`
    函数中设置此操作，如下面的代码片段所示：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We remove the item from `localStorage` and update the UI.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `localStorage` 中删除项并更新 UI。
- en: 'To test removing items, follow these steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试删除项，请按照以下步骤操作：
- en: Open `http://localhost:3000/` in your browser.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开 `http://localhost:3000/`。
- en: In the browser window, type a list name and hit **Join List**. The UI should
    update as expected.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，输入一个列表名称，然后点击 **加入列表**。UI 应按预期更新。
- en: Once you've connected to the shared list, add a few to-do items.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您连接到共享列表，添加一些待办事项。
- en: Now open the site again, this time using a second browser.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次打开网站，这次使用第二个浏览器。
- en: Once again, type the same list name as you did in the other browser and hit
    **Join List**. Your to-do list will be synced with the shared list and will contain
    the items that you have added in the other browser.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次输入与另一个浏览器中相同的列表名称，然后点击 **加入列表**。您的待办事项列表将与共享列表同步，并包含您在另一个浏览器中添加的项。
- en: Click the remove icon to delete to-do items in either browser. You'll see the
    deleted to-do items disappear in the other browser immediately.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击删除图标以在任一浏览器中删除待办事项。您将立即看到被删除的待办事项在另一个浏览器中消失。
- en: Now, it's your turn
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在，轮到你了
- en: As a final exercise to you, I will ask you to make the **Clear completed** button
    work. As a hint, you should be able to use the existing `destroyItem` method functionality.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的练习，我将要求您使 **清除已完成** 按钮工作。作为一个提示，您应该能够使用现有的 `destroyItem` 方法功能。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we completed our tour of the CoffeeScript ecosystem by exploring
    Node.js as a fast, event-driven platform that lets you use JavaScript or CoffeeScript
    to write server applications. I hope that you have been given a glimpse of the
    joy of being able to write web applications using CoffeeScript on the server as
    well as in the browser at the same time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过探索 Node.js 作为快速、基于事件的平台，让您可以使用 JavaScript 或 CoffeeScript 编写服务器应用程序，完成了对
    CoffeeScript 生态系统的全面游览。我希望您已经看到了使用 CoffeeScript 在服务器和浏览器上同时编写 Web 应用程序的乐趣。
- en: We also spent some time with some of the wonderful open source libraries and
    frameworks that have been written for Node.js, like expressjs, connect, and Socket.IO
    and have seen how we can successfully use npm to manage dependencies and modules
    in our applications.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还花了一些时间与为 Node.js 编写的许多出色的开源库和框架一起工作，如 expressjs、connect 和 Socket.IO，并看到了我们如何成功使用
    npm 来管理应用程序中的依赖项和模块。
- en: Our sample application was exactly the kind of thing that you would use Node.js
    for, and we saw how its event-driven model lends itself to writing applications
    where there are lots of constant interactions between the client and server.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序正是您会用 Node.js 来实现的那种类型，我们看到了它的基于事件的模型如何适合编写客户端和服务器之间有大量持续交互的应用程序。
- en: Now that we've come to an end to our journey, I hope to have instilled in you
    the eagerness and skills to go out and use CoffeeScript to change the world. We've
    spent some time exploring not just the language but also the wonderful tools,
    libraries, and frameworks that enable us to develop powerful applications more
    rapidly using less code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经结束了这段旅程，我希望我已经在你心中种下了渴望和技能，让你能够走出并使用 CoffeeScript 改变世界。我们花了一些时间探索的不仅仅是语言，还有那些奇妙的工具、库和框架，它们使我们能够用更少的代码更快地开发出强大的应用程序。
- en: The future of CoffeeScript and the JavaScript ecosystem is bright, and hopefully
    you'll be a part of it!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript 和 JavaScript 生态系统的未来光明，希望你们能成为其中的一员！
