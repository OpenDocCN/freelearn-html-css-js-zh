- en: Building a Blockchain
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建区块链
- en: In the previous chapter, we learned about what a blockchain is and how it functions.
    In addition, we learned how to set up a project to build our blockchain. In this
    chapter, you will begin building the blockchain and all of its functionalities.
    First, let's create the blockchain data structure using a constructor function,
    and then we'll add a lot of different types of functionalities to our blockchain
    by adding different methods to its prototype.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了区块链是什么以及它的功能。此外，我们还学习了如何设置项目来构建我们的区块链。在本章中，您将开始构建区块链及其所有功能。首先，让我们使用构造函数创建区块链数据结构，然后通过向其原型添加不同类型的功能来为我们的区块链添加许多不同类型的功能。
- en: We're then going to give the blockchain certain functionalities, such as creating
    new blocks and transactions, as well as the ability to hash data and blocks. We'll
    also give it the ability to do a proof of work and many other functionalities
    that a blockchain should be able to do. We'll then make sure that the blockchain
    is fully functional by testing the added functionalities as we progress.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将赋予区块链某些功能，例如创建新的区块和交易，以及对数据和区块进行哈希的能力。我们还将赋予它进行工作证明和许多其他区块链应该具备的功能。然后，我们将通过测试添加的功能来确保区块链是完全功能的。
- en: By building each piece of the blockchain step by step, you will gain a better
    understanding of how blockchain actually works under the hood. You may also realize
    that once you dive into it, creating a blockchain is not as complicated as it
    sounds.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐步构建区块链的每个部分，您将更好地了解区块链在幕后实际上是如何工作的。您还可能意识到，一旦您深入其中，创建区块链并不像听起来那么复杂。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning how to create a Blockchain constructor function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建区块链构造函数
- en: Building and testing various methods such as `createNewBlock`, `createNewTransaction`,
    and `hashBlock` to add functionalities to the blockchain
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和测试各种方法，如`createNewBlock`、`createNewTransaction`和`hashBlock`，以为区块链添加功能
- en: Understanding what proof of work is and learning how to implement it for our
    blockchain
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解工作证明是什么，并学习如何为我们的区块链实现它
- en: Creating and testing a genesis block
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和测试创世区块
- en: So, let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: Before we get building...
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们开始之前...
- en: 'Before we get into building the blockchain, there are two crucial concepts
    that we need to familiarize ourselves with. These important concepts are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建区块链之前，有两个关键概念我们需要熟悉。这些重要概念如下：
- en: The JavaScript constructor function
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript构造函数
- en: The prototype object
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型对象
- en: An explanation of the JavaScript constructor function
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript构造函数的解释
- en: Becoming familiar with the constructor function is important as we'll be using
    it to build our blockchain data structure. By now, you must be wondering what
    a constructor function is and what it actually does.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉构造函数很重要，因为我们将使用它来构建我们的区块链数据结构。到目前为止，您一定想知道构造函数是什么，它实际上是做什么。
- en: A constructor function is simply a function that creates an object class and
    allows you to easily create multiple instances of that particular class. What
    this actually means is that the constructor function allows you to create a lot
    of objects very quickly. All of these objects that are created will have the same
    properties and functionalities because they are all part of the same class. Now,
    all of this might seem a little bit confusing when you hear it for the first time,
    but don't worry — we'll try to understand what a constructor function is with
    the help of an example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只是一个创建对象类并允许您轻松创建该特定类的多个实例的函数。这实际上意味着构造函数允许您非常快速地创建大量对象。由于它们都是同一类的一部分，所以创建的所有这些对象都将具有相同的属性和功能。现在，当您第一次听到这些时，所有这些可能看起来有点令人困惑，但不要担心——我们将尝试通过一个示例来理解构造函数是什么。
- en: Let's take Facebook, for example. Facebook has over one-and-a half billion users,
    which are all objects of the same class and have similar properties such as name,
    email, password, birthday, and so on. For our example, let's assume that we are
    building the Facebook website and want to create a bunch of different users for
    it. Let's do this by creating a `User` constructor function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以Facebook为例。Facebook拥有超过15亿用户，它们都是同一类的对象，并具有类似的属性，如姓名、电子邮件、密码、生日等。对于我们的示例，假设我们正在构建Facebook网站，并希望为其创建一堆不同的用户。我们可以通过创建一个`User`构造函数来实现这一点。
- en: 'To learn and explore the constructor functions, let''s use the Google Chrome
    console. We can access the console by going to Google Chrome and simply pressing
    *command* + *option* + *J* for Mac users and *Ctrl* + *Shift* + *I* for Windows
    users. Alternatively, we can simply go to the menu option, go to More Tools, and
    then select the Developer Tools option, as shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习和探索构造函数，让我们使用Google Chrome控制台。我们可以通过打开Google Chrome并简单地按下*command* + *option*
    + *J*（Mac用户）或*Ctrl* + *Shift* + *I*（Windows用户）来访问控制台。或者，我们可以简单地转到菜单选项，转到“更多工具”，然后选择“开发者工具”选项，如下截图所示：
- en: '![](img/cdd62f3b-e3ef-4f56-a595-2c1f57330fbe.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdd62f3b-e3ef-4f56-a595-2c1f57330fbe.png)'
- en: 'Following the aforementioned steps will open the console for you, as shown
    in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上述步骤将为您打开控制台，如下截图所示：
- en: '![](img/172ac298-046d-45f0-9bdc-79c5baaa110d.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/172ac298-046d-45f0-9bdc-79c5baaa110d.png)'
- en: 'The constructor function that we''ll be coding in this example will allow us
    to create multiple users or multiple user objects that will have the same properties
    and functionalities. The code to create this `User` constructor function begins
    by defining it as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将编写的构造函数将允许我们创建多个用户或多个用户对象，这些对象将具有相同的属性和功能。创建此`User`构造函数的代码如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inside of the parentheses, `()`, let's pass the properties that we want each
    of our `User` objects to have. We're going to pass properties such as `firstName`,
    `lastName`, `age`, and `gender` because we want all of our user objects to have
    these components.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号`()`内，让我们传递我们希望每个`User`对象具有的属性。我们将传递诸如`firstName`、`lastName`、`age`和`gender`等属性，因为我们希望所有的用户对象都具有这些组件。
- en: 'We then assign these parameters to our `User` objects by using the `this` keyword,
    as shown in the following block of code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`this`关键字将这些参数分配给我们的`User`对象，如下面的代码块所示：
- en: '![](img/9ddd09c9-3fe2-485d-9a6a-c9457654c039.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ddd09c9-3fe2-485d-9a6a-c9457654c039.png)'
- en: This is how we define the constructor function in JavaScript. Now, reading through
    the preceding code block, you might be wondering what we did and what the `this`
    keyword is all about.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在JavaScript中定义构造函数的方法。现在，通过阅读上面的代码块，你可能会想知道我们做了什么，`this`关键字是什么意思。
- en: We're going to use this constructor function to create a lot of user objects.
    The `this` keyword is simply referring to each of the user objects that we're
    going to create. This might all seem a bit overwhelming right now, but let's run
    through a couple of examples and try to gain more clarity on it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个构造函数来创建很多用户对象。`this`关键字只是简单地指向我们将要创建的每一个用户对象。现在可能看起来有点令人不知所措，但让我们通过一些例子来更清楚地理解它。
- en: 'Let''s begin using our `User` constructor function. To make some `User` objects,
    also known as `User` instances, follow these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用我们的`User`构造函数。要创建一些`User`对象，也称为`User`实例，请按照以下步骤进行：
- en: 'The first user that we are going to create – let''s call it `user1` – will
    be defined as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要创建的第一个用户 - 让我们称之为`user1` - 将被定义如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, you may have noticed that we used the `new` keyword to
    invoke our constructor function and make a user object, which is how we get our
    constructor function to work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，你可能已经注意到我们使用了`new`关键字来调用我们的构造函数并创建一个用户对象，这就是我们让构造函数工作的方法。
- en: 'Then press *Enter,* and `user1` is in the system. Now, if we type `user1` 
    in the console, we''ll be able to see what we just created in the previous step:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后按下*Enter*，`user1`就出现在系统中。现在，如果我们在控制台中输入`user1`，我们将能够看到我们在上一步中创建的内容：
- en: '![](img/d44eaca9-749c-471a-8d79-efead9ca8491.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d44eaca9-749c-471a-8d79-efead9ca8491.png)'
- en: In the preceding output screenshot, we can see that `user1` is an object of
    the `User` class. We can also see that `user1` has a `firstName` of `John`, a
    `lastName` of `Smith`, an `age` of `26`, and `gender` of `male` because these
    are the parameters that we passed into the constructor function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出截图中，我们可以看到`user1`是`User`类的一个对象。我们还可以看到`user1`的`firstName`是`John`，`lastName`是`Smith`，`age`是`26`，`gender`是`male`，因为这些是我们传入构造函数的参数。
- en: 'For clarity, try adding one more user. This time, we''ll create another user
    called `user200` and pass in into the `new User ( )` function with the user''s
    properties, such as a first name of `Jill`, a last name of `Robinson`, an age
    of `25`, and a `female` gender:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更清晰，尝试添加一个用户。这一次，我们将创建另一个名为`user200`的用户，并将其传递到`new User()`函数中，传入用户的属性，例如名字为`Jill`，姓氏为`Robinson`，年龄为`25`，性别为`female`。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By pressing *Enter*, our new `user200` will be in the system. Now, if we type
    `user200` into the console and press *Enter*, we''ll see the following output:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Enter*，我们的新`user200`将出现在系统中。现在，如果我们在控制台中输入`user200`并按下*Enter*，我们将看到以下输出：
- en: '![](img/902899d7-1de6-4a56-b8af-ffc15758e7fe.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/902899d7-1de6-4a56-b8af-ffc15758e7fe.png)'
- en: In the preceding output, we can see that `user200` is an object of the `User` class,
    just like `user1`, and that she has a first name of `Jill`, a last name of `Robinson`,
    an age of `25`, and a `female` gender because these were the parameters that we
    passed into our constructor function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，我们可以看到`user200`是`User`类的一个对象，就像`user1`一样，她的名字是`Jill`，姓氏是`Robinson`，年龄是`25`，性别是`female`，因为这些是我们传入构造函数的参数。
- en: Now, you might be wondering how all of these properties that we mentioned got
    assigned correctly. This was all due to the `this` keyword that we mentioned earlier.
    When we create our constructor function, we use the `this` keyword to assign properties.
    When it comes to a constructor function, the `this` keyword does not refer to
    the function that it is in – in our case, the `User` function. Instead, `this`
    refers to the object that will be created by the constructor function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道我们提到的所有这些属性是如何被正确分配的。这都是由我们之前提到的`this`关键字所致。当我们创建我们的构造函数时，我们使用`this`关键字来分配属性。当涉及到构造函数时，`this`关键字不是指代它所在的函数
    - 在我们的例子中是`User`函数。相反，`this`指的是将由构造函数创建的对象。
- en: This signifies that if we use the constructor function to create an object,
    we must make sure that the property and their objects are first name, last name,
    age, and gender, or whenever you make your constructor function, set the `firstName`
    property as equal to the `firstName` parameter that is passed in, and do the same
    for the rest of the properties.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们使用构造函数来创建一个对象，我们必须确保属性和它们的对象是名字、姓氏、年龄和性别，或者无论何时你创建你的构造函数，都要将`firstName`属性设置为等于传入的`firstName`参数，并对其余属性做同样的操作。
- en: This is how a constructor function works and how the `this` keyword plays an
    important role in the constructor function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是构造函数的工作原理，以及`this`关键字在构造函数中扮演的重要角色。
- en: Explanation of the prototype object
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型对象的解释
- en: Another important concept that we need to discuss before getting into coding
    our blockchain data structure is the prototype object. The **prototype object**
    is simply an object that multiple other objects can refer to in order to get any
    information or functionality that they need. For our example, which we discussed
    in the previous section, each of our constructor functions will have a prototype
    that all of their instances will be able to refer to. Let's try to understand
    what a prototype object means by exploring a couple of examples.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写区块链数据结构之前，我们需要讨论的另一个重要概念是原型对象。**原型对象**只是一个多个其他对象可以引用以获取它们需要的任何信息或功能的对象。对于我们在上一节中讨论的示例，我们的每个构造函数都将有一个原型，它们的所有实例都可以引用。让我们通过探索一些例子来尝试理解原型对象的含义。
- en: 'For example, if we take our `User` constructor function that we created in
    the previous section, we can put those properties onto its prototype. Then, all
    of our user instances like `user1` and `user200` will have access to and be able
    to use that prototype. Let''s add a property on our `User` prototype and see what
    happens. To add a property on the user prototype, we will type the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们拿出我们在上一节中创建的`User`构造函数，我们可以将这些属性放在它的原型上。然后，我们所有的用户实例，如`user1`和`user200`，都将可以访问并使用该原型。让我们在`User`原型上添加一个属性并看看会发生什么。要在用户原型上添加一个属性，我们将输入以下代码：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then let''s add the name of the property to the preceding code. For example,
    let''s say we want a property email domain:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们在上面的代码中添加属性的名称。例如，假设我们想要一个属性电子邮件域：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For our example, assume that Facebook wants every user to have an `@facebook.com`
    email address, so we''ll set the email domain property as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，假设Facebook希望每个用户都有一个`@facebook.com`的电子邮件地址，因此我们将设置电子邮件域属性如下：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s check out our `user1` object again:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次检查我们的`user1`对象：
- en: '![](img/12909ac8-5180-4732-9a08-be947497cc3e.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12909ac8-5180-4732-9a08-be947497cc3e.png)'
- en: 'In the preceding screenshot, we can see that `user1` does not have the email
    domain property that we just added to it. However, we can expand the `user1` object,
    as well as its dunder proto, as highlighted in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到`user1`没有我们刚刚添加的电子邮件域属性。但是，我们可以展开`user1`对象以及它的dunder proto，如下面的截图所示：
- en: '![](img/bbf3d80b-4db6-45bc-8621-12d5e3ead677.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbf3d80b-4db6-45bc-8621-12d5e3ead677.png)'
- en: When we do this, we can observe the `emailDomain` property that we just added,
    which is set to `@facebook.com`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们可以观察到我们刚刚添加的`emailDomain`属性，它被设置为`@facebook.com`。
- en: Just to clarify, the dunder proto and the prototype object that we actually
    put the `emailDomain` property on are actually not exactly the same, but are very
    similar. Basically, anything that we put on the constructor function prototype
    will have access to the dunder proto of any of the objects that we create with
    the constructor function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了澄清，dunder proto和我们实际放置`emailDomain`属性的原型对象实际上并不完全相同，但非常相似。基本上，我们放在构造函数原型上的任何东西都可以访问我们使用构造函数创建的任何对象的dunder
    proto。
- en: So, if we put `emailDomain` on the constructor function prototype, we'll have
    access to it on the `user1` dunder proto, the `user200` dunder proto, and the
    dunder protos of any other user instance that we've created.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们在构造函数原型上放置`emailDomain`，我们将可以在`user1` dunder proto、`user200` dunder proto以及我们创建的任何其他用户实例的dunder
    proto上访问它。
- en: 'Now let''s get back to the `emailDomain` property. We put the `emailDomain`
    property and the user prototype. We can see that we don''t have the property on
    the actual `user200` object, but we have that property under the `user200` dunder
    proto. So, if we type the following command, we will still have access to that
    property:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到`emailDomain`属性。我们将`emailDomain`属性放在用户原型上。我们可以看到我们在实际的`user200`对象上没有该属性，但是我们在`user200`的dunder
    proto下有该属性。因此，如果我们输入以下命令，我们仍然可以访问该属性：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We should then see the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应该看到以下输出：
- en: '![](img/aa4732f7-2141-488c-bb2a-a583599f70ec.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa4732f7-2141-488c-bb2a-a583599f70ec.png)'
- en: So, this is how the prototype object works. If we put a property on the constructor
    function's prototype, all of the instances of the constructor function will have
    access to that property.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是原型对象的工作原理。如果我们在构造函数的原型上放置一个属性，那么构造函数的所有实例都将可以访问该属性。
- en: 'The same thing applies for any methods or functions that we might want all
    of our instances to have. Let''s take a look at another example, assuming that
    we want all of our user instances to have a `getEmailAddress` method. We can put
    this on the prototype of the constructor function as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们可能希望所有实例都具有的任何方法或函数，都适用相同的情况。让我们看另一个例子，假设我们希望所有用户实例都有一个`getEmailAddress`方法。我们可以将其放在构造函数的原型上，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s have this `getEmailAddress` method return some specific properties,
    as follows (highlighted):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们让这个`getEmailAddress`方法返回一些特定的属性，如下所示（高亮显示）：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now both `user1` and `user200` should have this method under their dunder proto,
    so let''s check it out. Type in our users, and under their dunder proto you will
    get to observe the preceding function, as shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`user1`和`user200`都应该在它们的dunder proto下有这个方法，所以让我们来检查一下。在我们的用户下输入，并在它们的dunder
    proto下你将看到前面的函数，如下面的截图所示：
- en: '![](img/33ba858a-1e99-4237-99ab-ce881768de47.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33ba858a-1e99-4237-99ab-ce881768de47.png)'
- en: In the preceding screenshot, we can observe that both `user1` and `user200`
    have the `getEmailAddress` method under their dunder proto.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以观察到`user1`和`user200`都在它们的dunder proto下有`getEmailAddress`方法。
- en: 'Now, if we type `user200.getEmailAddress` and then invoke it, the method will
    then create user200''s Facebook email address for us, as shown in the following
    screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们输入`user200.getEmailAddress`然后调用它，该方法将为我们创建user200的Facebook电子邮件地址，如下面的截图所示：
- en: '![](img/cf1af2a5-d453-4cc1-b182-f30a7f095b92.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf1af2a5-d453-4cc1-b182-f30a7f095b92.png)'
- en: 'A similar thing will happen if we invoke the method for `user1`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为`user1`调用该方法，类似的事情也会发生：
- en: '![](img/27d5b431-3bee-4bef-a976-634e3cb30c4d.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27d5b431-3bee-4bef-a976-634e3cb30c4d.png)'
- en: So, this is how we use the prototype object with a constructor function. If
    we want our constructor function instances to all have the properties that are
    the same for all of them, or all have a method that is the same for all of them,
    we will put it on the prototype instead of the constructor function itself. This
    will help in keeping the instances more lean and cleaner.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何使用原型对象与构造函数。如果我们希望我们的构造函数实例都具有相同的属性，或者都具有相同的方法，我们将把它放在原型上，而不是构造函数本身。这将有助于保持实例更加精简和清晰。
- en: This is all the background information that we need to know in order to start
    coding our blockchain data structure. In the following section, we will start
    building our blockchain by using a constructor function and the prototype object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要了解的所有背景信息，以便开始编写我们的区块链数据结构。在接下来的部分中，我们将通过使用构造函数和原型对象来开始构建我们的区块链。
- en: Blockchain constructor function
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链构造函数
- en: Let's get started with building our blockchain data structure. We'll start by
    opening all of the files that we have in our blockchain directory by using the
    Sublime editor. If you are comfortable using any other editor, you can use that
    too. Open our entire blockchain directory in whichever editor you prefer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的区块链数据结构。我们将首先通过使用Sublime编辑器打开我们区块链目录中的所有文件。如果你习惯使用其他编辑器，也可以使用。在你喜欢的任何编辑器中打开我们整个区块链目录。
- en: 'We''ll be building our entire blockchain data structure in the `dev/blockchain.js`
    file that we created in [Chapter 1](cd35f368-cf70-4065-8bd8-ed8347b1878a.xhtml),
    *Setting up the Project*. Let''s build this blockchain data structure by using
    a constructor function that we learned about in the previous section.  So, let''s
    begin:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们在[第一章](cd35f368-cf70-4065-8bd8-ed8347b1878a.xhtml)中创建的`dev/blockchain.js`文件中构建整个区块链数据结构，*设置项目*。让我们通过使用我们在上一节中学到的构造函数来构建这个区块链数据结构。所以，让我们开始：
- en: 'For the constructor by type the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构造函数，请键入以下内容：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For now, the `Blockchain ()` function is not going to take any parameters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`Blockchain()`函数不会接受任何参数。
- en: 'Next, inside of our constructor function, we are going to add the following
    terms:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的构造函数内部，我们将添加以下术语：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code block, `[]` defines an array, and the `this.chain = [];` is
    where the meat of our blockchain will be stored. All of the blocks that we mine
    will be stored in this particular array as a chain, while `this.newTransactions
    = [];`  is where we will hold all of the new transactions that are created before
    they are placed into a block.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码块中，`[]`定义了一个数组，而`this.chain = [];`是我们的区块链的核心所在。我们挖掘的所有区块都将存储在这个特定的数组中作为一个链，而`this.newTransactions
    = [];`是我们将在放入区块之前创建的所有新交易的存储位置。
- en: All of this might seem a little bit confusing and overwhelming right now, but
    don't worry about it. Let's dive deeper into this in future sections.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有这些可能看起来有点混乱和令人不知所措，但不用担心。让我们在未来的部分深入了解这一点。
- en: When defining the preceding function, we have initiated the process of creating
    the blockchain data structure. Now, you might be wondering why we are using a
    constructor function to build our blockchain data structure instead of a class;
    the answer to this is that this is simply a preference. We prefer to create constructor
    functions over classes in JavaScript because in JavaScript there really are no
    classes. Classes in JavaScript are simply a kind of a sugar coating on top of
    constructor functions and the object prototype. So, we simply prefer to just stick
    with constructor functions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义上述函数时，我们已经开始了创建区块链数据结构的过程。现在，你可能会想为什么我们要使用构造函数来构建我们的区块链数据结构，而不是类；答案是这只是一种偏好。在JavaScript中，我们更喜欢使用构造函数而不是类，因为在JavaScript中实际上并没有类。JavaScript中的类只是构造函数和对象原型的一种糖衣。所以，我们更喜欢坚持使用构造函数。
- en: 'However, if you want to create a blockchain by using a class, you could do
    something such as in the following block of code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想使用类来创建区块链，你可以像下面的代码块一样做：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, either way, if you prefer using a constructor function or using a class,
    it would work just fine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，无论你喜欢使用构造函数还是类，都可以正常工作。
- en: This is it – with defining our function, we've began the process of building
    our blockchain data structure. In further sections, we'll continue to build on
    this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 通过定义我们的函数，我们已经开始了构建我们的区块链数据结构的过程。在后续部分中，我们将继续构建。
- en: Building the createNewBlock method
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建`createNewBlock`方法
- en: 'Let''s continue with building our blockchain data structure. After defining
    our constructor function in the previous section, the next thing that we want
    to do with our constructor function is to place a method in our `Blockchain` function.
    This method that we are going to create will be called `createNewBlock`. As its
    name suggests, this method will create a new block for us. Let''s follow the below
    mentioned steps to build the method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建我们的区块链数据结构。在上一节中定义了我们的构造函数之后，我们想要做的下一件事是在我们的`Blockchain`函数中放置一个方法。我们将要创建的这个方法将被称为`createNewBlock`。顾名思义，这个方法将为我们创建一个新的区块。让我们按照下面提到的步骤来构建这个方法：
- en: 'The `createNewBlock` method will be defined as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createNewBlock`方法将定义如下：'
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we''ve got this `createNewBlock ` method on our blockchain `prototype`
    object. This method will take the three parameters, as highlighted in the following
    line of code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在我们的区块链`prototype`对象上有了这个`createNewBlock`方法。这个方法将使用下面代码行中突出显示的三个参数：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll learn in depth about these three parameters in further sections, so don't
    worry if you're not familiar with them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的部分深入学习这三个参数，所以如果你对它们不熟悉，不用担心。
- en: 'Now, the next thing that we want to do inside of our `createNewBlock` method
    is to create a `newBlock` object. Let''s define this as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在`createNewBlock`方法内想要做的下一件事是创建一个`newBlock`对象。让我们定义如下：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `newBlock` object is going to be a new block inside of our `BlockChain`,
    so all of the data is going to be stored inside of this block. This `newBlock` object
    is a pretty important part of our blockchain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`newBlock`对象将成为我们`BlockChain`中的一个新区块，因此所有数据都将存储在这个区块中。这个`newBlock`对象是我们区块链的一个非常重要的部分。
- en: 'Next, on the `newBlock` object, we''re going to have an `index` property. This
    `index` value will basically be the block number. It will describe what number
    of block the `newBlock` is in our chain (for example, it may be the first block):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`newBlock`对象上，我们将有一个`index`属性。这个`index`值基本上就是区块编号。它将描述`newBlock`在我们的链中的区块编号（例如，它可能是第一个区块）：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our next property is going to be a `timestamp`, because we want to know when
    the block was created:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来的属性将是一个`timestamp`，因为我们想知道区块是什么时候创建的：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, the next property we will add will be for the `transactions`. When we
    create a new block, we''ll want to put all of the new transactions or the pending
    transactions that have just been created into the new block so that they''re inside
    of our blockchain and can never be changed:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要添加的属性是`transactions`。当我们创建一个新区块时，我们将希望将所有新的交易或者刚刚创建的待处理交易放入新区块中，以便它们在我们的区块链中，并且永远不会被更改：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding highlighted line of code states that all of the transactions in
    the block should be the new transactions that are waiting to be placed into a
    block.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面突出显示的代码行表示区块中的所有交易应该是等待放入区块中的新交易。
- en: 'The next property that we are going to have on our block is a `nonce`, and
    this will be equal to the `nonce` parameter that we passed into our function earlier:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们区块的下一个属性将是一个`nonce`，它将等于我们之前传递到函数中的`nonce`参数：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, you might be wondering what a `nonce` is. Basically, a nonce comes from
    a proof of work. In our case, this is simply any number; it doesn't matter which.
    This nonce is pretty much proof that we've created this new block in a legitimate
    way by using a `proofOfWork` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道`nonce`是什么。基本上，nonce来自于工作证明。在我们的情况下，这只是一个数字；它无关紧要。这个nonce基本上证明了我们通过使用`proofOfWork`方法以合法的方式创建了这个新区块。
- en: All of this might seem a little bit confusing right now, but don't worry — once
    we build more on our blockchain data structure, it will be much easier to understand
    how everything works together to create a functional blockchain. So, if you don't
    understand what a nonce is right now, don't worry about it. We're going to deal
    with this property in further sections, and it will become clearer as we move
    on.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有这些可能看起来有点混乱，但不要担心——一旦我们在区块链数据结构上建立更多内容，就会更容易理解所有东西是如何一起工作的，从而创建一个功能性的区块链。所以，如果你现在不理解nonce是什么，不要担心。我们将在后续章节中处理这个属性，随着我们的进展，它会变得更清晰。
- en: 'The next property is going to be a `hash`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的属性将是一个`hash`：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Basically, this `hash` will be the data from our `newBlock`. What's going to
    happen is we're going to pass our transactions or our `newTransactions` into a
    hashing function. What this means is that all of our transactions are going to
    be compressed into a single string of code, which will be our `hash`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个`hash`将是我们`newBlock`的数据。发生的情况是我们将我们的交易或者`newTransactions`传递到一个哈希函数中。这意味着我们所有的交易将被压缩成一个代码字符串，这将是我们的`hash`。
- en: 'Finally, our last property on our `newBlock` will be our `previousBlockHash`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们`newBlock`上的最后一个属性将是我们的`previousBlockHash`：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This `previousBlockHash` property is very similar to our `hash` property, except
    our `hash` property deals with the data from our current block hashed into a string,
    and the `previousBlockHash` property deals with the data from our previous block
    or the previous block to the current block hashed into a string.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`previousBlockHash`属性与我们的`hash`属性非常相似，只是我们的`hash`属性处理的是我们当前区块的数据哈希成一个字符串，而`previousBlockHash`属性处理的是我们上一个区块或者当前区块的上一个区块的数据哈希成一个字符串。
- en: So, `hash` and `previousBlockHash` are both hashes. The only difference is that
    the `hash` property deals with the data of the current block, and, the `previousBlockHash` property
    deals with the hashing of the data of the previous block.  This is how you create
    a new block, and this is what every block in our blockchain will look like.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`hash`和`previousBlockHash`都是哈希。唯一的区别是`hash`属性处理的是当前区块的数据，而`previousBlockHash`属性处理的是上一个区块的数据的哈希。这就是如何创建一个新区块，这就是我们区块链中每个区块的样子。
- en: 'Continuing with our `createNewBlock` method, the next thing that we want to
    do is set `this.newTransaction` as equal to an empty array, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续我们的`createNewBlock`方法，我们接下来要做的是将`this.newTransaction`设置为空数组，如下所示：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We do this because, once we create our new block, we are putting all of the
    new transactions into the `newBlock`. Therefore, we want to clear out the entire
    new transactions array so that we can start over for the next block.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为，一旦我们创建了新的区块，我们就将所有新的交易放入`newBlock`中。因此，我们希望清空整个新交易数组，以便我们可以为下一个区块重新开始。
- en: 'Next, what we simply want to do is take the new block that we''ve created and
    push it into our chain, and then we''re going to return the `newBlock`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要做的就是将我们创建的新区块推入我们的链中，然后我们将返回`newBlock`：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By adding these last two lines of code, our `createNewBlock` method is ready.
    Basically, what this method does on a high level is it creates a new block. Inside
    of this block, we have our transactions and the new transactions that have been
    created since our last block was mined. After we've created a new block, let's
    clear out the new transactions, push the new block into our chain, and simply
    return our new block.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这最后两行代码，我们的`createNewBlock`方法已经准备好了。基本上，这个方法在高层次上所做的就是创建一个新区块。在这个区块内，我们有我们的交易和自上一个区块被挖掘以来创建的新交易。创建了新区块后，让我们清空新交易，将新区块推入我们的链中，然后简单地返回我们的新区块。
- en: Testing the createNewBlock method
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试`createNewBlock`方法
- en: 'Now lets test the `createNewBlock` method that we created in the preceding
    section:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试我们在前面部分创建的`createNewBlock`方法：
- en: 'The first thing that we need to do is export our `Blockchain` constructor function
    because we are going to use this function in our `test.js` file. So, to export
    the constructor function, we will go to the bottom of the `blockchain.js` file,
    type the following line of code, and then save the file:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是导出我们的`Blockchain`构造函数，因为我们将在我们的`test.js`文件中使用这个函数。因此，为了导出构造函数，我们将转到`blockchain.js`文件的底部，输入以下代码行，然后保存文件：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, go to the `dev/test.js` file, as this is where we will be testing our
    `createNewBlock` method. Now, the first thing that we want to do in our `dev/test.js`
    file is import our `Blockchain` constructor function, so type the following:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到`dev/test.js`文件，因为这是我们将测试`createNewBlock`方法的地方。现在，在`dev/test.js`文件中，我们要做的第一件事是导入我们的`Blockchain`构造函数，因此输入以下内容：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This preceding line of code simply requires or calls the `blockchain.js` file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行只是需要或调用`blockchain.js`文件。
- en: Testing the Blockchain constructor function
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Blockchain构造函数
- en: 'Let''s test the Blockchain constructor function as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式测试Blockchain构造函数：
- en: 'Lets make an instance of our `Blockchain` constructor function, so we will
    add the following line of code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`Blockchain`构造函数的实例，因此我们将添加以下代码行：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `bitcoin` variable in the preceding line of code is just used for the purpose
    of an example. Then we add the following line of code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一行代码中的`bitcoin`变量只是用作示例。然后我们添加以下代码行：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the preceding line of code, `bitcoin` should be our blockchain. There is
    currently no data or blocks in this, but it should log out as a blockchain. Let's
    save the `test.js` file and run the test to observe the output on the terminal
    window.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述代码行，`bitcoin`应该是我们的区块链。目前这里没有数据或区块，但它应该作为一个区块链记录出来。让我们保存`test.js`文件并运行测试，观察终端窗口上的输出。
- en: 'Now go to our terminal window. In here, we''re currently in the `blockchain`
    directory, and our `test.js` file is in our `dev` folder, so type the following
    command in the terminal:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到我们的终端窗口。在这里，我们目前在`blockchain`目录中，我们的`test.js`文件在我们的`dev`文件夹中，因此在终端中输入以下命令：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This preceding line of code will allow us to run the test that we have written
    to test our `Blockchain` constructor function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行将允许我们运行我们编写的测试来测试我们的`Blockchain`构造函数。
- en: 'Now press *Enter*, and we''ll get to observe the `Blockchain` on the terminal
    window, as highlighted in the following screenshot:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按下*Enter*，我们将在终端窗口上观察`Blockchain`，如下截图所示：
- en: '![](img/23de40f9-44af-44a7-891e-a3e534e61291.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23de40f9-44af-44a7-891e-a3e534e61291.png)'
- en: From the output in the preceding screenshot, we can observe that `Blockchain`
    has an empty chain and an empty transactions array. This is exactly what we expected
    the output to be.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述截图的输出中，我们可以观察到`Blockchain`有一个空的链和一个空的交易数组。这正是我们预期的输出。
- en: Testing the createNewBlock method
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试createNewBlock方法
- en: 'Let''s follow the below mentioned steps to test the createNewBlock method:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤测试createNewBlock方法：
- en: 'Firstly, underneath where we created our `bitcoin` variable, type in the following
    highlighted line of code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在我们创建`bitcoin`变量的地方下面，输入以下突出显示的代码行：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This `createNewBlock()` method requires three parameters, such as `nonce`,
    `previousBlockHash`, and a `hash`. For test purposes, we can just pass in whatever
    we want for now. Here, the nonce will just be a number. Then we will create a
    dummy hash for our `previousBlockHash`, followed by another hash for our `hash`
    parameter, as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`createNewBlock()`方法需要三个参数，比如`nonce`、`previousBlockHash`和`hash`。为了测试目的，我们现在可以随便传入一些值。这里，nonce只是一个数字。然后我们将为我们的`previousBlockHash`创建一个虚拟哈希，然后为我们的`hash`参数创建另一个哈希，如下所示：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Right now, we are creating our `bitcoin` blockchain, followed by a new block
    in our bitcoin blockchain. When we log out of our bitcoin blockchain, we should
    have one block in it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在创建我们的`bitcoin`区块链，然后在我们的比特币区块链中创建一个新区块。当我们退出比特币区块链时，我们应该有一个区块。
- en: 'Save this file and run our `test.js` file again in the terminal. You''ll then
    get to observe the following output:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此文件并在终端中再次运行我们的`test.js`文件。然后您将观察到以下输出：
- en: '![](img/0dae3277-99de-4416-985e-14a3168953f9.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dae3277-99de-4416-985e-14a3168953f9.png)'
- en: In the preceding screenshot, you can observe the entire blockchain data structure
    in the `chain` array. This has one block in it, or one object in it. This block
    also has the `hash`, `nonce`, and `previousBlockHash` parameters that we had passed.
    It also has the `timestamp` and the `index` of `1`. It has no transactions because
    we haven't created any transactions yet. Consequently, we can conclude that the
    `createNewBlock` method works just fine.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，您可以观察到`chain`数组中的整个区块链数据结构。它里面有一个区块，或者说一个对象。这个区块还有我们传递的`hash`、`nonce`和`previousBlockHash`参数。它还有`timestamp`和`index`为`1`。它没有交易，因为我们还没有创建任何交易。因此，我们可以得出结论，`createNewBlock`方法运行正常。
- en: 'Now let''s test our method even further by creating a couple more blocks in
    our chain. Let''s duplicate the following lines of code  multiple times and then
    try to change the values in it as we wish:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过在我们的链中创建更多的区块来进一步测试我们的方法。让我们多次复制以下代码行，然后尝试更改其中的值：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After duplicating the code and changing the value, save the file. Now, when
    we run our `test.js` file, we should have three blocks in our chain, as shown
    in the following screenshot:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制代码并更改值后保存文件。现在，当我们运行`test.js`文件时，我们应该在我们的链中有三个区块，如下截图所示：
- en: '![](img/8eb516d6-29bd-48e1-b177-dd2895418bfc.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8eb516d6-29bd-48e1-b177-dd2895418bfc.png)'
- en: In the preceding screenshot, you may have observed the three blocks inside of
    the `chain` array. These are all of the blocks that we've created with our `createNewBlock`
    method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，您可能已经观察到`chain`数组中的三个区块。这些都是我们用`createNewBlock`方法创建的所有区块。
- en: Building the getLastBlock method
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建getLastBlock方法
- en: 'Now, the next method that we are going to add to our `Blockchain` constructor
    function will be the `getLastBlock`. This method will simply return the last block
    in our blockchain to us. Follow the below mentioned steps to build the method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要添加到我们的`Blockchain`构造函数中的下一个方法将是`getLastBlock`。这个方法将简单地返回我们区块链中的最后一个块。按照下面提到的步骤来构建这个方法：
- en: 'Go to our `dev/blockchain.js` file, and after our `createNewBlock` method,
    add the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到我们的`dev/blockchain.js`文件，在我们的`createNewBlock`方法之后添加以下内容：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inside of this `getLastBlock` method, we will type the following highlighted
    line of code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getLastBlock`方法中，我们将输入以下突出显示的代码行：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `[this.chain.length - 1];` in this preceding code defines the position of
    the block in the chain, which, in our case, is the previous block, therefore negated
    by `1`. This method is simple and straightforward, and we'll use it in later chapters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中的`[this.chain.length - 1];`定义了链中块的位置，在我们的情况下是前一个块，因此通过`1`进行否定。这个方法简单明了，我们将在后面的章节中使用它。
- en: Creating the createNewTransaction method
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`createNewTransaction`方法
- en: 'The next method that we are going to add to our blockchain constructor function
    is called `createNewTransaction`. This method will create a new transaction for
    us. Let''s follow the below mentioned steps to create the method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加到我们的区块链构造函数中的下一个方法是`createNewTransaction`。这个方法将为我们创建一个新的交易。让我们按照下面提到的步骤来创建这个方法：
- en: 'Start building up this method by adding the following line of code after our
    `getLastBlock` method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在我们的`getLastBlock`方法之后添加以下代码来开始构建这个方法：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `function ()` will take three parameters, such as the following:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`function ()`将接收三个参数，如下所示：'
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What these three parameters will do is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个参数的作用如下：
- en: '`amount`: This parameter will take in the amount of the transaction or how
    much is being sent in this transaction.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amount`：此参数将接收交易金额或此交易发送的金额。'
- en: '`sender`: This will take in the sender''s address.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sender`：这将接收发件人的地址。'
- en: '`recipient`: This will take in the recipient''s address.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipient`：这将接收收件人的地址。'
- en: 'The next thing that we want to do inside of our `createNewTransaction` method
    is create a transaction object. So, add the following line of code to our method:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`createNewTransaction`方法中要做的下一件事是创建一个交易对象。因此，将以下代码添加到我们的方法中：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This object will have three properties in it. It will have an `amount`, a `sender`,
    and the `recipient`. These are the same three parameters that we passed into our
    `function()`. So, type in the following:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个对象将有三个属性。它将有一个`amount`，一个`sender`和一个`recipient`。这些都是我们传递给`function()`的相同三个参数。因此，输入以下内容：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is what our transaction object will look like. All of the transactions
    that we record on our `Blockchain` are going to look just like this. They all
    are going to have an amount, a sender, and the recipient, which is pretty straightforward
    and simple.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的交易对象将会是什么样子。我们在`Blockchain`上记录的所有交易都将看起来像这样。它们都将有一个金额，一个发件人和一个收件人，这非常简单明了。
- en: 'The next thing that we want to do now is push this `newTransaction` data into
    our `newTransactions` array. Let''s do this by adding the following code after
    our `newTransaction` object:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在要做的下一件事是将这个`newTransaction`数据推送到我们的`newTransactions`数组中。让我们在`newTransaction`对象之后添加以下代码来实现这一点：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, the new transaction that we just created will now be pushed into our `newTransactions`
    array.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚创建的新交易现在将被推送到我们的`newTransactions`数组中。
- en: Now, let's just try to understand what this `newTransactions` array actually
    is. Basically, what is happening here with this `newTransactions` array is that
    on our blockchain there are going to be a lot of people who will be making a lot
    of different transactions. They will be sending money from one person to another
    and this will be happening repetitively. Every time a new transaction is created,
    it's going to be pushed into our `newTransactions` array.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试着理解一下这个`newTransactions`数组实际上是什么。基本上，这个`newTransactions`数组在我们的区块链上会有很多人进行很多不同的交易。他们将会把钱从一个人发送到另一个人，这将会重复发生。每当创建一个新交易时，它都会被推送到我们的`newTransactions`数组中。
- en: However, all of the transactions in this array are not really set in stone.
    They're not really recorded in our blockchain yet. They will get recorded in our
    blockchain when a new block is mined, which is when a new block is created. All
    of these new transactions are pretty much just pending transactions, and they
    have not been validated yet. They get validated, set in stone, and recorded in
    our blockchain when we create a new block with the help of the `createNewBlock`
    method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个数组中的所有交易实际上并没有被确定下来。它们实际上还没有被记录在我们的区块链上。当挖掘新块时，也就是创建新块时，所有这些新交易基本上只是待处理交易，并且尚未被验证。当我们使用`createNewBlock`方法创建新块时，它们将被验证，确定下来，并记录在我们的区块链上。
- en: 'In our `createNewBlock` method, you can observe in `transactions: this.newTransactions` that
    we set the transactions on a new block equal to the `newTransactions` or the pending
    transactions in our blockchain. You can think of this `newTransactions` property
    on our blockchain as a pending transactions property.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的`createNewBlock`方法中，您可以观察到在`transactions: this.newTransactions`中，我们将新块上的交易设置为`newTransactions`或我们区块链中的待处理交易。您可以将我们区块链上的`newTransactions`属性视为待处理交易属性。'
- en: For easy reference,  let's actually change all of the `newTransactions` properties
    in our code to `pendingTransactions` properties. Overall, when a new transaction
    is created, it is pushed into our `pendingTransactions` array. Then, when a new
    block is mined or when a new block is created, that's when all of our pending
    transactions become recorded on our blockchain, and they are then set in stone
    and can never be changed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便参考，让我们实际上将代码中的所有`newTransactions`属性更改为`pendingTransactions`属性。总的来说，当创建新交易时，它被推送到我们的`pendingTransactions`数组中。然后，当挖掘新块或创建新块时，我们的所有待处理交易都会记录在我们的区块链上，然后它们就被确定下来，永远不能被更改。
- en: 'The point of all this is that before our method ends, we want to return in
    which block we will be able to find the new transaction because our new transaction
    will be in the next block when it is mined. Consequently, we''ll simply type the
    following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切的重点是，在我们的方法结束之前，我们希望返回我们将能够找到新交易的区块，因为当新交易被挖掘时，我们的新交易将在下一个区块中。因此，我们只需输入以下代码：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, `this.getlastBlock()` returns a block object for us.
    We want to get the index property of this block – adding `['index']` will provide
    us with the index of the last block in our chain, and adding `+ 1` will provide
    us with the number of the block our transaction was pushed to.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`this.getlastBlock()`为我们返回一个区块对象。我们想要获取这个区块的index属性 - 添加`['index']`将为我们提供链中最后一个区块的索引，添加`+
    1`将为我们提供我们的交易被推送到的区块的编号。
- en: Let's have a quick recap,  the `createNewTransaction` method simply creates
    a `newTransaction` object, and then we push that `newTransaction` into our `pendingTransactions`
    array. Finally, we return the number of the block that the `newTransaction` will
    be added to.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下，`createNewTransaction`方法只是创建一个`newTransaction`对象，然后我们将`newTransaction`推送到我们的`pendingTransactions`数组中。最后，我们返回`newTransaction`将被添加到的区块的编号。
- en: Testing the createNewTransaction method
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试createNewTransaction方法
- en: 'Let''s test the `createNewTransaction` method that we created in the previous
    section. Just as a heads up: this section is going to be a lot of fun, as here
    you will really start to understand how powerful a blockchain can be and how blocks
    and transactions work with each other. You''ll also get to learn how the transactions
    are recorded in the blockchain. So let''s get started:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试在上一节中创建的`createNewTransaction`方法。提醒一下：这一节将会非常有趣，因为在这里你将真正开始理解区块链有多强大，以及区块和交易是如何相互作用的。您还将学习交易如何记录在区块链中。所以让我们开始吧：
- en: 'We''re going to test our `createNewTransaction` method in our `test.js` file.
    In this file, we''ve already required our `blockchain.js` file and have made a
    new instance of our `Blockchain` called `bitcoin`, which we are logging out at
    the end of our file. Take a look at the following screenshot for a quick review:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在我们的`test.js`文件中测试我们的`createNewTransaction`方法。在这个文件中，我们已经需要了我们的`blockchain.js`文件，并创建了一个名为`bitcoin`的`Blockchain`的新实例，我们在文件末尾记录了它。快速查看以下截图：
- en: '![](img/841dc351-8c46-47a1-b1ac-276b187e57eb.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/841dc351-8c46-47a1-b1ac-276b187e57eb.png)'
- en: 'Now, the first thing that we''re going to do in our `test.js` file is create
    a new block using our `createNewBlock` method, similarly to what we did in the *Testing
    the createNewBlock method* section. Type in the following into your `test.js`
    file:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的`test.js`文件中，我们要做的第一件事是使用我们的`createNewBlock`方法创建一个新的区块，类似于我们在*测试createNewBlock方法*部分所做的。在您的`test.js`文件中输入以下内容：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, what we want to do is create some new transactions to test our `createNewTransaction`
    method. This `createNewTransaction` method takes in three parameters, such as `amount`,
    a `sender`, and the `recipient`. Let''s add this transaction data to our test
    case:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是创建一些新的交易来测试我们的`createNewTransaction`方法。这个`createNewTransaction`方法接受三个参数，比如`amount`，`sender`和`recipient`。让我们将这个交易数据添加到我们的测试用例中：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding line of code, we've set the amount of the transaction to `100 `and
    the sender and recipient's address to some random hash numbers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码行中，我们将交易金额设置为`100`，发送方和接收方的地址设置为一些随机哈希数。
- en: You might have noticed the names `ALEX` and `JEN` in the addresses. We've added
    those just to simplify the identification of who the sender and recipient is.
    In reality, you would more than likely not have this kind of name appear at the
    beginning of an address. We've done this to make it easier for us to reference
    these addresses.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到地址中的`ALEX`和`JEN`的名称。我们添加这些只是为了简化发送方和接收方的识别。实际上，您很可能不会在地址开头看到这种名称。我们这样做是为了更容易地引用这些地址。
- en: 'Now, let''s just quickly summarize what we have done so far in our test case.
    Take a look at the following code block:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速总结一下我们在测试用例中到目前为止所做的事情。看一下以下代码块：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, we first required the bitcoin blockchain, and then we
    created a new block. After that, we created a new transaction, and then we logged
    out the bitcoin blockchain.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先需要了比特币区块链，然后创建了一个新的区块。之后，我们创建了一个新的交易，然后记录了比特币区块链。
- en: When we run this `test.js` file, we should expect to see our bitcoin blockchain,
    which should have one block in the chain as well as one transaction in the `pendingTransactions`
    array because we have not mined or created a new block after creating the transaction.
    Let's save this file and run it to see what we get.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个`test.js`文件时，我们应该期望看到我们的比特币区块链，它应该有一个链中的区块以及`pendingTransactions`数组中的一个交易，因为我们在创建交易后还没有挖掘或创建新的区块。让我们保存这个文件并运行它看看我们得到什么。
- en: 'Now go to your terminal window, type in the following command, and then press
    *Enter*:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到您的终端窗口，输入以下命令，然后按*Enter*：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We get to observe the bitcoin blockchain on the terminal window, as shown in
    the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在终端窗口上观察比特币区块链，如下截图所示：
- en: '![](img/8384e707-7642-4498-8e43-335168607f06.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8384e707-7642-4498-8e43-335168607f06.png)'
- en: In the output on your window and in the preceding screenshot, you can observe
    our chain, which has the one block that we created.  In our `pendingTransactions` array,
    we have one pending transaction, which is the transaction we created in the test
    case. Looking at the output of the test, we can conclude that, so far, our `createNewTransaction`
    method works fine.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的窗口输出和上述截图中，您可以观察到我们的链，其中有我们创建的一个区块。在我们的`pendingTransactions`数组中，我们有一个待处理的交易，这是我们在测试用例中创建的交易。从测试的输出来看，我们可以得出结论，到目前为止，我们的`createNewTransaction`方法运行正常。
- en: Adding a pending transaction to our blockchain
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的区块链添加待处理交易
- en: 'Now let''s try to understand how we can get the `pendingTransaction` into our
    actual `chain` up here. The way we do that is by mining a new block or by creating
    a new block. Let''s do that now:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试着理解如何将`pendingTransaction`放入我们实际的`chain`中。我们这样做的方式是通过挖掘一个新的区块或创建一个新的区块。现在就让我们这样做：
- en: 'After we create the `newTransaction`, let''s create a new block using the `createNewBlock`
    method, as highlighted in the following code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`newTransaction`之后，让我们使用`createNewBlock`方法创建一个新的区块，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What we have done is created a block, created a transaction, and then mined
    a new block. Now the transaction that we created should show up in our second
    block because we mined a block after we created a transaction.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是创建一个区块，创建一个交易，然后挖掘一个新的区块。现在我们创建的交易应该出现在我们的第二个区块中，因为我们在创建交易后挖掘了一个区块。
- en: 'Now save the file and run the test again. Let''s see what we get from this.
    Go to your terminal and again type in the `node dev/test.js` command and press
    *Enter*. You will get to observe the output that is shown in the following screenshot:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存文件并再次运行测试。让我们看看从中得到了什么。去你的终端，再次输入`node dev/test.js`命令并按*Enter*。你将看到以下截图中显示的输出：
- en: '![](img/a9ef7fc6-b02d-4298-a717-ff658920faad.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9ef7fc6-b02d-4298-a717-ff658920faad.png)'
- en: 'Here, we have our entire blockchain again, which has two blocks in it because
    we mined two blocks. The chain has our first block (index: 1), which has no transactions
    and has our second block (index: 2),  in which, if you look at our transactions,
    it says that there is an Array that has items in it versus a first block''s transaction
    array, which has no items in it.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次拥有了我们的整个区块链，其中有两个区块，因为我们挖掘了两个区块。这个链有我们的第一个区块（索引：1），其中没有交易，还有我们的第二个区块（索引：2），在其中，如果你看我们的交易，它说有一个包含项目的数组，而第一个区块的交易数组中没有项目。
- en: 'Now take a closer look at the second block''s transaction array. We should
    expect to see the transaction that we had created previously. Let''s make the
    following highlighted modification to our test case:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在仔细看看第二个区块的交易数组。我们应该期望看到我们之前创建的交易。让我们对我们的测试案例进行以下突出显示的修改：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this modification, we just log out of the second block in our chain. `[1]`
    in the code defines the position of the second block.  Save this file and run
    it. In the output, you can observe that we are simply logging out of the second
    block in our chain and you can see that, for transactions, it has an array with
    one object in it. Check out the following screenshot:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个修改中，我们只是登出了我们链中的第二个区块。代码中的`[1]`定义了第二个区块的位置。保存这个文件并运行它。在输出中，你可以观察到我们只是登出了我们链中的第二个区块，并且你可以看到，对于交易，它有一个包含一个对象的数组。查看以下截图：
- en: '![](img/9f82129a-ed23-4cb4-852e-effb7e1052b5.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f82129a-ed23-4cb4-852e-effb7e1052b5.png)'
- en: This object is the transaction that we created in our test. What we did here
    was just create a transaction and then mine it by creating a new block or mining
    a new block, which now has our transaction in it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象是我们在测试中创建的交易。我们在这里所做的就是创建一个交易，然后通过创建一个新的区块或挖掘一个新的区块来挖掘它，现在我们的交易就在其中了。
- en: Now, let's carry out a couple more examples to help clarify what is happening
    here. Let's take the `createNewTransaction` method and duplicate it three more
    times after our `createNewBlock` method. Make the modifications to the amounts
    as you wish to.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行几个更多的示例，以帮助澄清这里发生了什么。让我们在`createNewBlock`方法之后再次复制并粘贴`createNewTransaction`方法三次。根据需要修改金额。
- en: 'What''s happening over here is that, from the top, we are first creating a
    block and then creating a transaction. We are then creating or mining a new block,
    so we should have one block with no transactions and another block with one transaction
    in it. After we create our second block, we are creating three more new transactions.
    At this point, all three of these new transactions should be in our `pendingTransactions`
    array because we are not creating a new block after we create these three transactions.
    Lastly, we log out of our bitcoin blockchain again. Your test should now look
    similar to the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，从顶部开始，我们首先创建一个区块，然后创建一个交易。然后我们创建或挖掘一个新的区块，所以我们应该有一个没有交易的区块和另一个有一个交易的区块。在创建第二个区块后，我们创建了另外三个新的交易。此时，这三个新的交易应该都在我们的`pendingTransactions`数组中，因为我们在创建这三个交易后没有创建新的区块。最后，我们再次登出我们的比特币区块链。你的测试现在应该类似于以下内容：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, if we save the file and run it, we should have two blocks in our chain,
    and we should also have three transactions in the `pendingTransactions` array.
    Let''s see what we get here. You will get to observe the following output on your
    screen:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们保存文件并运行它，我们应该在我们的链中有两个区块，并且在`pendingTransactions`数组中也应该有三个交易。让我们看看我们在这里得到了什么。你将在屏幕上看到以下输出：
- en: '![](img/30c69a57-08f5-4a1f-ab4c-f47ba6c35ce0.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30c69a57-08f5-4a1f-ab4c-f47ba6c35ce0.png)'
- en: In the preceding screenshot, you can observe that we have our blockchain. In
    this chain, we have two blocks, just like we expected to have, and in our `pendingTransactions`
    array, we have three transactions, which are the three transactions that we had
    created in our test file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到我们的区块链。在这个链中，我们有两个区块，就像我们期望的那样，并且在我们的`pendingTransactions`数组中，我们有三个交易，这就是我们在测试文件中创建的三个交易。
- en: 'What we have to do next is get these pending transactions into our chain. For
    that, let''s mine another block. Just copy and paste the `creatNewBlock` method
    after the three transactions that we created and make modifications to its parameters
    as you wish to. When we run the test now, the three transactions that are pending
    should appear in our new block. Let''s save the file and run the test. You will
    get to observe the following output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是将这些待处理的交易放入我们的链中。为此，让我们挖掘另一个区块。只需在我们创建的三个交易后复制并粘贴`creatNewBlock`方法，并根据需要修改其参数。当我们现在运行测试时，这三个待处理的交易应该出现在我们的新区块中。保存文件并运行测试。你将看到以下输出：
- en: '![](img/6b8768ca-64a2-493a-ae89-f895e71c5a5f.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b8768ca-64a2-493a-ae89-f895e71c5a5f.png)'
- en: 'So, we have our blockchain, which has three blocks in it. Our `pendingTransactions`
    array is currently empty, but where did those three transactions go? As it turns
    out, they should be in the last block that we created, which is the index: 3 block.
    Inside of this third block we have our transactions, which should be the three
    transactions we just created. Let''s take a deeper look at this by making a tiny
    modification to the last line of our test code, which is `console.log(bitcoin.chain[2]); `.
    The value `2` here specifies the third block in the chain. Let''s save this modification
    and run the test again.  You will get to see the third block in the chain:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有我们的区块链，其中有三个区块。我们的`pendingTransactions`数组目前是空的，但是那三笔交易去哪了呢？事实证明，它们应该在我们创建的最后一个区块中，也就是索引：3区块。在这第三个区块中，我们有我们的交易，应该是我们刚刚创建的三笔交易。让我们通过对我们测试代码的最后一行进行微小修改来更深入地了解一下，即`console.log(bitcoin.chain[2]);`。这里的值`2`指定了链中的第三个区块。让我们保存这个修改并再次运行测试。你将看到链中的第三个区块：
- en: '![](img/3d4a892c-7972-4159-ad4b-b929943e13fc.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d4a892c-7972-4159-ad4b-b929943e13fc.png)'
- en: In the transaction's array, you can see that we have all three of the transactions
    that we created. So, this is how our `createNewTransaction` and `createNewBlock`
    methods work with each other.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在交易数组中，你可以看到我们有我们创建的所有三个交易。这就是我们的`createNewTransaction`和`createNewBlock`方法是如何一起工作的。
- en: If you are having trouble understanding how both of these methods work or how
    they work together, we encourage you to mess around with your `test.js` file and
    create some new blocks, create some new transactions, log some different information
    out, and get a good idea of how these things work.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这两种方法如何工作或它们如何一起工作有困难，我们鼓励你在`test.js`文件中进行一些实验，创建一些新的区块，创建一些新的交易，记录一些不同的信息，并对这些事情如何工作有一个很好的理解。
- en: Hashing the data
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数据进行哈希处理
- en: The next method that we are going to look at and add into our blockchain data
    structure is called `hashBlock`. What this `hashBlock` method will do is take
    in a block from our blockchain and hash its data into a fixed length string. This
    hashed data will appear randomly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的下一个方法并添加到我们的区块链数据结构中的是`hashBlock`。这个`hashBlock`方法将接收我们的区块并将其数据哈希成一个固定长度的字符串。这个哈希数据将会是随机的。
- en: In essence, what we're going to do is pass some blocks of data into this hash
    method, and in return we'll get a fixed-length string, which will simply be a
    hash data that is generated from the data that we passed in or from the block
    that we passed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们将把一些数据块传递到这个哈希方法中，作为返回我们将得到一个固定长度的字符串，这个字符串将简单地是从我们传入的数据或我们传入的区块生成的哈希数据。
- en: 'To add the `hashBlock` method to our blockchain data structure, type the following
    line of code after our `createNewTransaction` method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`hashBlock`方法添加到我们的区块链数据结构中，请在我们的`createNewTransaction`方法之后输入以下代码行：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In our `hashBlock` method, `blockdata` will be the input data of our block from
    which we want to generate the hash.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`hashBlock`方法中，`blockdata`将是我们要生成哈希的区块数据的输入数据。
- en: So, how can we take a block or blocks of data and get a hashed string in return? For
    generating hash data, we're going to use a hashing function called **SHA256**.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何将一个或多个数据块转换为哈希字符串呢？为了生成哈希数据，我们将使用一个名为**SHA256**的哈希函数。
- en: Understanding the SHA256 hashing function
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SHA256哈希函数
- en: The **SHA256** hashing function takes in any string of text, hashes that text,
    and returns a fixed-length hashed string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**SHA256**哈希函数接收任何文本字符串，对该文本进行哈希处理，并返回一个固定长度的哈希字符串。'
- en: To get a better understanding of what hash data looks like, visit [https://passwordsgenerator.net/sha256-hash-generator/](https://passwordsgenerator.net/sha256-hash-generator/).
    This is a hash generator. If you input any text into the text box, you will get
    hash data as the output.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地了解哈希数据的样子，请访问[https://passwordsgenerator.net/sha256-hash-generator/](https://passwordsgenerator.net/sha256-hash-generator/)。这是一个哈希生成器。如果你在文本框中输入任何文本，你将得到哈希数据作为输出。
- en: 'For example, if we put `CodingJavaScript` into the textbox, the hash that is
    returned to us will look like the one highlighted in the following screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将`CodingJavaScript`放入文本框中，返回给我们的哈希看起来像以下截图中突出显示的那样：
- en: '![](img/c0859648-a484-478f-a7e0-75ce71d7340a.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0859648-a484-478f-a7e0-75ce71d7340a.png)'
- en: The output hash that we can observe in the preceding screenshot seems arbitrary,
    and thus helps in keeping the data safe. This is one of the reasons why SHA256
    hashing is so secure.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中我们可以观察到的输出哈希看起来是随意的，因此有助于保持数据的安全。这就是为什么SHA256哈希如此安全的原因之一。
- en: 'Now, if we add another character to our input string or if we change our input
    string in any way, the entire output hash will change completely. For example,
    if we add an exclamation mark at the end of our input string, the output hash
    will entirely change. You can observe that in the following screenshot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在输入字符串中添加另一个字符，或者以任何方式改变我们的输入字符串，整个输出哈希将完全改变。例如，如果我们在输入字符串的末尾添加一个感叹号，输出哈希将完全改变。你可以在以下截图中观察到这一点：
- en: '![](img/35373ad6-ebe7-411b-83cb-56ae2ac854d0.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35373ad6-ebe7-411b-83cb-56ae2ac854d0.png)'
- en: You can try experimenting by adding new characters at the end of the input string.
    You'll observe that as we add more or remove the characters, the entire output
    hash will change drastically every time, thus generating the new random patterns.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试通过在输入字符串的末尾添加新字符来进行实验。你会观察到随着我们添加或删除字符，整个输出哈希每次都会发生巨大的变化，从而生成新的随机模式。
- en: One other thing that you may want to observe related to SHA256 hashing is that
    with any given input, the output will always be the same. For example, for our
    input string, `codingJavaScript!`, you will always get the same hash output that
    was shown in the previous screenshot. This is another very important feature of
    SHA256 hashing. With any given input, the output or the hash that is returned
    from that input will always be the same.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想观察与SHA256哈希相关的另一件事是，对于任何给定的输入，输出将始终相同。例如，对于我们的输入字符串`codingJavaScript!`，你将始终得到与之前截图中显示的相同的哈希输出。这是SHA256哈希的另一个非常重要的特性。对于任何给定的输入，从该输入返回的输出或哈希将始终相同。
- en: So, this is how SHA256 hashing works. In the next section, we'll implement the
    SHA256 hashing function inside of our `hashBlock` method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是SHA256哈希的工作原理。在下一节中，我们将在我们的`hashBlock`方法中实现SHA256哈希函数。
- en: The hashBlock method
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hashBlock方法
- en: 'Let''s build up our `hashBlock` method. Inside of this method, we want to use
    SHA256 hashing to hash our block data. Follow the below mentioned steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的`hashBlock`方法。在这个方法中，我们要使用SHA256哈希来哈希我们的区块数据。按照下面提到的步骤进行：
- en: 'To use an SHA256 hashing function, import it as an npm library. To do that,
    go to Google and type SHA256 into the search bar, or visit [https://www.npmjs.com/package/sha256](https://www.npmjs.com/package/sha256).
    On this website, you will get to see the command that we need to type into our
    terminal to install SHA256\. We''ll have to type in the following command in our
    terminal:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SHA256哈希函数，将其作为npm库导入。要做到这一点，去谷歌搜索栏中输入SHA256，或访问[https://www.npmjs.com/package/sha256](https://www.npmjs.com/package/sha256)。在这个网站上，你将看到我们需要在终端中输入的命令。我们需要在终端中输入以下命令：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: After doing this, press *Enter*. The `--save`  in the following command will
    save this library as a dependency for us. Now, inside of our blockchain file structure,
    you may see that the `node_modules` folder has appeared. Inside of this folder
    is where our SHA256 library and all other dependencies have been downloaded.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，按*Enter*。在以下命令中的`--save`将保存此库作为我们的依赖项。现在，在我们的区块链文件结构中，你可能会看到`node_modules`文件夹已经出现。在这个文件夹中，我们下载了SHA256库和所有其他依赖项。
- en: 'To use this SHA256 library, we will have to import the library to our code
    so that we can use it. At the very start of our code, type the following line:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用这个SHA256库，我们需要将库导入到我们的代码中，这样我们才能使用它。在我们的代码开头，输入以下行：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding line of code specifies that we have an SHA256 hashing function
    stored as the variable SHA256 in the `blockchain.js` file. By importing it, we
    can use that inside of our `hashBlock` method.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行指定了我们在`blockchain.js`文件中存储的SHA256哈希函数，存储为变量SHA256。通过导入它，我们可以在我们的`hashBlock`方法中使用它。
- en: 'Now, the first thing that we want to do in our `hashBlock` method is to change
    the parameters that it takes. We''re going replace the `blockData` parameter with 
    `previousBlockHash`, `currentBlockData`, and `nonce`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的`hashBlock`方法中要做的第一件事是更改它所接受的参数。我们将用`previousBlockHash`、`currentBlockData`和`nonce`替换`blockData`参数：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These three parameters will be the data that we are going to be hashing inside
    of our `hashBlock` method. All of this data will come from a single block in our
    chain and we're going to hash this data, which is essentially hashing a block.
    We are then going to get a hashed string in return.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个参数将是我们在`hashBlock`方法中要进行哈希的数据。所有这些数据将来自我们链中的一个单一区块，我们将对这些数据进行哈希，本质上是对一个区块进行哈希。然后我们将得到一个哈希字符串作为返回。
- en: 'The first thing that we want to do is change all of these pieces of data into
    a single string, so add the following line of code to our `hashBlock` method:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是将所有这些数据转换为单个字符串，因此在我们的`hashBlock`方法中添加以下代码行：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, `previousBlockHash` is already a string. Our nonce is
    a number, so we're going to change that to a string with `toString`. Furthermore,
    our `currentBlockData` is going to be an object, an array of our transactions,
    or some kind of JSON data. It will either be an array or an object, and `JSON.stringify`
    will simply turn that data (as well as any object or array) into a string. Once
    this whole line is run, we will simply have all of the data that we passed to
    be concatenated into a single string.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`previousBlockHash`已经是一个字符串。我们的nonce是一个数字，所以我们将使用`toString`将其更改为字符串。此外，我们的`currentBlockData`将是一个对象，一个包含我们的交易或某种JSON数据的数组。它将是一个数组或一个对象，`JSON.stringify`将简单地将该数据（以及任何对象或数组）转换为字符串。一旦运行了整行代码，我们将简单地将所有传递的数据连接成一个单一的字符串。
- en: 'Now, the next thing that we want to do is create our hash, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们要做的下一件事是创建我们的哈希，如下所示：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is how we create a hash from our block or all of the block data that we
    have passed into our function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从区块或我们传递给函数的所有区块数据中创建哈希的方法。
- en: 'The last thing that we want to do is simply return the hash, so before we complete
    this method, add the following:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事就是简单地返回哈希，因此在完成这个方法之前，添加以下内容：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is how our `hashBlock` method will work. In the following section, we will
    test this method to see if it works perfectly.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`hashBlock`方法将如何工作。在接下来的部分中，我们将测试这个方法，看看它是否完美地工作。
- en: Testing the hashBlock method
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试hashBlock方法
- en: 'Let''s test our `hashBlock` method in the `test.js` file. Similar to what we
    did in the previous sections, in our `test.js` file, we should be importing our
    blockchain data structure, creating a new instance of our blockchain, and naming
    it `bitcoin`. Now, let''s test our `hashBlock` method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`test.js`文件中测试我们的`hashBlock`方法。与我们在之前的部分中所做的类似，在我们的`test.js`文件中，我们应该导入我们的区块链数据结构，创建一个新的区块链实例，并将其命名为`bitcoin`。现在，让我们测试我们的`hashBlock`方法：
- en: 'For that, type in the following highlighted line of code into our `test.js`
    file:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，在我们的`test.js`文件中输入以下突出显示的代码行：
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Our `hashBlock` method requires three parameters:  a `previousBlockHash`, `currentBlockData`,
    and the `nonce`. Let''s define these variables above the part where we''re calling
    our `hashBlock` method. We''ll begin by defining the `previousBlockHash`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`hashBlock`方法需要三个参数：`previousBlockHash`、`currentBlockData`和`nonce`。让我们在调用`hashBlock`方法的部分之前定义这些变量。我们将从定义`previousBlockHash`开始：
- en: '[PRE54]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For now, this random string/hash data will act as input for our `previousBlockHash`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个随机字符串/哈希数据将作为我们的`previousBlockHash`的输入。
- en: 'Next, we create the `currentBlockData` variable. This `currentBlockData` will
    simply be an array of all of the transactions that will be present in this block.
    We''re simply going to use the transactions in this block as our `currentBlockData`,
    so in this array, we will have to make a couple of transaction objects, as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`currentBlockData`变量。这个`currentBlockData`将简单地是一个包含在这个区块中的所有交易的数组。我们将简单地使用这个区块中的交易作为我们的`currentBlockData`，所以在这个数组中，我们将不得不创建一些交易对象，如下所示：
- en: '[PRE55]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Next, duplicate this transaction object at least three times to make a couple
    more transaction objects in the array and then make modifications to the data
    as you wish, aiming to change the amount and the sender's and recipient's addresses.
    This will make our `currentBlockData` an array that holds three transactions.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，至少复制这个交易对象三次，以在数组中创建更多的交易对象，然后根据需要对数据进行修改，目的是改变金额和寄件人和收件人的地址。这将使我们的`currentBlockData`成为一个包含三个交易的数组。
- en: 'Finally, we have to assign the `nonce` value in our `hashBlock` method:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须在我们的`hashBlock`方法中分配`nonce`值：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After defining these variables, we call the `hashBlock` method and pass the
    `previousBlockHash` and `currentBlockData` parameters, as well as the `nonce`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义了这些变量之后，我们调用`hashBlock`方法，并传递`previousBlockHash`和`currentBlockData`参数，以及`nonce`：
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Furthermore, let''s try to push the results onto the terminal window so that
    we can observe it. To do this, we''ll have to make a tiny modification to our
    preceding code:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，让我们尝试将结果推送到终端窗口，以便我们可以观察它。为了做到这一点，我们将不得不对我们之前的代码进行一些微小的修改：
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this test case, we are calling our `hashBlock` method with all of the correct
    parameters. When we run this file, we should get to observe the hash on the terminal
    window.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试案例中，我们使用所有正确的参数调用我们的`hashBlock`方法。当我们运行这个文件时，我们应该能够在终端窗口观察到哈希值。
- en: Now save this `test.js` file and run it to check whether or not we get the output
    that we expect it to be.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存这个`test.js`文件并运行它，检查我们是否得到了我们期望的输出。
- en: 'Go to your terminal window and type in the `node dev/test.js` command, and
    let''s observe what results we get. You will get to observe the similar resulting
    hash as output of our `hashBlock` method as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的终端窗口，输入`node dev/test.js`命令，让我们观察一下结果。你将能够观察到与我们的`hashBlock`方法输出相似的结果哈希值。
- en: '![](img/34c4b7d1-ad74-482c-b25e-d190cf2d079e.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34c4b7d1-ad74-482c-b25e-d190cf2d079e.png)'
- en: It looks like our `hashBlock` method is working pretty well.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的`hashBlock`方法工作得相当好。
- en: Try to explore this `hashBlock` method a little more. As explained in the previous
    section, if we change some of the data that we are passing into the `hashBlock`
    method, it will result in completely changing the hash that we returned as output.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试更仔细地探索一下`hashBlock`方法。正如前一节所解释的，如果我们改变传递给`hashBlock`方法的一些数据，将会完全改变我们返回的哈希值。
- en: 'Now try to test this feature of hashing data by changing a letter in any of
    the sender''s or recipient''s address. Then save the file and run it by using
    `node dev/test.js` again. You will get to observe a totally different hash data
    as output, as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试通过更改寄件人或收件人地址中的一个字母来测试数据哈希的这个特性。然后保存文件，并再次使用`node dev/test.js`运行它。你将观察到一个完全不同的哈希数据作为输出，如下所示：
- en: '![](img/6b78757c-e711-4dce-93a8-0aa93d024e7f.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b78757c-e711-4dce-93a8-0aa93d024e7f.png)'
- en: In the preceding screenshot, you can observe both the hash data and the differences
    between them.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以观察到哈希数据和它们之间的差异。
- en: Now, if we revert the change that we made to the sender's or recipient's address
    and run our hash method again, we'll get to observe the same hash that we originally
    got. This is because we're passing in the same data that we did the first time
    around. You can try experimenting with the data and try observing the output to
    explore the `hashBlock` method further.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们撤销了对寄件人或收件人地址所做的更改，并再次运行我们的哈希方法，我们将能够观察到与我们最初得到的相同的哈希值。这是因为我们传递的数据与第一次相同。你可以尝试尝试改变数据并观察输出，以进一步探索`hashBlock`方法。
- en: After this test, we can thus conclude that our `hashBlock` method works perfectly.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这个测试，我们可以得出结论，我们的`hashBlock`方法完美地工作。
- en: What is a Proof of Work?
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是工作证明？
- en: The next method that we are going to add to our blockchain data structure is
    the `proofOfWork` method. This method is very important and essential to the blockchain
    technology. It is because of this method that Bitcoin and many other blockchains
    are so secure.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要添加到我们的区块链数据结构中的方法是`proofOfWork`方法。这个方法对于区块链技术非常重要和必要。正是因为这个方法，比特币和许多其他区块链才如此安全。
- en: Now, you must be getting curious about what a **Proof of Work** (**PoW**) actually is. Well,
    if we take a look at our blockchain, every blockchain is pretty much a list of
    blocks. Every single block has to be created and added to the chain. However,
    we don't just want any block to be created and added to the chain. We want to
    make sure that every block that is added to the chain is legitimate, has the correct transactions,
    and has the correct data inside of it. This is because if it doesn't have the
    correct transactions or the correct data, then people could fake how much Bitcoin
    they have and essentially cause fraud and steal money from other people. So, every
    time a new block is created, we first have to make sure that it is a legitimate
    block by mining it through PoW.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你一定对**工作量证明**（PoW）是什么感到好奇。如果我们看一下我们的区块链，每个区块链基本上都是一个区块列表。每个区块都必须被创建并添加到链中。然而，我们不希望随便创建并添加任何区块到链中。我们希望确保每个添加到链中的区块都是合法的，具有正确的交易和正确的数据。这是因为如果它没有正确的交易或正确的数据，那么人们可能会伪造自己拥有多少比特币，并从其他人那里窃取钱财。因此，每次创建新的区块时，我们首先必须通过PoW来确保它是一个合法的区块。
- en: A `proofOfWork` method will take in the `currentBlockData` and the `previousBlockHash`.
    From this data that we supply, the `proofOfWork` method will try to generate a
    specific hash. This specific hash in our example is going to be a hash that starts
    with four zeros. So, with the given `currentBlockData` and the `previousBlockHash`,
    the method will somehow generate a resulting hash that begins with four zeros.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`proofOfWork`方法将接收`currentBlockData`和`previousBlockHash`。从我们提供的数据中，`proofOfWork`方法将尝试生成一个特定的哈希。在我们的示例中，这个特定的哈希将以四个零开头。因此，通过给定的`currentBlockData`和`previousBlockHash`，该方法将以某种方式生成一个以四个零开头的结果哈希。'
- en: Now let's try to understand how we can do this. As we learned in the previous
    sections, the hash that is generated from SHA256 is pretty much random. So, if
    the resulting hash is pretty much random, then how can we generate a hash from
    our current block that starts with four zeros? The only way this can be done is
    by trial and error, or by guessing and checking. So, what we will have to do is
    run our `hashBlock` method many times until we end up getting lucky one time by
    generating a hash that has four zeros at the beginning.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试着理解我们如何做到这一点。正如我们在前面的部分中学到的，从SHA256生成的哈希基本上是随机的。因此，如果得到的哈希基本上是随机的，那么我们如何从我们当前的区块生成一个以四个零开头的哈希呢？唯一的方法是通过反复试错或猜测和检查。因此，我们将不得不多次运行我们的`hashBlock`方法，直到最终有一次幸运地生成一个以四个零开头的哈希。
- en: Now, you might be wondering that the input to our `hashBlock` method are the `previousBlockHash`,
    `currentBlockData`, and `nonce` parameters. How will these three parameters that
    have been passed in once and possibly generate multiple different hashes, when,
    in actual fact, we're always passing exactly the same data? Furthermore, as we
    know from the previous section that whenever we pass in a specific piece of data,
    we are always going to get the same resulting hash generated from that data.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想到我们的`hashBlock`方法的输入是`previousBlockHash`、`currentBlockData`和`nonce`参数。当实际上，我们总是传递完全相同的数据时，这三个参数可能会生成多个不同的哈希，这个问题会让你感到困惑。此外，正如我们从上一节中所知，每当我们传入特定的数据时，我们总是会得到从该数据生成的相同的结果哈希。
- en: So, how can we alter this data in a way that does not change our `currentBlockData`
    or the `previousBlockHash`, but we still get a resulting hash that has four zeros
    at the beginning of it?  The answer to this question is that we are going to constantly
    change the nonce value.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何改变这些数据，而不改变我们的`currentBlockData`或`previousBlockHash`，但我们仍然可以得到一个以四个零开头的结果哈希呢？这个问题的答案是，我们将不断改变nonce值。
- en: This might all seem a bit confusing right now, so let's try to clarify it by
    knowing what actually happens in a `proofOfWork` by breaking it down a little
    bit.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这一切可能看起来有点混乱，所以让我们试着通过对`proofOfWork`中实际发生的事情进行一些分解来澄清一下。
- en: Essentially, what is happening in our `proofOfWork` is that we're going to repeatedly
    hash our block until we find the correct hash, which will be any hash that starts
    with four zeros. We'll be changing the input to our `hashBlock` method by constantly
    incrementing the nonce value. The first time that we run our `hashBlock` method,
    we are going to start with a nonce value of 0. Then, if that resulting hash does
    not have four zeros at the beginning of it, we are going to run our `hashBlock`
    method again, except this time we are going to increment our nonce value by 1\.
    If we do not get the correct hash value again, we're going to increment the nonce
    value and try it again. If that doesn't work, we'll again increment the nonce
    value and try again. Then we'll continually run this `hashBlock` method until
    we find a hash that begins with four zeros. That is how our `proofOfWork` method
    will function.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们的`proofOfWork`中正在发生的事情是，我们将反复对我们的区块进行哈希，直到找到正确的哈希，这个哈希可以是以四个零开头的任何哈希。我们将通过不断增加nonce值来改变我们的`hashBlock`方法的输入。第一次运行我们的`hashBlock`方法时，我们将从0开始nonce值。然后，如果得到的结果哈希不以四个零开头，我们将再次运行我们的`hashBlock`方法，只是这一次我们将nonce值增加1。如果我们再次没有得到正确的哈希值，我们将增加nonce值并再次尝试。如果这样不起作用，我们将再次增加nonce值并再次尝试。然后我们将不断运行这个`hashBlock`方法，直到找到一个以四个零开头的哈希。这就是我们的`proofOfWork`方法的功能。
- en: You might be wondering how this `proofOfWork` method actually secures the blockchain.
    The reason for this is because in order to generate the correct hash, we're going
    to have to run our `hashBlock` method many times, and this is going to use up
    a lot of energy and computing power.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这个`proofOfWork`方法是如何确保区块链安全的。原因是为了生成正确的哈希，我们将不得不多次运行我们的`hashBlock`方法，这将消耗大量的能量和计算能力。
- en: So, if somebody wanted to go back into the blockchain and try to change a block
    or the data in that block – perhaps to give themselves more Bitcoin – they would
    have to do a ton of calculations and use a lot of energy to create the correct
    hash. In most cases, going back and trying to recreate an already existing block
    or trying to re-mine an already existing block with your own fake data is not
    feasible. On top of that, not only does our `hashBlock` method take in the `currentBlockData`,
    it also takes in the previous `BlockHash`. This means that all of the blocks in
    the blockchain are linked together by their data.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果有人想要回到区块链并尝试更改一个区块或该区块中的数据 - 也许是为了获得更多的比特币 - 他们将不得不进行大量的计算并使用大量的能量来创建正确的哈希。在大多数情况下，回头尝试重新创建已经存在的区块或尝试用自己的虚假数据重新挖掘已经存在的区块是不可行的。除此之外，我们的`hashBlock`方法不仅接受`currentBlockData`，还接受前一个`BlockHash`。这意味着区块链中的所有区块都通过它们的数据链接在一起。
- en: If somebody tries to go back and re-mine or recreate a block that already exists,
    they would also have to re-mine and recreate every single block that comes after
    the first one that they recreated. This would take an incredible amount of calculation
    and energy, and is just not feasible for a well-developed blockchain. A person
    would have to go in, recreate a block by using a proof of work, and then recreate
    every block after that by doing a new proof of work for each block. This is just
    not feasible for any well-produced blockchain, and this is the reason why blockchain
    technology is so secure.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人试图回去重新挖掘或重新创建已经存在的区块，他们还必须重新挖掘和重新创建每一个在他们重新创建的第一个区块之后的每一个区块。这将需要大量的计算和能量，对于一个成熟的区块链来说是不可行的。一个人必须进去，通过工作证明重新创建一个区块，然后通过为每个区块进行新的工作证明来重新创建每个区块。这对于任何一个成熟的区块链来说都是不可行的，这就是为什么区块链技术如此安全的原因。
- en: To summarize this section, what our `proofOfWork` method will basically do is
    repeatedly hash our `previousBlockHash`, our `currentBlockData`, and a nonce until
    we get an acceptable generated hash that starts with four zeros.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们的`proofOfWork`方法基本上会重复哈希我们的`previousBlockHash`，`currentBlockData`和一个nonce，直到我们得到一个以四个零开头的可接受的生成的哈希。
- en: This might all seem overwhelming and a little bit confusing right now, but don't
    worry – we are going to build the `proofOfWork` method in the following section,
    and then we're going to test it with many different types of data. This will help
    you to become much more familiar with how the `proofOfWork` method functions and
    how it is securing the blockchain.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切可能看起来很压抑，现在可能有点混乱，但不用担心 - 我们将在接下来的部分构建`proofOfWork`方法，然后我们将用许多不同类型的数据进行测试。这将帮助您更加熟悉`proofOfWork`方法的功能以及它如何保护区块链。
- en: Creating the proofOfWork method
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`proofOfWork`方法
- en: 'Let''s build out the `proofOfWork` method, which we discussed in the preceding
    section:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们在前一节中讨论过的`proofOfWork`方法：
- en: 'After the `hashBlock` method, define the `proofOfWork` method as follows:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`hashBlock`方法之后，定义`proofOfWork`方法如下：
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This method takes in two parameters: `previousBlockHash` and `currentBlockData`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法接受两个参数：`previousBlockHash`和`currentBlockData`：
- en: '[PRE60]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The first thing that we want to do inside of our method is define a nonce:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的方法内部，我们要做的第一件事是定义一个nonce：
- en: '[PRE61]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we want to hash all of our data for the first time, so type in the following
    highlighted line of code:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要对我们的所有数据进行第一次哈希，所以输入以下突出显示的代码行：
- en: '[PRE62]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding code, you may notice that we used the term `let` because both
    our nonce and hash will be changing as we move through the method.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可能会注意到我们使用了`let`这个术语，因为我们的nonce和hash都会随着我们在方法中的移动而改变。
- en: 'The next step that we want to do is constantly run the `hashBlock` method over
    and over again until we get a hash that starts with four zeros. We''re going to
    do this repeated operation with the help of a `while` loop:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来要做的是不断运行`hashBlock`方法，直到我们得到以四个零开头的哈希。我们将通过`while`循环来重复执行这个操作：
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If the hash that we created does not start with four zeros, we''ll want to
    run our hash again, except this time with the different value of nonce. Consequently,
    inside of the `while` loop, add the following highlighted lines of code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们创建的哈希值不以四个零开头，我们将希望再次运行我们的哈希，只不过这次使用不同的nonce值。因此，在`while`循环内，添加以下突出显示的代码行：
- en: '[PRE64]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Inside of the `while` loop, we are running our `hashBlock` method again with
    all the same data, except this time our nonce is incremented and equal to 1 instead
    of 0\. This will be the first iteration of our while loop. Now, after the first
    iteration, the new hash that is generated doesn't have the first four characters
    equal to 0000\. In this case, we'll want to generate a new hash. So, our while
    loop will run again, the nonce value will be incremented to 2 and a new hash will
    be created. If that hash also does not start with four zeros then the `while`
    loop will run again, the nonce value will be incremented again, and the hash will
    be generated again.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环内，我们再次运行我们的`hashBlock`方法，使用完全相同的数据，只是这次我们的nonce增加并且等于1而不是0。这将是我们的while循环的第一次迭代。现在，在第一次迭代之后，生成的新哈希不具有前四个字符等于0000的特性。在这种情况下，我们将希望生成一个新的哈希。因此，我们的while循环将再次运行，nonce值将再次增加到2，并且将生成一个新的哈希。如果该哈希也不以四个零开头，那么`while`循环将再次运行，nonce值将再次增加，并且将再次生成哈希。
- en: Our loop will continue doing this until it winds up with a hash that starts
    with four zeros. This might take many iterations. This could happen 10 times,
    10,000 times, or 100,000 times.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的循环将继续这样做，直到得到以四个零开头的哈希。这可能需要很多次迭代。这可能发生10次，10,000次或100,000次。
- en: 'This loop is where all of the calculations will take place, and this is the
    reason why the `proofOfWork` method uses so much energy – there are a lot of calculations
    being made. We''ll continue going through the `while` loop until we generate a
    suitable hash that starts with four zeros. When we finally have the correct hash,
    our `while` loop will stop running, and at the end of our proofOfWork, it will
    simply return the nonce value that gave us the valid hash:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环是所有计算将发生的地方，这就是为什么`proofOfWork`方法会消耗如此多的能量——有很多计算在进行。我们将继续通过`while`循环，直到生成一个以四个零开头的合适的哈希。当我们最终得到正确的哈希时，我们的`while`循环将停止运行，在`proofOfWork`结束时，它将简单地返回给我们提供有效哈希的nonce值：
- en: '[PRE65]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: So, this is how our `proofOfWork` method will work and validate the hash.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是我们的`proofOfWork`方法是如何工作和验证哈希的。
- en: In the following section, we'll test our `proofOfWork` method to make sure that
    it works properly. We'll also study why we return a nonce value instead of returning
    the hash.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将测试我们的`proofOfWork`方法，确保它能正常工作。我们还将研究为什么我们返回一个nonce值而不是返回哈希。
- en: Testing the proofOfWork method
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试`proofOfWork`方法
- en: 'Let''s test our `proofOfWork` method to make sure that it works properly. We''ll
    be testing the method in our `test.js` file. So, let''s get started:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下我们的`proofOfWork`方法，确保它能正常工作。我们将在`test.js`文件中测试这个方法。所以，让我们开始吧：
- en: 'Open up the `test.js` file. You might observe the data in a similar way to
    the following screenshot, which is present in the file from the previous section, *Testing
    the hashBlock method*:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`test.js`文件。你可能会观察到数据与前一节文件中的以下截图类似，*测试hashBlock方法*：
- en: '*![](img/bba3d0e1-4701-4b4d-9edc-4dab25d74b65.png)*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](img/bba3d0e1-4701-4b4d-9edc-4dab25d74b65.png)*'
- en: If you don't have any data in the `test.js` file, add this to your `test.js`
    file, as shown in the preceding screenshot, and then you can begin testing the
    data.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的`test.js`文件中没有任何数据，就像在上面的截图中显示的那样添加到你的`test.js`文件中，然后你就可以开始测试数据了。
- en: 'To test our `proofOfWork` method, we need the `previousBlockHash` and `currentBlockData`.
    So, in our test case, get rid of the nonce value and add the following lines of
    code to our file:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的`proofOfWork`方法，我们需要`previousBlockHash`和`currentBlockData`。所以，在我们的测试用例中，去掉nonce值，并在我们的文件中添加以下代码行：
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now, what we should get as a result from this `proofOfWork` method is a nonce
    value. What our `proofOfWork` method essentially does is test to see what the
    correct nonce value is to hash with our block data and our `previousBlockHash`
    to generate a resulting block hash that starts with four zeros. Here, `proofOfWork` finds
    the correct nonce for us.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们从`proofOfWork`方法中应该得到的结果是一个nonce值。我们的`proofOfWork`方法本质上是测试看看什么是与我们的块数据和`previousBlockHash`一起哈希的正确nonce值，以生成一个以四个零开头的结果块哈希。在这里，`proofOfWork`为我们找到了正确的nonce。
- en: 'Save this file and run our test by typing the `node dev/test.js` command in
    our terminal window. After the test is run, you will observe that a number pops
    up as an output on the screen:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存这个文件，并在终端窗口中输入`node dev/test.js`命令来运行我们的测试。测试运行后，你会看到一个数字作为输出出现在屏幕上：
- en: '![](img/4890a799-e9e5-4e2f-9b82-52ea58c75933.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4890a799-e9e5-4e2f-9b82-52ea58c75933.png)'
- en: What this number signifies is that it took 27,470 iterations for our `proofOfWork`
    method to find a hash that starts with four zeros.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字表示的是，我们的`proofOfWork`方法花了27,470次迭代来找到一个以四个零开头的哈希。
- en: 'Now, to understand this whole process in-depth, what we can do is, inside of
    our `while` loop, log out of every hash that we try. We will have to make minor
    modifications to our `while` loop, as highlighted in the following code block:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了深入了解整个过程，我们可以在`while`循环中记录我们尝试的每个哈希值。我们将不得不对我们的`while`循环进行一些微小的修改，就像下面的代码块中突出显示的那样：
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: When we run our test file now, what's going to happen is we should actually
    get to see 27,000 different hashes logged out inside of our terminal. None of
    these hashes will start with four zeros, except for the last one. Only the last
    hash that gets logged out should start with four zeros because after our method,
    this will terminate and return the nonce value for which the valid hash was obtained.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行我们的测试文件时，会发生的是我们应该能够在终端中看到27,000个不同的哈希值被记录出来。除了最后一个之外，这些哈希值都不会以四个零开头。只有最后一个被记录出来的哈希值应该以四个零开头，因为在我们的方法之后，这将终止并返回获得有效哈希值的nonce值。
- en: 'Now let''s save our `test.js` file again. You can now observe on your screen
    that we have a whole bunch of different hashes being logged out to the terminal:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次保存我们的`test.js`文件。你现在可以在屏幕上观察到有大量不同的哈希值被记录到终端中：
- en: '![](img/0b29a624-1279-4b4b-b0a9-d0c8be618fc4.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b29a624-1279-4b4b-b0a9-d0c8be618fc4.png)'
- en: You can also observe that for every single hash that has been logged out, the
    beginning is never four zeros in a row until we obtain our final value.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以观察到，每个被记录出来的哈希值的开头都不会连续出现四个零，直到我们得到最终值。
- en: Basically, what is happening over here is that we are generating the hash from
    our `currentBlockData`, `previousBlockHash`, and `nonce` of value 0\. Then, for
    the next hash, we are incrementing the nonce by 1. So, it's all the same input
    data, but the nonce value is incremented until the valid hash is obtained. Finally,
    at 27,470, with the value of a nonce, the valid hash is obtained.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这里发生的是我们从`currentBlockData`、`previousBlockHash`和值为0的`nonce`生成哈希。然后，对于下一个哈希，我们将`nonce`递增1。所以，输入数据都是一样的，但是`nonce`值会递增，直到获得有效的哈希。最终，在27,470次迭代中，通过nonce值获得了有效的哈希。
- en: 'Now let''s try using our `hashBlock` method. In our `dev/test.js` file, delete
    the `proofOfWork` method and add the following line of code:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用我们的`hashBlock`方法。在我们的`dev/test.js`文件中，删除`proofOfWork`方法，并添加以下代码行：
- en: '[PRE68]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the preceding code, for the nonce let's input the value 27,470\. This value
    we obtained from our `proofOfWork` method.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，对于nonce，让我们输入值27,470。这个值是我们从`proofOfWork`方法中获得的。
- en: 'What we would observe as output is running the single hash with the correct
    nonce value that we obtained by running the `proofOfWork` method. By doing this,
    we should generate a hash that starts with four zeros on the first try. Let''s
    save it and run it. Once the test is run, you will get to observe the single hash
    that starts with four zeros, as shown in the following screenshot:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到的输出是使用正确的nonce值运行单个哈希，我们通过运行`proofOfWork`方法获得。通过这样做，我们应该在第一次尝试时生成一个以四个零开头的哈希。让我们保存并运行它。一旦测试运行，您将看到以四个零开头的单个哈希，如下面的截图所示：
- en: '![](img/cd81285c-c159-4a11-a439-8c12ae5f37ea.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd81285c-c159-4a11-a439-8c12ae5f37ea.png)'
- en: The `proofOfWork` is a very important part of blockchain technology. It is very
    difficult to calculate, as you can observe from the test results – it took us
    more than 27,000 iterations to generate the correct hash. Consequently, a `proofOfWork`
    takes in a lot of energy and many calculations, and is very difficult to calculate.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`proofOfWork`是区块链技术的一个非常重要的部分。从测试结果中可以看出，计算它非常困难 - 我们花了超过27,000次迭代才生成正确的哈希。因此，`proofOfWork`需要大量的能量和许多计算，非常难以计算。'
- en: Once we have the correct proof or the nonce value at which the desired hash
    is generated, it should be very easy for us to verify that we have the correct
    nonce value. We can verify this by simply passing it into our `hashBlock` method –
    we would obtain the hash that starts with four zeros.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了正确的证明或生成所需哈希的nonce值，我们应该很容易验证我们是否有了正确的nonce值。我们可以通过简单地将其传递到我们的`hashBlock`方法中来验证这一点
    - 我们将获得以四个零开头的哈希。
- en: It takes a lot of work to generate a proof of work, but it is very easy to verify
    that it is correct. So, if we ever want to go back into our blockchain and check
    to make sure that a block is valid, all you have to do is hash that block's data
    with the previous block's hash and the nonce that was generated from the `proofOfWork`
    when that block was mined. If this returns a valid hash to us that starts with
    four zeros, then we already know that the block is valid.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 生成工作证明需要大量工作，但验证其正确性非常容易。因此，如果我们想要回到我们的区块链并检查一个块是否有效，我们只需对该块的数据与前一个块的哈希和从`proofOfWork`挖掘该块时生成的nonce进行哈希。如果这给我们返回一个以四个零开头的有效哈希，那么我们已经知道该块是有效的。
- en: Thus, from our test, we can conclude that the `proofOfWork` method works as
    expected.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从我们的测试中，我们可以得出结论，`proofOfWork`方法的工作符合预期。
- en: Creating a genesis block
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建创世区块
- en: One more thing that we would have to add to our blockchain data structure is
    the genesis block. But what is a genesis block? Well, a genesis block is simply
    the first block in any blockchain.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的区块链数据结构中还需要添加的一件事是创世块。但是什么是创世块？嗯，创世块只是任何区块链中的第一个块。
- en: 'To create our genesis block, we are going to use the `createNewBlock` method
    inside of the `Blockchain()` constructor function. Go to the `dev/blockchain.js`
    file, and inside of the blockchain constructor function type in the following
    highlighted lines of code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的创世区块，我们将在`Blockchain()`构造函数内部使用`createNewBlock`方法。转到`dev/blockchain.js`文件，并在区块链构造函数内部输入以下突出显示的代码行：
- en: '[PRE69]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As we observed in the previous section, the `createNewBlock` method takes in
    the value of a nonce, a `previousBlockHash`, and a hash as parameters. Since we''re
    using the `createNewBlock` method over here to create the genesis block, we are
    not going to have any of those mentioned parameters. Instead, we''re simply going
    to pass in some arbitrary parameters, as highlighted in the following code block:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中观察到的，`createNewBlock`方法接受nonce的值，`previousBlockHash`和哈希作为参数。由于我们在这里使用`createNewBlock`方法创建创世区块，我们将不会有这些提到的参数。相反，我们只会传入一些任意的参数，如以下代码块中所示：
- en: '[PRE70]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding code, we passed the nonce value as `100`, `previousBlockHash`
    as `0`, and the hash value as `0`. These are all just arbitrary values; you can
    add whatever value you wish to add.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们将nonce值传递为`100`，`previousBlockHash`为`0`，哈希值为`0`。这些都只是任意值；您可以添加任何您希望添加的值。
- en: Just be aware that it is okay to pass in such arbitrary parameters while creating
    our genesis block, but when we use the `createNewBlock` method to create new blocks,
    we'll have to pass the legitimate values for the parameters.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在创建我们的创世区块时传入这种任意参数是可以的，但是当我们使用`createNewBlock`方法创建新的区块时，我们将不得不传递参数的合法值。
- en: Now save the file, and let's test the genesis block in the `test.js` file.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存文件，让我们在`test.js`文件中测试创世区块。
- en: Testing the genesis block
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试创世区块
- en: 'In the `dev/test.js` file, we will begin by importing our blockchain data structure
    or Blockchain constructor function, and then making a new instance of our blockchain
    as `bitcoin`. We''re then going to log out of the bitcoin blockchain as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dev/test.js`文件中，我们将首先导入我们的区块链数据结构或区块链构造函数，然后将我们的区块链实例化为`bitcoin`。然后我们将以以下方式退出比特币区块链：
- en: '[PRE71]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Save this file and run the test by typing `node dev/test.js` into the terminal.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件，并在终端中键入`node dev/test.js`来运行测试。
- en: 'After running the test, we can observe the genesis block, as shown in the following
    screenshot:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，我们可以观察到创世区块，如下面的截图所示：
- en: '![](img/90baad26-9808-4f2d-b0b3-d502b17bcc25.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90baad26-9808-4f2d-b0b3-d502b17bcc25.png)'
- en: In the preceding screenshot, for the chain array, you can see that we have one
    block inside of the chain. This block is our genesis block and it has a nonce
    of 100, a hash of 0, and a `previousBlockHash` of `0`. Henceforth, all of our
    blockchains will have a genesis block.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，对于链数组，您可以看到我们的链中有一个块。这个块是我们的创世块，它的nonce为100，哈希为0，`previousBlockHash`为`0`。因此，我们所有的区块链都将有一个创世块。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we began by building the constructor function and then moved 
    on to create some amazing methods such as `createNewBlock`, `creatNewTransaction`,
    `getLastBlock`, and so on. We then learned about the hashing method, SHA256 hashing,
    and created a method to generate a hash for our block data. We also learned what
    a proof of work is and how this works. In this chapter, you also got to learn
    how to test the various methods that we created and check whether they are working
    as expected. The methods that we have learned about in this chapter will be very
    useful for us in further chapters when we interact more with the blockchain.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先构建了构造函数，然后继续创建了一些令人惊奇的方法，比如`createNewBlock`、`creatNewTransaction`、`getLastBlock`等。然后我们学习了哈希方法，SHA256哈希，并创建了一个为我们的区块数据生成哈希的方法。我们还学习了什么是工作量证明以及它是如何工作的。在本章中，您还学会了如何测试我们创建的各种方法，并检查它们是否按预期工作。在以后的章节中，我们将更多地与区块链进行交互，本章学到的方法将对我们非常有用。
- en: If you want to get more familiar with the blockchain data structure, it is recommended
    that you open up the `test.js` file, test all of the methods, try to play around
    with those, observe how they work together, and have fun with it.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更加熟悉区块链数据结构，建议您打开`test.js`文件，测试所有方法，尝试玩弄它们，观察它们如何一起工作，并且享受其中的乐趣。
- en: In the next chapter, we'll be building an API to interact with and use our blockchain.
    That's where the real fun begins.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个API来与我们的区块链进行交互和使用。那将是真正有趣的开始。
