- en: Dynamic Client/Server Interaction with Socket.IO
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Socket.IO进行动态客户端/服务器交互
- en: 'The original design model of the web is similar to the way that mainframes worked
    in the 1970s. Both old-school dumb terminals, such as the IBM 3270, and web browsers
    follow a request-response paradigm. The user sends a request and the far-off computer
    sends a response. That request-response paradigm is evident in the Node.js HTTP
    Server API, as shown in the following code:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web的原始设计模型类似于20世纪70年代主机的工作方式。旧式的哑终端，如IBM 3270，和Web浏览器都遵循请求-响应范式。用户发送请求，远程计算机发送响应。这种请求-响应范式在Node.js
    HTTP服务器API中是明显的，如下面的代码所示：
- en: '[PRE0]js\1'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]js\1'
- en: We will incorporate user authentication with the `passport` module, used in
    [Chapter 8](1ef2de06-5b7d-44c8-a132-55f822d113cf.xhtml), *Authenticating Users
    with a Microservice*, into some of the real-time interactions we'll implement.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一些实时交互中结合使用`passport`模块进行用户身份验证，该模块在[第8章](1ef2de06-5b7d-44c8-a132-55f822d113cf.xhtml)
    *使用微服务对用户进行身份验证*中使用。
- en: 'At the beginning of `app.mjs`, add this to the `import` statements:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.mjs`的开头，将此添加到`import`语句中：
- en: '[PRE1]js\1'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]js\1'
- en: What this does is create a couple of global scope variables to hold objects
    related to the session configuration. We had been using these values as constants
    when setting up the Express session support. We now need to share those values
    with both the Socket.IO and the Express session managers. When we initialize both Express
    and Socket.IO session handlers, there is an initialization object taking initialization
    parameters. In each, we will pass in the same values for the `secret` and `sessionStore` fields,
    to ensure they are in agreement.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的是创建一对全局范围的变量来保存与会话配置相关的对象。在设置Express会话支持时，我们一直在使用这些值作为常量。现在我们需要将这些值与Socket.IO和Express会话管理器共享。当我们初始化Express和Socket.IO会话处理程序时，有一个初始化对象接受初始化参数。在每个对象中，我们将传入相同的值作为`secret`和`sessionStore`字段，以确保它们保持一致。
- en: 'The next change is moving some code related to setting up the server object
    from the bottom of `app.mjs` closer to the top, as shown here:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个更改是将与设置服务器对象相关的一些代码从`app.mjs`的底部移到靠近顶部，如下所示：
- en: '[PRE2]js\1'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]js\1'
- en: This is the same configuration of Express session support that we added in [Chapter
    8](1ef2de06-5b7d-44c8-a132-55f822d113cf.xhtml), *Authenticating Users with a Microservice*,
    but modified to use the configuration variables we set up earlier. Done this way,
    both Express and Socket.IO session handling is managed from the same set of information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[第8章](1ef2de06-5b7d-44c8-a132-55f822d113cf.xhtml) *使用微服务对用户进行身份验证*中添加的Express会话支持的配置相同，但修改为使用我们之前设置的配置变量。这样做，Express和Socket.IO会话处理都是从相同的信息集中管理的。
- en: We have accomplished the basic setup of Socket.IO in our Express application.
    First, we connected the Socket.IO library to the HTTP Server so that it can handle
    requests on the Socket.IO service. Then we integrated it with Passport session
    management.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了在Express应用程序中设置Socket.IO的基本设置。首先，我们将Socket.IO库连接到HTTP服务器，以便它可以处理Socket.IO服务的请求。然后我们将其与Passport会话管理集成。
- en: Let's now learn how we can use Socket.IO to add real-time updating in Notes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们学习如何使用Socket.IO在Notes中添加实时更新。
- en: Real-time updates on the Notes homepage
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Notes主页的实时更新
- en: The goal we're working toward is for the Notes home page to automatically update
    the list of notes as notes are edited or deleted. What we've done so far is to
    restructure the application startup so that Socket.IO is initialized in the Notes
    application. There's no change of behavior yet.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在努力实现的目标是，当笔记被编辑、删除或创建时，Notes主页会自动更新笔记列表。到目前为止，我们已经重构了应用程序启动，以便在Notes应用程序中初始化Socket.IO。但是行为还没有改变。
- en: What we will do is send an event whenever a note is created, updated, or deleted.
    Any interested part of the Notes application can listen to those events and act
    appropriately. For example, the Notes home page router module can listen for events,
    and then send an update to the browser. The code in the web browser will listen
    for an event from the server, and in response, it would rewrite the home page.
    Likewise, when a Note is modified, a listener can send a message to the web browser
    with the new note content, or if the Note is deleted, a listener can send a message
    so that the web browser redirects to the home page.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在创建、更新或删除笔记时发送事件。Notes应用程序的任何感兴趣的部分都可以监听这些事件并做出适当的反应。例如，Notes主页路由模块可以监听事件，然后向浏览器发送更新。Web浏览器中的代码将监听来自服务器的事件，并在响应时重新编写主页。同样，当笔记被修改时，监听器可以向Web浏览器发送包含新笔记内容的消息，或者如果笔记被删除，监听器可以发送消息，以便Web浏览器重定向到主页。
- en: 'These changes are required:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改是必需的：
- en: Refactoring the Notes Store implementations to send create, update, and delete
    events
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构Notes Store实现以发送创建、更新和删除事件
- en: Refactoring the templates to support both Bootstrap on every page and a custom
    Socket.IO client for each page
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构模板以支持每个页面上的Bootstrap和自定义Socket.IO客户端
- en: Refactoring the home page and Notes' viewing router modules to listen for Socket.IO
    events and send updates to the browser
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构主页和笔记查看路由模块，以侦听Socket.IO事件并向浏览器发送更新
- en: We'll handle this over the next few sections, so let's get started.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几节中处理这个问题，所以让我们开始吧。
- en: Refactoring the NotesStore classes to emit events
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构NotesStore类以发出事件
- en: In order to automatically update the user interface when a Note is changed or
    deleted or created, the `NotesStore` must send events to notify interested parties
    of those changes. We will employ our old friend, the `EventEmitter` class, to
    manage the listeners to the events we must send.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在笔记更改、删除或创建时自动更新用户界面，`NotesStore`必须发送事件以通知感兴趣的各方这些更改。我们将使用我们的老朋友`EventEmitter`类来管理必须发送的事件的监听器。
- en: Recall that we created a class, `AbstractNotesStore`, and that every storage
    module contains a subclass of `AbstractNotesStore`. Hence we can add listener
    support in `AbstractNotesStore`, making it automatically available to the implementations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们创建了一个名为`AbstractNotesStore`的类，每个存储模块都包含`AbstractNotesStore`的子类。因此，我们可以在`AbstractNotesStore`中添加监听器支持，使其自动可用于实现。
- en: 'In `models/Notes.mjs`, make this change:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models/Notes.mjs`中，进行以下更改：
- en: '[PRE3]js\1'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]js\1'
- en: The changes do not change the original contract of these methods, since they
    still create, update, and destroy notes. The other `NotesStore` implementations
    require similar changes. What's new is that now those methods emit the appropriate
    events for any code that may be interested.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改并未改变这些方法的原始合同，因为它们仍然创建、更新和销毁笔记。其他`NotesStore`实现需要类似的更改。新的是现在这些方法会为可能感兴趣的任何代码发出适当的事件。
- en: Another task to take care of is initialization, which must happen after `NotesStore`
    is initialized. Recall that setting up `NotesStore` is asynchronous. Therefore,
    calling the `.on` function to register an event listener must happen after `NotesStore`
    is initialized.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个需要处理的任务是初始化，这必须发生在`NotesStore`初始化之后。请记住，设置`NotesStore`是异步的。因此，在`NotesStore`初始化之后调用`.on`函数注册事件监听器必须发生在`NotesStore`初始化之后。
- en: 'In both `routes/index.mjs` and `routes/notes.mjs`, add the following function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/index.mjs`和`routes/notes.mjs`中，添加以下函数：
- en: '[PRE4]js\1'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]js\1'
- en: This imports the two `init` functions, giving them unique names, then calling
    them once `NotesStore` is set up. At the moment, both functions do nothing, but
    that will change shortly. The important thing is these two `init` functions will
    be called after `NotesStore` is completely initialized.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这导入了两个`init`函数，为它们提供了唯一的名称，然后在`NotesStore`设置完成后调用它们。目前，这两个函数什么也不做，但很快会改变。重要的是这两个`init`函数将在`NotesStore`完全初始化后被调用。
- en: We have our `NotesStore` sending events when a Note is created, updated, or
    destroyed. Let's now use those events to update the user interface appropriately.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`NotesStore`在创建、更新或销毁笔记时发送事件。现在让我们使用这些事件适当地更新用户界面。
- en: Real-time changes in the Notes home page
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Notes主页的实时更改
- en: The Notes model now sends events as Notes are created, updated, or destroyed.
    For this to be useful, the events must be displayed to our users. Making the events
    visible to our users means the controller and view portions of the application
    must consume those events.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Notes模型现在在创建、更新或销毁笔记时发送事件。为了让这些事件有用，它们必须显示给我们的用户。使事件对我们的用户可见意味着应用程序的控制器和视图部分必须消耗这些事件。
- en: 'At the top of `routes/index.mjs`, add this to the list of imports:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/index.mjs`的顶部，将其添加到导入列表中：
- en: '[PRE5]js\1'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]js\1'
- en: This extracts what had been the body of the `router` function into a separate
    function. We need to use this function not only in the home page `router` function
    but also when we emit Socket.IO messages for the home page.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将原本是`router`函数主体的内容提取到一个单独的函数中。我们不仅需要在主页的`router`函数中使用这个函数，还需要在为主页发出Socket.IO消息时使用它。
- en: We did change the return value. Originally, it contained an array of Note objects,
    and now it contains an array of anonymous objects containing `key` and `title`
    data. We did this because providing the array of Note objects to Socket.IO resulted
    in an array of empty objects being sent to the browser while sending the anonymous
    objects worked correctly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实改变了返回值。最初，它包含一个Note对象数组，现在它包含一个包含`key`和`title`数据的匿名对象数组。我们之所以这样做，是因为将Note对象数组提供给Socket.IO会导致发送到浏览器的是一组空对象，而发送匿名对象则可以正常工作。
- en: 'Then, add this at the bottom:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在底部添加这个：
- en: '[PRE6]js\1'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]js\1'
- en: This code had been at the bottom of `views/layout.hbs`, and it is the shared
    code snippet we just mentioned. This is meant to be used on every page template,
    and to be followed by custom JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码原本位于`views/layout.hbs`的底部，这是我们刚提到的共享代码片段。这意味着它将用于每个页面模板，并在自定义JavaScript之后使用。
- en: 'We now need to modify `views/layout.hbs` as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修改`views/layout.hbs`如下：
- en: '[PRE7]js\1'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]js\1'
- en: With this, every one of the templates explicitly loads the JavaScript code for
    Bootstrap and FeatherJS at the bottom of the page. They were previously loaded
    at the bottom of the page in `layout.hbs`. What this bought us is the freedom
    to load Socket.IO client code after Bootstrap and jQuery are loaded.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，每个模板都明确地在页面底部加载了Bootstrap和FeatherJS的JavaScript代码。它们以前是在`layout.hbs`的页面底部加载的。这给我们带来的好处是可以在加载Bootstrap和jQuery之后加载Socket.IO客户端代码。
- en: We have changed every template to use a new policy for loading the JavaScript.
    Let's now take care of the Socket.IO client on the home page.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了每个模板以使用新的加载JavaScript的策略。现在让我们来处理主页上的Socket.IO客户端。
- en: Adding a Socket.IO client to the Notes home page
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向Notes主页添加Socket.IO客户端
- en: Remember that our task is to add a Socket.IO client to the home page so that
    the home page receives notifications about created, updated, or deleted Notes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住我们的任务是在主页添加一个Socket.IO客户端，以便主页接收有关创建、更新或删除笔记的通知。
- en: 'In `views/index.hbs`, add this at the bottom, after the `footerjs` partial:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views/index.hbs`中，在`footerjs`部分之后添加以下内容：
- en: '[PRE8]js\1'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]js\1'
- en: You'll notice in the script that it references `$("#notetitles")` to clear the
    existing list of note titles, then to add a new list. Obviously, that requires
    an `id="notetitles"` attribute on this `<div>`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到脚本中引用了`$("#notetitles")`来清除现有的笔记标题列表，然后添加一个新列表。显然，这需要在这个`<div>`上有一个`id="notetitles"`属性。
- en: Our code in `routes/index.mjs` listened to various events from the Notes model
    and, in response, sent a `notetitles` event to the browser. The browser code takes
    that list of note information and redraws the screen.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`routes/index.mjs`中的代码监听了来自Notes模型的各种事件，并相应地向浏览器发送了一个`notetitles`事件。浏览器代码获取笔记信息列表并重新绘制屏幕。
- en: You might notice that our browser-side JavaScript is not using ES-2015/2016/2017
    features. This code would, of course, be cleaner if we were to do so. How can
    we know whether our visitors use a browser modern enough for those language features?
    We could use Babel to transpile ES-2015/2016/2017 code into ES5 code capable of
    running on any browser. However, it is a pragmatic trade-off to still write ES5
    code in the browser.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我们的浏览器端JavaScript没有使用ES-2015/2016/2017功能。当然，如果我们这样做，代码会更清晰。我们如何知道我们的访问者是否使用足够现代的浏览器来支持这些语言特性呢？我们可以使用Babel将ES-2015/2016/2017代码转译为能够在任何浏览器上运行的ES5代码。然而，在浏览器中仍然编写ES5代码是一种务实的折衷。
- en: Running Notes with real-time home page updates
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用实时主页更新运行Notes
- en: We now have enough implemented to run the application and see some real-time
    action.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了足够的功能来运行应用程序并看到一些实时操作。
- en: 'As you did earlier, start the user information microservice in one window:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前一样，在一个窗口中启动用户信息微服务：
- en: '[PRE9]js\1'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]js\1'
- en: Then, in a browser window, go to `http://localhost:3000` and log in to the Notes
    application. To see the real-time effects, open multiple browser windows. If you
    can use Notes from multiple computers, then do that as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在浏览器窗口中，转到`http://localhost:3000`并登录Notes应用程序。要查看实时效果，请打开多个浏览器窗口。如果您可以从多台计算机上使用Notes，则也可以这样做。
- en: In one browser window, start creating and deleting notes, while leaving the
    other browser windows viewing the home page. Create a note, and it should show
    up immediately on the home page in the other browser windows. Delete a note and it
    should disappear immediately as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个浏览器窗口中，创建和删除便签，同时保留其他浏览器窗口查看主页。创建一个便签，它应该立即显示在其他浏览器窗口的主页上。删除一个便签，它也应该立即消失。
- en: One scenario you might try requires three browser windows. In one window, create
    a new note, and then leave that browser window showing the newly created note.
    In another window, show the Notes home page. And in the third window, show the
    newly created note. Now, delete this newly created note. Of those windows, two
    are correctly updated and are now showing the home page. The third, where we were
    simply viewing the note, is still showing that note even though it no longer exists.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能要尝试的一个场景需要三个浏览器窗口。在一个窗口中，创建一个新的便签，然后保留显示新创建的便签的浏览器窗口。在另一个窗口中，显示Notes主页。在第三个窗口中，显示新创建的便签。现在，删除这个新创建的便签。其中两个窗口被正确更新，现在显示主页。第三个窗口，我们只是在查看便签，仍然显示该便签，即使它已经不存在。
- en: We'll get to that shortly, but first, we need to talk about how to debug your
    Socket.IO client code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会解决这个问题，但首先，我们需要讨论如何调试您的Socket.IO客户端代码。
- en: A word on enabling debug tracing in Socket.IO code
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于在Socket.IO代码中启用调试跟踪的说明
- en: It is useful to inspect what Socket.IO is doing in case you're having trouble.
    Fortunately, the Socket.IO package uses the same Debug package that Express uses,
    and we can turn on debug tracing just by setting the `DEBUG` environment variable.
    It even uses a variable, `localStorage.debug`, with the same syntax on the client
    side, and we can enable debug tracing in the browser as well.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Socket.IO正在做什么是有用的，如果您遇到问题。幸运的是，Socket.IO包使用与Express相同的Debug包，我们可以通过设置`DEBUG`环境变量来打开调试跟踪。它甚至在客户端使用相同的语法`localStorage.debug`变量，我们也可以在浏览器中启用调试跟踪。
- en: 'On the server side, this is a useful `DEBUG` environment variable setting:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，这是一个有用的`DEBUG`环境变量设置：
- en: '[PRE10]js\1'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: Immediately, you will start seeing a constant chatter of messages from Socket.IO.
    One thing you'll learn is that even when the application is idle, Socket.IO is
    communicating back and forth.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，您将开始看到来自Socket.IO的不断交谈的消息。您将了解到的一件事是，即使应用程序处于空闲状态，Socket.IO也在来回通信。
- en: There are several other `DEBUG` strings to use. For example, Socket.IO relies
    on the Engine.IO package for its transport layer. If you want debug tracing of
    that package, add `engine*` to the `DEBUG` string. The strings shown were most
    helpful during the testing of this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个要使用的`DEBUG`字符串。例如，Socket.IO依赖于Engine.IO包来进行传输。如果您想要对该包进行调试跟踪，将`engine*`添加到`DEBUG`字符串中。在测试本章节时，所示的字符串最有帮助。
- en: Now that we've learned about debug tracing, we can take care of changing the
    `/notes/view` pages to react so they changes to the Note being viewed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了调试跟踪，我们可以处理将`/notes/view`页面更改为对正在查看的便签做出反应的问题。
- en: Real-time action while viewing notes
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看便签时的实时操作
- en: 'It''s cool how we can now see real-time changes in a part of the Notes application.
    Let''s turn to the `/notes/view` page to see what we can do. What comes to mind
    is this functionality:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到Notes应用程序的一部分实时更改，这很酷。让我们转到`/notes/view`页面看看我们能做些什么。我想到的是这个功能：
- en: Update the note if someone else edits it.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其他人编辑便签，则更新便签。
- en: Redirect the viewer to the home page if someone else deletes the note.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其他人删除了便签，将查看者重定向到主页。
- en: Allow users to leave comments on the note.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户在便签上留下评论。
- en: For the first two features, we can rely on the existing events coming from the
    Notes model. Therefore, we can implement those two features in this section. The
    third feature will require a messaging subsystem, so we'll get to that later in
    this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前两个功能，我们可以依赖于来自Notes模型的现有事件。因此，我们可以在本节中实现这两个功能。第三个功能将需要一个消息传递子系统，因此我们将在本章的后面进行讨论。
- en: To implement this, we could create one Socket.IO namespace for each Note, such
    as `/notes/${notekey}`. Then, when the browser is viewing a Note, the client code
    added to the `noteview.hbs` template would connect to that namespace. However,
    that raises the question of how to create those namespaces. Instead, the implementation
    selected was to have one namespace, `/notes`, and to create one room per Note.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以为每个便签创建一个Socket.IO命名空间，例如`/notes/${notekey}`。然后，当浏览器查看便签时，添加到`noteview.hbs`模板的客户端代码将连接到该命名空间。然而，这引发了如何创建这些命名空间的问题。相反，所选的实现是有一个命名空间`/notes`，并为每个便签创建一个房间。
- en: 'In `routes/notes.mjs`, make sure to import the `io` object as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/notes.mjs`中，确保像这样导入`io`对象：
- en: '[PRE11]js\1'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: This simply adds the `export` keyword so we can access the function from elsewhere.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是添加了`export`关键字，以便我们可以从其他地方访问该函数。
- en: 'Then, change the `init` function to this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`init`函数更改为以下内容：
- en: '[PRE12]js\1'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: This is how we use Socket.IO to send a message to any browser connected to the
    given namespace and room.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何使用Socket.IO向连接到给定命名空间和房间的任何浏览器发送消息。
- en: For `noteupdated`, we simply send the new Note data. We again had to convert
    the Note object into an anonymous JavaScript object, because otherwise, an empty
    object arrived in the browser. The client code will have to use, as we will see
    shortly, jQuery operations to update the page.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`noteupdated`，我们只需发送新的笔记数据。我们再次不得不将笔记对象转换为匿名JavaScript对象，因为否则浏览器中会收到一个空对象。客户端代码将不得不使用jQuery操作来更新页面，我们很快就会看到。
- en: For `notedestroyed`, we simply send the `key`. Since the client code will respond
    by redirecting the browser to the home page, we don't have to send anything at
    all.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`notedestroyed`，我们只需发送`key`。由于客户端代码将通过将浏览器重定向到主页来做出响应，我们根本不需要发送任何内容。
- en: In both, we also call `emitNoteTitles` to ensure the home page is updated if
    it is being viewed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两者中，我们还调用`emitNoteTitles`来确保主页在被查看时得到更新。
- en: Changing the note view template for real-time action
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为实时操作更改笔记视图模板
- en: 'As we did in the home page template, the data contained in these events must
    be made visible to the user. We must not only add client code to the template,
    `views/noteview.hbs`; we need a couple of small changes to the template:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在主页模板中所做的那样，这些事件中包含的数据必须对用户可见。我们不仅需要向模板`views/noteview.hbs`中添加客户端代码；我们还需要对模板进行一些小的更改：
- en: '[PRE13]js\1'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: In this script, we first connect to the `/notes` namespace and then create listeners
    for the `noteupdated` and `notedestroyed` events.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们首先连接到`/notes`命名空间，然后为`noteupdated`和`notedestroyed`事件创建监听器。
- en: 'When connecting to the `/notes` namespace, we are passing an extra parameter.
    The optional second parameter to this function is an options object, and in this
    case, we are passing the `query` option. The `query` object is identical in form
    to the `query` object of the `URL` class. This means the namespace is as if it
    were a URL such as `/notes?key=${notekey}`. Indeed, according to the Socket.IO
    documentation, we can pass a full URL, and it also works if the connection is
    created like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到`/notes`命名空间时，我们传递了一个额外的参数。这个函数的可选第二个参数是一个选项对象，在这种情况下，我们传递了`query`选项。`query`对象在形式上与`URL`类的`query`对象相同。这意味着命名空间就像是一个URL，比如`/notes?key=${notekey}`。根据Socket.IO文档，我们可以传递一个完整的URL，如果连接是这样创建的，它也可以工作：
- en: '[PRE14]js\1'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: We needed to update the title at the top of the page as well, and this `id`
    attribute helps to target the correct element.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在页面顶部更新标题，这个`id`属性有助于定位正确的元素。
- en: For the `notedestroyed` event, we simply redirect the browser window back to
    the home page. The note being viewed has been deleted, and there's no point the user
    continuing to look at a note that no longer exists.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`notedestroyed`事件，我们只需将浏览器窗口重定向回主页。正在查看的笔记已被删除，用户继续查看不再存在的笔记是没有意义的。
- en: Running Notes with pseudo-real-time updates while viewing a note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在查看笔记时运行带有伪实时更新的笔记
- en: At this point, you can now rerun the Notes application and try the new real-time
    updates feature.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您现在可以重新运行笔记应用程序并尝试新的实时更新功能。
- en: By now you have put Notes through its paces many times, and know what to do.
    Start by launching the user authentication server and the Notes application. Make
    sure there is at least one note in the database; add one if needed. Then, open
    multiple browser windows with one viewing the home page and two viewing the same
    note. In a window viewing the note, edit the note to make a change, making sure
    to change the title. The text change should change on both the home page and the
    page viewing the note.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经多次测试了笔记，并知道该怎么做。首先启动用户认证服务器和笔记应用程序。确保数据库中至少有一条笔记；如果需要，添加一条。然后，打开多个浏览器窗口，一个查看主页，两个查看同一条笔记。在查看笔记的窗口中，编辑笔记进行更改，确保更改标题。文本更改应该在主页和查看笔记的页面上都有变化。
- en: Then delete the note and watch it disappear from the home page, and further,
    the browser window that had viewed the note is now on the home page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后删除笔记并观察它从主页消失，而且查看笔记的浏览器窗口现在位于主页上。
- en: We took care of a lot of things in this section, and the Notes application now
    has dynamic updates happening. To do this, we created an event-based notification
    system, then used Socket.IO in both browser and server to communicate data back
    and forth.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们处理了很多事情，现在笔记应用程序具有动态更新功能。为此，我们创建了一个基于事件的通知系统，然后在浏览器和服务器中使用Socket.IO来往返通信数据。
- en: We have implemented most of what we've set out to do. By refactoring the Notes
    Store implementations to send events, we are able to send events to Socket.IO
    clients in the browser. That in turn is used to automatically update the Notes
    home page, and the `/notes/view` page.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了我们设定的大部分目标。通过重构笔记存储实现以发送事件，我们能够向浏览器中的Socket.IO客户端发送事件。这反过来又用于自动更新笔记主页和`/notes/view`页面。
- en: The remaining feature is for users to be able to write comments on Notes. In
    the next section, we will take care of that by adding a whole new database table
    to handle messages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的功能是让用户能够在笔记上写评论。在下一节中，我们将通过添加一个全新的数据库表来处理消息。
- en: Inter-user chat and commenting for Notes
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 笔记的用户间聊天和评论
- en: This is cool! We now have real-time updates in Notes as we edit delete or create
    notes. Let's now take it to the next level and implement something akin to inter-user
    chatting.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷！现在我们在编辑、删除或创建笔记时可以实时更新笔记。现在让我们把它提升到下一个级别，并实现类似于用户之间聊天的功能。
- en: Earlier, we named three things we could do with Socket.IO on `/notes/view` pages.
    We've already implemented live updating when a Note is changed and a redirect
    to the home page if a Note is deleted; the remaining task is to allow users to
    make comments on Notes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们列举了在`/notes/view`页面上可以使用Socket.IO做的三件事。我们已经实现了当笔记更改时的实时更新和当笔记被删除时重定向到主页；剩下的任务是允许用户对笔记进行评论。
- en: It's possible to pivot our Notes application concept and take it in the direction
    of a social network. In the majority of such networks, users post things (notes,
    pictures, videos, and so on), and other users comment on those things. Done well,
    these basic elements can develop a large community of people sharing notes with
    each other. While the Notes application is kind of a toy, it's not too terribly
    far from being a basic social network. Commenting the way we will do now is a
    tiny step in that direction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的笔记应用程序概念转变，并将其发展成一个社交网络。在大多数这样的网络中，用户发布东西（笔记、图片、视频等），其他用户对这些东西进行评论。如果做得好，这些基本元素可以发展成一个庞大的人群共享笔记的社区。虽然笔记应用程序有点像一个玩具，但它离一个基本的社交网络并不太远。我们现在将要做的评论是朝着这个方向迈出的一小步。
- en: On each note page, we'll have an area to display messages from Notes users.
    Each message will show the username, a timestamp, and their message. We'll also
    need a method for users to post a message, and we'll also allow users to delete
    messages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个笔记页面上，我们将有一个区域来显示来自笔记用户的消息。每条消息将显示用户名、时间戳和他们的消息。我们还需要一种方法让用户发布消息，并允许用户删除消息。
- en: Each of those operations will be performed without refreshing the screen. Instead,
    code running inside the web page will send commands to/from the server and take
    action dynamically. By doing this, we'll learn about Bootstrap modal dialogs,
    as well as more about sending and receiving Socket.IO messages. Let's get started.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都将在不刷新屏幕的情况下执行。相反，网页内运行的代码将发送命令到/从服务器，并动态采取行动。通过这样做，我们将学习关于Bootstrap模态对话框，以及更多关于发送和接收Socket.IO消息的知识。让我们开始吧。
- en: Data model for storing messages
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储消息的数据模型
- en: We need to start by implementing a data model for storing messages. The basic fields
    required are a unique ID, the username of the person sending the message, the
    namespace and the room associated with the message, the message, and finally a
    timestamp for when the message was sent. As messages are received or deleted,
    events must be emitted from the data model so we can do the right thing on the
    web page. We associate messages with a room and namespace combination because
    in Socket.IO that combination has proved to be a good way to address a specific
    page in the Notes application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先实现一个用于存储消息的数据模型。所需的基本字段是唯一ID、发送消息的人的用户名、与消息相关的命名空间和房间、消息，最后是消息发送的时间戳。当接收或删除消息时，必须从数据模型中发出事件，以便我们可以在网页上做正确的事情。我们将消息与房间和命名空间组合关联起来，因为在Socket.IO中，该组合已被证明是一种很好的方式来定位笔记应用程序中的特定页面。
- en: This data model implementation will be written for Sequelize. If you prefer
    a different storage solution, you can, by all means, re-implement the same API
    on other data storage systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据模型实现将被写入Sequelize。如果您喜欢其他存储解决方案，您可以尽管在其他数据存储系统上重新实现相同的API。
- en: 'Create a new file, `models/messages-sequelize.mjs`, containing the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`models/messages-sequelize.mjs`，其中包含以下内容：
- en: '[PRE15]js\1'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: The structure of `connectDB` is similar to what we did in `notes-sequelize.mjs`.
    We use the same `connectSequlz` function to connect with the same database, and
    we return immediately if the database is already connected.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectDB`的结构与我们在`notes-sequelize.mjs`中所做的类似。我们使用相同的`connectSequlz`函数与相同的数据库连接，并且如果数据库已经连接，我们会立即返回。'
- en: With `SQMessage.init`, we define our message schema in the database. We have
    a simple database schema that is fairly self-explanatory. To emit events about
    messages, we're using a `Sequelize` feature to be called at certain times.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`SQMessage.init`，我们在数据库中定义了我们的消息模式。我们有一个相当简单且相当自解释的数据库模式。为了发出关于消息的事件，我们使用了`Sequelize`的一个特性，在特定时间调用。
- en: The `id` field won't be supplied by the caller; instead, it will be autogenerated.
    Because it is an `autoIncrement` field, each message that's added will be assigned a
    new `id` number by the database. The equivalent in MySQL is the `AUTO_INCREMENT`
    attribute on a column definition.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`字段不会由调用者提供；相反，它将自动生成。因为它是一个`autoIncrement`字段，每添加一条消息，数据库将为其分配一个新的`id`编号。在MySQL中的等效操作是在列定义上的`AUTO_INCREMENT`属性。'
- en: The `namespace` and `room` fields together define which page in Notes each message
    belongs to. Remember that when emitting an event with Socket.IO we can target
    the event to one or both of those spaces, and therefore we will use these values
    to target each message to a specific page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace`和`room`字段一起定义了每条消息属于笔记中的哪个页面。请记住，在使用Socket.IO发出事件时，我们可以将事件定位到这两个空间中的一个或两个，因此我们将使用这些值将每条消息定位到特定页面。'
- en: So far we defined one namespace, `/home`, for the Notes home page, and another
    namespace, `/notes`, for viewing an individual note. In theory, the Notes application
    could be expanded to have messages displayable in other areas. For example, a
    `/private-message` namespace could be used for private messages. Therefore, the
    schema is defined with both a `namespace` and `room` field so that, in due course,
    we could use messages in any future part of the Notes application that may be
    developed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们为笔记主页定义了一个命名空间`/home`，为查看单个笔记定义了另一个命名空间`/notes`。理论上，笔记应用程序可以扩展到在其他区域显示消息。例如，`/private-message`命名空间可以用于私人消息。因此，模式被定义为具有`namespace`和`room`字段，以便在将来的笔记应用程序的任何部分中使用消息。
- en: For our current purposes, messages will be stored with `namespace` equal to
    `/home`, and `room` equal to the `key` of a given Note.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们当前的目的，消息将被存储在`namespace`等于`/home`，`room`等于给定笔记的`key`的情况下。
- en: We will use the `timestamp` to present messages in the order of when they were
    sent. The `from` field is the username of the sender.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`timestamp`按发送顺序呈现消息。`from`字段是发送者的用户名。
- en: To send notifications about created and destroyed messages, let's try something
    different. If we follow the pattern we used earlier, the functions we're about
    to create will have `emitter.emit` calls with corresponding messages. But Sequelize
    offers a different approach.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送有关已创建和已销毁消息的通知，让我们尝试一些不同的方法。如果我们遵循之前使用的模式，我们即将创建的函数将具有带有相应消息的`emitter.emit`调用。但Sequelize提供了一种不同的方法。
- en: With `Sequelize`, we can create what are called hook methods. Hooks can also
    be called **life cycle events**, and they are a series of functions we can declare.
    Hook methods are invoked when certain trigger states exist for the objects managed
    by Sequelize. In this case, our code needs to know when a message is created,
    and when a message is deleted.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Sequelize`，我们可以创建所谓的钩子方法。钩子也可以被称为**生命周期事件**，它们是我们可以声明的一系列函数。当Sequelize管理的对象存在某些触发状态时，将调用钩子方法。在这种情况下，我们的代码需要知道何时创建消息，以及何时删除消息。
- en: Hooks are declared as shown in the options object. A field named `hooks` in
    the `schema` options object defines hook functions. For each hook we want to use,
    add an appropriately named field containing the hook function. For our needs,
    we need to declare `hooks.afterCreate` and `hooks.afterDestroy`. For each, we've
    declared a function that takes the instance of the `SQMessage` object that has
    just been created or destroyed. And, with that object, we call `emitter.emit`
    with either the `newmessage` or `destroymessage` event name.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子声明如选项对象所示。`schema`选项对象中的名为`hooks`的字段定义了钩子函数。对于我们想要使用的每个钩子，添加一个包含钩子函数的适当命名字段。对于我们的需求，我们需要声明`hooks.afterCreate`和`hooks.afterDestroy`。对于每个钩子，我们声明一个函数，该函数接受刚刚创建或销毁的`SQMessage`对象的实例。然后，使用该对象，我们调用`emitter.emit`，使用`newmessage`或`destroymessage`事件名称。
- en: 'Continue by adding this function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加这个函数：
- en: '[PRE16]js\1'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: This is to be called when a user posts a new comment/message. We store it in
    the database, and the hook emits an event saying the message was created.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户发布新评论/消息时将调用此函数。我们将其存储在数据库中，并且钩子发出一个事件，表示消息已创建。
- en: Remember that the `id` field is auto-created as the new message is stored. Therefore,
    it is not supplied when calling `SQMessage.create`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`id`字段是在存储新消息时自动创建的。因此，在调用`SQMessage.create`时不提供它。
- en: This function, and the next, could have contained the `emitter.emit` call to
    send the `newmessage` or `destroymessage` events. Instead, those events are sent
    in the hook functions we created earlier. The question is whether it is correct
    to place `emitter.emit` in a hook function, or to place it here.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数和下一个函数本来可以包含`emitter.emit`调用来发送`newmessage`或`destroymessage`事件。相反，这些事件是在我们之前创建的钩子函数中发送的。问题是是否将`emitter.emit`放在钩子函数中，还是放在这里。
- en: The rationale used here is that by using hooks we are assured of always emitting
    the messages.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的原理是，通过使用钩子，我们可以确保始终发出消息。
- en: 'Then, add this function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加这个函数：
- en: '[PRE17]js\1'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]js\1'
- en: This function retrieves recent messages, and the immediate use case is for this
    to be used while rendering `/notes/view` pages.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数检索最近的消息，立即使用情况是在渲染`/notes/view`页面时使用。
- en: While our current implementation is for viewing a Note, it is generalized to
    work for any Socket.IO namespace and room. This is for possible future expansion,
    as we explained earlier. It finds the most recent 20 messages associated with
    the given namespace and room combination, then returns a cleaned-up list to the
    caller.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们当前的实现是用于查看笔记，但它是通用的，适用于任何Socket.IO命名空间和房间。这是为了可能的未来扩展，正如我们之前解释的那样。它找到与给定命名空间和房间组合关联的最近的20条消息，然后将一个经过清理的列表返回给调用者。
- en: In `findAll`, we specify an `order` attribute. This is similar to the `ORDER
    BY` phrase in SQL. The `order` attribute takes an array of one or more descriptors
    declaring how Sequelize should sort the results. In this case, there is one descriptor,
    saying to sort by the `timestamp` field in descending order. This will cause the
    most recent message to be displayed first.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`findAll`中，我们指定一个`order`属性。这类似于SQL中的`ORDER BY`短语。`order`属性接受一个或多个描述符的数组，声明Sequelize应该如何对结果进行排序。在这种情况下，有一个描述符，表示按照时间戳字段降序排序。这将导致最近的消息首先显示。
- en: We have created a simple module to store messages. We didn't implement the full
    set of **create, read, update, and delete** (**CRUD**) operations because they
    weren't necessary for this task. The user interfaces we're about to create only
    let folks add new messages, delete existing messages, and view the current messages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的模块来存储消息。我们没有实现完整的**创建、读取、更新和删除**（**CRUD**）操作，因为对于这个任务并不需要。我们即将创建的用户界面只允许用户添加新消息、删除现有消息和查看当前消息。
- en: Let's get on with creating the user interface.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建用户界面。
- en: Adding support for messages to the Notes router
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Notes路由器添加消息支持
- en: Now that we can store messages in the database, let's integrate this into the
    Notes router module.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将消息存储到数据库中，让我们将其集成到Notes路由器模块中。
- en: Integrating messages to the `/notes/view` page will require some new HTML and
    JavaScript in the `notesview.hbs` template, and some new Socket.IO communications
    endpoints in the `init` function in `routes/notes.mjs`. In this section, let's
    take care of those communications endpoints, then in the next section let's talk
    about how to set it up in the user interface.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息集成到`/notes/view`页面将需要在`notesview.hbs`模板中添加一些新的HTML和JavaScript，并在`routes/notes.mjs`中的`init`函数中添加一些新的Socket.IO通信端点。在本节中，让我们处理这些通信端点，然后在下一节中让我们讨论如何在用户界面中设置它。
- en: 'In `routes/notes.mjs`, add this to the `import` statements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/notes.mjs`中，将这个添加到`import`语句中：
- en: '[PRE18]js\1'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]js\1'
- en: These receive notifications of new messages, or destroyed messages, from `models/messages-sequelize.mjs`,
    then forwards the notification to the browser. Remember that the message object
    contains the namespace and room, therefore this lets us address this notification
    to any Socket.IO communication channel.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接收来自`models/messages-sequelize.mjs`的新消息或已销毁消息的通知，然后将通知转发到浏览器。请记住，消息对象包含命名空间和房间，因此这让我们能够将此通知发送到任何Socket.IO通信通道。
- en: Why didn't we just make the Socket.IO call in `models/messages-sequelize.mjs`?
    Clearly, it would have been slightly more efficient, require fewer lines of code,
    and therefore fewer opportunities for a bug to creep in, to have put the Socket.IO
    call in `messages-sequelize.mjs`. But we are maintaining the separation between
    model, view, and controller, which we talked of earlier in [Chapter 5](582d3898-0135-430c-8b6e-8326f287e18b.xhtml), *Your
    First Express Application*. Further, can we predict confidently that there will
    be no other use for messages in the future? This architecture allows us to connect
    multiple listener methods to those message events, for multiple purposes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不直接在`models/messages-sequelize.mjs`中进行Socket.IO调用呢？显然，将Socket.IO调用放在`messages-sequelize.mjs`中会更有效率，需要更少的代码行，因此减少了错误的机会。但是我们正在保持模型、视图和控制器之间的分离，这是我们在[第5章](582d3898-0135-430c-8b6e-8326f287e18b.xhtml)中讨论过的。此外，我们能够自信地预测将来不会有其他用途的消息吗？这种架构允许我们将多个监听器方法连接到这些消息事件，以实现多种目的。
- en: In the user interface, we'll have to implement corresponding listeners to receive
    these messages, then take appropriate user interface actions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面中，我们将不得不实现相应的监听器来接收这些消息，然后采取适当的用户界面操作。
- en: 'In the `connect` listener in the `init` function, add these two new event listeners:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中的`connect`监听器中，添加这两个新的事件监听器：
- en: '[PRE19]js\1'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]js\1'
- en: That function in the third parameter becomes the `fn` parameter in the `create-message`
    event handler function. Then, anything supplied to a call to `fn` will arrive
    in this function as the `result` parameter. It doesn't matter that it's a browser
    supplying that function across a connection to the server and that the call to
    the function happens on the server, Socket.IO takes care of transporting the response
    data back to the browser code and invoking the acknowledgment function there.
    The last thing to note is that we're being lazy with error reporting. So, put
    a task on the backlog to improve error reporting to the users.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数中的函数成为`create-message`事件处理程序函数中的`fn`参数。然后，提供给`fn`调用的任何内容都将作为`result`参数传递到此函数中。不管是浏览器通过连接到服务器提供该函数，还是在服务器上调用该函数，Socket.IO都会负责将响应数据传输回浏览器代码并在那里调用确认函数。最后要注意的是，我们在错误报告方面有些懒惰。因此，将一个任务放在待办事项中，以改进向用户报告错误。
- en: The next task is to implement code in the browser to make all this visible to
    the user.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是在浏览器中实现代码，使所有这些对用户可见。
- en: Changing the note view template for messages
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改消息的注释视图模板
- en: We need to dive back into `views/noteview.hbs` with more changes so that we
    can view, create, and delete messages. This time, we will add a lot of code, including
    using a Bootstrap modal popup to get the message, the Socket.IO messages we just
    discussed, and the jQuery manipulations to make everything appear on the screen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要再次深入`views/noteview.hbs`进行更多的更改，以便我们可以查看、创建和删除消息。这一次，我们将添加大量的代码，包括使用Bootstrap模态弹出窗口来获取消息，我们刚刚讨论的Socket.IO消息，以及jQuery操作，使所有内容显示在屏幕上。
- en: We want the `/notes/view` page to not cause unneeded page reloads. Instead,
    we want the user to add a comment by having a pop-up window collect the message
    text, and then the new message is added to the page, without causing the page
    to reload. Likewise, if another user adds a message to a Note, we want the message
    to show up without the page reloading. Likewise, we want to delete messages without
    causing the page to reload, and for messages to be deleted for others viewing
    the note without the page reloading.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`/notes/view`页面不会导致不必要的页面重新加载。相反，我们希望用户通过弹出窗口收集消息文本来添加评论，然后新消息将被添加到页面上，而不会导致页面重新加载。同样，如果另一个用户向Note添加消息，我们希望消息能够在不重新加载页面的情况下显示出来。同样，我们希望删除消息而不会导致页面重新加载，并且希望消息被删除后，其他查看Note的用户也不会导致页面重新加载。
- en: Of course, this will involve several Socket.IO messages going back and forth
    between browser and server, along with some jQuery DOM manipulations. We can do
    both without reloading the page, which generally improves the user experience.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这将涉及浏览器和服务器之间来回传递多个Socket.IO消息，以及一些jQuery DOM操作。我们可以在不重新加载页面的情况下完成这两个操作，这通常会提高用户体验。
- en: Let's start by implementing the user interface to create a new message.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实现用户界面来创建新消息。
- en: Composing messages on the Note view page
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Note视图页面上撰写消息
- en: The next task for the `/notes/view` page is to let the user add a message. They'll
    click a button, a pop-up window lets them enter the text, they'll click a button
    in the popup, the popup will be dismissed, and the message will show up. Further,
    the message will be shown to other viewers of the Note.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`/notes/view`页面的下一个任务是让用户添加消息。他们将点击一个按钮，弹出窗口让他们输入文本，然后他们将在弹出窗口中点击一个按钮，弹出窗口将被关闭，消息将显示出来。此外，消息将显示给Note的其他查看者。'
- en: The Bootstrap framework includes support for Modal windows. They serve a similar
    purpose to Modal dialogs in desktop applications. Modal windows appear above existing
    windows of an application, while preventing interaction with other parts of the
    web page or application. They are used for purposes such as asking a question
    of the user. The typical interaction is to click a button, then the application
    pops up a Modal window containing some UI elements, the user interacts with the
    Modal, then dismisses it. You will certainly have interacted with many thousands
    of Modal windows while using computers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap框架包括对模态窗口的支持。它们与桌面应用程序中的模态对话框具有类似的作用。模态窗口出现在应用程序现有窗口的上方，同时阻止与网页或应用程序其他部分的交互。它们用于向用户提问等目的。典型的交互是点击按钮，然后应用程序弹出一个包含一些UI元素的模态窗口，用户与模态交互，然后关闭它。在使用计算机时，您肯定已经与成千上万个模态窗口进行了交互。
- en: 'Let''s first add a button with which the user will request to add a comment.
    In the current design, there is a row of two buttons below the Note text. In `views/noteview.hbs`,
    let''s add a third button:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先添加一个按钮，用户将请求添加评论。在当前设计中，笔记文本下方有一排两个按钮。在`views/noteview.hbs`中，让我们添加第三个按钮：
- en: '[PRE20]js\1'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]js\1'
- en: Again, this comes directly from the Bootstrap documentation for the Modal component,
    along with a simple form to collect the message.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是直接来自Bootstrap模态组件的文档，以及一个简单的表单来收集消息。
- en: Notice there is `<div class="modal-dialog">`, and within that, `<div class="model-content">`.
    Together, these form what is shown within the dialog window. The content is split
    between a `<div class="modal-header">` for the top row of the dialog, and a `<div
    class="modal-body">` for the main content.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里有`<div class="modal-dialog">`，在其中有`<div class="model-content">`。这两者一起形成了对话框窗口内显示的内容。内容分为`<div
    class="modal-header">`用于对话框的顶部行，以及`<div class="modal-body">`用于主要内容。
- en: The `id` value on the outermost element, `id="notes-comment-modal"`, matches
    the target declared in the button, `data-target="#notes-comment-modal"`. Another
    connection to make is `aria-labelledby`, which matches the `id` of the `<h5 class="modal-title">`
    element.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层元素的`id`值，`id="notes-comment-modal"`，与按钮中声明的目标匹配，`data-target="#notes-comment-modal"`。另一个连接是`aria-labelledby`，它与`<h5
    class="modal-title">`元素的`id`匹配。
- en: '`<form id="submit-comment">` is minimal because we will not use it to submit
    anything over an HTTP connection to a regular URL. Therefore, it does not have
    `action` and `method` attributes. Otherwise, this is a normal everyday Bootstrap
    `form`, with a `fieldset` and various form elements.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form id="submit-comment">`很简单，因为我们不会使用它通过HTTP连接提交任何内容到常规URL。因此，它没有`action`和`method`属性。否则，这是一个正常的日常Bootstrap`form`，带有`fieldset`和各种表单元素。'
- en: The next step is to add the client-side JavaScript code to make this functional.
    When clicking the button, we want some client code to run, which will send a `create-message`
    event matching the code we added to `routes/notes.mjs`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加客户端JavaScript代码使其功能正常。单击按钮时，我们希望运行一些客户端代码，该代码将发送与我们添加到`routes/notes.mjs`匹配的`create-message`事件。
- en: 'In `views/noteview.hbs`, we have a section using `$(document).ready` that contains
    the client code. In that function, add a section that exists only if the `user`
    object exists, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views/noteview.hbs`中，我们有一个包含客户端代码的`$(document).ready`部分。在该函数中，添加一个仅在`user`对象存在时存在的部分，如下所示：
- en: '[PRE21]js\1'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]js\1'
- en: This matches the button in the form we just created. Normally in the event handler
    for a `type="submit"` button, we would use `event.preventDefault` to prevent the
    normal result, which is to reload the page. But that's not required in this case.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们刚刚创建的表单中的按钮相匹配。通常在`type="submit"`按钮的事件处理程序中，我们会使用`event.preventDefault`来防止正常结果，即重新加载页面。但在这种情况下不需要。
- en: The function gathers various values from the form elements and sends the `create-message`
    event. If we refer back to the server-side code, `create-message` calls `postMessage`,
    which saves the message to the database, which then sends a `newmessage` event,
    which makes its way to the browser.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数从表单元素中收集各种值，并发送`create-message`事件。如果我们回顾服务器端代码，`create-message`调用`postMessage`，将消息保存到数据库，然后发送`newmessage`事件，该事件传递到浏览器。
- en: Therefore, we will need a `newmessage` event handler, which we'll get to in
    the next section. In the meantime, you should be able to run the Notes application,
    add some messages, and see they are added to the database.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将需要一个`newmessage`事件处理程序，我们将在下一节中介绍。与此同时，您应该能够运行Notes应用程序，添加一些消息，并查看它们是否已添加到数据库中。
- en: Notice that this has a third parameter, a function that when called causes the
    Modal to be dismissed, and clears any message that was entered. This is the acknowledgment
    function we mentioned earlier, which is invoked on the server, and Socket.IO arranges
    to then invoke it here in the client.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这有一个第三个参数，一个函数，当调用时会导致模态被关闭，并清除输入的任何消息。这是我们之前提到的确认函数，在服务器上调用，并且Socket.IO安排在客户端调用它。
- en: Showing any existing messages on the Note view page
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Note视图页面上显示任何现有消息
- en: Now that we can add messages, let's learn how to display messages. Remember
    that we've defined an SQMessage schema and that we've defined a function, `recentMessages`,
    to retrieve the recent messages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加消息了，让我们学习如何显示消息。请记住，我们已经定义了SQMessage模式，并且我们已经定义了一个函数`recentMessages`来检索最近的消息。
- en: We have two possible methods to display existing messages when rendering Note
    pages. One option is for the page, when it initially displays, to send an event requesting
    the recent messages, and rendering those messages on the client once they're received.
    The other option is to render the messages on the server, instead. We've chosen
    the second option, server-side rendering.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在呈现Note页面时，我们有两种可能的方法来显示现有消息。一种选择是当页面最初显示时，发送一个事件请求最近的消息，并在接收到消息后在客户端呈现这些消息。另一种选择是在服务器上呈现消息。我们选择了第二种选择，即服务器端呈现。
- en: 'In `routes/notes.mjs`, modify the `/view` router function like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/notes.mjs`中，修改`/view`路由器函数如下：
- en: '[PRE22]js\1'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]js\1'
- en: If there is a `messages` object, these steps through the array, and for each
    entry, it sets up a Bootstrap `card` component to display the message. The messages
    are displayed within `<div id="noteMessages">`, which we'll target in DOM manipulations
    later. The markup for each message comes directly from the Bootstrap documentation,
    with a few modifications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个`messages`对象，这些步骤会遍历数组，并为每个条目设置一个Bootstrap `card`组件来显示消息。消息显示在`<div id="noteMessages">`中，我们稍后会在DOM操作中进行定位。每条消息的标记直接来自Bootstrap文档，稍作修改。
- en: In each case, the `card` component has an `id` attribute we can use to associate
    with a given message in the database. The `button` component will be used to cause
    a message to be deleted, and it carries data attributes to identify which message
    would be deleted.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，`card`组件都有一个`id`属性，我们可以用它来与数据库中的特定消息关联。`button`组件将用于删除消息，并携带数据属性来标识将要删除的消息。
- en: With this, we can view a Note, and see any messages that have been attached.
    We did not select the ordering of the messages but remember that in `models/messages-sequelize.mjs`
    the database query orders the messages in reverse chronological order.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们可以查看一个笔记，并查看已附加的任何消息。我们没有选择消息的排序，但请记住，在`models/messages-sequelize.mjs`中，数据库查询按照时间顺序相反的顺序排列消息。
- en: In any case, our goal was for messages to automatically be added without having
    to reload the page. For that purpose, we need a handler for the `newmessage` event,
    which is a task left over from the previous section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们的目标是使消息能够自动添加，而无需重新加载页面。为此，我们需要一个`newmessage`事件的处理程序，这是上一节遗留下来的任务。
- en: 'Below the handler for the `submitNewComment` button, add this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`submitNewComment`按钮的处理程序下面，添加以下内容：
- en: '[PRE23]js\1'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]js\1'
- en: The `socket` object already exists and is the Socket.IO connection to the room
    for this Note. We send to the room a `delete-message` event giving the values
    stored in data attributes on the button.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket`对象已经存在，并且是与此笔记的Socket.IO连接。我们向房间发送一个`delete-message`事件，其中包含按钮上存储的数据属性的值。'
- en: 'As we''ve already seen, on the server the `delete-message` event invokes the
    `destroyMessage` function. That function deletes the message from the database
    and also emits a `destroymessage` event. That event is received in `routes/notes.mjs`,
    which forwards the message to the browser. Therefore, we need an event listener
    in the browser to receive the `destroymessage` event:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，在服务器上，`delete-message`事件调用`destroyMessage`函数。该函数从数据库中删除消息，并发出一个`destroymessage`事件。`routes/notes.mjs`中接收到该事件，并将消息转发到浏览器。因此，我们需要在浏览器中添加一个事件监听器来接收`destroymessage`事件：
- en: '```js'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '```js'
- en: Refer back and see that every message display `card` has an `id` parameter fitting
    the pattern shown here. Therefore, the jQuery `remove` function takes care of
    removing the message from the display.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 回头看看，每条消息显示`card`都有一个符合这里显示模式的`id`参数。因此，jQuery的`remove`函数负责从显示中删除消息。
- en: Running Notes and passing messages
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行笔记并传递消息
- en: That was a lot of code, but we now have the ability to compose messages, display
    them on the screen, and delete them, all with no page reloads.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多代码，但现在我们有能力撰写消息，在屏幕上显示它们，并删除它们，而无需重新加载页面。
- en: 'You can run the application as we did earlier, first starting the user authentication
    server in one command-line window and the Notes application in another:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像我们之前那样运行应用程序，首先在一个命令行窗口中启动用户认证服务器，然后在另一个命令行窗口中启动笔记应用程序：
- en: '![](img/8600d6c4-884c-4758-bf91-e57db6f92371.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8600d6c4-884c-4758-bf91-e57db6f92371.png)'
- en: It shows us any existing messages on a Note.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了笔记上的任何现有消息。
- en: 'While entering a message, the Modal looks like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 输入消息时，模态框看起来像这样：
- en: '![](img/332a268c-23b4-440f-aa4c-b3084db30df7.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/332a268c-23b4-440f-aa4c-b3084db30df7.png)'
- en: Try this with multiple browser windows viewing the same note or different notes.
    This way, you can verify that notes show up only on the corresponding note window.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在多个浏览器窗口中查看相同的笔记或不同的笔记。这样，您可以验证笔记只显示在相应的笔记窗口上。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We came a long way in this chapter, but maybe Facebook doesn't have anything
    to fear from the baby steps we took toward converting the Notes application into
    a social network. Still, we added interesting new features to the application,
    which gave us the opportunity to explore some really cool technology for pseudo-real-time
    communication between browser sessions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们走了很长的路，但也许Facebook不必担心我们将笔记应用程序转换为社交网络的初步尝试。尽管如此，我们为应用程序添加了一些有趣的新功能，这使我们有机会探索一些真正酷的伪实时通信技术，用于浏览器会话之间的交流。
- en: We learned about using Socket.IO for pseudo-real-time web experiences. As we
    learned, it is a framework for dynamic interaction between server-side code and
    client code running in the browser. It follows an event-driven model for sending
    events between the two. Our code used this both for notifications to the browser
    of events occurring on the server and for users who wish to write comments.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了如何使用Socket.IO进行伪实时的网络体验。正如我们所学到的，它是一个用于服务器端代码和在浏览器中运行的客户端代码之间动态交互的框架。它遵循一个事件驱动模型，用于在两者之间发送事件。我们的代码使用这个框架，既用于向浏览器发送服务器上发生的事件的通知，也用于希望编写评论的用户。
- en: We learned about the value of events being sent from one part of the server-side
    code to another. This lets us have client-side updates based on changes occurring
    in the server. This used the `EventEmitter` class with listener methods that directed
    events and data to the browser.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了从服务器端代码的一个部分发送到另一个部分的事件的价值。这使我们能够根据服务器上发生的更改进行客户端更新。这使用了`EventEmitter`类和监听器方法，将事件和数据传递到浏览器。
- en: In the browser, we used jQuery DOM manipulation to change the user interface
    in response to these dynamically sent messages. By using Socket.IO and normal
    DOM manipulation, we were able to refresh the page content while avoiding page
    reloads.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们使用jQuery DOM操作来响应这些动态发送的消息来改变用户界面。通过使用Socket.IO和正常的DOM操作，我们能够刷新页面内容，同时避免重新加载页面。
- en: We also learned about Modal windows, using that technique to create comments. Of
    course, there is much more that could be done, such as a different experience
    of creating, deleting, or editing notes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了关于模态窗口，利用这种技术来创建评论。当然，还有很多其他事情可以做，比如不同的体验来创建、删除或编辑笔记。
- en: To support all this, we added another kind of data, the *message*, and an accompanying
    database table, managed by a new Sequelize schema. It is used for representing
    the comments our users can make on notes, but is general enough to be used in
    other ways.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持所有这些，我们添加了另一种数据，*消息*，以及一个由新的Sequelize模式管理的相应数据库表。它用于表示我们的用户可以在笔记上发表的评论，但也足够通用，可以用于其他用途。
- en: Socket.IO, as we've seen, gives us a rich foundation of events passing between
    server and client that can build multiuser, multichannel communication experiences
    for your users.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Socket.IO为我们提供了丰富的事件基础，可以在服务器和客户端之间传递事件，为用户构建多用户、多通道的通信体验。
- en: In the next chapter, we will look into Node.js application deployment on real
    servers. Running code on our laptop is cool, but to hit the big time, the application
    needs to be properly deployed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Node.js应用程序在真实服务器上的部署。在我们的笔记本上运行代码很酷，但要取得成功，应用程序需要得到适当的部署。
