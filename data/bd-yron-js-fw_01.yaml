- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Benefits of Different JavaScript Frameworks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同 JavaScript 框架的好处
- en: It has been over 25 years since JavaScript was first introduced into our web
    browsers. Since then, this technology has vastly changed how we interact with
    websites and applications, how we build APIs for backend systems, and even how
    we communicate with hardware platforms. JavaScript has become one of the most
    popular programming languages on the planet. To this day, JavaScript’s pace of
    evolution and rapid change is a popular topic of conversation among developers
    – it is a source of excitement and innovation. As a programming language, JavaScript
    has been ranked as the most popular among developers in the last 10 consecutive
    years and has been the key to client-side scripting for 98% of all websites. We
    cannot underestimate how much JavaScript and its closely related ECMAScript standardization
    have enabled the web to become the platform to host the next generation of software
    that can be accessed by billions of people. With these technologies, millions
    of businesses and individuals can easily build great applications, creative experiences,
    and complex software solutions. In many ways, the web platform has the potential
    to be the most vibrant and friendly developer ecosystem in the whole world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 JavaScript 首次被引入我们的网络浏览器以来，已经过去了 25 多年。从那时起，这项技术极大地改变了我们与网站和应用程序互动的方式，我们为后端系统构建
    API 的方式，甚至我们与硬件平台通信的方式。JavaScript 已经成为地球上最受欢迎的编程语言之一。时至今日，JavaScript 的演变速度和快速变化仍然是开发者之间热门的讨论话题——它是兴奋和创新的源泉。作为一种编程语言，JavaScript
    在过去 10 年中连续 10 年被开发者评为最受欢迎的语言，并且是 98% 的网站客户端脚本的关键。我们无法低估 JavaScript 及其紧密相关的 ECMAScript
    标准化如何使网络成为可以由数十亿人访问的下一代软件的平台。有了这些技术，数百万的企业和个人可以轻松构建出色的应用程序、创意体验和复杂的软件解决方案。在许多方面，网络平台有潜力成为全世界最充满活力和友好的开发者生态系统。
- en: JavaScript frameworks are the straightforward way millions of web developers
    build projects today. Due to their popularity and ease of use, frameworks allow
    developers to quickly make product ideas come to life without unnecessary overheads.
    Without the framework systems that we have at our disposal today, the web would
    not have been able to compete with other development platforms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 框架是数百万网络开发者今天构建项目的直接方式。由于它们的流行和易用性，框架允许开发者快速将产品想法变为现实，而无需不必要的开销。如果没有我们今天可用的框架系统，网络将无法与其他开发平台竞争。
- en: In this book, we will study the vast ecosystem and expand our knowledge to become
    confident in creating and maintaining our own self-developed frameworks. Developing
    the skill to build a framework or extend existing ones comes with the benefit
    of becoming an impactful domain expert in frontend and backend projects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将研究庞大的生态系统，并扩展我们的知识，以便在创建和维护我们自己的自开发框架时充满信心。掌握构建框架或扩展现有框架的技能，将使我们成为前端和后端项目中具有影响力的领域专家。
- en: As part of becoming experts in JavaScript frameworks, we need to get a sense
    of the core components and tools of the web development workflow. In this first
    chapter of the book, we will take a look at how web development evolved, how frameworks
    changed the landscape of working with JavaScript, and what the ecosystem currently
    has to offer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为成为 JavaScript 框架专家的一部分，我们需要了解网络开发工作流程的核心组件和工具。在本书的第一章中，我们将探讨网络开发是如何演变的，框架是如何改变与
    JavaScript 一起工作的格局的，以及当前生态系统提供了什么。
- en: 'We will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: The emergence of JavaScript frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 框架的出现
- en: The evolution of code bases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库的演变
- en: Types of frameworks in JavaScript and their benefits
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 中的框架类型及其好处
- en: My experiences with frameworks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我与框架的经历
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book has an accompanying GitHub repository at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    In each chapter, we will point to the relevant directories in this repository.
    Feel free to clone or download the repository as a ZIP file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附有 GitHub 仓库 [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework)。在每一章中，我们将指向该仓库中的相关目录。您可以随意克隆或下载该仓库的
    ZIP 文件。
- en: You need a desktop or a laptop computer with internet access and a terminal
    application to install and run the code from this repository. We shall also be
    utilizing Node.js to run some of the parts of the repository. Node.js is an open
    source, cross-platform, backend JavaScript runtime environment that runs JavaScript
    code outside a web browser. The installation for Node.js can be found at [nodejs.org](https://nodejs.org).
    For the code from the repository, you can use any environment that supports a
    terminal and runs Node.js, such as Windows, macOS, and most varieties of Linux.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个带有互联网访问权限的桌面或笔记本电脑以及终端应用程序来安装和运行此存储库中的代码。我们还将使用Node.js来运行存储库的一些部分。Node.js是一个开源的、跨平台的、后端JavaScript运行环境，可以在浏览器外运行JavaScript代码。Node.js的安装信息可以在[nodejs.org](https://nodejs.org)找到。对于存储库中的代码，您可以使用任何支持终端和运行Node.js的环境，例如Windows、macOS和大多数Linux版本。
- en: The emergence of JavaScript frameworks
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript框架的出现
- en: As JavaScript progressed and evolved, the innovators who were heavily involved
    in the language, both companies and individuals, started writing software libraries
    to help solve the everyday burdens of web application architectures. The initial
    focus of the most basic JavaScript libraries was to provide singular features,
    interactivity, and add-ons, which progressively enhanced the web page. At that
    time, JavaScript gave life to a static page with its interactive components –
    simple examples that always come to mind are tiny scripts, which enabled creative
    button effects and mouse cursor effects. In many cases, these scripts were separate
    from the site’s core functionality and were not essential to allow users to interact
    with the content. Since the inception of small libraries, these have paved the
    way for the complex framework systems that we have today. The frontend technology
    quickly evolved, and now, developers are much more accustomed to megabytes of
    scripts powering the frontend code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript的进步和演变，那些在语言中投入大量精力，无论是公司还是个人，的创新者开始编写软件库来帮助解决Web应用程序架构的日常负担。最基本的JavaScript库的初始重点是提供单一功能、交互性和附加功能，这些功能逐渐增强了网页。当时，JavaScript通过其交互组件赋予了静态页面生命——总是浮现在脑海中的简单例子是微小的脚本，这些脚本使得创意按钮效果和鼠标光标效果成为可能。在许多情况下，这些脚本与网站的核心功能是分开的，并且不是用户与内容交互所必需的。自从小型库的诞生以来，这些库为今天我们所拥有的复杂框架系统铺平了道路。前端技术迅速发展，现在，开发者们更加习惯于数兆字节的脚本驱动前端代码。
- en: JavaScript libraries were the next step in the web development evolution, assisting
    with cross-browser quirks, complex visual effects, network requests, and web page
    layout. With the use of these libraries, developers were able to have the cross-browser
    development challenges under control. CSS started to catch up with its focus on
    layout features and cross-browser standards, improving the web’s styling features.
    Developers finally began introducing structure and well-crafted systems into web
    development.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript库是Web开发演变的下一步，帮助解决跨浏览器怪癖、复杂视觉效果、网络请求和网页布局。使用这些库，开发者能够控制跨浏览器开发挑战。CSS开始关注布局功能和跨浏览器标准，改善了Web的样式功能。开发者最终开始将结构和精心设计的系统引入Web开发。
- en: The time has come to finally focus on building scalable and opinionated software
    on the web, and this is where we began to see glimpses of complex software paradigms
    introduced into large websites and web applications. Companies and larger enterprises
    started treating the web as a serious application platform, which led to a few
    prominent projects written in JavaScript and compiled to JavaScript from languages
    such as Java. Tracing back to late 2009, we see the first iterations of **Model-View-Controller**
    (**MVC**) frameworks built entirely with HTML, CSS, and JavaScript. This MVC model
    allows more extensive projects to stay organized, enriches the development workflow,
    and opens up the world of frontend development to developers who expect a much
    more structured approach when writing software. The MVC model fit web applications
    well enough to spawn a renaissance in framework development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于构建可扩展且具有意见的Web软件的时代终于到来了，这正是我们开始看到复杂软件范式被引入大型网站和Web应用的曙光。公司和大型企业开始将Web视为一个严肃的应用平台，这导致了一些以JavaScript编写并从Java等语言编译到JavaScript的突出项目。回顾到2009年末，我们看到了完全使用HTML、CSS和JavaScript构建的第一个**模型-视图-控制器**（**MVC**）框架的迭代。这种MVC模型允许更广泛的项目保持组织性，丰富了开发工作流程，并为期望在编写软件时采用更结构化方法的开发者打开了前端开发的世界。MVC模型与Web应用配合得足够好，以至于催生了框架开发的复兴。
- en: 'Many development hours were invested into connecting the mechanisms between
    the JavaScript engines and the browser web APIs. In *Figure 1**.1*, we see a simplified
    view of how this interaction happens:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发时间都投入到了连接JavaScript引擎和浏览器Web API之间的机制中。在*图1*.1中，我们可以看到这种交互发生的简化视图：
- en: '![Figure 1.1: Interaction between the JavaScript engine and web APIs](img/Figure_1.1_B19014.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：JavaScript引擎与Web API之间的交互](img/Figure_1.1_B19014.jpg)'
- en: 'Figure 1.1: Interaction between the JavaScript engine and web APIs'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：JavaScript引擎与Web API之间的交互
- en: The framework code and its internal technologies, such as the virtual DOM, use
    the DOM and its components to make the web application experience possible. The
    web has its own approach to the MVC architecture, with DOM and web API events
    interacting with Controllers defined in JavaScript. The Controllers interface
    with Views written in HTML or templated HTML. Furthermore, in this paradigm, the
    components of the applications utilize a Model to model the data within them.
    Using this approach, we can later communicate with backend services to retrieve
    the data in a particular manner.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 框架代码及其内部技术，如虚拟DOM，使用DOM及其组件来使Web应用体验成为可能。Web有其自己的MVC架构方法，其中DOM和Web API事件与JavaScript中定义的控制器交互。控制器与用HTML或模板HTML编写的视图接口。此外，在这个范式下，应用组件利用模型来模拟其内部的数据。使用这种方法，我们可以在以后与后端服务通信，以特定方式检索数据。
- en: Each new JavaScript MVC framework tried to perfect its implementation or approach
    in various ways. About five years after the first MVC frameworks appeared and
    gained popularity, several new paradigms that focused on the **observer** software
    design pattern started gaining traction in the JavaScript community. This observer
    approach is a software design pattern in which an object maintains a list of its
    dependants, called observers. The object notifies the observers automatically
    of the state changes within it. At that time, **Flux** came about, which is an
    application architecture that concentrates on simplifying the hurdles faced within
    MVC. The burdens included dealing with views constantly needing to interact with
    the models, hard-to-debug, deeply nested logic, and the need for adequate testing
    solutions of complex applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的JavaScript MVC框架都试图以各种方式完善其实现或方法。在第一个MVC框架出现并获得普及后的约五年，几个专注于**观察者**软件设计模式的新范式开始在JavaScript社区中受到关注。这种观察者方法是一种软件设计模式，其中对象维护一个其依赖者的列表，称为观察者。对象会自动通知观察者其内部状态的变化。那时，**Flux**应运而生，这是一种专注于简化MVC内部障碍的应用架构。这些障碍包括处理视图不断需要与模型交互、难以调试的深层嵌套逻辑，以及需要为复杂应用提供充分的测试解决方案。
- en: In the observer pattern, we define subjects that include a collection of observers
    informing about state changes. The Flux architecture expanded this existing pattern
    to fit better with applications built on the web. In the case of the Flux pattern,
    it consists of **stores** interacting with the state of a component. These stores
    get notified by a **dispatcher** based on data coming from **actions** that a
    user in the **view** took. Many JavaScript frameworks started adapting this pattern,
    ultimately simplifying how engineers structured their applications while still
    enforcing a set of applicable rules to keep the separation of concerns intact.
    The software patterns in all of these frameworks provide a clear separation of
    concerns between the interface, data model, and the application logic that integrates
    them. The Flux-based JavaScript frameworks introduced new concepts that emerged
    from the known MVC patterns. Still, both the MVC and Flux approaches focused on
    the principle of the separation of concerns in application development.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察者模式中，我们定义了包含一组通知状态变化的观察者的主题。Flux架构将这个现有的模式扩展，以更好地适应基于Web的应用程序。在Flux模式的情况下，它包括与组件状态交互的**存储**。这些存储根据来自**视图**中用户的**动作**产生的数据由**调度器**通知。许多JavaScript框架开始采用这种模式，最终简化了工程师构建应用程序的方式，同时仍然强制执行一套适用规则以保持关注点的分离。所有这些框架中的软件模式在接口、数据模型和整合它们的程序逻辑之间提供了清晰的关注点分离。基于Flux的JavaScript框架引入了从已知MVC模式中出现的新的概念。然而，MVC和Flux方法都侧重于应用程序开发中的关注点分离原则。
- en: Furthermore, while simplifying ideas brought to light by Flux, a library called
    Redux inspired the next generation of frameworks to switch their approach to application
    state management. Instead of the Flux dispatchers, Redux frameworks rely on a
    single store with pure **reducer** functions, taking the current state and returning
    an updated state. Even today, frontend patterns are still maturing, and building
    for the web platform is becoming increasingly easier.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在简化Flux提出的思想的同时，一个名为Redux的库启发了下一代框架改变它们的应用状态管理方法。与Flux调度器不同，Redux框架依赖于一个单一的存储，使用纯**reducer**函数，接受当前状态并返回一个更新后的状态。即使今天，前端模式仍在成熟，为Web平台构建正变得越来越容易。
- en: While there’s a lot to mention with regard to frontend technologies, JavaScript
    has also made a great impact in places outside of web browsers. We cover those
    areas in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有很多关于前端技术的方面可以提及，JavaScript也在Web浏览器之外的地方产生了巨大的影响。我们将在下一节中介绍这些领域。
- en: Frameworks outside the web browser
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器外部的框架
- en: Another monumental event during the appearance of the first frontend frameworks
    was the emergence of a new open source runtime called Node.js. Node.js allowed
    developers to use JavaScript to produce server-side scripts, deploy backend systems,
    build developer tools, and, more importantly, write frameworks using the same
    language as the one from the web browser. The unique combination of having JavaScript
    on both sides of the software stack created immense possibilities for software
    developers. This runtime has since spread into many directions beyond software
    applications, with frameworks for desktop application development, hardware I/O
    solutions, and much more.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个前端框架出现期间，另一个具有里程碑意义的事件是出现了一个名为Node.js的新开源运行时。Node.js允许开发者使用JavaScript来生成服务器端脚本、部署后端系统、构建开发者工具，更重要的是，使用与浏览器相同的语言编写框架。软件栈两端的JavaScript的独特组合为软件开发者创造了巨大的可能性。这个运行时随后扩展到许多超出软件应用的方向，包括桌面应用程序开发、硬件I/O解决方案等等。
- en: JavaScript-built frameworks enabled the web platform to become one of the most
    important technologies within reach of billions of people. It’s almost impossible
    to imagine starting a new project without relying on the consistency and amiability
    of using a framework, and even the smallest tasks benefit significantly from using
    a cohesive and opinionated structure. However, even with the fast-paced evolution
    of the language and how we build web projects, it took quite a bit of time for
    JavaScript frameworks to emerge as fully encapsulated platforms that can aid developers
    in producing efficient applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript 构建的框架使得网络平台成为数十亿人可触及的最重要技术之一。几乎无法想象在没有依赖框架的一致性和友好性的情况下开始一个新项目，即使是微小的任务也能从使用一个统一且具有观点的结构中受益显著。然而，尽管语言和构建网络项目的方式发展迅速，JavaScript
    框架作为完全封装的平台来帮助开发者生产高效应用，这一过程还是花费了相当长的时间。
- en: JavaScript prevailed through the rise of mobile platforms, with multiple frameworks
    being created for mobile and existing systems integrating mobile benchmarks into
    their release process. The optimizations got to the hardware level, having the
    **ARM** ([arm.com](https://arm.com)) processor architecture introduce optimizations
    to improve JavaScript performance in data type conversion, resulting in performance
    boosts for many JavaScript applications. That is quite a journey for a scripting
    language that started with small scripts on plain web pages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 mobile 平台的发展，JavaScript 取得了胜利，为移动和现有系统创建了多个框架，并将移动基准测试整合到其发布流程中。优化已经达到了硬件级别，**ARM**
    ([arm.com](https://arm.com)) 处理器架构引入了优化，以改善数据类型转换中的 JavaScript 性能，从而为许多 JavaScript
    应用程序带来性能提升。这对于一个始于普通网页上的小脚本的脚本语言来说，确实是一段漫长的旅程。
- en: Today, we can create fully fledged applications and services using the web platform
    by combining the power of web APIs, the JavaScript language, and technologies
    such as progressive web apps, using the frameworks that bring it all together.
    It is a fantastic time to start traversing the world of these JavaScript systems
    and using them to our advantage.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们可以通过结合 Web API 的力量、JavaScript 语言以及像渐进式 Web 应用这样的技术，使用将这些所有元素整合在一起的框架，来创建完整的应用和服务。这是开始探索这些
    JavaScript 系统的世界并利用它们为我们带来优势的绝佳时机。
- en: Now that we have an overview of how web development evolved, let’s take a look
    at how the code bases have changed over time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经对网络开发的发展有了概述，让我们来看看代码库是如何随时间变化的。
- en: The evolution of code bases
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码库的演变
- en: While learning about frameworks, it is fascinating to reflect on how building
    for the web has changed over time. This exploration helps us understand why we
    build web applications the way we do today and helps us learn from historical
    shifts. It also allows us to be more mindful concerning framework usability and
    development decisions when we take on large projects. As technology pushes forward,
    the requirements and expectations around how websites and web applications are
    built drastically change. Depending on how long someone has been involved in web
    development, they either experienced many rapidly evolving shifts to how the code
    bases are structured or were lucky enough to avoid the times when the tooling
    and the process were highly tedious.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习框架的同时，回顾构建网络的方式是如何随时间变化的，是非常有趣的。这种探索帮助我们理解为什么我们今天以这种方式构建 Web 应用程序，并帮助我们从历史转变中学习。它还允许我们在承担大型项目时，对框架的可用性和开发决策更加谨慎。随着技术的进步，围绕网站和
    Web 应用程序构建的要求和期望发生了巨大变化。根据一个人参与 Web 开发的时间长短，他们要么经历了代码库结构快速演变的许多转变，要么幸运地避开了工具和流程非常繁琐的时期。
- en: Initially, the code bases comprised isolated frontend components stitched together,
    consisting of code repetition and mixes of coding patterns. Code organization,
    usage of software development patterns, and performance optimizations were not
    a primary focus for developers. The web application deployment process used to
    be rudimentary as well. In many cases, the websites were manually updated and
    did not use source control or version tracking. Testing was also highly manual
    and would only exist in a few projects that were large enough to enable it. This
    was before deployment pipelines with continuous integration, deployment automation,
    and advanced testing infrastructure, rigorously verified every change. There used
    to be a time when developers had to optimize their CSS selectors for performance
    reasons.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，代码库由独立的客户端组件拼接而成，包含代码重复和编码模式的混合。代码组织、软件开发模式的运用和性能优化并不是开发者关注的重点。Web 应用程序的部署过程也相对简单。在许多情况下，网站是手动更新的，没有使用源代码控制或版本跟踪。测试也高度手动，并且仅在少数足够大的项目中存在，以便进行测试。这还是在部署管道、持续集成、部署自动化和高级测试基础设施严格验证每个变更之前。曾经有一段时间，开发者必须为了性能原因优化他们的
    CSS 选择器。
- en: Luckily, productivity and workflows rapidly started to improve once the industry
    started focusing more on building complex applications. Today we have source control,
    we have a myriad of testing and deployment tools to choose from, and we have established
    software paradigms that considerably improve our lives as developers and vastly
    improve the quality of the projects we build. Improvements to JavaScript engines
    unlocked new pathways for frameworks, and enhancements to web browsers fixed slow
    DOM interactivity with techniques such as the **virtual DOM**, **Shadow DOM**,
    and **Web Components**. These days, frontend frameworks have a better client platform
    to target as well, and the more established and improved web standards make it
    possible to perform much more complex operations. For example, with the help of
    WebAssembly ([webassembly.org](https://webassembly.org)) standards, we can now
    run low-level code with improved performance, all within the browser.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，随着行业开始更多地关注构建复杂应用程序，生产力和工作流程迅速开始提高。今天，我们有源代码控制，我们有众多测试和部署工具可供选择，我们建立了软件范式，这些范式大大提高了我们的生活质量，并极大地提高了我们构建的项目质量。JavaScript
    引擎的改进为框架开辟了新的途径，而网络浏览器的改进则通过如 **虚拟 DOM**、**Shadow DOM** 和 **Web Components** 等技术解决了慢速
    DOM 交互问题。如今，前端框架有更好的客户端平台可以针对，而更成熟和改进的网络标准使得执行更复杂的操作成为可能。例如，借助 WebAssembly ([webassembly.org](https://webassembly.org))
    标准，我们可以在浏览器中运行低级代码，并实现性能的提升。
- en: 'As part of all these developments and growth in popularity, the web application
    development workflow got a lot more complex in many ways. Almost at every point
    of interaction with a web application project, there is a tooling set designed
    to improve our workflow. Some examples of this would be Git source control, various
    pre- and post-processors of our files, code editors with plugins, browser extensions,
    and many more. Here we have an example that illustrates the key components of
    a modern web application code base structure, in this case, generated by **SvelteKit**:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为所有这些发展和流行度增长的一部分，Web 应用程序开发工作流程在许多方面变得更加复杂。几乎在每次与 Web 应用程序项目互动的每个点上，都有一个工具集旨在改进我们的工作流程。这方面的例子包括
    Git 源代码控制、各种文件的前后处理器、带有插件的代码编辑器、浏览器扩展等。这里有一个示例，说明了现代 Web 应用程序代码库结构的关键组件，在这种情况下，是由
    **SvelteKit** 生成的：
- en: '![Figure 1.2: SvelteKit code base structure](img/Figure_1.2_B19014.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：SvelteKit 代码库结构](img/Figure_1.2_B19014.jpg)'
- en: 'Figure 1.2: SvelteKit code base structure'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：SvelteKit 代码库结构
- en: We will go over SvelteKit later in the *Frameworks that use React* section of
    this chapter, and even if you have never used Svelte, this project file tree will
    look very familiar if you work with other frameworks. This dynamic structure of
    tools enables flexibility when it comes to switching out certain functionality.
    For example, *Prettier* can be substituted for another code formatting tool if
    need be, while the rest of the project structure remains the same and functions
    as it was.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的“使用 React 的框架”部分稍后介绍 SvelteKit，即使你从未使用过 Svelte，如果你与其他框架一起工作，这个项目文件结构看起来也会非常熟悉。这种工具的动态结构使得在更换某些功能时具有灵活性。例如，如果需要，可以用另一个代码格式化工具替换
    *Prettier*，而项目的其余结构保持不变，并按原样运行。
- en: With the establishment of the first frameworks in JavaScript, we experienced
    the introduction of a build step into our projects, which meant that either external
    or bundled tooling would help run or build the application. Today, this build
    step, popularized by **Webpack** or **esbuild**, is almost impossible to avoid.
    As part of this build step, we fetch application dependencies using package managers,
    process CSS, create code bundles, and run various optimization steps to make our
    app run fast and consume the least bandwidth. The ecosystem also introduced JavaScript
    transpilers, which are a type of source-to-source code compiler. They are used
    to take one particular syntax, which could consist of more modern features or
    include additional features, and convert them to be compatible with broadly accepted
    JavaScript syntax. Transpilers, such as **Babel**, began to see everyday use,
    integrated with the build step in many projects; this pattern generally motivated
    the use of the latest language features while also supporting old browser engines.
    These days, transpilation and build steps apply to files beyond JavaScript, as
    well as files such as CSS and specific templating formats.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript中第一个框架的建立，我们经历了构建步骤被引入到我们的项目中，这意味着外部或捆绑的工具将帮助运行或构建应用程序。今天，这个由**Webpack**或**esbuild**普及的构建步骤几乎无法避免。作为构建步骤的一部分，我们使用包管理器获取应用程序依赖项，处理CSS，创建代码包，并运行各种优化步骤，使我们的应用程序运行得更快，消耗最少的带宽。生态系统还引入了JavaScript转译器，这是一种源到源代码的编译器。它们用于将一种特定的语法（可能包含更现代的功能或包括额外的功能）转换为广泛接受的JavaScript语法。转译器，如**Babel**，开始被日常使用，并在许多项目中与构建步骤集成；这种模式通常促使人们使用最新的语言功能，同时也支持旧的浏览器引擎。如今，转译和构建步骤不仅适用于JavaScript文件，还适用于CSS和特定的模板格式文件。
- en: Integrating with the build step are the package managers, such as `npm` or `yarn`,
    which play an essential role in resolving project dependencies. If you want to
    bootstrap a workflow with a framework, you will likely rely on the package manager
    to initialize the framework structure and its dependencies. For new projects,
    it is almost impossible to have a sensible framework workflow without using a
    package manager or some form of dependency resolution. As the project grows, the
    package manager facilitates the organization of newer dependencies while keeping
    track of updates to modules that are already in use. These days text editors,
    such as Visual Studio Code and IntelliJ WebStorm, adapt to our code bases and
    provide excellent tooling to enable source control of our code. The editors rely
    on built-in features and external plugins that encourage better formatting, easier
    debugging, and framework-specific improvements.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与构建步骤集成的是包管理器，如`npm`或`yarn`，它们在解决项目依赖关系方面发挥着至关重要的作用。如果你想使用框架启动工作流程，你可能会依赖包管理器来初始化框架结构和其依赖项。对于新项目来说，如果不使用包管理器或某种形式的依赖关系解析，几乎不可能有一个合理的框架工作流程。随着项目的增长，包管理器有助于组织新的依赖项，同时跟踪已使用模块的更新。如今，文本编辑器，如Visual
    Studio Code和IntelliJ WebStorm，适应我们的代码库，并提供出色的工具，使我们能够实现代码的源代码控制。这些编辑器依赖于内置功能和外部插件，鼓励更好的格式化、更简单的调试以及针对特定框架的改进。
- en: The code bases will keep changing as technology develops further, and the tools
    will keep improving to enable us to develop applications more quickly. Regarding
    the framework organization, we can expect higher levels of abstractions that simplify
    the way we do web development. Many programming languages, such as Java and Swift,
    have pre-defined development workflows encapsulating all aspects of development.
    JavaScript code bases so far have been an exception to these rules and allowed
    for high levels of flexibility. This trend is going to continue for many more
    years as the rapid pace of tooling and innovation in web development is not slowing
    down at all.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术的进一步发展，代码库将不断变化，工具也将持续改进，以便我们能够更快地开发应用程序。关于框架组织，我们可以期待更高层次的抽象，这将简化我们的Web开发方式。许多编程语言，如Java和Swift，都有预定义的开发工作流程，封装了开发的所有方面。迄今为止，JavaScript代码库一直是这些规则的例外，并允许高度灵活性。随着Web开发工具和创新的快速步伐并未放缓，这一趋势还将持续许多年。
- en: Now that we understand how the JavaScript ecosystem has evolved and how codebases
    have changed over time, let us explore what JavaScript frameworks offer in terms
    of frontend, backend, testing, and beyond.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JavaScript生态系统是如何演变的，以及代码库是如何随时间变化的，让我们来探讨JavaScript框架在前端、后端、测试等方面的提供内容。
- en: Types of JavaScript frameworks and their benefits
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript框架的类型及其好处
- en: Though it is challenging to compare all the subtle differences of every framework
    out there in the ecosystem, we can cover several frameworks that significantly
    impact the developer community or offer a unique approach to solving a particular
    problem. The expanded knowledge of the tools helps us notice specific patterns
    in these frameworks regarding the different strategies for developer experience
    and feature sets.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在生态系统中比较每个框架的细微差异具有挑战性，但我们仍可以涵盖几个对开发者社区产生重大影响或提供独特解决方案的框架。对工具的深入了解帮助我们注意到这些框架中关于开发者体验和功能集的不同策略的具体模式。
- en: There are still ways to build apps and websites without frameworks, but many
    developers prefer to use established and opinionated frameworks even with the
    given overhead and learning curves. If you follow the JavaScript community, you
    will find that it is always passionately abuzz with discussions around frameworks,
    so let us dive deeper into the needs and benefits of framework use.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有方法在不使用框架的情况下构建应用程序和网站，但许多开发者即使考虑到额外的开销和学习曲线，也更倾向于使用成熟且具有观点的框架。如果你关注JavaScript社区，你会发现它总是充满热情地讨论着框架，因此让我们更深入地探讨框架使用的需求和好处。
- en: The frameworks provide good levels of abstraction to write high-level code without
    rewriting low-level functionality. Developers can be much more involved in business
    and product logic and iterate faster on new features. To give an example, up until
    recently, writing the code to make an asynchronous web request with proper error
    handling was a very time-consuming task without the aid of a good abstraction.
    Now that we have the Fetch API ([fetch.spec.whatwg.org](https://fetch.spec.whatwg.org)),
    this is a much easier endeavor, but Fetch is only part of the story, so the rest
    of the web APIs, especially the ones from earlier times, still benefit from good
    abstractions. In cases where we choose to write low-level code, it is a much better
    approach to find ways to write that code within the framework boundaries. This
    way it is tested and maintained within the primitives of the framework. This yields
    the benefits of avoiding extra maintenance and ensuring all the usages of that
    code are still behind sensible abstractions. Some backend frameworks approach
    this by providing extensible interfaces to hook into framework internals through
    plugins or extending the default behavior.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 框架提供了良好的抽象级别，可以在不重写底层功能的情况下编写高级代码。开发者可以更多地参与到业务和产品逻辑中，并更快地迭代新功能。以一个例子来说，直到最近，在没有良好抽象的帮助下编写带有适当错误处理的异步Web请求的代码是一项非常耗时的工作。现在有了Fetch
    API ([fetch.spec.whatwg.org](https://fetch.spec.whatwg.org))，这变得容易多了，但Fetch只是故事的一部分，所以其他Web
    API，尤其是早期的一些，仍然受益于良好的抽象。在我们选择编写底层代码的情况下，找到在框架边界内编写该代码的方法是一个更好的方法。这样，代码就在框架的基本原理中得到测试和维护。这避免了额外的维护，并确保所有该代码的使用都仍然在合理的抽象之下。一些后端框架通过提供可扩展的接口来实现这一点，通过插件或扩展默认行为来钩入框架内部。
- en: Developing software with groups of people is a challenging endeavor, so small
    and large teams can benefit from integrating a framework into the engineering
    workflow. The provided structure of abstractions generally results in much more
    well-architected systems, given the limits of how developers can write high-level
    components. The key benefit is enabling everyone involved in the task to understand
    the code base better and conveniently spend less time deliberating refactors and
    adding new code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与团队一起开发软件是一项具有挑战性的任务，因此小型和大型团队都可以从将框架集成到工程工作流程中受益。提供的抽象结构通常会导致更完善的系统，考虑到开发者编写高级组件的限制。关键好处是使所有参与任务的人都能更好地理解代码库，并方便地减少在重构和添加新代码上的深思熟虑时间。
- en: Now that we have our abstracted high-level code, we can cherish another benefit
    of frameworks – the performance optimizations they enable. Writing performant
    code that works in all provided use cases takes skill and takes away significant
    time from the project at hand. Even the most knowledgeable developers would only
    be able to come up with good enough solutions in a short amount of time. With
    frameworks, especially open source ones, you benefit from many minds put together
    to solve performance bottlenecks, overcome typical encumbrances, and continue
    to benefit from improvements as the framework develops. The performance benefits
    come from optimized low-level and well-structured high-level components; notably,
    some frameworks will guard against code that will slow down the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了抽象的高级代码，我们可以珍惜框架的另一个好处——它们所提供的性能优化。编写适用于所有提供用例的性能代码需要技能，并且会从当前项目上消耗大量时间。即使是最有知识的开发者，在短时间内也只能提出足够好的解决方案。有了框架，尤其是开源框架，你可以从许多人的智慧中受益，解决性能瓶颈，克服典型障碍，并在框架发展的过程中继续受益。性能优势来自于优化的低级和结构良好的高级组件；值得注意的是，一些框架会防止降低应用程序速度的代码。
- en: Frameworks make integrating with external systems, such as databases, external
    APIs, or specific components, easier. For instance, some web frameworks can integrate
    directly with the GraphQL data query language, simplifying backend systems’ interaction.
    It’s not just the ease of use, but also these integrations enable safe interaction
    with components such as databases, which helps avoid problematic queries that
    can be slow or harmful to execute. For frontend projects, it is important to always
    keep up with the latest web standards, and this is where frameworks provide another
    integration benefit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 框架使得与外部系统（如数据库、外部API或特定组件）的集成更加容易。例如，一些Web框架可以直接与GraphQL数据查询语言集成，简化后端系统的交互。这不仅是因为使用方便，而且这些集成使得与数据库等组件的安全交互成为可能，有助于避免可能执行缓慢或有害的查询。对于前端项目，始终跟上最新的Web标准非常重要，这正是框架提供另一个集成优势的地方。
- en: Finally, as with all software, support plays an important role. Another reason
    a project may use an established framework is the available support channels through
    paid, volunteer, and open source help. The shared knowledge of these systems enables
    developers to help each other build systems and makes it easier to hire new developers
    who are familiar with these existing systems.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像所有软件一样，支持发挥着重要作用。一个项目可能使用成熟框架的另一个原因是可用的支持渠道，包括付费、志愿者和开源的帮助。这些系统的共享知识使得开发者能够互相帮助构建系统，并使得雇佣熟悉这些现有系统的新开发者变得更加容易。
- en: 'As we see, frameworks benefit us in countless ways – let us recap with these
    exact reasons. Here’s what frameworks allow us to do:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，框架以无数的方式为我们带来好处——让我们用这些确切的原因来回顾一下。以下是框架允许我们做的事情：
- en: Focus on business logic and writing high-level code
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于业务逻辑和编写高级代码
- en: Write less code and follow code conventions defined by the framework
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写更少的代码并遵循框架定义的代码约定
- en: Benefit from performance gains and rely on future optimizations
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从性能提升中受益并依赖未来的优化
- en: Develop the project with good architecture, abstractions, and organization
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以良好的架构、抽象和组织开发项目
- en: Easily integrate with external systems such as databases and external APIs
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易与数据库和外部API等外部系统集成
- en: Ability to rely on security fixes, audits, and patches
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够依赖安全修复、审计和补丁
- en: Improve developer workflow using framework-specific toolings, such as text-editor
    integrations and command-line utilities
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用框架特定的工具（如文本编辑器集成和命令行实用程序）改进开发者工作流程
- en: Ability to debug issues easily by relying on detailed error messages and consistent
    logging
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够通过依赖详细的错误信息和一致的日志轻松调试问题
- en: Rely on external support from framework authors and the community
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖框架作者和社区的额外支持
- en: Hire more developers who are already accustomed to working with the framework
    of our choice or with similar experience
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 招聘已经习惯于使用我们选择的框架或具有类似经验的开发者
- en: Develop better user experiences by leveraging the framework feature set
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用框架的功能集开发更好的用户体验
- en: While a lot of JavaScript frameworks focus on the developer experience, the
    user experience can sometimes suffer from the overhead of these systems. This
    is usually relevant in frontend projects – an example of this would be loading
    a complex web application on budget mobile devices. In backend systems, this can
    be seen when the APIs are not able to keep up with request load and reliably scale
    with traffic spikes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多JavaScript框架专注于开发者体验，但用户体验有时会因这些系统的开销而受到影响。这通常在前端项目中相关——一个例子就是在预算有限的移动设备上加载复杂的Web应用程序。在后端系统中，这可以在API无法跟上请求负载并可靠地与流量峰值同步时看到。
- en: Even if the systems are skillfully built in both of these cases, the framework
    of choice might not be optimized to cover all use cases. I believe the next iteration
    of the framework ecosystem will largely focus on the user experience aspects,
    which means making load times faster, shipping less JavaScript over the network,
    and ensuring the web applications we create work seamlessly on all platforms.
    In the following sections, we will examine some of the most popular frameworks
    that enable these benefits for web application developers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这两种情况下系统都巧妙地构建，所选框架可能并不优化以覆盖所有用例。我相信框架生态系统的下一版本将主要关注用户体验方面，这意味着加快加载时间，减少通过网络传输的JavaScript，并确保我们创建的Web应用程序能够在所有平台上无缝运行。在接下来的章节中，我们将探讨一些最受欢迎的框架，这些框架为Web应用程序开发者提供了这些好处。
- en: Frontend frameworks
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端框架
- en: Since JavaScript frameworks originated in the browser, let us look at modern
    frontend frameworks as our first exploration.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript框架起源于浏览器，让我们将现代前端框架作为我们的第一次探索。
- en: Ember.js
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ember.js
- en: Suppose we trace the roots of the first JavaScript frameworks through the origins
    of libraries such as `Prototype.js`, `jQuery`, and `script.aculo.us`. In that
    case, we will eventually arrive at **SproutCore**, a framework used by Apple and
    a handful of other companies to build some of the most complex web experiences
    many years ago.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们通过`Prototype.js`、`jQuery`和`script.aculo.us`等库的起源追溯第一个JavaScript框架的根源。在这种情况下，我们最终会到达**SproutCore**，这是一个被苹果公司和少数其他公司用来在多年前构建一些最复杂Web体验的框架。
- en: Today this early SproutCore project has influenced the **Ember.js** framework.
    Ember continues to be a highly opinionated piece of software that allows us to
    build applications with defined components, services, models, and a powerful router.
    Like many frameworks we will discuss in this chapter, Ember comes with its own
    command-line tooling, which helps developers quickly get started on the basics
    of the application and later generate more code quickly as the project scope grows.
    The usefulness of the provided framework tooling is immense. The CLI encapsulates
    the code generation steps and enables a way to run common framework commands,
    such as running tests or serving application files. With Ember, developers get
    a complete set of tools such as auto-reload, browser developer tooling, and a
    package called Ember Data, which helps manage the API-to-model relationship through
    adapters and serializers. Ultimately, Ember has a steeper learning curve than
    other frameworks, but its highly opinionated concepts guide developers toward
    highly functional web applications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，这个早期的SproutCore项目已经影响了**Ember.js**框架。Ember继续是一款具有高度意见的软件，允许我们使用定义良好的组件、服务、模型和强大的路由器来构建应用程序。像本章中我们将讨论的许多框架一样，Ember自带命令行工具，这有助于开发者快速入门应用程序的基础，并在项目范围扩大后快速生成更多代码。提供的框架工具的实用性巨大。CLI封装了代码生成步骤，并允许运行常见的框架命令，例如运行测试或提供应用程序文件。使用Ember，开发者可以获得一套完整的工具，如自动重新加载、浏览器开发者工具以及一个名为Ember
    Data的包，该包通过适配器和序列化器帮助管理API到模型的关系。最终，Ember的学习曲线比其他框架更陡峭，但其高度意见的概念引导开发者构建高度功能的Web应用程序。
- en: Angular
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular
- en: '**Angular** is another framework with a large following. With TypeScript at
    its core, it is often used as a subset system for other full stack web frameworks.
    Angular provides its opinionated approach to component-based architecture. Angular
    has a complex history of rewrites but is now a more streamlined project with a
    stable feature set. Angular’s template syntax extends HTML by adding expressions
    and new attributes. At its core, it uses the pattern of dependency injection.
    The latest versions of this framework offer a variety of binding techniques, including
    event, property, and two-way binding.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular** 是另一个拥有大量追随者的框架。以其核心的 TypeScript 为基础，它通常被用作其他全栈 Web 框架的子集系统。Angular
    提供了其基于组件架构的见解方法。Angular 有一个复杂的重写历史，但现在它是一个更精简的项目，具有稳定的特性集。Angular 的模板语法通过添加表达式和新属性扩展了
    HTML。在其核心，它使用依赖注入的模式。该框架的最新版本提供了各种绑定技术，包括事件、属性和双向绑定。'
- en: Vue.js
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vue.js
- en: '**Vue.js**, also written in TypeScript, was created by borrowing the good elements
    of Angular. Developers love Vue’s simplicity within its component system, syntax,
    and general ease of use. It utilizes the **Model–View–Viewmodel** (**MVVM**) pattern,
    where a View communicates with a ViewModel using some data binding technique.
    In the case of Vue.js, for its data, it uses different techniques through HTML
    classes, HTML elements, and custom binding element attributes to achieve this.
    The purpose of the given ViewModel is to handle as much of the View’s interaction
    logic and be the middle structure between the presentation logic and the application’s
    business logic. Besides using HTML authoring, Vue has the **Single-File Component**
    (**SFC**) format ([vuejs.org/api/sfc-spec.html](https://vuejs.org/api/sfc-spec.html))
    to encapsulate all aspects of the components – scripts, styling, and templating
    into one file. The SFC happens as part of the build step and helps the components
    avoid runtime compilation, scopes the CSS styles to the component, enables Hot
    Module Replacement, and much more.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vue.js**，也是用 TypeScript 编写的，是通过借鉴 Angular 的优点而创建的。开发者喜欢 Vue 在其组件系统、语法和一般使用上的简单性。它利用了
    **模型-视图-视图模型**（**MVVM**）模式，其中视图通过某种数据绑定技术与视图模型进行通信。在 Vue.js 的例子中，对于其数据，它通过 HTML
    类、HTML 元素和自定义绑定元素属性使用不同的技术来实现这一点。给定视图模型的目的在于处理尽可能多的视图交互逻辑，并在表示逻辑和应用业务逻辑之间充当中间结构。除了使用
    HTML 编写，Vue 还具有 **单文件组件**（**SFC**）格式（[vuejs.org/api/sfc-spec.html](https://vuejs.org/api/sfc-spec.html)），将组件的所有方面——脚本、样式和模板——封装到一个文件中。SFC
    作为构建步骤的一部分发生，有助于组件避免运行时编译，将 CSS 样式限制在组件范围内，启用热模块替换，以及更多。'
- en: About TypeScript
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 TypeScript
- en: '`.ts` and `.tsx` are TypeScript files that must be compiled to JavaScript to
    be used in most environments.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ts` 和 `.tsx` 是 TypeScript 文件，必须在大多数环境中编译成 JavaScript 才能使用。'
- en: Frameworks that use React
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 React 的框架
- en: These days, we hear about **React** a lot; even though it is a user interface
    component library by itself, it has become the cornerstone for many frontend frameworks,
    such as **Gatsby**, **Remix**, **Next.js**, and others. As part of its introduction,
    React also debuted **JSX**, its own set of extensions to JavaScript, making it
    possible to define the components in a similar-looking syntax to HTML. For instance,
    the static site framework Gatsby relies on React’s state management and the nested
    component architecture to compose its web pages. With Gatsby, developers can multiplex
    data, utilizing GraphQL, from content management systems, e-commerce sources,
    and other places.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，我们经常听到关于 **React** 的消息；尽管它本身是一个用户界面组件库，但它已成为许多前端框架的基石，例如 **Gatsby**、**Remix**、**Next.js**
    以及其他一些框架。作为其介绍的一部分，React 还推出了 **JSX**，这是它自己的 JavaScript 扩展集，使得可以使用类似 HTML 的语法来定义组件。例如，静态站点框架
    Gatsby 依赖于 React 的状态管理和嵌套组件架构来组合其网页。使用 Gatsby，开发者可以通过 GraphQL 从内容管理系统、电子商务来源和其他地方多路复用数据。
- en: Following along our React route, we get to Remix, which bundles a full stack
    solution with features for both the server and the client, plus a compiler and
    a request handler. Remix provides solutions for the View and Controller aspects
    of the application and relies on the Node.js module ecosystem for the rest, giving
    flexibility to the developers who need custom solutions from project to project.
    Based on the experience of creating and maintaining the `react-router` project
    for many years, the creators of Remix were able to come up with powerful abstractions
    while taking advantage of the browser’s web APIs instead of investing in new concepts.
    To give an example, if you choose Remix for your project, you will find yourself
    using web standard APIs more than some of the other frameworks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着我们的 React 路线，我们来到了 Remix，它捆绑了一个全栈解决方案，包括服务器和客户端的功能，以及编译器和请求处理器。Remix 为应用的视图和控制器方面提供了解决方案，并依赖于
    Node.js 模块生态系统来处理其余部分，为需要从项目到项目定制解决方案的开发者提供了灵活性。基于多年来创建和维护 `react-router` 项目的经验，Remix
    的创造者能够在利用浏览器 Web API 的同时，避免了投资于新概念，从而提出了强大的抽象。例如，如果你选择 Remix 作为你的项目，你将发现自己比在其他一些框架中更多地使用
    Web 标准 API。
- en: Next.js is our next React-based framework, which extends the use of the React
    component architecture as well by bringing it to the server with its built-in
    server rendering. The server-rendered components allow for a pre-rendered page
    to be sent to the client, resulting in the client only spending resources on initializing
    the interactive components. The framework provides the concept of pages, which
    allows for simpler routing implementations with lazy loading and enables automatic
    code-splitting. Combining all these features results in a fantastic user experience
    with fast loading times. In addition, the deployed applications rank highly when
    indexed by search engines, a feature that makes this framework stand out.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 是我们的下一个基于 React 的框架，它通过内置的服务器端渲染扩展了 React 组件架构的使用。服务器端渲染的组件允许将预渲染的页面发送到客户端，从而使客户端只需在初始化交互式组件上花费资源。该框架提供了页面概念，允许使用懒加载进行更简单的路由实现，并启用自动代码拆分。结合所有这些功能，结果是一个具有快速加载时间的出色用户体验。此外，部署的应用程序在搜索引擎索引中排名很高，这是使该框架脱颖而出的特性。
- en: While talking about React frameworks, it is worth mentioning **Solid.js**. It’s
    a newer library that creates frontend interfaces. Solid’s benchmarks outperform
    React and others. It uses features such as JSX, but with a few key differences.
    With Solid, there is no virtual DOM and no concept of hooks. Instead, it relies
    on the pattern of **signals** to update the real DOM nodes, while utilizing reactive
    primitives. As part of Solid’s approach, it offers the **SolidStart** app framework,
    which is very comparable to Next.js. It consists of core support components –
    *router*, *session*, *document*, *actions*, *data*, *entrypoints*, and *server*
    – these are integrated together as part of SolidStart.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到 React 框架时，值得提及 **Solid.js**。这是一个较新的库，用于创建前端界面。Solid 的基准测试优于 React 和其他库。它使用
    JSX 等特性，但有一些关键区别。在 Solid 中，没有虚拟 DOM 和 hooks 的概念。相反，它依赖于 **信号** 模式来更新真实的 DOM 节点，同时利用响应式原语。作为
    Solid 方法的一部分，它提供了 **SolidStart** 应用框架，这与 Next.js 非常相似。它由核心支持组件组成 – *路由器*、*会话*、*文档*、*动作*、*数据*、*入口点*
    和 *服务器* – 这些组件作为 SolidStart 的一部分集成在一起。
- en: SvelteKit
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SvelteKit
- en: Like SolidStart, there is also `.svelte` files, which encapsulate the components
    with the `<script>`, `<style>`, and HTML tags that are coded together. These are
    compiled into JavaScript output generated by the compiler.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SolidStart 类似，也存在 `.svelte` 文件，这些文件封装了带有 `<script>`、`<style>` 和 HTML 标签的组件。这些组件被编译成由编译器生成的
    JavaScript 输出。
- en: About Vite
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Vite
- en: '`vite.config.js` configuration file. Mainly, it is used as a build tool for
    frontend projects. It is optimized for speed and it achieves that speed by providing
    a development server with Hot Module Replacement and a bundler that optimizes
    JavaScript output using esbuild ([esbuild.github.io](https://esbuild.github.io)).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`vite.config.js` 配置文件。主要用作前端项目的构建工具。它针对速度进行了优化，并通过提供具有热模块替换的开发服务器以及使用 esbuild
    优化 JavaScript 输出的打包器来实现这一速度（[esbuild.github.io](https://esbuild.github.io)）。'
- en: Framework features and patterns
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架特性和模式
- en: 'To understand what most modern frameworks enable, we need to understand the
    following acronyms and features:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解大多数现代框架能实现的功能，我们需要了解以下缩写和特性：
- en: '**Single-Page Application** (**SPA**): An early term that describes an application
    that purely uses JavaScript and other frontend frameworks for all interactions
    with reduced browser routing.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单页应用**（**SPA**）：一个早期术语，描述了一个仅使用JavaScript和其他前端框架进行所有交互，并减少浏览器路由的应用程序。'
- en: '**Server-Side Rendering** (**SSR**): Pre-rendered components on the server
    side, which are transferred for JavaScript hydration on the client side.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染**（**SSR**）：在服务器端预渲染的组件，在客户端传输以进行JavaScript激活。'
- en: '**Client-Side Rendering** (**CSR**): Rendering of components using JavaScript,
    purely on the browser’s side.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端渲染**（**CSR**）：使用JavaScript在浏览器端纯渲染组件。'
- en: '**Static Site Generator** (**SSG**): The concept of pre-generating all pages
    from source for faster rendering and better search engine optimization.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态站点生成器**（**SSG**）：预先从源生成所有页面以实现更快渲染和更好的搜索引擎优化的概念。'
- en: '**Deferred Static Generator** (**DSG**): Renders content on the server when
    initiated by a request to the server.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟静态生成器**（**DSG**）：在服务器接收到请求时在服务器上渲染内容。'
- en: '**Incremental Static Regeneration** (**ISR**): Another pattern of static content
    generation. In this case, the static generation is triggered by updates by some
    external trigger.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量静态再生**（**ISR**）：另一种静态内容生成的模式。在这种情况下，静态生成是由外部触发器更新触发的。'
- en: '**Content Security Policy** (**CSP**): Configuration for serving scripts that
    helps protect against cross-site scripting attacks.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容安全策略**（**CSP**）：用于提供脚本的配置，有助于防止跨站脚本攻击。'
- en: '**Hot Module Replacement** (**HMR**): Technique to replace JavaScript modules
    as the application is running in the browser, mainly used to improve development
    speed and avoid page reloads.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热模块替换**（**HMR**）：在浏览器中运行应用程序时替换JavaScript模块的技术，主要用于提高开发速度并避免页面重新加载。'
- en: '**Single-File Component** (**SFC**): A file structure that encapsulates all
    aspects of a usable framework component, such as styling, templating, logic, and
    more.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单文件组件**（**SFC**）：一种封装了可使用框架组件所有方面的文件结构，如样式、模板、逻辑等。'
- en: '**Model-View-Controller** (**MVC**): A design pattern focusing on the separation
    of concerns in various types of applications. It approaches this separation by
    using the following: a Model that represents the data, a View that provides the
    user with an interface, and a Controller that is the intermediary between the
    views and the models.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）：一种关注于各种类型应用中关注点分离的设计模式。它通过以下方式实现这种分离：一个表示数据的模型，一个提供用户界面的视图，以及作为视图和模型之间中介的控制器。'
- en: '**Model-View-ViewModel** (**MVVM**): Another design pattern that also focuses
    on the separation of concerns in applications, but the approach to these separations
    is different. In this case, there are still Views and Models, similar to MVC.
    However, the ViewModel acts as a connection between those types. This approach
    uses two-way data binding between the View and the Model.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**（**MVVM**）：另一种关注于应用程序中关注点分离的设计模式，但实现这些分离的方法不同。在这种情况下，仍然有视图和模型，类似于MVC。然而，ViewModel充当这些类型之间的连接。这种方法使用视图和模型之间的双向数据绑定。'
- en: 'Besides the features and their acronyms, here is a helpful visual describing
    both the MVC and MVVM patterns:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了功能和它们的缩写，这里有一个有用的视觉描述，描述了MVC和MVVM模式：
- en: '![Figure 1.3: MVC versus MVVM patterns](img/Figure_1.3_B19014.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3：MVC与MVVM模式对比](img/Figure_1.3_B19014.jpg)'
- en: 'Figure 1.3: MVC versus MVVM patterns'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：MVC与MVVM模式对比
- en: During the renaissance of frontend frameworks, an open source project called
    **TodoMVC** was established to help developers compare frameworks based on the
    same To Do app, where anyone can send pull requests with their framework implementations.
    Besides comparing different frameworks, the project also popularized the approach
    to complex code organization in JavaScript. Now with the emergence of these new
    frameworks, we need another iteration of TodoMVC to continue aiding developers
    with comparisons of these systems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端框架复兴期间，一个名为**TodoMVC**的开源项目被建立起来，旨在帮助开发者根据相同的待办事项应用比较框架，任何人都可以发送带有他们框架实现的拉取请求。除了比较不同的框架外，该项目还普及了JavaScript复杂代码组织的方法。现在随着这些新框架的出现，我们需要对TodoMVC进行新一轮迭代，以继续帮助开发者比较这些系统。
- en: Backend frameworks
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端框架
- en: Switching gears from the frontend, let us look at some of the backend frameworks.
    Node.js plays a vital role in the JavaScript ecosystem, powering a variety of
    frameworks that allow us to develop backend services. Similar to the frontend,
    it is impossible to cover all of them, but in this section, we will examine **hapi.js**,
    **express**, **Sails.js**, **nest.js**, and **AdonisJS**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从前端切换到后端，让我们来看看一些后端框架。Node.js在JavaScript生态系统中扮演着至关重要的角色，它为开发后端服务提供了各种框架。与前端一样，不可能涵盖所有这些框架，但在这个部分，我们将检查**hapi.js**、**express**、**Sails.js**、**nest.js**和**AdonisJS**。
- en: Hapi.js
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hapi.js
- en: As part of framework explorations over the years, I had the opportunity to work
    with these frameworks in a professional capacity and on small hobby projects.
    I started with hapi.js, which is a good example of a well-crafted Node.js framework,
    built with essential defaults that allow it to craft a server backend quickly.
    It has a unique approach of avoiding middlewares and relying on external modules.
    As part of its core, it already has validation rules, parsing, logging, and more
    built right into it. hapi.js doesn’t lock down extensibility; developers can create
    plugins and register them to execute as part of the different parts of the request
    lifecycle. Hapi.js’ mission puts an emphasis on avoiding unexpected consequences
    when combining a lot of application logic. This is evident in how hapi.js approaches
    dependency management and module namespacing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在多年的框架探索中，我有机会以专业身份和在小型的爱好项目中使用这些框架。我首先从hapi.js开始，它是Node.js框架精心制作的良好例子，它通过提供必要的默认设置，使得快速构建服务器后端成为可能。它采用了一种独特的方法，避免使用中间件并依赖于外部模块。作为其核心的一部分，它已经内置了验证规则、解析、日志记录等。hapi.js不限制可扩展性；开发者可以创建插件并将它们注册为请求生命周期不同部分的执行部分。hapi.js的使命强调在组合大量应用程序逻辑时避免意外后果。这在hapi.js处理依赖管理和模块命名空间的方式中表现得尤为明显。
- en: Express
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express
- en: In stark contrast to hapi.js, the Node.js ecosystem also has a framework called
    **Express**, which is largely an unopinionated approach to building backend services.
    Thousands of projects and tools usually use Express for its routing, content parsers,
    and high-performance reasons. Being flexible in almost every way and with support
    for over a dozen templating engines, Express is the introductory framework for
    developers starting with Node.js development. For example, a popular MVC framework,
    Sails.js, builds upon Express’ functionality to offer API generation, database
    ORM solutions, and support for building real-time features. Generally, it is a
    good solution for those appreciating the middleware patterns of Express, while
    having a more structured approach to building backend systems.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与hapi.js形成鲜明对比的是，Node.js生态系统还有一个名为**Express**的框架，它主要是一种无特定观点的后端服务构建方法。成千上万的项目和工具通常使用Express进行路由、内容解析和高性能。Express几乎在所有方面都很灵活，并支持超过一打的模板引擎，是Node.js开发者的入门框架。例如，一个流行的MVC框架Sails.js，基于Express的功能提供API生成、数据库ORM解决方案以及构建实时功能的支持。通常，它是对那些欣赏Express中间件模式、同时希望采用更结构化方法构建后端系统的人来说是一个好的解决方案。
- en: NestJS
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NestJS
- en: NestJS, not to be confused with Next.js, is another server-side framework that
    is worth mentioning. It is similar to Vue, and Angular inspired its approach to
    application structure, but in this case, for a backend system. By default, it
    utilizes Express as its default HTTP server and creates an abstraction layer that
    allows for the ability to change the third-party modules, enabling the developers
    to swap out Express for some other HTTP framework such as **Fastify**. In NestJS,
    we see a similar pattern of dependency injection, which enables developers to
    architect contained modules. These modules can be reused, overridden, and mocked
    in tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: NestJS，不要与Next.js混淆，是另一个值得提及的服务端框架。它与Vue类似，并且Angular启发了其对应用结构的处理方法，但在这个案例中，是针对后端系统的。默认情况下，它使用Express作为其默认的HTTP服务器，并创建了一个抽象层，允许开发者更换第三方模块，使得开发者可以将Express替换为其他HTTP框架，例如**Fastify**。在NestJS中，我们看到类似的依赖注入模式，这使开发者能够构建封装的模块。这些模块可以在测试中重用、覆盖和模拟。
- en: AdonisJS
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AdonisJS
- en: Our final Node.js framework for this section is AdonisJS. Built entirely with
    TypeScript, it is packed with features that you would expect from a mature framework,
    such as the ORM based on the Active Record pattern, schema validators, extensive
    authentication support, and much more. The built-in and first-party plugin features
    provide solutions for many mundane problems of backend building. AdonisJS also
    packs a custom templating engine to render HTML layouts. As an added bonus, AdonisJS
    has straight-to-the-point and clear documentation, which is a joy to read and
    explore.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本节最后要介绍的 Node.js 框架是 AdonisJS。它完全使用 TypeScript 构建，集成了许多成熟框架应有的特性，例如基于 Active
    Record 模式的 ORM、模式验证器、广泛的认证支持以及更多。内置和第一方插件特性为后端构建中的许多常规问题提供了解决方案。AdonisJS 还内置了一个自定义模板引擎，用于渲染
    HTML 布局。作为额外的奖励，AdonisJS 的文档直接明了，易于阅读和探索。
- en: Fresh
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Fresh
- en: Given the focus on essential frameworks in the Node.js ecosystem, we should
    also mention a backend framework called **Fresh**, which is powered by the **Deno**
    runtime. This runtime is built using a combination of technologies – JavaScript,
    TypeScript, WebAssembly, and the Rust programming language. Fresh takes a simplistic
    approach with its emphasis on having no build steps, minimal configuration, and
    just-in-time rendering of components on the server. Routing is taken care of by
    creating files in the directories of your project, called File-system routing,
    a similar pattern in other frameworks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Node.js 生态系统对核心框架的关注，我们也应该提一下名为 **Fresh** 的后端框架，它由 **Deno** 运行时提供支持。这个运行时结合了多种技术——JavaScript、TypeScript、WebAssembly
    和 Rust 编程语言。Fresh 采用了一种简单的方法，强调没有构建步骤、最小化配置，并在服务器上即时渲染组件。路由通过在项目目录中创建文件来处理，称为文件系统路由，这与其他框架中的类似模式。
- en: Looking back at all the Node.js frameworks we covered in this section, there
    is a healthy framework diversity that delivers solutions for projects of any type.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本节中我们讨论的所有 Node.js 框架，可以看到一个健康的框架多样性，为任何类型的项目提供了解决方案。
- en: Native frameworks
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生框架
- en: The knowledge of JavaScript also allows us to build for native operating system
    environments and interact with hardware platforms. The availability of the runtime
    in other environments makes it possible for us to create unique solutions that
    can help web developers apply their skills in areas beyond the browser. In this
    section, we cover some of the frameworks created for native JavaScript development.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对 JavaScript 的了解也使我们能够为原生操作系统环境构建，并与硬件平台交互。在其他环境中运行时的可用性使我们能够创建独特的解决方案，帮助网页开发者将他们的技能应用到浏览器以外的领域。在本节中，我们将介绍为原生
    JavaScript 开发创建的一些框架。
- en: Electron
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电子
- en: The idea of packaging a web app as a native app is not new, but it has been
    perfected with **Electron**. Electron allows developers to use familiar frontend
    technologies to build fully capable cross-platform applications that run on popular
    desktop platforms. It has feature supports features such as auto-updates and inter-process
    communication, as well as having a collection of plugins that tap into operating
    system functionality. Besides the advanced framework features, it is beneficial
    to have a single code base targeting all the platforms, which helps with efficiently
    building new features and bug fixing. These days millions of people use applications
    built with Electron, in many cases without knowing it. Applications such as Microsoft
    Teams, Slack, 1Password, Discord, Figma, Notion, and many more utilize Electron.
    Even more examples can be found at [electronjs.org/apps](https://electronjs.org/apps).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Web 应用打包成原生应用的想法并不新鲜，但通过 **Electron** 得到了完善。Electron 允许开发者使用熟悉的客户端技术构建能够在流行的桌面平台上运行的完整跨平台应用程序。它支持诸如自动更新和进程间通信等特性，同时还拥有一个利用操作系统功能的插件集合。除了高级框架特性外，有一个针对所有平台的单一代码库对于高效构建新功能和修复错误也是有益的。如今，数百万人在使用由
    Electron 构建的应用程序，在很多情况下甚至不知道这一点。例如 Microsoft Teams、Slack、1Password、Discord、Figma、Notion
    等应用程序都使用了 Electron。更多示例可以在 [electronjs.org/apps](https://electronjs.org/apps)
    找到。
- en: React Native
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React Native
- en: Another framework that helps us create for native platforms is **React Native**,
    which unlocks the world of mobile development to those experienced with JavaScript.
    Targeting iOS and Android mobile platforms, just like Electron on desktop, it
    brings all the benefits of React user-interface building blocks, a unified codebase,
    and a strong, established community.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个帮助我们为原生平台创建应用的框架是**React Native**，它为熟悉JavaScript的开发者打开了移动开发的世界。针对iOS和Android移动平台，就像桌面上的Electron一样，它带来了React用户界面构建块的所有好处、统一的代码库和强大、成熟的社区。
- en: Johnny-Five
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Johnny-Five
- en: The Node.js ecosystem also offers hardware frameworks such as **Johnny-Five**,
    which allows for creative learning use cases of robotics programming using JavaScript
    and the Firmata protocol. Johnny-Five is an IoT platform supporting over 30 hardware
    boards. Mainly, it offers interfaces to interact with LEDs, services, motors,
    switches, and more.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js生态系统还提供了如**Johnny-Five**这样的硬件框架，它允许使用JavaScript和Firmata协议进行机器人编程的创意学习用例。Johnny-Five是一个支持超过30块硬件板的IoT平台。主要提供与LED、服务、电机、开关等交互的接口。
- en: All the frameworks so far deal with building out application logic, but there
    are also other types of frameworks in JavaScript that play an important role in
    the development process – these would be the testing frameworks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有框架都处理构建应用程序逻辑，但在JavaScript中还有其他类型的框架在开发过程中扮演着重要的角色——这些就是测试框架。
- en: Testing frameworks
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试框架
- en: Testing frameworks in software development are essential for ensuring our projects
    function as expected. With JavaScript and its supported runtime environments,
    we have a much more challenging task at hand – we have to test in different browser
    engines and mock the native web APIs. In some cases, mocking built-in and external
    libraries can also be challenging. The asynchronous behavior of the language brings
    its own obstacles as well. Luckily, the JavaScript ecosystem came up with various
    testing frameworks addressing many software testing challenges – unit, integration,
    functional, end-to-end testing, and beyond. To name a few, **Jest**, **Playwright**,
    and **Vitest** all offer great solutions to testing challenges. We will discuss
    them next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的测试框架对于确保我们的项目按预期运行至关重要。随着JavaScript及其支持的运行时环境，我们手头上的任务更加艰巨——我们不得不在不同的浏览器引擎中进行测试并模拟原生的Web
    API。在某些情况下，模拟内置和外部库也可能具有挑战性。语言的异步行为也带来了自己的障碍。幸运的是，JavaScript生态系统提出了各种测试框架，以解决许多软件测试挑战——单元测试、集成测试、功能测试、端到端测试等。例如，**Jest**、**Playwright**和**Vitest**都为测试挑战提供了很好的解决方案。我们将在下一节讨论它们。
- en: Jest
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jest
- en: As we develop our web applications, we want to ensure that the components we
    build are functioning as intended; this is where a framework such as Jest comes
    in. Jest is a unit testing framework that integrates well into other projects.
    If we are given a project with one of the frameworks that we already saw in this
    chapter, Jest would equip us with reliable testing solutions. It is ergonomic,
    with minimal or zero configuration, and provides us with interfaces for easy mocking,
    object snapshotting, code coverage, and most importantly, an easy-to-understand
    API for organizing our tests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开发Web应用程序，我们希望确保我们构建的组件按预期工作；这就是Jest这样的框架发挥作用的地方。Jest是一个与其他项目集成良好的单元测试框架。如果我们得到一个包含我们在本章中看到的一些框架的项目，Jest将为我们提供可靠的测试解决方案。它设计得非常人性化，配置最小或为零，并提供易于模拟、对象快照、代码覆盖和最重要的是，一个易于理解的API来组织我们的测试。
- en: Vitest
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vitest
- en: Vitest is a similar unit testing framework, offering the same interfaces to
    mock modules in web projects. It focuses on speed and support for components of
    many frameworks, including Vue, React, Svelte, and even Web Components. It is
    designed for developer productivity and has a mode for smart test watching, a
    multi-threaded test runner, and a familiar snapshotting mechanism.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest是一个类似的单元测试框架，提供了与在Web项目中模拟模块相同的接口。它专注于速度和对许多框架组件的支持，包括Vue、React、Svelte，甚至Web
    Components。它旨在提高开发者的生产力，并具有智能测试监视模式、多线程测试运行器和熟悉的快照机制。
- en: Playwright
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Playwright
- en: Besides unit testing, our software projects benefit highly from end-to-end testing;
    this is where a testing framework such as Playwright is a good contender. It delivers
    cross-browser and cross-platform testing for web applications. Playwright comes
    with a set of test interfaces to automate various browsers, including navigating
    to URLs and clicking buttons. Historically, this has been a challenging problem
    due to the asynchronous nature of web pages, but this framework is equipped with
    ways to avoid flaky tests through retries and await behavior.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单元测试之外，我们的软件项目从端到端测试中受益匪浅；这正是Playwright等测试框架成为良好竞争者的地方。它为Web应用程序提供跨浏览器和跨平台的测试。Playwright附带一组测试接口，用于自动化各种浏览器，包括导航到URL和点击按钮。由于网页的异步性质，这历来是一个具有挑战性的问题，但这个框架通过重试和await行为提供避免不稳定测试的方法。
- en: Depending on the requirements of the JavaScript project you are involved in,
    you might have to create new testing workflows or customize the existing testing
    infrastructure to fit your use case – this is where experience in building testing
    frameworks would be advantageous.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你参与的JavaScript项目的需求，你可能需要创建新的测试工作流程或定制现有的测试基础设施以适应你的用例——这正是构建测试框架的经验会带来优势的地方。
- en: Framework showcase
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架展示
- en: Here’s a breakdown of the frameworks we covered in this chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章中我们讨论的框架的概述。
- en: 'These are some of the noteworthy web application frameworks that we will be
    focusing on in this book:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在本书中关注的值得注意的Web应用程序框架：
- en: '| **Frontend +** **Full Stack** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **前端 +** **全栈** |'
- en: '| Name | Released |  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 发布时间 |  |'
- en: '| **AngularJS** | 2010 | Obsolete MVC framework with features such as two-way
    data binding and dependency injection. Part of the original MEAN software stack.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **AngularJS** | 2010 | 已过时的MVC框架，具有双向数据绑定和依赖注入等功能。是原始MEAN软件栈的一部分。|'
- en: '| **Bootstrap** | 2011 | Basic framework that allows utilizing HTML, CSS, and
    JavaScript to create responsive mobile-first websites and can be integrated with
    other systems to power interfaces for web applications. Bootstrap defines its
    own layout primitives and provides a great set of built-in components for forms
    and user interface elements. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **Bootstrap** | 2011 | 允许利用HTML、CSS和JavaScript创建响应式移动优先网站的基本框架，并且可以与其他系统集成以提供Web应用程序的界面。Bootstrap定义了自己的布局原语，并提供了一套内置组件，用于表单和用户界面元素。|'
- en: '| **Ember.js** | 2011 | Component-service architecture SPA framework with regular
    releases and opinionated conventions over configuration characteristics. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **Ember.js** | 2011 | 采用组件-服务架构的SPA框架，具有定期发布和基于配置特性的意见化约定。|'
- en: '| **Vue.js** | 2014 | Lightweight MVVM component-based framework with an easy
    learning curve – uses the virtual DOM. Comes with its own reactivity system and
    support for state-changing CSS transitions. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **Vue.js** | 2014 | 学习曲线平缓的轻量级MVVM组件化框架，使用虚拟DOM。自带反应系统和对状态变化CSS过渡的支持。|'
- en: '| **Gatsby** | 2015 | Advanced static site generator using React and Node.js.
    Includes various modes of rendering pages and serving dynamic websites. Heavily
    relies on GraphQL for data retrieval. Variety of plugins in the ecosystem. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **Gatsby** | 2015 | 使用React和Node.js的高级静态网站生成器。包括各种页面渲染和动态网站服务模式。高度依赖GraphQL进行数据检索。生态系统中有各种插件。|'
- en: '| **Angular** | 2016 | Component-based framework with dependency injection,
    templating, and additive directives. Has a slew of extra features to enable internationalization
    and accessibility. Full rewrite of the original AngularJS. TypeScript-based. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **Angular** | 2016 | 基于依赖注入、模板和附加指令的组件化框架。具有一系列额外功能以实现国际化和无障碍访问。是原始AngularJS的全面重写。基于TypeScript。|'
- en: '| **Next.js** | 2016 | Server-side rendering framework using React as its rendering
    interface. Supports multiple data request methods. A lot of features are built
    right into the framework. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **Next.js** | 2016 | 使用React作为渲染界面的服务器端渲染框架。支持多种数据请求方法。许多功能直接集成到框架中。|'
- en: '| **Nuxt.js** | 2016 | Framework that uses Vue.js as its core, with a combination
    of Webpack, Babel.js, and other components. Focuses on delivering an optimized
    application experience. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **Nuxt.js** | 2016 | 使用Vue.js作为核心的框架，结合Webpack、Babel.js和其他组件。专注于提供优化的应用程序体验。|'
- en: '| **SolidStart** | 2019 | Framework for Solid.js applications. Supports all
    methods of component rendering. Optimizations for code splitting and providing
    the best Solid.js experience. Solid.js works with real DOM nodes, supports Web
    Components, and has efficient rendering. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **SolidStart** | 2019 | Solid.js应用的框架。支持所有组件渲染方法。优化代码拆分，提供最佳的Solid.js体验。Solid.js与真实DOM节点协同工作，支持Web组件，具有高效的渲染。|'
- en: '| **Remix** | 2021 | Full stack, UI-focused framework written in TypeScript.
    Consists of a browser, server, compiler, and HTTP handler. Built on top of React
    and includes a powerful application router. Offers many modes of rendering and
    file-based routing. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **Remix** | 2021 | 以UI为中心的TypeScript全栈框架。包括浏览器、服务器、编译器和HTTP处理器。基于React构建，包含强大的应用程序路由器。提供多种渲染模式和基于文件的路由。|'
- en: '| **SvelteKit** | 2022 | Framework to develop Svelte-based apps. Uses the Svelte
    compiler and the Vite tooling. Does not rely on the Virtual DOM and supports all
    modes of rendering components. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **SvelteKit** | 2022 | 开发基于Svelte的应用程序的框架。使用Svelte编译器和Vite工具。不依赖于虚拟DOM，支持所有组件渲染模式。|'
- en: 'Figure 1.4: Examples of frontend and full stack frameworks'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：前端和全栈框架示例
- en: 'These are some of the backend frameworks that will serve as good examples and
    help us learn certain framework development patterns:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些可以作为良好示例并帮助我们学习某些框架开发模式的后端框架：
- en: '| **Backend** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **Backend** |'
- en: '| Name | Released |  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 发布时间 |  |'
- en: '| **hapi.js** | 2009 | Framework for building backend web services of any kind,
    with a convention-over-configuration mantra. Supports a lot of advanced features
    such as API validation, payload parsing, and more right out of the box. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **hapi.js** | 2009 | 建立任何类型后端Web服务的框架，采用约定优于配置的口号。开箱即支持许多高级功能，如API验证、有效载荷解析等。|'
- en: '| **Express** | 2010 | One of the most popular Node.js frameworks for building
    RESTful APIs, integrated with many modules in the ecosystem. Used in real-world
    applications and many developer tools. Part of the MEAN stack. Includes helpers
    for caching, redirection, and support for many templating engines. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **Express** | 2010 | 建立RESTful API最流行的Node.js框架之一，与生态系统中的许多模块集成。用于实际应用和许多开发者工具。MEAN堆栈的一部分。包括缓存、重定向和许多模板引擎的支持助手。|'
- en: '| **Sails.js** | 2012 | Enterprise-grade MVC framework built on top of Express
    and Socket.io. Comes with ORM support and a powerful CLI to generate parts of
    projects. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **Sails.js** | 2012 | 基于Express和Socket.io的企业级MVC框架。包含ORM支持和强大的CLI来生成项目部分。|'
- en: '| **NestJS** | 2018 | Server-side application framework with a modular approach.
    It follows certain patterns of Angular and includes a lot of built-in features,
    such as WebSocket, GraphQL, and microservice support. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **NestJS** | 2018 | 采用模块化方法的服务器端应用框架。遵循Angular的一些模式，并包含许多内置功能，如WebSocket、GraphQL和微服务支持。|'
- en: '| **AdonisJS** | 2019 | All-inclusive backend framework for APIs and web applications
    written in and for TypeScript-based code bases. Comes with its own components
    for ORM, templating, and routing. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **AdonisJS** | 2019 | 针对TypeScript代码库的API和Web应用程序的全功能后端框架。包含自己的ORM、模板和路由组件。|'
- en: '| **Fresh** | 2022 | Framework written using the Deno runtime. With no build
    steps, minimal configuration, and just-in-time rendering. Uses the island architecture
    pattern, focusing on reducing work on the client. Independent server-side components
    are rendered using HTML and sent over to the client. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **Fresh** | 2022 | 使用Deno运行时编写的框架。没有构建步骤，配置最小化，即时渲染。使用岛屿架构模式，专注于减少客户端的工作。独立的服务器端组件使用HTML渲染并发送到客户端。|'
- en: 'Figure 1.5: Examples of backend frameworks'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：后端框架示例
- en: 'Other frameworks that use frontend technologies to target native or hardware
    development are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其他使用前端技术针对原生或硬件开发的框架如下：
- en: '| **Native +** **Hardware** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **Native +** **Hardware** |'
- en: '| Name | Released |  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 发布时间 |  |'
- en: '| **Johnny-Five** | 2012 | Robotics framework for IoT development. Allows developers
    to interact with hardware modules with an easy-to-use API. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **Johnny-Five** | 2012 | 物联网开发机器人框架。允许开发者使用易于使用的API与硬件模块交互。|'
- en: '| **Electron** | 2013 | Popular cross-platform desktop application framework
    that uses web technologies. Uses the architecture from the Chromium project, which
    enables developers to interact with the application and the renderer processes.
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **Electron** | 2013 | 使用Web技术的流行跨平台桌面应用程序框架。使用来自Chromium项目的架构，使开发者能够与应用程序和渲染进程交互。|'
- en: '| **React Native** | 2015 | Application framework for iOS, Android, and other
    platforms. Uses familiar concepts from React to build interfaces. Mainly useful
    for web developers who want a single code base for their application and don’t
    want to use native toolkits to build these apps. Has a large community and plugin
    ecosystem. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **React Native** | 2015 | 用于iOS、Android和其他平台的应用框架。使用React的熟悉概念来构建界面。主要适用于希望为应用使用单一代码库且不想使用原生工具包来构建这些应用的Web开发者。拥有庞大的社区和插件生态系统。
    |'
- en: 'Figure 1.6: Examples of native and hardware frameworks'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：原生和硬件框架示例
- en: 'Here are testing framework examples, which are useful to integrate and use
    in web application projects:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些测试框架示例，这些示例在Web应用项目中集成和使用非常有用：
- en: '| **Testing** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **Testing** |'
- en: '| **Jest** | 2019 | Zero-configuration testing framework that universally supports
    many JavaScript environments, including TypeScript, Node.js, and more. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **Jest** | 2019 | 零配置测试框架，通用支持许多JavaScript环境，包括TypeScript、Node.js等。 |'
- en: '| **Playwright** | 2020 | End-to-end testing and automation framework supporting
    cross-platform testing in the Chromium, WebKit, and Firefox browsers. Helps developers
    quickly and reliably conduct instrument tests for any web application. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **Playwright** | 2020 | 支持在Chromium、WebKit和Firefox浏览器中进行跨平台测试的端到端测试和自动化框架。帮助开发者快速可靠地对任何Web应用进行仪器测试。
    |'
- en: '| **Vitest** | 2022 | Unit test framework, part of the Vite ecosystem. Comes
    with ESM, JSX, and TypeScript support. Developed in conjunction with Vue.js |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **Vitest** | 2022 | 单元测试框架，Vite生态系统的一部分。支持ESM、JSX和TypeScript。与Vue.js共同开发
    |'
- en: 'Figure 1.7: Examples of testing frameworks'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：测试框架示例
- en: One of the best resources to keep up with the current direction of framework
    development is [stateofjs.com](https://stateofjs.com). It is a yearly survey with
    results from thousands of developers, and it provides an outlook of where the
    technologies are shifting. For example, if we look at the frontend framework rankings
    of 2022 ([2022.stateofjs.com/en-US/libraries/front-end-frameworks](https://2022.stateofjs.com/en-US/libraries/front-end-frameworks)),
    we can already start to see the retention and interest in React slowly dropping,
    which could potentially indicate that the industry is slowly shifting to other
    solutions. Due to this constant change of use, awareness, and popularity of all
    these frameworks, instead of focusing on many of the frameworks of today, we are
    going to cover the core patterns that could be applicable to new frameworks in
    the future. These patterns will be helpful to you while you explore creating your
    own framework.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪框架开发当前方向的最好资源之一是 [stateofjs.com](https://stateofjs.com)。这是一年一度的调查，结果来自数千名开发者，它提供了技术发展趋势的展望。例如，如果我们看看2022年的前端框架排名（[2022.stateofjs.com/en-US/libraries/front-end-frameworks](https://2022.stateofjs.com/en-US/libraries/front-end-frameworks)），我们已经开始看到React的保留和兴趣缓慢下降，这可能表明行业正在缓慢转向其他解决方案。由于所有这些框架的使用、意识和流行度的持续变化，我们不会专注于许多今天的框架，而是将涵盖适用于未来新框架的核心模式。这些模式将有助于您在探索创建自己的框架时。
- en: 'Now it’s time to try out some of the frameworks mentioned in this chapter using
    the GitHub repository for this book mentioned in the *Technical requirements*
    section. You can follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候尝试本章中提到的某些框架了，使用本书“技术要求”部分中提到的GitHub仓库。您可以按照以下步骤操作：
- en: Install Node.js version 20 from [nodejs.org](http://nodejs.org).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [nodejs.org](http://nodejs.org) 安装Node.js版本20。
- en: Clone the repository from [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework)
    克隆仓库。
- en: Using your terminal, change directories into the `chapter1` directory of the
    repository.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的终端，切换到仓库的 `chapter1` 目录。
- en: Run `npm install` and then `npm start`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm install` 然后运行 `npm start`。
- en: Follow the interactive prompt to run the examples.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照交互式提示运行示例。
- en: The showcase focuses on reproducing the same example based on the framework
    type. All frontend frameworks demonstrate the same component written in different
    structures. Note that some examples might take a while to install and run.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 展示重点在于根据框架类型重现相同的示例。所有前端框架都展示了用不同结构编写的相同组件。请注意，一些示例可能需要一些时间来安装和运行。
- en: In the final part of this chapter, we shall take a look at my notable personal
    experiences with frameworks in web development.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探讨我在Web开发中与框架相关的显著个人经验。
- en: My experiences with frameworks
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我与框架的经历
- en: My professional web development career initially started with building basic
    websites before established frameworks or libraries were around. Looking ahead,
    I want to share my framework experiences of professionally utilizing them and
    contributing to some of the open source ones. These days, the accumulated knowledge
    gathered from these experiences has helped me better assess framework usefulness
    and introduce new software paradigms into my work. Many find it challenging to
    keep up with the latest innovations in the JavaScript field, but building even
    the smallest projects helps one grow as a developer in many ways.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我的专业网页开发生涯最初是从构建基本的网站开始的，那时还没有现成的框架或库。展望未来，我想分享我在专业上利用框架的经验，以及为一些开源项目做出贡献的经历。如今，从这些经验中积累的知识帮助我更好地评估框架的实用性，并将新的软件范式引入我的工作中。许多人发现跟上JavaScript领域的最新创新具有挑战性，但即使是构建最小的项目也能在许多方面帮助开发者成长。
- en: Here are some examples from the full stack development areas that helped me
    become much more effective as a web developer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些全栈开发领域的例子，这些例子帮助我成为了一名更加高效的网页开发者。
- en: Frontend development
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端开发
- en: The first few professional websites I built were developed for Internet Explorer
    6 and early versions of Firefox web browsers. As we learned from this chapter,
    there were no frameworks for building web applications at the time, and I had
    to utilize the few libraries at my disposal. These would help add interactivity
    for components such as image galleries and dynamic page layouts. Luckily, when
    my focus switched to larger projects, the **jQuery** frontend library came along
    and started growing in popularity. Even to this day, jQuery is still a popular
    tool of choice for a large chunk of websites. I now had the opportunity to hand-craft
    a basic framework, which could be reused from project to project. This series
    of scripts was incredibly convenient and foreshadowed the bright future of frameworks
    that we have today. It was clear that the trend of single-page JavaScript applications
    was heading towards structured and opinionated solutions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初构建的几个专业网站是为Internet Explorer 6和Firefox网络浏览器的早期版本开发的。正如我们从这一章节中学到的，当时还没有用于构建Web应用的框架，我不得不利用我所拥有的少数库。这些库可以帮助添加交互性，例如图片库和动态页面布局。幸运的是，当我的关注点转向更大型的项目时，**jQuery**前端库出现了，并开始流行起来。时至今日，jQuery仍然是大批网站的首选工具。我有了亲手打造一个基本框架的机会，这个框架可以从一个项目重用到另一个项目。这一系列脚本非常方便，预示了我们今天所拥有的框架的辉煌未来。很明显，单页JavaScript应用的趋势正朝着结构化和有观点的解决方案发展。
- en: During one of my large early-on projects – specifically the Firefox Accounts
    frontend ([accounts.firefox.com](http://accounts.firefox.com)), I had the opportunity
    to use **Backbone.js**, with the help of jQuery and multiple extension libraries
    to make it more suitable for large projects. The Firefox Accounts frontend, which
    is serving millions of users, is still using Backbone.js to this day. The way
    the Backbone.js framework is structured allows for a soft dependency on jQuery,
    so it did feel like a natural continuation of my earlier approach to web application
    development. My key takeaways from this experience are that Backbone.js wasn’t
    the perfect answer to the challenges of frontend web applications, but it was
    beneficial in many ways. For example, it allowed the project to stay flexible
    with the ever-evolving JavaScript ecosystem and helped diverse developers work
    on the application while following a solid set of application guidelines. The
    unique opportunity to work on the client and the integrated services of the Firefox
    web browser taught me how to produce JavaScript components for a desktop client
    that runs on millions of computers worldwide.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我早期的大型项目中之一——具体来说是 Firefox 账户前端（[accounts.firefox.com](http://accounts.firefox.com)），我有机会使用
    **Backbone.js**，借助 jQuery 和多个扩展库使其更适合大型项目。至今仍在为成百万用户服务的 Firefox 账户前端仍在使用 Backbone.js。Backbone.js
    框架的结构允许对 jQuery 的软依赖，所以它感觉像是我在早期网络应用开发方法上的自然延续。我从这次经历中得到的要点是，Backbone.js 并非前端网络应用挑战的完美答案，但在许多方面都有益。例如，它使项目能够保持与不断发展的
    JavaScript 生态系统的灵活性，并帮助多样化的开发者遵循一套稳固的应用程序指南来共同工作。有机会在客户端和 Firefox 网络浏览器的集成服务中工作，教会了我如何为全球数百万台计算机上运行的桌面客户端生成
    JavaScript 组件。
- en: Throughout many professional projects, I had the chance to work with Ember.js,
    Angular, and various React frameworks. I was impressed by how empowering these
    frameworks can be on these occasions. A notable mention from my experience is
    the **Meteor** web framework, released in early 2012\. One of the big selling
    features of Meteor was the isomorphic or so-called *universal JavaScript* approach,
    where the code runs on both the client and the server. In many ways, we see similar
    approaches in popular frameworks today, where a full stack framework lets developers
    write JavaScript to develop on both sides of the stack. I have built a few applications
    and some plugins for this framework, and while it felt so easy to get started
    with Meteor, I have experienced hurdles while trying to build something that didn’t
    fit exactly into the scope of what Meteor supported, especially in the early releases
    of the framework. A particular example of fighting with the framework’s constraints
    was developing a feature with a synchronized document state across multiple clients.
    This ended up being challenging to implement with Meteor’s feature set at the
    time and had to be rebuilt with alternative tooling. Luckily this was not a critical
    project, but for times when it is important, it is a good idea to evaluate whether
    the framework of your choice is the right tool for what you are trying to build.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多专业项目中，我有机会与 Ember.js、Angular 以及各种 React 框架合作。在这些场合，我对这些框架的强大功能印象深刻。在我的经验中，值得特别一提的是于
    2012 年初发布的 **Meteor** 网络框架。Meteor 的一个主要卖点是其同构或所谓的 *通用 JavaScript* 方法，其中代码在客户端和服务器上同时运行。在许多方面，我们今天在流行的框架中看到了类似的方法，其中全栈框架让开发者能够编写
    JavaScript 来在栈的两端进行开发。我为这个框架构建了一些应用程序和一些插件，虽然开始使用 Meteor 感觉非常容易，但在尝试构建不符合 Meteor
    支持范围的项目时，我遇到了障碍，尤其是在框架的早期版本中。一个特别与框架限制作斗争的例子是在多个客户端之间同步文档状态的功能开发。当时，使用 Meteor
    的功能集来实现这一点颇具挑战性，不得不使用替代工具重新构建。幸运的是，这并不是一个关键项目，但在重要的时候，评估你选择的框架是否是你试图构建的正确工具是一个好主意。
- en: Backend development
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端开发
- en: During the early years of Node.js, I had the chance to work on several projects
    utilizing the microservices architecture, and these involved using the Express
    and hapi frameworks. I felt the contrast between the open-ended approach of the
    express framework versus the rigorous set of rules and options that were defined
    in hapi.js. To give some examples, overriding and customizing certain behaviors
    in hapi.js was quite difficult, and keeping the framework up to date required
    difficult migrations to the code base.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js的早期几年，我有机会参与几个使用微服务架构的项目，这些项目涉及使用Express和hapi框架。我感受到了express框架的开放性方法与hapi.js中定义的严格规则和选项之间的对比。例如，在hapi.js中覆盖和自定义某些行为相当困难，而保持框架更新则需要困难的代码库迁移。
- en: I still remember combing through the changelog of every new version of hapi.js,
    making sure not to miss any breaking changes that would make my projects dysfunctional.
    Even with the hardships of hapi.js, it did feel like the framework was providing
    a good set of abstractions. In many ways, following the existing examples from
    something like Flask in Python, hapi had the necessary components to build highly
    usable services. Meanwhile, my experiences with Express seemed more reminiscent
    of working with the jQuery and Backbone.js days. In the Express projects, I could
    have a highly flexible development environment, combining different Node.js modules
    to achieve what I wanted from the framework. This made me realize that the perfect
    framework for me would be something between Express and hapi, in the sense that
    it would allow me to stay creative, highly productive, and able to utilize the
    runtime ecosystem to the fullest, while at the same time having a strong opinionated
    framework core, which would keep my application efficient and reliable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然记得逐个版本地检查hapi.js的变更日志，确保不会错过任何可能导致我的项目失效的重大变更。尽管hapi.js存在困难，但它确实感觉这个框架提供了一套良好的抽象。在许多方面，遵循像Python中的Flask这样的现有示例，hapi拥有构建高度可用的服务所需的必要组件。同时，我的Express经验似乎更让我想起了jQuery和Backbone.js的日子。在Express项目中，我可以拥有一个高度灵活的开发环境，结合不同的Node.js模块来实现框架想要的功能。这让我意识到，对我来说完美的框架应该介于Express和hapi之间，也就是说，它将允许我保持创造力、高度的生产力，并充分利用运行时生态系统，同时同时拥有一个有强烈意见的框架核心，这将使我的应用程序高效且可靠。
- en: Developer tooling and more
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发者工具和更多
- en: As part of my profession, I have always been passionate about open source, so
    I focused my efforts on contributing to developer tooling and testing frameworks.
    I have been a maintainer of **Grunt.js** ([gruntjs.com](http://gruntjs.com)),
    a JavaScript task runner for many years. Grunt.js has been a core component of
    frameworks, such as **Yeoman**, and has been used as a tool of choice in the early
    version of AngularJS. The task runner conventions in Node.js have changed a lot
    since then, but there is still a solid number of projects that use Grunt.js. Maintaining
    this project for many years feels similar to maintaining a large framework project
    – releasing new versions, keeping a stable API, supporting it through security
    bounties, and much more. There is also a huge list of issues, feature demands,
    pull requests, and plugins to support.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我的职业的一部分，我一直对开源充满热情，因此我将我的努力集中在为开发者工具和测试框架做贡献上。多年来，我一直担任**Grunt.js**（[gruntjs.com](http://gruntjs.com)）的维护者，这是一个JavaScript任务运行器。Grunt.js一直是框架的核心组件，如**Yeoman**，并且在AngularJS的早期版本中被用作首选工具。自从那时起，Node.js的任务运行器规范已经发生了很大变化，但仍然有相当数量的项目在使用Grunt.js。维护这个项目多年感觉就像维护一个大型框架项目一样——发布新版本、保持稳定的API、通过安全赏金支持它以及更多。还有一大堆问题、功能需求、拉取请求和插件需要支持。
- en: In terms of my testing framework contributions, I was involved in developing
    the **Intern.js** testing framework ([github.com/theintern](http://github.com/theintern)),
    which enabled unit and functional testing for web applications. I was both the
    contributor and the consumer of this framework in my daily projects, which gave
    me a unique angle on the project. I was inspired to provide a good integration
    experience because it would aid my own projects. As part of this effort, besides
    learning how a testing framework is built, I focused on developing integration
    examples and documentation for other application frameworks. Covering many integration
    scenarios in the provided examples made it much easier for developers to integrate
    this testing system into their applications.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的测试框架贡献方面，我参与了**Intern.js**测试框架（[github.com/theintern](http://github.com/theintern)）的开发，它为Web应用程序提供了单元和功能测试。在我的日常项目中，我既是这个框架的贡献者也是消费者，这让我对这个项目有了独特的视角。我受到启发，要提供一个良好的集成体验，因为它将有助于我的项目。作为这项工作的一个部分，除了学习如何构建测试框架之外，我还专注于为其他应用程序框架开发集成示例和文档。在提供的示例中涵盖了众多集成场景，这使得开发者将这个测试系统集成到他们的应用程序中变得容易得多。
- en: A final notable framework from my personal experience would be with **voxel.js**
    – an open source voxel game-building toolkit. While not that popular, it is a
    great example of creative use of JavaScript, combining both frontend and backend
    technologies. It is a framework built by a small team that fills in a niche for
    an audience of developers, who are looking into working on games and visualizations.
    voxel.js did not set out to be a world-changing framework; instead, it was a creative
    outlet for many to create. While exploring voxel.js in my personal project, I
    learned a lot about unique framework and module structures, and it was fun to
    experiment with systems that enable more imaginative thinking.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我个人的经验，一个值得注意的框架是**voxel.js**——一个开源的体素游戏构建工具包。虽然它并不那么流行，但它是一个创造性使用JavaScript的绝佳例子，结合了前端和后端技术。这是一个由小型团队构建的框架，为那些想要从事游戏和可视化开发的开发者群体填补了一个空白。voxel.js并非旨在成为一个改变世界的框架；相反，它为许多人提供了一个创造性表达的途径。在我个人的项目中探索voxel.js时，我学到了很多关于独特框架和模块结构的知识，并且尝试那些能够激发更多创造性思维的系统是一件很有趣的事情。
- en: Contributing to new projects
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为新项目做出贡献
- en: These experiences with JavaScript frameworks in frontend, backend, and developer
    systems were incredibly valuable to me as part of my career. I have learned the
    importance of following best practices, adhering to software patterns, and developing
    for various runtime environments, which ultimately helped me write better code
    and deliver successful projects. As part of this book, I am sharing my learnings
    and as much knowledge as possible for the next generation of devoted JavaScript
    developers to build and contribute to their own framework projects.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在前端、后端和开发者系统中的JavaScript框架经验对我来说作为职业生涯的一部分是极其宝贵的。我学会了遵循最佳实践、遵守软件模式以及为各种运行时环境开发的重要性，这最终帮助我编写了更好的代码并成功交付了项目。作为本书的一部分，我分享了我的学习经验和尽可能多的知识，以便下一代虔诚的JavaScript开发者能够构建和贡献他们自己的框架项目。
- en: The projects that I have been involved in always had different origins. In my
    case, I had to work with both private and open source frameworks. In work projects,
    I have focused on combining open source tooling with the context of the larger
    business organization. This approach helped align the existing tooling with the
    requirements of particular projects. In the open source context, I have been lucky
    to contribute to projects that have improved the overall developer experience.
    In many of the scenarios, I got to work on projects that were innovative and were
    firsts of their kind in the JavaScript ecosystem. For example, when Grunt.js was
    coming along, there were task runner tools from other languages, but the JavaScript
    tools were in their inception. Contributing to voxel.js was a similar experience;
    as more HTML5 APIs and WebGL enable more advanced graphics on the web, it enabled
    voxel.js as a project and created the contributor community.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与的项目总是有不同的起源。在我的情况下，我必须与私有和开源框架一起工作。在工作项目中，我专注于将开源工具与更大的商业组织环境相结合。这种方法有助于将现有工具与特定项目的需求相一致。在开源环境中，我有幸为那些改善了整体开发者体验的项目做出贡献。在许多场景中，我有机会参与那些创新且在JavaScript生态系统中的首创项目。例如，当Grunt.js正在发展时，有来自其他语言的作业运行工具，但JavaScript工具还处于起步阶段。为voxel.js做出贡献有类似的体验；随着更多HTML5
    API和WebGL使网页上的图形更加先进，它使voxel.js项目成为可能，并创建了贡献者社区。
- en: During my contributions to the Intern.js testing framework, the overall feeling
    was that there were not fully fledged testing frameworks that solved all of the
    needs of web application testing. The goal of this project was to create an all-in
    solution for testing using the same types of testing APIs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我为Intern.js测试框架做出贡献的过程中，整体感觉是没有完全成熟的测试框架能够解决网络应用程序测试的所有需求。这个项目的目标是创建一个使用相同类型测试API的全能测试解决方案。
- en: The framework that we create in this book focuses on the use of modern technologies,
    such as Web Components, intermixed with popular JavaScript libraries. The Web
    Components field does not feel as explored in the ecosystem just yet; therefore,
    with this book, we are taking aim to further widen the knowledge of these technologies
    among web developers. Besides expanding those skills, one of the greater goals
    is to make the framework development process more approachable and demystify the
    established JavaScript systems.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中所创建的框架侧重于使用现代技术，如Web组件，与流行的JavaScript库混合使用。在生态系统中，Web组件领域尚未得到充分探索；因此，通过本书，我们旨在进一步拓宽网络开发者对这些技术的了解。除了扩展这些技能外，一个更大的目标是将框架开发过程变得更加易于接近，并揭开既定JavaScript系统的神秘面纱。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This first chapter began our exploration into how the web application development
    process has changed from pure basics into a full-fledged software platform. We
    have looked at how the innovations and challenges of the web shape the frameworks
    discussed in this chapter and play a huge role in offering a variety of useful
    features to web developers. As part of my career journey, working on various projects
    made me appreciate how much can be achieved by combining elegant patterns and
    the creative use of the JavaScript programming language.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章开始，我们探索了网络应用程序开发过程是如何从纯基础转变为完整的软件平台的。我们研究了网络创新和挑战如何塑造本章讨论的框架，并在为网络开发者提供各种有用功能方面发挥巨大作用。在我的职业生涯旅程中，参与各种项目让我欣赏到通过结合优雅的模式和JavaScript编程语言的创造性使用所能取得的成就。
- en: As part of the framework showcase, it is evident that the ecosystem has a lot
    of options for the browser and other places where JavaScript runtime functions.
    However, there is always room for improvement in speed, features, and unique ideas,
    which can help us enhance the development processes. The significant part that
    stimulates this ecosystem is the ever-evolving web platform, development of the
    ECMAScript specification, and of course, the hard work of maintainers of runtimes
    such as Node.js and Deno.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为框架展示的一部分，很明显，生态系统在浏览器和其他JavaScript运行时功能的地方有很多选择。然而，在速度、功能和独特想法方面，总有改进的空间，这可以帮助我们提高开发过程。刺激这个生态系统的关键部分是不断发展的网络平台、ECMAScript规范的制定，当然，还有Node.js和Deno等运行时维护者的辛勤工作。
- en: In the upcoming chapters, we will dive deeper into software paradigms, focusing
    on framework organization and their architectural patterns. In [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030),
    we are going to look at how frameworks are structured and organized.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地探讨软件范式，重点关注框架组织和它们的架构模式。在[*第二章*](B19014_02.xhtml#_idTextAnchor030)中，我们将探讨框架是如何构建和组织的。
