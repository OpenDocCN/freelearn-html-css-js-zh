- en: Chapter 5. Introduction to Mongoose
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Mongoose简介
- en: 'Mongoose is a robust Node.js ODM module that adds MongoDB support to your Express
    application. It uses schemas to model your entities, offers predefined validation
    along with custom validations, allows you to define virtual attributes, and uses
    middleware hooks to intercept operations. The Mongoose design goal is to bridge
    the gap between the MongoDB schemaless approach and the requirements of real-world
    application development. In this chapter, you''ll go through the following basic
    features of Mongoose:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose是一个强大的Node.js ODM模块，为您的Express应用程序添加了MongoDB支持。它使用模式来对实体进行建模，提供预定义验证以及自定义验证，允许您定义虚拟属性，并使用中间件钩子来拦截操作。Mongoose的设计目标是弥合MongoDB无模式方法与现实世界应用程序开发要求之间的差距。在本章中，您将了解Mongoose的以下基本特性：
- en: Mongoose schemas and models
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mongoose模式和模型
- en: Schema indexes, modifiers, and virtual attributes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式索引、修饰符和虚拟属性
- en: Using the model's methods and performing CRUD operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型的方法和执行CRUD操作
- en: Verifying your data using predefined and custom validators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预定义和自定义验证器验证您的数据
- en: Using middleware to intercept the model's methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件拦截模型的方法
- en: Introducing Mongoose
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Mongoose
- en: Mongoose is a Node.js module that provides developers with the ability to model
    objects and save them as MongoDB documents. While MongoDB is a schemaless database,
    Mongoose offers you the opportunity to enjoy both strict and loose schema approaches
    when dealing with Mongoose models. As with any other Node.js module, before you
    can start using it in your application, you will first need to install it. The
    examples in this chapter will continue directly from those in the previous chapters;
    so, for this chapter, copy the final example from [Chapter 3](ch03.html "Chapter 3. Building
    an Express Web Application"), *Building an Express Web Application*, and let's
    start from there.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose是一个Node.js模块，为开发人员提供了将对象建模并将其保存为MongoDB文档的能力。虽然MongoDB是一个无模式的数据库，但在处理Mongoose模型时，Mongoose为您提供了享受严格和宽松模式方法的机会。与任何其他Node.js模块一样，在您的应用程序中开始使用它之前，您首先需要安装它。本章中的示例将直接从前几章中的示例继续进行；因此，在本章中，从[第3章](ch03.html
    "第3章。构建一个Express Web应用程序")中复制最终示例，*构建一个Express Web应用程序*，然后从那里开始。
- en: Installing Mongoose
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Mongoose
- en: 'Once you''ve installed and verified that your MongoDB local instance is running,
    you''ll be able to connect it using the Mongoose module. First, you will need
    to install Mongoose in your `node_modules` folder, so change your `package.json`
    file to look like what is shown in the following code snippet:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并验证您的MongoDB本地实例正在运行后，您将能够使用Mongoose模块连接到它。首先，您需要在`node_modules`文件夹中安装Mongoose，因此将您的`package.json`文件更改为以下代码片段所示的样子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install your application dependencies, go to your application folder and
    issue the following command in your command-line tool:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装应用程序依赖项，请转到应用程序文件夹，并在命令行工具中发出以下命令：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will install the latest version of Mongoose in your `node_modules` folder.
    After the installation process has successfully finished, the next step will be
    to connect to your MongoDB instance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的`node_modules`文件夹中安装最新版本的Mongoose。安装过程成功完成后，下一步将是连接到您的MongoDB实例。
- en: Connecting to MongoDB
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到MongoDB
- en: 'To connect to MongoDB, you will need to use the MongoDB connection URI. The
    MongoDB connection URI is a string URL that tells the MongoDB drivers how to connect
    to the database instance. The MongoDB URI is usually constructed as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到MongoDB，您需要使用MongoDB连接URI。MongoDB连接URI是一个字符串URL，告诉MongoDB驱动程序如何连接到数据库实例。MongoDB
    URI通常构造如下：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since you''re connecting to a local instance, you can skip the username and
    password and use the following URI:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您正在连接到本地实例，可以跳过用户名和密码，使用以下URI：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The simplest thing to do is to define this connection URI directly in your
    `config/express.js` configuration file and use the `mongoose` module to connect
    to the database, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是直接在您的`config/express.js`配置文件中定义此连接URI，并使用`mongoose`模块连接到数据库，如下所示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, since you''re building a real application, saving the URI directly
    in the `config/express.js` file is a bad practice. The proper way to store application
    variables is to use your environment configuration file. Go to your `config/env/development.js`
    file and change it to look like what is shown in the following code snippet:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于您正在构建一个真实的应用程序，直接在`config/express.js`文件中保存URI是一种不好的做法。存储应用程序变量的正确方法是使用您的环境配置文件。转到您的`config/env/development.js`文件，并将其更改为以下代码片段所示的样子：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now in your `config` folder, create a new file named `mongoose.js`, which contains
    the following code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在您的`config`文件夹中，创建一个名为`mongoose.js`的新文件，其中包含以下代码片段：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note how you required the `mongoose` module and connected to the MongoDB instance
    using the `db` property of your configuration object. To initialize your Mongoose
    configuration, go back to your `server.js` file and change it to look like what
    is shown in the following code snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要`mongoose`模块并使用配置对象的`db`属性连接到MongoDB实例。要初始化Mongoose配置，请返回到您的`server.js`文件，并将其更改为以下代码片段所示的样子：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That''s it; you have installed Mongoose, updated your configuration file, and
    connected to your MongoDB instance. To start your application, use your command-line
    tool and navigate to your application folder to execute the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；您已经安装了Mongoose，更新了配置文件，并连接到了MongoDB实例。要启动应用程序，请使用命令行工具并导航到应用程序文件夹，执行以下命令：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Your application should be running and be connected to the MongoDB local instance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序应该正在运行并连接到MongoDB本地实例。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you experience any problems or get the `Error: failed to connect to [localhost:27017]`
    output, make sure that your MongoDB instance is running properly.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到任何问题或出现“错误：无法连接到[localhost:27017]”的输出，请确保您的MongoDB实例正常运行。
- en: Understanding Mongoose schemas
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Mongoose模式
- en: Connecting to your MongoDB instance was the first step, but the real magic of
    the Mongoose module is its ability to define a document schema. As you already
    know, MongoDB uses collections to store multiple documents, which aren't required
    to have the same structure as one another. However, when dealing with objects,
    it is sometimes necessary for documents to be similar. Mongoose uses a schema
    object to define the document list of properties, each with its own type and constraints
    in order to enforce the document structure. After specifying a schema, you will
    go on to define a Model constructor, which you'll use to create instances of MongoDB
    documents. In this section, you'll learn how to define a user schema and model
    and how to use a model instance to create, retrieve, and update user documents.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到您的MongoDB实例是第一步，但Mongoose模块的真正魔力在于其定义文档模式的能力。正如您已经知道的，MongoDB使用集合来存储多个文档，这些文档不需要具有相同的结构。但是，在处理对象时，有时需要文档相似。Mongoose使用模式对象来定义文档属性列表，每个属性都有自己的类型和约束，以强制执行文档结构。在指定模式之后，您将继续定义一个模型构造函数，用于创建MongoDB文档的实例。在本节中，您将学习如何定义用户模式和模型，以及如何使用模型实例来创建、检索和更新用户文档。
- en: Creating the user schema and model
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户模式和模型
- en: 'To create your first schema, go to the `app/models` folder and create a new
    file named `user.server.model.js`. In this file, paste the following lines of
    code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建您的第一个模式，请转到`app/models`文件夹并创建一个名为`user.server.model.js`的新文件。在此文件中，粘贴以下代码行：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code snippet, you did two things: first, you defined your
    `UserSchema` object using the `Schema` constructor, and then you used the schema
    instance to define your User model. Note that for simplicity reasons, we save
    the password as clear text; however, in real world applications, the user password
    should be properly encrypted. Next, you''ll learn how to use the User model to
    perform CRUD operations in your application''s logic layer.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，您做了两件事：首先，使用`Schema`构造函数定义了您的`UserSchema`对象，然后使用模式实例定义了您的User模型。请注意，出于简单起见，我们将密码保存为明文；但是，在实际应用程序中，用户密码应该得到适当的加密。接下来，您将学习如何使用User模型在应用程序逻辑层执行CRUD操作。
- en: Registering the User model
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册User模型
- en: 'Before you can start using the User model, you will need to include the `user.server.model.js`
    file in your Mongoose configuration file in order to register the User model.
    To do this, change your `config/mongoose.js` file to look like what is shown in
    the following code snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以开始使用User模型之前，您需要在Mongoose配置文件中包含`user.server.model.js`文件，以注册User模型。为此，请更改您的`config/mongoose.js`文件，使其看起来像以下代码片段中所示：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Make sure that your Mongoose configuration file is loaded before any other configuration
    is performed in the `server.js` file. This is important since any module that
    is loaded after this module will be able to use the User model without loading
    it by itself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`server.js`文件中执行任何其他配置之前加载Mongoose配置文件。这很重要，因为在此模块之后加载的任何模块都将能够使用User模型，而无需自行加载它。
- en: Creating new users using save()
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用save()创建新用户
- en: 'You can start using the User model right away, but to keep things organized,
    it is better that you create a `Users` controller that will handle all user-related
    operations. In the `app/controllers` folder, create a new file named `users.server.controller.js`
    and paste the following lines of code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以立即开始使用User模型，但为了保持组织有序，最好创建一个`Users`控制器，用于处理所有与用户相关的操作。在`app/controllers`文件夹中，创建一个名为`users.server.controller.js`的新文件，并粘贴以下代码行：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's go over this code. First, you used the `mongoose` module to call the `model`
    method, which will return the `User` model you defined previously. Next, you create
    a controller method named `create()`, which you will later use to create new users.
    Using the new keyword, the `create()` method creates a new model instance, which
    is populated using the request body. Finally, you call the model instance's `save()`
    method, which either saves the user and outputs the `user` object or fails it,
    passing the error to the next middleware.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码。首先，您使用`mongoose`模块调用`model`方法，该方法将返回您之前定义的`User`模型。接下来，您创建了一个名为`create()`的控制器方法，稍后将用于创建新用户。使用`new`关键字，`create()`方法创建一个新的模型实例，该实例使用请求体进行填充。最后，您调用模型实例的`save()`方法，该方法要么保存用户并输出`user`对象，要么失败并将错误传递给下一个中间件。
- en: 'To test your new controller, let''s add a set of user-related routes that call
    the controller''s methods. Begin by creating a file named `users.server.routes.js`
    inside the `app/routes` folder. In this newly created file, paste the following
    lines of code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的新控制器，让我们添加一组调用控制器方法的与用户相关的路由。首先，在`app/routes`文件夹中创建一个名为`users.server.routes.js`的文件。在这个新创建的文件中，粘贴以下代码行：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since your Express application will serve mainly as a RESTful API for the AngularJS
    application, it is a best practice to build your routes according to the REST
    principles. In this case, the proper way to create a new user is to use an HTTP
    POST request to the base `users` route you defined here. Change your `config/express.js`
    file to look like what is shown in the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的Express应用程序主要将作为AngularJS应用程序的RESTful API，因此最佳实践是根据REST原则构建路由。在这种情况下，创建新用户的正确方式是使用HTTP
    POST请求到您在此定义的基本`users`路由。更改您的`config/express.js`文件，使其看起来像以下代码片段中所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That''s it! To test it out, go to your root application folder and execute
    the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！要进行测试，请转到根应用程序文件夹并执行以下命令：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Your application should be running. To create a new user, perform an HTTP POST
    request to the base `users` route and make sure that the request body includes
    the following JSON:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序应该正在运行。要创建新用户，请执行HTTP POST请求到基本的`users`路由，并确保请求体包含以下JSON：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another way to test your application would be to execute the following `curl`
    command in your command-line tool:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种测试应用程序的方法是在命令行工具中执行以下`curl`命令：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You are going to execute many different HTTP requests to test your application.
    For Mac OS X and Linux users, `curl` is a useful tool, but there are several other
    tools specifically designed for this task; we recommend that you find your favorite
    one and use it from now on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您将执行许多不同的HTTP请求来测试您的应用程序。对于Mac OS X和Linux用户，`curl`是一个有用的工具，但还有其他几种专门设计用于此任务的工具；我们建议您找到自己喜欢的工具并从现在开始使用它。
- en: Finding multiple user documents using find()
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`find()`查找多个用户文档
- en: 'The `find()` method is a model method that retrieves multiple documents stored
    in the same collection using a query and is a Mongoose implementation of the MongoDB
    `find()` collection method. To understand this better, add the following `list()`
    method to your `app/controllers/users.server.controller.js` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()`方法是一个模型方法，它使用查询检索存储在同一集合中的多个文档，并且是MongoDB `find()`集合方法的Mongoose实现。为了更好地理解这一点，请将以下`list()`方法添加到您的`app/controllers/users.server.controller.js`文件中：'
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note how the new `list()` method uses the `find()` method to retrieve an array
    of all the documents in the `users` collection. To use the new method you created,
    you''ll need to register a route for it, so go to your `app/routes/users.server.routes.js`
    file and change it to look like what is shown in the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新的`list()`方法如何使用`find()`方法来检索`users`集合中所有文档的数组。要使用您创建的新方法，您需要为其注册一个路由，因此转到您的`app/routes/users.server.routes.js`文件并更改为以下代码片段所示：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All you have left to do is run your application by executing the following
    command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的就是通过执行以下命令运行应用程序：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, you will be able to retrieve a list of your users by visiting `http://localhost:3000/users`
    in your browser.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将能够通过在浏览器中访问`http://localhost:3000/users`来检索用户列表。
- en: Advanced querying using find()
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`find()`进行高级查询
- en: 'In the preceding code example, the `find()` method accepted two arguments,
    a MongoDB query object and a callback function, but it can accept up to four parameters:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，`find()`方法接受了两个参数，一个是MongoDB查询对象，另一个是回调函数，但它最多可以接受四个参数：
- en: '`Query`: This is a MongoDB query object'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Query`：这是一个MongoDB查询对象'
- en: '`[Fields]`: This is an optional string object that represents the document
    fields to be returned'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Fields]`：这是一个可选的字符串对象，表示要返回的文档字段'
- en: '`[Options]`: This is an optional `options` object'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Options]`：这是一个可选的`options`对象'
- en: '`[Callback]`: This is an optional callback function'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Callback]`：这是一个可选的回调函数'
- en: 'For instance, in order to retrieve only the usernames and e-mails of your users,
    you will need to modify your call to look like what is shown in the following
    lines of code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了仅检索用户的用户名和电子邮件，您需要修改调用，使其类似于以下代码行所示：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Furthermore, you can also pass an `options` object when calling the `find()`
    method, which will manipulate the query result. For instance, to paginate through
    the `users` collection and retrieve only a subset of your `users` collection,
    you can use the `skip` and `limit` options, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当调用`find()`方法时，还可以传递一个`options`对象，该对象将操作查询结果。例如，要通过`skip`和`limit`选项分页浏览`users`集合并仅检索`users`集合的子集，可以使用以下方法：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will return a subset of up to 10 user documents while skipping the first
    10 documents.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回最多10个用户文档的子集，同时跳过前10个文档。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about query options, it is recommended that you visit the official
    Mongoose documentation at [http://mongoosejs.com/docs/api.html](http://mongoosejs.com/docs/api.html).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多有关查询选项的信息，建议您访问官方的Mongoose文档[http://mongoosejs.com/docs/api.html](http://mongoosejs.com/docs/api.html)。
- en: Reading a single user document using findOne()
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`findOne()`读取单个用户文档
- en: 'Retrieving a single user document is done using the `findOne()` method, which
    is very similar to the `find()` method, but it retrieves only the first document
    of the subset. To start working with a single user document, we''ll have to add
    two new methods. Add the following lines of code to the end of your `app/controllers/users.server.controller.js`
    file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`findOne()`方法检索单个用户文档，这与`find()`方法非常相似，但它仅检索子集的第一个文档。要开始处理单个用户文档，我们需要添加两个新方法。将以下代码行添加到您的`app/controllers/users.server.controller.js`文件的末尾：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `read()` method is simple to understand; it is just responding with a JSON
    representation of the `req.user` object, but what is creating the `req.user` object?
    Well, the `userById()` method is the one responsible for populating the `req.user`
    object. You will use the `userById()` method as a middleware to deal with the
    manipulation of single documents when performing read, delete, and update operations.
    To do this, you will have to modify your `app/routes/users.server.routes.js` file
    to look like what is shown in the following lines of code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`read()`方法很容易理解；它只是用`req.user`对象的JSON表示进行响应，但是是谁创建了`req.user`对象呢？嗯，`userById()`方法负责填充`req.user`对象。在执行读取、删除和更新操作时，您将使用`userById()`方法作为中间件来处理单个文档的操作。为此，您需要修改`app/routes/users.server.routes.js`文件，使其类似于以下代码行所示：'
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note how you added the `users.read()` method with a request path containing
    `userId`. In Express, adding a colon before a substring in a route definition
    means that this substring will be handled as a request parameter. To handle the
    population of the `req.user` object, you use the `app.param()` method, which defines
    a middleware to be executed before any other middleware that uses that parameter.
    Here, the `users.userById()` method will be executed before any other middleware
    registered with the `userId` parameter, which is the `users.read()` middleware
    in this case. This design pattern is useful when building a RESTful API, where
    you often add request parameters to the routing string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您添加了包含`userId`的请求路径的`users.read()`方法。在Express中，在路由定义中的子字符串前添加冒号意味着该子字符串将被处理为请求参数。为了处理`req.user`对象的填充，您使用`app.param()`方法，该方法定义了在使用该参数的任何其他中间件之前执行的中间件。在这里，`users.userById()`方法将在此情况下`users.read()`中注册的任何其他使用`userId`参数的中间件之前执行。在构建RESTful
    API时，此设计模式非常有用，其中您经常向路由字符串添加请求参数。
- en: 'To test this out, run your application using the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个，使用以下命令运行您的应用程序：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, navigate to `http://localhost:3000/users` in your browser, grab one of
    your users' `_id` values, and navigate to `http://localhost:3000/users/[id]`,
    replacing the `[id]` part with the user's `_id` value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在浏览器中导航到`http://localhost:3000/users`，获取其中一个用户的`_id`值，并导航到`http://localhost:3000/users/[id]`，将`[id]`部分替换为用户的`_id`值。
- en: Updating an existing user document
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新现有用户文档
- en: 'The Mongoose model has several available methods to update an existing document.
    Among these are the `update()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`
    methods. Each of the methods serves a different level of abstraction, easing the
    `update` operation when possible. In our case, and since we already use the `userById()`
    middleware, the easiest way to update an existing document would be to use the
    `findByIdAndUpdate()` method. To do this, go back to your `app/controllers/users.server.controller.js`
    file and add a new `update()` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose模型有几种可用的方法来更新现有文档。其中包括`update()`、`findOneAndUpdate()`和`findByIdAndUpdate()`方法。每种方法在可能时都提供了不同级别的抽象，简化了`update`操作。在我们的情况下，由于我们已经使用了`userById()`中间件，更新现有文档的最简单方法是使用`findByIdAndUpdate()`方法。要做到这一点，返回到您的`app/controllers/users.server.controller.js`文件并添加一个新的`update()`方法：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Observe how you used the user''s `id` field to find and update the correct
    document. Note that the default Mongoose behavior is to pass the callback to the
    document before it was updated; by setting the `new` option to `true`, we''re
    making sure that we''re receiving the updated document. The next thing you should
    do is wire your new `update()` method in your users'' routing module. Go back
    to your `app/routes/users.server.routes.js` file and change it to look like what
    is shown in the following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您如何使用用户的`id`字段来查找和更新正确的文档。请注意，默认的Mongoose行为是在更新文档之前将回调传递给文档；通过将`new`选项设置为`true`，我们确保我们收到更新后的文档。接下来您应该做的是在用户的路由模块中连接您的新的`update()`方法。返回到您的`app/routes/users.server.routes.js`文件并将其更改为以下代码片段所示的样子：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note how you used the route you had previously created and how you just chained
    the `update()` method using the route''s `put()` method. To test your `update()`
    method, run your application using the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您如何使用之前创建的路由，并如何使用路由的`put()`方法链接`update()`方法。要测试您的`update()`方法，请使用以下命令运行您的应用程序：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, use your favorite REST tool to issue a PUT request, or use `curl` and
    execute this command, replacing the `[id]` part with a real document''s `_id`
    property:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用您喜欢的REST工具发出PUT请求，或者使用`curl`并执行此命令，将`[id]`部分替换为实际文档的`_id`属性：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Deleting an existing user document
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除现有用户文档
- en: 'The Mongoose model has several available methods for removing an existing document.
    Among these are the `remove()`, `findOneAndRemove()`, and `findByIdAndRemove()`
    methods. In our case, and since we already use the `userById()` middleware, the
    easiest way to remove an existing document would be to simply use the `remove()`
    method. To do this, go back to your `app/controllers/users.server.controller.js`
    file and add the following `delete()` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose模型有几种可用的方法来删除现有文档。其中包括`remove()`、`findOneAndRemove()`和`findByIdAndRemove()`方法。在我们的情况下，由于我们已经使用了`userById()`中间件，删除现有文档的最简单方法就是简单地使用`remove()`方法。要做到这一点，返回到您的`app/controllers/users.server.controller.js`文件并添加以下`delete()`方法：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note how you used the `user` object to remove the correct document. The next
    thing you should do is use your new `delete()` method in your user''s routing
    file. Go to your `app/routes/users.server.routes.js` file and change it to look
    like what is shown in the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您如何使用`user`对象来删除正确的文档。接下来您应该做的是在用户的路由文件中使用您的新的`delete()`方法。转到您的`app/routes/users.server.routes.js`文件并将其更改为以下代码片段所示的样子：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note how you used the route you had previously created and how you just chained
    the `delete()` method using the route''s `delete()` method. To test your `delete`
    method, run your application using the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您如何使用之前创建的路由，并如何使用路由的`delete()`方法链接`delete()`方法。要测试您的`delete`方法，请使用以下命令运行您的应用程序：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, use your favorite REST tool to issue a `DELETE` request, or use `curl`
    and execute the following command, replacing the `[id]` part with a real document''s
    `_id` property:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用您喜欢的REST工具发出`DELETE`请求，或者使用`curl`并执行以下命令，将`[id]`部分替换为实际文档的`_id`属性：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This completes the implementation of the four CRUD operations, providing you
    with a brief understanding of the Mongoose model capabilities. However, these
    methods are just examples of the vast features included with Mongoose. In the
    next section, you'll learn how to define default values, power your schema fields
    with modifiers, and validate your data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了四个CRUD操作的实现，让您简要了解了Mongoose模型的能力。然而，这些方法只是Mongoose包含的众多功能的示例。在下一节中，您将学习如何定义默认值，为模式字段提供动态功能，并验证您的数据。
- en: Extending your Mongoose schema
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展您的Mongoose模式
- en: Performing data manipulations is great, but in order to develop complex applications,
    you will need your ODM module to do more. Luckily, Mongoose supports various other
    features that help you safely model your documents and keep your data consistent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 进行数据操作是很好的，但为了开发复杂的应用程序，您需要让您的ODM模块做更多的事情。幸运的是，Mongoose支持各种其他功能，帮助您安全地对文档进行建模并保持数据的一致性。
- en: Defining default values
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义默认值
- en: Defining default field values is a common feature for data-modeling frameworks.
    You can add this functionality directly to your application's logic layer, but
    that would be messy and is generally a bad practice. Mongoose offers to define
    the default values at the schema level, helping you organize your code better
    and guaranteeing your documents' validity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 定义默认字段值是数据建模框架的常见功能。您可以直接将此功能添加到应用程序的逻辑层，但这样会很混乱，通常是一种不好的做法。Mongoose提供在模式级别定义默认值的功能，帮助您更好地组织代码并保证文档的有效性。
- en: 'Let''s say you want to add a created date field to your `UserSchema`. The created
    date field should be initialized at creation time and the time at which the user
    document was initially created should be saved—a perfect example of when you can
    utilize a default value. To do this, you''ll have to change your `UserSchema`;
    so, go back to your `app/models/user.server.model.js` file and change it to look
    like what is shown in the following code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要向你的`UserSchema`添加一个创建日期字段。创建日期字段应该在创建时初始化，并且应该保存用户文档最初创建的时间，这是一个完美的例子，你可以利用默认值。为了做到这一点，你需要更改你的`UserSchema`；所以，回到你的`app/models/user.server.model.js`文件，并将其更改为以下代码片段所示的样子：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note how the created field is added and its default value defined. From now
    on, every new user document will be created with a default creation date that
    represents the moment the document was created. You should also note that every
    user document created prior to this schema change would be assigned a created
    field representing the moment you queried for it, since these documents don't
    have the created field initialized.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`created`字段的添加和其默认值的定义。从现在开始，每个新的用户文档都将被创建一个默认的创建日期，代表文档创建的时刻。你还应该注意，在此模式更改之前创建的每个用户文档都将被分配一个创建字段，代表你查询它的时刻，因为这些文档没有初始化创建字段。
- en: 'To test your new changes, run your application using the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的新更改，使用以下命令运行你的应用程序：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, use your favorite REST tool to issue a POST request or use `curl` and
    execute the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用你喜欢的REST工具发出一个POST请求，或者使用`curl`并执行以下命令：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A new user document will be created with a default created field initialized
    at the moment of creation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将会创建一个新的用户文档，其中包含一个默认的创建字段，在创建时初始化。
- en: Using schema modifiers
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模式修饰符
- en: Sometimes, you may want to perform a manipulation over schema fields before
    saving them or presenting them to the client. For this purpose, Mongoose uses
    a feature called *modifiers*. A modifier can either change the field's value before
    saving the document, or it can represent it differently at query time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望在保存或呈现给客户端之前对模式字段进行操作。为此，Mongoose使用了一个称为*修饰符*的功能。修饰符可以在保存文档之前更改字段的值，也可以在查询时以不同的方式表示它。
- en: Predefined modifiers
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预定义的修饰符
- en: 'The simplest modifiers are the predefined ones included with Mongoose. For
    instance, string-type fields can have a trim modifier to remove whitespaces, an
    uppercase modifier to uppercase the field value, and so on. To understand how
    predefined modifiers work, let''s make sure the username of your users is clear
    from a leading and trailing whitespace. To do this, all you have to do is change
    your `app/models/user.server.model.js` file to look like what is shown in the
    following code snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的修饰符是Mongoose附带的预定义修饰符。例如，字符串类型的字段可以有一个修剪修饰符来去除空格，一个大写修饰符来将字段值大写，等等。为了理解预定义修饰符的工作原理，让我们确保你的用户的用户名不包含前导和尾随空格。要做到这一点，你只需要更改你的`app/models/user.server.model.js`文件，使其看起来像以下代码片段所示的样子：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note the `trim` property added to the `username` field. This will make sure
    your username data will be kept trimmed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`username`字段中添加的`trim`属性。这将确保你的用户名数据将被保持修剪。
- en: Custom setter modifiers
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义setter修饰符
- en: 'Predefined modifiers are great, but you can also define your own custom setter
    modifiers to handle data manipulation before saving the document. To understand
    this better, let''s add a new `website` field to your User model. The `website`
    field should begin with `http://` or `https://`, but instead of forcing your customer
    to add this in the UI, you can simply write a custom modifier that validates the
    existence of these prefixes and adds them when required. To add your custom modifier,
    you will need to create the new `website` field with a `set` property, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的修饰符很棒，但你也可以定义自己的自定义setter修饰符来处理保存文档之前的数据操作。为了更好地理解这一点，让我们向你的用户模型添加一个新的`website`字段。`website`字段应该以`http://`或`https://`开头，但是不要强迫你的客户在UI中添加这些前缀，你可以简单地编写一个自定义修饰符来验证这些前缀的存在，并在需要时添加它们。要添加你的自定义修饰符，你需要创建一个带有`set`属性的新的`website`字段，如下所示：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, every user created will have a properly formed website URL that is modified
    at creation time. However, what if you already have a big collection of user documents?
    You can, of course, migrate your existing data, but when dealing with big datasets,
    it would have a serious performance impact, so you can simply use getter modifiers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个创建的用户都将拥有一个在创建时修改的正确形式的网站URL。然而，如果你已经有了一个大量的用户文档集合，你当然可以迁移你现有的数据，但是当处理大型数据集时，这将会对性能产生严重影响，所以你可以简单地使用getter修饰符。
- en: Custom getter modifiers
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义getter修饰符
- en: '**Getter** modifiers are used to modify existing data before outputting the
    documents to the next layer. For instance, in our previous example, a getter modifier
    would sometimes be better for changing the already existing user documents by
    modifying their website field at query time instead of going over your MongoDB
    collection and updating each document. To do this, all you have to do is change
    your `UserSchema`, as shown in the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Getter**修饰符用于在将文档输出到下一层之前修改现有数据。例如，在我们之前的示例中，getter修饰符有时会更好地通过在查询时修改网站字段来更改已经存在的用户文档，而不是遍历你的MongoDB集合并更新每个文档。要做到这一点，你只需要更改你的`UserSchema`，如下面的代码片段所示：'
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You simply changed the setter modifier to a getter modifier by changing the
    `set` property to `get`. However, the important thing to notice here is how you
    configured your schema using `UserSchema.set()`. This will force Mongoose to include
    getters when converting the MongoDB document to a JSON representation and will
    allow the output of documents using `res.json()` in order to include the getter's
    behavior. If you didn't include this, you would have your document's JSON representation
    ignoring the getter modifiers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需通过将`set`属性更改为`get`来将setter修改器更改为getter修改器。然而，这里需要注意的重要事情是如何使用`UserSchema.set()`配置了你的模式。这将强制Mongoose在将MongoDB文档转换为JSON表示时包含getter，并允许使用`res.json()`输出文档以包含getter的行为。如果你没有包含这个，你的文档的JSON表示将忽略getter修改器。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modifiers are powerful and can save you a lot of time, but they should be used
    with caution in order to prevent unpredicted application behavior. It is recommended
    that you visit [http://mongoosejs.com/docs/api.html](http://mongoosejs.com/docs/api.html)
    for more information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 修改器非常强大，可以节省大量时间，但应谨慎使用，以防止出现意外的应用程序行为。建议您访问[http://mongoosejs.com/docs/api.html](http://mongoosejs.com/docs/api.html)获取更多信息。
- en: Adding virtual attributes
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加虚拟属性
- en: 'Sometimes, you may want to have dynamically calculated document properties,
    which are not really presented in the document. These properties are called *virtual
    attributes*, and they can be used to address several common requirements. For
    instance, let''s say you want to add a new `fullName` field, which will represent
    the concatenation of the user''s first and last names. To do this, you will have
    to use the `virtual()` schema method; so, a modified `UserSchema` would include
    the following code snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望有动态计算的文档属性，这些属性实际上并不在文档中呈现。这些属性称为*虚拟属性*，它们可以用来满足几个常见的需求。例如，假设你想要添加一个新的`fullName`字段，它将表示用户的名和姓的连接。为此，你将需要使用`virtual()`模式方法；因此，修改后的`UserSchema`将包括以下代码片段：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code example, you added a virtual attribute named `fullName`
    to your `UserSchema`, added a `getter` method to that virtual attribute, and then
    configured your schema to include virtual attributes when converting the MongoDB
    document to a JSON representation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，你向`UserSchema`添加了一个名为`fullName`的虚拟属性，为该虚拟属性添加了一个`getter`方法，然后配置了你的模式以在将MongoDB文档转换为JSON表示时包含虚拟属性。
- en: 'However, virtual attributes can also have setters in order to help you save
    your documents they way you prefer instead of just adding more field attributes.
    In this case, let''s say you wanted to break an input''s `fullName` field into
    your first and last name fields. To do this, a modified virtual declaration would
    look like what is shown in the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虚拟属性也可以有setter，以帮助你保存你的文档，而不仅仅是添加更多字段属性。在这种情况下，假设你想要将输入的`fullName`字段分解为名和姓字段。为此，修改后的虚拟声明将如下代码片段所示：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Virtual attributes are a great feature of Mongoose, allowing you to modify document
    representation as they're being moved through your application's layers without
    getting persisted to MongoDB.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟属性是Mongoose的一个很棒的特性，允许你在文档表示被传递到应用程序的各个层时修改它们，而不会被持久化到MongoDB中。
- en: Optimizing queries using indexes
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用索引优化查询
- en: As we previously discussed, MongoDB supports various types of indexes to optimize
    query execution. Mongoose also supports the indexing functionality and even allows
    you to define secondary indexes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，MongoDB支持各种类型的索引来优化查询执行。Mongoose也支持索引功能，甚至允许你定义次要索引。
- en: 'The basic example of indexing is the unique index, which validates the uniqueness
    of a `document` field across a collection. In our example, it is common to keep
    usernames unique, so in order to convey this to MongoDB, you will need to modify
    your `UserSchema` definition to include the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的基本示例是唯一索引，它验证了集合中`document`字段的唯一性。在我们的示例中，保持用户名唯一是很常见的，因此为了传达这一点给MongoDB，你需要修改你的`UserSchema`定义，包括以下代码片段：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will tell MongoDB to create a unique index for the `username` field of
    the `users` collections. Mongoose also supports the creation of secondary indexes
    using the `index` property. So, if you know that your application will use a lot
    of queries involving the `email` field, you can optimize these queries by creating
    an e-mail secondary index, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉MongoDB为`users`集合的`username`字段创建一个唯一索引。Mongoose还支持使用`index`属性创建次要索引。因此，如果你知道你的应用程序将使用大量涉及`email`字段的查询，你可以通过以下方式优化这些查询，创建一个电子邮件次要索引：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Indexing is a wonderful feature of MongoDB, but you should keep in mind that
    it might cause you some trouble. For example, if you define a unique index on
    a collection where data is already stored, you might encounter some errors while
    running your application until you fix the issues with your collection data. Another
    common issue is Mongoose's automatic creation of indexes when the application
    starts, a feature that can cause major performance issues when running in a production
    environment.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是MongoDB的一个很棒的特性，但你应该记住它可能会给你带来一些麻烦。例如，如果你在已经存储数据的集合上定义了唯一索引，你可能会在运行应用程序时遇到一些错误，直到你解决了集合数据的问题。另一个常见问题是Mongoose在应用程序启动时自动创建索引，这个特性可能会在生产环境中导致严重的性能问题。
- en: Defining custom model methods
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自定义模型方法
- en: Mongoose models are quite packed with both static and instance predefined methods,
    some of which you have already used. However, Mongoose also lets you define your
    own custom methods to empower your models, giving you a modular tool to separate
    your application logic properly. Let's go over the proper way of defining these
    methods.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose模型中既包含静态方法又包含实例预定义方法，其中一些你已经使用过。然而，Mongoose还允许你定义自己的自定义方法来增强你的模型，为你提供一个模块化的工具来正确分离你的应用程序逻辑。让我们来看一下定义这些方法的正确方式。
- en: Defining custom static methods
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自定义静态方法
- en: 'Model static methods give you the liberty to perform model-level operations,
    such as adding extra `find` methods. For instance, let''s say you want to search
    users by their username. You could, of course, define the `this` method in your
    controller, but that wouldn''t be the right place for it. What you''re looking
    for is a static model method. To add a static method, you will need to declare
    it as a member of your schema''s `statics` property. In our case, adding a `findOneByUsername()`
    method would look like what is shown in the following code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 模型静态方法使您有自由进行模型级操作，例如添加额外的`find`方法。例如，假设您想通过他们的用户名搜索用户。当然，您可以在控制器中定义`this`方法，但那不是正确的地方。您要找的是静态模型方法。要添加静态方法，您需要将其声明为模式的`statics`属性的成员。在我们的情况下，添加一个`findOneByUsername()`方法将看起来像下面的代码片段所示：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This method is using the model''s `findOne()` method to retrieve a user document
    that has a certain username. Using the new `findOneByUsername()` method would
    be similar to using a standard `static` method by calling it directly from the
    `User` model, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用模型的`findOne()`方法来检索具有特定用户名的用户文档。使用新的`findOneByUsername()`方法类似于直接从`User`模型调用标准的`static`方法，如下所示：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can, of course, come up with many other static methods; you'll probably
    need them when developing your application, so don't be afraid to add them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发应用程序时，您当然可以想出许多其他静态方法；您可能在开发应用程序时需要它们，所以不要害怕添加它们。
- en: Defining custom instance methods
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自定义实例方法
- en: 'Static methods are great, but what if you need methods that perform instance
    operations? Well, Mongoose offers support for those too, helping you slim down
    your code base and properly reuse your application code. To add an instance method,
    you will need to declare it as a member of your schema''s `methods` property.
    Let''s say you want to validate your user''s password with an `authenticate()`
    method. Adding this method would then be similar to what is shown in the following
    code snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法很棒，但如果您需要执行实例操作的方法怎么办？好吧，Mongoose也支持这些方法，帮助您精简代码库并正确重用应用程序代码。要添加实例方法，您需要将其声明为模式的`methods`属性的成员。假设您想使用`authenticate()`方法验证用户的密码。添加此方法将类似于下面的代码片段所示：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will allow you to call the `authenticate()` method from any `User` model
    instance, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您从任何`User`模型实例调用`authenticate()`方法，如下所示：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, defining custom model methods is a great way to keep your project
    properly organized while reusing common code. In the upcoming chapters, you'll
    discover how both instance and static methods can be very useful.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，定义自定义模型方法是保持项目正确组织并重用常见代码的好方法。在接下来的章节中，您将发现实例方法和静态方法都非常有用。
- en: Model validation
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型验证
- en: One of the major issues when dealing with data marshaling is validation. When
    users input information to your application, you'll often have to validate that
    information before passing it on to MongoDB. While you can validate your data
    at the logic layer of your application, it is more useful to do this at the model
    level. Luckily, Mongoose supports both simple predefined validators and more complex
    custom validators. Validators are defined at the field level of a document and
    are executed when the document is being saved. If a validation error occurs, the
    save operation is aborted and the error is passed to the callback.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据编组时的一个主要问题是验证。当用户向您的应用程序输入信息时，您经常需要在将信息传递给MongoDB之前验证该信息。虽然您可以在应用程序的逻辑层验证数据，但在模型级别进行此操作更有用。幸运的是，Mongoose支持简单的预定义验证器和更复杂的自定义验证器。验证器在文档的字段级别定义，并在保存文档时执行。如果发生验证错误，则保存操作将被中止，并将错误传递给回调函数。
- en: Predefined validators
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义验证器
- en: 'Mongoose supports different types of predefined validators, most of which are
    type-specific. The basic validation of any application is, of course, the existence
    of a value. To validate field existence in Mongoose, you''ll need to use the `required`
    property in the field you want to validate. Let''s say you want to verify the
    existence of a `username` field before you save the user document. To do this,
    you''ll need to make the following changes to your `UserSchema`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose支持不同类型的预定义验证器，其中大多数是特定于类型的。当然，任何应用程序的基本验证是值的存在。要在Mongoose中验证字段的存在，您需要在要验证的字段中使用`required`属性。假设您想在保存用户文档之前验证`username`字段的存在。为此，您需要对`UserSchema`进行以下更改：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will validate the existence of the `username` field when saving the document,
    thus preventing the saving of any document that doesn't contain that field.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在保存文档时验证`username`字段的存在，从而防止保存不包含该字段的任何文档。
- en: 'Besides the `required` validator, Mongoose also includes type-based predefined
    validators, such as the `enum` and `match` validators for strings. For instance,
    to validate your `email` field, you will need to change your `UserSchema` as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`required`验证器之外，Mongoose还包括基于类型的预定义验证器，例如用于字符串的`enum`和`match`验证器。例如，要验证您的`email`字段，您需要将`UserSchema`更改如下：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The usage of a `match` validator here will make sure that the `email` field
    value matches the given `regex` expression, thus preventing the saving of any
    document where the e-mail doesn't conform to the right pattern.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用`match`验证器将确保`email`字段值与给定的`regex`表达式匹配，从而防止保存任何不符合正确模式的电子邮件的文档。
- en: 'Another example is the `enum` validator, which can help you define a set of
    strings that are available for that field value. Let''s say you add a `role` field.
    A possible validation would look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是`enum`验证器，它可以帮助您定义可用于该字段值的一组字符串。假设您添加了一个`role`字段。可能的验证如下所示：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding condition will allow the insertion of only these three possible
    strings, thus preventing you from saving the document.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的条件将只允许插入这三个可能的字符串，从而防止您保存文档。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about predefined validators, it is recommended that you visit
    [http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于预定义验证器的信息，建议您访问[http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html)。
- en: Custom validators
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义验证器
- en: 'Other than predefined validators, Mongoose also enables you to define your
    own custom validators. Defining a custom validator is done using the `validate`
    property. The `validate` property value should be an array consisting of a **validation**
    function and an error message. Let''s say you want to validate the length of your
    user password. To do this, you would have to make these changes in your `UserSchema`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预定义的验证器，Mongoose还允许您定义自己的自定义验证器。使用`validate`属性来定义自定义验证器。`validate`属性的值应该是一个包含**验证**函数和错误消息的数组。假设您想要验证用户密码的长度。为此，您需要在`UserSchema`中进行以下更改：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This validator will make sure your user password is at least six characters
    long, or else it will prevent the saving of documents and pass the error message
    you defined to the callback.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该验证器将确保您的用户密码至少为六个字符长，否则它将阻止文档的保存并将您定义的错误消息传递给回调函数。
- en: Mongoose validation is a powerful feature that allows you to control your model
    and supply proper error handling, which you can use to help your users understand
    what went wrong. In the upcoming chapters, you'll learn how you can use Mongoose
    validators to handle users input and prevent common data inconsistencies.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose验证是一个强大的功能，允许您控制模型并提供适当的错误处理，您可以用它来帮助用户理解出了什么问题。在接下来的章节中，您将学习如何使用Mongoose验证器来处理用户输入并防止常见的数据不一致性。
- en: Using Mongoose middleware
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mongoose中间件
- en: 'Mongoose middleware are functions that can intercept the process of the `init`,
    `validate`, `save`, and `remove` instance methods. Middleware are executed at
    the instance level and have two types: pre middleware and post middleware.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose中间件是可以拦截`init`、`validate`、`save`和`remove`实例方法的函数。中间件在实例级别执行，并且有两种类型：预中间件和后中间件。
- en: Using pre middleware
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预中间件
- en: Pre middleware gets executed before the operation happens. For instance, a pre-save
    middleware will get executed before the saving of the document. This functionality
    makes pre middleware perfect for more complex validations and default values assignments.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 预中间件在操作发生前执行。例如，一个预保存中间件将在保存文档之前执行。这个功能使得预中间件非常适合更复杂的验证和默认值分配。
- en: 'A pre middleware is defined using the `pre()` method of the schema object,
    so validating your model using a pre middleware will look like what is shown in
    the following code snippet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pre()`方法定义预中间件，因此使用预中间件验证模型将如下所示：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Using post middleware
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用后中间件
- en: A post middleware gets executed after the operation happens. For instance, a
    post-save middleware will get executed after saving the document. This functionality
    makes post middleware perfect for logging your application logic.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 后中间件在操作发生后执行。例如，一个后保存中间件将在保存文档后执行。这个功能使得后中间件非常适合记录应用程序逻辑。
- en: 'A post middleware is defined using the `post()` method of the schema object,
    so logging your model''s `save()` method using a post middleware will look something
    like what is shown in the following code snippet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`post()`方法定义后中间件，因此使用后中间件记录模型的`save()`方法将如下所示：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Mongoose middleware are great for the performing of various operations, including
    logging, validation, and performing various data consistency manipulations. Don't
    worry if you feel overwhelmed right now because later on in this book, you'll
    understand these better.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose中间件非常适合执行各种操作，包括日志记录、验证和执行各种数据一致性操作。如果您现在感到不知所措，不要担心，因为在本书的后面，您将更好地理解这些内容。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about middleware, it is recommended that you visit [http://mongoosejs.com/docs/middleware.html](http://mongoosejs.com/docs/middleware.html).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于中间件的信息，建议您访问[http://mongoosejs.com/docs/middleware.html](http://mongoosejs.com/docs/middleware.html)。
- en: Using Mongoose ref fields
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mongoose的ref字段
- en: Although MongoDB doesn't support joins, it supports the reference from a document
    to another document using a convention named **DBRef**. DBRef enables the reference
    from one document to another using a special field that contains the collection
    name and the document `ObjectId` field. Mongoose implements a similar behavior
    for supporting document referral using the `ObjectID` schema type and the use
    of the `ref` property. It also supports the population of the parent document
    with the child document when querying the database.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MongoDB不支持连接，但它支持使用名为**DBRef**的约定从一个文档到另一个文档的引用。DBRef使得可以使用一个特殊字段来引用另一个文档，该字段包含集合名称和文档的`ObjectId`字段。Mongoose实现了类似的行为，支持使用`ObjectID`模式类型和`ref`属性来支持文档引用。它还支持在查询数据库时将父文档与子文档进行关联。
- en: 'To understand this better, let''s say you create another schema for blog posts
    called `PostSchema`. Because a user authors a blog post, `PostSchema` will contain
    an `author` field that will be populated by a `User` model instance. So, a `PostSchema`
    will look like what is shown in the following code snippet:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，假设您为博客文章创建了另一个模式，称为`PostSchema`。因为用户是博客文章的作者，`PostSchema`将包含一个`author`字段，该字段将由`User`模型实例填充。因此，`PostSchema`将如下所示：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note the `ref` property telling Mongoose that the `author` field will use the
    `User` model to populate the value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`ref`属性告诉Mongoose`author`字段将使用`User`模型来填充值。
- en: 'Using this new schema is a simple task. To create a new blog post, you will
    need to retrieve or create an instance of the `User` model, create an instance
    of the `Post` model, and then assign the `post author` property with the `user`
    instance. An example of this is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新模式是一个简单的任务。要创建一个新的博客文章，您需要检索或创建一个`User`模型的实例，创建一个`Post`模型的实例，然后将`post author`属性分配给`user`实例。示例如下：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Mongoose will create a reference in the MongoDB `post` document and will later
    use it to retrieve the referenced user document.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose将在MongoDB“post”文档中创建一个引用，并稍后使用它来检索引用的用户文档。
- en: 'Since it is only an `ObjectID` reference to a real document, Mongoose will
    have to populate the `post` instance with the `user` instance. To do this, you''ll
    have to tell Mongoose to use the `populate()` method when retrieving the document.
    For instance, a `find()` method that populates the `author` property will look
    like what is shown in the following code snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它只是对真实文档的“ObjectID”引用，Mongoose将不得不使用“populate（）”方法来填充“post”实例中的“user”实例。为此，您将需要告诉Mongoose在检索文档时使用“populate（）”方法。例如，一个填充“author”属性的“find（）”方法将如下面的代码片段所示：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Mongoose will then retrieve all the documents in the `posts` collection and
    populate their `author` attribute.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Mongoose将检索“posts”集合中的所有文档，并填充它们的“author”属性。
- en: Mongoose's support for this feature enables you to calmly rely on object references
    to keep your data models organized. Later in this book, you'll learn how to reference
    in order to support your application logic.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose对此功能的支持使您能够放心地依赖对象引用来保持数据模型的组织。在本书的后面，您将学习如何引用以支持您的应用程序逻辑。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To find out more about reference fields and population, it is recommended that
    you visit [http://mongoosejs.com/docs/populate.html](http://mongoosejs.com/docs/populate.html).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于引用字段和填充的信息，建议您访问[http://mongoosejs.com/docs/populate.html](http://mongoosejs.com/docs/populate.html)。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you were introduced to the robust Mongoose model. You connected
    to your MongoDB instance and created your first Mongoose schema and model. You
    also learned how to validate your data and modify it using schema modifiers and
    Mongoose middleware. You discovered virtual attributes and modifiers, and you
    learned how to use them in order to change the representation of your documents.
    You also discovered how to use Mongoose to implement a reference between documents.
    In the next chapter, we'll go through the **Passport** authentication module,
    which will use your `User` model to address user authentication.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了强大的Mongoose模型。您连接到了您的MongoDB实例，并创建了您的第一个Mongoose模式和模型。您还学会了如何验证您的数据，并使用模式修改器和Mongoose中间件进行修改。您发现了虚拟属性和修改器，并学会了如何使用它们来改变文档的表示。您还发现了如何使用Mongoose来实现文档之间的引用。在下一章中，我们将介绍Passport身份验证模块，它将使用您的“User”模型来处理用户身份验证。
