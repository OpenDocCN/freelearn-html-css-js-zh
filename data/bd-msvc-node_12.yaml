- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Ensuring Data Security with the Saga Pattern, Encryption, and Security Measures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Saga 模式、加密和安全措施确保数据安全
- en: When working with microservices architecture and Node.js, you need to have a
    better understanding of data security with the Saga pattern and learn about encryption
    and security measures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用微服务架构和 Node.js 时，你需要更好地理解使用 Saga 模式确保数据安全，并了解加密和安全措施。
- en: We’ll start this chapter by understanding better how to ensure data security
    with the Saga pattern, encryption, and security measures in microservices with
    Node.js. The Saga pattern, data encryption, and security are essential aspects
    to consider when designing and implementing microservices. The Saga pattern is
    a technique used to manage distributed transactions across multiple microservices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过理解如何使用 Node.js 中的 Saga 模式、加密和安全措施来确保微服务中的数据安全来开始本章。在设计和实现微服务时，Saga 模式、数据加密和安全都是需要考虑的重要方面。Saga
    模式是一种用于管理跨多个微服务的分布式事务的技术。
- en: By the end of this chapter, you will have learned how to ensure data security
    with the Saga pattern, encryption, and security measures in Node.js.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何使用 Saga 模式、加密和 Node.js 中的安全措施来确保数据安全。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将涵盖以下主要内容：
- en: Compensating actions and Saga orchestration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补偿操作和 Saga 协调
- en: Event-driven communication and Sagas and state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动通信和 Sagas 及状态
- en: Transport layer security (TLS) and data encryption at rest
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层安全（TLS）和静态数据加密
- en: Encryption algorithms and key management
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密算法和密钥管理
- en: Authentication, authorization, input validation, secure coding practices, and
    API rate limiting
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证、授权、输入验证、安全编码实践和 API 速率限制
- en: In the following section, we’re going to learn how to work with compensating
    actions and Saga orchestration. Compensating actions and Saga orchestration are
    both concepts used in microservices architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何处理补偿操作和 Saga 协调。补偿操作和 Saga 协调都是微服务架构中使用的概念。
- en: Compensating actions and Saga orchestration
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补偿操作和 Saga 协调
- en: Microservices often need to have transactional behavior across multiple services.
    Compensating actions and Saga orchestration are two concepts related to the Saga
    pattern, which is a way to manage data consistency across microservices in distributed
    transaction scenarios.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常需要在多个服务之间具有事务行为。补偿操作和 Saga 协调是与 Saga 模式相关的两个概念，后者是一种在分布式事务场景中管理微服务间数据一致性的方法。
- en: Compensating actions
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补偿操作
- en: '**Compensating actions** are used to undo the effects of a failed operation
    in a microservices architecture. They are often needed when an operation consists
    of multiple steps that are eventually consistent, meaning that the system might
    be in an inconsistent state until all steps are completed. If one or more of the
    steps fail, the system should revert to a consistent state by applying compensating
    actions that revert changes made by the previous steps. For example, if an operation
    involves reserving a hotel room, booking a flight, and charging a credit card,
    and the flight booking fails, the compensating actions would be to cancel the
    hotel reservation and refund the credit card. Compensating actions are usually
    implemented as separate transactions triggered by an error or a timeout. They
    can also be idempotent, meaning that they can be executed multiple times without
    changing the outcome.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**补偿操作**用于在微服务架构中撤销失败操作的影响。当操作由多个最终一致性的步骤组成时，通常需要补偿操作，这意味着系统可能处于不一致状态，直到所有步骤都完成。如果其中一个或多个步骤失败，系统应通过应用补偿操作来撤销之前步骤所做的更改，以恢复到一致状态。例如，如果操作涉及预订酒店房间、预订航班和扣款信用卡，而航班预订失败，补偿操作将是取消酒店预订并退还信用卡。补偿操作通常作为由错误或超时触发的单独事务实现。它们也可以是幂等的，这意味着它们可以多次执行而不改变结果。'
- en: Unlike in a monolithic system where traditional database transactions can be
    used, this is not possible in a distributed system where each microservice can
    have its own database.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与在单体系统中可以使用传统数据库事务不同，在分布式系统中，每个微服务可以有自己的数据库，这是不可能的。
- en: Let’s take a look at one of the most common use cases of compensating actions.
    In microservices, compensating actions are crucial when a complex transaction
    involves multiple steps across different services, and a failure occurs at any
    point. Instead of rolling back the entire transaction, compensating actions are
    triggered to revert changes made during the transaction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看补偿操作最常见的一个用例。在微服务中，当复杂事务涉及跨不同服务的多个步骤，并且在任何一点发生故障时，补偿操作至关重要。而不是回滚整个事务，补偿操作被触发以撤销事务期间所做的更改。
- en: For example, consider an e-commerce system where a user places an order and
    several microservices are involved (order creation, inventory deduction, payment
    processing). If payment fails, compensating actions might involve canceling the
    order, adding inventory back, and refunding the user.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个电子商务系统，其中用户下单，涉及多个微服务（订单创建、库存扣除、支付处理）。如果支付失败，补偿操作可能包括取消订单、恢复库存和向用户退款。
- en: 'The following are some key considerations for compensating actions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对补偿操作的一些关键考虑因素：
- en: '**Idempotency**: Compensating actions must be designed to be idempotent, ensuring
    that executing them multiple times has the same effect as executing them once.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幂等性**：补偿操作必须设计成幂等的，确保多次执行与单次执行具有相同的效果。'
- en: '**Atomicity**: Each compensating action should be atomic and independent of
    others to ensure proper handling.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：每个补偿操作应该是原子的，并且与其他操作独立，以确保正确处理。'
- en: '**Failure scenarios** for compensating actions in microservices are situations
    where the compensating actions themselves fail or are not executed properly. This
    can lead to data inconsistency, resource leakage, or business logic errors. Some
    examples of failure scenarios are the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**补偿操作失败场景**是指在微服务中，补偿操作本身失败或未能正确执行的情况。这可能导致数据不一致、资源泄漏或业务逻辑错误。以下是一些失败场景的例子：'
- en: '**Network failures**: If the network connection between the services is unreliable
    or slow, compensating actions might not be able to reach the target services or
    might be delayed. This can result in partial or duplicate execution of the compensating
    actions, causing data corruption or inconsistency.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络故障**：如果服务之间的网络连接不可靠或缓慢，补偿操作可能无法到达目标服务或可能延迟。这可能导致补偿操作的局部或重复执行，导致数据损坏或不一致。'
- en: '**Service failures**: If the target service is unavailable or crashes during
    the execution of the compensating action, the compensating action might not be
    completed or might be rolled back. This can leave the system in an inconsistent
    state or cause resource leakage.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务故障**：如果在执行补偿操作期间目标服务不可用或崩溃，补偿操作可能无法完成或可能被回滚。这可能导致系统处于不一致状态或造成资源泄漏。'
- en: '**Business logic failures**: If the compensating action violates some business
    rules or constraints, the compensating action might fail or cause unwanted side
    effects. For example, if the compensating action tries to cancel a hotel reservation
    that has already been checked in, the compensating action might fail or incur
    a penalty fee.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务逻辑失败**：如果补偿操作违反某些业务规则或约束，补偿操作可能会失败或产生不希望的结果。例如，如果补偿操作试图取消已经入住的酒店预订，补偿操作可能会失败或产生罚款。'
- en: '**Data conflicts**: If the data that the compensating action tries to modify
    has been changed by another concurrent operation, the compensating action might
    fail or overwrite the new data. This can cause data loss or inconsistency.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据冲突**：如果补偿操作试图修改的数据已被其他并发操作更改，补偿操作可能会失败或覆盖新数据。这可能导致数据丢失或不一致。'
- en: 'To handle these failure scenarios, some possible solutions include the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些失败场景，以下是一些可能的解决方案：
- en: '**Retry mechanism**: The compensating action can be retried a certain number
    of times or until a timeout is reached, in case of transient failures or network
    delays. The retry mechanism should also handle idempotency and concurrency issues,
    such as using unique identifiers or version numbers to avoid duplicate or conflicting
    updates.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试机制**：在出现暂时性故障或网络延迟的情况下，补偿操作可以重试一定次数或直到达到超时。重试机制还应处理幂等性和并发问题，例如使用唯一标识符或版本号来避免重复或冲突的更新。'
- en: '**Fallback mechanism**: The compensating action can have a fallback option
    that provides an alternative way to undo the original operation, in case of permanent
    failures or service unavailability. The fallback mechanism should also ensure
    data consistency and business logic correctness, such as using a manual process
    or a third-party service to perform the compensating action.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退机制**：补偿行为可以有一个回退选项，提供撤销原始操作的一种替代方式，以防永久性故障或服务不可用。回退机制还应确保数据一致性和业务逻辑正确性，例如使用人工流程或第三方服务来执行补偿行为。'
- en: '**Compensation chain**: The compensating action can trigger another compensating
    action in case of failure, forming a chain of compensations that eventually restores
    the system to a consistent state. The compensation chain should also avoid circular
    dependencies and infinite loops, such as using a termination condition or a maximum
    depth limit to stop the chain.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补偿链**：在失败的情况下，补偿行为可以触发另一个补偿行为，形成一个补偿链，最终将系统恢复到一致状态。补偿链还应避免循环依赖和无限循环，例如使用终止条件或最大深度限制来停止链。'
- en: Compensating transactions come to the rescue in such situations. They are a
    way to undo the previous operations in case of a failure. For example, if you’re
    creating an order and you’ve deducted an item from inventory, but the payment
    service fails due to some reason, you would want to compensate for the deducted
    item and add it back to the inventory. This undo operation is the compensating
    action.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，补偿事务会提供帮助。它们是在失败时撤销先前操作的一种方式。例如，如果你正在创建一个订单并从库存中扣除了一个项目，但由于某些原因支付服务失败，你将想要补偿扣除的项目并将其重新添加到库存中。这种撤销操作就是补偿行为。
- en: We have learned the basics of compensating actions, so now, let’s move on to
    Saga orchestration.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了补偿行为的基础知识，现在，让我们继续学习Saga编排。
- en: Saga orchestration
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Saga编排
- en: '**Saga** is a design pattern to manage transactions across multiple microservices.
    **Saga orchestration** is a specific way to implement the Saga pattern. In this
    approach, a central service (the “orchestrator”) manages the sequence of steps
    for the transaction and tells each service what to do and when. It also handles
    failures and triggers compensating actions when necessary. The advantage is that
    this simplifies error handling as Saga orchestration is centralized and provides
    consistency across transactions. However, it also creates a dependency on the
    orchestrator service, which can become a bottleneck.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Saga**是一种管理跨多个微服务的交易的设计模式。**Saga编排**是实施Saga模式的一种特定方式。在这种方法中，一个中心服务（“协调器”）管理交易的步骤顺序，并告诉每个服务何时执行其部分。它还处理失败情况，并在必要时触发补偿行为。这种方法的优点是简化了错误处理，因为Saga编排是集中的，并且在整个交易中提供一致性。然而，这也导致了对协调器服务的依赖，这可能会成为瓶颈。'
- en: The most common use case of Saga orchestration is in scenarios where a business
    process spans multiple microservices, whereby a Saga ensures that each step in
    the process is either fully completed or compensated for in case of failure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Saga编排最常见的使用场景是在业务流程跨越多个微服务的情况下，此时一个Saga确保流程中的每一步要么完全完成，要么在失败时得到补偿。
- en: 'For example, in the context of an e-commerce system, a Saga might involve multiple
    steps: creating an order, deducting inventory, processing payment, and shipping.
    If any step fails, compensating actions are triggered to revert changes made during
    the preceding steps.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在电子商务系统的背景下，一个Saga可能涉及多个步骤：创建订单、扣除库存、处理支付和发货。如果任何步骤失败，将触发补偿行为以撤销之前步骤所做的更改。
- en: 'The two types of Saga patterns are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Saga模式有两种类型：
- en: '**Choreography**: In choreography-based Sagas, each microservice involved knows
    how to initiate its part of the Saga and communicate with others to achieve the
    overall business process.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编排**：在基于编排的Sagas中，每个参与的微服务都知道如何启动其Sagas的部分并与他人通信以实现整体业务流程。'
- en: '**Orchestration**: In orchestration-based Sagas, there is a central component
    (orchestrator) that coordinates the sequence of steps in the Saga, instructing
    microservices when to execute their parts.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编排**：在基于编排的Sagas中，有一个中心组件（协调器）负责协调Sagas中步骤的顺序，指导微服务何时执行其部分。'
- en: Both approaches have their advantages and disadvantages, depending on the complexity,
    reliability, and scalability of the system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都有其优点和缺点，这取决于系统的复杂性、可靠性和可伸缩性。
- en: 'The following are some key considerations for Saga orchestration:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于Saga编排的关键考虑因素：
- en: '**Sagas versus transactions**: Sagas are different from traditional **ACID**
    (**Atomicity**, **Consistency**, **Isolation**, **Durability**) transactions as
    they focus on distributed and long-running processes rather than short-lived,
    isolated transactions.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sagas与事务的比较**：Sagas与传统**ACID**（**原子性**、**一致性**、**隔离性**、**持久性**）事务不同，因为它们侧重于分布式和长时间运行的过程，而不是短暂、隔离的事务。'
- en: '**Compensating transactions**: The ability to compensate for failures is a
    critical aspect of Sagas, ensuring that the system remains consistent even if
    individual steps fail.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补偿事务**：补偿失败的能力是Sagas的关键方面，确保即使在单个步骤失败的情况下，系统也能保持一致性。'
- en: Saga orchestration is a technique to manage data consistency across microservices
    in distributed transaction scenarios. It uses a central coordinator to execute
    and compensate transactions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Saga编排是一种在分布式事务场景中管理跨微服务数据一致性的技术。它使用中央协调器来执行和补偿事务。
- en: 'A Saga may face the following challenges:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Saga可能会遇到以下挑战：
- en: '**Consistency**: Ensuring that the system remains consistent even in the presence
    of failures. To solve this, the Saga can use techniques such as versioning, locking,
    or timestamps to prevent or resolve data conflicts.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：确保即使在出现故障的情况下，系统也能保持一致性。为了解决这个问题，Saga可以使用版本控制、锁定或时间戳等技术来防止或解决数据冲突。'
- en: '**Durability**: Handling scenarios where the system fails at different points
    in the Saga and ensuring that the state is recoverable. To solve this, the Saga
    can use techniques such as retries, timeouts, circuit breakers, or compensating
    transactions to recover from failures and restore data consistency ([https://research.aimultiple.com/facial-recognition-challenges/](https://research.aimultiple.com/facial-recognition-challenges/)).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：处理在叙事的不同点系统失败的场景，并确保状态可恢复。为了解决这个问题，Saga可以使用重试、超时、断路器或补偿事务等技术从失败中恢复并恢复数据一致性（[https://research.aimultiple.com/facial-recognition-challenges/](https://research.aimultiple.com/facial-recognition-challenges/)）。'
- en: '**Complexity**: Implementing and managing Sagas introduces complexity, and
    proper tooling and patterns are needed. To solve this, the Saga can use tools
    and frameworks that support the Saga pattern, such as Axon, Eventuate, or Camunda.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：实现和管理Sagas引入了复杂性，需要适当的工具和模式。为了解决这个问题，Saga可以使用支持Sagas模式的工具和框架，如Axon、Eventuate或Camunda。'
- en: In general, both concepts serve to ensure data consistency and handle failures
    in a distributed system environment. It’s also important to note that choosing
    an approach depends on the specific needs of your application and team capacity.
    Both have their advantages and trade-offs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这两个概念都用于确保数据一致性并处理分布式系统环境中的故障。还应注意，选择方法取决于您应用程序的具体需求和团队能力。两者都有其优点和权衡。
- en: Here is some sample Saga orchestration code for e-commerce in Node.js (divided
    into code blocks).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些Node.js中电子商务的示例Saga编排代码（分为代码块）。
- en: 'Let us go step by step, starting with the initiation of a service with default
    dependencies and constants:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来，从使用默认依赖和常量的服务初始化开始：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we’ll create API endpoints with their functionalities:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建具有其功能的API端点：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the following code block, we can handle messages from the order service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码块，我们可以处理来自订单服务的消息：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we’ll start the server on the selected port:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在所选端口上启动服务器：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of this code depends on the input and the events that occur in the
    order processing saga. The code is an example of an orchestrator service in Node.js
    that uses Kafka as a message broker to coordinate order, payment, and stock services.
    The code defines the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出取决于输入以及在顺序处理叙事中的事件顺序。该代码是一个使用Kafka作为消息代理以协调订单、支付和库存服务的Node.js编排服务示例。代码定义了以下步骤：
- en: When a new order is created, the orchestrator service assigns a random order
    ID, sets the order status to `pending`, saves it in a mock database, and sends
    a message to the order service to start the Saga.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建新订单时，编排服务分配一个随机订单ID，将订单状态设置为`pending`，将其保存在模拟数据库中，并向订单服务发送消息以启动Saga。
- en: 'When the orchestrator service receives a message from the order service, it
    checks the event type and the order ID and finds the corresponding order in the
    database. If the order exists and is not already cancelled, it performs the following
    actions based on the event type:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编排服务从订单服务接收到消息时，它会检查事件类型和订单ID，并在数据库中找到相应的订单。如果订单存在且尚未取消，它将根据事件类型执行以下操作：
- en: If the order service has approved the order, the orchestrator service sets the
    order status to `approved` and sends a message to the payment service to request
    the payment.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果订单服务已批准订单，编排服务将订单状态设置为`approved`并向支付服务发送消息请求支付。
- en: If the order service has rejected the order, the orchestrator service sets the
    order status to `rejected` and does nothing else.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果订单服务已拒绝订单，编排服务将订单状态设置为`rejected`并不再执行其他操作。
- en: If the payment service has charged the payment, the orchestrator service sends
    a message to the stock service to reserve the items.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果支付服务已收取支付，编排服务向库存服务发送消息以预留商品。
- en: If the payment service has failed to charge the payment, the orchestrator service
    sends a message to the order service to reject the order.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果支付服务未能收取支付，编排服务向订单服务发送消息以拒绝订单。
- en: If the stock service has reserved the items, the orchestrator service logs that
    the saga is completed successfully and does nothing else.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果库存服务已预留商品，编排服务记录Sagas成功完成并不再执行其他操作。
- en: If the stock service has failed to reserve the items, the orchestrator service
    sends a message to the payment service to refund the payment and a message to
    the order service to reject the order.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果库存服务未能预留商品，编排服务向支付服务发送消息以退款并向订单服务发送消息以拒绝订单。
- en: If the event type is unknown, the orchestrator service logs an error and does
    nothing else.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果事件类型未知，编排服务记录错误并不再执行其他操作。
- en: If the order is not found or already cancelled, the orchestrator service logs
    an error and does nothing else.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找不到订单或订单已被取消，编排服务记录错误并不再执行其他操作。
- en: The code also defines a route to create a new order and a listener to start
    the server. This code’s output would be the console logs and the JSON responses
    sent or received by the orchestrator service.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还定义了一个创建新订单的路由和一个启动服务器的监听器。此代码的输出将是控制台日志和编排服务发送或接收的JSON响应。
- en: '*Figure 12**.1* illustrates Saga orchestration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.1*展示了Sagas编排：'
- en: '![Figure 12.1: Saga orchestration (image by Freepik)](img/B14980_12_01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：Sagas编排（图片由Freepik提供）](img/B14980_12_01.jpg)'
- en: 'Figure 12.1: Saga orchestration (image by Freepik)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：Sagas编排（图片由Freepik提供）
- en: In summary, compensating actions and Saga orchestration are essential patterns
    in microservices architecture, enabling the design of robust and resilient distributed
    systems. They provide mechanisms to handle failures and maintain data consistency
    in scenarios where traditional ACID transactions are not applicable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，补偿操作和Sagas编排是微服务架构中的关键模式，使得设计健壮和有弹性的分布式系统成为可能。它们提供了在传统ACID事务不适用的情况下处理故障和维护数据一致性的机制。
- en: With an understanding of these concepts, let’s now move to event-driven communication
    and Sagas and state.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了这些概念后，我们现在转向事件驱动通信和Sagas以及状态。
- en: Event-driven communication and Sagas with state
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动通信和具有状态的Sagas
- en: Event-driven communication and Sagas and state refer to software and system
    development concepts, particularly within the realm of microservices architecture.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动通信和Sagas以及状态指的是软件和系统开发概念，尤其是在微服务架构领域。
- en: Event-driven communication
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动通信
- en: '**Event-driven communication** is a communication paradigm between software
    components where one component changes its state and emits an event to notify
    other components. The advantage of this communication model is that it helps reduce
    system connectivity and enhances reactivity, scalability, and flexibility.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动通信**是一种软件组件之间的通信范式，其中一个组件改变其状态并向其他组件发出事件以通知它们。这种通信模型的优势在于它有助于减少系统连接性并增强反应性、可扩展性和灵活性。'
- en: A use case of event-driven communication is that in a distributed system of
    microservices, event-driven communication is valuable for loosely coupling services
    and enabling asynchronous, real-time interactions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动通信的一个用例是在微服务分布式系统中，事件驱动通信对于松耦合服务和实现异步、实时交互非常有价值。
- en: For instance, in an e-commerce system, when a user places an order, the `OrderPlaced`
    event. The **inventory service and payment service**, which are interested parties,
    can subscribe to this event and take appropriate actions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个电子商务系统中，当用户下单时，会触发 `OrderPlaced` 事件。**库存服务**和**支付服务**等感兴趣的相关方可以订阅此事件并采取适当的行动。
- en: 'The following are key characteristics of event-driven communication:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下事件驱动通信的关键特性：
- en: '**Publishers and subscribers**: Microservices act as publishers when generating
    events and as subscribers when reacting to events of interest.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者和订阅者**：当生成事件时，微服务充当发布者；当对感兴趣的事件做出反应时，充当订阅者。'
- en: '**Decoupling**: Event-driven communication promotes loose coupling between
    microservices, allowing them to evolve independently.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦**：事件驱动通信促进了微服务之间的松散耦合，使它们能够独立演进。'
- en: Event-driven communication is a way of exchanging data between microservices
    or clients based on events, which are discrete messages that represent changes
    in the state of the system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动通信是一种基于事件的数据交换方式，这些事件是代表系统状态变化的离散消息。
- en: 'Challenges with event-driven communication are illustrated here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了事件驱动通信的挑战：
- en: '**Eventual consistency**: As events are processed asynchronously, ensuring
    eventual consistency across microservices can be challenging. To solve this, event-driven
    communication can use techniques such as versioning, locking, or timestamps to
    prevent or resolve data conflicts.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：由于事件异步处理，确保微服务之间的最终一致性可能具有挑战性。为了解决这个问题，事件驱动通信可以使用版本控制、锁定或时间戳等技术来防止或解决数据冲突。'
- en: '**Message ordering**: Maintaining the correct order of events is crucial in
    certain scenarios.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息顺序**：在特定场景中，保持事件的正确顺序至关重要。'
- en: 'Here is a simple example of event-driven communication in Node.js, using the
    built-in `http` module and the `EventEmitter` class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 Node.js 内置的 `http` 模块和 `EventEmitter` 类的事件驱动通信的简单示例：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Event-driven communication is a paradigm where microservices communicate with
    each other through the generation and consumption of events. Events represent
    state changes or occurrences within a microservices ecosystem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动通信是一种范式，其中微服务通过生成和消费事件相互通信。事件代表微服务生态系统中的状态变化或事件。
- en: With these concepts learned, we can continue with Sagas and state.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了这些概念后，我们可以继续学习 Saga 和状态。
- en: Sagas with state
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有状态的 Saga
- en: In the context of microservices, a **Saga** **with state** refers to a long-running
    business process (Saga) that involves a sequence of steps, each with its associated
    state. The state of the Saga determines the next steps to be taken.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务的上下文中，**有状态**的 **Saga** 指的是一个涉及一系列步骤的长期运行的业务流程（Saga），每个步骤都有其关联的状态。Saga 的状态决定了下一步要采取的行动。
- en: A common use case of Sagas and state is in complex business processes that span
    multiple microservices and involve multiple steps with an associated state.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Saga 和状态的一个常见用例是在涉及多个微服务和多个步骤及其关联状态的复杂业务流程中。
- en: An example of Sagas and state is as follows. Consider the process of booking
    a flight. The Saga may involve steps such as seat selection, payment, and confirmation.
    The state of the Saga (e.g., `SeatSelected`, `PaymentProcessed`) determines the
    next steps in the process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 Saga 和状态的示例。考虑预订航班的流程。Saga 可能涉及选择座位、支付和确认等步骤。Saga 的状态（例如，`SeatSelected`、`PaymentProcessed`）决定了流程中的下一步。
- en: 'Some of its key characteristics are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一些关键特性如下：
- en: '**Stateful steps**: Each step in the Saga maintains its state, and the overall
    Saga progresses based on the combination of these states.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有状态步骤**：在 Saga 中，每个步骤都维护其状态，整个 Saga 的进展基于这些状态的组合。'
- en: '**Compensating actions**: If there is a failure, compensating actions are executed
    to revert the effects of the preceding steps.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补偿操作**：如果发生故障，将执行补偿操作以撤销先前步骤的影响。'
- en: '**Coordination**: There is a need for coordination to ensure that steps are
    executed in the correct sequence.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协调**：需要协调以确保步骤按正确的顺序执行。'
- en: Saga and state are two important concepts in microservices architecture.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Saga 和状态是微服务架构中的两个重要概念。
- en: 'The following are challenges for Sagas and state:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 Saga 和状态的挑战：
- en: '**State management**: Managing and persisting the state of Sagas becomes crucial
    for reliability.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态管理**：管理和持久化 Saga 的状态对于可靠性至关重要。'
- en: '**Compensation logic**: Designing and implementing compensating actions for
    each step requires careful consideration.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补偿逻辑**：为每个步骤设计和实施补偿措施需要仔细考虑。'
- en: In summary, in microservices architecture, Sagas are used to manage transactions
    that span multiple services. Each Saga represents a high-level business transaction,
    which involves steps that need to be performed in multiple services. It manages
    and oversees these processes, ensuring they either all succeed or undergo a compensating
    transaction in case of failure, maintaining data consistency across services.
    State usually refers to the information maintained by software components during
    their life cycle. This can involve user info, system configurations, or other
    operation-critical data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在微服务架构中，Sagas用于管理跨越多个服务的交易。每个Sagas代表一个高级业务交易，涉及需要在多个服务中执行的多步操作。它管理和监督这些过程，确保它们要么全部成功，要么在失败时进行补偿交易，以保持服务之间的数据一致性。状态通常指软件组件在其生命周期中维护的信息。这可能涉及用户信息、系统配置或其他操作关键数据。
- en: Now, we can continue to the next section, in which we will talk about TLS and
    data encryption at rest.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续到下一节，我们将讨论TLS和静态数据加密。
- en: Transport layer security (TLS) and data encryption at rest
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层安全（TLS）和静态数据加密
- en: '**Transport layer security** (**TLS**) is a protocol that provides privacy
    and data integrity between two communicating applications. Data encryption at
    rest is the process of encoding and securing data stored in databases, filesystems,
    or disk storage. In contrast, data in motion is generally protected by networking
    protocols, such as TLS.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输层安全**（**TLS**）是一种协议，为两个通信应用程序之间提供隐私和数据完整性。静态数据加密是将存储在数据库、文件系统或磁盘存储中的数据进行编码和加密的过程。相比之下，运动中的数据通常由网络协议（如TLS）保护。'
- en: TLS
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TLS
- en: '**TLS** is a cryptographic protocol that ensures secure communication over
    a computer network. It is widely used to secure data transmission between a client
    and a server, protecting it from eavesdropping, tampering, and forgery.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**TLS**是一种加密协议，确保计算机网络上的安全通信。它被广泛用于保护客户端和服务器之间的数据传输，防止窃听、篡改和伪造。'
- en: One important use case of TLS is in microservices, where TLS is crucial for
    securing communication between services over the network. It establishes a secure
    channel by encrypting data during transmission.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: TLS的一个重要用例是在微服务中，其中TLS对于在网络中保护服务之间的通信至关重要。它通过在传输过程中加密数据来建立安全通道。
- en: To implement TLS, each microservice can be configured to support **HTTPS**,
    the secure version of HTTP. TLS certificates are used to encrypt the communication
    channel, and **mutual TLS** (**mTLS**) can be implemented for service-to-service
    authentication.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现TLS，每个微服务都可以配置为支持**HTTPS**，这是HTTP的安全版本。TLS证书用于加密通信通道，并且可以实现**双向TLS**（**mTLS**）以进行服务到服务的认证。
- en: 'The following are key considerations for TLS:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对TLS的关键考虑因素：
- en: '**Encryption**: TLS ensures that data transmitted between microservices is
    encrypted, preventing unauthorized access.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：TLS确保微服务之间传输的数据被加密，防止未经授权的访问。'
- en: '**Authentication**: mTLS adds an extra layer of security by requiring both
    parties to authenticate each other, enhancing the overall security posture.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：mTLS通过要求双方相互认证，增加了额外的安全层，增强了整体的安全态势。'
- en: '**Certificates and public key infrastructure (PKI)**: Certificates and PK)
    are related concepts that enable secure and authenticated communication over the
    internet. A certificate is a digital document that contains information about
    the identity of a user, device, or service, as well as a public key that can be
    used for encryption and digital signatures. A PKI is a system that manages the
    creation, distribution, verification, and revocation of certificates, using trusted
    entities called **certificate authorities** (**CAs**). A PKI ensures that the
    certificates are valid and trustworthy and that the public keys are linked to
    the correct owners.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书和公钥基础设施（PKI）**：证书和PKI是相关概念，它们使互联网上的安全认证通信成为可能。证书是一个包含有关用户、设备或服务身份信息以及可用于加密和数字签名的公钥的数字文档。PKI是一个系统，它使用称为**证书颁发机构**（**CAs**）的受信任实体来管理证书的创建、分发、验证和撤销。PKI确保证书有效且可信，并且公钥与正确的所有者相关联。'
- en: '**TLS handshake**: A TLS handshake is a process that establishes a secure and
    encrypted connection between a client and a server over the internet.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLS握手**：TLS握手是一个过程，它通过互联网在客户端和服务器之间建立安全且加密的连接。'
- en: TLS is a protocol that provides secure and reliable communication over the internet.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: TLS是一种提供互联网上安全可靠通信的协议。
- en: 'Some challenges to TLS are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: TLS面临的一些挑战如下：
- en: '**Certificate management**: Proper management of TLS certificates, including
    issuance, renewal, and revocation, is crucial. Some solutions are to use a centralized
    and automated certificate management solution that can discover, inventory, monitor,
    renew, and revoke certificates across your network.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书管理**：正确管理TLS证书，包括颁发、续订和吊销，至关重要。一些解决方案是使用集中化和自动化的证书管理解决方案，该解决方案可以跨网络发现、盘点、监控、续订和吊销证书。'
- en: '**Performance overhead**: While the overhead is minimal, the encryption and
    decryption process in TLS introduces some computational load. One solution is
    to use the latest version of TLS (TLS 1.3), which offers faster and more secure
    connections than previous versions.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能开销**：虽然开销很小，但TLS中的加密和解密过程引入了一些计算负载。一种解决方案是使用最新的TLS版本（TLS 1.3），它比之前的版本提供更快、更安全的连接。'
- en: '**Algorithm agility**: Algorithm agility is the ability to change or replace
    cryptographic algorithms without affecting the functionality or security of a
    system. It is an important aspect of crypto-agility, which is the broader concept
    of adapting to changes in the cryptographic landscape. Algorithm agility can help
    mitigate the challenges of TLS, which is a protocol that provides secure and authenticated
    communication over the internet.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法灵活性**：算法灵活性是指在不影响系统功能或安全性的情况下更改或替换加密算法的能力。它是更广泛的概念——适应加密领域变化的加密敏捷性的一个重要方面。算法灵活性可以帮助缓解TLS的挑战，TLS是一种提供互联网上安全认证通信的协议。'
- en: '**Security of private keys**: The security of private keys on TLS is a topic
    that concerns how to protect cryptographic keys that are used to establish and
    secure TLS connections. Private keys are secret keys that are used to decrypt
    data that is encrypted with the corresponding public keys. If the private keys
    are compromised, an attacker can intercept, modify, or impersonate the TLS traffic,
    leading to data breaches, identity theft, or **man-in-the-middle** (**MitM**)
    attacks.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私钥安全**：TLS上私钥的安全性是一个关于如何保护用于建立和确保TLS连接的加密密钥的问题。私钥是用于使用相应公钥解密数据的秘密密钥。如果私钥被泄露，攻击者可以拦截、修改或冒充TLS流量，导致数据泄露、身份盗窃或**中间人攻击**（MitM）。'
- en: '*Figure 12**.2* illustrates TLS:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.2*展示了TLS：'
- en: '![Figure 12.2: TLS (image by Freepik)](img/B14980_12_02.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：TLS（图片由Freepik提供）](img/B14980_12_02.jpg)'
- en: 'Figure 12.2: TLS (image by Freepik)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：TLS（图片由Freepik提供）
- en: TLS is used to create a secure environment for web browsing, e-commerce, and
    other types of internet traffic. It does this by encrypting the data being sent
    between the client and server, thus preventing potential eavesdroppers from gaining
    access to sensitive information.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: TLS用于创建安全的网络浏览、电子商务和其他类型互联网流量的环境。它是通过加密客户端和服务器之间发送的数据来实现的，从而防止潜在的窃听者获取敏感信息。
- en: We can continue now with data encryption at rest.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续讨论静态数据加密。
- en: Data encryption at rest
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态数据加密
- en: Data encryption at rest involves securing data when it is stored in databases,
    filesystems, or any other persistent storage. It prevents unauthorized access
    to data even if physical storage media are compromised.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数据加密涉及在数据库、文件系统或任何其他持久存储中存储数据时的数据安全。即使物理存储介质被破坏，它也能防止未经授权的数据访问。
- en: In microservices, data encryption at rest is vital for protecting sensitive
    information stored in databases or other persistent storage solutions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，静态数据加密对于保护存储在数据库或其他持久存储解决方案中的敏感信息至关重要。
- en: To implement data encryption at rest, use encryption algorithms to encrypt data
    before it is stored. This can be done at the application level or by utilizing
    features provided by the database or storage system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现静态数据加密，使用加密算法在数据存储之前对其进行加密。这可以在应用层完成，或者通过利用数据库或存储系统提供的功能来实现。
- en: 'Here are some key considerations for data encryption at rest:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态数据加密方面，以下是一些关键考虑因素：
- en: '**Key management**: Proper key management is essential to ensure that encryption
    keys are securely stored and managed.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥管理**：适当的密钥管理对于确保加密密钥安全存储和管理至关重要。'
- en: '**Granular encryption**: Depending on sensitivity, consider encrypting specific
    fields or columns rather than entire datasets for better performance.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒度加密**：根据敏感度，考虑加密特定的字段或列而不是整个数据集，以获得更好的性能。'
- en: Data encryption at rest is the process of protecting data that is stored on
    physical media, such as disks or tapes, from unauthorized access or theft.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数据加密是保护存储在物理介质上（如磁盘或磁带）的数据免受未经授权的访问或盗窃的过程。
- en: 'The following are challenges to data encryption at rest:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对静态数据加密的挑战：
- en: '**Key life-cycle management**: Managing the life cycle of encryption keys,
    including generation, rotation, and disposal, can be complex. A solution is to
    use a centralized and automated certificate management solution that can discover,
    inventory, monitor, renew, and revoke certificates across your network.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥生命周期管理**：管理加密密钥的生命周期，包括生成、轮换和销毁，可能很复杂。一种解决方案是使用集中式和自动化的证书管理解决方案，该解决方案可以跨您的网络发现、库存、监控、续订和吊销证书。'
- en: '**Performance impact**: Encrypting and decrypting data at rest can introduce
    some performance overhead, which needs to be considered. A solution is to use
    the latest version of TLS (TLS 1.3), which offers faster and more secure connections
    than previous versions.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能影响**：对静态数据进行加密和解密可能会引入一些性能开销，这需要考虑。一种解决方案是使用最新版本的TLS（TLS 1.3），它比之前的版本提供更快、更安全的连接。'
- en: With data at rest encryption, even if an unauthorized party were to gain access
    to the physical storage, the data would be unreadable without the encryption keys.
    This process is crucial in ensuring the protection of personal or sensitive information
    when stored digitally. Combining these techniques allows for comprehensive security
    both in the transmission and storage of sensitive data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态数据加密，即使未经授权的方获得了对物理存储的访问权限，没有加密密钥，数据也将无法读取。这个过程对于确保存储在数字形式时个人或敏感信息的安全至关重要。结合这些技术可以在传输和存储敏感数据时提供全面的安全保障。
- en: In summary, implementing both TLS for data in transit and encryption at rest
    provides a layered security approach, safeguarding data throughout its life cycle
    in a microservices architecture. It is essential to stay updated on security best
    practices and continuously monitor and adapt security measures based on evolving
    threats and technologies.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，实施TLS（传输中的数据）和静态加密提供了一种分层的安全方法，在整个微服务架构的生命周期中保护数据。了解安全最佳实践并基于不断发展的威胁和技术持续监控和调整安全措施是至关重要的。
- en: In the next section, we will learn about encryption algorithms and key management.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习关于加密算法和密钥管理的内容。
- en: Encryption algorithms and key management
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密算法和密钥管理
- en: Encryption algorithms and key management are crucial components of information
    security.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法和密钥管理是信息安全的关键组成部分。
- en: Encryption algorithms
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密算法
- en: '**Encryption algorithms** are methods of transforming data into a secret code
    that can only be deciphered by authorized parties.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密算法**是将数据转换为只有授权方才能解密的秘密代码的方法。'
- en: 'There are several types of encryption algorithms, including the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种加密算法，包括以下几种：
- en: '**Symmetric algorithms**: The same key is used to encrypt and decrypt data.
    Examples include **Advanced Encryption Standard** (**AES**), **Data Encryption
    Standard** (**DES**), **Triple DES** (**3DES**), Blowfish, and **Rivest Cipher
    4** (**RC4**). Here is a brief summary of each algorithm:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称算法**：使用相同的密钥进行加密和解密数据。例如包括**高级加密标准**（**AES**）、**数据加密标准**（**DES**）、**三重DES**（**3DES**）、Blowfish和**Rivest
    Cipher 4**（**RC4**）。以下是每种算法的简要概述：'
- en: '**AES** is the current standard for symmetric encryption, which means that
    the same key is used to encrypt and decrypt the data. AES can use different key
    sizes, such as 128, 192, or 256 bits, and operates on 128-bit blocks of data.
    AES is considered to be very secure and efficient and is widely used in various
    applications and protocols, such as HTTPS, VPN, and Wi-Fi.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AES**是对称加密的当前标准，这意味着使用相同的密钥进行加密和解密数据。AES可以使用不同的密钥大小，如128位、192位或256位，并操作128位的数据块。AES被认为非常安全和高效，在各种应用和协议中广泛使用，如HTTPS、VPN和Wi-Fi。'
- en: '**DES** is the predecessor of AES and was the first standard for symmetric
    encryption. DES uses a 56-bit key and operates on 64-bit blocks of data. DES is
    no longer considered secure as its key size is too small and can be cracked by
    brute-force attacks. DES was officially withdrawn as a standard in 2005.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DES** 是 AES 的前身，是第一个对称加密标准。DES 使用 56 位密钥，操作 64 位数据块。由于密钥大小太小，DES 已不再被认为是安全的，可以通过暴力攻击破解。DES
    于 2005 年正式撤消为标准。'
- en: '**3DES** is a variation of DES that applies the DES algorithm three times with
    different keys, effectively increasing the key size to 112 or 168 bits. 3DES is
    more secure than DES but still suffers from some vulnerabilities, such as its
    small block size and its slow performance. 3DES is still used in some legacy systems
    but is not recommended for new applications.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3DES** 是 DES 的一个变体，它使用不同的密钥三次应用 DES 算法，有效地将密钥大小增加到 112 或 168 位。3DES 比DES更安全，但仍然存在一些漏洞，例如其小的块大小和较慢的性能。3DES
    仍在一些遗留系统中使用，但不推荐用于新应用。'
- en: '**Blowfish** is a symmetric encryption algorithm that was designed by Bruce
    Schneier as an alternative to DES. Blowfish can use variable key sizes, up to
    448 bits, and operates on 64-bit blocks of data. Blowfish is considered to be
    secure and fast but has not been widely adopted as a standard. Blowfish is mostly
    used in some software applications, such as password managers and file encryption
    tools.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blowfish** 是 Bruce Schneier 设计的一种对称加密算法，作为 DES 的替代方案。Blowfish 可以使用可变密钥大小，高达
    448 位，并操作 64 位数据块。Blowfish 被认为是安全且快速的，但尚未被广泛采用为标准。Blowfish 主要用于一些软件应用中，例如密码管理器和文件加密工具。'
- en: '**RC4** is a symmetric encryption algorithm that was designed by Ron Rivest
    as a stream cipher, which means that it encrypts data 1 bit or byte at a time,
    rather than in blocks. RC4 can use variable key sizes, up to 256 bits, and is
    very simple and fast. However, RC4 has been found to have several weaknesses and
    vulnerabilities and is no longer considered secure. RC4 was widely used in some
    protocols, such as **Secure Sockets Layer** (**SSL**), TLS, and **Wired Equivalent
    Privacy** (**WEP**), but has been deprecated or replaced by newer algorithms.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RC4** 是 Ron Rivest 设计的一种对称加密算法，作为流密码，这意味着它一次加密 1 位或 1 字节的数据，而不是块。RC4 可以使用可变密钥大小，高达
    256 位，非常简单且快速。然而，RC4 已被发现存在几个弱点和漏洞，不再被认为是安全的。RC4 曾在许多协议中使用，如 **安全套接字层**（**SSL**）、TLS
    和 **有线等效隐私**（**WEP**），但已被弃用或被较新的算法取代。'
- en: '**Asymmetric algorithms**: Different keys are used to encrypt and decrypt data.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非对称算法**：使用不同的密钥来加密和解密数据。'
- en: 'Encryption algorithms are widely used to protect data in transit and at rest,
    such as online communications, web transactions, and cloud storage. Let’s take
    a closer look at these:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法广泛用于保护传输中和静止中的数据，例如在线通信、网络交易和云存储。让我们更详细地看看这些：
- en: '**Symmetric encryption**: Symmetric encryption uses a single key for both encryption
    and decryption. It is fast and suitable for bulk data. A use case and example
    algorithm are as follows:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称加密**：对称加密使用单个密钥进行加密和解密。它速度快，适合大量数据。以下是一个用例和示例算法：'
- en: '*Use case*: Protecting data in transit within a microservices architecture.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用例*：保护微服务架构中传输中的数据。'
- en: '*Example* *algorithm*: AES.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*示例* *算法*：AES。'
- en: '**Asymmetric encryption**: Asymmetric encryption uses a pair of public and
    private keys. Data encrypted with one key can only be decrypted by the other key
    in the pair. A use case and example algorithm are as follows:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非对称加密**：非对称加密使用一对公钥和私钥。用其中一个密钥加密的数据只能由这对密钥中的另一个密钥解密。以下是一个用例和示例算法：'
- en: '*Use case*: Securely exchanging secret keys for symmetric encryption.'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用例*：安全交换用于对称加密的秘密密钥。'
- en: '*Example algorithm*: **Rivest-Shamir-Adleman** (**RSA**).'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*示例算法*：**Rivest-Shamir-Adleman**（**RSA**）。'
- en: '**Hash functions**: Hash functions create a fixed-size output (hash) from variable-size
    input. They are used for integrity verification. A use case and example algorithm
    are as follows:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**散列函数**：散列函数将可变大小的输入（散列值）转换为固定大小的输出。它们用于完整性验证。以下是一个用例和示例算法：'
- en: '*Use case*: Verifying the integrity of data or creating digital signatures.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用例*：验证数据的完整性或创建数字签名。'
- en: '*Example algorithm*: **Secure Hash Algorithm** **256-bit** (**SHA-256**).'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*示例算法*：**安全散列算法** **256位**（**SHA-256**）。'
- en: '**Elliptic-curve cryptography (ECC)**: ECC uses the mathematics of elliptic
    curves to provide strong security with shorter key lengths compared to traditional
    asymmetric algorithms. A use case and example algorithm are as follows:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**椭圆曲线密码学 (ECC)**：ECC 使用椭圆曲线的数学来提供与传统非对称算法相比具有更短密钥长度的强大安全性。以下是一个用例和示例算法：'
- en: '*Use case*: Efficient asymmetric encryption for resource-constrained environments.'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用例*：在资源受限环境中进行高效的非对称加密。'
- en: '*Example algorithm*: **Elliptic Curve** **Diffie-Hellman** (**ECDH**).'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*示例算法*：**椭圆曲线** **Diffie-Hellman** (**ECDH**)。'
- en: '*Figure 12**.3* illustrates encryption algorithms:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12**.3* 展示了加密算法：'
- en: '![Figure 12.3: Encryption (image by macrovector on Freepik)](img/B14980_12_03.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3：加密（图片由 macrovector 在 Freepik 提供）](img/B14980_12_03.jpg)'
- en: 'Figure 12.3: Encryption (image by macrovector on Freepik)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3：加密（图片由 Freepik 上的 macrovector 提供）
- en: You need to master these concepts for better data encryption.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要掌握这些概念以更好地进行数据加密。
- en: Now, we can continue with key management.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续讨论密钥管理。
- en: Key management
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥管理
- en: '**Key management** involves the entire life cycle of cryptographic keys and
    other key-related materials. Key management in microservices is the process of
    generating, storing, rotating, and revoking encryption keys that are used to protect
    data and communication among microservices. Let’s look at this in more detail,
    along with some examples of best practices and considerations:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥管理**涉及加密密钥和其他相关密钥材料的整个生命周期。在微服务中的密钥管理是生成、存储、轮换和吊销用于保护微服务之间数据和通信的加密密钥的过程。让我们更详细地看看这一点，以及一些最佳实践和注意事项的示例：'
- en: '**Key generation**: Key generation is the process of creating keys for cryptography.
    Keys are used to encrypt and decrypt data so that only authorized parties can
    access it.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥生成**：密钥生成是创建用于密码学的密钥的过程。密钥用于加密和解密数据，以确保只有授权方可以访问它。'
- en: '*Best practice*: Use cryptographically secure random number generators to create
    strong keys.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳实践*：使用密码学安全的随机数生成器来创建强大的密钥。'
- en: '*Considerations*: Key length and algorithm choice impact security. Longer keys
    generally provide stronger security.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注意事项*：密钥长度和算法选择影响安全性。通常，较长的密钥提供更强的安全性。'
- en: '**Key storage**: Key storage is the process of keeping encryption keys safe
    and accessible for authorized parties. Encryption keys are used to protect data
    and communication from unauthorized access or theft.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥存储**：密钥存储是将加密密钥安全且可供授权方访问的过程。加密密钥用于保护数据和通信免受未经授权的访问或盗窃。'
- en: '*Best practice*: Store encryption keys securely, avoiding hardcoding them in
    source code or configuration files.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳实践*：安全存储加密密钥，避免在源代码或配置文件中硬编码它们。'
- en: '*Considerations*: Utilize **hardware security modules** (**HSMs**) for enhanced
    key protection.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注意事项*：利用 **硬件安全模块** (**HSM**) 以增强密钥保护。'
- en: '**Key distribution**: Key distribution is the process of delivering encryption
    keys to parties who wish to exchange secure encrypted data. Encryption keys are
    used to protect data and communication from unauthorized access or theft.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥分发**：密钥分发是将加密密钥交付给希望交换安全加密数据的各方的过程。加密密钥用于保护数据和通信免受未经授权的访问或盗窃。'
- en: '*Best practice*: Securely distribute keys in asymmetric encryption scenarios.
    Use key exchange protocols such as **Diffie-Hellman**.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳实践*：在不对称加密场景中安全地分发密钥。使用如 **Diffie-Hellman** 的密钥交换协议。'
- en: '*Considerations*: Protect against MitM attacks during key exchange. A MitM
    attack is a type of cyberattack where an attacker secretly intercepts and modifies
    the communication between two parties who think they are directly talking to each
    other.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注意事项*：在密钥交换期间防止中间人攻击。中间人攻击是一种网络攻击，攻击者秘密拦截并修改两个认为他们正在直接交谈的当事人之间的通信。'
- en: '**Key rotation**: Key rotation is the process of changing encryption keys periodically
    to reduce the risk of compromise or exposure.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥轮换**：密钥轮换是定期更改加密密钥的过程，以降低密钥被泄露或暴露的风险。'
- en: '*Best practice*: Regularly rotate keys to minimize the impact of a compromised
    key.'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳实践*：定期轮换密钥以最大限度地减少泄露密钥的影响。'
- en: '*Considerations*: Coordinate key rotation across microservices to avoid disruption.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注意事项*：协调微服务之间的密钥轮换以避免中断。'
- en: '**Key revocation**: Key revocation is the process of declaring that an encryption
    key is no longer valid and should not be used for encryption or decryption.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥吊销**：密钥吊销是宣布一个加密密钥不再有效且不应用于加密或解密的过程。'
- en: '*Best practice*: Implement processes for revoking compromised keys.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳实践*：实施吊销受损密钥的流程。'
- en: '*Considerations*: Rapidly revoke and replace keys if a compromise is suspected.'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注意事项*：如果怀疑出现泄露，应迅速吊销并更换密钥。'
- en: '**Secrets management**: Secrets management is the process of securely and efficiently
    managing the creation, rotation, revocation, and storage of digital authorization
    credentials.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥管理**：密钥管理是安全且高效地管理数字授权凭证的创建、轮换、吊销和存储的过程。'
- en: '*Best practice*: Use dedicated secrets management solutions for secure storage,
    retrieval, and rotation of keys and other sensitive information.'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳实践*：使用专门的密钥管理解决方案，以安全地存储、检索和轮换密钥及其他敏感信息。'
- en: '*Considerations*: Integrate with solutions that support key life-cycle management.'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注意事项*：与支持密钥生命周期管理的解决方案集成。'
- en: '**Monitoring and auditing**: Monitoring and auditing are two related but distinct
    processes that are essential for ensuring the effectiveness and compliance of
    an organization’s operations, systems, and data.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和审计**：监控和审计是两个相关但不同的过程，对于确保组织运营、系统和数据的有效性和合规性至关重要。'
- en: '*Best practice*: Implement robust monitoring and auditing of key usage.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳实践*：实施对密钥使用的稳健监控和审计。'
- en: '*Considerations*: Detect and respond to unusual or unauthorized key access.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注意事项*：检测并响应异常或不授权的密钥访问。'
- en: '**Crypto-agility**: Crypto-agility is the ability of a system to switch between
    different cryptographic algorithms, keys, and parameters without disrupting the
    system’s functionality or security.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密灵活性**：加密灵活性是指系统在不会干扰系统功能或安全性的情况下，在不同的加密算法、密钥和参数之间切换的能力。'
- en: '*Best practice*: Design systems with crypto-agility to facilitate the adoption
    of new algorithms or key lengths.'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳实践*：设计具有加密灵活性的系统，以促进新算法或密钥长度的采用。'
- en: '*Considerations*: Stay informed about developments in cryptography and be prepared
    to transition to stronger algorithms.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注意事项*：关注密码学的发展动态，并准备好过渡到更强的算法。'
- en: Key management is important because if keys are compromised, the data protected
    by those keys is also compromised. Therefore, **key management systems** (**KMSs**)
    are designed to protect against key compromises.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥管理很重要，因为如果密钥被泄露，受这些密钥保护的数据也会受到损害。因此，**密钥管理系统**（**KMSs**）旨在防止密钥泄露。
- en: In summary, encryption algorithms and key management are foundational elements
    of microservices security. Choosing appropriate algorithms and implementing sound
    key management practices are critical for protecting sensitive information and
    ensuring the overall security of a microservices architecture.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，加密算法和密钥管理是微服务安全的基础元素。选择合适的算法并实施合理的密钥管理实践对于保护敏感信息和确保微服务架构的整体安全性至关重要。
- en: Now, let’s move on to the next section, in which we will discuss authentication
    and authorization, input validation, secure coding practices, and API rate limiting.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入下一节，我们将讨论身份验证和授权、输入验证、安全编码实践和API速率限制。
- en: Authentication, authorization, input validation, secure coding practices, and
    API rate limiting
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证、授权、输入验证、安全编码实践和API速率限制
- en: In this section, we will discuss some of the core principles of secure software
    development and API management.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些安全软件开发和API管理的核心原则。
- en: Authentication
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证
- en: '**Authentication** is the process of verifying the identity of a user, device,
    or system. It often involves a username and password but can include any other
    method of demonstrating identity, such as biometrics.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证**是验证用户、设备或系统身份的过程。它通常涉及用户名和密码，但可以包括任何其他证明身份的方法，例如生物识别。'
- en: 'Best practices for authentication are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证的最佳实践如下：
- en: Use strong authentication mechanisms such as **Open Authorization 2.0** (**OAuth
    2.0**) or **JSON Web** **Token** (**JWT**).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用强认证机制，如**开放授权2.0**（**OAuth 2.0**）或**JSON Web令牌**（**JWT**）。
- en: Implement **multi-factor authentication** (**MFA**) for added security.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施额外的**多因素认证**（**MFA**）以提高安全性。
- en: Centralize authentication to a dedicated service when possible.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，将身份验证集中到专用服务。
- en: 'The following are some key considerations for authentication:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于身份验证的关键考虑因素：
- en: Ensure secure transmission of credentials.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保凭证的安全传输。
- en: Regularly audit and monitor authentication logs.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期审计和监控身份验证日志。
- en: Authentication is the process of verifying the identity of a user or a process
    before granting access to confidential data or systems.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是在授予对机密数据或系统访问权限之前验证用户或进程身份的过程。
- en: '*Figure 12**.4* illustrates authentication and authorization:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.4* 展示了认证和授权：'
- en: '![Figure 12.4: Authorization and authentication (image by vectorjuice on Freepik)](img/B14980_12_04.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4：授权和认证（图片由vectorjuice在Freepik提供）](img/B14980_12_04.jpg)'
- en: 'Figure 12.4: Authorization and authentication (image by vectorjuice on Freepik)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：授权和认证（图片由vectorjuice在Freepik提供）
- en: Authorization
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权
- en: Once a user’s identity is verified, **authorization** determines what permissions
    the user has—that is, what they are allowed to do. This could include access to
    certain files, the ability to perform certain functions, and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证了用户的身份，**授权**将确定用户拥有的权限——即他们被允许做什么。这可能包括访问某些文件、执行某些功能等。
- en: 'The following are best practices for authorization:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些授权的最佳实践：
- en: Adopt the **principle of least** **privilege** (**PoLP**).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用**最小权限**（**PoLP**）原则。
- en: Use **role-based access control** (**RBAC**) for fine-grained authorization.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**基于角色的访问控制**（**RBAC**）进行细粒度授权。
- en: Regularly review and update access permissions.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期审查和更新访问权限。
- en: 'Some key considerations for authorization are as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 授权的一些关键考虑因素如下：
- en: Implement proper session management.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施适当的会话管理。
- en: Use **attribute-based access control** (**ABAC**) for more dynamic authorization.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**基于属性的访问控制**（**ABAC**）进行更动态的授权。
- en: Authorization is the process of granting or denying access to resources, based
    on the identity and privileges of the requester. Authorization can be applied
    to different types of resources, such as files, databases, networks, or applications.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是根据请求者的身份和权限授予或拒绝访问资源的过程。授权可以应用于不同类型的资源，如文件、数据库、网络或应用程序。
- en: Input validation
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入验证
- en: This is a process used to ensure that data being input into an application or
    API is valid and secure before it is processed. This can help prevent things such
    as SQL injection attacks or data corruption.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个确保在处理之前，输入到应用程序或API中的数据有效且安全的过程。这有助于防止SQL注入攻击或数据损坏。
- en: 'The following are best practices for input validation:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些输入验证的最佳实践：
- en: Validate and sanitize all user inputs, both on the client and server sides.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端和服务器端验证和清理所有用户输入。
- en: Use parameterized queries to prevent SQL injection.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数化查询来防止SQL注入。
- en: Apply input validation on both frontend and backend components.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前端和后端组件上应用输入验证。
- en: 'Some key considerations for input validation are as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证的一些关键考虑因素如下：
- en: Implement whitelist validation to accept only known and expected inputs.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施白名单验证，仅接受已知和预期的输入。
- en: Regularly update and patch components to address known vulnerabilities.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期更新和修补组件以解决已知漏洞。
- en: Input validation is the process of checking data that users enter into a website
    or an application, to make sure that it is correct, complete, and secure.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证是检查用户输入到网站或应用程序中的数据的过程，以确保其正确、完整和安全。
- en: Secure coding practices
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全编码实践
- en: These are guidelines or standards for writing code in a manner that avoids common
    security vulnerabilities. This could include things such as proper error handling,
    strong encryption usage, and more.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是编写代码时避免常见安全漏洞的指南或标准。这可能包括正确处理错误、使用强加密等。
- en: 'Best practices for secure coding practices are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 安全编码实践的最佳实践如下：
- en: Follow PoLP when assigning permissions to services.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配服务权限时遵循PoLP原则。
- en: Use secure coding frameworks and libraries.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全的编码框架和库。
- en: Conduct regular security code reviews.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期进行安全代码审查。
- en: 'The following are some key considerations for secure coding practices:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些安全编码实践的关键考虑因素：
- en: Train developers in secure coding practices.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对开发者进行安全编码实践培训。
- en: Implement secure coding guidelines and enforce them.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施安全编码指南并强制执行。
- en: Secure coding practices are guidelines and standards that help developers write
    code that is secure, reliable, and resistant to common vulnerabilities and attacks.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 安全编码实践是帮助开发者编写安全、可靠且对常见漏洞和攻击具有抵抗力的代码的指南和标准。
- en: API rate limiting
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API速率限制
- en: '**API rate limiting** is the process of limiting the number of requests that
    a client (user or system) can make to an API in a certain amount of time. This
    helps protect the API from being overloaded and can also be a method of security
    to prevent things such as brute-force attacks.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**API 速率限制**是指在一定时间内限制客户端（用户或系统）对 API 发出请求数量的过程。这有助于保护 API 不被过载，也可以作为一种安全方法来防止诸如暴力攻击等问题。'
- en: 'Best practices for API rate limiting are as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: API 速率限制的最佳实践如下：
- en: Implement rate limiting to prevent abuse and protect against **distributed denial-of-service**
    (**DDoS**) attacks.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施速率限制以防止滥用并保护免受**分布式拒绝服务**（**DDoS**）攻击。
- en: Use token buckets or sliding window algorithms (for rate limiting).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用令牌桶或滑动窗口算法（用于速率限制）。
- en: The Sliding Window technique
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动窗口技术
- en: The **Sliding Window** technique is a computational approach used to optimize
    certain problems involving arrays, strings, or other data structures. It aims
    to reduce the use of nested loops and replace them with a single loop, thereby
    improving time complexity.)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**滑动窗口**技术是一种计算方法，用于优化涉及数组、字符串或其他数据结构的某些问题。它的目的是减少嵌套循环的使用，并用单个循环来替换它们，从而提高时间复杂度。）'
- en: Provide clear error messages when rate limits are exceeded.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当超过速率限制时，提供清晰的错误信息。
- en: 'The following are some key considerations for API rate limiting:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 API 速率限制的关键考虑因素：
- en: Differentiate rate limits based on user roles or API endpoints.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户角色或 API 端点区分速率限制。
- en: Implement adaptive rate limiting to respond dynamically to traffic patterns.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施自适应速率限制以动态响应流量模式。
- en: All these practices help improve the reliability and security of software applications
    and web services.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些实践都有助于提高软件应用程序和 Web 服务的可靠性和安全性。
- en: In summary, by integrating these security practices into the development life
    cycle of microservices, organizations can significantly enhance the security posture
    of their systems. Regular security assessments, training, and a proactive approach
    to addressing emerging threats are key components of a robust microservices security
    strategy.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过将这些安全实践集成到微服务的开发生命周期中，组织可以显著提高其系统的安全态势。定期的安全评估、培训和积极应对新兴威胁是强大微服务安全策略的关键组成部分。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned a lot about microservices and how to ensure
    data security in a microservices architecture involves implementing various measures,
    including the use of the Saga pattern, encryption, and additional security measures.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于微服务的大量知识，以及如何在微服务架构中确保数据安全，这涉及到实施各种措施，包括使用 Saga 模式、加密和额外的安全措施。
- en: In summary, by combining the Saga pattern, encryption, and additional security
    measures, you create a robust defense against various security threats in a microservices
    environment. Regularly reassess and update security practices to stay ahead of
    emerging threats.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过结合 Saga 模式、加密和额外的安全措施，您可以在微服务环境中创建针对各种安全威胁的强大防御。定期重新评估和更新安全实践，以保持对新兴威胁的领先。
- en: Data security is of paramount significance, especially in our modern, data-driven
    era. Protecting sensitive information from unauthorized access, use, disclosure,
    disruption, modification, or destruction requires strategic measures. We looked
    at three ways to ensure data security—by implementing the Saga pattern, encryption,
    and additional security measures.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 数据安全至关重要，尤其是在我们这个以数据驱动的现代时代。保护敏感信息免受未经授权的访问、使用、披露、中断、修改或破坏需要战略措施。我们探讨了确保数据安全的三个方法——通过实施
    Saga 模式、加密和额外的安全措施。
- en: In the next chapter, we are going to learn about monitoring microservices in
    Node.js.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在 Node.js 中监控微服务。
- en: Quiz time
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验时间
- en: What are some key considerations for compensating actions?
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补偿操作有哪些关键考虑因素？
- en: What is a saga orchestration?
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 saga 调度？
- en: What is event-driven communication?
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是事件驱动通信？
- en: What are encryption algorithms?
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密算法是什么？
- en: 'Part 4: Monitoring and Logging in Microservices with Node.js'
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 部分：使用 Node.js 在微服务中进行监控和日志记录
- en: In this part, we will talk about monitoring and logging in microservices and
    how to interpret and analyze logging data in microservices in Node.js.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们将讨论微服务的监控和日志记录，以及如何在 Node.js 中解释和分析日志数据。
- en: 'The part contains the following chapters:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 13*](B14980_13.xhtml#_idTextAnchor241), *Monitoring Microservices
    in Node.js*'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 13 章*](B14980_13.xhtml#_idTextAnchor241)，*在 Node.js 中监控微服务*'
- en: '[*Chapter 14*](B14980_14.xhtml#_idTextAnchor261), *Logging in Microservices
    with Node.js*'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B14980_14.xhtml#_idTextAnchor261), *使用Node.js在微服务中进行日志记录*'
- en: '[*Chapter 15*](B14980_15.xhtml#_idTextAnchor276), *Interpreting Monitoring
    Data in Microservices*'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B14980_15.xhtml#_idTextAnchor276), *在微服务中解释监控数据*'
- en: '[*Chapter 16*](B14980_16.xhtml#_idTextAnchor285), *Analyzing Log Data in Microservices
    with Node.js*'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B14980_16.xhtml#_idTextAnchor285), *使用Node.js在微服务中分析日志数据*'
