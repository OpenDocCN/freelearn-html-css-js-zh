- en: Chapter 7. Patterns and Architectures in JavaScript and TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. JavaScript和TypeScript中的模式和架构
- en: In the previous four chapters, we've walked through common and classical design
    patterns and discussed some of their variants in JavaScript or TypeScript. In
    this chapter, we'll continue with some architecture and patterns closely related
    to the language and their common applications. We don't have many pages to expand
    and certainly cannot cover everything in a single chapter, so please take it as
    an appetizer and feel free to explore more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前四章中，我们介绍了常见的和经典的设计模式，并在JavaScript或TypeScript中讨论了一些变体。在本章中，我们将继续探讨一些与语言紧密相关且具有常见应用的架构和模式。我们没有很多页面来扩展，当然也不能在一章中涵盖所有内容，所以请把它当作开胃菜，并自由探索更多。
- en: Many topics in this chapter are related to asynchronous programming. We'll start
    with a web architecture for Node.js that's based on Promise. This is a larger
    topic that has interesting ideas involved, including abstractions of responses
    and permissions, as well as error handling tips. Then we'll talk about how to
    organize modules with **ECMAScript** (**ES**) module syntax. And this chapter
    will end with several useful asynchronous techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多主题都与异步编程相关。我们将从基于Promise的Node.js Web架构开始。这是一个较大的主题，其中包含有趣的想法，包括响应和权限的抽象以及错误处理技巧。然后我们将讨论如何使用**ECMAScript**（**ES**）模块语法组织模块。本章将以几个有用的异步技术结束。
- en: 'Overall, we''ll have the following topics covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，本章将涵盖以下主题：
- en: Architecture and techniques related to Promise
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Promise相关的架构和技术
- en: Abstraction of responses and permissions in a web application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序中响应和权限的抽象
- en: Modularizing a project to scale
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目模块化以实现扩展
- en: Other useful asynchronous techniques
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他有用的异步技术
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Again, due to the limited length, some of the related code is aggressively simplified
    and nothing more than the idea itself can be applied practically.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于篇幅有限，一些相关代码被大大简化，实际上只能应用其理念本身。
- en: Promise-based web architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Promise的Web架构
- en: 'To have a better understanding of the differences between Promises and traditional
    callbacks, consider an asynchronous task like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Promise与传统回调之间的区别，考虑以下异步任务：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we write preceding above in Promise style, it would be as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以上述方式用Promise风格编写，将会如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As in the preceding example, Promise makes it easy and *natural* to write asynchronous
    operations with a flat chain instead of nested callbacks. But the most exciting
    thing about Promise might be the benefits it brings to error handling. In a Promise-based
    architecture, throwing an error can be safe and pleasant. You don't have to explicitly
    handle errors when chaining asynchronous operations, and this makes mistakes less
    likely to happen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的例子所示，Promise使得使用扁平链而不是嵌套回调来编写异步操作变得简单且*自然*。但Promise最令人兴奋的事情可能是它为错误处理带来的好处。在基于Promise的架构中，抛出错误可以是安全和愉快的。你不必在链式调用异步操作时显式处理错误，这使得错误发生的可能性降低。
- en: With the growing usage with ES6 compatible runtimes, Promise is already there
    out of the box. And we actually have plenty of polyfills for Promises (including
    my `*ThenFail*` written in TypeScript), as people who write JavaScript roughly
    refer to the same group of people who created wheels.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着与ES6兼容运行时的使用日益增长，Promise已经作为默认选项存在。实际上，我们有很多Promise的polyfills（包括我用TypeScript编写的`*ThenFail*`），因为编写JavaScript的人大致上指的是创造了轮子的人群。
- en: 'Promises work well with other Promises:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Promise与其他Promise协同工作得很好：
- en: A *Promises/A+* -compatible implementation should work with other *Promises/A+*
    -compatible implementations
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与*Promises/A+* 兼容的实现应该与其他*Promises/A+* 兼容的实现一起工作
- en: Promises work best in a Promise-based architecture
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promise在基于Promise的架构中表现最佳
- en: If you are new to Promise, you might be complaining about using Promises with
    a callback-based project. Using asynchronous helpers such as `Promise.each` (non-standard)
    provided by Promise libraries is a common reason for people to try out Promise,
    but it turns out they have better alternatives (for a callback-based project)
    such as the popular `async` library.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触Promise，你可能会抱怨在使用基于回调的项目中使用Promise。使用Promise库提供的异步助手，如`Promise.each`（非标准），是人们尝试Promise的常见原因，但结果证明他们有更好的替代方案（对于基于回调的项目），例如流行的`async`库。
- en: The reason that makes you decide to switch should not be these helpers (as there
    are a lot of them for old-school callbacks as well), but an easier way to handle
    errors or to take advantage of the ES `async`/`await` feature, which is based
    on Promise.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使你决定切换的原因不应该是这些辅助工具（因为老式的回调也有很多），而应该是一个更容易处理错误或利用基于承诺的 ES `async`/`await` 功能的方法，这是基于承诺的。
- en: Promisifying existing modules or libraries
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺化现有模块或库
- en: Though Promises do best in a Promise-based architecture, it is still possible
    to begin using Promise with a smaller scope by promisifying existing modules or
    libraries.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然承诺在基于承诺的架构中表现最好，但仍然可以通过承诺化现有模块或库以较小的范围开始使用承诺。
- en: 'Let''s take Node.js style callbacks as an example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 Node.js 风格的回调为例：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You may expect a promisified version of the `readFile` function to look like
    the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望被承诺化的 `readFile` 函数看起来像以下这样：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The implementation of the promisified function `readFile` can be easy:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实现被承诺化的函数 `readFile` 可以很简单：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I am using the type `any` here for parameter options to reduce the size of the
    code example, but I would suggest not using `any` whenever possible in practice.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用类型 `any` 来减少代码示例的大小，但在实际操作中，我建议尽可能不要使用 `any`。
- en: There are libraries that are able to promisify methods automatically. Though,
    unfortunately, you might need to write declaration files yourself for the promisified
    methods if there are no promisified version available.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些库能够自动承诺化方法。不过，不幸的是，如果没有可用的承诺化版本，你可能需要自己编写声明文件来承诺化这些方法。
- en: Views and controllers in Express
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Express 中的视图和控制器
- en: 'Many of us may have already worked with frameworks such as **Express**. And
    this is how we render a view or response with JSON in Express:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人可能已经与 **Express** 等框架一起工作过。这就是我们在 Express 中使用 JSON 渲染视图或响应的方式：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will usually separate controllers from the routing configuration:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会分离控制器和路由配置：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Thus we may have a better idea of existing routes, and have controllers managed
    more easily. Furthermore, automated routing could be introduced so that we don''t
    always need to update routing manually:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能对现有路由有更好的了解，并且更容易管理控制器。此外，可以引入自动化路由，这样我们就不必总是手动更新路由：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The implementation above is certainly too simple to cover daily use, but it
    shows a rough idea of how automated routing could work: via conventions based
    on file structures.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现当然过于简单，不足以覆盖日常使用，但它展示了自动化路由可能如何工作：基于文件结构的约定。
- en: 'Now, if we are working with asynchronous code written in Promises, an action
    in the controller could be like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们正在使用承诺编写的异步代码，控制器中的操作可能如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are destructuring  an array within a parameter. `Promise.all` returns a Promise
    of an array with elements corresponding to the values of the resolvables passed
    in. (A resolvable means a normal value or a Promise-like object that may resolve
    to a normal value.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个参数内部解构数组。`Promise.all` 返回一个承诺，该承诺是一个数组，其元素对应于传入的可解析值的值。（可解析意味着一个普通值或可能解析为普通值的类似承诺的对象。）
- en: 'But that''s not enough; we still need to handle errors properly, or in some
    Promise implementations, the preceding code may fail in silence because the Promise
    chain is not handled by a rejection handler (which is terrible). In Express, when
    an error occurs, you should call `next` (the third argument passed into the callback)
    with the error object:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不够；我们仍然需要正确处理错误，或者在某些承诺实现中，如果承诺链没有被拒绝处理程序（这很糟糕）处理，前面的代码可能会静默失败。在 Express
    中，当发生错误时，你应该使用错误对象调用 `next`（传递给回调的第三个参数）：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we are fine with the correctness of this approach, but that''s simply
    not how Promises work. Explicit error handling with callbacks could be eliminated
    in the scope of controllers, and the easiest way is to return the Promise chain
    and hand over to code that was previously doing routing logic. So the controller
    could be written like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对这种方法的正确性感到满意，但这并不是承诺的工作方式。在控制器范围内，可以通过显式使用回调来处理错误，并且最简单的方法是返回承诺链并将其交给之前执行路由逻辑的代码。因此，控制器可以写成这样：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But, could we make it even better?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但，我们能否让它更好？
- en: Abstraction of responses
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应的抽象
- en: 'We''ve already been returning a Promise to tell whether an error occurs. So
    now the returned Promise indicates the status of the response: success or failure.
    But why we are still calling `res.render()` for rendering the view? The returned
    promise object could be the response itself rather than just an error indicator.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经返回了一个Promise来告诉是否发生错误。所以现在返回的Promise表示响应的状态：成功或失败。但为什么我们仍然调用`res.render()`来渲染视图？返回的promise对象可以是响应本身，而不仅仅是错误指示器。
- en: 'Think about the controller again:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次思考控制器：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The response object returned could vary for different response outputs. For
    example, it could be either a `PageResponse` like it is in the preceding example,
    a `JSONResponse`, a `StreamResponse`, or even a simple `Redirection`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的响应对象可能因不同的响应输出而异。例如，它可以是类似于前一个示例中的`PageResponse`，`JSONResponse`，`StreamResponse`，甚至简单的`Redirection`。
- en: 'As, in most cases, `PageResponse` or `JSONResponse` is applied, and the view
    of a `PageResponse` can usually be implied by the controller path and action name,
    it is useful to have those two responses automatically generated from a plain
    data object with a proper view to render with:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在大多数情况下，`PageResponse`或`JSONResponse`被应用，并且`PageResponse`的视图通常可以通过控制器路径和动作名称隐含，因此从普通数据对象自动生成具有适当视图的这两个响应是有用的：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And that''s how a Promise-based controller should respond. With this idea,
    let''s update the routing code with the abstraction of responses. Previously,
    we were passing controller actions directly as Express request handlers. Now we
    need to do some wrapping up with the actions by resolving the return value, and
    applying operations based on the resolved result:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于Promise的控制器应该如何响应。有了这个想法，让我们用响应的抽象更新路由代码。之前，我们直接将控制器动作作为Express请求处理程序传递。现在我们需要通过解析返回值对动作进行一些包装，并基于解析结果应用操作：
- en: If it fulfils and it's an instance of `Response`, apply it to the `res` object
    passed in by Express.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它实现，并且是`Response`的实例，则将其应用于Express传入的`res`对象。
- en: If it fulfils and it's a plain object, construct a `PageResponse` or a `JSONResponse`
    if no view found and apply it to the `res` object.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它实现，并且是一个普通对象，如果没有找到视图，则构建一个`PageResponse`或`JSONResponse`，并将其应用于`res`对象。
- en: If it rejects, call the `next` function with the reason.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它拒绝，则使用原因调用`next`函数。
- en: 'Previously, it was like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，它看起来是这样的：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now it gets a few more lines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它多了几行：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, so far we can handle only `GET` requests as we hardcoded `app.get()`
    in our router implementation. The poor view-matching logic can hardly be used
    in practice either. We need to make the actions configurable, and ES decorators
    could do nice work here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，我们只能处理`GET`请求，因为我们硬编码了`app.get()`在我们的路由实现中。糟糕的视图匹配逻辑在实践中也几乎无法使用。我们需要使操作可配置，并且ES装饰器可以在这里做得很好：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I'll leave the implementation to you, and feel free to make it awesome.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把实现留给你，并自由地让它变得很棒。
- en: Abstraction of permissions
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限抽象
- en: Permissions play an important role in a project, especially in systems that
    have different user groups, for example, a forum. The abstraction of permissions
    should be extendable to satisfy changing requirements, and it should be easy to
    use as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 权限在项目中扮演着重要的角色，尤其是在有不同用户组的系统中，例如论坛。权限的抽象应该可扩展以满足不断变化的需求，并且应该易于使用。
- en: Here, we are going to talk about the abstraction of permission in the level
    of controller actions. Consider the legibility of performing one or more actions
    as a  ***privilege**.* The permission of a user may consist of several privileges and
    usually most users at the same level would have the same set of privileges. So
    we may have a larger concept, namely ***groups**.*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论控制器动作层面的权限抽象。将执行一个或多个动作的可读性视为**权限**。用户的权限可能由几个权限组成，并且通常同一级别的用户通常会有相同的权限集合。因此，我们可能有一个更大的概念，即**组**。
- en: 'The abstraction could either work based on both groups and privileges or based
    on privileges only (groups are then just aliases to sets of privileges):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象可以基于组和权限同时工作，或者仅基于权限（此时组只是权限集合的别名）：
- en: Abstractions that validate based on privileges and groups at the same time is
    easier to build. You do not need to create a large list of which actions can be
    performed for a certain group of users; granular privileges are only required
    when necessary.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时基于权限和组进行验证的抽象更容易构建。您不需要创建一个包含哪些操作可以由特定用户组执行的大列表；只有在必要时才需要细粒度的权限。
- en: Abstractions that validate based on privileges have better control and more
    flexibility for describing the permission. For example, you can remove a small
    set of privileges from the permission of a user easily.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于权限验证的抽象在描述权限方面具有更好的控制和更大的灵活性。例如，您可以轻松地从用户的权限中移除一小部分权限。
- en: 'However, both approaches have similar upper-level abstractions and differ mostly
    in implementation. The general structure of the permission abstractions we''ve
    talked about is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两种方法在高级抽象方面相似，主要区别在于实现。我们讨论过的权限抽象的一般结构如下：
- en: '![Abstraction of permissions](img/image_07_001.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![权限抽象](img/image_07_001.jpg)'
- en: 'The participants include the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者包括以下内容：
- en: '**Privilege**: Describes detailed privileges corresponding to specific actions'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限**：描述与特定操作对应的详细权限'
- en: '**Group**: Defines a set of privileges'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**：定义一组权限'
- en: '**Permission**: Describes what a user is capable of doing; consists of groups
    the user belongs to and privileges the user has'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限**：描述用户能够做什么；由用户所属的组和用户拥有的权限组成'
- en: '**Permission descriptor**: Describes how the permission of a user would be
    sufficient; consists of *possible* groups and privileges'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限描述符**：描述用户的权限如何足够；由*可能的*组和权限组成'
- en: Expected errors
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预期错误
- en: A great concern wiped away by using Promises is that we do not need to worry
    about throwing an error in a `callback` would crash the application most of the
    time. The error will flow through the Promises chain and, if not caught, will
    be handled by our router. Errors can be roughly divided into **expected errors**
    and **unexpected errors**. Expected errors are usually caused by incorrect input
    or foreseeable exceptions, and unexpected errors are usually caused by bugs or
    other libraries the project relies on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Promise消除的一个重大担忧是，我们不需要担心在`callback`中抛出错误会大多数情况下导致应用程序崩溃。错误将通过Promise链流动，如果没有被捕获，将由我们的路由器处理。错误可以大致分为**预期错误**和**意外错误**。预期错误通常是由错误的输入或可预见的异常引起的，而意外错误通常是由项目依赖的bug或其他库引起的。
- en: For expected errors, we usually want to give user-friendly responses with readable
    error messages and codes, so that users can help themselves to find solutions
    or report to us with useful context. For unexpected errors, we would also want
    reasonable responses (usually messages described as unknown errors), a detailed
    server-side log (including the real error name, message, stack information, and
    so on), and even alarms for getting the team notified as soon as possible.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预期错误，我们通常希望提供用户友好的响应，带有可读的错误消息和代码，以便用户可以自行找到解决方案或向我们提供有用的上下文进行报告。对于意外错误，我们也会想要合理的响应（通常描述为未知错误），详细的客户端日志（包括真实错误名称、消息、堆栈信息等），甚至警报以尽快通知团队。
- en: Defining and throwing expected errors
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和抛出预期错误
- en: 'The router will need to handle different types of errors, and an easy way to
    achieve that is to subclass a universal `ExpectedError` class and throw its instances
    out:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器需要处理不同类型的错误，而实现这一点的一个简单方法是从通用的`ExpectedError`类派生子类，并抛出其实例：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `extendable-error` is a package of mine that handles stack trace and the
    `message` property. You can directly extend the `Error` class as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`extendable-error`是我处理堆栈跟踪和`message`属性的包。您也可以直接扩展`Error`类。'
- en: Thus, when receiving an expected error, we can safely output its message as
    part of the response. And if it's not an instance of `ExpectedError`, we can then
    output predefined `unknown` error messages and have detailed error information
    logged.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当接收到预期错误时，我们可以安全地将错误消息作为响应的一部分输出。如果不是`ExpectedError`的实例，我们可以输出预定义的`unknown`错误消息，并将详细的错误信息记录下来。
- en: Transforming errors
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误转换
- en: Some errors, such as those caused by unstable networks or remote services, are
    expected; we may want to catch those errors and throw them out again as expected
    errors. But it is rather trivial to actually do that. A centralized error-transforming
    process can then be applied to reduce the efforts required to manage those errors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些错误，如由不稳定网络或远程服务引起的错误，是预期的；我们可能想要捕获这些错误并将它们再次作为预期错误抛出。但这实际上相当简单。然后可以应用集中的错误转换过程，以减少管理这些错误所需的工作量。
- en: 'The transforming process includes two parts: filtering (or matching) and transforming.
    There are many approaches to filter errors, such as the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 转换过程包括两个部分：过滤（或匹配）和转换。有许多方法可以过滤错误，例如以下方法：
- en: '**Filter by error class**: Many third-party libraries throw errors of certain
    classes. Taking Sequelize (a popular Node.js ORM) as an example, it throws `DatabaseError`,
    `ConnectionError`, `ValidationError`, and so on. By filtering errors by checking
    whether they are instances of a certain error class, we may easily pick up target
    errors from the pile.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按错误类过滤**：许多第三方库会抛出特定类的错误。以流行的Node.js ORM Sequelize为例，它抛出`DatabaseError`、`ConnectionError`、`ValidationError`等。通过检查它们是否是特定错误类的实例来过滤错误，我们可以轻松地从错误堆中挑选出目标错误。'
- en: '**Filter by string or regular expression**: Sometimes a library might be throwing
    errors that are instances of an `Error` class itself instead of its subclasses;
    this makes those errors harder to distinguish from others. In this situation,
    we may filter those errors by their message, with keywords or regular expressions.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按字符串或正则表达式过滤**：有时一个库可能会抛出错误，这些错误本身就是`Error`类的实例，而不是其子类；这使得这些错误与其他错误区分起来更困难。在这种情况下，我们可能通过它们的消息、关键词或正则表达式来过滤这些错误。'
- en: '**Filter by scope**: It''s possible that instances of the same error class
    with the same error message should result in different responses. One of the reasons
    might be that the operation that throws a certain error is at a lower level, but
    is being used by upper structures within different scopes. Thus, a `scope` mark
    could be added for those errors and make them easier to be filtered.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按作用域过滤**：可能存在具有相同错误消息的同一错误类的实例应该导致不同的响应。其中一个原因可能是抛出特定错误的操作处于较低级别，但被不同作用域中的上层结构使用。因此，可以为这些错误添加一个`scope`标记，使它们更容易被过滤。'
- en: There could be more ways to filter errors, and they are usually able to cooperate
    as well. By properly applying those filters and transforming errors, we can reduce
    noise for analyzing what's going on within a system and locate problems faster
    if they show up.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有更多过滤错误的方法，并且它们通常能够相互协作。通过恰当地应用这些过滤器和转换错误，我们可以减少分析系统内部发生情况时的噪音，并在问题出现时更快地定位它们。
- en: Modularizing project
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化项目
- en: Before ES6, there were a lot of module solutions for JavaScript that worked.
    The two most famous of them are AMD and commonjs. AMD is designed for asynchronous
    module loading, which is mostly applied in browsers, while commonjs does module
    loading synchronously, and that's the way the Node.js module system works.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，JavaScript有很多模块解决方案，其中最著名的两个是AMD和commonjs。AMD是为异步模块加载而设计的，主要应用于浏览器，而commonjs则同步加载模块，这正是Node.js模块系统的工作方式。
- en: To make it work asynchronously, writing an AMD module takes more characters.
    And due to the popularity of tools such as browserify and webpack, commonjs becomes
    popular even for browser projects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其异步工作，编写AMD模块需要更多的字符。而且由于browserify和webpack等工具的流行，commonjs甚至对于浏览器项目也变得流行起来。
- en: 'The proper granularity of internal modules could help a project keep its structure
    healthy. Consider a project structure like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 内部模块的正确粒度可以帮助项目保持其结构健康。考虑以下项目结构：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Assume we are writing a controller file that''s going to import a module defined
    by the `core/product/order.ts` file. Previously, with the commonjs `require` style, we
    would want to write the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一个控制器文件，该文件将导入由`core/product/order.ts`文件定义的模块。以前，使用commonjs的`require`风格，我们可能想要编写以下内容：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, with the new ES `import` syntax, it would be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用新的ES `import`语法，它将是以下这样：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Wait, isn''t that essentially the same? Sort of. But you may have noticed several
    `index.ts` files I''ve put into folders. Now, in the file `core/product/index.ts`,
    we can have the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，这不是本质上是一样的吗？有点像。但你可能已经注意到我放入文件夹中的几个`index.ts`文件。现在，在`core/product/index.ts`文件中，我们可以有如下所示：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, we could have the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以有如下所示：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What's the difference? The ideas behind those two approaches of **re-exporting**
    modules can vary. The first style works better when we treat `Order` and `Shipping`
    as namespaces, under which the entity names may not be easy to distinguish from
    one group to another. With this style, the files are the natural boundaries of
    building those namespaces. The second style weakens the namespace property of
    two files and uses them as tools to organize objects and classes under the same
    larger category.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么区别？这两种**重新导出**模块的方法背后的思想可能不同。第一种风格在我们将`Order`和`Shipping`视为命名空间时效果更好，在这个命名空间下，实体名称可能不容易区分不同组。采用这种风格，文件是构建这些命名空间的自然边界。第二种风格削弱了两个文件的命名空间属性，并使用它们作为组织同一更大类别下对象和类的工具。
- en: A good thing about using those files as namespaces is that multiple-level re-exporting
    is fine while weakening namespaces makes it harder to understand different identifier
    names as the number of re-exporting levels grows.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些文件作为命名空间的好处是，多级重导出是可行的，而命名空间的弱化使得随着重导出级别的增加，理解不同的标识符名称变得更加困难。
- en: Asynchronous patterns
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步模式
- en: When we are writing JavaScript with network or file system I/O, there is a 95%
    chance that we are doing it asynchronously. However, an asynchronous code may
    tremendously decrease the determinability at the dimension of time. But we are
    so lucky that JavaScript is usually single-threaded; this makes it possible for
    us to write predictable code without mechanisms such as locks most of the time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用网络或文件系统I/O编写JavaScript时，有95%的可能性我们在做异步操作。然而，异步代码可能会在时间维度上极大地降低可确定性。但幸运的是，JavaScript通常是单线程的；这使得我们能够在大多数情况下无需使用锁等机制来编写可预测的代码。
- en: Writing predictable code
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写可预测的代码
- en: 'The predictable code relies on predictable tools (if you are using any). Consider
    a helper like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测的代码依赖于可预测的工具（如果你在使用任何的话）。考虑以下这样的辅助工具：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This module exports a `ready` function, which will invoke the callbacks passed
    in when "ready". It will assure that callbacks will be called even if added after
    that. However, you cannot say for sure whether the callback will be called in
    the current event loop:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块导出了一个`ready`函数，该函数将在“ready”时调用传入的回调函数。它将确保即使在该之后添加的回调也会被调用。然而，你无法确定回调是否会在当前的事件循环中被调用：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding example, `i` could either be 0 or `1` when the callback gets
    called. Again, this is not wrong, or even bad, it just makes the code less predictable.
    When someone else reads this piece of code, he or she will need to consider two
    possibilities of how this program would run. To avoid this issue, we can simply
    wrap up the synchronous invocation with `setImmediate` (it may fallback to `setTimeout`
    in older browsers):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当回调被调用时，`i`可以是0或1。再次强调，这并不错，甚至不坏，它只是让代码的可预测性降低。当其他人阅读这段代码时，他们需要考虑程序如何运行的两种可能性。为了避免这个问题，我们可以简单地用`setImmediate`（在旧浏览器中可能会回退到`setTimeout`）包装同步调用：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Writing predictable code is actually more than writing predictable asynchronous
    code. The highlighted line above can also be written as `setImmediate(callback)`,
    but that would make people who read your code think twice: how will `callback`
    get called and what are the `arguments`?'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 编写可预测的代码实际上不仅仅是编写可预测的异步代码。上面的高亮行也可以写成`setImmediate(callback)`，但这会让阅读你代码的人三思：`callback`将如何被调用以及`arguments`是什么？
- en: 'Consider the line of code below:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码行：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'What''s the value of the array `results`? Certainly not `[1, 2, 3]`. Because
    the callback passed to the method `map` receives several arguments: value of current
    item, index of current item, and the whole array, while the function `parseInt`
    accepts two arguments: string to parse, and radix. So `results` are actually the
    results of the following snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`results`的值是多少？当然不是`[1, 2, 3]`。因为传递给`map`方法回调函数的参数有几个：当前项的值、当前项的索引和整个数组，而`parseInt`函数接受两个参数：要解析的字符串和基数。因此`results`实际上是以下代码片段的结果：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, it is actually okay to write `setImmediate(callback)` directly, as
    the APIs of those functions (including `setTimeout`, `setInterval`, `process.nextTick`,
    and so on) are designed to be used in this way. And it is fair to assume people
    who are going to maintain this project know that as well. But for other asynchronous
    functions whose signatures are not well known, it is recommended to call them
    with explicit arguments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，直接编写`setImmediate(callback)`实际上是可行的，因为这些函数的API（包括`setTimeout`、`setInterval`、`process.nextTick`等）被设计成这样使用。而且可以合理假设将要维护此项目的人也知道这一点。但对于签名不太为人所知的其他异步函数，建议使用显式参数来调用它们。
- en: Asynchronous creational patterns
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步创建型模式
- en: We talked about many creational patterns in [Chapter 3](ch03.html "Chapter 3. Creational
    Design Patterns"), *Creational Design Patterns*. While a constructor cannot be
    asynchronous, some of those patterns may have problems applying to asynchronous
    scenarios. But others need only slight modifications for asynchronous use.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。创建型设计模式")中讨论了许多创建型模式，*创建型设计模式*。虽然构造函数不能是异步的，但其中一些模式可能存在应用于异步场景的问题。但其他模式只需稍作修改即可用于异步使用。
- en: 'In [Chapter 4](ch04.html "Chapter 4. Structural Design Patterns"), *Structural
    Design Patterns* we walked through the Adapter Pattern with a storage example
    that opens the database and creates a storage object asynchronously:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](ch04.html "第 4 章。结构型设计模式") 中，我们通过一个打开数据库并异步创建存储对象的示例，探讨了适配器模式。
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And in the Proxy Pattern, we made the storage object immediately available
    from its constructor. When a method of the object is called, it waits for the
    initialization to complete and finishes the operation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理模式中，我们使存储对象从其构造函数立即可用。当调用对象的方法时，它等待初始化完成并完成操作：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A drawback of this approach is that all members that rely on initialization
    have to be asynchronous, though most of the time they just are asynchronous.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，所有依赖初始化的成员都必须是异步的，尽管大多数情况下它们只是异步的。
- en: Asynchronous middleware and hooks
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步中间件和钩子
- en: The concept of middleware is widely used in frameworks such as Express. Middleware
    usually processes its target in serial. In Express, middleware is applied roughly
    in the order it is added while there are not different phases. Some other frameworks,
    however, provide hooks for different phases in time. For example, there are hooks
    that will be triggered *before install*, *after install*, *after uninstall*, and
    so on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的概念在 Express 等框架中得到了广泛的应用。中间件通常按顺序处理其目标。在 Express 中，中间件的添加顺序大致与添加的顺序相同，而没有不同的阶段。然而，一些其他框架提供了不同时间阶段的钩子。例如，有在
    *安装前*、*安装后*、*卸载后* 等触发的事件。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The middleware mechanism of Express is actually a variant of the Chain of Responsibility
    Pattern. And depending on the specific middleware to be used, it can act more
    or less like hooks instead of a responsibility chain.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Express 的中间件机制实际上是一种责任链模式的变体。根据要使用的具体中间件，它可能更像钩子而不是责任链，其作用程度有所不同。
- en: 'The reasons to implement middleware or hooks vary. They may include the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中间件或钩子的原因多种多样。可能包括以下内容：
- en: '**Extensibility**: Most of the time, they are applied due to the requirement
    of extensibility. New rules and processes could be easily added by new middleware
    or hooks.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：大多数情况下，它们的应用是由于可扩展性的需求。新的规则和流程可以通过新的中间件或钩子轻松添加。'
- en: '**Decoupling interactions with business logic**: A module that should only
    care about business logic could need potential interactions with an interface.
    For example, we might expect to be able to either enter or update credentials
    while processing an operation, without restarting everything. Thus we can create
    a middleware or a hook, so that we don''t need to have them tightly coupled.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦与业务逻辑的交互**：一个只应关注业务逻辑的模块可能需要与接口进行潜在交互。例如，我们可能期望在处理操作时能够输入或更新凭据，而无需重启一切。因此，我们可以创建一个中间件或钩子，这样我们就不需要将它们紧密耦合。'
- en: 'The implementation of asynchronous middleware could be interesting. Take the
    Promise version as an example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 异步中间件的实现可能很有趣。以 Promise 版本为例：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we're using `reduce` to do the trick. We passed in a Promise fulfilled
    with undefined as the initial value, and chained it with the result of `middleware(this)`.
    And this is actually how the `Promise.each` helper is implemented in many Promise
    libraries.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `reduce` 来完成这个任务。我们传递了一个以 `undefined` 作为初始值的已解决的 Promise，并将其与 `middleware(this)`
    的结果链式连接。实际上，这正是许多 Promise 库中 `Promise.each` 辅助函数的实现方式。
- en: Event-based stream parser
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于事件的流解析器
- en: When creating an application relies on socket, we usually need a lightweight
    "protocol" for the client and server to communicate. Unlike XHR that already handles
    everything, by using socket, you will need to define the boundaries so data won't
    be mixed up.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个依赖于套接字的应用程序时，我们通常需要一个轻量级的“协议”供客户端和服务器进行通信。与已经处理所有事情的 XHR 不同，使用套接字时，你需要定义边界，以防止数据混淆。
- en: 'Data transferred through a socket might be concatenated or split, but TCP connection
    ensures the order and correctness of bytes gets transferred. Consider a tiny protocol
    that consists of only two parts: a 4-byte unsigned integer followed by a JSON
    string with byte length that matches the 4-byte unsigned integer.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过套接字传输的数据可能会连接或拆分，但 TCP 连接确保字节传输的顺序和正确性。考虑一个只包含两个部分的微小协议：一个 4 字节的无符号整数，后面跟着一个与
    4 字节无符号整数匹配的字节长 JSON 字符串。
- en: 'For example, for JSON `"{}"`, the data packet would be as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 JSON `"{}"`，数据包可能如下所示：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To build such a data packet, we just need to convert the JSON string to `Buffer`
    (with encoding such as `utf-8`, which is default encoding for Node.js), and then
    prepend its length:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这样的数据包，我们只需要将JSON字符串转换为`Buffer`（使用如`utf-8`这样的编码，这是Node.js的默认编码），然后在其前面添加其长度：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A socket client emits a `data` event when it receives new buffers. Assume we
    are going to send the following JSON strings:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当套接字客户端接收到新的缓冲区时，它会触发一个`data`事件。假设我们将发送以下JSON字符串：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We may be receiving them like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会像这样接收它们：
- en: Get two buffers separately; each of them is a complete packet with length and
    JSON bytes
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分别获取两个缓冲区；每个缓冲区都是一个完整的包，包含长度和JSON字节
- en: Get one single buffer with two buffers concatenated
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过连接两个缓冲区获得一个单独的缓冲区
- en: Get two, or more than two, buffers; at least one of the previously sent packets
    gets split into several ones.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取两个或更多缓冲区；至少有一个之前发送的包被分割成几个。
- en: 'The entire process is happening asynchronously. But just like the socket client
    emits a `data` event, the parser can just emit its own `data` event when a complete
    packet gets parsed. The parser for parsing our tiny protocol may have only two
    states, corresponding to header (JSON byte length) and body (JSON bytes), and
    the emitting of the `data` event happens after successfully parsing the body:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程都是异步发生的。但是，就像套接字客户端会触发一个`data`事件一样，当解析器解析完一个完整的包后，它也可以触发自己的`data`事件。用于解析我们的小协议的解析器可能只有两个状态，对应于头部（JSON字节长度）和主体（JSON字节），并且`data`事件的触发发生在成功解析主体之后：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Due to the limitation of length, I'm not going to put the complete implementation
    of the parser here. For the complete code, please refer to the file `src/event-based-parser.ts`
    in the code bundle of [Chapter 7](ch07.html "Chapter 7. Patterns and Architectures
    in JavaScript and TypeScript"), *Patterns and Architectures in JavaScript and
    TypeScript*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于长度限制，我无法在这里放置解析器的完整实现。对于完整的代码，请参阅[第7章](ch07.html "第7章。JavaScript和TypeScript中的模式和架构")代码包中的`src/event-based-parser.ts`文件，*JavaScript和TypeScript中的模式和架构*。
- en: 'Thus the use of such a parser could be as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这样的解析器的使用方法如下：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed some interesting ideas and an architecture formed
    by those ideas. Most of the topics focus on a small scope and do their own job,
    but there are also ideas about putting a whole system together.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些有趣的想法和由这些想法形成的架构。大多数主题都集中在小范围内，并完成自己的任务，但也有一些想法是将整个系统组合起来。
- en: The code that implements techniques such as expected error and the approach
    to managing modules in a project is not hard to apply. But with proper application,
    it can bring notable convenience to the entire project.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实现诸如预期错误和项目模块管理方法等技术所需的代码并不难应用。但是，如果应用得当，它可以为整个项目带来显著的便利。
- en: However, as I have already mentioned at the beginning of this chapter, there
    are too many beautiful things in JavaScript and TypeScript to be covered or even
    mentioned in a single chapter. Please don't stop here, and keep exploring.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我在本章开头已经提到的，JavaScript和TypeScript中有太多美好的事物无法在一个章节中涵盖或提及。请不要在这里停止，继续探索。
- en: Many patterns and architectures are the result of some fundamental principles
    in software engineering. Those principles might not always be applicable in every
    scenario, but they may help when you feel confused. In the next chapter, we are
    going to talk about SOLID principles in object-oriented design and find out how
    those principles may help form a useful pattern.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模式和架构是软件工程中一些基本原理的结果。这些原理可能并不总是适用于每个场景，但当你感到困惑时，它们可能会有所帮助。在下一章中，我们将讨论面向对象设计中的SOLID原则，并找出这些原则如何帮助形成有用的模式。
