- en: 'Chapter 10. The App: Consuming Tweets Via Web Workers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：应用：通过Web Workers消费推文
- en: Up until now, JavaScript has been single-threaded. With a slow-running or lengthy
    process, everything on your page could come to a screeching halt waiting for something
    to finish. So far you could use AJAX or even `setTimeout` to delegate your tasks;
    however, neither of these solutions allows for real parallel execution and handling
    state gets pretty messy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，JavaScript一直是单线程的。对于运行缓慢或耗时的过程，页面上的所有内容都可能因为等待某个任务完成而突然停止。到目前为止，你可以使用AJAX甚至`setTimeout`来委托任务；然而，这些解决方案都不允许真正的并行执行，处理状态变得相当混乱。
- en: To make up for this deficiency, the HTML5 specification introduces Web Workers.
    Web Workers allow you to create non-user oriented background threads that can
    run simultaneously. They are typically meant for computationally heavy tasks.
    However, for our MovieNow enterprise application, we will use Web Workers to find
    tweets near a theater and display them. Although not necessarily computationally
    heavy, Web Workers can be useful to update the state of multiple elements on a
    page without interrupting the overall user experience (notice that there is still
    generally only a single UI-rendering thread).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弥补这一不足，HTML5规范引入了Web Workers。Web Workers允许你创建非用户导向的后台线程，它们可以同时运行。它们通常用于计算密集型任务。然而，对于我们的MovieNow企业应用，我们将使用Web
    Workers来查找剧院附近的推文并显示它们。尽管不一定计算密集，但Web Workers在更新页面上的多个元素状态时非常有用，而不会打断整体的用户体验（请注意，通常只有一个UI渲染线程）。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Getting the data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据
- en: Capturing geocodes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获地理编码
- en: Anatomy of a Web Worker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页工作线程的结构
- en: Using Web Workers to get nearby tweets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Web Workers获取附近的推文
- en: Updating the event listener
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新事件监听器
- en: Styling the tweets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推文的样式
- en: Getting the data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据
- en: 'To start us out, let us create an endpoint for querying the Twitter REST API
    and returning tweets near a specified geocode. At the root of the application,
    create a PHP file called `nearbytweets.php`. Open it and paste in the following
    code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们创建一个查询Twitter REST API并返回指定地理编码附近推文的端点。在应用程序的根目录下创建一个名为`nearbytweets.php`的PHP文件。打开它并粘贴以下代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a simple page that takes two parameters: latitude and longitude. It
    then queries the Twitter REST API 1.1 as defined in [https://dev.twitter.com/docs/api/1.1](https://dev.twitter.com/docs/api/1.1).
    It returns JSON data containing tweets originating from within 0.25 miles from
    the specified latitude and longitude.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的页面，它接受两个参数：纬度和经度。然后它查询Twitter REST API 1.1，如[https://dev.twitter.com/docs/api/1.1](https://dev.twitter.com/docs/api/1.1)中定义的。它返回包含来自指定纬度和经度0.25英里范围内的推文的JSON数据。
- en: Capturing geocodes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获地理编码
- en: Now that we have a place to get data, we will need to capture the latitude and
    longitude of each theater to send to our new endpoint. In `movienow.geolocation.js`,
    we will make a minor modification. In the `displayShowtimes` method, we will need
    to adjust where the theater name is displayed. Specifically, we will need to input
    the latitude and longitude and add them to a new `data` attribute. This allows
    us to use this data later on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了获取数据的地方，我们需要捕获每个剧院的纬度和经度以发送到我们的新端点。在`movienow.geolocation.js`中，我们将进行一些小的修改。在`displayShowtimes`方法中，我们需要调整剧院名称的显示位置。具体来说，我们需要输入纬度和经度并将它们添加到一个新的`data`属性中。这允许我们稍后使用这些数据。
- en: 'Change the following line:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更改以下行：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Change it to:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will create a new JavaScript file called `movienow.nearbytweets.js`
    in the `js` folder. In `index.php`, we will add a reference to the new JavaScript
    file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`js`文件夹中创建一个名为`movienow.nearbytweets.js`的新JavaScript文件。在`index.php`中，我们将添加对新JavaScript文件的引用：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `movienow.nearbytweets.js`, we will start with some boilerplate code. Add
    the following to set up the `nearbytweets` namespace within `movienow`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`movienow.nearbytweets.js`中，我们将从一些模板代码开始。向`movienow`中设置`nearbytweets`命名空间添加以下代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Anatomy of a Web Worker
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页工作线程的结构
- en: To really understand Web Workers, imagine a work-at-home business where households
    are sent packages of promotions and envelopes. Each household is to stuff the
    envelopes with the promotional literature, seal the envelopes, and send them as
    a parcel back to the originating business. The work-at-home households know nothing
    about the internals of the business. They merely know they are given a parcel,
    they must do something with the parcel, and they must return the parcel.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解 Web Workers，可以想象一个在家工作的业务，其中家庭被发送包含促销材料和信封的包裹。每个家庭都需要将促销材料装入信封，密封信封，并将包裹作为包裹送回原始业务。在家工作的家庭对业务的内部情况一无所知。他们只知道他们被给予了一个包裹，他们必须对包裹进行处理，并且他们必须将包裹送回。
- en: Web Workers run in an isolated thread wherein they know nothing about the state
    of the page that invokes them. They are simply sent a message, they do something
    with that message, and then return a message. The calling procedure specifies
    an event listener that responds when a message is returned by a Web Worker.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers 在一个隔离的线程中运行，它们对调用它们的页面状态一无所知。它们只是接收一条消息，对这条消息进行处理，然后返回一条消息。调用程序指定了一个事件监听器，当
    Web Worker 返回消息时，该监听器会做出响应。
- en: 'There are two types of Web Workers. They are:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers 有两种类型。它们是：
- en: '**Dedicated Web Workers**: They are sometimes referred to as just Web Workers.
    They are only reachable by the script that created them, although message ports
    can be used to communicate with other contexts.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专用 Web Workers**：有时它们也被称为 Web Workers。它们只能通过创建它们的脚本访问，尽管可以使用消息端口与其他上下文进行通信。'
- en: '**Shared Web Workers**: They are named and share a global scope, so any script
    running in the same origin can obtain a reference of this kind of worker.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享 Web Workers**：它们有名称并且共享全局作用域，因此任何在同一源运行的脚本都可以获取此类工作者的引用。'
- en: 'In this case, we will use Dedicated Web Workers. Web Workers are typically
    defined in a separate JavaScript file. To create a Web Worker, you simply need
    to instantiate it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用专用 Web Workers。Web Workers 通常在单独的 JavaScript 文件中定义。要创建一个 Web Worker，你只需实例化它：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once created, you can communicate with a Web Worker by using the `postMessage`
    method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，你可以通过使用 `postMessage` 方法与 Web Worker 进行通信：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To receive communications back from the Web Worker, simply define an event
    listener that triggers based on the `onmessage` event:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Web Worker 接收通信，只需定义一个基于 `onmessage` 事件触发的事件监听器：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Web Worker can then be defined as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Web Worker 可以定义为以下内容：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It basically has an event listener defined for incoming messages. As messages
    arrive, it executes the function attached to the message event and returns it
    by using the `postMessage` method in much the same way it was invoked. The event
    listener on the client side is invoked and everyone goes on their merry way.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上定义了一个用于接收消息的事件监听器。随着消息的到来，它执行附加到消息事件的函数，并通过使用 `postMessage` 方法返回它，这与它的调用方式非常相似。客户端的事件监听器被调用，然后大家继续各自的道路。
- en: 'If an error does occur in a Web Worker, the exception can be handled by listening
    to the error event on the Web Worker:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Web Worker 中发生错误，可以通过监听 Web Worker 上的错误事件来处理异常：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is important to note that the Web Worker exists in a sandbox. It is not accessing
    the state of the page at all. Instead, anything it receives will always be a copy
    of what was sent. Event referenced JavaScript libraries are not available. In
    fact, the DOM, the `window`, the `document`, and the `parent` objects are unavailable,
    so you cannot do any manipulation of or reading from the DOM or make use of the
    `window` object in a Web Worker. You are a completely separate household.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Web Worker 处于一个沙盒中。它根本不访问页面的状态。相反，它接收到的任何内容都将始终是发送内容的副本。事件引用的 JavaScript
    库不可用。实际上，DOM、`window`、`document` 和 `parent` 对象都不可用，因此在 Web Worker 中无法进行任何 DOM
    操作或读取，也无法使用 `window` 对象。你是一个完全独立的家庭。
- en: You can however use the `navigator` object, make use of the `XMLHttpRequest`
    object, and spawn other Web Workers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用 `navigator` 对象，利用 `XMLHttpRequest` 对象，并启动其他 Web Workers。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Nested workers must be hosted within the same origin as the parent document.
    Moreover, the URIs for nested workers are resolved relative to the parent worker's
    location rather than the owning document.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套工作者必须托管在与父文档相同的源中。此外，嵌套工作者的 URI 是相对于父工作者的位置解析的，而不是拥有文档的位置。
- en: You can also import scripts using the `importScripts` method as well as use
    `setTimeout` and `setInterval`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `importScripts` 方法导入脚本，以及使用 `setTimeout` 和 `setInterval`。
- en: Using Web Workers to get nearby tweets
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Web Workers 获取附近的推文
- en: 'In `movienow.nearbytweets.js`, we are going to define a couple of methods.
    First of all, let us define an entry point method for getting tweets:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `movienow.nearbytweets.js` 中，我们将定义几个方法。首先，让我们定义一个获取推文的入口点方法：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we have added this, we can invoke it from `movienow.geolocation.js` at
    the very end of the `displayShowtimes` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此方法后，我们可以在 `movienow.geolocation.js` 的 `displayShowtimes` 方法的最后调用它：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far, so good, but we are not doing anything yet. Let us add a new method
    to `movienow.nearbytweets.js` called `getTweetsByTheater`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但我们还没有做任何事情。让我们在 `movienow.nearbytweets.js` 中添加一个新的方法，名为 `getTweetsByTheater`：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The new `getTweetsByTheater` method will take a "theater" element and get tweets
    for it. What we mean by a "theater" element in this case is a `div` tag of the
    `theater` class as defined in `movienow.geolocation.js`. We will then invoke it
    from the `getTweets` method using a simple jQuery call. Augment `getTweets` as
    follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `getTweetsByTheater` 方法将接受一个 "theater" 元素并获取其推文。在这种情况下，我们所说的 "theater" 元素是指
    `movienow.geolocation.js` 中定义的 `theater` 类的 `div` 标签。然后我们将通过简单的 jQuery 调用从 `getTweets`
    方法中调用它。如下增强 `getTweets`：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now onto the meat of our script. We will instantiate our Web Worker. Let us
    start by adding a skeleton of the Web Worker mechanism. Add the following to the
    `getTweetsByTheater` method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入脚本的核心部分。我们将实例化我们的 Web Worker。让我们首先添加 Web Worker 机制的框架。将以下内容添加到 `getTweetsByTheater`
    方法中：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To finish out the skeleton, we will add a new JavaScript file called `movienow.worker.js`
    to the `js` folder. Add the following code snippet to it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成框架，我们将在 `js` 文件夹中添加一个新的 JavaScript 文件，名为 `movienow.worker.js`。将以下代码片段添加到其中：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have our initial skeleton of the Web Worker set, let us extract
    the geocode from the theater object passed into `getTweetsByTheater` and pass
    it along to the Web Worker. We will take the `data-location` attribute we added
    earlier in `movienow.geolocation.js` and parse out the latitude and longitude.
    Replace the skeleton `worker.postMessage()` invocation with the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 Web Worker 的初始框架，让我们从传递给 `getTweetsByTheater` 的剧院对象中提取地理编码，并将其传递给
    Web Worker。我们将使用之前在 `movienow.geolocation.js` 中添加的 `data-location` 属性并解析出纬度和经度。用以下代码替换
    `worker.postMessage()` 调用的框架：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we are passing the latitude and longitude to the Web Worker, let us
    update it to invoke the service we implemented at the beginning of this chapter.
    Add the following to the body of the event listener in `movienow.worker.js`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将经纬度传递给 Web Worker，让我们更新它以调用本章开头实现的该服务。将以下内容添加到 `movienow.worker.js` 的事件监听器主体中：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that we are using `XMLHttpRequest`. Normally, we would use the jQuery
    `ajax` method to make such a call. However, since jQuery has dependencies on the
    DOM and—as you may recall—the DOM is not available in this context, we cannot
    use it here. Instead, we will have to invoke the object directly and make the
    request. Once the AJAX request is made and the `onreadystatechange` event is triggered,
    the payload is passed back to the client via `self.postMessage()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用 `XMLHttpRequest`。通常，我们会使用 jQuery 的 `ajax` 方法来执行此类调用。然而，由于 jQuery 依赖于
    DOM，并且——如您所回忆的那样——在这个上下文中 DOM 不可用，所以我们不能使用它。相反，我们必须直接调用该对象并发出请求。一旦发出 AJAX 请求并触发
    `onreadystatechange` 事件，负载将通过 `self.postMessage()` 返回给客户端。
- en: 'The complete `movienow.worker.js` code should look similar to the following
    code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `movienow.worker.js` 代码应类似于以下代码片段：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'It is possible to implement Web Workers without creating a separate worker
    file. You can check out a tutorial on implementing this technique at the following
    location: [http://www.html5rocks.com/en/tutorials/workers/basics/#toc-inlineworkers](http://www.html5rocks.com/en/tutorials/workers/basics/#toc-inlineworkers)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在不创建单独的 worker 文件的情况下实现 Web Workers。您可以在以下位置查看有关实现此技术的教程：[http://www.html5rocks.com/en/tutorials/workers/basics/#toc-inlineworkers](http://www.html5rocks.com/en/tutorials/workers/basics/#toc-inlineworkers)
- en: Updating the event listener
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新事件监听器
- en: 'Going back to `movienow.nearbytweets.js`, we can update the event listener
    to take the JSON object returned from the Web Worker. If you look at the following
    code that we will add to the event listener body, you will see that we get the
    returned data and loop through the result set to capture the text of each tweet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `movienow.nearbytweets.js`，我们可以更新事件监听器以接收 Web Worker 返回的 JSON 对象。如果您查看我们将添加到事件监听器主体的以下代码，您将看到我们获取返回的数据并遍历结果集以捕获每条推文的文本：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that we defined the `objectifyJSON` function in previous chapters inside
    `movienow.geolocation.js`. It returns the same input if the parameter passed is
    an object and parses the content and returns an object if it is a string.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们在之前的章节中在 `movienow.geolocation.js` 内定义了 `objectifyJSON` 函数。如果传入的参数是对象，它返回相同的输入；如果它是一个字符串，它解析内容并返回一个对象。
- en: 'Here we are doing two things. First, we are appending a tweet count to the
    theater name (notice that we verify the number of tweets to add a singular **tweet**
    or plural **tweets** label). Secondly, we are adding a `section` element containing
    an unordered list of tweets. The target behavior is that we click on the tweet
    count and display the tweets. In addition, we will need to add two more methods
    to the `nearbytweets` object to show and hide the tweets:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们做了两件事。首先，我们在剧院名称旁边添加了一个推文计数（注意我们验证推文数量以添加单数 **tweet** 或复数 **tweets** 标签）。其次，我们添加了一个包含推文无序列表的
    `section` 元素。目标是点击推文计数并显示推文。此外，我们还需要向 `nearbytweets` 对象添加两个更多的方法来显示和隐藏推文：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The complete `movienow.nearbytweets.js` code should look like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `movienow.nearbytweets.js` 代码应如下所示：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Before we go on, we need to make one more modification to `movienow.geolocation.js`.
    Because we are mimicking the same behavior as the info and ratings buttons, we
    will need to make sure we are hiding and showing these in conjunction with the
    nearby tweets section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要对 `movienow.geolocation.js` 进行一次修改。因为我们正在模仿信息和评分按钮的行为，我们需要确保我们与附近的推文部分一起隐藏和显示这些内容。
- en: 'Change the `showCharts` method by changing the following line:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改以下行来更改 `showCharts` 方法：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will change it to:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其改为：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Change the `showDetails` method by changing the following line:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改以下行来更改 `showDetails` 方法：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Change it to:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 改为：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Styling the tweets
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为推文添加样式
- en: Now that the mechanics are set up for retrieving and loading nearby tweets,
    we will need to add some styles to make everything look complete. First, we will
    need to add the same treatment for the new nearby-tweets section as we have for
    the description and charting sections. We will do this by modifying the following
    lines in `styles.css`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经为检索和加载附近的推文设置了机制，我们需要添加一些样式来使一切看起来完整。首先，我们需要为新附近的推文部分添加与描述和图表部分相同的处理。我们将通过修改
    `styles.css` 中的以下行来实现这一点。
- en: 'Look for the following line:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找以下行：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Change it by adding a selector for `nearby-tweets`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `nearby-tweets` 选择器来更改：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Likewise, look for the following line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，寻找以下行：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Change it by adding a selector for `nearby-tweets`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `nearby-tweets` 选择器来更改：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now add the following code to `styles.css`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下代码添加到 `styles.css`：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the styles in place, we can test out our behavior by previewing our changes.
    You should see the following when the data loads:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式就绪后，我们可以通过预览我们的更改来测试我们的行为。当数据加载时，您应该看到以下内容：
- en: '![Styling the tweets](img/5689_10_01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![为推文添加样式](img/5689_10_01.jpg)'
- en: 'Notice **(18 tweets)** next to the theater name. It is the result of the Web
    Worker''s efforts. If you click on it, you should see the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意剧院名称旁边的 **(18 tweets)**。这是 Web Worker 的成果。如果您点击它，您应该看到以下内容：
- en: '![Styling the tweets](img/5689_10_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![为推文添加样式](img/5689_10_02.jpg)'
- en: If all goes well, the nearby tweets section should open, revealing the latest
    tweets that were posted near the theater's location.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，附近的推文部分应该会打开，显示在剧院位置附近发布的最新推文。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We walked through the anatomy of a Web Worker, how to set one up, and how it
    can be used to solve problems without disaffecting the user experience. Although
    a contrived example, we stepped through how to use Web Workers to get tweets near
    a theater based on its geocode.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了 Web Worker 的结构，如何设置它，以及它如何在不影响用户体验的情况下解决问题。虽然这是一个虚构的例子，但我们逐步展示了如何使用 Web
    Workers 根据剧院的地理编码获取附近的推文。
- en: 'Some real world use cases for Web Workers include:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers 的实际应用案例包括：
- en: Processor-intensive calculations that should not block the general enterprise
    application flow
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该不会阻塞一般企业应用流程的处理器密集型计算
- en: Auto-correction and syntax highlighting
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动纠错和语法高亮
- en: Posting images to a message queue
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图片发布到消息队列
- en: Consuming data in parallel using concurrent AJAX requests
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发 AJAX 请求并行处理数据
- en: In the next chapter, we will walk through debugging applications. We will cover
    tools available at our disposal to get under the hood and figure out what is happening
    in our enterprise applications. We will also cover some powerful techniques using
    proxies to sniff out problems as they occur.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨调试应用程序。我们将介绍我们可用的工具，以便深入了解并找出我们的企业应用程序中正在发生的事情。我们还将介绍一些使用代理来嗅探问题的强大技术。
