- en: The Age of Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务时代
- en: Decades ago, more specifically in 1974, Intel introduced 8080 to the world,
    which is an 8-bit processor with a 2 MHz clock speed and 64 KB of memory. This
    processor was used in Altair and began the revolution in personal computers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数十年前，具体来说是在1974年，英特尔向世界推出了8080，这是一款2兆赫时钟速度和64KB内存的8位处理器。这款处理器被用于Altair，并开始了个人计算机的革命。
- en: It was sold pre-assembled or as a kit for hobbyists. It was the first computer
    to have enough power to actually be used for calculations. Even though it had
    some poor design choices and needed an engineering major to be able to use and
    program it, it started the spread of personal computers to the general public.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以预先组装出售，也可以作为爱好者的套件出售。这是第一台真正有足够力量用于计算的计算机。尽管它有一些设计上的缺陷，并且需要工程专业的知识才能使用和编程，但它开始了个人计算机向公众普及的传播。
- en: The technology evolved rapidly and the processor industry followed Moore's law,
    almost doubling speed every two years. Processors were still single core, with
    a low-efficiency ratio (power consumption per clock cycle). Because of this, servers
    usually did one specific job, called a service, like serving HTTP pages or managing
    a **Lightweight Directory Access Protocol** (**LDAP**) directory. Services were
    the monolith, with very few components, and were compiled altogether to be able
    to take the most out of the hardware processor and memory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 技术迅速发展，处理器行业遵循摩尔定律，几乎每两年速度翻一番。处理器仍然是单核，效率比（每时钟周期的功耗）较低。因此，服务器通常只做一项特定的工作，称为服务，例如提供HTTP页面或管理**轻量级目录访问协议**（**LDAP**）目录。服务是单体，组件非常少，全部编译在一起以充分利用硬件处理器和内存。
- en: 'In the 90s, the internet was still only available for the few. Hypertext, based
    on HTML and HTTP, was in its infancy. Documents were simple and browsers developed
    language and protocol as they pleased. Competition for market share was ferocious
    between Internet Explorer and Netscape. The latter introduced JavaScript, which
    Microsoft copied as JScript:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在90年代，互联网仍然只为少数人可用。基于HTML和HTTP的超文本还处于婴儿期。文档很简单，浏览器根据需要开发语言和协议。在Internet Explorer和Netscape之间，市场份额的竞争非常激烈。后者引入了JavaScript，微软将其作为JScript复制：
- en: '![](img/e38df4a8-338d-4077-b40f-ec079f5ad490.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e38df4a8-338d-4077-b40f-ec079f5ad490.png)'
- en: Simple single-core servers
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的单核服务器
- en: After the turn of the century, processor speed continued to increase, memory
    grew to generous sizes, and 32-bit became insufficient for allocating memory addresses.
    The all-new 64-bit architecture appeared and personal computer processors hit
    the 100 W consumption mark. Servers gained muscle and were able to handle different
    services. Developers still avoided breaking the service into parts. Interprocess
    communication was considered slow and services were kept in threads, inside a
    single process.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 进入新世纪后，处理器速度继续提高，内存增长到宽敞的尺寸，32位对于分配内存地址来说已经不足。全新的64位架构出现，个人计算机处理器达到100瓦的功耗。服务器变得更加强壮，能够处理不同的服务。开发者仍然避免将服务拆分成部分。进程间通信被认为速度慢，服务保持在单个进程的线程中。
- en: The internet was starting to become largely available. Telcos started offering
    triple play, which included the internet bundled with television and phone services.
    Cellphones became part of the revolution and the age of the smartphone began.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网开始变得广泛可用。电信公司开始提供三合一服务，包括互联网捆绑电视和电话服务。手机成为革命的一部分，智能手机时代开始了。
- en: JSON appeared as a subset of the JavaScript language, although it's considered
    a language-independent data format. Some web services began to support the format.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JSON作为JavaScript语言的一个子集出现，尽管它被认为是一种与语言无关的数据格式。一些网络服务开始支持这种格式。
- en: The following is an example of servers with a couple of services running, but
    still having only one processor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个运行了几个服务但仍然只有一个处理器的服务器的示例。
- en: '![](img/dd8fac4c-1cd8-47af-9711-192faa7cdedf.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd8fac4c-1cd8-47af-9711-192faa7cdedf.png)'
- en: Powerful but single-core servers
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 强大但单核的服务器
- en: Processor evolution then shifted. Instead of the increased speed that we were
    used to, processors started to appear with two cores, and then four cores. Eight
    cores followed, and it seemed the evolution of the computer would follow this
    path for some time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的发展随后发生了转变。不再是我们所习惯的速度增加，处理器开始出现双核，然后是四核。随后是八核，似乎计算机的发展将遵循这条路径一段时间。
- en: This also meant a shift in architecture in the development paradigms. Relying
    on the system to take advantage of all processors is unwise. Services started
    to take advantage of this new layout and now it's common to see services having
    at least one processor per core. Just look at any web server or proxy, such as
    Apache or Nginx.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着在开发范式中的架构转变。依赖系统利用所有处理器是不明智的。服务开始利用这种新的布局，现在常见的是每个服务至少有一个处理器。只需看看任何网络服务器或代理，如Apache或Nginx。
- en: The internet is now widely available. Mobile access to the internet and its
    information corresponds to more or less half of all internet access.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网现在广泛可用。移动访问互联网及其信息大约占所有互联网访问的一半左右。
- en: In 2012, the **Internet Engineering Task Force** (**IETF**) began its first
    drafts for the second version of HTTP or HTTP/2, and **World Wide Web Consortium**
    (**W3C**) did the same for HTML/HTML5, as both standards were old and needed a
    remake. Thankfully, browsers agreed on merging new features and specifications
    and developers no longer have the burden of developing and testing their ideas
    on the different browser edge cases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年，**互联网工程任务组**（**IETF**）开始为其第二个版本HTTP或HTTP/2的第一份草案，**万维网联盟**（**W3C**）也做了同样的事情，因为这两个标准都很旧，需要重做。幸运的是，浏览器同意合并新功能和规范，开发者不再需要在不同的浏览器边缘情况上开发和测试他们的想法。
- en: 'The following is an example of servers with more services running as we reach
    a point where each server has more than one processor:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了随着每个服务器拥有超过一个处理器，服务数量增加的情况：
- en: '![](img/d535ce61-66e6-4f4c-865e-af2ef9e9725b.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d535ce61-66e6-4f4c-865e-af2ef9e9725b.png)'
- en: Powerful multi-core servers
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的多核服务器
- en: Access to information in real time is a growing demand. The **Internet of Things**
    (**IoT**) multiplies the number of devices connected to the internet. People now
    have a couple of devices at home, and the number will just keep rising. Applications
    need to be able to handle this growth.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实时获取信息的需求正在增长。**物联网**（**IoT**）增加了连接到互联网的设备数量。现在人们在家中有几台设备，数量还将持续增长。应用程序需要能够处理这种增长。
- en: On the internet, HTTP is the standard protocol for communication. Routers usually
    do not block it, as it is considered a low traffic protocol (in contrast with
    video streams). This is actually not true nowadays, but it's now so widely used
    that changing this behavior would probably cause trouble.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，HTTP是通信的标准协议。路由器通常不会阻止它，因为它被认为是一种低流量协议（与视频流相比）。实际上，现在并非如此，但它现在被广泛使用，改变这种行为可能会引起麻烦。
- en: Nowadays, it's actually so common to have the HTTP serving developer API working
    with JSON that most programming languages that release any version after 2015
    probably support this data format natively.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用HTTP服务开发API并与JSON一起工作实际上非常普遍，以至于大多数在2015年之后发布任何版本的编程语言可能都原生支持这种数据格式。
- en: As a consequence of processor evolution, and because of the data-demanding internet
    we now have, it's important to not only be able to scale a service or application
    to the several available cores, but also to scale outside a single hardware machine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理器的发展，以及我们现在拥有的数据需求驱动的互联网，不仅能够将服务或应用程序扩展到多个可用核心，而且还要能够扩展到单个硬件机器之外，这一点非常重要。
- en: Many developers started using and following the **Service-Oriented Architecture** (**SOA**)
    principle. It's a principle where the architecture is focused on services, and
    each service presents itself to others as an application component and provides
    information to other application components, passing messages over some standard
    communication protocol.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者开始使用并遵循**面向服务架构**（**SOA**）原则。这是一个将架构重点放在服务上的原则，每个服务将自己呈现为应用程序组件，并向其他应用程序组件提供信息，通过某些标准通信协议传递消息。
- en: From monolith to microservices
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单体到微服务
- en: As we described previously, a microservices architecture is based on a loosely
    coupled set of services that work together to achieve a specific target application.
    At the end of the spectrum, there are monolith applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所描述的，微服务架构基于一组松散耦合的服务，这些服务共同工作以实现特定的目标应用程序。在光谱的另一端，有单体应用程序。
- en: A monolith application is composed of a set of components that are tightly coupled.
    These components are usually developed using the same language and the application
    runs as a whole. The first noticeable difference is probably the slow start. Deploying
    might also be slow since you might need a couple of dependencies before having
    anything up and running.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用由一组紧密耦合的组件组成。这些组件通常使用相同的语言开发，并且整个应用作为一个整体运行。第一个明显的区别可能是启动速度慢。部署也可能很慢，因为你可能需要一些依赖项才能使应用正常运行。
- en: Let's imagine an event application, a simple one, an application that lets users
    define events and be notified when those events are about to start.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个事件应用，一个简单的应用，一个允许用户定义事件并在事件即将开始时通知他们的应用。
- en: '![](img/893a307a-7fcd-4a7d-9639-5341fbfe5906.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/893a307a-7fcd-4a7d-9639-5341fbfe5906.png)'
- en: A monolith event application
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单体事件应用
- en: 'Let''s describe what the event application does:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下事件应用的功能：
- en: It allows users to register themselves and add events to a calendar
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许用户注册自己并将事件添加到日历中
- en: A few minutes before the event starts (that's what the **Scheduler** component
    is for), the users receive an email with the event information (that's the **SMTP**
    component)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件开始前几分钟（这就是**调度器**组件的作用），用户会收到包含事件信息的电子邮件（这就是**SMTP**组件）。
- en: Users can use the frontend interface or the **API** interface
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以使用前端界面或**API**接口
- en: Imagine the preceding application as being a monolith (the greyed out area on
    the right).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下前面的应用作为一个单体（右边的灰色区域）。
- en: Imagine that all four parts are part of the same process, even though they could
    be in separate threads. Imagine that the database is accessed directly across
    the application. Sound good?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这四个部分都是同一个过程的一部分，即使它们可以在不同的线程中。想象一下数据库是直接跨应用访问的。听起来不错？
- en: Well, it sounds terrible, perhaps not for a small application, but for a medium
    one, this would be a representation of chaos. Having a group of developers making
    new features or improvements would be a nightmare, and for new developers entering
    the group, it would take some time before having the base knowledge to make some
    changes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，听起来很糟糕，可能对于小型应用来说不是这样，但对于中型应用，这将是混乱的体现。有一组开发者制作新功能或改进将会是一场噩梦，而对于新加入的开发者来说，在能够进行一些更改之前需要一段时间来掌握基础知识。
- en: The first principle that you should follow is the **Don't Repeat Yourself**
    (**DRY**) principle. Avoiding multiple components from accessing a data source
    helps developers in the future. Later on, if there's a need to change the data
    source or part of its structure, it will be easier if only one component manipulates
    it. This is not always possible, but if it is possible, you should keep the data
    source access to a minimum.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该遵循的第一个原则是**不要重复自己**（**DRY**）原则。避免多个组件访问数据源有助于未来的开发者。稍后，如果需要更改数据源或其结构的一部分，如果只有一个组件操作它，将会更容易。这并不总是可能的，但如果可能的话，你应该将数据源访问限制在最小范围内。
- en: In our example, the API should probably have access, and all others should use
    the API.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，API可能应该有访问权限，而所有其他应用都应该使用API。
- en: '![](img/debed603-fdb0-4f0b-9c31-5fea32261ec8.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/debed603-fdb0-4f0b-9c31-5fea32261ec8.png)'
- en: A single service accessing a data source
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单一服务访问数据源
- en: 'We now have two services:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个服务：
- en: The API, which is the only service accessing the data source
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API，这是唯一访问数据源的服务
- en: The frontend, which is the user's interface to change the data source
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端，这是用户更改数据源的界面
- en: Although the frontend is used to manage events, it uses the API service to manipulate
    data sources. Besides having only one service managing data sources, it forces
    you to think of the API for external developers. It's a win-win.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前端用于管理事件，但它使用API服务来操作数据源。除了只有一个服务管理数据源外，它还迫使你为外部开发者考虑API。这是一个双赢的局面。
- en: There is still room for improvement. The **Frontend** could be in a separate
    service, allowing you to scale the interface according to user traffic, and have
    the other parts on separate services. **Scheduler** and **SMTP** are both candidates
    for separate services. **SMTP** should be thought of as a reusable service for
    other applications you might develop later on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有改进的空间。**前端**可以作为一个独立的服务，这样你可以根据用户流量扩展界面，并将其他部分放在独立的服务上。**调度器**和**SMTP**都是作为独立服务的候选者。**SMTP**应该被视为一个可重用的服务，用于你以后可能开发的其他应用。
- en: 'Let''s take a look at how we could build the same application using the microservices
    approach:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用微服务方法构建相同的应用程序：
- en: '![](img/034310f1-1917-4a3e-aa4e-0fba06ef39ea.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/034310f1-1917-4a3e-aa4e-0fba06ef39ea.png)'
- en: A microservices event application
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微服务事件应用
- en: 'It looks more complex. Well, the architecture is more complex. The difference
    is that now, we have loosely coupled components, and each one of them is easily
    understandable and maintainable. Summing up the changes and advantages:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来更复杂。好吧，架构更复杂。区别在于现在，我们有松耦合的组件，并且每个组件都易于理解和维护。总结这些变化和优势：
- en: The **API** is the only one accessing the database so it can change from SQLite,
    MongoDB, MySQL, or anything else, and no other component is affected
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API** 是唯一访问数据库的组件，因此它可以从 SQLite、MongoDB、MySQL 或其他任何东西改变，而不会影响其他组件'
- en: '**SMTP** can be used from the **Frontend** and **Scheduler**, and if you decide
    to change it from using a local service to using a third-party email sending **API**,
    you can make the change easily'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SMTP** 可以从 **前端** 和 **调度器** 使用，如果你决定从使用本地服务改为使用第三方电子邮件发送 **API**，你可以轻松地进行更改'
- en: '**SMTP** is a candidate for being a reusable service in other applications,
    meaning you can use it in other applications or event share the same service between
    multiple applications'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SMTP** 可以作为其他应用程序的可重用服务，这意味着你可以在其他应用程序中使用它，或者在不同应用程序之间共享相同的服务'
- en: You can think of these components as capabilities of your application. They
    can be swapped, upgraded, maintained, and scaled, all without affecting other
    components or your application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些组件视为你应用程序的能力。它们可以被交换、升级、维护和扩展，而不会影响其他组件或你的应用程序。
- en: A commonly underestimated advantage of using this approach is that your application
    is much more resilient to failures. In a monolith application, any part can bring
    your application offline. In this microservices approach, this application might
    not send emails but can still be running and accessible. Add caching into the
    mixture and the API can restart in moments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法的一个常被低估的优势是，你的应用程序对失败的抵抗能力要强得多。在单体应用程序中，任何部分都可能使你的应用程序离线。在这种微服务方法中，这个应用程序可能不会发送电子邮件，但仍然可以运行和访问。加入缓存到混合中，API可以在瞬间重新启动。
- en: Patterns of microservices
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务模式
- en: Microservices architecture, like other archicectures, has a set of patterns
    that are easily identifiable and form the basis for this application development
    approach.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构，就像其他架构一样，有一套易于识别的模式，构成了这种应用程序开发方法的基础。
- en: Some of these patterns can make the initial bootstrap a burden and can eventually
    be postponed. Others are essential from the beginning or you will have difficulty,
    later on, in migrating to a full microservice approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些模式可能会使初始引导变得负担，并且最终可以推迟。其他模式从一开始就是必需的，否则你将在以后迁移到完整的微服务方法时遇到困难。
- en: 'The following patterns are not an extensive list but they represent a solid
    foundation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模式并不是一个详尽的列表，但它们代表了一个坚实的基础：
- en: '![](img/c78fda11-0afc-49b7-a839-6acb6be49f58.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c78fda11-0afc-49b7-a839-6acb6be49f58.png)'
- en: An example of services working together to form an application
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 服务协同工作以形成应用程序的示例
- en: Decomposable
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可分解性
- en: The main pattern behind a microservice architecture is the ability to have loosely
    coupled services. These services are decomposed, separated into smaller parts.
    This decomposition should create a set of services that implement a set of strongly
    related functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构背后的主要模式是拥有松耦合的服务的能力。这些服务被分解，分成更小的部分。这种分解应该创建一组实现一组强相关功能的服务的集合。
- en: Each service should be small but complete, meaning it should run a set of functions
    in a given context. Those functions should represent all the functions you need
    or need to support for that context. What this means is that if you have a service
    that handles meeting events, all meeting event functions should be done using
    that service, whether it's creating an event, changing, removing, or getting information
    about a specific event. This ensures that an implementation change to events will
    affect that service only.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都应该小巧但完整，这意味着它应该在给定的上下文中运行一系列函数。这些函数应该代表你需要的所有函数或需要支持该上下文的函数。这意味着如果你有一个处理会议事件的服务，所有会议事件函数都应该使用该服务完成，无论是创建事件、更改、删除还是获取特定事件的详细信息。这确保了事件实现的更改只会影响该服务。
- en: 'Decomposing an application can take one of two main approaches:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解可以采用两种主要方法：
- en: By capability, when a service has a specific power or set of powers, such as
    sending emails, regardless of its content
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过能力，当一个服务具有特定的权力或一系列权力，例如发送电子邮件，无论其内容如何
- en: By subdomain, when a service has the complete knowledge of a subdomain or module
    of your application domain
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过子域，当一个服务拥有应用程序领域子域或模块的完整知识
- en: 'In our previous event application, a service that was decomposed by capability
    is, for example, the SMTP service. A service decomposed by the domain could be
    the API service, assuming the application only manages events:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的事件应用中，通过能力分解的服务，例如，是SMTP服务。通过领域分解的服务可能是API服务，假设应用程序只管理事件：
- en: '![](img/39cd716e-fc18-4160-bc96-9d49f3e99af8.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/39cd716e-fc18-4160-bc96-9d49f3e99af8.png)'
- en: An example of services being tested and deployed autonomously, instead of the
    whole application
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的测试和部署自主进行的例子，而不是整个应用程序
- en: Autonomous
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主
- en: In a microservice architecture, each service should be autonomous. A small team
    should be able to run it without the other services that make your application.
    That team should also be able to develop autonomously and make changes to implementation
    without affecting the application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务应该是自主的。一个小团队应该能够在没有其他服务的情况下运行它，这些服务构成了你的应用程序。该团队还应该能够自主开发并修改实现，而不会影响应用程序。
- en: 'The development team should be able to:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队应该能够：
- en: Test, creating business logic and unit tests to ensure the service functions
    work as expected
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试，创建业务逻辑和单元测试以确保服务功能按预期工作
- en: Deploy, upgrading functionality, without restarting other services in the process
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署，升级功能，在此过程中无需重启其他服务
- en: 'Services should be able to evolve regardless of others, keeping backward compatibility,
    adding new functions, and scaling to several locations, with minimal changes to
    the architecture:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 服务应该能够在不影响其他服务的情况下独立演进，保持向后兼容性，添加新功能，并在多个位置进行扩展，对架构的更改最小：
- en: '![](img/1dff5ae6-966b-4dbb-be33-8df99b86f0bb.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/1dff5ae6-966b-4dbb-be33-8df99b86f0bb.png)'
- en: An example of an application with two instances per service, making it fault-tolerant
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有每个服务两个实例的应用程序示例，使其具有容错能力
- en: Scalable
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展
- en: A service should be scalable. At least two instances should be able to run in
    parallel, enabling failure tolerance and maintenance downtime. A service can also,
    later on, scale geographically, be near your customers, and improve apparent performance
    and application response.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 服务应该是可扩展的。至少应该能够并行运行两个实例，以实现容错和减少维护停机时间。服务还可以在以后地理上扩展，靠近客户，提高性能和应用程序响应速度。
- en: For this scaling to be effective, the application platform will need service
    discovery and routing, a service that could be used by other services to register
    themselves and expose their capabilities. Other services could, later on, inquire
    this service directory and know how to reach these capabilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种扩展有效，应用程序平台将需要服务发现和路由，这是一种其他服务可以用来注册自己并公开其能力的服务。其他服务可以在以后查询这个服务目录，并了解如何到达这些能力。
- en: To reduce complexity for other services, a service router can redirect requests
    to service instances. For example, to send emails, you could have three instances
    and one central router that would redirect requests in a round-robin manner. If
    any of those instances go offline, the router will stop redirecting to it and
    the rest of the application doesn't need to care about it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少其他服务的复杂性，服务路由器可以将请求重定向到服务实例。例如，为了发送电子邮件，你可以有三个实例和一个中央路由器，它会以轮询方式重定向请求。如果其中任何一个实例离线，路由器将停止将其重定向，其余的应用程序也不需要关心它。
- en: 'Another approach could be to use a DNS approach. The name service is capable
    of handling registrations to a subdomain, and then, when another service makes
    simple requests, it will receive one or all of the addresses and connect it as
    if there was only one service operating:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能是使用DNS方法。名称服务能够处理对子域的注册，然后，当另一个服务进行简单请求时，它将收到一个或所有地址，并将其连接，就像只有一个服务在运行一样：
- en: '![](img/1fac72a0-5c63-4460-b7c0-70e529a6afc7.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/1fac72a0-5c63-4460-b7c0-70e529a6afc7.png)'
- en: An example of communication between services of an application
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务之间通信的一个例子
- en: Communicable
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可通信
- en: Usually, services communicate over HTTP using a REST-compliant API. This is
    not a pattern that you must follow, but it's something that comes naturally based
    on how common HTTP is nowadays, making it an obvious choice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务通过HTTP使用REST兼容的API进行通信。这不是你必须遵循的模式，但这是基于当今HTTP的普遍性自然而然产生的，使其成为显而易见的选择。
- en: There are plenty of HTTP servers out there, making it easy to expose a non-HTTP
    service with minimum effort.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多HTTP服务器，这使得以最小的努力公开非HTTP服务变得容易。
- en: 'HTTP is also a mature communication transport layer. It''s a stateless protocol,
    giving developers and operations many features, such as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP也是一个成熟的通信传输层。它是一个无状态的协议，为开发者和运营人员提供了许多功能，例如：
- en: Caching commonly used and often updated resources
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存常用且经常更新的资源
- en: Proxying and routing requests
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理和路由请求
- en: Securing communication over TLS
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TLS加密通信
- en: '![](img/3a5de26d-a878-480b-b568-3011eb16e22d.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a5de26d-a878-480b-b568-3011eb16e22d.png)'
- en: A complex application with several services and streams of communication
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个服务和通信流的复杂应用程序
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In conclusion, microservices architecture is a good, clear pattern that helps
    tackle more complex projects. In the long term, it reduces the complexity associated
    with new projects by appealing to service reuse. It helps to structure an application
    into loosely coupled services that can be independently developed and tested by
    small, different teams. It comes at the cost of initial proper planning and a
    more complex deployment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，微服务架构是一个良好、清晰的模式，有助于处理更复杂的项目。从长远来看，它通过吸引服务重用来降低与新产品相关的复杂性。它有助于将应用程序结构化为松散耦合的服务，这些服务可以由小型、不同的团队独立开发和测试。这需要初始的适当规划和更复杂的部署。
- en: Before creating your first microservice, let's look at some Node.js tools that
    could eventually help you leverage your next big project. This is what we'll be
    covering in the next chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建您的第一个微服务之前，让我们先看看一些可能最终帮助您利用下一个大型项目的Node.js工具。这就是我们将在下一章中要涵盖的内容。
