- en: Object-Oriented Programming with TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript进行面向对象编程
- en: 'In the previous chapter, we learned how to work with functions and how to take
    advantage of some asynchronous programming APIs. In this chapter, we are going
    to learn how to implement TypeScript applications using the **object-oriented
    programming** (**OOP**) paradigm. We are going to learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用函数以及如何利用一些异步编程API。在本章中，我们将学习如何使用**面向对象编程**（**OOP**）范式实现TypeScript应用程序。我们将学习以下主题：
- en: Classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Association, aggregation, and composition
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联、聚合和组合
- en: Inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Mixins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合
- en: Generic classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类
- en: Generic constraints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型约束
- en: Interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: The SOLID principles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID原则
- en: Classes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'We should already be familiar with the basics of TypeScript classes, as we
    have declared some of them in previous chapters. We will now look at some details
    and OOP concepts through examples. Let''s start by declaring a simple class:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该已经熟悉了TypeScript类的基础知识，因为我们已经在之前的章节中声明了一些。现在，我们将通过示例来查看一些细节和OOP概念。让我们从一个简单的类开始声明：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We use classes to represent the type of an object or entity. A **class** is
    composed of a name, **properties** (also known as **attributes**), and **methods**.
    Both methods and properties are known as **members**. Class properties are used
    to describe the object's characteristics, while class methods are used to describe
    its behavior.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类来表示对象或实体的类型。一个**类**由一个名称、**属性**（也称为**属性**）和**方法**组成。方法和属性都称为**成员**。类属性用于描述对象的特征，而类方法用于描述其行为。
- en: The class in the preceding example is named `Person` and contains three attributes
    or properties (`name`, `surname`, and `email`) and two methods (`constructor`
    and `greet`).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，该类名为`Person`，包含三个属性或属性（`name`、`surname`和`email`）和两个方法（`constructor`和`greet`）。
- en: 'A **constructor** is a special method used by the `new` keyword to create **instances**
    (also known as **objects**) of our class. We have declared a variable named `me`,
    which holds an instance of the `Person` class. The `new` keyword uses the `Person`
    class''s constructor to return an object whose type is `Person`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数**是`new`关键字用来创建我们类**实例**（也称为**对象**）的特殊方法。我们声明了一个名为`me`的变量，它持有`Person`类的实例。`new`关键字使用`Person`类的构造函数来返回一个类型为`Person`的对象：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Strict property initialization
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格的属性初始化
- en: 'Since the release of TypeScript 2.7, a compile-time error will be thrown if
    strict mode is enabled and we forget to initialize one of the properties of a
    class. For example, the following class initializes the property named `height`
    using a method, and the property named `width` using its constructor. TypeScript
    knows that if an instance of the class is created, a value will be assigned to
    the `width` property. However, it has no way to ensure that a value is assigned
    to the `height` property. If strict mode is enabled, an error will be thrown:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自TypeScript 2.7版本发布以来，如果启用了严格模式并且我们忘记初始化类的一个属性，将会抛出一个编译时错误。例如，以下类使用方法初始化名为`height`的属性，使用构造函数初始化名为`width`的属性。TypeScript知道如果创建类的实例，`width`属性将被分配一个值。然而，它没有方法来确保`height`属性被分配一个值。如果启用了严格模式，将会抛出一个错误：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can use the `!` operator to let TypeScript know that we don''t want an error
    to be thrown:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`!`运算符让TypeScript知道我们不想抛出错误：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is very common to encounter this compilation error when we define a class
    without a constructor:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个没有构造函数的类时，遇到这种编译错误是非常常见的：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use the `!` operator to solve the compile-time error when we don''t
    want to define a constructor:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`!`运算符解决我们不希望定义构造函数时的编译时错误：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, we can initialize the properties with a default value:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用默认值初始化属性：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inheritance
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: One of the most fundamental OOP features is its capability to extend existing
    classes. This feature is known as **inheritance** and allows us to create a new
    class (child class) that inherits all the properties and methods from an existing
    class (parent class). Child classes can include additional properties and methods
    that are not available in the parent class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的OOP特性之一是其扩展现有类的功能。这个特性被称为**继承**，它允许我们创建一个新的类（子类），该类从现有的类（父类）继承所有属性和方法。子类可以包含父类中不可用的额外属性和方法。
- en: 'We are going to use the `Person` class that we declared in the preceding section
    as the parent class of a child class named `Teacher`. We can extend the parent
    class (`Person`) by using the reserved keyword `extends`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在前一节中声明的`Person`类作为名为`Teacher`的子类的父类。我们可以通过使用保留关键字`extends`来扩展父类（`Person`）：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Teacher` class will inherit all the attributes and methods from its parent
    class. However, we have also added a new method named `teach` to the `Teacher` class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Teacher`类将继承其父类的所有属性和方法。然而，我们还在`Teacher`类中添加了一个名为`teach`的新方法。'
- en: 'If we create instances of the `Person` and `Teacher` classes, we will be able
    to see that both instances share the same attributes and methods except for the
    `teach` method, which is only available for the instance of the `Teacher` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建`Person`和`Teacher`类的实例，我们将能够看到这两个实例共享相同的属性和方法，除了`teach`方法，这个方法仅对`Teacher`类的实例可用：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Depth of the inheritance tree (DIT)
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承树深度（DIT）
- en: 'We can also declare a new class that inherits from a class, which is already
    inheriting from another class. In the following code snippet, we declare a class
    called `SchoolPrincipal` that `extends` the `Teacher` class, which extends the
    `Person` class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以声明一个新的类，它从已经从另一个类继承的类中继承。在以下代码片段中，我们声明了一个名为`SchoolPrincipal`的类，它`extends`了`Teacher`类，而`Teacher`类又继承自`Person`类：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we create an instance of the `SchoolPrincipal` class, we will be able to
    access all the properties and methods from its parent classes (`SchoolPrincipal`,
    `Teacher`, and `Person`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建`SchoolPrincipal`类的实例，我们将能够访问其父类（`SchoolPrincipal`、`Teacher`和`Person`）中的所有属性和方法：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is **not recommended to have too many levels in the inheritance tree**. A
    class situated too deeply in the inheritance tree will be relatively complex to
    develop, test, and maintain.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议在继承树中拥有太多层级。位于继承树较深位置的类将相对复杂，难以开发、测试和维护。
- en: Unfortunately, we don't have a specific rule that we can follow when we are
    unsure whether we should increase the **depth of the inheritance tree** (**DIT**).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当我们不确定是否应该增加**继承树深度**（**DIT**）时，我们没有一条具体的规则可以遵循。
- en: We should use inheritance in such a way that it helps us to reduce the complexity
    of our application and not the opposite. We should try to keep the DIT between
    zero and four because a value greater than four would compromise encapsulation
    and increase complexity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该以这种方式使用继承，以帮助我们减少应用程序的复杂性，而不是相反。我们应该尽量保持DIT在零到四之间，因为大于四的值将损害封装性并增加复杂性。
- en: Access modifiers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: TypeScript allows us to restrict the access to the properties and methods of
    a class using the `public`, `private`, and `protected` keywords.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许我们使用`public`、`private`和`protected`关键字来限制对类属性和方法访问。
- en: The public access modifier
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共访问修饰符
- en: 'If we use the `public` modifier, the method or property can be accessed by
    other objects. The following example redeclares the `Person` and `Teacher` classes
    that we have used in the preceding section. It is important to note that the `public`
    access modifier is used in all the properties of the class, but for this example,
    we are going to pay special attention to the property named `email`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`public`修饰符，方法或属性可以被其他对象访问。以下示例重新声明了我们在前一节中使用的`Person`和`Teacher`类。重要的是要注意，在类的所有属性中使用了`public`访问修饰符，但在这个例子中，我们将特别关注名为`email`的属性：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we create an instance of both the `Person` and `Teacher` classes, we will
    be able to confirm that the `email` property can be accessed by both instances
    and by an external object such as the `console` object:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建`Person`和`Teacher`类的实例，我们将能够确认`email`属性可以被这两个实例以及像`console`对象这样的外部对象访问：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The private access modifier
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有访问修饰符
- en: If we use the `private` modifier, the method or property can only be accessed
    by the object that owns them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`private`修饰符，方法或属性只能由拥有它们的对象访问。
- en: 'The following example redeclares, once more, the classes that we declared in
    the preceding example, but uses the `private` access modifier instead of the `public`
    modifier. The example also adds a couple of extra methods to the classes to demonstrate
    the implications of using a `private` access modifier:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例再次重新声明了我们在前一个示例中声明的类，但使用的是`private`访问修饰符而不是`public`修饰符。该示例还向类中添加了一些额外的方法，以展示使用`private`访问修饰符的影响：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we create an instance of both the `Person` and `Teacher` classes, we will
    be able to observe that the `getEmail` method, which belongs to the `Person` instance,
    can access the `private` property. However, the `private` property, `email`, cannot
    be accessed from the method named `shareEmail`, which is declared by the derived  `Teacher` class. Also,
    other objects (such as the `console` object) cannot access the `private` property.
    This code snippet confirms that the `email` property can only be accessed by the
    instances of the `Person` class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建`Person`和`Teacher`类的实例，我们将能够观察到属于`Person`实例的`getEmail`方法可以访问`private`属性。然而，`private`属性`email`不能从由派生类`Teacher`声明的名为`shareEmail`的方法中访问。此外，其他对象（如`console`对象）也不能访问`private`属性。此代码片段确认`email`属性只能由`Person`类的实例访问：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can update the `Teacher` class to use the public `getEmail` method instead
    of trying to access the `private` property directly:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`Teacher`类更新为使用公共的`getEmail`方法，而不是直接尝试访问`private`属性：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The protected access modifier
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`protected`访问修饰符'
- en: If we use the `protected` modifier, the method or property can only be accessed
    by the object that owns them or instances of the derived classes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`protected`修饰符，方法或属性只能被拥有它们的对象或派生类的实例访问。
- en: 'The following example declares, once more, the classes that we declared in
    the preceding examples, but uses the `protected` access modifier instead of the
    `public` modifier:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例再次声明了我们在前面示例中声明的类，但使用的是`protected`访问修饰符而不是`public`修饰符：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we create an instance of both the `Person` and `Teacher` classes, we will
    be able to observe that the `protected` property, `email`, can be accessed from
    the method named `shareEmail`, which is declared by the derived  `Teacher` class. However,
    other objects (such as the `console` object) cannot access the `private` property.
    This code snippet confirms that the `email` property can only be accessed by the
    instances of the `Person` class or derived classes, but it cannot be accessed
    by other objects:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建`Person`和`Teacher`类的实例，我们将能够观察到属于派生类`Teacher`的名为`shareEmail`的方法可以访问`protected`属性`email`。然而，其他对象（如`console`对象）不能访问`private`属性。此代码片段确认`email`属性只能由`Person`类或派生类的实例访问，但不能由其他对象访问：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Parameter properties
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数属性
- en: 'In TypeScript, when we declare a class, we can define its properties and initialize
    some or all of the properties using the class constructor:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，当我们声明一个类时，我们可以定义其属性，并使用类构造函数初始化一些或所有属性：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, we can use an alternative syntax, which allows us to declare the properties
    and initialize them using the class constructor in a less verbose way. We only
    need to remove the property declarations and its initialization, and add access
    modifiers to the arguments of the constructor of the class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用一种替代语法，它允许我们以更简洁的方式使用类构造函数声明属性并初始化它们。我们只需要移除属性声明及其初始化，并给类构造函数的参数添加访问修饰符。
- en: 'The preceding code snippet declares a class with an identical behavior to the
    following class. However, it uses the parameter properties syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段声明了一个与以下类具有相同行为的类。然而，它使用了参数属性语法：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Class expressions
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类表达式
- en: We can use two different APIs to declare a class. The first one is the class
    declaration syntax that we used during the preceding section. The second one is
    an alternative syntax known as a class expression.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种不同的API来声明一个类。第一个是我们前面部分使用的类声明语法。第二个是称为类表达式的替代语法。
- en: 'The following code snippet redeclares the `Person` class that we declared in
    the preceding section using the class expression syntax:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段重新声明了我们在前面部分声明的`Person`类，使用的是类表达式语法：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are no differences between the creation of an instance of a class declared
    using the class expression syntax and one declared using the class declaration
    syntax:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类表达式语法声明的类实例的创建和使用类声明语法声明的类实例之间没有区别：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Static members
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态成员
- en: 'We can use the `static` keyword to enable the usage properties and methods
    in a class without needing to create an instance of it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`static`关键字来启用类中无需创建其实例即可使用的属性和方法：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we can observe in the preceding code snippet, the `TemperatureConverter` class
    has two static methods named `CelsiusToFahrenheit` and `FahrenheitToCelsius`.
    We can invoke these methods without creating an instance of the `TemperatureConverter`
    class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，`TemperatureConverter` 类有两个名为 `CelsiusToFahrenheit` 和 `FahrenheitToCelsius`
    的静态方法。我们可以不创建 `TemperatureConverter` 类的实例就调用这些方法：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When a method or property is not static, we refer to it as an instance method
    or an instance property. It is possible to declare classes that have both static
    and instance methods or properties:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法或属性不是静态的，我们将其称为实例方法或实例属性。可以声明同时具有静态和实例方法或属性的类：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding class declares a vector in a 3D space. The vector class has instance
    methods to calculate the length of the vector and to normalize it (change its
    length to `1` without changing its direction). We can create instances of the
    class using the class constructor and the `new` keyword:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类在 3D 空间中声明了一个向量。向量类有实例方法来计算向量的长度并对其进行归一化（不改变其方向的情况下改变其长度为 `1`）。我们可以使用类构造函数和
    `new` 关键字创建类的实例：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, the class also has a static method named `GetDefault`, which can be
    used to create a default instance:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该类还有一个名为 `GetDefault` 的静态方法，可以用来创建一个默认实例：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Optional members
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选成员
- en: We can define optional class properties and methods by appending the `?` character
    at the end of the name of a property or method. This behavior is like the behavior
    that we observed in [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml), *Working
    with Functions,* when we learned how to use the `?` character to declare optional
    arguments in a function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在属性或方法名称的末尾附加 `?` 字符来定义可选类属性和方法。这种行为类似于我们在 [第 3 章](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml)
    “与函数一起工作” 中学习如何使用 `?` 字符在函数中声明可选参数时所观察到的行为。
- en: 'The following code snippet defines a class named `Vector` with an optional
    property named `z`. When we define a `Vector` instance using numeric values for
    the properties `x` and `y`, the `Vector` has two dimensions. When we define a
    `Vector` instance using numeric values for the properties `x`, `y`, and `z`, the
    `Vector` has three dimensions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段定义了一个名为 `Vector` 的类，其中有一个名为 `z` 的可选属性。当我们使用 `x` 和 `y` 属性的数值定义 `Vector`
    实例时，`Vector` 有两个维度。当我们使用 `x`、`y` 和 `z` 属性的数值定义 `Vector` 实例时，`Vector` 有三个维度：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following code snippet declares a `Vector` instance using only two constructor
    arguments. As a result, the optional property, `z`, will be `undefined`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段仅使用两个构造函数参数声明了一个 `Vector` 实例。因此，可选属性 `z` 将是 `undefined`：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following code snippet declares a `Vector` instance using three constructor
    arguments. As a result, the optional property, `z`, will be defined:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用三个构造函数参数声明了一个 `Vector` 实例。因此，可选属性 `z` 将被定义：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Read-only properties
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读属性
- en: The `readonly` keyword is a modifier that can be applied to the properties of
    a class. When a property declaration includes a `readonly` modifier, assignments
    to the property can only take place as part of the declaration or in a constructor
    in the same class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly` 关键字是一个可以应用于类属性的修饰符。当属性声明包含 `readonly` 修饰符时，对该属性的赋值只能作为声明的一部分或在同一类中的构造函数中进行。'
- en: 'The following example showcases how the `readonly` modifier prevents assignments
    to the  `x`, `y`, and `z` properties:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用 `readonly` 修饰符防止对 `x`、`y` 和 `z` 属性进行赋值：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can fix the compilation errors in the preceding code snippet by modifying
    the `normalize` method so that it returns a new vector (instead of modifying the
    original vector):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改 `normalize` 方法来修复前面代码片段中的编译错误，使其返回一个新的向量（而不是修改原始向量）：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Method overriding
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重写
- en: Sometimes, we will need a child class to provide a specific implementation of
    a method that is already provided by its parent class. We can use the reserved
    keyword `super` for this purpose.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要子类为其父类已提供的特定方法提供特定的实现。我们可以使用保留关键字 `super` 来实现这个目的。
- en: We are going to use, once more, the `Person` and `Teacher` classes declared
    during the *Inheritance* section in this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用本章 *继承* 部分中声明的 `Person` 和 `Teacher` 类。
- en: 'Imagine that we want to add a new attribute to list the teacher''s subjects,
    and we want to be able to initialize this attribute through the teacher constructor.
    We are going to use the `super` keyword to explicitly reference the parent class
    constructor inside the child class constructor:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要添加一个新的属性来列出教师的科目，并且我们希望能够通过教师构造函数初始化这个属性。我们将使用`super`关键字在子类构造函数中显式引用父类构造函数：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have also used the `super` keyword to extend an existing method, such as
    `greet`. This OOP language feature that allows a subclass or child class to provide
    a specific implementation of a method that is already provided by its parent classes
    is known as **method overriding**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`super`关键字来扩展一个现有方法，例如`greet`。这种面向对象编程语言特性允许子类或子类提供其父类已经提供的方法的特定实现，这被称为**方法重写**。
- en: 'At this point, we can create an instance of the `Person` and `Teacher` classes
    to observe their differences:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以创建`Person`和`Teacher`类的实例来观察它们之间的差异：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Generic classes
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类
- en: In the previous chapter, we learned how to work with generic functions. Now,
    we will look at how to work with generic classes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用泛型函数。现在，我们将探讨如何使用泛型类。
- en: 'Just like with generic functions, generic classes can help us to avoid the
    duplication of code. Let''s look at an example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像通用函数一样，通用类可以帮助我们避免代码的重复。让我们看看一个例子：
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have declared a class named `User` with two properties named `name` and
    `password`. We will now declare a class named `UserQueue`. A queue is a data structure
    that we can use to store a list of items. Items can be added at the end of the
    list and removed from the beginning of the list. For this reason, a queue is considered
    a **first-in-first-out** (**FIFO**) data structure. The `UserQueue` class doesn''t
    use generics:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了一个名为`User`的类，它有两个属性名为`name`和`password`。我们现在将声明一个名为`UserQueue`的类。队列是一种我们可以用来存储项目列表的数据结构。项目可以添加到列表的末尾，并从列表的开头删除。因此，队列被认为是一种**先进先出**（**FIFO**）的数据结构。`UserQueue`类不使用泛型：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Please note the array shift method removes the first element from an array and
    returns that removed element.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数组移位方法从数组中删除第一个元素并返回该删除的元素。
- en: 'Once we have finished declaring the `UserQueue` class, we can create an instance
    and invoke the `push` and `pop` methods to add and remove items, respectively:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了`UserQueue`类的声明，我们就可以创建一个实例并调用`push`和`pop`方法来分别添加和删除项目：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we also need to create a new queue with items of a different type, we could
    end up duplicating a lot of code that looks almost identical:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还需要创建一个包含不同类型项目的新的队列，我们可能会重复大量看起来几乎相同的代码：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the number of entities grows, we will continue to repeatedly duplicate code.
    We could use the `any` type to avoid this problem, but then we would be losing
    the type checks at compile time:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体的数量增加，我们将继续重复复制代码。我们可以使用`any`类型来避免这个问题，但这样我们就会在编译时丢失类型检查：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A much better solution is to create a generic queue:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是创建一个泛型队列：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The generic queue code is identical to `UserQueue` and `CarQueue`, except for
    the type of the `items` property. We have replaced the hardcoded reference to
    the `User` and `Car` entities and replaced them with the generic type `T`. We
    can now declare as many kinds of queues as we might need without duplicating a
    single line of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型队列代码与`UserQueue`和`CarQueue`相同，除了`items`属性的类型。我们用硬编码的`User`和`Car`实体替换了它们，并用泛型类型`T`替换了它们。我们现在可以声明我们可能需要的任何种类的队列，而不需要重复任何一行代码：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Generic constraints
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用约束
- en: Sometimes, we might need to restrict the use of a generic class. For example,
    we can add a new feature to the generic queue. The new feature is going to validate
    the entities before they are added to the queue.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要限制通用类的使用。例如，我们可以向通用队列添加一个新功能。这个新功能将在实体被添加到队列之前进行验证。
- en: 'One possible solution would be to use the `typeof` operator to identify the
    type of the generic type parameter `T` within a generic class or function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是使用`typeof`运算符来识别泛型类或函数中泛型类型参数`T`的类型：
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The problem is that we will have to modify our `Queue` class to add extra logic
    with each new kind of entity. We will not add the validation rules into the `Queue` class
    because a generic class should not know the type used as the generic type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，我们将不得不修改我们的`Queue`类，为每种新的实体添加额外的逻辑。我们不会将验证规则添加到`Queue`类中，因为一个通用类不应该知道用作通用类型的类型。
- en: 'A better solution is to add a method named `validate` to the entities. The
    method will throw and exception if the entity is invalid:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是为实体添加一个名为 `validate` 的方法。如果实体无效，该方法将抛出一个异常：
- en: '[PRE42]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code snippet throws a compilation error because we can use the
    generic repository with any type, but not all types have a method named `validate`.
    Fortunately, this issue can easily be resolved by using a generic constraint.
    Constraints will restrict the types that we can use as the generic type parameter
    `T`. We are going to declare a constraint, so only the types that implement an
    interface named `Validatable` can be used with the generic method. Let''s start
    by declaring the `Validatable` interface:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段抛出一个编译错误，因为我们可以使用任何类型的通用仓库，但并非所有类型都有一个名为 `validate` 的方法。幸运的是，这个问题可以通过使用通用约束轻松解决。约束将限制我们可以用作泛型类型参数
    `T` 的类型。我们将声明一个约束，因此只有实现了名为 `Validatable` 的接口的类型才能与泛型方法一起使用。让我们首先声明 `Validatable`
    接口：
- en: '[PRE43]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we can proceed to implement the interface. In this case, we must implement
    the `validate` method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续实现接口。在这种情况下，我们必须实现 `validate` 方法：
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s declare a generic repository and add a type constraint so that
    only types that implement the `Validatable` interface are accepted:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们声明一个泛型仓库并添加一个类型约束，以便只接受实现了 `Validatable` 接口类型的类型：
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Even though we have used an interface, we used the `extends` keyword and not
    the `implements` keyword to declare the constraint in the preceding example. There
    is no special reason for that. This is just the way the TypeScript constraint's
    syntax works.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经使用了一个接口，但在前面的例子中，我们使用了 `extends` 关键字而不是 `implements` 关键字来声明约束，这并没有特殊的原因。这只是
    TypeScript 约束语法的常规方式。
- en: 'At this point, we should be ready to see the new validation feature in action:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们应该准备好看到新的验证功能在实际中的应用：
- en: '[PRE46]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we attempt to use a class that doesn't implement the `Validatable` as the
    generic parameter `T`, we will get a compilation error.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用未实现 `Validatable` 的类作为泛型参数 `T`，我们将得到一个编译错误。
- en: Multiple types in generic type constraints
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型约束中的多个类型
- en: 'We can only refer to one type when declaring a generic type constraint. Let''s
    imagine that we need a generic class to be constrained, so it only allows types
    that extend the following two interfaces:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明泛型类型约束时，我们只能引用一个类型。让我们想象我们需要一个受约束的泛型类，它只允许扩展以下两个接口的类型：
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We may think that we can define the required generic constraint as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为我们可以如下定义所需的泛型约束：
- en: '[PRE48]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'However, this code snippet will throw a compilation error. We cannot specify
    multiple types when declaring a generic type constraint. However, we can work
    around this issue by using `Foo` and `Bar` in a superinterface:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个代码片段将抛出一个编译错误。在声明泛型类型约束时，我们不能指定多个类型。然而，我们可以通过使用 `Foo` 和 `Bar` 作为超接口来解决这个问题：
- en: '[PRE49]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`Foo` and `Bar` are now superinterfaces because they are the parent interfaces
    of the `FooBar` interface. We can then declare the constraint using the new `FooBar`
    interface:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Foo` 和 `Bar` 现在是超接口，因为它们是 `FooBar` 接口的父接口。然后我们可以使用新的 `FooBar` 接口声明约束：'
- en: '[PRE50]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The new operator in generic types
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型中的新操作符
- en: 'To create a new object within a generic piece of code, we need to use the constructor
    function of the type. This means that instead of using `t: T` as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '在泛型代码块中创建新对象时，我们需要使用类型的构造函数。这意味着我们不能再像这样使用 `t: T`：'
- en: '[PRE51]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We should use `t: { new(): T;}`, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '我们应该使用 `t: { new(): T;}`，如下所示：'
- en: '[PRE52]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Association, aggregation, and composition
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联、聚合和组合
- en: In OOP, classes can have a relationship with each other. In this section, we
    are going to talk about three different types of relationships between classes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，类可以相互关联。在本节中，我们将讨论类之间三种不同类型的关系。
- en: Association
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联
- en: 'We call **association** those relationships whose objects have an independent
    life cycle where there is no ownership of the objects. Let''s take a look at an
    example of a teacher and a student. Multiple students can be associated with a
    single teacher, and a single student can be associated with multiple teachers,
    but both have independent life cycles (both can create and delete independently).
    So, when a teacher leaves the school, we don''t need to delete any students, and
    when a student leaves the school, we don''t need to delete any teachers:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称那些对象具有独立生命周期且没有对象所有权的那些关系为**关联**。让我们看看教师和学生的例子。多个学生可以与一个教师相关联，一个学生也可以与多个教师相关联，但它们都有独立的生命周期（它们都可以独立创建和删除）。因此，当教师离开学校时，我们不需要删除任何学生，当学生离开学校时，我们也不需要删除任何教师：
- en: '![](img/cecece17-72dc-449d-a149-21a299988965.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cecece17-72dc-449d-a149-21a299988965.png)'
- en: Aggregation
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: 'We call **aggregation** those relationships whose objects have an independent
    life cycle, but there is ownership, and child objects cannot belong to another
    parent object. Let''s take an example of a cell phone and a cell phone battery.
    A single battery can belong to a phone, but if the phone stops working, and we
    delete it from our database, the phone battery will not be deleted because it
    may still be functional. So, in aggregation, while there is ownership, objects
    have their life cycle:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称那些对象具有独立生命周期，但存在所有权的那些关系为**聚合**。以手机和手机电池为例。单个电池可以属于一部手机，但如果手机停止工作，我们从数据库中删除它，手机电池不会删除，因为它可能仍然可以使用。因此，在聚合中，虽然存在所有权，但对象有自己的生命周期：
- en: '![](img/f95aba88-a80e-4594-acbb-81bbdd3e2f36.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f95aba88-a80e-4594-acbb-81bbdd3e2f36.png)'
- en: Composition
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: We use the term **composition** to refer to relationships whose objects don't
    have an independent life cycle, and if the parent object is deleted, all child
    objects will also be deleted.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语**组合**来指代那些对象没有独立生命周期的关系，如果父对象被删除，所有子对象也将被删除。
- en: Let's take an example of the relationship between questions and answers. Single
    questions can have multiple answers, and answers cannot belong to multiple questions.
    If we delete questions, answers will automatically be deleted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以问题和答案之间的关系为例。单个问题可以有多个答案，答案不能属于多个问题。如果我们删除问题，答案将自动被删除。
- en: Objects with a dependent life cycle (answers in the example) are known as **weak
    entities**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 具有依赖生命周期的对象（例如示例中的答案）被称为**弱实体**。
- en: '![](img/25cdb92f-3463-4193-8161-f24756777bec.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25cdb92f-3463-4193-8161-f24756777bec.png)'
- en: 'Sometimes, it can be a complicated process to decide if we should use association,
    aggregation, or composition. This difficulty is caused in part because aggregation
    and composition are subsets of association, which means they are specific cases
    of association:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '有时，决定是否使用关联、聚合或组合可能是一个复杂的过程。这种困难部分是由于聚合和组合是关联的子集，这意味着它们是关联的特定情况： '
- en: '![](img/851875e3-9a74-4a7e-a9de-fd009c0d5fb7.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/851875e3-9a74-4a7e-a9de-fd009c0d5fb7.png)'
- en: It is also important to mention that, in general, we should try to **use composition
    over inheritance** whenever it is possible. Inheritance tightly couples derived
    classes to their respective base classes and it can become a maintainability issue
    over time. Composition can lead to much less tightly coupled code than inheritance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提到的是，一般来说，我们应该尽可能**使用组合而非继承**。继承将派生类紧密耦合到其相应的基类，这可能会随着时间的推移成为一个可维护性问题。组合可以导致比继承更松散耦合的代码。
- en: Mixins (multiple inheritance)
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混入（多继承）
- en: Sometimes, we will find scenarios in which it would be useful to be able to
    declare a class that inherits from two or more classes simultaneously (known as
    **multiple inheritance**).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会遇到一些场景，在这些场景中，能够声明一个同时从两个或更多类继承的类（称为**多继承**）会有用。
- en: We are going to create an example to demonstrate how multiple inheritance works.
    We are going to avoid adding any code to the methods in this example because we
    want to avoid the possibility of getting distracted by the details. We should
    focus on the inheritance tree.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个示例来演示多继承是如何工作的。在这个例子中，我们将避免向方法中添加任何代码，因为我们想避免被细节分散注意力。我们应该关注继承树。
- en: 'We are going to start by declaring a class named `Animal` that has only one
    method, named `eat`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先声明一个名为`Animal`的类，它只有一个名为`eat`的方法：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After declaring the `Animal` class, we are going to declare two new classes
    named `WingedAnimal` and `Mammal`. Both classes are inherited from the `Animal`
    class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明`Animal`类之后，我们将声明两个新的类，分别命名为`WingedAnimal`和`Mammal`。这两个类都继承自`Animal`类：
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that we have our classes ready, we are going to try to implement a class
    named `Bat`. Bats are mammals and have wings. This means that we need to create
    a new class named `Bat`, which will extend both the `Mammal` and `WingedAnimal` classes.
    We might think that this seems logical, however, if we attempt to do this, we
    will encounter a compilation error:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了准备好的类，我们将尝试实现一个名为`Bat`的类。蝙蝠是哺乳动物，有翅膀。这意味着我们需要创建一个新的类`Bat`，它将继承自`Mammal`和`WingedAnimal`类。我们可能会认为这看起来很合理，然而，如果我们尝试这样做，我们将遇到一个编译错误：
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This error is thrown because TypeScript doesn't support multiple inheritance.
    This means that a class can only extend one class. Most OOP languages such as
    C# or TypeScript do not support multiple inheritance because it can potentially
    increase the complexity of applications and lead to a well-defined problem known
    as the diamond problem.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误被抛出是因为TypeScript不支持多重继承。这意味着一个类只能继承一个类。大多数面向对象的语言，如C#或TypeScript，都不支持多重继承，因为它可能会增加应用程序的复杂性，并导致一个被称为菱形问题的明确问题。
- en: The diamond problem
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菱形问题
- en: 'Sometimes, a class inheritance diagram can take a diamond-like shape (as seen
    in the following diagram). This kind of class inheritance diagram can potentially
    lead us to a design issue known as the **diamond problem**:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个类继承图可能呈现出类似菱形的形状（如下面的图所示）。这种类继承图可能会使我们面临一个称为**菱形问题**的设计问题：
- en: '![](img/6671b510-494d-465d-ac95-c9e6f72a073e.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6671b510-494d-465d-ac95-c9e6f72a073e.png)'
- en: 'If multiple inheritance was allowed and we encounter an inheritance tree with
    a diamond shape, we would not face any problems while using a method that is exclusive
    to only one of the classes in the inheritance tree:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许多重继承，并且我们遇到一个具有菱形形状的继承树，我们在使用仅属于继承树中一个类的独有方法时不会遇到任何问题：
- en: '[PRE56]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The problem takes place when we try to invoke one of the `Bat` class's parent
    methods, and it is unclear or ambiguous which of the parent's implementations
    of that method should be invoked. For example, if we could add a method named
    move to both the `Mammal` and the `WingedAnimal` classes and try to invoke it
    from an instance of `Bat`, we would get an ambiguous call error.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试调用`Bat`类的一个父方法时，会出现问题，不清楚或模糊地知道应该调用父类中该方法的哪个实现。例如，如果我们能够在`Mammal`和`WingedAnimal`类中添加一个名为`move`的方法，并尝试从`Bat`的一个实例中调用它，我们将会得到一个模糊调用错误。
- en: Implementing mixins
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现混入
- en: Now that we know why multiple inheritance can be potentially dangerous, we will
    introduce a feature known as **mixins**. Mixins are an alternative to multiple
    inheritance with some limitations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道多重继承可能存在潜在的危险，我们将介绍一个称为**混入**的功能。混入是多重继承的一种替代方案，但有一些限制。
- en: 'We are going to re-declare the `Mammal` and `WingedAnimal` classes to showcase
    how to work with mixins:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新声明`Mammal`和`WingedAnimal`类，以展示如何使用混入：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The two classes presented in the preceding example are not much different from
    the ones that we declared in the preceding sections. We have added some logic
    to the `breath` and `fly` methods, so we can have some values to help us understand
    this demonstration. It is also important to note that the `Mammal` and `WingedAnimal`
    classes no longer extend the `Animal` class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中展示的两个类与我们之前章节中声明的类并没有太大的区别。我们在`breath`和`fly`方法中添加了一些逻辑，以便我们有一些值来帮助我们理解这个演示。同时，值得注意的是，`Mammal`和`WingedAnimal`类不再继承自`Animal`类。
- en: 'The `Bat` class needs some important additions. We are going to use the `reserved`
    keyword `implements` to indicate that `Bat` will implement the functionality declared
    in the `Mammal` and `WingedAnimal` classes. We are also going to add the signature
    of each of the methods that the `Bat` class will implement:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bat`类需要一些重要的添加。我们将使用`reserved`关键字`implements`来表示`Bat`将实现`Mammal`和`WingedAnimal`类中声明的功能。我们还将添加`Bat`类将实现的方法的签名：'
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We need to copy the following function somewhere in our code to be able to
    apply mixins:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将以下函数复制到我们的代码中的某个地方，以便能够应用混入：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding function is a well-known pattern and can be found in many books
    and online references, including the official *TypeScript Handbook*. Don't worry
    if you don't fully understand it at this point because it uses some concepts (such
    as An iterator is a behavioral design pattern which
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数是一个众所周知的模式，可以在许多书籍和在线参考资料中找到，包括官方 *TypeScript 手册*。如果你现在还没有完全理解它，不要担心，因为它使用了一些概念（例如，迭代器是一种行为设计模式，它
- en: porotypes) that will not be covered until [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 原型（prototypes）等概念，这些内容将在 [第 6 章](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml)
    *理解运行时* 中介绍。
- en: 'This function iterates each property of the parent classes (contained in an
    array named `bases`) and copies the implementation to a child class (`derived`).
    We only need to declare this function once in our entire application. Once we
    have done it, we can use it as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数遍历父类（包含在名为 `bases` 的数组中）的每个属性，并将实现复制到子类（`derived`）中。我们只需要在我们的整个应用程序中声明这个函数一次。一旦我们完成了它，我们就可以如下使用它：
- en: '[PRE60]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The child class (`Bat`) will then contain each of the properties and methods
    of the two parent classes (`WingedAnimal` and `Mammal`):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 子类（`Bat`）将包含两个父类（`WingedAnimal` 和 `Mammal`）的每个属性和方法：
- en: '[PRE61]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As we said at the beginning of this section, mixins have some limitations:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，混入有一些限制：
- en: The first limitation is that we can only inherit the properties and methods
    from one level in the inheritance tree. This explains why we removed the `Animal`
    class before applying the mixins.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个限制是我们只能从继承树中的一级继承属性和方法。这解释了为什么我们在应用混入之前移除了 `Animal` 类。
- en: The second limitation is that if two or more of the parent classes contain a
    method with the same name, the method that is going to be inherited will be taken
    from the last class passed in the `bases` array to the `applyMixins` function.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个限制是，如果两个或多个父类包含具有相同名称的方法，将要继承的方法将是从传递给 `applyMixins` 函数的 `bases` 数组中最后一个类中获取的。
- en: We will now see an example that presents both of these limitations.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到一个示例，展示这两个限制：
- en: 'To show the first limitation, we will re-declare the `Animal` class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示第一个限制，我们将重新声明 `Animal` 类：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We will then declare the `Mammal` and `WingedAnimal` classes, but this time,
    they will extend the `Animal` class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将声明 `Mammal` 和 `WingedAnimal` 类，但这次，它们将扩展 `Animal` 类：
- en: '[PRE63]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will then declare again the `Bat` class. This class will implement both
    the `Mammal` and `WindgedAnimal` classes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将再次声明 `Bat` 类。这个类将实现 `Mammal` 和 `WindgedAnimal` 类：
- en: '[PRE64]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We are ready to invoke the `applyMixins` function. Notice how we pass `Mammal`
    before `WingedAnimal` in the array:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备调用 `applyMixins` 函数。注意我们如何在数组中先传递 `Mammal` 再传递 `WingedAnimal`：
- en: '[PRE65]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can now create an instance of `Bat`, and we will be able to observe that
    the `eat` method has not been inherited from the `Animal` class due to the first
    limitation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个 `Bat` 的实例，我们将能够观察到由于第一个限制，`eat` 方法没有从 `Animal` 类继承：
- en: '[PRE66]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Each of the parent class''s methods has been inherited without issues:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 父类中的每个方法都无问题地继承了：
- en: '[PRE67]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `move` method has issues because according to the second limitation, only
    the implementation of the last parent class passed to the `applyMixins` method
    will be implemented. In this case, the implementation is inherited from the `WingedAnimal`
    class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`move` 方法存在问题，因为根据第二个限制，只有传递给 `applyMixins` 方法的最后一个父类的实现将被实现。在这种情况下，实现是从 `WingedAnimal`
    类继承的：'
- en: '[PRE68]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To finalize, we will see the effect of switching the order of the parent classes
    when invoking the `applyMixins` method. Notice how we have passed `WingedAnimal`
    before `Mammal` in the array:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到在调用 `applyMixins` 方法时改变父类顺序的影响。注意我们如何在数组中先传递 `WingedAnimal` 再传递 `Mammal`：
- en: '[PRE69]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Iterables
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'An iterator is a behavioral design pattern that is common in OOP. An iterator
    is an object that implements an interface such as the following one:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一种在面向对象编程中常见的行性行为设计模式。迭代器是一个实现如下接口的对象：
- en: '[PRE70]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding interface allows us to retrieve the items available in a collection.
    The iterator result allows us to know if we have reached the last item in the
    collection and to access the values in the collection:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的接口允许我们检索集合中可用的项目。迭代器结果允许我们知道我们是否已到达集合中的最后一个项目，并访问集合中的值：
- en: '[PRE71]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can create custom iterators by implementing the `IterableIterator` interface.
    We will need to implement the next method and a method named `Symbol.iterator`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现 `IterableIterator` 接口来创建自定义迭代器。我们需要实现 `next` 方法以及一个名为 `Symbol.iterator`
    的方法：
- en: '[PRE72]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We can use brackets to define the name of a property or method using the value
    of a variable as the name of the method or property. In this case, the `Symbol.iterator`
    is used as the name of the method. The `Symbol` iterator contains the unique string
    `@@iterator`. This name is a special name for a method because whenever an object
    needs to be iterated (such as at the beginning of a `for...of` loop), its `@@iterator`
    method is called with no arguments, and the returned iterator is used to obtain
    the values to be iterated.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用方括号来定义属性或方法的名称，使用变量的值作为方法或属性的名称。在这种情况下，`Symbol.iterator` 被用作方法的名称。`Symbol`
    迭代器包含唯一的字符串 `@@iterator`。这个名称是一个特殊的方法名称，因为每当一个对象需要被迭代（例如在 `for...of` 循环的开始时），它的
    `@@iterator` 方法会被调用，并且不带任何参数，返回的迭代器被用来获取要迭代的值。
- en: 'After declaring the class, we can create instances and iterate their values:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明类之后，我们可以创建实例并迭代它们的值：
- en: '[PRE73]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The preceding iterable never stops returning values, but we can also declare
    an instance with a fixed number of items and iterate the items using a `for...of`
    loop:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的可迭代对象永远不会停止返回值，但我们可以声明一个具有固定项目数的实例，并使用 `for...of` 循环迭代这些项目：
- en: '[PRE74]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Note that some additional types are required by asynchronous iterators if we
    are targeting ES5 or ES3\. You will need to add `esnext.asynciterable` to your
    `tsconfig.json` file. We are also going to need to enable an additional setting
    in our `tsconfig.json` to provide full support for iterables (for example, using
    `for...of` control flow statements, the spread operator or object destructuring)
    when targeting ES3 or ES5:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们针对 ES5 或 ES3，异步迭代器可能需要一些额外的类型。你需要将 `esnext.asynciterable` 添加到你的 `tsconfig.json`
    文件中。我们还需要在 `tsconfig.json` 中启用一个额外的设置，以提供对可迭代对象的全面支持（例如，使用 `for...of` 控制流语句、扩展运算符或对象解构）当针对
    ES3 或 ES5：
- en: '`"lib": [`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`"lib": [`'
- en: '`              "es2015.promise",`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`              "es2015.promise",`'
- en: '`              "dom",`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`              "dom",`'
- en: '`              "es5",`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`              "es5",`'
- en: '`              "es5",`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`              "es5",`'
- en: '`              "es2015.generator",`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`              "es2015.generator",`'
- en: '`              "es2015.iterable",`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`              "es2015.iterable",`'
- en: '`              "esnext.asynciterable" // new`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`              "esnext.asynciterable" // new`'
- en: '`]`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`]`'
- en: You might also need a recent version of Node.js as the preceding example will
    not work in old versions of Node.js. We will learn more about the `lib` setting
    in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating Your Development
    Workflow*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要一个较新的 Node.js 版本，因为前面的示例在旧版本的 Node.js 中将不会工作。我们将在第 9 章 *自动化你的开发工作流程* 中学习更多关于
    `lib` 设置的内容。[链接](https://example.org/ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)。
- en: Abstract classes
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'Abstract classes are base classes that can be extended by other classes. The
    `abstract` keyword is used to define abstract classes as well as abstract methods
    within an abstract class:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是基类，可以被其他类扩展。`abstract` 关键字用于定义抽象类以及抽象类中的抽象方法：
- en: '[PRE75]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The methods in an abstract class that are preceded by the `abstract` keyword
    cannot contain an implementation and must be implemented by the derived classes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象类中，由 `abstract` 关键字引导的方法不能包含实现，必须由派生类实现。
- en: 'Abstract methods may look like interface methods. However, an abstract class
    may contain implementation details for some of its members:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法可能看起来像接口方法。然而，一个抽象类可能包含其成员的一些实现细节：
- en: '[PRE76]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'It is not possible to create an instance of an abstract class:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 无法创建抽象类的实例：
- en: '[PRE77]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Interfaces
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are probably the feature that you will miss the most while developing
    large-scale web applications with JavaScript if you have a background in object-oriented
    statically-typed programming languages such as Java or C#.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你具有 Java 或 C# 等面向对象静态类型编程语言的背景，那么在用 JavaScript 开发大型 Web 应用程序时，接口可能是你最怀念的特性。
- en: 'Traditionally, in OOP, we say that a class can extend only one class and implement
    one or more interfaces. An interface can implement one or more interfaces and
    cannot extend another class or interface. Wikipedia''s definition of interfaces
    in OOP is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在面向对象编程（OOP）中，我们说一个类只能扩展一个类并实现一个或多个接口。一个接口可以实现一个或多个接口，但不能扩展另一个类或接口。维基百科对面向对象编程中接口的定义如下：
- en: '"In object-oriented languages, the term interface is often used to define an
    abstract type that contains no data or code, but defines behaviors as method signatures."'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: “在面向对象的语言中，术语接口通常用来定义一个不包含数据或代码的抽象类型，但定义行为作为方法签名。”
- en: 'In TypeScript, interfaces don''t strictly follow this definition. The two main
    differences are that in TypeScript:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，接口并不严格遵循这个定义。TypeScript 中的两个主要区别是：
- en: An interface can extend a class
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以扩展一个类
- en: An interface can define data and behaviors as opposed to only behaviors
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以定义数据和行为，而不仅仅是行为
- en: 'For example, we can define an interface named `Weapon`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一个名为 `Weapon` 的接口：
- en: '[PRE78]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `Weapon` interface defines the behavior shared by all weapons (a weapon
    can be used to try to hit an enemy, but each kind of weapon has a different range).
    However, the interface does not define the details of each if its implementations
    (the specific range of each kind of weapon).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Weapon` 接口定义了所有武器共享的行为（武器可以用来尝试击中敌人，但每种武器都有不同的射程）。然而，接口并没有定义其实现细节（每种武器的具体射程）。'
- en: 'Implementing an interface can be understood as signing a contract. An interface
    is a contract, and when we sign it (implement it), we must follow its rules. The
    interface rules are the signatures of the methods and properties, and we must
    implement them:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口可以理解为签订一份合同。接口是一份合同，当我们签订它（实现它）时，我们必须遵循其规则。接口规则是方法的签名和属性，我们必须实现它们：
- en: '[PRE79]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The two preceding classes implement the methods defined by the `Weapon` interface.
    Both classes share the same public API but have different internal implementations.
    We will see many more examples of interfaces through the rest of this chapter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个类实现了由 `Weapon` 接口定义的方法。这两个类共享相同的公共 API，但具有不同的内部实现。我们将在本章的其余部分看到更多接口的例子。
- en: SOLID principles, encapsulation, and polymorphism
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID 原则、封装和多态
- en: In the early days of software development, developers used to write code with
    procedural programming languages. In procedural programming languages, the programs
    follow a top-to-bottom approach, and the logic is wrapped with functions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发初期，开发者通常使用过程式编程语言编写代码。在过程式编程语言中，程序遵循自顶向下的方法，逻辑被封装在函数中。
- en: New styles of computer programming, such as modular programming or structured
    programming, emerged when developers realized that procedural computer programs
    could not provide them with the desired level of abstraction, maintainability,
    and reusability.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者意识到过程式计算机程序无法提供他们所需的抽象级别、可维护性和可重用性时，出现了新的计算机编程风格，如模块化编程或结构化编程。
- en: The development community created a series of recommended practices and design
    patterns to improve the level of abstraction and reusability of procedural programming
    languages, but some of these guidelines required a certain level of expertise.
    To facilitate adherence to these guidelines, a new style of computer programming
    known as **object-oriented programming** (**OOP**) was created.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 开发社区创建了一系列推荐的最佳实践和设计模式，以提高过程式编程语言的抽象级别和可重用性，但其中一些指南需要一定的专业知识。为了便于遵循这些指南，创建了一种新的计算机编程风格，称为**面向对象编程**（**OOP**）。
- en: 'Developers quickly noticed some common OOP mistakes and came up with five rules
    that every OOP developer should follow to create a system that is easy to maintain
    and extend over time. These five rules are known as the SOLID principles. SOLID
    is an acronym introduced by Michael Feathers. Each of the characters in the acronym
    represents one of the following principles:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者很快注意到一些常见的面向对象错误，并提出了五条每名面向对象开发者都应该遵循的规则，以创建一个易于维护和随时间扩展的系统。这五条规则被称为 SOLID
    原则。SOLID 是由 Michael Feathers 提出的一个缩写，每个字母代表以下原则之一：
- en: '**Single responsibility principle** (**SRP**): This principle states that a
    software component (function, class, or module) should focus on one unique task
    (have only one responsibility).'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）：该原则指出，软件组件（函数、类或模块）应专注于一个独特的任务（只有一个职责）。'
- en: '**Open/closed principle** (**OCP**): This principle states that software entities
    should be designed with application growth (new code) in mind (be open to extension),
    but that application growth should require as few changes to the existing code
    as possible (be closed for modification).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**（**OCP**）：这个原则指出，软件实体应该考虑到应用的增长（新代码）（易于扩展），但应用的增长应尽可能少地改变现有代码（对修改封闭）。'
- en: '**Liskov substitution principle** (**LSP**): This principle states that we
    should be able to replace a class in a program with another class if both classes
    implement the same interface. After replacing the class, no other changes should
    be required, and the program should continue to work as it did originally.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**（**LSP**）：这个原则指出，如果两个类都实现了相同的接口，我们应该能够用一个类替换程序中的另一个类。在替换类之后，不应需要其他更改，程序应继续按原样工作。'
- en: '**Interface segregation principle** (**ISP**): This principle states that we
    should split interfaces that are very large (general-purpose interfaces) into
    smaller and more specific ones (many client-specific interfaces) so that clients
    will only need to know about the methods that are of interest to them.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（**ISP**）：这个原则指出，我们应该将非常大的接口（通用接口）拆分成更小、更具体的接口（许多客户端特定的接口），这样客户端就只需要了解对他们感兴趣的方法。'
- en: '**Dependency inversion principle** (**DIP**): This principle states that entities
    should depend on abstractions (interfaces) as opposed to depending on concretion
    (classes).'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**）：这个原则指出，实体应该依赖于抽象（接口），而不是依赖于具体（类）。'
- en: In this chapter, we are going to learn how to write TypeScript code that adheres
    to these principles so that our applications are easy to maintain and extend over
    time.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何编写遵循这些原则的TypeScript代码，以便我们的应用程序易于维护和随时间扩展。
- en: SOLID – the single responsibility principle
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID – 单一职责原则
- en: 'All our classes should adhere to the **single responsibility principle** (**SRP**).
    The `Person` class declared during the very first example in this chapter represents
    a person, including all of their characteristics (attributes) and behaviors (methods).
    We are going to modify the preceding class by adding an `email` as validation
    logic:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有类都应该遵循**单一职责原则**（**SRP**）。在本章的第一个示例中声明的`Person`类代表一个人，包括他们的所有特征（属性）和行为（方法）。我们将通过添加一个`email`作为验证逻辑来修改前面的类：
- en: '[PRE80]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When an object doesn't follow the SRP and it knows too much (has too many properties)
    or does too much (has too many methods), we say that the object is a `God` object.
    The `Person` class here is a `God` object because we have added a method named
    `validateEmail` that is not related to the `Person` class's behavior.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象不遵循SRP（单一职责原则），知道太多（有太多属性）或做得太多（有太多方法）时，我们称这个对象为`God`对象。这里的`Person`类就是一个`God`对象，因为我们添加了一个名为`validateEmail`的方法，这个方法与`Person`类的行为无关。
- en: Deciding which attributes and methods should or should not be part of a class
    is a relatively subjective decision. If we spend some time analyzing our options,
    we should be able to identify ways to improve the design of our classes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 决定哪些属性和方法应该或不应该成为类的一部分是一个相对主观的决定。如果我们花些时间分析我们的选项，我们应该能够识别出改进我们类的设计的方法。
- en: 'We can refactor the `Person` class by declaring an `Email` class, which is
    responsible for email validation, and use it as an attribute in the `Person` class:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过声明一个负责电子邮件验证的`Email`类来重构`Person`类，并将其作为`Person`类的一个属性使用：
- en: '[PRE81]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now that we have an `Email` class, we can remove the responsibility of validating
    the emails from the `Person` class and update its `email` attribute to use the  `Email`
    type instead of `string`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Email`类，我们可以从`Person`类中移除验证电子邮件的责任，并更新其`email`属性以使用`Email`类型而不是`string`：
- en: '[PRE82]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Making sure that a class has a single responsibility makes it easier to see
    what it does and how we can extend/improve it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 确保一个类有单一职责使其更容易看到它做什么以及我们如何扩展/改进它。
- en: Encapsulation
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: We can further improve our `Person` and `Email` classes declared in the previous
    section by increasing the level of abstraction of our classes. For example, when
    we use the `Email` class, we don't need to be aware of the existence of the `validateEmail`
    method; this method could be invisible from outside the `Email` class. As a result,
    the `Email` class would be much simpler to understand.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提高类的抽象级别来进一步改进上一节中声明的 `Person` 和 `Email` 类。例如，当我们使用 `Email` 类时，我们不需要意识到
    `validateEmail` 方法的存在；这个方法可以从 `Email` 类的外部不可见。因此，`Email` 类将更容易理解。
- en: 'When we increase the level of abstraction of an object, we can say that we
    are encapsulating some logic. Encapsulation is also known as **information hiding**.
    For example, the `Email` class allows us to use emails without having to worry
    about email validation because the class will deal with it for us. We can make
    this clearer by using access modifiers (`public` or `private`) to flag all the
    class attributes and methods that we want to abstract from the use of the `Email`
    class as `private`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提高对象的抽象级别时，我们可以说是我们正在封装一些逻辑。封装也被称为**信息隐藏**。例如，`Email` 类允许我们使用电子邮件而无需担心电子邮件验证，因为类会为我们处理它。我们可以通过使用访问修饰符（`public`
    或 `private`）来标记所有我们希望从 `Email` 类的使用中抽象出来的类属性和方法，使这一点更加清晰：
- en: '[PRE83]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can then simply use the `Email` class without needing to explicitly perform
    any kind of validation:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简单地使用 `Email` 类，而无需显式执行任何类型的验证：
- en: '[PRE84]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: SOLID – the open/closed principle
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID – 开闭原则
- en: The **open/closed principle** (**OCP**)  recommends that we design our classes
    and methods in a way that enables us to extend their behavior (open for extension)
    in the future without modifying their current behavior (closed for modification).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**开闭原则**（**OCP**）建议我们以使我们在未来能够扩展它们的行为（对扩展开放）而不修改它们当前的行为（对修改封闭）的方式设计我们的类和方法。'
- en: 'The following code snippet is not great because it does not adhere to the open/closed
    principle:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段不太好，因为它没有遵循开闭原则：
- en: '[PRE85]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The preceding code does not adhere to the open/closed principle because if
    we need to extend our program to also support circles, we will need to modify
    the existing `AreaCalculator` class:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码没有遵循开闭原则，因为如果我们需要扩展我们的程序以支持圆形，我们将需要修改现有的 `AreaCalculator` 类：
- en: '[PRE86]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'A better solution is to add the area calculation as a method of the shapes
    so that when we add a new shape (extension), we don''t need to change the existing
    `AreaCalculator` class (modification):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是将面积计算作为形状的方法添加，这样当我们添加一个新的形状（扩展）时，我们不需要更改现有的 `AreaCalculator` 类（修改）：
- en: '[PRE87]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The second approach follows the second SOLID principle, the open/closed principle,
    as we can create new entities, and the generic repository will continue to work
    (open for extension), but no additional changes to it will be required (closed
    for modification).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法遵循第二个 SOLID 原则，即开闭原则，因为我们可以创建新的实体，通用的仓库将继续工作（对扩展开放），但不需要对其进行任何额外的更改（对修改封闭）。
- en: Polymorphism
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: Polymorphism is the ability to present the same interface for differing underlying
    forms (data types). Polymorphism is often referred to as the third pillar of object-oriented
    programming, after encapsulation and inheritance.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是呈现不同底层形式（数据类型）相同接口的能力。多态性通常被称为面向对象编程的第三根支柱，在封装和继承之后。
- en: 'Polymorphism is what enabled us to implement the LSP in the preceding section:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性使我们能够在前一节中实现 LSP：
- en: '[PRE88]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Objects of the derived class (`Circle` and `Rectangle`) may be treated as objects
    of a base class (`Shape`) in places such as method parameters (such  as the `area`
    method). Base classes may define and implement abstract methods, and derived classes
    can override them, which means they provide their definition and implementation.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类的对象（`Circle` 和 `Rectangle`）可以在方法参数（如 `area` 方法）等地方被视为基类（`Shape`）的对象。基类可以定义和实现抽象方法，派生类可以覆盖它们，这意味着它们提供了它们的定义和实现。
- en: SOLID – the Liskov substitution principle
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID – 李斯克夫替换原则
- en: The **Liskov substitution principle** (**LSP**) states, *Subtypes must be substitutable
    for their base types*. Let's look at an example to understand what this means.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**李斯克夫替换原则**（**LSP**）指出，*子类型必须可替换为其基类型*。让我们通过一个例子来理解这意味着什么。'
- en: 'We will declare a class named `PersistanceService`, the responsibility of which
    is to persist some object into some sort of storage. We will start by declaring
    the following interface:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明一个名为 `PersistanceService` 的类，其责任是将某些对象持久化到某种存储中。我们将从声明以下接口开始：
- en: '[PRE89]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'After declaring the `PersistanceServiceInterface` interface, we can implement
    it. We will use cookies as the storage for the application''s data:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明 `PersistanceServiceInterface` 接口之后，我们可以实现它。我们将使用 cookie 作为应用程序数据的存储：
- en: '[PRE90]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We will continue by declaring a class named `FavouritesController`, which has
    a dependency on `PersistanceServiceInterface`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续通过声明一个名为 `FavouritesController` 的类，该类依赖于 `PersistanceServiceInterface`
    来继续操作：
- en: '[PRE91]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can finally create an instance of `FavouritesController` and pass an instance
    of `CookiePersitanceService` via its constructor:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以创建一个 `FavouritesController` 的实例，并通过其构造函数传递一个 `CookiePersitanceService`
    的实例：
- en: '[PRE92]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The LSP allows us to replace a dependency with another implementation if both
    implementations are based in the same base type; so, if we decide to stop using
    cookies as storage and use the HTML5 local storage API instead, we can declare
    a new implementation:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: LSP 允许我们在两个基于相同基类型的实现之间替换依赖项；因此，如果我们决定停止使用 cookie 作为存储并改用 HTML5 本地存储 API，我们可以声明一个新的实现：
- en: '[PRE93]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can then replace it without having to add any changes to the `FavouritesController`
    controller class:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以替换它，而无需对 `FavouritesController` 控制器类进行任何更改：
- en: '[PRE94]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: SOLID – the interface segregation principle
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID – 接口隔离原则
- en: Interfaces are used to declare how two or more software components cooperate
    and exchange information with each other. This declaration is known as an **application
    programming interface** (**API**). In the previous example, our interface was
    `PersistanceServiceInterface`, and it was implemented by the classes `LocalStoragePersitanceService`
    and `CookiePersitanceService`. The interface was consumed by the `FavouritesController`
    class, so we say that this class is a client of the `PersistanceServiceInterface` API.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接口用于声明两个或多个软件组件如何合作以及如何相互交换信息。这种声明被称为 **应用程序编程接口**（**API**）。在先前的例子中，我们的接口是 `PersistanceServiceInterface`，它由
    `LocalStoragePersitanceService` 和 `CookiePersitanceService` 类实现。该接口被 `FavouritesController`
    类消费，因此我们说这个类是 `PersistanceServiceInterface` API 的客户端。
- en: The **interface segregation principle** (**ISP**) states that no client should
    be forced to depend on methods it does not use. To adhere to the ISP, we need
    to keep in mind that when we declare the API (how two or more software components
    cooperate and exchange information with each other) of our application's components,
    the declaration of many client-specific interfaces is better than the declaration
    of one general-purpose interface. Let's look at an example.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（**ISP**）指出，没有任何客户端应该被迫依赖于它不使用的方法。为了遵循 ISP，我们需要记住，当我们声明应用程序组件的 API（两个或多个软件组件如何合作以及如何相互交换信息）时，声明许多特定于客户端的接口比声明一个通用接口更好。让我们看看一个例子。'
- en: 'If we design an API to control all the elements in a vehicle (engine, radio,
    heating, navigation, and lights), we could have one general-purpose interface,
    that allows us to control every single element of the vehicle:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设计一个 API 来控制车辆中的所有元素（引擎、收音机、加热、导航和灯光），我们可以有一个通用接口，它允许我们控制车辆的每一个单独元素：
- en: '[PRE95]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: If a class has a dependency (client) in the `VehicleInterface` interface but
    it only wants to use the radio methods, we would be facing a violation of the
    ISP because, as we have already seen, a client shouldn't  be forced to depend
    on methods it does not use.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类在 `VehicleInterface` 接口中有一个依赖（客户端），但它只想使用收音机方法，我们将面临 ISP 的违反，因为我们已经看到，客户端不应该被迫依赖于它不使用的方法。
- en: 'The solution is to split the `VehicleInterface` interface into many client-specific
    interfaces so that our class can adhere to the ISP by depending only on the `RadioInterface`
    interface:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将 `VehicleInterface` 接口拆分为许多特定于客户端的接口，这样我们的类就可以通过仅依赖于 `RadioInterface`
    接口来遵循 ISP：
- en: '[PRE96]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: SOLID – the dependency inversion principle
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID – 依赖倒置原则
- en: The **dependency inversion** (**DI**) principle states, *Depend upon abstractions.
    Do not depend upon concretions*. In the LSP, we implemented a class named `FavouritesController`.
    In the example, it was possible to replace an implementation of `PersistanceServiceInterface`
    with another without having to perform any additional change to `FavouritesController`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置**（**DI**）原则指出，*依赖于抽象。不要依赖于具体实现*。在LSP中，我们实现了一个名为`FavouritesController`的类。在示例中，我们可以替换`PersistanceServiceInterface`的实现，而无需对`FavouritesController`进行任何额外的修改。'
- en: 'We followed the DI principle, as `FavouritesController` has a dependency upon
    `PersistanceServiceInterface` (abstraction):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循了DI原则，因为`FavouritesController`依赖于`PersistanceServiceInterface`（抽象）：
- en: '![](img/438ea4e3-82fe-4d79-a90f-cfae68e79262.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/438ea4e3-82fe-4d79-a90f-cfae68e79262.png)'
- en: 'The preceding can be implemented as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容可以按照以下方式实现：
- en: '[PRE97]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Rather than `FavouritesController` having a dependency on `LocalStoragePersitanceService`
    or `CookiePersitanceService` (concretions) directly:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让`FavouritesController`直接依赖于`LocalStoragePersitanceService`或`CookiePersitanceService`（具体实现）：
- en: '![](img/3538b3eb-29c5-409e-96c4-1ccd68bde2a0.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3538b3eb-29c5-409e-96c4-1ccd68bde2a0.png)'
- en: 'The preceding can be implemented as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容可以按照以下方式实现：
- en: '[PRE98]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If we compare the two diagrams, we will notice that the direction arrow that
    links the dependent and the dependency has been inverted thanks to the introduction
    of the interface (abstraction). This should help us to understand why this principle
    is known as the dependency inversion principle.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们比较这两个图，我们会注意到，由于引入了接口（抽象），连接依赖和依赖关系的方向箭头已经被反转。这应该有助于我们理解为什么这个原则被称为依赖倒置原则。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to work with classes and interfaces in
    depth. We were able to make our application more maintainable by using techniques
    such as encapsulation and dependency inversion. In the next chapter, we will learn
    how to work with dependencies.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何深入地处理类和接口。通过使用封装和依赖倒置等技术，我们使我们的应用程序更加易于维护。在下一章中，我们将学习如何处理依赖关系。
