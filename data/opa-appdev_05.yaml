- en: Chapter 5. Communicating between Client and Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 客户端与服务器之间的通信
- en: 'An important difference between Opa and most other web development languages
    is that other technologies typically require the use of multiple languages in
    order to write client-side and server-side code, whereas in Opa we can do both
    using a single language. This gives us the ability to invoke a remote procedure
    just like a local function. We do not need to send Ajax requests and parse response
    data ourselves. In this chapter, we will first talk about how to slice server
    and client code using Opa and what we can do to help the slicer when automatic
    slicing is not enough. Then, we will introduce three primitives for communication
    between clients and the server: session, cell, and network.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Opa 与大多数其他 Web 开发语言的一个重要区别是，其他技术通常需要使用多种语言来编写客户端和服务器端代码，而在 Opa 中，我们可以使用单一语言完成这两者。这使我们能够像调用本地函数一样调用远程过程。我们不需要自己发送
    Ajax 请求并解析响应数据。在本章中，我们将首先讨论如何使用 Opa 切片服务器端和客户端代码，以及当自动切片不足时我们可以做些什么来帮助切片器。然后，我们将介绍客户端和服务器之间通信的三个原语：会话、单元格和网络。
- en: Client and server slicing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端和服务器端切片
- en: Opa allows developers to write the server and client code both in the same language
    within the same module. And even better, the Opa slicer automates the calls between
    the client and the server. No more manually written Ajax calls or value serialization
    is needed!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Opa 允许开发者在同一个模块中使用同一种语言编写服务器端和客户端代码。而且更好，Opa 切片器自动化了客户端和服务器之间的调用。不再需要手动编写的 Ajax
    调用或值序列化！
- en: A simple example
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: 'Let''s get started with a simple example. Suppose we want to send our name
    to the server and request the server to respond with the words "Say hello to [name]
    from server":'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。假设我们想将我们的名字发送到服务器，并请求服务器以“从服务器向 [name] 说你好”的词语响应：
- en: '![A simple example](img/3749OS_05_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的例子](img/3749OS_05_01.jpg)'
- en: 'This is quite simple and can be accomplished with almost any language that
    we are familiar with. Typically, you would send an Ajax request to the server
    with name as request data, and the server will respond with a JSON object containing
    the string we want. The following code fragment demonstrates how we can do this
    using jQuery for the client-side code and ASP as server-side code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，几乎我们可以用我们熟悉的任何语言来完成。通常，你会发送一个带有名字作为请求数据的 Ajax 请求到服务器，服务器将响应一个包含我们想要的字符串的
    JSON 对象。以下代码片段演示了我们可以如何使用 jQuery 作为客户端代码和 ASP 作为服务器端代码来完成这个操作：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With Opa, things become even easier. We can skip the step of sending an Ajax
    request, and we also don''t need to parse the JSON response data ourselves. We
    only need to write a normal function with a server tag and invoke the function
    from the client. Here is the complete code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Opa，事情变得更加简单。我们可以跳过发送 Ajax 请求的步骤，也不需要自己解析 JSON 响应数据。我们只需要编写一个带有 `server`
    标签的正常函数，并从客户端调用该函数。以下是完整的代码：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we add a `server` tag before the `sayhello` function
    to indicate that it is a function on the server side, and we invoke this function
    on the client as a normal client-side function. If the `server` tag is removed,
    the `sayhello` function will be a client-side function in this example, and there
    will be no communication between the client and the server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在 `sayhello` 函数之前添加了一个 `server` 标签，以指示它是一个服务器端的函数，并在客户端作为正常客户端函数调用此函数。如果移除
    `server` 标签，则 `sayhello` 函数将在这个例子中成为客户端函数，客户端和服务器之间将没有通信。
- en: Slicing annotations
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片注解
- en: The `server` tag tells the Opa complier to put the `sayhello` function on the
    server side. Opa is a language that can be executed both on a client and a server,
    but at some point during the compilation process, it must be decided on which
    side does the code actually end up, and whether there are any remote calls.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`server` 标签指示 Opa 编译器将 `sayhello` 函数放置在服务器端。Opa 是一种可以在客户端和服务器端执行的语言，但在编译过程中某个时刻，必须决定代码最终在哪个端运行，以及是否存在任何远程调用。'
- en: If the developer does not provide the slicing information by adding the slicing
    annotations (server, client, and both) before a function or a module, then Opa
    will perform the slicing job automatically. The rules for slicing that Opa follows
    by default are quite simple. Opa will implement the function on both the server
    as well as the client if possible. If it is not possible to implement the function
    both on the server and the client, then Opa will implement the function either
    on the server or on the client, depending on where it is possible to implement
    the function. For instance, if we remove the `server` tag from the `sayhello`
    function in the previous example, then Opa's slicer will implement the function
    twice, once on the server and once on the client. As a result, the invocation
    is no longer a remote call but a local call.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者没有通过在函数或模块之前添加切片注释（服务器、客户端和两边）来提供切片信息，那么Opa将自动执行切片任务。Opa默认遵循的切片规则相当简单。如果可能，Opa将在服务器和客户端上实现函数。如果不可能在服务器和客户端上实现函数，那么Opa将根据函数可以在哪里实现来在服务器或客户端上实现函数。例如，如果我们从上一个示例中的
    `sayhello` 函数中删除 `server` 标签，那么Opa的切片器将实现该函数两次，一次在服务器上，一次在客户端。结果，调用不再是远程调用，而是一个本地调用。
- en: 'When automatic slicing is not enough, for example, if we want a function to
    only be available on the server side or client side, we can add slicing annotations
    before the function keyword to tell the slicer where a declaration should end
    up. There are three slicing annotations: **server**, **client** and **both**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动切片不足以满足需求时，例如，如果我们希望一个函数仅在服务器端或客户端可用，我们可以在函数关键字之前添加切片注释来告诉切片器一个声明应该在哪里结束。有三个切片注释：**服务器**、**客户端**和**两边**。
- en: '**server**: Opa will implement the function on the server (but it does not
    mean that it will not be visible for the code running on the client)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：Opa将在服务器上实现该函数（但这并不意味着它对在客户端运行的代码不可见）'
- en: '**client**: Opa will implement the code on the client (but it does not mean
    that it will not be visible for the code running on the server)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：Opa将在客户端实现代码（但这并不意味着它对在服务器上运行的代码不可见）'
- en: '**both**: The function is implemented both on the server as well as the client'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两边**：函数在服务器和客户端都实现'
- en: It is easy to understand what the **server** and **client** mean, but the **both**
    keyword is less intuitive. The problem is that a definition can have arbitrary
    side effects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解 **服务器** 和 **客户端** 的含义，但 **两边** 关键字不太直观。问题是定义可以有任意副作用。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Side effect**: In computer science, a function or expression is said to have
    a side effect if, in addition to returning a value, it also modifies some state
    or has an observable interaction with calling functions or the outside world.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**副作用**：在计算机科学中，如果一个函数或表达式除了返回一个值之外，还修改了一些状态或与调用函数或外部世界有可观察的交互，那么它被认为有副作用。'
- en: 'Therefore, there are two possible meanings: either the side effect is executed
    on both sides or the side effect is executed once on the server and the resulting
    value is shared between the two sides. By default, the slicer duplicates some
    side effects such as printing and avoids duplicating the allocation of mutable
    structures.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有两种可能的含义：要么副作用在两边都执行，要么副作用在服务器上执行一次，然后结果值在两边之间共享。默认情况下，切片器会复制一些副作用，如打印，并避免复制可变结构的分配。
- en: 'Consider the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we compile and run the preceding code, it will print "Hello Opa!" on the
    server and the client both, but will create only one unique mutable variable called
    `counter` that is shared between the client and the server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并运行前面的代码，它将在服务器和客户端上打印 "Hello Opa!"，但只会创建一个唯一的可变变量 `counter`，该变量在客户端和服务器之间共享。
- en: 'But, we sometimes do want to duplicate the declaration on both sides. In that
    case, we can use the `@both_implem` directive. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们有时确实希望在两边都重复声明。在这种情况下，我们可以使用 `@both_implem` 指令。例如：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will create a mutable variable `counter` at the startup of the server and
    in each client.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在服务器启动时以及在每个客户端创建一个可变变量 `counter`。
- en: Module slicing
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块切片
- en: 'When a slicing annotation refers to a module, it becomes the default slicing
    annotation for its components, but can be overridden by annotating the component
    with another annotation. Consider the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当切片注释引用一个模块时，它成为其组件的默认切片注释，但可以通过对组件进行另一个注释来覆盖。考虑以下示例：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because we put `server` before the `Logic` module, function `f1` will end up
    on the server side. But we override the slicing annotation of function `f2` with
    `client`, so function `f2` will be on the client side. We invoke both `f1` and
    `f2` when the page is ready, `f1` will print **function1** on the server side
    while `f2` will print **function2** on the client side. The following screenshot
    shows the result as expected:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将 `server` 放在 `Logic` 模块之前，所以函数 `f1` 最终会在服务器端。但我们用 `client` 覆盖了函数 `f2` 的切片注解，所以函数
    `f2` 将在客户端。当页面准备就绪时，我们调用 `f1` 和 `f2`，`f1` 将在服务器端打印 **function1**，而 `f2` 将在客户端打印
    **function2**。以下截图显示了预期的结果：
- en: '![Module slicing](img/3749OS_05_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![模块切片](img/3749OS_05_02.jpg)'
- en: Expression slicing
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式切片
- en: 'Sometimes, we want to have a different behavior on the server and on the client.
    We can use the `@sliced_expr` directive to do this. Consider the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望在服务器和客户端有不同的行为。我们可以使用 `@sliced_expr` 指令来实现这一点。考虑以下示例：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code will print "server" on the server side and "client" on the
    client side.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在服务器端打印 "server"，在客户端打印 "client"。
- en: Client and server communication
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端和服务器通信
- en: 'Opa provides three primitives for communicating between clients and the server:
    session, cell, and network. We can use these three primitives to exchange messages
    between clients and servers.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Opa 提供了三个用于客户端和服务器之间通信的原语：会话、单元和网络。我们可以使用这三个原语在客户端和服务器之间交换消息。
- en: Session
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话
- en: A session is a one-way asynchronous communication between the client and the
    server. A session can be created on a server or on a client, and can be shared
    between several servers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是客户端和服务器之间的一种单向异步通信。会话可以在服务器或客户端创建，并且可以在多个服务器之间共享。
- en: To create a session, use either `Session.make` or `Session.NonBlocking.make`.
    The `Session.make` function creates a session that handles all messages in the
    background, but only one message at a time. This ensures absolute consistency
    on the state of the session, but may not be appropriate for all applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个会话，可以使用 `Session.make` 或 `Session.NonBlocking.make`。`Session.make` 函数创建一个会话，该会话在后台处理所有消息，但一次只处理一条消息。这确保了会话状态的绝对一致性，但可能不适合所有应用程序。
- en: 'In contrast, the `Session.NonBlocking.make` function creates a session that
    can handle any number of messages simultaneously. This ensures maximal responsiveness,
    but the message handler cannot be certain that it is holding the latest value
    of the state. Let''s have a look at how `Session.make` is declared:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`Session.NonBlocking.make` 函数创建的会话可以同时处理任意数量的消息。这确保了最大的响应性，但消息处理器不能确定它是否持有状态的最新值。让我们看看
    `Session.make` 是如何声明的：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first parameter `state` is the initial state of the session. The second
    parameter is a message handler for this session. The message handler will be invoked
    when messages are sent to this session. The return value of this function is a
    channel, which we can use to send messages to the session by using the `Session.send`
    function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数 `state` 是会话的初始状态。第二个参数是此会话的消息处理器。当向此会话发送消息时，将调用消息处理器。此函数的返回值是一个通道，我们可以使用
    `Session.send` 函数通过该通道向会话发送消息。
- en: 'Consider the following example: suppose we want to send a string to the server
    through a session such that if the state of this session is an odd number, then
    whatever we send to the server is printed in uppercase. In contrast, if the state
    of this session is even then we print in lowercase. The code is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：假设我们想通过会话向服务器发送一个字符串，如果此会话的状态是奇数，则我们发送给服务器的任何内容都将打印为大写。相反，如果会话的状态是偶数，则我们打印为小写。代码如下：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we compile and run the preceding code, then we will see the following result
    on the server:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并运行前面的代码，那么在服务器上我们将看到以下结果：
- en: '![Session](img/3749OS_05_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![会话](img/3749OS_05_03.jpg)'
- en: Cell
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元
- en: 'A cell is a session in which sending messages produces return values. It''s
    a two-way synchronous communication between the client and the server. We can
    create a cell with `Cell.make` and call it with `Cell.call`. In the following
    example, the cell does almost the same thing as we had described in the previous
    example, but it returns the string to the client instead of printing it on the
    server. Here is the code fragment:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单元是一个会话，其中发送消息会产生返回值。它是客户端和服务器之间的双向同步通信。我们可以使用 `Cell.make` 创建一个单元，并通过 `Cell.call`
    调用它。在以下示例中，单元几乎与我们在上一个示例中描述的相同，但它将字符串返回给客户端而不是在服务器上打印。以下是代码片段：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Network
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: A network is an infrastructure for broadcasting information to observers. Observers
    may be sessions or functions located on the same machine or on any client or server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是向观察者广播信息的基础设施。观察者可能位于同一台机器上，或者位于任何客户端或服务器上。
- en: We can create a network with the `Network.empty()` function or construct a network
    that is automatically shared between servers with the `Network.cloud(key)` function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Network.empty()` 函数创建一个网络，或者使用 `Network.cloud(key)` 函数构建一个在服务器之间自动共享的网络。
- en: We can observe a network with the `Network.observe(cb,network)` function, where
    `cb` is a callback function that is executed when a message is received on the
    network. To send a message to all observers of a network, use `Network.broadcast(msg,network)`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Network.observe(cb,network)` 函数观察一个网络，其中 `cb` 是一个回调函数，当网络接收到消息时执行。要向一个网络的全部观察者发送消息，请使用
    `Network.broadcast(msg,network)`。
- en: The following example is a very simple chat application; the client will observe
    the network when its page is ready, and it will broadcast a message when the send
    button is triggered. We will learn to build a more sophisticated web chat application
    in [Chapter 9](ch09.html "Chapter 9. Building a Chat Application"), *Building
    a Chat Application*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是一个非常简单的聊天应用；当客户端页面准备就绪时，它将观察网络，并在发送按钮被触发时广播一条消息。我们将在第 9 章 [构建聊天应用](ch09.html
    "第 9 章。构建聊天应用") 中学习如何构建一个更复杂的网络聊天应用。
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Compile and run the preceding code, then open the web application in several
    browsers. We can communicate between browsers by sending the messages that we
    input. Here is a screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行前面的代码，然后在几个浏览器中打开网络应用。我们可以通过发送我们输入的消息在浏览器之间进行通信。以下是截图：
- en: '![Network](img/3749OS_05_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![网络](img/3749OS_05_04.jpg)'
- en: Summary
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first talked about the Opa slicer. If we do not provide
    slicing information, the slicer will try to put the code on both sides whenever
    it is possible and will put the code on only one side when there is no way to
    put the code on both sides. When this automatic slicing is not enough, we can
    add slicing annotations (server, client, and both) before functions and modules
    to tell the slicer on which side we want our code to end. Then, we talked about
    the three primitives for communicating between clients and servers. Session is
    a one-way asynchronous communication, cell is a two-way synchronous communication,
    and network is for broadcasting messages to any number of observers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先讨论了 Opa 切片器。如果我们不提供切片信息，切片器会在可能的情况下尝试将代码放在两边，在没有办法将代码放在两边的情况下，则将代码放在一边。当这种自动切片不足以满足需求时，我们可以在函数和模块前添加切片注释（服务器、客户端和两者），以告诉切片器我们希望在哪个方面结束我们的代码。然后，我们讨论了客户端和服务器之间通信的三个原语。会话是一种单向异步通信，单元是双向同步通信，网络用于向任何数量的观察者广播消息。
