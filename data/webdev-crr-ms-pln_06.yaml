- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Exploring Modern Frontend Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索现代前端开发
- en: Okay, the last two chapters have in large part focused on the backend. Not exclusively,
    of course, since we touched on some things that aren’t backend, but largely. In
    this chapter, we’re going to jump with both feet back onto the frontend.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，前两章在很大程度上专注于后端。当然，我们当然也触及了一些非后端的内容，但主要还是集中在后端。在本章中，我们将全力以赴地回到前端。
- en: As far as the frontend goes, where are we so far? Well, you’ve gotten a pretty
    good look at HTML, CSS, and JavaScript, the basics of web development. Every web
    developer needs to know about these to be effective.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 就前端而言，到目前为止我们走到了哪里？嗯，您已经很好地了解了HTML、CSS和JavaScript，这些都是网络开发的基础。每个网络开发者都需要了解这些才能有效。
- en: But what would you think if I told you that, in most modern web development,
    you might not be working with them in exactly the form you’ve seen so far? In
    fact, in some cases, you might barely work with them at all. That would seem weird
    and contradictory, right?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我说，在大多数现代网络开发中，您可能不会以您迄今为止看到的形式使用它们，您会怎么想？实际上，在某些情况下，您可能几乎不会使用它们。这听起来是不是有点奇怪且矛盾？
- en: Alas, it is, to a large degree, the reality!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这在很大程度上是现实！
- en: In this chapter, we’re going to look at some technologies that are built *on
    top* of HTML, CSS, and JavaScript, in some cases extending them, and ultimately
    leading to a place where you aren’t working with plain old HTML, CSS, and JavaScript
    anymore. These include frameworks such as React, Angular, and Vue, frontend toolkits
    such as Bootstrap and Tailwind, and **TypeScript** (**TS**). You’ll also see how
    they have many benefits in terms of what you can deliver to your clients.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些建立在HTML、CSS和JavaScript之上，有时扩展它们的技术，最终达到一个您不再使用纯HTML、CSS和JavaScript工作的地方。这些包括如React、Angular和Vue这样的框架，以及Bootstrap和Tailwind这样的前端工具包，还有**TypeScript**（**TS**）。您还将看到它们在向客户交付内容方面具有许多优势。
- en: By the end, you’ll have a good understanding of why this trend of moving away
    from plain HTML, CSS, and JavaScript is so popular and so beneficial.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到最后，您将很好地理解为什么这种远离纯HTML、CSS和JavaScript的趋势如此流行且有益。
- en: 'So, we’ll cover the following main topics here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在此处涵盖以下主要主题：
- en: Abstracting away the basics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象化基础知识
- en: Meeting the modern frontend frameworks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向现代前端框架
- en: Boosting CSS capabilities
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升CSS功能
- en: Transpiling and data typing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转译和数据处理
- en: Packing up and going – bundlers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包和部署——打包器
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need the download the source code bundle from GitHub.
    Since I expect that you’ve already installed Node (and thus npm), that’s it! Everything
    you’ll need will be in the `ch-06` directory, ready to go.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要从GitHub下载源代码包。由于我预计您已经安装了Node（以及npm），所以这就足够了！您所需的一切都将位于`ch-06`目录中，随时可用。
- en: Abstracting away the basics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象化基础知识
- en: A long time ago, in an internet far, far away, developing websites was kind
    of a pain in the butt. You see, for a long time, browsers didn’t all work the
    same. You might write some HTML and have it look great in Netscape Navigator,
    but then find it didn’t look right in Internet Explorer. Or, you might write some
    JavaScript that worked perfectly in Internet Explorer but then caused an error
    in Opera. And CSS required all sorts of hacks to make it work even remotely the
    same across browsers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，在一个遥远的互联网上，开发网站有点痛苦。您知道，长期以来，浏览器的工作方式并不完全相同。您可能会编写一些HTML代码，在Netscape Navigator中看起来很棒，但然后在Internet
    Explorer中看起来就不对了。或者，您可能会编写一些在Internet Explorer中运行完美的JavaScript代码，但然后在Opera中引发了错误。而CSS则需要各种技巧才能在浏览器之间实现大致相同的效果。
- en: Today, we tend to write to standards, which are well-defined guidelines that
    browsers follow for how HTML, JavaScript, and CSS work. So long as you write to
    standards, and the browsers implement the standards properly, what you write will
    nearly always work the same across the major browsers at least.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们倾向于编写符合标准的内容，这些标准是浏览器遵循的、关于HTML、JavaScript和CSS如何工作的明确指南。只要您编写的内容符合标准，并且浏览器正确地实现了这些标准，您编写的内容几乎总是可以在主要浏览器中保持一致。
- en: But it wasn’t always like that, not by a long shot.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并非一直如此，远非如此。
- en: Before standards were the order of the day, developers decided that building
    websites with plain HTML, JavaScript, and CSS wasn’t always the best experience.
    At that point, they started writing abstraction layers on top of HTML, JavaScript,
    and CSS. These came in the form of various JavaScript libraries that would do
    the work of creating the HTML, JavaScript, and CSS for you in effect. And they
    did so intelligently, meaning if they saw you were running in Internet Explorer,
    they knew how to output the right code for it, but could then output the right
    code for Netscape when running in that browser (don’t worry if you’ve never even
    heard of Netscape – it’s a long-defunct browser that was popular in the early
    days of the web – that is, the late 1990s and early 2000s).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准成为主流之前，开发者认为使用纯HTML、JavaScript和CSS构建网站并不总是最佳体验。在那个阶段，他们开始在HTML、JavaScript和CSS之上编写抽象层。这些以各种JavaScript库的形式出现，实际上为你创建HTML、JavaScript和CSS。它们这样做是智能的，意味着如果它们看到你在Internet
    Explorer中运行，它们知道如何为它输出正确的代码，但然后在Netscape浏览器中运行时可以输出正确的代码（如果你从未听说过Netscape，请不要担心——它是一个在互联网早期非常流行的已停用的浏览器——也就是说，在20世纪90年代末和21世纪初）。
- en: 'The goal of these abstractions is primarily threefold:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些抽象的目标主要是三方面的：
- en: One is that they allow you to write less code! If there is a single function
    you can call that will produce a UI with a button and some text that the button
    can collapse and expand, then that’s a lot less code you have to write – a lot
    less custom HTML, CSS, and JavaScript that you could get wrong.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中之一是它们允许你编写更少的代码！如果你可以调用一个函数来生成一个带有按钮和一些文本的UI，按钮可以展开和折叠，那么你就不必编写那么多的代码——远比你可能出错的自定义HTML、CSS和JavaScript要少得多。
- en: Following on from the previous point, writing less code yourself means you can
    deliver results quicker. Not having to write all that expand/collapse code yourself
    saves time, which clients tend to like.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于前面的观点，编写更少的代码意味着你可以更快地交付结果。不必自己编写所有那些展开/折叠代码可以节省时间，客户通常都喜欢这一点。
- en: The third key benefit is that shared code tends to be more robust code. If you
    use code that someone else wrote, and there are a lot of other people out there
    using it too, then there is a good chance that code is very sound, error-free,
    performs well, and is just generally problem-free.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三大关键好处是共享代码往往更健壮。如果你使用别人写的代码，而且有很多人也在使用它，那么代码很可能非常可靠，没有错误，性能良好，并且通常没有问题。
- en: One of the biggest names ever in the area of abstractions was, and in some places
    still is, jQuery. It could be argued that the World Wide Web wouldn’t have become
    what it is today without jQuery, a JavaScript library that provides a long list
    of functions designed to work across all supported browsers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象领域，jQuery曾经是最大的名字之一，而且在某些地方至今仍然是。可以争辩说，没有jQuery，一个提供了一系列旨在跨所有支持浏览器工作的函数的JavaScript库，万维网今天可能不会成为现在这个样子。
- en: 'For example, in plain JavaScript, you can get a reference to a DOM node with
    this code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在纯JavaScript中，你可以使用以下代码获取DOM节点的引用：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you have a `<div id="mySpecialDiv">` element on the page, then the `node`
    variable will reference it and you can manipulate it in various ways. While that
    is a common, fully cross-browser function today, it wasn’t always. At one point,
    you might have to write different code for different browsers, and someone would
    have to determine which code to execute when needed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你页面上有一个`<div id="mySpecialDiv">`元素，那么`node`变量将引用它，你可以以各种方式操作它。虽然这在今天是一个常见的、完全跨浏览器的功能，但并非总是如此。在某个时刻，你可能不得不为不同的浏览器编写不同的代码，而且有人必须确定在需要时执行哪种代码。
- en: 'But, enter jQuery, and you could write something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，随着jQuery的出现，你可以编写类似以下这样的代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `$()` function – yes, `$` is a valid function name in JavaScript, despite
    it not looking like any of the function names you’ve seen to this point and it
    just being a single non-alphanumeric character – is provided by jQuery (if you
    import jQuery into your page that is, and it’s just a JavaScript file, so that’s
    easy enough) and it took care of whatever differences the browsers may have. With
    jQuery, that line of code works in all supported browsers equally, and you don’t
    have to worry about how one browser does things versus another because jQuery
    handles all that for you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`$()`函数——是的，`$`在JavaScript中是一个有效的函数名，尽管它看起来不像你之前见过的任何函数名，而且它只是一个单个的非字母数字字符——是由jQuery提供的（如果你将jQuery导入到你的页面中，那只是一个JavaScript文件，所以这很容易做到），并且它处理了浏览器可能存在的任何差异。有了jQuery，那行代码在所有支持的浏览器中都能正常工作，你不必担心一个浏览器如何处理事情与另一个浏览器相比，因为jQuery为你处理了所有这些。'
- en: 'jQuery is a library and a small one at that. But what does the word library
    mean in this context? And what does it mean compared to the terms framework and
    toolkit, which are commonly spoken about in software development in general, which
    of course includes web development? We can break it down like so:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个库，而且是一个小库。但在这个语境下，“库”这个词是什么意思？与通常在软件开发中（当然包括Web开发）广泛讨论的框架和工具包相比，它意味着什么？我们可以这样分解：
- en: A *library* is a collection of functions and callable routines that can be written
    in any language. With a library, you are in command of the flow and structure
    of your application, and you use the library only when you need it. Your code
    always calls the library.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库**是一组可以写成任何语言的函数和可调用例程。使用库时，你掌握着应用程序的流程和结构，你只在需要时使用库。你的代码总是调用库。'
- en: A *framework*, on the other hand, provides the overall structure for your application.
    You have to fit your code into the structure the framework dictates (with varying
    degrees of rigidity, depending on the framework author’s basic thinking). The
    framework’s code controls the flow, at various points calling your code in response
    to various events.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，**框架**为你的应用程序提供整体结构。你必须将你的代码放入框架规定的结构中（根据框架作者的思维方式，这种结构的刚性程度有所不同）。框架的代码控制着流程，在各个点上根据各种事件调用你的代码。
- en: A *toolkit* is a set of tools or components for a specific domain. Most commonly,
    a toolkit refers to user interface components – things such as buttons, grids,
    progress bars, and other elements you might see in a user interface. In fact,
    in my experience, you will rarely see the word toolkit used in any context other
    than building interfaces.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具包**是一组针对特定领域的工具或组件。最常见的情况下，工具包指的是用户界面组件——比如按钮、网格、进度条以及其他你可能在用户界面中看到的元素。实际上，根据我的经验，你很少在其他语境下看到“工具包”这个词，除了在构建界面时。'
- en: The difference between the three ultimately comes down mostly to what’s most
    in control. If your code is calling on other code, then your code is in control,
    and that other code is, therefore, most likely a library or toolkit. If, on the
    other hand, the other code calls your code most of the time, then that other code
    is more in control, and there is then a good bet that it’s a framework.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这三者之间的区别最终主要取决于谁控制得更多。如果你的代码在调用其他代码，那么你的代码在控制，那么其他代码很可能是库或工具包。相反，如果其他代码大多数时候在调用你的代码，那么其他代码控制得更多，那么有很大可能是框架。
- en: 'To be sure, this is a borderline academic discussion: whether something is
    a library, framework, or toolkit isn’t usually something we need to worry about
    too much when developing a website. It’s worth understanding the difference, but
    at the end of the day, so long as a given thing helps us get our job done, then
    it can be whatever it wants to be!'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个边缘性的学术讨论：在开发网站时，我们通常不需要太担心某物是库、框架还是工具包。了解它们之间的区别是值得的，但最终，只要某个东西能帮助我们完成工作，那么它可以是它想成为的任何东西！
- en: But, with that said, it’s also worth noting that there is some overlap and even
    some degree of fungibility to these terms. You can easily find online debates
    about whether *X* or *Y* is a library or framework (toolkits tend to be a bit
    more obvious). It’s less important what they are and more important what they
    can do for you.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，话虽如此，也值得指出的是，这些术语之间有一些重叠，甚至有一定的可互换性。你很容易在网上找到关于*X*或*Y*是库还是框架（工具包通常更明显）的辩论。它们是什么并不那么重要，重要的是它们能为你做什么。
- en: 'Now, let’s meet three of the most popular frontend frameworks out there today:
    React, Angular, and Vue.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来认识一下目前最受欢迎的前端框架中的三个：React、Angular和Vue。
- en: Meeting the modern frontend tools
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面对现代前端工具
- en: Today, there is a bit of a schism in web development. There is a group of web
    developers who like the “vanilla” approach, which means you use HTML, CSS, and
    JavaScript, just as you’ve seen so far. On the other hand, there is another group
    that feels there are better answers at higher levels of abstraction. They feel
    that there is a lot of benefit to libraries, frameworks, and toolkits since they
    can do things such as smooth over browser differences (as the jQuery library does),
    or even save us from writing a lot of what would be complex HTML, CSS, and JavaScript,
    as the MUI toolkit does by providing a wealth of premade widgets to build interfaces
    with. There are pluses and minuses to both approaches, and there is no canonically
    *correct* answer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，在Web开发中存在一些分歧。有一群Web开发者喜欢“纯 vanilla”方法，这意味着你使用HTML、CSS和JavaScript，就像你之前看到的那样。另一方面，还有另一群人认为在更高层次的抽象中存在更好的答案。他们认为，由于它们可以做到像jQuery库那样平滑浏览器差异，或者像MUI工具包那样通过提供丰富的预制小部件来构建界面，因此库、框架和工具集有很多好处。两种方法都有优点和缺点，而且没有公认的正确答案。
- en: However, it’s not crazy to suggest that “team vanilla” is the smaller group
    these days, and the prevailing wisdom is that using modern libraries, frameworks,
    and toolkits is the better way to go in most ways. And, of course, even if you
    only ever use these things, you *still* need to know HTML, CSS, and JavaScript.
    That is foundational knowledge. These modern tools build on them, and extend them,
    but rarely replace them outright (you can find a few that do, but they tend to
    be the minority).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，提出“纯 vanilla 团队”现在是较小的群体并不疯狂，而且普遍的观点是，在大多数情况下，使用现代库、框架和工具集是更好的选择。当然，即使你只使用这些工具，你*仍然*需要知道HTML、CSS和JavaScript。这是基础知识。这些现代工具基于它们构建，并扩展它们，但很少完全取代它们（你可以找到一些这样的工具，但它们往往是少数）。
- en: So, what you’ve learned so far is in absolutely no way a wasted effort – it
    was *required* to be able to understand something such as React.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你到目前为止所学的绝对不是徒劳的努力——这是*必需的*，以便能够理解像React这样的东西。
- en: React above them all
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: React独占鳌头
- en: 'It may seem that I’m giving far more attention to React than any others, and
    that’s intentional: React is, by a fairly wide margin, the most popular frontend
    tool out there at the time of writing. It’s the one you’re most likely to use
    in most environments. It’s also arguably the simplest, and also in many regards
    looks similar to most others. While they’re all different, they have a common
    enough philosophy that I think if you understand React, then when and if you have
    to use something else, your React knowledge will provide a sufficient foundation
    to learn the other easily enough.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来我给React的关注比其他任何东西都要多，这是故意的：React在写作时，是相当广泛的前端工具中最受欢迎的。你很可能在大多数环境中都会使用它。它也是最具争议性的，而且在许多方面看起来与其他工具相似。虽然它们都不同，但它们有足够的共同哲学，我认为如果你理解React，那么当你需要使用其他东西时，React的知识将为你提供足够的基础，以便足够容易地学习其他工具。
- en: Meeting React
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面对React
- en: '**React** comes from our friends at Facebook (or our enemies – it seems everyone
    has an opinion about Facebook, and it tends to be pretty extreme one way or the
    other, rarely neutral). React is a library that focuses on building the user interface
    of websites, and little else. There is some degree of debate in development circles
    about whether React is a framework, but given that its creator calls it a library,
    I think we can reasonably go with that!'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**React** 来自我们的朋友Facebook（或者我们的敌人——似乎每个人都对Facebook有意见，而且往往非常极端，很少中立）。React是一个专注于构建网站用户界面的库，其他方面则很少涉及。在开发圈子里，关于React是否是一个框架，有一些争议，但鉴于其创造者称其为库，我认为我们可以合理地采用这种说法！'
- en: The underlying goal of React is to make it easy to reason about the state and
    structure of your interface at any given moment in time. What you see on the screen
    is a function of the underlying data – the state – that the UI is showing. It
    accomplishes this by way of components, which are essentially self-contained pieces
    of the interface. When you combine a whole bunch of components, you wind up with
    the overall interface, and a working website or web app ultimately, backed up
    by a set of data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: React的潜在目标是使你在任何给定时刻都能轻松地推理出界面的状态和结构。你屏幕上看到的是UI显示的底层数据——状态——的函数。它是通过组件实现的，组件本质上是无状态的界面部分。当你组合大量组件时，你最终得到的是整体界面，以及一个由数据支持的网站或Web应用程序。
- en: React uses a concept called the **virtual DOM**, or **VDOM**, to do all of this
    effectively. When you write code with React, you don’t work with the VDOM directly,
    but it’s always there. React uses it under the covers to make everything work,
    so what exactly is it?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: React使用一个称为虚拟DOM（VDOM）的概念来有效地完成所有这些。当你用React编写代码时，你并不直接与VDOM交互，但它始终存在。React在幕后使用它来使一切工作，那么它究竟是什么呢？
- en: You were introduced to the DOM earlier, that tree of elements that the browser
    creates from your markup, and which is manipulated by both code and events. When
    such changes occur, the browser must perform a lot of work, which can be intensive
    and expensive in terms of performance. Some changes don’t impact the flow, or
    structure, of the page, and are therefore less expensive. Something such as changing
    the color of existing text falls into this category. But something such as inserting
    a new `<div>` element into the page changes the flow – the structure of the DOM
    essentially – and as a result, the browser has to recalculate a lot before it
    can then repaint the screen. The DOM handles all of this, and depending on the
    type and degree of change, it can result in a sluggish, slow interface that doesn’t
    react immediately to user interactions, which isn’t a good thing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经接触过DOM了，这是浏览器从你的标记中创建的元素树，它既可以通过代码也可以通过事件进行操作。当发生这样的变化时，浏览器必须执行大量工作，这在性能上可能是密集和昂贵的。有些变化不会影响页面的流程或结构，因此成本较低。例如，改变现有文本的颜色就属于这一类。但是，像在页面上插入一个新的`<div>`元素这样的变化会改变流程——DOM的结构——因此，浏览器在重新绘制屏幕之前必须重新计算很多内容。DOM处理所有这些，根据变化类型和程度，可能会导致界面反应迟缓、缓慢，无法立即响应用户交互，这不是一个好现象。
- en: To deal with this problem, React introduces the concept of the VDOM. This is
    a secondary DOM that conceptually sits on top of the real DOM but is implemented
    in JavaScript. When something happens in React that requires the screen to be
    updated, rather than directly manipulating the real DOM immediately, the VDOM
    will be changed. This allows React to mediate and manage the changes to perform
    them more efficiently when they are ultimately done on the real DOM.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，React引入了VDOM的概念。这是一个概念上位于真实DOM之上但用JavaScript实现的二级DOM。当React中发生需要更新屏幕的事件时，而不是立即直接操作真实DOM，VDOM将被更改。这允许React进行调解和管理变化，以便在最终在真实DOM上执行时更加高效。
- en: React uses what’s called a diffing algorithm, which is code that compares the
    VDOM to the real DOM and collects a list of the differences. React is then able
    to make intelligent decisions about the minimum set of changes that have to be
    made to the real DOM and can do things such as batch them all together (which
    tends to be more efficient than doing them one by one), or defer them until no
    other events occur, generally trying to minimize the amount of changes that have
    to occur to the real DOM. In general, assuming everything is done right, this
    approach can yield better performance than always manipulating the real DOM directly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: React使用所谓的diffing算法，这是一种比较VDOM和真实DOM并收集差异列表的代码。然后React能够做出明智的决定，关于对真实DOM需要做出的最小更改集，并且可以执行诸如将它们全部批量处理（这通常比逐个处理更有效）或推迟到没有其他事件发生，通常试图最小化对真实DOM需要发生的变化的数量。一般来说，如果一切做得正确，这种方法可以比直接操作真实DOM提供更好的性能。
- en: A simple React example
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的React示例
- en: 'Let’s jump right into a React example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入一个React示例：
- en: '![Figure 6.1: Be it ever so humble – a (very) simple React example](img/B18315_06_1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：无论多么简陋——一个（非常）简单的React示例](img/B18315_06_1.jpg)'
- en: 'Figure 6.1: Be it ever so humble – a (very) simple React example'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：无论多么简陋——一个（非常）简单的React示例
- en: This example shows a friendly greeting and a button that increments a counter
    when clicked. It’s simple, but it’ll demonstrate the basics well enough. We’ll
    need to create three files – `react.html`, `react.js`, and `react-greeting.js`
    – which you can find in the `ch-06` directory of the download bundle after that.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一个友好的问候和一个点击时增加计数的按钮。它很简单，但足以演示基础知识。我们需要创建三个文件——`react.html`、`react.js`
    和 `react-greeting.js`——这些文件可以在下载包的 `ch-06` 目录中找到。
- en: 'Let’s start with `react.html` (and work on the other two files shortly):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `react.html` 开始（稍后也会处理其他两个文件）：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To run this, you’ll need to put it on a web server; otherwise, you’ll run into
    problems with something called `react.development.js` script here can be a problem
    if the `unpkg.com` domain doesn’t allow requests from domains other than `unpkg.com`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个，你需要将其放在一个 web 服务器上；否则，你可能会遇到与 `react.development.js` 脚本相关的问题，如果 `unpkg.com`
    域不允许来自除 `unpkg.com` 以外的域的请求，这可能会成为一个问题。
- en: Now, as it turns out in this case, that’s not a problem because `unpkg.com`
    is what’s known as a `react.html` in your browser, namely that it won’t allow
    the JavaScript imports from a `file://` scheme. When a site is hosted on a web
    server, the scheme that’s used is `http://` or `https://`, as we previously talked
    about. But when you just load a file from your local filesystem, the browser uses
    the `file://` scheme, and most browsers today will have CORS rules that won’t
    let the content be imported into the page if it doesn’t come from the local filesystem.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实际上在这个案例中，这并不是一个问题，因为 `unpkg.com` 是浏览器中所谓的 `react.html`，也就是说，它不会允许来自 `file://`
    方案的 JavaScript 导入。当一个网站托管在 web 服务器上时，使用的方案是 `http://` 或 `https://`，正如我们之前讨论过的。但是当你只是从本地文件系统中加载一个文件时，浏览器会使用
    `file://` 方案，而今天的大多数浏览器都会有 CORS 规则，如果内容不是来自本地文件系统，则不允许将其导入到页面中。
- en: To get around that, we need to put the files on a web server so that the `http://`
    scheme will be used instead, and the requests will then work. There are many ways
    you could do that, but one of the simplest is to use the `http-server` package,
    which is a Node package that implements a simple web server as an executable program
    without you having to write any code. You just run it, and it starts a web server
    that makes the files in the directory you run it from accessible via browser by
    default.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要将文件放在 web 服务器上，这样就会使用 `http://` 方案，然后请求就会工作。你可以用很多种方法来做这件事，但其中最简单的一种是使用
    `http-server` 包，这是一个 Node 包，它实现了一个简单的可执行程序形式的 web 服务器，你不需要编写任何代码。你只需运行它，它就会启动一个
    web 服务器，使得你运行它的目录中的文件可以通过浏览器默认访问。
- en: 'So, to get set up, you need to create an npm/Node project, which you already
    know how to do:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了设置环境，你需要创建一个 npm/Node 项目，这你已经知道如何做了：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You would do this in the `ch-06` directory (you’ll find it’s already been done;
    I’m just walking you through the steps I did already) and select all defaults
    as usual. Then, add the `http-server` package as a dev dependency:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在 `ch-06` 目录中这样做（你会发现它已经被完成了；我只是带你走过我已经走过的步骤）并选择所有默认选项。然后，将 `http-server`
    包添加为开发依赖项：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, go into the `ch-06` directory and start the server, like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入 `ch-06` 目录并启动服务器，如下所示：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, you will be able to access the `react.html` file, like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你将能够访问 `react.html` 文件，如下所示：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see something like what’s shown in *Figure 6**.2* in your console:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在控制台中看到类似 *图6.2* 中所示的内容：
- en: '![Figure 6.2: http-server, up and running, serving files](img/B18315_06_2.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：http-server 已启动并运行，正在服务文件](img/B18315_06_2.jpg)'
- en: 'Figure 6.2: http-server, up and running, serving files'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：http-server 已启动并运行，正在服务文件
- en: Now that you have it running, let’s take a look at the HTML file and see what’s
    going on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经运行起来了，让我们来看看 HTML 文件，看看发生了什么。
- en: 'First, we have three JavaScript files that have been imported:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有三个已经被导入的 JavaScript 文件：
- en: '`react.development.js` is React itself, and the development part indicates
    that this is a version suitable for development. There is also a non-development
    version, which is meant for when you deploy your site for real, and the difference
    is that the version will be reduced in size and obfuscated in a process called
    **minification**. Not only does this process reduce the size, but it also alters
    the code into a form that is more efficient, but also harder to debug. Once your
    site is fully working with the development version, that’s not a problem and it’ll
    be more important to have the more efficient version running.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react.development.js` 是React本身，开发部分表示这是一个适合开发的版本。还有一个非开发版本，它适用于你真正部署网站时，区别在于版本将减小大小并在称为**最小化**的过程中混淆。这个过程不仅减小了大小，而且还将代码转换成更高效的形式，但同时也更难调试。一旦你的网站完全使用开发版本运行，那就没问题了，更重要的是要有一个更高效的版本在运行。'
- en: '`react-dom.development.js` is a helper library that React uses to interface
    with the browser itself. Both are needed to use React in any meaningful way.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-dom.development.js` 是React用来与浏览器本身交互的辅助库。两者都是使用React的必要条件。'
- en: '`babel.min.js` is the in-browser version of something called Babel. That’s
    a topic I’ll be covering in the *Transpiling and data typing* section later, but
    in short, it’s a library that can take code in one form and convert it into another.
    In this case, it will be converting something called JSX into plain old JavaScript.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babel.min.js` 是Babel的浏览器版本。这是一个我将在后面的*转换和数据类型*部分讨论的主题，但简而言之，它是一个可以将一种形式的代码转换为另一种形式的库。在这种情况下，它将把称为JSX的内容转换为普通的JavaScript。'
- en: 'Although it’s not what we’re primarily concerned with here, I’d be remiss if
    I didn’t mention the URLs that you see for these. As I mentioned earlier, these
    three files come from the [unpkg.com](http://unpkg.com) CDN. This is a popular
    site that hosts all sorts of libraries, frameworks, and toolkits. It hosts everything
    that can be found on npmjs.org, which is where npm gets everything you install
    from. The way you use it is to specify a URL in the general form:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是我们这里主要关注的内容，但如果我不提一下你看到的这些URL，那我就失职了。正如我之前提到的，这三个文件来自[unpkg.com](http://unpkg.com)
    CDN。这是一个流行的网站，托管了各种库、框架和工具包。它托管了在npmjs.org上可以找到的所有内容，这也是npm获取你安装的所有内容的地方。你使用它的方式是指定一个通用的URL形式：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This way, you can get a copy of anything you want, and any version of it you
    want, without having to install it locally. This can not only be faster because
    CDNs like this will have multiple servers all around the world and will route
    requests to the nearest one for speed, but it also makes getting examples like
    this, or indeed real projects, up and running quickly and easily since you don’t
    have to worry about getting the dependencies yourself. It’s just another tool
    in the toolbox to be aware of.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以获取任何你想要的任何版本，而不需要本地安装它。这不仅可能更快，因为像这样的CDN将在世界各地有多个服务器，并将请求路由到最近的那个服务器以提高速度，而且它还使得像这样的示例或真实项目能够快速轻松地启动运行，因为你不必担心自己获取依赖项。这只是工具箱中需要了解的另一个工具。
- en: Our first component – RootComponent
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们的第一个组件 – RootComponent
- en: 'After the three imports are done, it’s just a simple HTML `<body>` with a single
    `<div>`. This is where React will create our app, where it will generate HTML
    and insert it (as well as CSS and JavaScript). But the app is defined in a second
    file, the `react.js` file, which is imported right after that `<div>`. Without
    it, we’d just have a blank page! So, let’s look at it now:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成三个导入后，它只是一个简单的HTML `<body>`，其中包含一个单独的`<div>`。这是React创建我们的应用的地方，它将生成HTML并将其插入（以及CSS和JavaScript）。但应用是在第二个文件中定义的，即`react.js`文件，它紧随`<div>`之后导入。没有它，我们只会得到一个空白页面！所以，让我们现在看看它：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Every React app begins with a single root component. It can be the only component
    sometimes, though that doesn’t use the full power of React, which is building
    up an interface from several components.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个React应用都以一个单一的根组件开始。有时它可能只是唯一的组件，但这并不完全利用React的强大功能，即通过多个组件构建界面。
- en: 'A component can take a couple of different forms, but here, I’m focusing on
    the new form, which is generally considered better these days: functional components.
    In short, you have a JavaScript function that’s defined using arrow notation where
    a variable references `RootComponent`. That variable becomes a tag you can use
    later, as you’ll see shortly.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以采取几种不同的形式，但在这里，我专注于新的形式，这在当今通常被认为更好：函数式组件。简而言之，你有一个使用箭头符号定义的 JavaScript
    函数，其中变量引用 `RootComponent`。该变量成为你可以稍后使用的标签，正如你很快就会看到的。
- en: 'The job of any React component is to return HTML that is shown on the page.
    With a functional component, you simply return that markup from the function itself.
    How you return the markup is entirely up to you, but perhaps the most common form
    is shown here: JSX.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 React 组件的职责是返回页面显示的 HTML。使用函数式组件，你只需从函数本身返回该标记。你如何返回标记完全取决于你，但最常见的形式如下所示：JSX。
- en: JSX
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSX
- en: 'Inside the function that is our root component, you return the markup for the
    component, which can be any HTML you wish. But you may be looking at that code
    thinking something doesn’t look quite right, and you’re right: it’s not valid
    JavaScript!'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的根组件的函数内部，你返回组件的标记，可以是任何你想要的 HTML。但你可能正在看这段代码，觉得有些不对劲，你是对的：这不是有效的 JavaScript！
- en: Instead, this is another language called JSX, which is an extended version of
    JavaScript where you can embed HTML in it. That may sound weird, but it makes
    for much simpler code. Without JSX, what you see here would require several dozen
    lines of somewhat complex JavaScript code to build up the HTML that is returned
    by the function. Instead, with JSX, we can just write (a form of) HTML and the
    Babel import from earlier will convert it into JavaScript that calls on React
    functions to produce the HTML, CSS, and JavaScript for this component.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这是一种名为 JSX 的另一种语言，它是 JavaScript 的扩展版本，其中你可以嵌入 HTML。这听起来可能有些奇怪，但它使得代码更加简单。没有
    JSX，这里看到的内容需要几十行相对复杂的 JavaScript 代码来构建函数返回的 HTML。相反，有了 JSX，我们只需编写（一种形式的）HTML，之前导入的
    Babel 将将其转换为调用 React 函数以生成此组件的 HTML、CSS 和 JavaScript 的 JavaScript 代码。
- en: The markup that’s returned is fairly simple. It’s just a `<div>` element with
    a `<GreetingComponent>` element (whatever that is – we’ll get to that soon), a
    `<button>` element, and a `<p>` element in it. The `<button>` element has an `onClick`
    handler, but the syntax there is different than you’ve seen before. With JSX,
    the values of HTML tag properties must be enclosed in braces, not quotes like
    you’ve seen before. The value is a JavaScript function that, when called, calls
    the `setCount()` function, passing it the value of the `count` variable incremented
    by one. Inside the `<p>` element, there is some static text, and then a JSX expression.
    As with interpolated strings, which I’ve talked about before, JSX allows you to
    insert the value of JavaScript expressions into the markup to be returned. Here
    is the value of the `count` variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的标记相当简单。它只是一个包含 `<GreetingComponent>` 元素（无论是什么——我们很快就会了解到）、一个 `<button>` 元素和一个
    `<p>` 元素的 `<div>` 元素。该 `<button>` 元素有一个 `onClick` 处理器，但那里的语法与之前看到的不同。在 JSX 中，HTML
    标签属性的值必须用大括号括起来，而不是像之前看到的那样用引号。该值是一个 JavaScript 函数，当被调用时，会调用 `setCount()` 函数，并将
    `count` 变量的值加一后传递给它。在 `<p>` 元素内部，有一些静态文本，然后是一个 JSX 表达式。与之前提到的插值字符串一样，JSX 允许你将
    JavaScript 表达式的值插入到要返回的标记中。以下是 `count` 变量的值。
- en: Now, I’ve skipped over a couple of things here, so let’s talk about them now,
    starting with that line of code before the `return` statement that implements
    something called state in our component.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我在这里跳过了一两个东西，所以让我们现在谈谈它们，从 `return` 语句之前的那个实现我们组件中所谓的状态的代码行开始。
- en: Component state
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组件状态
- en: React components can – but don’t *have* to – have state. That’s just a fancy
    way of saying it has data internal to it. Generally speaking, state can’t be touched
    from outside the component. There are many, many options for implementing state
    in a component, but the key thing that has to happen is inherent in the name React
    itself.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件可以——但不必——有状态。这只是说它内部有数据的一种花哨说法。一般来说，状态不能从组件外部触摸。在组件中实现状态有许多许多选项，但关键的事情与
    React 本身的名字相符。
- en: The name React comes from the fact that the UI you build with it is *reactive*,
    meaning it changes as data changes, whether triggered by user interaction or not.
    For example, since this app shows a counter and a button to increment it, we want
    the counter value to be updated on the screen when the user presses the button.
    In a web app using plain JavaScript, HTML, and CSS, you can imagine code that
    executes when the button is clicked which increments a JavaScript variable and
    then uses DOM methods to update the screen. But with React, much of that happens
    automatically, and it’s based on the notion of state.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: React 这个名字来源于你用它构建的 UI 是 *响应式* 的，这意味着数据变化时它会改变，无论是由用户交互触发的还是不是。例如，由于这个应用程序显示了一个计数器和用于增加它的按钮，我们希望在用户按下按钮时屏幕上的计数器值被更新。在一个使用纯
    JavaScript、HTML 和 CSS 的 Web 应用程序中，你可以想象当按钮被点击时执行的代码，该代码增加一个 JavaScript 变量，然后使用
    DOM 方法更新屏幕。但是，使用 React，其中许多事情都是自动发生的，并且它基于状态的概念。
- en: When the state of a component – the data internal to it – changes, React will
    destroy the component and r-create it, which means the function you write is executed
    again to produce new markup which will use the new state data. The web app *reacts*
    to the change, in other words, without you directly updating the screen in code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件的状态——其内部的数据——发生变化时，React 将销毁该组件并重新创建它，这意味着你编写的函数将再次执行以产生新的标记，该标记将使用新的状态数据。换句话说，Web
    应用程序 *响应* 变化，无需你直接在代码中更新屏幕。
- en: So, React has to be aware of the internal state data of a component because
    it has to monitor it for changes so that it knows when to destroy and re-create
    the component. Therefore, we can’t (usually) just have plain old JavaScript variables
    in there because React wouldn’t know about them. Instead, we have to create those
    variables in a way that makes React aware of them, and that’s what the call to
    `React.useState()` does.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，React 必须知道组件的内部状态数据，因为它必须监控这些变化，以便知道何时销毁和重新创建组件。因此，我们通常不能（通常）只在那里使用普通的 JavaScript
    变量，因为 React 不会知道它们。相反，我们必须以让 React 意识到它们的方式创建这些变量，这正是调用 `React.useState()` 所做的。
- en: 'We pass to it any JavaScript value we wish – in this case, just a number –
    and `React.useState()` returns a value that is two things: the current state of
    our new state variable, and a function to use to update it. It’s effectively that
    update function that makes React aware of changes: any time we call it, React
    knows the state of our component has changed, and it can decide whether the component
    needs to be destroyed and re-created or not.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给它任何我们想要的 JavaScript 值——在这个例子中，只是一个数字——然后 `React.useState()` 返回一个值，这个值包含两件事：我们新状态变量的当前状态，以及一个用于更新它的函数。实际上，正是这个更新函数让
    React 意识到变化：每次我们调用它时，React 就知道我们组件的状态已经改变，并且它可以决定组件是否需要被销毁并重新创建。
- en: 'Since we want to have a reference to both of the things returned by that call,
    we use a JavaScript capability called `const [ count, setCount ]` part of the
    line is for. When executed, it results in two variables being created, one named
    `count` and another named `setCount`. The `count` variable gets the current value
    we set in the state, which is 0, and the second gets a reference to the `update`
    function. Destructuring is a feature that allows you to copy the values from arrays
    or properties from objects into distinct variables. Without it, the code you would
    have to write to get the values from the array returned by `React.useState(0);`
    would be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要引用那个调用返回的两个东西，我们使用 JavaScript 的一种能力，即 `const [ count, setCount ]` 这部分是用于的。当执行时，它会导致创建两个变量，一个名为
    `count`，另一个名为 `setCount`。`count` 变量获取我们在状态中设置的当前值，即 0，而第二个获取对 `update` 函数的引用。解构赋值是一种允许你将值从数组复制到数组或从对象复制到对象的特性。没有它，你需要编写的代码来从
    `React.useState(0);` 返回的数组中获取值将如下所示：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Destructuring is just a shorter way of writing that code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值只是编写代码的一种更简洁的方式。
- en: 'Having those variables available allows us to write the `onClick` handler on
    the `<button>` element now: the `setCount()` function is called, passing in the
    new value for the state variable, which is just `count+1`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些变量可用，我们现在可以在 `<button>` 元素上编写 `onClick` 处理器：调用 `setCount()` 函数，传入状态变量的新值，即
    `count+1`。
- en: React will decide that the component should be destroyed and recreated, so our
    function will be called again, and new markup will be returned. This time, notice
    that inside `<p>` is the `{count}` expression. This means that the current value
    of our state variable, `count`, will be inserted, so we’d see 1 on the screen
    after the first button click. It’s important to understand that state variables
    remain between component destruction and recreation. So, what’s returned by the
    call to `React.useState()` when the component is recreated won’t be 0, despite
    that being the value passed to it, because React will already be aware of this
    state variable and will have already created it with the default value when `React.useState()`
    was first called. So, it will return the current value, not the default value.
    It won’t recreate the component’s state – in other words, it’ll be kept no matter
    how many times the component is destroyed and recreated.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: React将决定组件应该被销毁并重新创建，因此我们的函数将被再次调用，并返回新的标记。这次，注意在`<p>`内部是`{count}`表达式。这意味着我们的状态变量`count`的当前值将被插入，所以第一次点击按钮后，屏幕上会显示1。重要的是要理解状态变量在组件销毁和重新创建之间保持不变。因此，当组件被重新创建时，调用`React.useState()`返回的不会是0，尽管传递给它的值是0，因为React已经知道这个状态变量，并在第一次调用`React.useState()`时已经用默认值创建了它。所以，它会返回当前值，而不是默认值。它不会重新创建组件的状态——换句话说，无论组件被销毁和重新创建多少次，它都会被保留。
- en: The final line of code here – the call to `ReactDOM.render()` – is what creates
    our interface. This kind of code is often termed *bootstrapping*, meaning it’s
    where the work begins, or where everything is kicked off from more colloquially.
    We pass to it the React component that is to be the root component of our app,
    and then a reference to the DOM node where it should be inserted. Look back on
    the HTML and you’ll recognize the `<div>` element with an ID of root. Whatever
    markup this root component returns will be inserted into that `<div>`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里代码的最后一行——调用`ReactDOM.render()`——是创建我们界面的关键。这类代码通常被称为*引导加载*，意味着这是工作开始的地方，或者更通俗地说，是一切启动的地方。我们传递给它的是将成为我们应用根组件的React组件，然后是它应该插入的DOM节点的引用。回顾一下HTML，你会认出具有ID为root的`<div>`元素。无论这个根组件返回什么标记，都会插入到这个`<div>`中。
- en: Now, what’s the deal with `<GreetingComponent>`? That’s not a real HTML tag!
    Well, it *could* be – you don’t know all HTML tags, after all – but it’s not,
    and the deal with it is that it’s another React component that I’ve created and
    it’s the one responsible for showing the greeting.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于`<GreetingComponent>`是怎么回事呢？这并不是一个真正的HTML标签！好吧，它*可能*是——毕竟，你不知道所有的HTML标签——但它不是，而且它与它有关的是，它是我创建的另一个React组件，它负责显示问候语。
- en: Adding another component – GreetingComponent
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加另一个组件——GreetingComponent
- en: You’ll notice that `GreetingComponent` was imported into `react.html` before
    `react.js` was. This is important in that it has to be imported before it’s referenced
    in `react.js`; otherwise, when it’s referenced in `react.js`, we’d get a JavaScript
    error about it being undefined.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`GreetingComponent`是在`react.js`之前导入到`react.html`中的。这很重要，因为它必须在`react.js`中引用它之前导入；否则，当在`react.js`中引用它时，我们会得到一个关于它未定义的JavaScript错误。
- en: 'So, what does the code for that component look like? It’s quite simple, and
    it’s in the `react-greeting.js` file, which is the third of the three imported
    into the `index.html` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，那个组件的代码是什么样的呢？它相当简单，位于`react-greeting.js`文件中，这是三个导入到`index.html`文件中的第三个：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time, no state is needed, so it’s nothing but a return statement returning
    some plain old HTML. The only thing of real note is the value of the style attribute.
    Normally, this would be something like `"color:red;"`, but since our components
    are written using JSX, that won’t work. Instead, we need to use the brace syntax,
    and then we list out the style attributes to set, which is just the color of the
    text set to red.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，不需要状态，所以只是一个返回语句返回一些普通的HTML。真正值得注意的是style属性值。通常，这可能是`"color:red;"`这样的东西，但由于我们的组件是用JSX编写的，所以这不会起作用。相反，我们需要使用花括号语法，然后列出要设置的样式属性，这仅仅是文本颜色设置为红色。
- en: But I seem to have glossed over something, haven’t I? What’s that `textColor`
    stuff all about? That gets into another core concept of React named props.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但我似乎忽略了一些东西，不是吗？那个`textColor`是什么意思？这涉及到React的另一个核心概念，即props。
- en: Props
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表扬
- en: Props are the basic mechanism by which components can pass information to one
    another. Props always work from parent to child, meaning in our case that the
    root component can pass information to `GreetingComponent` since it’s the child
    of the root component, but not vice versa.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Props是组件之间传递信息的基本机制。Props总是从父组件到子组件工作，意味着在我们的例子中，根组件可以向`GreetingComponent`传递信息，因为它是根组件的子组件，但反之则不然。
- en: Props are simply attributes on the tags for the custom components you create,
    which is why you can write `<GreetingComponent textColor="red" />`. Since the
    `GreetingComponent` function has an object with a `textColor` attribute in its
    signature, that’s enough for React to know that’s a valid prop that can be passed
    into `GreetingComponent`. Inside the function, you can access the `textColor`
    variable as you can any JavaScript variable, so we can insert it into the style
    attribute, as shown in this code. This way, our parent component (`RootComponent`)
    can tell `GreetingComponent` what color to make the text.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Props是您为自定义组件创建的标签上的属性，这就是为什么您可以编写`<GreetingComponent textColor="red" />`。由于`GreetingComponent`函数的签名中有一个带有`textColor`属性的object，这足以让React知道这是一个有效的prop，可以被传递给`GreetingComponent`。在函数内部，您可以像访问任何JavaScript变量一样访问`textColor`变量，因此我们可以将其插入到style属性中，如所示代码。这样，我们的父组件（`RootComponent`）就可以告诉`GreetingComponent`文本的颜色。
- en: Components can be as simple or as complex as you need them to be, can have as
    many props as you need (or none at all), and can have state (or not). But the
    whole point of React, and almost any modern frontend framework, is to compose
    your UI from many small components. This makes testing them easier and allows
    you to build complex interfaces with components that you can reuse many times,
    saving time as you progress.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以像您需要的那么简单或复杂，可以拥有您需要的属性数量（或完全没有），并且可以有状态（或没有）。但React以及几乎所有现代前端框架的整个要点是从许多小的组件中组合您的UI。这使得测试它们变得更容易，并允许您使用可以多次重用的组件构建复杂的界面，随着项目的进展节省时间。
- en: As neat as React is, sometimes, it’s not quite enough, and that’s where something
    called a meta framework comes in.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管React非常整洁，但有时它可能还不够，这就是所谓的元框架发挥作用的地方。
- en: Meta frameworks
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元框架
- en: A **meta framework** is a framework that enhances other frameworks, sometimes
    combining multiple frameworks (or libraries or toolkits). It builds on top of
    another framework or platform, providing more capabilities, often in the form
    of automatic code generation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**元框架**是一种增强其他框架的框架，有时会结合多个框架（或库或工具包）。它建立在另一个框架或平台之上，提供更多功能，通常以自动代码生成的方式提供。'
- en: In short, meta frameworks try to save you time by doing things such as supplying
    intelligent defaults for configuration and capabilities such as the ability to
    read in plain text files and generate a complete website from them. They can save
    a great deal of time and effort, with the main trade-off being a bit less developer
    control.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，元框架试图通过提供智能默认配置和功能，如读取纯文本文件并从中生成完整网站的能力等方式来节省您的时间。它们可以节省大量的时间和精力，主要的权衡是开发者控制度略有降低。
- en: There are many meta frameworks, but one of the most popular is Next, built on
    top of React.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多元框架，但其中最受欢迎的是Next，它是建立在React之上的。
- en: You have to remember that React is a pretty simple library. It provides the
    basic structure that components must follow, state and props, and a well-defined
    life cycle that all React apps and components go through. However, building a
    more complex web app will often require a lot more capabilities, all of which
    can be added to React piecemeal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须记住，React是一个非常简单的库。它提供了组件必须遵循的基本结构，状态和props，以及所有React应用和组件都会经历的良好定义的生命周期。然而，构建更复杂的Web应用通常需要更多的功能，所有这些都可以逐步添加到React中。
- en: 'So, instead, you can use something such as Next, which adds a great many of
    them in for you at once, including the initial project setup. Some of the key
    things that Next adds on top of React are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以使用像Next这样的工具，它一次为您添加了许多功能，包括初始项目设置。Next在React之上添加的一些关键功能如下：
- en: '*Server-side rendering (SSR)*: Next allows React components to be rendered
    on the server, improving initial load times and **search engine optimization**
    (**SEO**, the art of getting as high as possible in search engine results).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务器端渲染（SSR）*：Next允许React组件在服务器上渲染，提高初始加载时间并**优化搜索引擎排名**（**SEO**，即尽可能在搜索引擎结果中排名靠前）。'
- en: '*Static site generation (SSG)*: You can pre-render pages at build time rather
    than at runtime, which is great for performance and SEO.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态站点生成（SSG）*：您可以在构建时而不是在运行时预渲染页面，这对于性能和 SEO 来说非常好。'
- en: '*File-based routing*: Next uses a filesystem-based routing mechanism. Pages
    are automatically routed based on their filenames in a specified directory. This
    provides a common structure and navigational model to your website automatically.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于文件的路由*：Next 使用基于文件系统的路由机制。页面会根据指定目录中文件的名称自动进行路由。这为您的网站自动提供了一种常见的结构和导航模型。'
- en: '*API routes*: This allows you to create API endpoints as part of your Next
    application. This is useful for building full-stack applications with a unified
    codebase.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*API 路由*：这允许您在 Next 应用程序中创建 API 端点。这对于使用统一代码库构建全栈应用程序非常有用。'
- en: '*Zero configuration*: Next works out-of-the-box with minimal setup, yet it’s
    highly configurable for more complex needs.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*零配置*：Next 无需太多设置即可直接使用，但对于更复杂的需求，它也高度可配置。'
- en: '*Automatic code splitting*: Next automatically splits code into manageable
    chunks, loading only what’s necessary for the current page, which enhances performance.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动代码拆分*：Next 自动将代码拆分为可管理的块，仅加载当前页面所需的代码，这提高了性能。'
- en: '*Built-in CSS and Sass support*: Next has built-in support for CSS and Sass
    (an extended form of CSS), allowing you to import styles directly into your components.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内置 CSS 和 Sass 支持*：Next 内置了对 CSS 和 Sass（CSS 的扩展形式）的支持，允许您直接将样式导入到组件中。'
- en: '*Image optimization*: Next includes automatic image optimization for better
    performance.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图像优化*：Next 包含自动图像优化，以获得更好的性能。'
- en: Next adds all of this, and more, to React, saving you the hassle of adding it
    all yourself. Therefore, it is the quintessential meta framework, making use of
    many other libraries and frameworks to deliver these abilities.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Next 添加了所有这些功能，甚至更多，从而为您节省了手动添加所有这些功能的麻烦。因此，它是一个典型的元框架，利用了许多其他库和框架来提供这些能力。
- en: 'Now, let’s look at a competitor to React, another relatively small library
    that has gained a lot of traction quickly: Vue.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 React 的一个竞争对手，另一个相对较小的库，它迅速获得了大量关注：Vue。
- en: Meeting Vue
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Vue
- en: '**Vue**, created by Evan You and first released in 2014, is a JavaScript library
    that’s used for building user interfaces and SPAs. It is designed to be incrementally
    adoptable, meaning it can be easily integrated into projects where jQuery or another
    library is already in use, or it can be used to build more sophisticated applications
    when combined with modern tooling and supporting libraries.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vue**，由 Evan You 创建，并于 2014 年首次发布，是一个用于构建用户界面和单页应用的 JavaScript 库。它被设计为可增量采用，这意味着它可以轻松地集成到已经使用
    jQuery 或其他库的项目中，或者当与现代化工具和支持库结合使用时，可以用于构建更复杂的应用程序。'
- en: 'Some of Vue’s core features are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 的核心特性如下：
- en: '*Reactive and composable view layer*: At its core, Vue focuses on the view
    layer – that is, the user interface. It supplies a reactive way to render data
    to the DOM using straightforward template syntax, meaning that like React, it
    knows when to re-draw parts of the page when state changes, and the components
    you build use a simple string-based markup generation approach.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*响应式和可组合的视图层*：Vue 的核心关注点在于视图层——即用户界面。它通过简单的模板语法提供了一种将数据渲染到 DOM 的响应式方式，这意味着它就像
    React 一样，知道何时在状态变化时重新绘制页面的一部分，并且您构建的组件使用基于简单字符串的标记生成方法。'
- en: '*Component-based architecture*: Vue encourages the use of components to build
    UIs. Each component in Vue is essentially a reusable instance with data, methods,
    and life cycle events.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件化架构*：Vue 鼓励使用组件来构建 UI。Vue 中的每个组件本质上都是一个具有数据、方法和生命周期事件的可重用实例。'
- en: '*Directives*: Vue uses special attributes, known as directives, to provide
    added functionality to existing HTML elements – for example, `v-if` for conditional
    rendering and `v-on` for handling events.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指令*：Vue 使用称为指令的特殊属性来为现有的 HTML 元素提供附加功能——例如，`v-if` 用于条件渲染和 `v-on` 用于处理事件。'
- en: '*Transition effects*: Vue provides ways to apply transition animation effects
    when items are inserted, updated, or removed from the DOM.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过渡效果*：Vue 提供了在 DOM 中插入、更新或删除元素时应用过渡动画效果的方法。'
- en: '*Vue CLI*: This is a command-line tool for scaffolding (generating the basic
    skeleton of) Vue applications. It offers a range of build setups to start with
    and is highly configurable.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Vue CLI*：这是一个用于脚手架（生成 Vue 应用程序的基本骨架）的命令行工具。它提供了一系列的构建设置以供开始，并且高度可配置。'
- en: '*Vue router*: The official router for Vue. It integrates deeply with Vue Core
    to make building SPAs and managing the navigation between its screens with Vue
    a breeze.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Vue 路由器*：Vue 的官方路由器。它与 Vue 核心深度集成，使得使用 Vue 构建单页应用（SPAs）和管理屏幕间的导航变得非常容易。'
- en: '*Ease of learning*: Vue’s learning curve is generally considered to be less
    steep than other libraries. Its straightforward syntax and excellent documentation
    make it accessible to beginners.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习容易*：Vue 的学习曲线通常被认为比其他库要平缓。其直观的语法和优秀的文档使其对初学者来说易于上手。'
- en: '*Flexibility*: Vue’s design allows it to be as simple or complex as your project
    requires. It can be dropped into an existing project or used to build an entire
    project from scratch.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*灵活性*：Vue 的设计允许它根据项目需求变得简单或复杂。它可以被插入到现有项目中，或者从头开始构建整个项目。'
- en: '*Performance*: Vue is lightweight and offers good performance. Its small size
    and efficient change detection mechanism make it fast.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能*：Vue 轻量级且提供良好的性能。它的小巧体积和高效的变更检测机制使其运行速度快。'
- en: '*Community support*: Although younger than some of its counterparts, Vue has
    a vibrant and growing community, with many resources for learning and a wide array
    of third-party plugins and components.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*社区支持*：尽管比一些竞争对手年轻，但 Vue 拥有一个充满活力且不断增长的社区，提供了许多学习资源，以及广泛的第三方插件和组件。'
- en: Vue is well-suited for those starting in the world of modern JavaScript frameworks,
    as well as for developers building complex, large-scale applications. Its simplicity,
    combined with its power, makes it a popular choice among both beginners and seasoned
    developers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 非常适合那些刚开始接触现代 JavaScript 框架的人，以及构建复杂、大规模应用程序的开发者。它的简单性与强大功能相结合，使其成为初学者和经验丰富的开发者中流行的选择。
- en: 'Let’s take a brief look at a Vue app in action, starting with `vue.html`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看看 Vue 应用程序的实际运行情况，从 `vue.html` 开始：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This shouldn’t look too different from the React example from earlier. Similar
    to that example, we have a single `<div>` element; this is where the interface
    built by Vue will live. However, as opposed to React, just a single import is
    required: Vue itself in `vue.js`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前提到的 React 示例看起来应该不会有太大的不同。类似于那个示例，我们有一个单独的 `<div>` 元素；Vue 构建的界面将在这里。然而，与
    React 不同，只需要一个导入：`vue.js` 中的 Vue 本身。
- en: But, unlike React, we have to put something there, namely our root component.
    I’ve created a custom component named `example-component`, so I can put the `<example-component>`
    custom tag there.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与 React 不同，我们必须在那里放置一些内容，即我们的根组件。我创建了一个名为 `example-component` 的自定义组件，因此我可以在那里放置
    `<example-component>` 自定义标签。
- en: 'The `vueApp.js` file is then imported, which houses that custom component:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后导入 `vueApp.js` 文件，其中包含该自定义组件：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With Vue, there’s no JSX (there doesn’t *have* to be with React either – it’s
    just easier this way), and instead we call the `Vue.component()` function to define
    a custom component. We give it a name as the first argument, and then pass in
    a JavaScript object that defines the component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vue，没有 JSX（React 也可以不使用 JSX – 只是这样做更简单），我们调用 `Vue.component()` 函数来定义一个自定义组件。我们将其名称作为第一个参数传递，然后传递一个定义组件的
    JavaScript 对象。
- en: We can have internal state data as in React by defining a `data` attribute that
    is a function that returns an object having whatever state data we want as fields
    in it. Vue knows how to take this and monitor it like React so that it can update
    the interface as necessary when state changes, making everything reactive.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个返回具有我们想要的任何状态数据的 `data` 属性（作为字段）的函数来拥有内部状态数据，就像在 React 中一样。Vue 会像
    React 一样监控这个状态，以便在状态变化时根据需要更新界面，使一切变得响应式。
- en: But rather than a React function returning markup, a Vue component must provide
    a `template` string that defines the markup this component produces. Here, I’ve
    used JavaScript string interpolation to allow the `template` string to flow across
    multiple lines so that I can insert elements from the state data object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但与返回标记的 React 函数不同，Vue 组件必须提供一个定义该组件生成的标记的 `template` 字符串。在这里，我使用了 JavaScript
    字符串插值，以便 `template` 字符串可以跨越多行，这样我就可以从状态数据对象中插入元素。
- en: 'The output is very similar to the React example, as shown in *Figure 6**.3*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与 React 示例非常相似，如图 *图 6**.3* 所示：
- en: '![Figure 6.3: The Vue example, after a couple of button clicks](img/B18315_06_3.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3：经过几次按钮点击后的 Vue 示例](img/B18315_06_3.jpg)'
- en: 'Figure 6.3: The Vue example, after a couple of button clicks'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：经过几次按钮点击后的 Vue 示例
- en: This time, though, the color of the message is defined in state directly rather
    than passed into the child component. The `:style` attribute syntax, that leading
    semicolon specifically, is necessary for Vue to be able to recognize that we want
    to output the `color` value in the generated HTML. Without it, you’d find that
    the style property isn’t present in the generated HTML and the text wouldn’t be
    red. Then, the `{{message}}` token has the effect of inserting the message text
    into the returned string.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次，消息的颜色是在状态中直接定义的，而不是传递给子组件。`:style`属性语法，特别是那个开头的分号，对于Vue能够识别我们想要在生成的HTML中输出`color`值是必要的。没有它，你会发现生成的HTML中没有样式属性，文本不会变成红色。然后，`{{message}}`标记的作用是将消息文本插入到返回的字符串中。
- en: The `<button>` element uses a Vue directive, `v-on`, to define a click handler.
    Unlike with React, we can change – or *mutate*, as we like to say in computer
    science circles – the `count` value directly because Vue has intelligently hooked
    into it and so knows what to do when it sees this code. Note that this is shorter
    than the React equivalent. The current value of `count` is inserted with `{{count}}`,
    giving us, more or less, the same result as the React version.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`<button>`元素使用Vue指令`v-on`来定义点击处理器。与React不同，我们可以直接更改——或者像计算机科学界喜欢说的那样，*变异*——`count`值，因为Vue智能地将其挂钩，所以知道在看到这段代码时该做什么。请注意，这比React的等效版本要短。当前`count`的值通过`{{count}}`插入，给我们带来了与React版本大致相同的结果。'
- en: Also, as with React, we have to bootstrap our app, but it’s a bit simpler here
    too. We create a new `Vue` object, passing it the ID of the existing HTML element
    to insert our root component into (`el` standing for element, and `#app` being
    like a CSS selector to find the `<div>` element with an ID of `app`), and that’s
    it! Vue takes care of the rest for us.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与React一样，我们必须引导我们的应用程序，但在这里也稍微简单一些。我们创建一个新的`Vue`对象，将其传递给现有HTML元素的ID，以便将根组件插入其中（`el`代表元素，`#app`类似于CSS选择器，用于找到ID为`app`的`<div>`元素），就这样！Vue会为我们处理其余的事情。
- en: So, you’ve seen plain HTML/CSS/JSS, you’ve seen React, and now you’ve seen Vue.
    Those aren’t your only choices, of course. There are meta frameworks too, but
    there are also other frameworks out there that can be your one-stop shop for frontend
    development, and probably the biggest one is Angular.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经看到了纯HTML/CSS/JSS，你已经看到了React，现在你也看到了Vue。当然，这并不是你的唯一选择。还有元框架，但还有其他框架可以作为你的前端开发一站式商店，其中最大的可能是Angular。
- en: Meeting Angular
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遇见Angular
- en: '**Angular** is a free, open source web framework for building single-page web
    applications. It’s developed and maintained by Google, in addition to a larger
    community of individuals and corporations. Angular’s first release, known as Angular
    2.0, was released on September 14, 2016\. It was a complete rewrite of an earlier
    framework named AngularJS. While they share a similar name, they are rather different
    and are considered two different things entirely (if for no other reason than
    apps written using AngularJS will rarely work with Angular).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular**是一个免费的、开源的Web框架，用于构建单页Web应用程序。它由Google开发并维护，此外还有更大的个人和公司社区。Angular的第一个版本，即Angular
    2.0，于2016年9月14日发布。它是之前名为AngularJS的框架的完全重写。虽然它们有相似的名字，但它们相当不同，被视为完全不同的两件事（即使没有其他原因，因为使用AngularJS编写的应用程序很少能与Angular一起工作）。'
- en: Angular has had many rapid-fire updates since its creation, some more notable
    than others. For example, Angular 4 was released on March 23, 2017, with Angular
    5 following on November 1, 2017, the latter of which brought improvements such
    as support for progressive web apps. Angular 6, released on May 4, 2018, focused
    on the toolchain (the command-line tools you use to build Angular apps, which
    is a big part of what it does, and some would say its appeal), and ease of future
    development. Subsequent versions continued to add features and improvements regularly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Angular自创建以来经历了许多快速更新，其中一些比其他一些更引人注目。例如，Angular 4于2017年3月23日发布，Angular 5随后于2017年11月1日发布，后者带来了对渐进式Web应用的支持等改进。Angular
    6于2018年5月4日发布，专注于工具链（你用来构建Angular应用程序的命令行工具，这是它所做的大事之一，有些人会说这是它的吸引力所在），以及未来开发的简便性。后续版本继续定期添加功能和改进。
- en: Angular is known for several key features. One is two-way data binding, which
    is a way to tie the UI components on the screen together with data. Essentially,
    a change in a UI component results in a change to the data, and vice versa, automatically,
    which leads to developers having to write less code in most cases while maintaining
    reactivity. Dependency injection is another key capability. This allows objects
    in code to be created by the framework and provided to application code, rather
    than the application code having to create them itself.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 以几个关键特性而闻名。一个是双向数据绑定，这是一种将屏幕上的 UI 组件与数据绑定在一起的方式。本质上，UI 组件中的更改会导致数据发生变化，反之亦然，自动进行，这导致开发者大多数情况下需要编写的代码更少，同时保持响应性。依赖注入是另一个关键能力。这允许框架创建代码中的对象，并将其提供给应用代码，而不是让应用代码自己创建它们。
- en: Like React and Vue, Angular follows a component-based architecture, allowing
    for reusable components and efficient development practices. However, Angular’s
    structure tends to be more complex. While React components are usually a combination
    of HTML, JavaScript, and CSS, Angular apps will usually break those out into separate
    files, so a component will be made up of multiple source files rather than (usually)
    just one in React or Vue.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与 React 和 Vue 类似，Angular 采用基于组件的架构，允许使用可重用组件和高效的开发实践。然而，Angular 的结构往往更复杂。虽然
    React 组件通常是 HTML、JavaScript 和 CSS 的组合，但 Angular 应用通常会将其拆分为单独的文件，因此一个组件将由多个源文件组成，而不是（通常）像
    React 或 Vue 那样只有一个。
- en: Angular tends to be used in large-scale “enterprise” web apps due to its robust
    feature set and scalability. Angular supplies virtually everything a developer
    may need to build such apps under one roof. This is in contrast to lighter libraries
    such as React or Vue, where you’ll typically need to add other libraries as you
    need them. For example, having your client-side code communicate with your server-side
    code will often mean adding a library such as Axios, an open-source communication
    library, to your React or Vue app. By contrast, Angular provides that function
    (you don’t *have* to use it, but one of the big draws of Angular is having just
    one dependency to deal with, so most Angular developers would tend to use it).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 由于其强大的特性和可扩展性，通常用于大型“企业”级 Web 应用。Angular 几乎为开发者提供了构建此类应用所需的一切，都在一个屋檐下。这与像
    React 或 Vue 这样的轻量级库形成对比，在这些库中，你通常需要根据需要添加其他库。例如，让你的客户端代码与你的服务器端代码通信通常意味着需要添加一个库，如
    Axios，这是一个开源的通信库，到你的 React 或 Vue 应用中。相比之下，Angular 提供了这种功能（你不必*必须*使用它，但 Angular
    的一个主要吸引力就是只有一个依赖项需要处理，因此大多数 Angular 开发者都会倾向于使用它）。
- en: 'So, what separates Angular from React and Vue? Let’s look at some key highlights:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Angular 与 React 和 Vue 有何不同？让我们看看一些关键亮点：
- en: '*Core philosophy*: Angular is a full-fledged framework offering a strong opinion
    on how your app should be structured and, as mentioned before, providing – theoretically
    – everything a developer needs in one place. React and Vue are libraries that
    focus just on UI components, giving you more freedom to use other libraries for
    different aspects of your app.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*核心哲学*：Angular 是一个完整的框架，对应用的结构有强烈的看法，并且如前所述，理论上在一个地方提供开发者可能需要的所有东西。React 和
    Vue 是专注于 UI 组件的库，这让你有更多的自由来使用其他库来处理应用的不同方面。'
- en: '*Language*: Angular uses TS, a language we’ll look at later, but in short,
    it’s an extended version of JavaScript that adds some key features, primarily
    strong typing. While you can develop React and Vue apps with TS as well, and many
    people do, Angular requires it (well, at least once you move beyond very basic
    example territory).'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语言*：Angular 使用 TypeScript（TS），这是我们稍后将要讨论的语言，但简而言之，它是 JavaScript 的扩展版本，增加了一些关键特性，主要是强类型。虽然你也可以用
    TypeScript 开发 React 和 Vue 应用，很多人确实这样做，但 Angular 要求使用它（好吧，至少在你超越非常基础的示例领域时）。'
- en: '*Data binding*: As mentioned previously, Angular has two-way data binding,
    meaning changes in the UI are automatically reflected in the app state and vice
    versa. React and Vue use a one-way data flow, where the UI is updated via state
    changes, making it more predictable but requiring more boilerplate to update the
    state.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据绑定*：如前所述，Angular 具有双向数据绑定，这意味着 UI 中的更改会自动反映在应用状态中，反之亦然。React 和 Vue 使用单向数据流，其中
    UI 通过状态更改进行更新，这使得它更可预测，但需要更多的样板代码来更新状态。'
- en: '*Learning curve*: Angular’s comprehensive nature makes its learning curve steeper
    compared to React and Vue, which is more straightforward to start with due to
    its simplicity and focus on UI.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习曲线*：Angular 的全面性使得其学习曲线比 React 和 Vue 更陡峭，而 React 和 Vue 由于其简洁性和对 UI 的关注，开始时更为直接。'
- en: '*Performance*: While Angular has good performance overall, React and Vue tend
    to have better performance due to its virtual DOM system in the case of React
    and simplicity in the case of Vue.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能*：虽然 Angular 在整体性能上表现良好，但由于 React 的虚拟 DOM 系统和 Vue 的简洁性，React 和 Vue 往往具有更好的性能。'
- en: Whether you’re talking about Angular, React, or Vue, all three are powerful
    in their own right, and the choice often comes down to the specific needs and
    preferences of your project.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在谈论 Angular、React 还是 Vue，三者各自都有其强大的地方，选择通常取决于你项目的具体需求和偏好。
- en: 'Let’s take a quick look at an Angular version of our counter example. As with
    React and Vue, we start with a plain HTML file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们的计数器示例的 Angular 版本。与 React 和 Vue 类似，我们从一个普通的 HTML 文件开始：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This basic form should start to look familiar at this point! Angular, at its
    most basic level, just requires a single `angular.min.js` file to be imported.
    With Angular, the element that the app will be rendered into (that the root component
    will be rendered into, in other words) is usually the `<body>` element itself.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这种基本形式应该开始看起来熟悉了！Angular 在最基本层面上，只需要导入一个 `angular.min.js` 文件。使用 Angular，应用将被渲染到的元素（换句话说，根组件将被渲染到的元素）通常是
    `<body>` 元素本身。
- en: And on the `<body>` tag, you can see one thing that Angular does differently
    than React and Vue, and does so a lot, and that’s the use of `ng-app` is an example
    of.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<body>` 标签上，你可以看到 Angular 与 React 和 Vue 不同之处，并且这种情况很多，那就是使用 `ng-app` 的例子。
- en: You see, when a page that uses Angular loads, the Angular code goes through
    the HTML and looks for these directives, converting them (and often the entire
    tag it’s on) into other HTML markup that Angular needs. Here, `ng-app="app"` identifies
    the `<body>` element as containing an Angular app. Angular contains many directives
    for doing many things, some of which include creating repeating sections of markup
    (`NGFor`), adding or removing elements based on some logic condition (`NGIf`),
    and binding things together using two-way data binding (`NGModel`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，当一个使用 Angular 的页面加载时，Angular 代码会遍历 HTML 并查找这些指令，将它们（以及通常整个标签）转换为 Angular
    需要的其他 HTML 标记。在这里，`ng-app="app"` 将 `<body>` 元素标识为包含 Angular 应用。Angular 包含许多用于执行许多任务的指令，其中一些包括创建重复的标记部分（`NGFor`）、根据某些逻辑条件添加或删除元素（`NGIf`），以及使用双向数据绑定将事物绑定在一起（`NGModel`）。
- en: 'Once we have a container element for the app marked with the `ng-app` directive,
    we can begin to use custom components inside of it, and the `<root-component>`
    element is exactly that: a custom root component. As with React and Vue, all components
    will be children, direct or indirect, of a root component. Here’s the code for
    that component, contained in the imported `angular.js` file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为应用标记了 `ng-app` 指令的容器元素，我们就可以开始在其内部使用自定义组件，而 `<root-component>` 元素正是这样一个自定义根组件。与
    React 和 Vue 类似，所有组件都将直接或间接地成为根组件的子组件。以下是该组件的代码，包含在导入的 `angular.js` 文件中：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first line creates an Angular module named `app`. Modules allow us to organize
    our code into discrete units more logically. The first argument is simply the
    name of the module, which is typically `app` – as shown here – for the module
    representing the app itself. The second argument, an empty array, indicates that
    this module doesn’t have dependencies on other modules, which they often will,
    but not in such a simple example as this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个名为 `app` 的 Angular 模块。模块允许我们更逻辑地将代码组织成离散的单元。第一个参数只是模块的名称，通常为 `app` –
    如此所示 – 代表应用本身的模块。第二个参数，一个空数组，表示此模块不依赖于其他模块，它们通常会有，但在这个简单的例子中不会。
- en: Next, a component named `rootComponent` is defined. The approach you can see
    here is perhaps the simplest – that is, using the `template` attribute of the
    object that was passed to `app.component()` as the second argument. The value
    of this defines the HTML structure for the component. It shouldn’t look that different
    to you than the Vue example from earlier. Once again, tokens can be inserted into
    the markup based on the state of the component, which Angular also has a notion
    of. The `style` attribute of the first `<p>` element uses Angular’s data binding
    to set its color based on the `textColor` property in the scope, which is essentially
    the same idea as state in React.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义了一个名为 `rootComponent` 的组件。您在这里可以看到的方法可能是最简单的——即使用传递给 `app.component()`
    的对象的 `template` 属性作为第二个参数。这个值定义了组件的 HTML 结构。它应该与之前提到的 Vue 示例看起来没有太大区别。再次强调，可以根据组件的状态将标记插入到标记中，Angular
    也有这个概念。第一个 `<p>` 元素的 `style` 属性使用 Angular 的数据绑定来根据作用域中的 `textColor` 属性设置其颜色，这本质上与
    React 中的状态相同。
- en: 'The `controller` function defines the behavior of the component. The `$scope`
    argument is an example of Angular’s dependency injection and is created and injected
    into the controller automatically by the framework when the component is created.
    The `controller` function sets up three properties on `$scope`: `message`, `count`,
    and `textColor`. These are then used in the component’s template when the component
    is rendered.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`controller` 函数定义了组件的行为。`$scope` 参数是 Angular 依赖注入的一个例子，当组件创建时，框架会自动创建并注入到控制器中。`controller`
    函数在 `$scope` 上设置了三个属性：`message`、`count` 和 `textColor`。这些属性随后在组件渲染时用于组件的模板中。'
- en: To use this component in an Angular application, you must use the custom `<root-component>`
    HTML element. Note that Angular automatically alters the name in this fashion
    for all components so that you wind up with a consistent naming pattern for your
    custom components. When Angular runs, it will replace this element with the specified
    `template` content, and the controller will manage the component’s behavior, such
    as when the user clicks the button, triggering a re-render of the component with
    the updated scope value for the `count` property.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用中使用此组件时，您必须使用自定义的 `<root-component>` HTML 元素。请注意，Angular 会自动以这种方式更改所有组件的名称，以便您最终拥有一个一致的命名模式来命名您的自定义组件。当
    Angular 运行时，它将用指定的 `template` 内容替换此元素，控制器将管理组件的行为，例如当用户点击按钮时，将触发组件的重新渲染，并更新 `count`
    属性的 `scope` 值。
- en: 'This is a simple example of Angular’s declarative approach to building UIs,
    where you define what you want and let the framework handle the DOM manipulations
    and data bindings. This time, I’ll save a few trees and not drop a screenshot
    onto the page because it looks no different from the React and Vue examples. But
    that’s on purpose: this exercise was to show you the same basic example done three
    ways so that you can compare and contrast them a little bit.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Angular 构建UI的声明式方法的简单示例，其中您定义您想要的内容，然后让框架处理DOM操作和数据绑定。这次，我将节省一些纸张，不会在页面上放置截图，因为它看起来与
    React 和 Vue 示例没有太大区别。但这是故意的：这个练习是为了向您展示以三种方式完成的相同基本示例，以便您可以进行比较和对比。
- en: I feel that it’s important to reiterate the point that this is just about as
    simple as Angular can get. A more full-featured Angular app will be noticeably
    more complex in many ways and will be written using TS, which we’ll be looking
    at later in this chapter. So far, we’ve talked about JavaScript libraries and
    frameworks, so let’s switch gears and talk about how CSS can be enhanced in a
    similar way to provide a more robust feature set.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为重申这一点很重要，那就是这几乎是 Angular 可以达到的最简单程度。一个功能更全面的 Angular 应用在许多方面将明显更复杂，并且将使用
    TS 编写，我们将在本章后面讨论。到目前为止，我们已经讨论了 JavaScript 库和框架，所以让我们转换一下话题，谈谈如何以类似的方式增强 CSS，以提供更强大的功能集。
- en: Boosting CSS capabilities
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升CSS功能
- en: While libraries and frameworks such as React and Angular tend to be the big
    hitters these days and tend to cover most of the bases in terms of HTML, CSS,
    and JavaScript, there are ways to augment those technologies, such as when using
    jQuery to augment JavaScript, and leave the other two entirely unchanged. CSS
    can also be augmented in this way, by using a CSS library. These can be as simple
    as a stylesheet file you import, or as complex as actually a combination of CSS
    and JavaScript working together to dynamically generate CSS based on simple configuration
    on your part.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 React 和 Angular 等库和框架如今通常是主流，并且通常涵盖了 HTML、CSS 和 JavaScript 的各个方面，但仍然有方法可以增强这些技术，例如使用
    jQuery 来增强 JavaScript，同时完全保留其他两个不变。CSS 也可以通过使用 CSS 库来增强，这些库可能只是一个导入的样式表文件，也可能是一个结合
    CSS 和 JavaScript 的工作组合，根据你简单的配置动态生成 CSS。
- en: 'It’s not impossible or even necessarily unusual to use such a CSS library in
    conjunction with a framework such as Angular, though that’s becoming less and
    less common as these frameworks gain more capabilities. But regardless of whether
    you use them alone or in conjunction with something else, let’s take a look at
    two of the most popular out there: Bootstrap and Tailwind.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Angular 等框架结合使用这样的 CSS 库并非不可能，甚至也不一定不寻常，尽管随着这些框架功能的增强，这种情况变得越来越少见。但无论你是单独使用它们还是与其他东西结合使用，让我们来看看其中最受欢迎的两个：Bootstrap
    和 Tailwind。
- en: Examining Bootstrap
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 Bootstrap
- en: '**Bootstrap** is billed as a frontend toolkit, and it is used for developing
    responsive and mobile-first web pages. It provides a collection of HTML, CSS,
    and JavaScript tools for creating websites and web apps. Bootstrap includes pre-designed
    components such as buttons, forms, navigation bars, modals, and much more, which
    can be easily customized. Using Bootstrap is simple, as this example shows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bootstrap** 被宣传为一个前端工具包，用于开发响应式和以移动设备为先的网页。它提供了一系列 HTML、CSS 和 JavaScript
    工具，用于创建网站和 Web 应用。Bootstrap 包含预设计的组件，如按钮、表单、导航栏、模态框等，这些组件可以轻松定制。使用 Bootstrap 很简单，如下例所示：'
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All it takes is importing a Bootstrap CSS file, and optionally (though usually)
    a JavaScript file as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 只需导入一个 Bootstrap CSS 文件，可选的（尽管通常是）还可以导入一个 JavaScript 文件。
- en: Once that’s done, the majority of what you do with Bootstrap is apply style
    classes, such as `container`, to say you want a container that will resize based
    on the available width of the screen, as shown in the first `<div>` element. The
    `btn` class transforms a regular `<button>` element into a Bootstrap-controlled
    button, which means you can then apply further styles to it, such as `btn-info`,
    which gives us a bluish button with rounded edges, a bit nicer than a typical
    browser-supplied button.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，你用 Bootstrap 做的大部分事情就是应用样式类，例如 `container`，表示你想要一个根据屏幕可用宽度调整大小的容器，正如第一个
    `<div>` 元素所示。`btn` 类将一个普通的 `<button>` 元素转换成 Bootstrap 控制的按钮，这意味着你可以进一步对其应用样式，例如
    `btn-info`，这会给我们一个带有圆角的蓝色按钮，比典型的浏览器提供的按钮要好看一些。
- en: This makes Bootstrap aware of this button and then allows us to attach behaviors
    to it by using `data-*` attributes. Any time you see `data-*` on a tag, that’s
    custom data that something else likely depends on. You can add `data-*` elements
    like this any time you like, and they have no bearing on the appearance of your
    markup, at least not directly. The browser simply ignores them because they’re
    for you, not it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 Bootstrap 能够识别这个按钮，然后我们可以通过使用 `data-*` 属性来附加行为。每次你在标签上看到 `data-*`，那都是其他东西可能依赖的定制数据。你可以随时添加这样的
    `data-*` 元素，并且它们对你的标记的显示没有影响，至少不是直接的影响。浏览器简单地忽略它们，因为它们是为了你，而不是为了它。
- en: But when Bootstrap sees those attributes on elements, it knows that you want
    to do something with it. In this case, `data-bs-toggle` tells it that you want
    the button to expand and collapse a section of content, namely the one with an
    ID of `text` here, which is then named in the `data-bs-target` attribute. The
    `<div>` element that follows the button has an ID of `text`, and also has the
    Bootstrap `collapse` style class applied. The result is that, without having to
    write any JavaScript or CSS ourselves, we can click the button to expand and collapse
    the content in that `<div>`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当 Bootstrap 在元素上看到这些属性时，它知道你想要对它做些什么。在这种情况下，`data-bs-toggle` 告诉它你想要按钮展开和折叠内容部分，即这里具有
    `text` ID 的部分，然后在 `data-bs-target` 属性中命名。跟随按钮的 `<div>` 元素具有 `text` ID，并且还应用了 Bootstrap
    的 `collapse` 样式类。结果是，我们无需自己编写任何 JavaScript 或 CSS，就可以点击按钮来展开和折叠 `<div>` 中的内容。
- en: Bootstrap is a bit more than just a CSS library. While it certainly does include
    a lot of CSS styles you can use right out of the box, it also offers components
    (such as the buttons and collapsible container seen in this sample), various other
    kinds of containers for doing layouts, including breakpoints for responsive design,
    and even JavaScript helper functions. It’s also extensible in that you can add
    plugins to extend its capabilities and themes to change the look and feel of its
    components wholesale. Bootstrap is also customizable in that you can override
    most of its styles and change how the results look without much difficulty.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 不仅仅是一个 CSS 库。虽然它确实包含了许多可以直接使用的 CSS 样式，还提供了组件（如这个示例中看到的按钮和可折叠容器），以及用于布局的各种其他类型的容器，包括响应式设计的断点，甚至还有
    JavaScript 辅助函数。它还支持扩展，你可以添加插件来扩展其功能，添加主题来全面改变其组件的外观和感觉。Bootstrap 还支持自定义，你可以覆盖大多数样式，并且可以轻松地改变结果的外观。
- en: All of this has made Bootstrap popular for a long time, and also because it
    tends to be quite simple to use but offers a fair bit of power. But its popularity
    is waning a little bit, in large part because sites built with Bootstrap all tend
    to look the same since it supplies components that largely define the look and
    feel of a site, and people generally don’t like that. While in no way an outright
    replacement, the new kid on the block, Tailwind, has been gaining developer mindshare
    rapidly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素使得 Bootstrap 在很长时间内都备受青睐，并且它使用起来相当简单，同时提供了相当多的功能。但它的受欢迎程度正在逐渐下降，这在很大程度上是因为使用
    Bootstrap 构建的网站都倾向于看起来很相似，因为 Bootstrap 提供的组件在很大程度上定义了网站的外观和感觉，而人们通常不喜欢这样。尽管 Tailwind
    并非一个完全的替代品，但这个新出现的 Tailwind 已经迅速获得了开发者的关注。
- en: Examining Tailwind
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检视 Tailwind
- en: '**Tailwind** is billed as a utility-first CSS framework for rapidly building
    custom designs. Unlike other CSS frameworks, such as Bootstrap, which come with
    predefined components, Tailwind provides low-level utility classes only, which
    lets the developer more easily build completely custom designs without ever leaving
    your HTML.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tailwind** 被宣传为一个以实用类为先的 CSS 框架，用于快速构建自定义设计。与其他 CSS 框架不同，如 Bootstrap，它提供了预定义的组件，Tailwind
    只提供低级别的实用类，这使得开发者可以更轻松地构建完全自定义的设计，而无需离开 HTML。'
- en: 'Tailwind comes with *a lot* more style classes than Bootstrap, which is kind
    of the point. Rather than drop a `btn` class on a `<button>` element, as in Bootstrap,
    with Tailwind, you might write something like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind 比 Bootstrap 提供了更多的样式类，这其实也是它的一个特点。与 Bootstrap 不同，在 Tailwind 中，你不会直接在
    `<button>` 元素上使用 `btn` 类，而是可能会写成这样：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This example is equivalent to the Bootstrap example, but you can see some key
    differences. First, Tailwind only requires us to import a stylesheet, not a JavaScript
    file, and no jQuery dependency. It’s generally nice to have fewer things to import,
    but there is a cost here: we don’t get the automatic expand/collapse functionality
    like with Bootstrap, and we have to write some JavaScript ourselves for that.
    That’s down on the `<button>` element. In response to the `onClick` event, we
    get a reference to the text content by calling `document.getElementById()`, which
    returns a DOM node. This has a list of classes applied, and calling `toggle()`
    on that list and passing it the name of a class adds or removes it, depending
    on the current state.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例与 Bootstrap 的示例等效，但你可以看到一些关键的不同之处。首先，Tailwind 只需要我们导入一个样式表，而不是 JavaScript
    文件，也没有 jQuery 依赖。通常来说，有更少的东西需要导入是件好事，但这里有一个代价：我们没有像 Bootstrap 那样的自动展开/折叠功能，我们必须自己编写一些
    JavaScript 来实现这一点。这是在 `<button>` 元素上。响应 `onClick` 事件时，我们通过调用 `document.getElementById()`
    获取文本内容的引用，它返回一个 DOM 节点。这个节点应用了一系列的类，通过调用 `toggle()` 方法并传递一个类的名称，根据当前状态添加或删除该类。
- en: 'The other thing to notice here, which is the hallmark of Tailwind, is all the
    style classes applied to the `<button>` element (this is true for other elements,
    but let’s focus on `<button>`). These are the Tailwind utility-style classes.
    Rather than a single `btn` class that has all the styles for a button like with
    Bootstrap, instead, you apply just the utility class you want:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一个需要注意的地方，这也是 Tailwind 的一个标志，那就是应用到 `<button>` 元素上的所有样式类（这同样适用于其他元素，但让我们专注于
    `<button>`）。这些是 Tailwind 的实用样式类。与 Bootstrap 中的单个 `btn` 类相比，它包含了按钮的所有样式，你只需应用你想要的实用类：
- en: The `bg-blue-500` class gives the button a blue background color
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bg-blue-500` 类为按钮提供了蓝色背景色'
- en: The `hover:bg-blue-700` class defines a hover pseudo style to make it a different
    shade of blue when you hover over it
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hover:bg-blue-700` 类定义了一个悬停伪样式，当鼠标悬停时使其变为不同的蓝色阴影'
- en: The `text-white` class makes the text on it white and `font-bold` bolds it
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text-white` 类使文本变为白色，而 `font-bold` 使其加粗'
- en: The `py-2` class applies padding on the top and bottom
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`py-2` 类在顶部和底部应用填充'
- en: The `px-4` class applies padding on the left and right around the text in the
    button
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`px-4` 类在按钮中的文本左右两侧应用填充'
- en: The `rounded` class gives the button rounded corners
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rounded` 类使按钮具有圆角'
- en: As you can see, you have much more fine-grained control over how the button
    looks. You can easily make the text red, for example, or change the amount of
    padding. With Bootstrap, you would need to override the styles that it provides,
    but with Tailwind, you only ever get what you want. There are more style classes
    to deal with – a lot more – but you have more control and flexibility by default,
    which means with Tailwind, there’s a better chance that your site won’t look like
    every other one using Tailwind out there.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你对按钮的外观有更多的精细控制。例如，你可以轻松地将文本设置为红色，或者改变填充量。使用 Bootstrap，你需要覆盖它提供的样式，但使用
    Tailwind，你总是能得到你想要的结果。有更多的样式类需要处理——很多——但默认情况下，你拥有更多的控制和灵活性，这意味着使用 Tailwind，你的网站更有可能不会像其他使用
    Tailwind 的网站那样看起来一样。
- en: Now, let’s move on to another topic that largely defines what most people consider
    modern web development, that being the concept of transpiling, specifically with
    a tool called Babel.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向另一个主题，这个主题在很大程度上定义了大多数人认为的现代网络开发，那就是转译的概念，特别是使用一个名为 Babel 的工具。
- en: Transpiling and data typing
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转译和数据类型
- en: 'JavaScript is a fun language in many ways, being extremely flexible and relatively
    easy to learn. However, while it’s fun to some, to others, they’ll tell you it’s
    an absolute nightmare! For that latter group, the complaints largely come down
    to one thing:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在很多方面都是一门有趣的语言，它非常灵活，相对容易学习。然而，虽然对一些人来说很有趣，但对另一些人来说，他们会告诉你这是一场绝对的噩梦！对于后者，投诉主要归结为一件事：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is perfectly valid JavaScript code, but it’s also code that will cause
    an error. Why? What gives?!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段完全有效的 JavaScript 代码，但也是会导致错误的代码。为什么？是什么原因呢？！
- en: First, the `myVar` variable is given a value of `abc`, which is a string. Then,
    we call the `toUpperCase()` method on that string, which is a method that all
    JavaScript strings have to convert into uppercase. After that, the value of `myVar`
    is changed to `123`, which is a number. The error then occurs on the second `toUpperCase()`
    call because that method isn’t available on a number.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`myVar` 变量被赋予了一个值为 `abc` 的字符串。然后，我们调用该字符串上的 `toUpperCase()` 方法，这是一个所有 JavaScript
    字符串都有的方法，用于将其转换为大写。之后，`myVar` 的值被更改为 `123`，这是一个数字。错误发生在第二次调用 `toUpperCase()` 方法时，因为该方法在数字上不可用。
- en: The problem we’re running into is related to a concept in programming called
    **data typing**. It’s the idea that a variable holds some data, and usually, we
    need to explicitly state in our code what type of data it is. The language often
    needs to know this because not all operations are valid for all types of data.
    As described before, you can’t convert a number into uppercase because that doesn’t
    make logical sense like it does with a string. Therefore, so long as the language
    knows what type of data a variable holds, it can proactively inform us of any
    mistakes we might make in terms of data typing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的问题与编程中的一个概念有关，称为 **数据类型**。这是指一个变量持有某些数据，通常，我们需要在我们的代码中明确声明它的数据类型。语言通常需要知道这一点，因为并非所有操作都适用于所有类型的数据。如前所述，你不能将数字转换为大写，因为这没有像字符串那样有逻辑意义。因此，只要语言知道变量持有的数据类型，它就可以主动通知我们可能在数据类型方面犯的错误。
- en: 'The problem in this example is that JavaScript is what’s called a *dynamically
    typed* language (sometimes called loosely typed), meaning the type of a variable
    can change on a whim. This is opposed to a *statically typed* language (or strongly
    typed), such as Java, where you have to write code like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，问题在于 JavaScript 是一种被称为 *动态类型* 的语言（有时称为松散类型），这意味着变量的类型可以随意更改。这与 *静态类型*
    语言（或强类型）相反，例如 Java，你必须编写如下代码：
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, the error will occur on the third line. When `myVar` is declared, in Java,
    we have to specify a type for it – `String` – so that Java knows that `myVar`
    is only allowed to contain a string. The code won’t even make it to the second
    call to `toUpperCase()` because trying to set `myVar` to `123` will cause an error.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，错误将出现在第三行。在 Java 中，当声明 `myVar` 时，我们必须为它指定一个类型——`String`——这样 Java 就知道 `myVar`
    只能包含字符串。代码甚至无法到达对 `toUpperCase()` 的第二次调用，因为尝试将 `myVar` 设置为 `123` 将导致错误。
- en: 'But here’s the key point: *this error will occur at compile time*. You see,
    JavaScript doesn’t need to be compiled – that is, converted from source code into
    a form the computer can execute. Instead, the source code itself is executed.
    JavaScript only has a runtime, meaning when the code runs.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 但关键点是：*这个错误将在编译时发生*。你看，JavaScript 不需要编译——也就是说，从源代码转换成计算机可以执行的形式。相反，源代码本身就会被执行。JavaScript
    只有一个运行时，这意味着代码运行时。
- en: Java, on the other hand, has to be compiled, which is when source code is transformed
    into another form (in the case of Java, that form is called **Intermediate Language**,
    or **IL** for short) so that it can be executed by the computer. That’s not particularly
    important for this discussion, but the part that matters is that the error on
    the third line will be caught when we try to compile the code. In other words,
    *we would never be able to even try to execute it because the Java compiler won’t
    even produce IL*. It’ll see the error during compilation and tell us about it
    before it gets that far. This will all happen during your development cycle.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，Java 需要编译，这是将源代码转换成另一种形式（在 Java 的情况下，这种形式被称为**中间语言**，或简称**IL**）以便计算机可以执行的时候。这对于本次讨论来说并不特别重要，但重要的是，当我们尝试编译代码时，第三行的错误会被捕获。换句话说，*我们甚至无法尝试执行它，因为
    Java 编译器甚至不会生成 IL*。它会在编译过程中发现错误，并在它走到那一步之前告诉我们。这一切都会发生在你的开发周期中。
- en: In contrast, you would only find out about the error in the JavaScript code
    when you go to run it for real. If you’re lucky, this means during development.
    But what happens if that code doesn’t get executed during development? Maybe it’s
    in a function that’s rarely used. Now, guess who’s going to find the error? The
    answer is *your users* when they hit that line of code on your live site!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，你只有在真正运行 JavaScript 代码时才会发现错误。如果你很幸运，这意味着在开发过程中。但如果那段代码在开发过程中没有被执行呢？也许它在一个很少使用的函数中。现在，猜猜谁会发现错误？答案是
    *你的用户* 当他们在你的实时网站上遇到那行代码时！
- en: This problem, primarily, is what led to the creation of something called a **transpiler**.
    A transpiler is like a compiler in that it converts code from one form into another.
    But while a compile converts source code into an executable form, a transpiler
    converts from one form of source code into another.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题，主要是导致创建了一个名为 **transpiler** 的东西的原因。transpiler 就像编译器一样，它将代码从一种形式转换成另一种形式。但编译器将源代码转换成可执行形式，而
    transpiler 则将一种源代码形式转换成另一种形式。
- en: 'The other big problem that transpilers can help with is where there are differences
    in the runtime environment (which usually means a web browser in the case of JavaScript).
    Transpilers can smooth these over for you. For example, let’s say that Google
    Chrome supports that `toUpperCase()` method on strings, but maybe you find that
    Firefox doesn’t (don’t worry – they both do support it!). You could certainly
    write some code like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Transpilers 可以帮助解决的另一个大问题是运行时环境中的差异（在 JavaScript 的情况下通常意味着一个网络浏览器）。Transpilers
    可以为你平滑这些差异。例如，假设 Google Chrome 支持字符串上的 `toUpperCase()` 方法，但也许你会发现 Firefox 不支持（别担心——它们都支持它！）。你当然可以编写一些像这样的代码：
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You would then have to figure out how to determine whether your code is running
    in Chrome or Firefox (giving a `true` or `false` value to that `running_in_chrome`
    variable), so you would have to write the code for `myOwnFunctionToDoUpperCase()`
    yourself, which does the equivalent of `toUpperCase()`. In this case, that’s not
    all that tall of an order, but you can imagine not all cases being quite so easy.
    This technique is called **polyfill**: writing code that allows you to use modern
    browser features in browsers that don’t yet support it.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你随后需要弄清楚如何确定你的代码是在 Chrome 还是 Firefox 中运行（给 `running_in_chrome` 变量一个 `true` 或
    `false` 的值），因此你必须自己编写 `myOwnFunctionToDoUpperCase()` 的代码，它执行 `toUpperCase()` 的等效操作。在这种情况下，这并不是什么大问题，但你可以想象并不是所有情况都这么简单。这种技术被称为
    **polyfill**：编写允许你在不支持现代浏览器功能的浏览器中使用现代浏览器功能的代码。
- en: A transpiler essentially does this work for you. With a transpiler, it will
    see that the `toUpperCase()` function is used, recognize that it won’t work in
    the browser you specify that you want your code to work in, and automatically
    add the necessary polyfill. It will produce JavaScript that will work across all
    browsers that way. Yes, it’s converting JavaScript into JavaScript, but modified
    JavaScript on the output side.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器本质上为你做这项工作。使用编译器，它会看到使用了`toUpperCase()`函数，认识到它不会在你指定的浏览器中工作，并自动添加必要的填充。这样，它将生成可以在所有浏览器上工作的JavaScript。是的，它是在将JavaScript转换为JavaScript，但输出侧是修改过的JavaScript。
- en: 'For now, though, let’s talk about perhaps the most famous transpiler out there,
    certainly in the realm of web development: Babel.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们谈谈最著名的编译器之一，尤其是在Web开发领域：Babel。
- en: Introducing Babel
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Babel
- en: Babel is a JavaScript transpiler that allows you to use next-generation JavaScript
    today. It converts newer forms of JavaScript code into a backward-compatible version
    for older browsers or environments (such as Node). Key features include transforming
    syntax (for example, converting functions in the `() => { }` form into the original
    `function xxx() { }` form), polyfilling features that are missing in your target
    environment, and source code transformations (typically things such as applying
    specific coding standards to make all your source code look the same). Babel is
    widely used in web development to ensure broad compatibility and to leverage the
    latest JavaScript features while maintaining support for older platforms.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Babel是一个JavaScript编译器，它允许你今天使用下一代JavaScript。它将新的JavaScript代码形式转换为与旧浏览器或环境（如Node）向后兼容的版本。关键特性包括转换语法（例如，将`()
    => { }`形式的函数转换为原始的`function xxx() { }`形式），填充目标环境中缺失的功能，以及源代码转换（通常是应用特定的编码标准，使所有源代码看起来相同）。Babel在Web开发中被广泛使用，以确保广泛的兼容性，同时利用最新的JavaScript特性，同时保持对旧平台的支持。
- en: 'Some of the key points about Babel are as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Babel的一些关键点如下：
- en: '*Plugins and presets*: Babel’s functionality can be extended through plugins.
    For example, things such as JSX can be supported through plugins. Presets essentially
    combine many different configuration options into a single option. For example,
    the `@babel/preset-env` preset will provide support for modern browsers without
    you having to configure every available option.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*插件和预设*：Babel的功能可以通过插件进行扩展。例如，JSX可以通过插件来支持。预设本质上是将许多不同的配置选项组合成一个单一选项。例如，`@babel/preset-env`预设将提供对现代浏览器的支持，而无需配置每个可用的选项。'
- en: '*Configuration*: Babel can be configured by creating a `.babelrc` file, or
    by adding a babel section in a `package.json` file. This configuration specifies
    the presets and plugins to be used, as well as other available options.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置*：Babel可以通过创建`.babelrc`文件或在一个`package.json`文件中添加babel部分来进行配置。此配置指定了要使用的预设和插件，以及其他可用的选项。'
- en: '*Integration with build tools*: Babel is used by bundlers such as Webpack,
    Rollup, and Vite. Babel provides a lot of the functionality these bundlers offer
    (certainly not all of it, of course).'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与构建工具的集成*：Babel被Webpack、Rollup和Vite等打包器所使用。Babel提供了这些打包器提供的许多功能（当然，不是全部，当然）。'
- en: '*Community and ecosystem*: Babel has a large community and ecosystem, with
    many third-party plugins and tools available. This makes it a versatile tool that
    can adapt to many different project requirements.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*社区和生态系统*：Babel有一个庞大的社区和生态系统，提供了许多第三方插件和工具。这使得它成为一个多才多艺的工具，可以适应许多不同的项目需求。'
- en: Babel’s role is crucial in ensuring that developers can use the latest JavaScript
    features without sacrificing compatibility, making it a cornerstone of modern
    web development.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Babel在确保开发者可以在不牺牲兼容性的情况下使用最新的JavaScript特性方面发挥着至关重要的作用，使其成为现代Web开发的基石。
- en: As useful and powerful as Babel is, you may have noticed that it doesn’t solve
    the type problem. JavaScript is still loosely typed, despite all that Babel can
    do for you. To solve that problem, we need to look at something else called TS,
    and the transpiler it provides, which can take the place of Babel (though Babel
    can handle TS too!).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Babel非常有用且功能强大，你可能已经注意到它并没有解决类型问题。尽管Babel能为你做很多事情，JavaScript仍然是弱类型语言。为了解决这个问题，我们需要看看另一种叫做TS的东西，以及它提供的编译器，它可以替代Babel（尽管Babel也可以处理TS！）。
- en: Introducing TS
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍TS
- en: TypeScript, or TS for short, is a product of Microsoft. It’s a programming language
    that is a superset of JavaScript, meaning it adds new features to JavaScript,
    most importantly static typing. This helps catch errors early in development.
    You transpile it to plain JavaScript so that it can run anywhere JavaScript does.
    TS is popular for large-scale projects due to its robust tooling and ability to
    make code more maintainable and understandable, but it’s certainly not just for
    big, enterprise projects!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript，简称 TS，是微软的产品。它是一种编程语言，是 JavaScript 的超集，这意味着它为 JavaScript 添加了新功能，最重要的是静态类型。这有助于在开发早期捕获错误。你需要将其转换为纯
    JavaScript，以便它可以在任何支持 JavaScript 的地方运行。由于其强大的工具和使代码更易于维护和理解的特性，TS 在大型项目中很受欢迎，但当然不仅仅适用于大型企业项目！
- en: 'TS isn’t just about static typing though – it has other benefits:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 TypeScript 不仅仅是关于静态类型，但它还有其他好处：
- en: '*Interfaces and classes*: TS supports **object-oriented programming** (**OOP**)
    concepts such as interfaces and classes, making it easier to structure complex
    systems and enforce contracts between different parts of your code. This is a
    more advanced topic that I won’t be covering in this book, but it’s something
    important for TS to support (JavaScript supports classes natively, though TS enhances
    this a fair bit).'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接口和类*：TypeScript 支持 **面向对象编程**（**OOP**）概念，如接口和类，这使得结构化复杂系统并强制代码不同部分之间的契约变得更加容易。这是一个更高级的话题，本书中不会涉及，但这是
    TypeScript 支持的重要特性（尽管 JavaScript 本地支持类，但 TypeScript 在这方面增强了很多）。'
- en: '*Advanced types*: TS includes advanced types such as enums, tuples, and generics,
    allowing for more precise and flexible code (these, too, are more advanced topics
    not covered in this book).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高级类型*：TypeScript 包含高级类型，如枚举、元组和泛型，这使得代码更加精确和灵活（这些也是本书中未涉及的高级话题）。'
- en: '*Type inference*: TS can often infer types, reducing the need to explicitly
    annotate code. This means that you don’t *always* have to specify a type because
    TS can oftentimes figure out what the right type is on its own.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型推断*：TypeScript 通常可以推断类型，减少了显式注释代码的需求。这意味着你不必 *总是* 指定类型，因为 TypeScript 通常可以自己确定正确的类型。'
- en: '*Compatibility with JS*: TS is a superset of JavaScript, so any valid JavaScript
    code is also valid TS code. This makes it easier to adopt incrementally if you
    have an existing JavaScript code base that you want to convert into TS. You don’t
    need to do it all at once, which is very helpful if it’s a large code base.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与 JavaScript 的兼容性*：TypeScript 是 JavaScript 的超集，所以任何有效的 JavaScript 代码也是有效的
    TypeScript 代码。如果你有一个现有的 JavaScript 代码库并希望将其转换为 TypeScript，这将使渐进式采用变得更加容易。你不需要一次性完成，这对于大型代码库来说非常有帮助。'
- en: '*Tooling*: TS offers powerful tools for large projects, such as auto-completion,
    navigation, and refactoring, owing to its high level of support in IDEs and other
    developer tools.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*工具*：TypeScript 为大型项目提供了强大的工具，如自动完成、导航和重构，这得益于其在 IDE 和其他开发者工具中的高度支持。'
- en: Now, let’s take a look at TS in action.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 TypeScript 在实际中的应用。
- en: A simple TS example
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的 TypeScript 示例
- en: 'To get started with TS, the first step is installing the TS compiler (well,
    really transpiler). To do so, start by using `npm init` in a new project with
    npm, then install TS itself:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 TypeScript，第一步是安装 TypeScript 编译器（实际上是一个转换器）。为此，首先在一个新的 npm 项目中使用 `npm
    init`，然后安装 TypeScript 本身：
- en: '[PRE20]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As before, this has already been done in the `ch-06/typescript` directory.
    In that same directory, you’ll find a file called `example.ts`. To compile it,
    execute this command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这已经在 `ch-06/typescript` 目录中完成。在同一个目录中，你会找到一个名为 `example.ts` 的文件。要编译它，执行以下命令：
- en: '[PRE21]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `tsc` command is the TS compiler. It will produce an `example.js` file,
    transpiling our TS code into pure JavaScrfipt. You can then run that JavaScript
    file (which you could not do with the TS file – go ahead and try it!) with Node:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsc` 命令是 TypeScript 编译器。它将生成一个 `example.js` 文件，将我们的 TypeScript 代码转换为纯 JavaScript。然后你可以使用
    Node 运行那个 JavaScript 文件（你无法用 TypeScript 文件这样做——试试看吧！）：'
- en: '[PRE22]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let’s look at the code in `example.ts`. This is our actual TS source code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `example.ts` 中的代码。这是我们实际的 TypeScript 源代码：
- en: '[PRE23]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first thing we did is create a class. This is part of OOP that I mentioned
    earlier, and in simple terms, a class is a blueprint. It defines a thing that
    we can then create instances of earlier. Here, we have a `Person` class. Classes
    usually hold some kind of data, in fields, and here, there are two: `name` and
    `age`. This is also the first time you can see some data types being used: the
    part after the field name and semicolon is the type of that field. So, we’re saying
    that the name field must be a `string` type, and the age field must be a `number`
    type.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的是创建一个类。这是我在前面提到的OOP的一部分，简单来说，一个类是一个蓝图。它定义了一个我们可以创建实例的东西。在这里，我们有一个`Person`类。类通常在字段中持有某种数据，这里有两个：`name`和`age`。这也是你第一次看到一些数据类型的使用：字段名和分号后面的部分是那个字段的类型。所以，我们说`name`字段必须是`string`类型，`age`字段必须是`number`类型。
- en: Next, we need to add a function to the class. In this case, it’s a special function
    named `constructor()`. A constructor is a function in a class that will be executed
    whenever we create an instance of that class (and you can have multiple instances
    of a class in most cases). This particular function takes in two arguments, `inName`
    and `inAge`. And here, again, types – which are referred to as `inName`, we’ll
    get an error when we compile this code. Inside the function, the values of the
    `name` and `age` fields are set to the values that were passed in (`inName` and
    `inAge`, respectively). Writing `this` before the field names means that we’re
    setting the value on the instance of the class created later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向类中添加一个函数。在这种情况下，它是一个名为`constructor()`的特殊函数。构造函数是一个类中的函数，每次我们创建该类的实例时都会执行（在大多数情况下，你可以有多个类的实例）。这个特定的函数接受两个参数，`inName`和`inAge`。在这里，同样有类型——被称为`inName`，如果我们编译这段代码，将会得到一个错误。在函数内部，`name`和`age`字段的值被设置为传递进来的值（分别是`inName`和`inAge`）。在字段名前写`this`意味着我们正在设置稍后创建的类的实例的值。
- en: Next, we add another function, this one named `speak()`. This will output a
    simple string telling us the person’s name, how old the person is, and a little
    bit of wisdom we’ll provide later. This just uses basic string interpolation to
    output the value of the fields, again referenced using `this`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加另一个函数，这个函数名为`speak()`。这个函数将输出一个简单的字符串，告诉我们这个人的名字、年龄以及我们稍后提供的智慧。这仅仅使用了基本的字符串插值来输出字段的值，再次使用`this`来引用。
- en: Now, we’ve defined the `Person` class, but on its own, that does nothing. We
    have to make use of this class by creating one or more instances of it. That’s
    the first line of code after the end of the class definition. Here, a variable
    named `p` is defined, and we apply a type annotation of the `Person` type. To
    create an instance of a class, we use the `new Person()` code as the value of
    the variable, and pass `name` and `age` values to it. This executes that `constructor()`
    function, and we now have a `Person` object referenced by the `p` variable with
    the `name` field having a value of “Xander” and the `age` field with a value of
    36.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了`Person`类，但仅凭它本身并不能做什么。我们必须通过创建一个或多个该类的实例来利用这个类。这是类定义结束后的第一行代码。在这里，定义了一个名为`p`的变量，并给它应用了`Person`类型的类型注解。要创建类的实例，我们使用`new
    Person()`代码作为变量的值，并向它传递`name`和`age`值。这执行了`constructor()`函数，现在我们有一个通过`p`变量引用的`Person`对象，其中`name`字段值为“Xander”，`age`字段值为36。
- en: Finally, we want to make Xander speak, so we call the `speak()` method on `p`,
    passing it the bit of wisdom to show via `console.log()` (a witty bit of dialogue
    from an old movie named *Jekyll and Hyde… Together Again* – check it out, it’s
    funny!).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想让Xander说话，所以我们调用`p`上的`speak()`方法，并通过`console.log()`（一部老电影《杰基尔与海德：再次在一起》中的机智对白——去看看，很有趣！）传递给他要展示的智慧。
- en: 'Now, let’s see what the results of compiling that TS code are in the `example.js`
    file that’s created:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看编译那个TS代码的结果是什么，在创建的`example.js`文件中：
- en: '[PRE24]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Well, that looks a bit different, doesn’t it? The differences start with that
    first line. Since classes may not be natively supported by the browser (or version
    of Node) that runs this code, `tsc` has used a trick called an **IIFE**, which
    stands for **Immediately Invoked Function Expression**. This is a nifty little
    trick where you create a function (an anonymous function, because it doesn’t have
    a name), and then immediately call it while wrapping that execution in parenthesis.
    Here’s the basic form of this technique in plain JavaScript and without all the
    preceding code to confuse matters:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这看起来有点不同，不是吗？差异始于第一行。由于类可能不被运行此代码的浏览器（或Node版本）原生支持，`tsc`使用了一个叫做**IIFE**（立即调用的函数表达式）的技巧。这是一个巧妙的小技巧，你创建一个函数（一个匿名函数，因为它没有名字），然后立即调用它，同时将执行包裹在括号中。以下是这种技术在纯JavaScript中的基本形式，没有所有前面的代码来混淆问题：
- en: '[PRE25]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The reason we do this is so that everything inside the enclosing parenthesis
    creates what we call a `Person`, and then returning it, which is assigned to the
    `Person` variable outside. If we didn’t return it, then it wouldn’t be accessible
    to code outside the enclosing parenthesis. The result is the equivalent in JavaScript
    of defining a class in TS, but as you can see, it’s a bit more code.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做的原因是，括号内部的所有内容都创建了我们所说的`Person`对象，然后返回它，这个返回值被分配给外部的`Person`变量。如果我们不返回它，那么它将无法被括号外的代码访问。结果是，在JavaScript中与在TS中定义类等效，但正如你所见，这需要更多的代码。
- en: By the way, the `/** @class */` line in the `example.js` code is a hint to certain
    tools (some of which are discussed in the next chapter) that help it do its job.
    They’re markers – that is, signs that provide some metadata to the tools. In this
    case, they’re telling it this is a class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`example.js`代码中的`/** @class */`行是给某些工具（其中一些将在下一章讨论）的一个提示，这些工具可以帮助它完成其工作。它们是标记——也就是说，提供一些元数据的标记。在这种情况下，它们在告诉它这是一个类。
- en: 'Inside the IIFE, you can see how the `speak()` function is added to the `Person`
    function. This is a thing you can do in JavaScript because functions are objects.
    Every object has a prototype, which conceptually is the same as a class in OOP:
    it’s a blueprint from which all instances come, so anything that prototype has,
    all the instances of it will also have. So, with the `Person.prototype.speak`
    code, we’re saying that we want to add a thing called `speak` to all instances
    of `Person`, and the thing we want speak to is the function we assign to it.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在IIFE内部，你可以看到` speak()`函数是如何被添加到`Person`函数中的。这是JavaScript中你可以做到的一件事，因为函数是对象。每个对象都有一个原型，从概念上讲，它与OOP中的类相同：它是一个蓝图，所有实例都由此而来，所以原型上有的任何东西，它的所有实例都会有。所以，通过`Person.prototype.speak`代码，我们是在说我们想要给`Person`的所有实例添加一个名为`speak`的东西，而我们想要`speak`的是我们分配给它的函数。
- en: Then, inside that `speak()` function, you can see how `tsc` has replaced our
    string interpolation tokens with the `concat()` function, which is a function
    JavaScript provides on strings to cram them together. Since string interpolation
    is a somewhat newer feature of JavaScript, it may not be supported yet in some
    browsers of versions of Node. `tsc` knows this by default and polyfills them with
    the use of `concat()` instead.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在` speak()`函数内部，你可以看到`tsc`是如何用`concat()`函数替换我们的字符串插值标记的，这是JavaScript提供的一个用于将字符串拼接在一起的函数。由于字符串插值是JavaScript的一个相对较新的特性，它可能还不会被某些浏览器或Node版本支持。`tsc`默认知道这一点，并通过使用`concat()`来填充它们。
- en: Note that all the type annotations have been removed throughout this code. That’s
    because they would be syntax errors in pure JavaScript, and anyway, they aren’t
    needed anymore. Remember that the whole point of TS is to catch data typing errors
    at compile time, so after the code is compiled (transpiled, really) to JavaScript,
    they no longer serve a purpose anyway.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这段代码中已经移除了所有的类型注解。这是因为它们在纯JavaScript中会是语法错误，而且无论如何，它们也不再需要了。记住，TS的整个目的就是在编译时捕获数据类型错误，所以一旦代码编译（实际上是通过转译）成JavaScript，它们就不再有任何作用了。
- en: From this relatively simple example, you can get a sense of TS. You can see
    how it is just an extension of JavaScript, including building classes and annotating
    things with types.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个相对简单的例子中，你可以对TS有一个感觉。你可以看到它只是JavaScript的一个扩展，包括构建类和用类型注解注解事物。
- en: 'Now would be a good time to see why we want to do this, and what happens when
    you have a data typing issue. So, after the last line of code, add this one:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们为什么要这样做，以及当你有一个数据类型问题时会发生什么。所以，在代码的最后一行之后，添加这一行：
- en: '[PRE26]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, execute `npx tsc example.ts` again; you should see an error telling you
    about the mistake and exactly where it is. This is the big thing TS is about:
    that error won’t occur when your site is live, and there isn’t any mystery about
    what the error is given the message `tsc` gives you. It’s a big benefit, and it’s
    why TS has rapidly become almost the de facto way modern website code is written.
    It’s getting more and more rare to see people writing “naked” JavaScript.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次执行 `npx tsc example.ts`；你应该会看到一个错误信息，告诉你错误的具体位置。这就是 TypeScript 的一个重要特点：当你的网站上线时，这种错误不会发生，并且由于
    `tsc` 给出的信息，关于错误的内容不会有任何神秘感。这是一个很大的好处，这也是为什么 TypeScript 迅速成为现代网站代码编写的事实标准。现在越来越少看到人们编写“裸”JavaScript。
- en: TS is a far more robust language than I’m showing here, but it would take far
    more pages than this to detail it all. As with the overarching theme of this book,
    I’m not trying to teach you every last detail of TS – I’m just introducing the
    concept and giving you some foundation of understanding.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是一个比这里展示的更健壮的语言，但要详细说明所有这些内容需要更多的页面。与这本书的主题一样，我并不是试图教你 TypeScript
    的每一个细节——我只是介绍这个概念，并给你一些理解的基础。
- en: Now that you know about transpilers and TS, let’s look at a category of tools
    that can make use of both, namely bundlers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了转译器和 TypeScript，让我们看看一类可以同时利用两者的工具，即打包器。
- en: Packing up and going – bundlers
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包并部署 - 打包器
- en: There was a time when web development was easy. You’d create some HTML, CSS,
    and JavaScript files, import the CSS and JavaScript files into your page, and
    you were good to go. After a while, though, things got much more complex. This
    JavaScript file depended on that one, and maybe parts of a given library you were
    using weren’t even needed, so why bother loading it on your page?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，网页开发很简单。你会创建一些 HTML、CSS 和 JavaScript 文件，将 CSS 和 JavaScript 文件导入到你的页面中，然后就可以开始了。然而，过了一段时间，事情变得复杂得多。这个
    JavaScript 文件依赖于那个，也许你使用的某个库的部分内容甚至并不需要，那么为什么还要在你的页面上加载它呢？
- en: When your project outgrows one or two source files, matters get complicated
    very quickly if you want to keep some semblance of sanity while ensuring the optimal
    performance of your website.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的项目超出一个或两个源文件时，如果你想在确保网站性能最优的同时保持一定的理智，那么事情会迅速变得复杂。
- en: Managing all that complexity is where something called a **bundler** comes into
    the picture.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 管理所有这些复杂性正是打包器发挥作用的地方。
- en: The overall purpose of a bundler – which typically is just a command-line interface
    tool – is to streamline and optimize the process of turning your development code
    into a production-ready package. This typically involves combining multiple JavaScript
    files into a single JavaScript file that has all unnecessary code removed. This
    can also involve things such as combining CSS files, converting images into JavaScript
    structure, transpiling TS and JSX into JavaScript, and much more.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 打包器的总体目的——它通常只是一个命令行界面工具——是简化并优化将你的开发代码转换为生产就绪包的过程。这通常涉及将多个 JavaScript 文件合并成一个单一的
    JavaScript 文件，其中移除了所有不必要的代码。这也可以包括合并 CSS 文件、将图片转换为 JavaScript 结构、将 TypeScript
    和 JSX 转译为 JavaScript 等更多操作。
- en: 'Here are some of the key reasons why bundlers are important to modern web development:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是打包器对现代网页开发重要的几个关键原因：
- en: '*Handling dependencies*: Modern websites and apps often use a variety of libraries,
    frameworks, and toolkits. Bundlers manage these dependencies efficiently, ensuring
    that everything your app needs is included in your final build artifact and nothing
    unnecessary bloats the final product.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理依赖关系*：现代网站和应用经常使用各种库、框架和工具包。打包器高效地管理这些依赖关系，确保你的应用需要的所有内容都包含在最终的构建工件中，并且没有任何不必要的冗余增加了最终产品的体积。'
- en: '*Module bundling*: JavaScript has evolved to use modules, which is a way to
    better organize your code, but browsers have varying levels of support for module
    systems. Bundlers can take modules written in different formats and combine them
    into a single file, or a few files that work universally. We call these files
    **bundles**, but at the end of the day, they’re nothing but JavaScript files,
    though they can include things other than JavaScript in some cases – things such
    as images and CSS files can be converted into a form of JavaScript so that only
    a single file has to be requested when your website loads rather than multiple
    if these things were separate files.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块打包*：JavaScript已经发展到使用模块，这是一种更好地组织代码的方式，但浏览器对模块系统的支持程度各不相同。打包器可以将用不同格式编写的模块组合成一个文件，或者几个通用的文件。我们称这些文件为**包**，但最终，它们只是JavaScript文件，尽管在某些情况下它们可以包含除了JavaScript之外的内容——例如，图像和CSS文件可以转换成JavaScript的形式，这样在您的网站加载时，只需要请求一个文件，而不是多个如果这些是单独的文件的话。'
- en: '*Performance optimization*: Bundlers minify and compress your code, which reduces
    load times for your users. This includes tree shaking (hold that thought!), splitting
    code into smaller chunks for faster loading, and optimizing asset loading, like
    images and stylesheets.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能优化*：打包器会压缩和压缩您的代码，这减少了用户加载时间。这包括摇树（记住这个想法！），将代码分割成更小的块以实现更快的加载，以及优化资产加载，如图片和样式表。'
- en: '*Development efficiency*: Bundlers often come with features such as hot reloading,
    which allows you to see changes in real time without a full page reload. This
    speeds up development and debugging. They also typically include a built-in development
    server, which saves you from having to set up a web server (as simple as that
    can be, as you saw earlier).'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发效率*：打包器通常带有诸如热重载等特性，这允许您在不进行完整页面重新加载的情况下实时查看更改。这加快了开发和调试速度。它们通常还包括一个内置的开发服务器，这可以节省您设置Web服务器（就像您之前看到的那样简单）。'
- en: '*Transpilation support*: They also integrate with tools such as Babel to allow
    you to use more modern JavaScript features that aren’t yet supported in all browsers,
    ensuring compatibility.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转译支持*：它们还与Babel等工具集成，允许您使用更多现代JavaScript特性，这些特性在所有浏览器中尚未得到支持，从而确保兼容性。'
- en: '*Environment variables*: Bundlers allow you to use different settings or configurations,
    depending on whether you’re in development or production. In other words, just
    by setting a variable in, say, a configuration file, a bundler can know to perform
    other steps that you would only want to be done in your final, ready-for-the-real-world
    product.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*环境变量*：打包器允许您根据您是在开发还是生产环境中使用不同的设置或配置。换句话说，只需在配置文件中设置一个变量，打包器就可以知道执行您只想在最终、准备投入实际使用的成品中完成的步骤。'
- en: Bundlers work by building a *dependency graph*. This is a fancy way of saying
    that it scans all the source files for your project and determines what code depends
    on what other code. It then uses a technique called *tree shaking* to get rid
    of what isn’t needed. It’s a lot like when you go to cut down a Christmas tree
    and they put the tree in those machines that shake the tree so any loose branches
    and such fall out. With tree shaking, unused code can be removed safely.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 打包器通过构建一个*依赖图*来工作。这是一种说法，即它扫描您的项目中的所有源文件，并确定哪些代码依赖于其他代码。然后它使用一种称为*摇树*的技术来去除不需要的代码。这就像当你去砍圣诞树时，他们把树放在那些摇树的机器里，这样任何松散的树枝等都会掉下来。通过摇树，可以安全地移除未使用的代码。
- en: The output of this process is one or more JavaScript files that are highly optimized
    and contain only what your website needs to work. That means the files will load
    faster since there’s less to transfer over the network, and the browser can use
    them more efficiently since there’s less code for it to deal with. In addition,
    things such as CSS and even images can be embedded in these JavaScript files,
    which means that when your HTML page is loaded, fewer requests need to be made,
    further leading to improved performance.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程的输出是一个或多个高度优化的JavaScript文件，其中只包含您的网站工作所需的内容。这意味着文件将加载得更快，因为要传输的网络内容更少，浏览器可以更有效地使用它们，因为它要处理的代码更少。此外，CSS甚至图像可以嵌入到这些JavaScript文件中，这意味着当您的HTML页面加载时，需要发出的请求更少，从而进一步提高了性能。
- en: There are a few big names in bundlers today, including Webpack, Rollup, and
    Vite. They all have the same basic goal and work in similar ways, but they have
    their differences too.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的打包器中，有一些响当当的大牌，包括 Webpack、Rollup 和 Vite。它们都有着相同的基本目标，并且工作方式相似，但它们之间也存在一些差异。
- en: 'Webpack is kind of the village elder at this point, being one of the first
    bundlers (though not the first: that honor goes to Browserify in 2011) and certainly
    the most successful and well-known at the time of writing. You configure it using
    JSON files, telling it about your project’s structure and defining what you want
    it to do when you bundle your project. It has a large number of plugins available
    to extend its capabilities. For example, `HtmlWebpackPlugin` can save you the
    effort of even writing an HTML file yourself, creating it for you on the fly.
    `ImageMinimizerWebpackPlugin` can compress images so that they are smaller in
    size, thereby making them load faster. There are around 30 official plugins and
    probably another dozen or so created by the Webpack community of users. It is
    a full-featured bundler that can do practically everything a bundler should.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，Webpack 可以说是村里的长者，它是首批打包器之一（尽管不是第一个：这个荣誉属于 2011 年的 Browserify），而且在写作时无疑是成功和知名度最高的。你通过
    JSON 文件来配置它，告诉它你的项目结构以及当你打包项目时你希望它执行的操作。它提供大量插件来扩展其功能。例如，`HtmlWebpackPlugin` 可以帮你省去编写
    HTML 文件的麻烦，它会自动为你创建。`ImageMinimizerWebpackPlugin` 可以压缩图片，使它们体积更小，从而加快加载速度。大约有
    30 个官方插件，以及可能由 Webpack 用户社区创建的另一打左右。它是一个功能齐全的打包器，几乎可以做任何打包器应该做的事情。
- en: But it’s fallen out of favor a little bit due to the emergence of rivals such
    as Vite and Rollup. These two seek to outdo Webpack in terms of being simpler
    to configure, easier to understand overall (Webpack can sometimes be a challenge
    to follow mentally), and often faster and more lightweight. All of them provide
    a plugin ecosystem, basic module bundling, and the ability to act as a development
    web server for you as you code, and they can all do what’s called **code splitting**,
    which is dividing up your code into logical units that you can then only load
    when necessary rather than just loading everything upfront when it may not yet
    be needed (and may *never* be needed).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于 Vite 和 Rollup 等竞争对手的出现，Webpack 逐渐失去了青睐。这两个工具都试图在配置更简单、整体上更容易理解（Webpack 有时在心理上可能难以跟上）以及通常更快、更轻量级方面超越
    Webpack。所有这些工具都提供了一个插件生态系统、基本的模块打包功能，以及在你编码时作为你的开发服务器的能力。它们都可以进行所谓的 **代码拆分**，即将你的代码分割成逻辑单元，你可以在需要时才加载，而不是一开始就加载所有内容（可能还不需要，甚至可能永远不需要）。
- en: 'While all three serve the same basic purpose and have a lot in common, they
    also have their differences (and to state the obvious: I’m talking in broad generalities
    here):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这三个都服务于相同的基本目的，并且有很多共同之处，但它们也存在差异（并且显然我要在这里说的是：我在这里谈论的是一些宽泛的概括）：
- en: '*Comprehensiveness*: While Vite and Rollup provide a lot of the same functionality,
    Webpack tends to offer a bit more, owing to its age. Webpack is a full-featured
    bundler, handling a wide range of tasks beyond just bundling (such as asset management
    and loader transformations).'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全面性*：虽然 Vite 和 Rollup 提供了很多相同的功能，但 Webpack 由于其历史原因，通常会提供更多一些。Webpack 是一个功能齐全的打包器，除了打包之外，还处理广泛的任务（如资产管理和服务器端渲染）。'
- en: '*Configuration*: Webpack is known for being highly configurable, but this can
    be complex and overwhelming. Vite and Rollup tend to be simpler, sometimes greatly
    so. They do this largely by having intelligent defaults, which means you simply
    tend to have to write your own configuration less with these than with Webpack.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置*：Webpack 以高度可配置而闻名，但这可能很复杂，令人不知所措。Vite 和 Rollup 通常更简单，有时简单得多。它们通过提供智能默认值来实现这一点，这意味着你使用这些工具时，通常不需要自己编写太多的配置，与
    Webpack 相比要少得多。'
- en: '*Build time*: Webpack will generally have the slowest build times compared
    to Vite and Rollup, especially the larger a project gets.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建时间*：与 Vite 和 Rollup 相比，Webpack 通常会有更慢的构建时间，尤其是项目规模越大时。'
- en: '*Development experience*: Vite and Rollup support **hot module replacement**
    (**HMR**), better than Webpack, which means that as you develop with these tools
    you can have a better experience when your code changes since reloading things
    will largely be handled automatically. While Webpack can do some of this too,
    Vite and Rollup tend to be better at it, especially with more modern code bases.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发体验*：Vite和Rollup支持**热模块替换**（**HMR**），比Webpack做得更好，这意味着当你使用这些工具进行开发时，代码更改时你可以拥有更好的体验，因为重新加载东西将主要被自动处理。虽然Webpack也能做这些，但Vite和Rollup在这方面通常做得更好，尤其是在更现代的代码库中。'
- en: '*Output efficiency*: Vite, and especially Rollup, tend to do a better job at
    optimizing output bundles than Webpack.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输出效率*：Vite，尤其是Rollup，在优化输出包方面通常比Webpack做得更好。'
- en: '*Overhead*: Vite and Rollup don’t include as many built-in features as Webpack,
    leading to less overhead but potentially more manual setup for complex tasks.
    They are very much 80/20 tools, meaning they’ll do 80% of the work you need them
    to do very easily, but the last 20% can be rather difficult (whereas Webpack tends
    to be more difficult – relatively speaking – all the time).'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开销*：Vite和Rollup不像Webpack那样包含许多内置功能，这导致开销更小，但可能需要更多手动设置来完成复杂任务。它们在很大程度上是80/20的工具，这意味着它们可以非常容易地完成你需要的80%的工作，但最后20%可能相当困难（而Webpack则相对而言总是更困难）。'
- en: While bundlers are very common in modern web development, they are a slightly
    more advanced topic because they are always optional. First, you may not need
    what they provide at all. Second, even if you do, you could simply write things
    such as shell scripts, batch files, or simple Python or Node scripts to do what
    they do in a way more specific to your needs. However, they do provide a lot of
    features and capabilities that modern web developers need, which is why they have
    become so popular over the years.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然打包器在现代网络开发中非常常见，但它们是一个稍微高级一点的话题，因为它们总是可选的。首先，你可能根本不需要它们提供的东西。其次，即使你需要，你也可以简单地编写诸如shell脚本、批处理文件或简单的Python或Node脚本，以更符合你需求的方式完成它们所做的工作。然而，它们确实提供了现代Web开发者需要的许多功能和能力，这也是为什么它们在近年来变得如此受欢迎的原因。
- en: In summary, bundlers are a good thing because they handle the complexities of
    modern web development, optimize performance, and enhance the development experience,
    making it easier to build sophisticated and efficient websites and web apps.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，打包器是一个好东西，因为它们处理了现代网络开发的复杂性，优化了性能，并提升了开发体验，使得构建复杂且高效的网站和Web应用变得更加容易。
- en: Reviewing the roadmap
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查路线图
- en: 'The mystery of the squares is falling away quickly now, isn’t it?! *Figure
    6**.4* shows the updated web developer roadmap:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在方块的神秘感正在迅速消失，不是吗？！*图6.4*显示了更新的Web开发者路线图：
- en: '![Figure 6.4: The roadmap, with a few more boxes filled in](img/B18315_06_04_NEW.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：路线图，填入了一些更多的盒子](img/B18315_06_04_NEW.jpg)'
- en: 'Figure 6.4: The roadmap, with a few more boxes filled in'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：路线图，填入了一些更多的盒子
- en: This time around, you’ve uncovered the **Frameworks**, **TypeScript**, and **Bundlers**
    boxes. There’s not many left now, is there? Woo-hoo!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你已经揭开了**框架**、**TypeScript**和**打包器**的盒子。现在剩下不多了吧？哇哦！
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at some of the tools that, in general terms, make
    up what we think of as *modern* web development. This includes libraries such
    as React and Vue (and also jQuery, though that one isn’t considered modern anymore),
    frameworks such as Angular, and meta frameworks such as Next. We looked at some
    CSS tools too, Bootstrap and Tailwind in particular. All of these were shown to
    provide a lot of benefits in terms of writing as little code as possible to get
    the job done, improving delivery velocity and robustness of the end product.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们查看了一些工具，从广义上讲，它们构成了我们所说的*现代*网络开发。这包括React和Vue（以及jQuery，尽管那个不再被认为是现代的），Angular这样的框架，以及Next这样的元框架。我们还查看了一些CSS工具，特别是Bootstrap和Tailwind。所有这些都被证明在尽可能少写代码以完成任务、提高交付速度和最终产品的健壮性方面提供了很多好处。
- en: We also talked about TS and Babel, and you learned how data typing is a benefit
    in modern development, but at the cost of the need to transpile.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了TS和Babel，你学习了数据类型在现代开发中的好处，但代价是需要进行转译。
- en: Finally, we talked about some modern build tools such as packers and bundlers,
    and how they help you deploy just the code you need and remove a lot of the tedium
    of building your application.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了一些现代构建工具，例如打包器和打包器，以及它们如何帮助你部署所需的代码，并消除构建应用程序的许多繁琐工作。
- en: In the next chapter, we’ll jump back to the server side of things and talk about
    some other technologies besides Node that you might choose to build your server-side
    code with. This will include PHP, Python (a bit more), Java, and its popular Spring
    Boot framework, and .NET. We’ll also talk about some general topics that are very
    important on the server side, including databases and something called REST APIs.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到服务器端，并讨论一些除了Node之外你可能选择用于构建服务器端代码的其他技术。这包括PHP、Python（稍微多一点）、Java及其流行的Spring
    Boot框架，以及.NET。我们还将讨论一些在服务器端非常重要的通用主题，包括数据库和称为REST API的东西。
- en: Grab a quick snack and a drink (alcoholic or non-alcoholic is entirely up to
    you!) and come right back here for the next exciting chapter!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 快速吃点小吃和喝点东西（酒精或非酒精完全取决于你！）然后直接回到这里，继续阅读下一章的精彩内容！
