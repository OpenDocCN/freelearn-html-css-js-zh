- en: Chapter 9. Adding Extra Capabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。添加额外功能
- en: We are almost on the final stage of our application. Ext JS provides great capabilities,
    but there are some capabilities that we need to code by ourselves with the help
    of other technologies. Despite possessing a GridPanel with paging, sorting, and
    filter capabilities, sometimes the user is going to expect more from the application.
    Adding features such as printing, the ability to export to Excel and PDF, and
    the ability to export charts to images and PDF can add great value to the application
    and please the final user.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎到了应用程序的最后阶段。Ext JS 提供了强大的功能，但还有一些功能我们需要借助其他技术自己编码。尽管我们拥有具有分页、排序和过滤功能的 GridPanel，但有时用户可能会对应用程序有更高的期望。添加打印、导出到
    Excel 和 PDF 以及将图表导出到图片和 PDF 的功能可以为应用程序增添巨大价值，并取悦最终用户。
- en: 'So, in this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖：
- en: Printing records of a GridPanel
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 GridPanel 的记录
- en: Exporting GridPanel information to PDF and Excel
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 GridPanel 信息导出为 PDF 和 Excel
- en: Creating charts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图表
- en: Exporting charts to PDF and images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图表导出到 PDF 和图片
- en: Using third-party plugins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方插件
- en: Exporting a GridPanel to PDF and Excel
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 GridPanel 导出为 PDF 和 Excel
- en: The first capability we are going to implement is exporting the contents of
    a GridPanel to PDF and Excel. We will implement these features for the `Films`
    GridPanel we implemented in the preceding chapter. However, the logic is the same
    for any GridPanel you might have in an Ext JS application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一项功能是将 GridPanel 的内容导出到 PDF 和 Excel。我们将为前一章中实现的 `Films` GridPanel 实现这些功能。然而，对于您可能在
    Ext JS 应用程序中拥有的任何 GridPanel，逻辑都是相同的。
- en: 'The first thing we are going to do is add the export buttons to the GridPanel
    toolbar. We will add three buttons: one to **Print** the contents of the GridPanel
    (we will develop this feature later, but let''s add this button right now), one
    button for **Export to PDF**, and one button for **Export to Excel**:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是将导出按钮添加到 GridPanel 工具栏中。我们将添加三个按钮：一个用于打印 GridPanel 的内容（我们将在稍后开发这个功能，但现在让我们先添加这个按钮），一个用于
    **导出到 PDF** 的按钮，以及一个用于 **导出到 Excel** 的按钮：
- en: '![Exporting a GridPanel to PDF and Excel](img/0457OT_09_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![将 GridPanel 导出为 PDF 和 Excel](img/0457OT_09_01.jpg)'
- en: 'Remember that in the preceding chapter, we created a toolbar, `Packt.view.base.TopToolBar`.
    We are going to add these three buttons on this toolbar:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在前一章中，我们创建了一个工具栏，`Packt.view.base.TopToolBar`。我们将在该工具栏上添加这三个按钮：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All buttons have `listeners` that we will handle in the ViewController. In this
    case, buttons will be in the `FilmsController` class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有按钮都有 `listeners`，我们将在 ViewController 中处理。在这种情况下，按钮将位于 `FilmsController` 类中。
- en: 'Inside the `Glyphs` class, we are also going to add the following attributes
    to represent the icons:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Glyphs` 类中，我们还将添加以下属性来表示图标：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Exporting to PDF
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出到 PDF
- en: Now that the buttons are being displayed on the `Films` GridPanel, it is time
    to go back to `FilmsController` and add these capabilities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按钮已经在 `Films` GridPanel 中显示，是时候回到 `FilmsController` 并添加这些功能了。
- en: 'The first button we are going to listen to is the **Export to PDF** `click`
    event. When the user clicks on this button, we will execute the following method:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将监听第一个按钮的 **导出到 PDF** `click` 事件。当用户点击此按钮时，我们将执行以下方法：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What we want to implement is that when the user clicks on the **Export to PDF**
    button, a new tab (`#4`) will be opened with the PDF file in it. This means we
    need to get that **Main** **Panel** class (xtype `mainpanel`) we declared as the
    center item of the Viewport of the application (`#1`), add a new tab to it, and
    as the PDF file will be inside it, we can implement it as **iFrame**. To implement
    iFrame in Ext JS, we can use the iFrame plugin (`#2`) that is distributed within
    the SDK.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要实现的是，当用户点击 **导出到 PDF** 按钮时，将打开一个新标签页（`#4`），其中包含 PDF 文件。这意味着我们需要获取我们声明的作为应用程序视口中心项的
    **Main** **Panel** 类（xtype `mainpanel`）（`#1`），向其中添加一个新标签页，由于 PDF 文件将包含在其中，我们可以将其实现为
    **iFrame**。要在 Ext JS 中实现 iFrame，我们可以使用 SDK 内部分发的 iFrame 插件（`#2`）。
- en: Inside the ViewController, we have access to the `Films` View, but we need to
    access `mainpanel`. We can get the `Films` View using the `getView` method and
    then use the `up` method to get `mainpanel`, or we can use `Ext.ComponentQuery`
    to query `mainpanel`. Remember that `Ext.ComponentQuery` returns an array of all
    matching results, but as we know, there is only one `mainPanel` in the application,
    so we can retrieve the first position.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ViewController 内部，我们可以访问 `Films` 视图，但我们需要访问 `mainpanel`。我们可以使用 `getView` 方法获取
    `Films` 视图，然后使用 `up` 方法获取 `mainpanel`，或者我们可以使用 `Ext.ComponentQuery` 来查询 `mainpanel`。记住，`Ext.ComponentQuery`
    返回所有匹配结果的数组，但正如我们所知，应用程序中只有一个 `mainPanel`，因此我们可以检索第一个位置。
- en: 'Now comes the most important part: Ext JS does not provide the **Export to
    PDF** capability natively. If we want the application to have it, we need to implement
    it using a different technology. In this case, the PDF will be generated on the
    server side (`#3`), and we will only display its output inside the iFrame.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是：Ext JS 并没有提供原生的 **导出为 PDF** 功能。如果我们想让应用程序具备这个功能，我们需要使用不同的技术来实现。在这种情况下，PDF
    将在服务器端生成（`#3`），我们将在 iFrame 内部显示其输出。
- en: 'When we execute the code, we will get the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行代码时，我们将得到以下输出：
- en: '![Exporting to PDF](img/0457OT_09_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![导出为 PDF](img/0457OT_09_02.jpg)'
- en: Generating the PDF file on the server – PHP
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在服务器上生成 PDF 文件 – PHP
- en: As we need to generate the file on the server side, we can use any framework
    or library that is available for the language we are using on the server. We can
    use *TCPDF* ([http://www.tcpdf.org/](http://www.tcpdf.org/)). There are other
    libraries as well, and you can use the one you are most familiar with.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要在服务器端生成文件，因此我们可以使用服务器端使用的任何框架或库。我们可以使用 *TCPDF* ([http://www.tcpdf.org/](http://www.tcpdf.org/))。还有其他库可供选择，你可以使用你最熟悉的那个。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are using Java, you can use *iText* ([http://itextpdf.com/](http://itextpdf.com/)),
    and if you are using .NET, you can use *excellibrary* ([https://code.google.com/p/excellibrary/](https://code.google.com/p/excellibrary/)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Java，你可以使用 *iText* ([http://itextpdf.com/](http://itextpdf.com/))，如果你使用的是
    .NET，你可以使用 *excellibrary* ([https://code.google.com/p/excellibrary/](https://code.google.com/p/excellibrary/))。
- en: Generating and viewing the PDF file with JavaScript – HTML5
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 JavaScript – HTML5 生成和查看 PDF 文件
- en: Thanks to HTML5, it is also possible to generate a PDF file using the HTML5
    API. There are a few solutions that we can use to generate the file without using
    any server-side code and only using JavaScript. One of them is using jsPDF ([https://github.com/MrRio/jsPDF](https://github.com/MrRio/jsPDF)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 HTML5，我们也可以使用 HTML5 API 生成 PDF 文件。我们可以使用一些解决方案来生成文件，而无需使用任何服务器端代码，仅使用 JavaScript。其中之一是使用
    jsPDF ([https://github.com/MrRio/jsPDF](https://github.com/MrRio/jsPDF))。
- en: By default, the browser is going to use whatever PDF viewer software the user
    has installed on the computer to view the PDF file. It is also possible to use
    a PDF viewer developed with JavaScript called `pdf.js`. This solution is implemented
    and maintained by Mozilla ([https://github.com/mozilla/pdf.js/](https://github.com/mozilla/pdf.js/)).
    There is also an Ext JS plugin developed on `pdf.js` ([https://market.sencha.com/extensions/pdf-panel-without-plugin-needed](https://market.sencha.com/extensions/pdf-panel-without-plugin-needed)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，浏览器将使用用户在计算机上安装的任何 PDF 查看器软件来查看 PDF 文件。也可以使用用 JavaScript 开发的 PDF 查看器 `pdf.js`。这个解决方案是由
    Mozilla 实现和维护的 ([https://github.com/mozilla/pdf.js/](https://github.com/mozilla/pdf.js/))。还有一个基于
    `pdf.js` 开发的 Ext JS 插件 ([https://market.sencha.com/extensions/pdf-panel-without-plugin-needed](https://market.sencha.com/extensions/pdf-panel-without-plugin-needed))。
- en: Exporting to Excel
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出为 Excel
- en: To export the GridPanel to Excel, we will also use a server-side technology
    to help us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 GridPanel 导出为 Excel，我们也将使用服务器端技术来帮助我们。
- en: 'On the Ext JS side, the only thing we need to do is to call the URL that will
    generate the Excel file as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS 方面，我们唯一需要做的就是调用以下将生成 Excel 文件的 URL：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On the server side, we will use the *PHPExcel* ([http://phpexcel.codeplex.com/](http://phpexcel.codeplex.com/))
    library to help us generate the Excel file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们将使用 *PHPExcel* ([http://phpexcel.codeplex.com/](http://phpexcel.codeplex.com/))
    库来帮助我们生成 Excel 文件。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are using Java, you can use the Apache POI library ([http://poi.apache.org/](http://poi.apache.org/)),
    and if you are using .NET, you can use *excellibrary* ([https://code.google.com/p/excellibrary/](https://code.google.com/p/excellibrary/)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Java，你可以使用 Apache POI 库 ([http://poi.apache.org/](http://poi.apache.org/))，如果你使用的是
    .NET，你可以使用 *excellibrary* ([https://code.google.com/p/excellibrary/](https://code.google.com/p/excellibrary/))。
- en: If you want to export the GridPanel of any other content from an Ext JS component
    to Excel, PDF, .txt, or a Word document, you can use the same approach.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将任何其他 Ext JS 组件的 GridPanel 或其他内容导出到 Excel、PDF、.txt 或 Word 文档，你可以使用相同的方法。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is also an Ext JS plugin that exports a grid to an Excel file: [http://goo.gl/E7jif4](http://goo.gl/E7jif4).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 Ext JS 插件可以将网格导出为 Excel 文件：[http://goo.gl/E7jif4](http://goo.gl/E7jif4)。
- en: Printing GridPanel content with the GridPrinter plugin
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GridPrinter 插件打印 GridPanel 内容
- en: The next functionality we will implement is printing the contents of the GridPanel.
    When the user clicks on the **Print** button, the application will open a new
    browser window and display the contents of the grid in this new window.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的下一种功能是打印 GridPanel 的内容。当用户点击 **打印** 按钮时，应用程序将打开一个新的浏览器窗口，并在此新窗口中显示网格的内容。
- en: To do this, we will use a plugin named `Ext.ux.grid.Printer`, which receives
    the GridPanel reference to be printed, gets the information that is on the Store,
    generates HTML from this content, and displays the information in a new window.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将使用一个名为 `Ext.ux.grid.Printer` 的插件，该插件接收要打印的 GridPanel 引用，获取 Store 上的信息，从这些内容生成
    HTML，并在新窗口中显示信息。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GridPrinter plugin is a third-party plugin available at [https://github.com/loiane/extjs4-ux-gridprinter](https://github.com/loiane/extjs4-ux-gridprinter).
    This plugin will only print the information that is available on the GridPanel
    Store, meaning if you are using the PagingToolbar, the plugin will only generate
    the HTML of the current page. The plugin also supports the RowExpander plugin.
    Please feel free to contribute to this plugin (or any other Ext JS plugin), and
    this way, we can help in growing the Ext JS community! It works with Ext JS 4
    and 5.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: GridPrinter 插件是一个可在 [https://github.com/loiane/extjs4-ux-gridprinter](https://github.com/loiane/extjs4-ux-gridprinter)
    获取的第三方插件。此插件只会打印 GridPanel Store 上可用的信息，这意味着如果你使用分页工具栏，插件将只生成当前页的 HTML。该插件还支持
    RowExpander 插件。请随时为此插件（或任何其他 Ext JS 插件）做出贡献，这样我们就可以帮助 Ext JS 社区的发展！它与 Ext JS 4
    和 5 兼容。
- en: 'To install the plugin, we are going to get the contents of the `ux` folder
    and place it inside the `app/ux` folder. As Ext JS also ships some plugins within
    the native SDK with the namespace `Ext.ux`, we are going to rename the plugin
    from `Ext.ux.grid.Printer` to `Packt.ux.grid.Printer` to avoid conflict (you can
    search for the occurrences inside the `Printer.js` file and replace it). This
    way, the plugin will be part of the application. The following screenshot demonstrates
    how the project structure will look after installing the plugin:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装插件，我们将获取 `ux` 文件夹的内容，并将其放置在 `app/ux` 文件夹内。由于 Ext JS 也通过带有命名空间 `Ext.ux` 的原生
    SDK 提供了一些插件，我们将把插件从 `Ext.ux.grid.Printer` 重命名为 `Packt.ux.grid.Printer` 以避免冲突（你可以在
    `Printer.js` 文件中搜索出现并替换它）。这样，插件将成为应用程序的一部分。以下截图展示了安装插件后项目结构将如何看起来：
- en: '![Printing GridPanel content with the GridPrinter plugin](img/0457OT_09_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![使用 GridPrinter 插件打印 GridPanel 内容](img/0457OT_09_03.jpg)'
- en: 'After installing the plugin, we simply need to add it to the `requires` declaration
    of `FilmsController`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 安装插件后，我们只需将其添加到 `FilmsController` 的 `requires` 声明中：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the user clicks on the **Print** button, the controller will execute the
    following method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 **打印** 按钮时，控制器将执行以下方法：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `printAutomatically` property means you want the print window to be displayed
    automatically. If set to `false`, the plugin will display the print window, and
    then, if the user wants to print it, they need to go to the browser's menu and
    select **Print** (*Ctrl* + *P*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`printAutomatically` 属性表示你希望自动显示打印窗口。如果设置为 `false`，则插件将显示打印窗口，然后，如果用户想要打印它，他们需要转到浏览器的菜单并选择
    **打印** (*Ctrl* + *P*)。'
- en: To make the plugin work, we need to pass the GridPanel reference to the `print`
    method. In this case, we can get the `Films` GridPanel reference.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要使插件工作，我们需要将 GridPanel 引用传递给 `print` 方法。在这种情况下，我们可以获取 `Films` GridPanel 引用。
- en: 'When we execute the code, we will get the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行代码时，我们将得到以下输出：
- en: '![Printing GridPanel content with the GridPrinter plugin](img/0457OT_09_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![使用 GridPrinter 插件打印 GridPanel 内容](img/0457OT_09_04.jpg)'
- en: Creating a Sales by Film Category chart
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建按电影类别划分的销售图表
- en: Ext JS provides a great set of visual charts we can implement, and users love
    things like this. For this reason, we will implement a chart using three different
    series (pie, column, and bar) where the user can see the **Sales by Film Category**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 提供了一套出色的可视化图表，我们可以实现，用户喜欢这样的事物。因此，我们将使用三个不同的系列（饼图、柱图和条形图）来实现图表，用户可以看到**按电影类别销售的图表**。
- en: 'The following is a screenshot of the final result we will have at the end of
    this topic. As we can see in the following screenshot, we have the chart. Above
    it, we have a toolbar with two buttons: **Change Chart Type**, where the user
    will be able to change the chart series from **Pie** to **Column** or **Bar**,
    and the **Download Chart** button, where the user will be able to download the
    chart in the following formats: **Download as Image** or **Download as PDF**.
    Here''s the screenshot we are discussing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本主题结束时我们将得到的最终结果的截图。正如我们在以下截图中所见，我们有一个图表。在其上方，我们有一个包含两个按钮的工具栏：**更改图表类型**，用户将能够将图表系列从**饼图**更改为**柱图**或**条形图**，以及**下载图表**按钮，用户将能够以下列格式下载图表：**作为图像下载**或**作为
    PDF 下载**。以下是我们要讨论的截图：
- en: '![Creating a Sales by Film Category chart](img/0457OT_09_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![创建按电影类别销售的图表](img/0457OT_09_05.jpg)'
- en: Ext JS 5 charts and terminology
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ext JS 5 图表和术语
- en: Before we start coding, let's understand a little bit about how Ext JS charts
    work. Ext JS 4 introduced great charting capabilities by leveraging the HTML5
    canvas and SVG features. However, in Ext JS 5, the charts introduced in Ext JS
    4 became deprecated. Ext JS 5 introduces a new Sencha Charts package that comes
    from Sencha Touch, with built-in support for touch, which means we can use touch
    gestures to interact with the charts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们了解一下 Ext JS 图表是如何工作的。Ext JS 4 通过利用 HTML5 画布和 SVG 功能引入了出色的图表功能。然而，在
    Ext JS 5 中，Ext JS 4 中引入的图表已弃用。Ext JS 5 引入了一个新的 Sencha Charts 包，它来自 Sencha Touch，并内置了对触摸的支持，这意味着我们可以使用触摸手势与图表进行交互。
- en: You might ask, but why am I interested in touch support in the charts? There
    are many companies that want to use the same application in tablets without developing
    a new application with the same capabilities for touch devices. Ext JS 5 offers
    this capability. We will discuss more about touch support later.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么我对图表中的触摸支持感兴趣？有许多公司希望在平板电脑上使用与触摸设备具有相同功能的相同应用程序，而不需要为触摸设备开发新应用程序。Ext
    JS 5 提供了这种功能。我们将在稍后讨论更多关于触摸支持的内容。
- en: 'Sencha Charts supports three types of charts:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Charts 支持三种类型的图表：
- en: '**Cartesian chart**: This represents a chart that uses cartesian coordinates.
    A cartesian chart has two directions, the *x* direction and *y* direction. The
    series and axes are coordinated along these directions. By default, the *x* direction
    is horizontal and the *y* direction is vertical (the directions can be flipped
    as well).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**笛卡尔图表**：这代表使用笛卡尔坐标的图表。笛卡尔图表有两个方向，*x* 方向和 *y* 方向。系列和轴沿着这些方向进行协调。默认情况下，*x*
    方向是水平的，*y* 方向是垂直的（方向也可以翻转）。'
- en: '**Polar chart**: This represents a chart that uses polar coordinates. A polar
    chart has two axes: an angular axis (which is a circle) and a radial axis (a straight
    line from the center to the edge of the circle). The angular axis is usually a
    category axis while the radial axis is typically numerical.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**极坐标图表**：这代表使用极坐标的图表。极坐标图表有两个轴：一个角度轴（即一个圆）和一个径向轴（从圆心到圆边的直线）。角度轴通常是类别轴，而径向轴通常是数值轴。'
- en: '**Space Filling chart**: This creates a chart that fills the entire area of
    the chart, for example, a gauge or a treemap chart.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间填充图表**：这创建了一个填充整个图表区域的图表，例如，一个仪表或树状图图表。'
- en: 'A chart consists of a **Legend**, **Axis**, **Series**, **Interaction**, and
    **Theme** and can load data from a Store as displayed in the following image:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图表由**图例**、**轴**、**系列**、**交互**和**主题**组成，可以从 Store 加载数据，如下面的图像所示：
- en: '![Ext JS 5 charts and terminology](img/0457OT_09_12.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Ext JS 5 图表和术语](img/0457OT_09_12.jpg)'
- en: The **Series** contains the logic about how the data will be rendered in the
    chart. The series can be **Pie**, **Line**, **Bar**, **Column**, and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**系列**包含关于数据如何在图表中渲染的逻辑。系列可以是**饼图**、**折线图**、**条形图**、**柱图**等等。'
- en: 'The **Axis** is responsible for rendering the chart axis based on the type
    of data. There are three types of axes: `numeric`, `category`, and `time`. The
    `numeric` type is used to render numeric values, `category` is used to render
    data that is a finite set (for example, the names of the months of the year),
    and `time` is used to render data that represents time.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**轴**负责根据数据类型渲染图表轴。有三种类型的轴：`numeric`、`category` 和 `time`。`numeric` 类型用于渲染数值，`category`
    用于渲染有限集的数据（例如，一年的月份名称），而 `time` 用于渲染表示时间的数值。'
- en: The **Legend** is responsible for displaying the legend box of the chart.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**图例**负责显示图表的图例框。'
- en: 'Sencha Charts also supports interactions. The available interactions are presented
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Charts 也支持交互。可用的交互如下所示：
- en: '**Crosshair**: This allows the user to get precise values for a specific point
    on the chart. The values are obtained by single-touch dragging on the chart.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十字准线**：这允许用户在图表的特定点上获得精确的值。这些值是通过在图表上单指拖动来获得的。'
- en: '**CrossZoom**: This allows the user to zoom in on a selected area of the chart.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉缩放**：这允许用户在图表的选定区域进行缩放。'
- en: '**Item Highlight**: This allows the user to highlight series items in the chart.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目高亮**：这允许用户在图表中突出显示系列项。'
- en: '**Item Info**: This allows displaying detailed information about a series data
    point in a popup panel.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目信息**：这允许在弹出面板中显示关于系列数据点的详细信息。'
- en: '**Pan/Zoom**: This allows the user to navigate the data for one or more chart
    axes by panning or zooming.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平移/缩放**：这允许用户通过平移或缩放来导航一个或多个图表轴的数据。'
- en: '**Rotate**: This allows the user to rotate a polar chart about its central
    point. There is also a special rotate interaction for 3D pie charts.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转**：这允许用户围绕图表的中心点旋转极坐标图。对于 3D 饼图，还有一个特殊的旋转交互。'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about charts can be obtained by diving into the *Charts Kitchen
    Sink* example ([http://dev.sencha.com/ext/5.1.0/examples/kitchensink/?charts=true](http://dev.sencha.com/ext/5.1.0/examples/kitchensink/?charts=true))
    and also into the `charts` package ([http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.chart.AbstractChart](http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.chart.AbstractChart))
    in the documentation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过深入了解 *Charts Kitchen Sink* 示例（[http://dev.sencha.com/ext/5.1.0/examples/kitchensink/?charts=true](http://dev.sencha.com/ext/5.1.0/examples/kitchensink/?charts=true)）和文档中的
    `charts` 包（[http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.chart.AbstractChart](http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.chart.AbstractChart)）可以获得有关图表的更多信息。
- en: Adding Sencha Charts to the project
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Sencha Charts 添加到项目中
- en: 'A very important detail: Sencha Charts is available for use in Ext JS 5 applications
    via a package, meaning the source code of the charts is not available automatically
    to an application like the grids, forms, and other components. Packages in Sencha
    applications have a similar concept as gems in Ruby or JARs in Java.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的细节：Sencha Charts 可以通过一个包在 Ext JS 5 应用程序中使用，这意味着图表的源代码不会自动对像网格、表单和其他组件这样的应用程序可用。Sencha
    应用程序中的包与 Ruby 中的 gems 或 Java 中的 JARs 有类似的概念。
- en: 'To add Sencha Charts to our project, we need to open the `app.json` file located
    in the root folder of the application. Around line 34, we should find the `requires`
    declaration. We need to add `sencha-charts` to `requires`. It is going to look
    like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Sencha Charts 添加到我们的项目中，我们需要打开位于应用程序根目录中的 `app.json` 文件。大约在第 34 行，我们应该找到
    `requires` 声明。我们需要将 `sencha-charts` 添加到 `requires` 中。它看起来如下所示：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After this change, if we start using charts in the project, our code should
    work.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，如果我们开始在项目中使用图表，我们的代码应该可以工作。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We cannot forget to have `sencha app watch` executed in a terminal application
    as well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忘记在终端应用程序中执行 `sencha app watch`。
- en: 'Also, here''s the last update we are going to do in the `menu` table to be
    able to see the report option in the application menu:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里是我们将在 `menu` 表中进行的最后更新，以便在应用程序菜单中看到报告选项：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating the Store inside the ViewModel
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 ViewModel 内部创建 Store
- en: Let's go back to our code and start implementing some charts. The Store is going
    to provide the charts with the data. No matter whether we want to create a pie
    chart or column chart or bar chart, we need a Store to provide the information
    we want to display.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的代码，开始实现一些图表。Store 将为图表提供数据。无论我们想要创建饼图、柱状图还是条形图，我们都需要一个 Store 来提供我们想要显示的信息。
- en: 'As we are going to create charts, we need to create a Store that is going to
    hold the collection of data especially for the chart, which means it is not going
    to be used anywhere else in the application. For this reason, we can create it
    directly inside the ViewModel. So we are going to create a new package named `reports`
    inside the `app/view` folder, where we are going to place the files from this
    topic. We are going to start creating the ViewModel this time, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将创建图表，我们需要创建一个Store，它将保存专门用于图表的数据集合，这意味着它不会在应用程序的任何其他地方使用。因此，我们可以在ViewModel中直接创建它。所以我们将创建一个名为`reports`的新包，位于`app/view`文件夹中，我们将放置这个主题的文件。我们将开始创建ViewModel，如下所示：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this Store, we will not declare a Model; we are going to declare its `fields`
    (`#1`) directly on it. As this Store is going to be used exclusively by the chart,
    there is no need to create a specific Model for it, as we do not intend to reuse
    it later.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个Store，我们不会声明一个Model；我们将在它上面直接声明其`fields`（`#1`）。由于这个Store将仅用于图表，因此没有必要为它创建一个特定的Model，因为我们不打算稍后重用它。
- en: We are also going to declare `proxy` (`#2`) with the `ajax`, `url`, and `reader`
    details on it. Most of the models we created in the previous chapters were part
    of a `schema` that contained a `proxy`. This time, we do not have this information
    available, so we need to declare it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将声明带有`ajax`、`url`和`reader`详细信息的`proxy`（`#2`）。我们之前创建的大多数模型都是包含`proxy`的`schema`的一部分。这次，我们没有这方面的信息，因此我们需要声明它。
- en: 'On the server side, we can query the data that will feed the chart from the
    `sales_by_ film_category` view from the Sakila database as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们可以从Sakila数据库的`sales_by_film_category`视图中查询将用于图表的数据，如下所示：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Pie chart
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 饼图
- en: 'Now that we are able to retrieve the information we need from the server, let''s
    work on the implementation of the chart. First, we will develop the pie chart,
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够从服务器检索所需的信息，让我们开始实现图表。首先，我们将开发饼图，如下所示：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's go through the most important parts of the preceding code; first, we need
    to extend the `PolarChart` class (`#1`) because we want to implement a chart with
    a `pie` series (`#5`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面代码中最重要的一部分；首先，我们需要扩展`PolarChart`类（`#1`），因为我们想要实现一个带有`pie`系列的图表（`#5`）。
- en: Next, we are going to add `legend` to this chart, and we are going to dock it
    on the `left` (`#2`). We are also going to add some interactions to this chart
    (`#3`). The user is going to be able to rotate and highlight the slices of `pie`.
    We are going to bind the Store (`#4`) we declared in the ViewModel as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向此图表添加`legend`，并将其停靠在`left`（`#2`）。我们还将为此图表添加一些交互（`#3`）。用户将能够旋转并突出显示`pie`的切片。我们还将绑定在ViewModel中声明的Store（`#4`）。
- en: Next, there is the `series` configuration that defines what `type` of chart
    we are implementing (`#5`), which is the `pie` chart in this case. The `pie` chart
    needs a field that is going to be used to do the sum and then calculate the fraction
    of each piece. We only have two fields, and `total_sales` (`#10`) is the numeric
    one, so we will use this field. The `donut` configuration (`#6`) sets the radius
    of the donut. This chart is actually a donut chart (because of the hole in the
    middle of the pie).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`series`配置，它定义了我们正在实现哪种类型的图表（`#5`），在这个例子中是饼图。饼图需要一个字段来执行求和并计算每个部分的分数。我们只有两个字段，而`total_sales`（`#10`）是数值字段，因此我们将使用这个字段。`donut`配置（`#6`）设置甜甜圈的半径。实际上，这个图表是一个甜甜圈图（因为饼图的中间有一个洞）。
- en: We can also style our chart (`#7`). The style in this example will add some
    white lines separating each slice of the chart.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为我们的图表设置样式（`#7`）。在这个例子中，样式将添加一些分隔图表每个切片的白色线条。
- en: Inside each slice, we also want to display its film category so that we can
    easily identify it. We can do this by adding the `label` configuration (`#8`)
    to `series`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个切片内部，我们还想显示其电影类别，这样我们就可以轻松识别它。我们可以通过向`series`添加`label`配置（`#8`）来实现这一点。
- en: On the `tooltip` configuration, we can define whether we want to display a quick
    tip or not (`#9`). In this case, we want Ext JS to track the movements of the
    mouse, and if the user does a mouseover over any item of the chart, Ext JS will
    display a tip with the name of `category` and the `total_sales` number.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tooltip`配置中，我们可以定义是否要显示快速提示（`#9`）。在这种情况下，我们希望Ext JS跟踪鼠标的移动，如果用户将鼠标悬停在图表的任何项目上，Ext
    JS将显示一个包含`category`名称和`total_sales`数字的提示。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is also possible to define `theme` in the chart. We can do so by adding
    the configuration `theme` in this class. The possible values we can set are: `''green''`,
    `''sky''`, `''red''`, `''purple''`, `''blue''`, `''yellow''`—`''category1''` to
    `''category6''`—and the mentioned theme names with the ''`-gradients''` suffix
    (`''green-gradients''` and so on).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中也可以定义`主题`。我们可以通过在这个类中添加`theme`配置来实现这一点。我们可以设置的值包括：`'green'`、`'sky'`、`'red'`、`'purple'`、`'blue'`、`'yellow'`——从`'category1'`到`'category6'`——以及带有`'-gradients'`后缀的提到的主题名称（例如`'green-gradients'`等）。
- en: 3D column chart
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D柱状图
- en: 'As we can change the chart `type`, we will also implement a column chart that
    looks like the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以更改图表`类型`，因此我们还将实现一个看起来如下截图的柱状图：
- en: '![3D column chart](img/0457OT_09_06.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![3D柱状图](img/0457OT_09_06.jpg)'
- en: 'So let''s get our hands on the code, which is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们动手编写以下代码：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The column chart extends from the `CartesianChart` class (`#1`) because we want
    to display a chart with *x* and *y* axes. We will also use the same Store we used
    in the pie chart (`#2`), and the user will also be able to highlight (`#3`) the
    columns in this chart.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 柱状图从`CartesianChart`类（`#1`）扩展，因为我们想显示带有*x*轴和*y*轴的图表。我们还将使用在饼图中使用的相同存储（`#2`），并且用户也将能够突出显示（`#3`）此图表中的柱状图。
- en: 'Let''s take a look at the `axes` declaration in the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码中的`axes`声明：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have two `axes` in a column chart. The *x* axis is going to display `category`
    (`#5`), which is going to be placed at the `bottom`, and the *y* axis is going
    to display the `numeric` (#4) data that is going to be displayed in the `right`
    or `left` (in this example, we chose `left`). In the case of a bar chart, all
    we have to do is swap the axes. The `category` value becomes the *y* axis and
    the `numeric` values become the *x* axis.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在柱状图中，我们有两个`轴`。*x*轴将显示`类别`（`#5`），它将被放置在`底部`，而*y*轴将显示在`右侧`或`左侧`（在这个例子中，我们选择了`左侧`）显示的`数值`（#4）。在条形图中，我们只需交换轴。`类别`值成为*y*轴，而`数值`成为*x*轴。
- en: 'Let''s take a look at the `series` configuration to finish configuring our
    chart:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`series`配置以完成图表的配置：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we are implementing a 3D column chart (`#6`) that can also
    be used as a 3D bar chart. If we want to implement the normal chart, the series
    type would be `'bar'`. As mentioned before, column and bar charts are very similar;
    only the configuration of the *x* and *y* axes are swapped. If we want to display
    a `label` (`#7`), we can also configure one.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在实现一个3D柱状图（`#6`），它也可以用作3D条形图。如果我们想实现普通图表，系列类型将是`'bar'`。如前所述，柱状图和条形图非常相似；只是*x*轴和*y*轴的配置被交换了。如果我们想显示`标签`（`#7`），我们也可以配置一个。
- en: It is important to note that `xField` (`#8`) matches the `Category` axis (`#5`),
    and `yField` (`#9`) matches the `Numeric` axis (vertical/`left` position—(`#4`)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意`xField`（`#8`）与`类别`轴（`#5`）匹配，而`yField`（`#9`）与`数值`轴（垂直/`左侧`位置——`#4`）匹配。
- en: The bar chart code is exactly the same as the column chart code with a small
    change. We need to invert `Axis` (`Category` will be `left` and `Numeric` will
    be `bottom`), `xField` (which will be `total_sales` instead of `category`), and
    `yField` (which will be `category` instead of `total_sales`).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图代码与柱状图代码完全相同，只是有一点小变化。我们需要反转`Axis`（`类别`将变为`左侧`，`数值`将变为`底部`），`xField`（将变为`total_sales`而不是`category`），以及`yField`（将变为`category`而不是`total_sales`）。
- en: 'The bar chart is going to look as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图将看起来如下：
- en: '![3D column chart](img/0457OT_09_07.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![3D柱状图](img/0457OT_09_07.jpg)'
- en: The Chart panel
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表面板
- en: As we want to display a panel and offer the user the possibility to change the
    chart type, we will create a panel and use the Card layout. To refresh our memory,
    the Card layout is mostly used for wizards and also when we have several items
    but want to display only one at a time. And the item that is currently being displayed
    uses the FitLayout.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想显示一个面板并给用户提供更改图表类型的机会，我们将创建一个面板并使用Card布局。为了刷新我们的记忆，Card布局主要用于向导，以及当我们有多个项目但只想一次显示一个时。当前显示的项目使用FitLayout。
- en: 'So let''s create a Chart panel, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个图表面板，如下所示：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So we need to declare `panel` and declare each chart we created as an item.
    So we can declare the pie chart (`#3`), the column chart (`#4`), and the bar chart
    (`#5`) as items of a **Sales by Film Category** panel. By default, the item `0`
    (which is the first item—pie chart) is going to be the default item to be displayed
    when the Chart panel is rendered.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要声明`panel`并声明我们创建的每个图表作为项。因此，我们可以将饼图（`#3`）、柱状图（`#4`）和条形图（`#5`）声明为**按电影类别销售**面板的项。默认情况下，项`0`（即第一个项——饼图）将是当图表面板渲染时默认显示的项。
- en: We also cannot forget to declare the ViewModel (`#2`) and the ViewController
    (`#1`), which we are going to create next.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不能忘记声明ViewModel（`#2`）和视图控制器（`#1`），我们将创建下一个。
- en: All the classes we mention are `xtype` of which(`#1` to `#5`) are inside `requires`
    declaration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的所有类都是`xtype`，其中（`#1`到`#5`）都在`requires`声明中。
- en: 'Next, we can declare the toolbar that will contain the button with the menu
    so that the user can choose `Chart Type` and `Download Type`. We will add the
    following code in the place where we have the comment in the preceding code (`#6`):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以声明一个包含按钮和菜单的工具栏，以便用户可以选择`图表类型`和`下载类型`。我们将在前一段代码中的注释位置（`#6`）添加以下代码：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the preceding menu, all menu items have the same `listener` declaration
    (`#7`). Instead of having the same code declare three times, we will have it declare
    only once in the ViewController. To help us identify which menu item fired the
    event, we are also going to declare `itemId` for each menu item on lines `#8`,
    `#9`, and `#10`. The output of the preceding code is displayed in the following
    screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前述菜单，所有菜单项都有相同的`listener`声明（`#7`）。为了避免三次重复相同的代码，我们将在视图控制器中只声明一次。为了帮助我们识别哪个菜单项触发了事件，我们还将为每行`#8`、`#9`和`#10`上的每个菜单项声明`itemId`。前述代码的输出显示在以下屏幕截图中：
- en: '![The Chart panel](img/0457OT_09_08.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图表面板](img/0457OT_09_08.jpg)'
- en: 'As the second `item` of the toolbar, we have the **Download Chart** button.
    Following the same behavior as the **Change Chart Type** button, the **Download
    Chart** button also has a menu with two menu items in it, one for each download
    type, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为工具栏的第二个`item`，我们有**下载图表**按钮。遵循与**更改图表类型**按钮相同的操作，**下载图表**按钮也有一个包含两个菜单项的菜单，每个下载类型一个，如下所示：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will have `listener` (`#11`) for this menu in the ViewController. The output
    for the preceding code will be the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在视图控制器（ViewController）中为这个菜单设置`listener`（`#11`）。前述代码的输出如下：
- en: '![The Chart panel](img/0457OT_09_09.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图表面板](img/0457OT_09_09.jpg)'
- en: The ViewController
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图控制器（ViewController）
- en: 'Before we develop the two methods we need to implement to close this chapter,
    let''s declare the structure of the `ViewController` for the `reports` module:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发需要实现以结束本章的两个方法之前，让我们声明`reports`模块的`ViewController`结构：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we will see how to develop the `onChangeChart` and `onChartDownload` methods.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何开发`onChangeChart`和`onChartDownload`方法。
- en: Changing the chart type
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改图表类型
- en: 'As the user has the capability to change the chart type by choosing an option
    from the menu, we will develop the following method:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户可以通过从菜单中选择选项来更改图表类型，我们将开发以下方法：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we need to get the Chart panel. We can simply retrieve it by calling
    the `getView` method from the ViewController (`#1`).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取图表面板。我们可以通过从视图控制器（ViewController）调用`getView`方法（`#1`）简单地检索它。
- en: As the menu item that was clicked on fired the event click, the first parameter
    this method receives is the item itself. We can get its `itemId` property to compare
    which `itemId` the user clicked on, and we set `ActiveItem` accordingly (`#2`,
    `#3`, and `#4`) to the option the user chose.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于被点击的菜单项触发了事件click，该方法接收的第一个参数是该项本身。我们可以获取其`itemId`属性来比较用户点击了哪个`itemId`，并根据用户选择的选项相应地设置`ActiveItem`（`#2`、`#3`和`#4`）。
- en: The `setActiveItem` method is from the Card layout. From the View, we can get
    the layout, which will return an instance of the Card layout, and the method will
    be available.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`setActiveItem`方法来自卡片布局。从视图（View）中，我们可以获取布局，它将返回一个卡片布局的实例，并且该方法将可用。'
- en: Exporting charts to images (PNG or JPEG)
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将图表导出为图像（PNG或JPEG）
- en: 'On the `onChartDownload` method, we will follow the same logic as we did for
    the **Change Chart Type** menu items. But in this case, we want to save the chart
    as an image (PNG) or PDF file. Here''s how we go about the task:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onChartDownload`方法中，我们将遵循与**更改图表类型**菜单项相同的逻辑。但在这个情况下，我们希望将图表保存为图像（PNG）或PDF文件。以下是我们的操作步骤：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Chart` class already has a method named `download`, which we can use to
    download the chart in different formats. This is a native feature from Ext JS.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chart`类已经有一个名为`download`的方法，我们可以使用它以不同格式下载图表。这是来自Ext JS的本地功能。'
- en: So first, we need to get a reference of the `Chart` class, which we can get
    through `ActiveItem` of the Chart panel (`#1`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们需要获取`Chart`类的引用，这可以通过图表面板的`ActiveItem`（`#1`）来获取。
- en: Then, depending on the user's choice, we will first ask whether the user really
    wants to download the chart in the specific format, and if yes, we will ask Ext
    JS to generate the file. So, if the user chooses to download in PNG (`#2`) or
    PDF (`#3`), we simply need to call the method `download` from the chart reference,
    passing the specific type selected by the user. In this case, the application
    will send a request to `http://svg.sencha.io` and the download will start.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据用户的选择，我们首先会询问用户是否真的想要以特定格式下载图表，如果是，我们将请求Ext JS生成文件。因此，如果用户选择以PNG（`#2`）或PDF（`#3`）格式下载，我们只需从图表引用调用`download`方法，传递用户选择的特定类型。在这种情况下，应用程序将向`http://svg.sencha.io`发送请求，并开始下载。
- en: 'According to the documentation, we can pass an object configuration to the
    `download` method with some options:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，我们可以向`download`方法传递一个包含一些选项的对象配置：
- en: '`url`: This is the URL to post the data to. This defaults to the Sencha IO.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`: 这是要发送数据的URL。默认情况下为Sencha IO。'
- en: '`format`: This is the format of the image to export. This defaults to `''png''`.
    The possible values are `png`, `pdf`, `jpeg`, and `gif`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`: 这是导出图像的格式。默认情况下为`''png''`。可能的值是`png`、`pdf`、`jpeg`和`gif`。'
- en: '`width`: This is a width value to send to the server to configure the image
    width. This defaults to the natural image width on the Sencha IO server.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`: 这是一个发送到服务器以配置图像宽度的值。默认情况下，在Sencha IO服务器上为自然图像宽度。'
- en: '`height`: This is a height value to send to the server to configure the image
    height. This defaults to the natural image height on the Sencha IO server.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`: 这是一个发送到服务器以配置图像高度的值。默认情况下，在Sencha IO服务器上为自然图像高度。'
- en: '`filename`: This is the filename of the downloaded image. This defaults to
    `''chart''` on the Sencha IO server. The `config.format` is used as a filename
    extension.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename`: 这是下载图像的文件名。默认情况下，在Sencha IO服务器上为`''chart''`。`config.format`用作文件名扩展名。'
- en: '`pdf`: This is a PDF-specific option. This configuration is only used if `config.format`
    is set to `''pdf''`. Check the documentation for more details.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdf`: 这是一个PDF特定的选项。此配置仅在`config.format`设置为`''pdf''`时使用。请参阅文档以获取更多详细信息。'
- en: '`jpeg`: This is a JPEG-specific option. This configuration is only used if
    `config.format` is set to `''jpeg''`. Check the documentation for more details.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jpeg`: 这是一个JPEG特定的选项。此配置仅在`config.format`设置为`''jpeg''`时使用。请参阅文档以获取更多详细信息。'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are planning to have the application running in a device with touch support,
    it is recommended that you use the method `preview` instead of `download`. The
    `preview` method opens a popup with the chart image, and in this case, the user
    can use the native capability of the device to save the image.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划在支持触摸的设备上运行应用程序，建议你使用`preview`方法而不是`download`方法。`preview`方法会打开一个包含图表图像的弹出窗口，在这种情况下，用户可以使用设备的本地功能来保存图像。
- en: 'The following screenshot is from an image that was generated by choosing to
    save the chart as PNG:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是从选择将图表保存为PNG时生成的图像：
- en: '![Exporting charts to images (PNG or JPEG)](img/0457OT_09_10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![导出图表为图像（PNG或JPEG）](img/0457OT_09_10.jpg)'
- en: 'If you want to generate the image or the PDF in your own server, you can specify
    the `url` where the data is going to be posted. In the server, you can retrieve
    a POST variable named `data`. The variable has the following content (it is a
    *Base64* image) that can be manipulated in the server to return an image or PDF
    or other required format:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的服务器上生成图像或PDF，你可以指定数据将要发送到的`url`。在服务器上，你可以检索一个名为`data`的POST变量。该变量包含以下内容（它是一个*Base64*图像），可以在服务器上对其进行操作以返回图像、PDF或其他所需格式：
- en: '![Exporting charts to images (PNG or JPEG)](img/0457OT_09_11.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![导出图表为图像（PNG或JPEG）](img/0457OT_09_11.jpg)'
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to export the content of a GridPanel to PDF,
    Excel, and also a page that is printer-friendly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将GridPanel的内容导出为PDF、Excel，以及一个打印友好的页面。
- en: We have also learned how to create different types of charts, use only one component
    and change its active item, and export a chart to an image or PDF using Ext JS
    native features.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何创建不同类型的图表，使用单个组件并更改其活动项，以及如何使用Ext JS原生功能将图表导出为图像或PDF。
- en: In the next chapter, we will learn how to test the application, how to enable
    touch support (so that we can execute the application from a tablet or smartphone),
    and also how to enable routing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何测试应用程序，如何启用触摸支持（这样我们就可以从平板电脑或智能手机上执行应用程序），以及如何启用路由。
