- en: '*Chapter 5*: Waiting for elements and network calls'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：等待元素和网络调用'
- en: I won't say I'm old, but I started browsing the internet in the late 90s. So
    yes, I'm old. Back then, you would sometimes have to wait over a minute to get
    a page loaded. You might be thinking, "So if you had 10 tabs open, that would
    be impossible to use." Well, browsers didn't have tabs! Downloading one single
    MP3 file could take you an hour.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会说我老了，但我在90年代末开始上网。所以是的，我老了。当时，有时你需要等待超过一分钟才能加载一个页面。你可能正在想，“如果你打开了10个标签页，那就无法使用了。”
    好吧，浏览器当时没有标签页！下载一个单独的MP3文件可能需要一个小时。
- en: In the early 2000s, the web got into the corporate world, and we started developing
    business apps using websites. But that was a decision from an IT department. Old
    terminal apps were hard to update and introduce new features, and desktop apps
    were hard to distribute. Web apps were the IT department's solution, leaving users
    with slow and non-user-friendly web apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代初，网络进入了企业界，我们开始使用网站开发商业应用。但那是一个来自 IT 部门的决策。旧的终端应用难以更新和引入新功能，桌面应用难以分发。Web
    应用是 IT 部门的解决方案，给用户留下了速度慢且不友好的 Web 应用。
- en: Developers were trying to do their best with the tools they had back then. Pages
    were mostly generated on the server side using tools such as ASP 3.0 or PHP. AJAX
    was used for small tasks, such as loading the state's list based on a country
    selection without reloading the entire page.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者当时尽力使用他们拥有的工具。页面主要是通过 ASP 3.0 或 PHP 等工具在服务器端生成的。AJAX 用于小任务，例如根据国家选择加载状态列表，而无需重新加载整个页面。
- en: In the late 2000s, Google launched *Gmail*, showing the world how the web should
    look. But the bar was too high for developers. Developing those kinds of apps
    was unthinkable for developers just trying to build CRUD pages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代后期，谷歌推出了 *Gmail*，向世界展示了网络应该如何看起来。但对于开发者来说，这个门槛太高了。对于仅仅尝试构建 CRUD 页面的开发者来说，开发这类应用是不可想象的。
- en: Nowadays, our web looks different. Developers are now able to create rich experiences,
    even for more straightforward scenarios.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的网络看起来不同了。开发者现在能够为更直接的场景创建丰富的体验。
- en: 'But there is a thing that didn''t change in all these years: **You have to
    wait**.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这些年里，有一件事没有改变：**你必须等待**。
- en: You have to wait for the site to load, for the data to be refreshed, for the
    new page to be opened, for the form to be submitted. You have to wait.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须等待网站加载、数据刷新、新页面打开、表单提交。你必须等待。
- en: 'Waiting for the right moment to act is key to avoid having flaky tests. A flaky
    test is a test that sometimes passes and sometimes fails. You have to consider
    flaky tests as a bug, not in the app but in your tests. Flaky tests bring many
    problems:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 等待正确的时机采取行动是避免不稳定测试的关键。不稳定测试有时通过，有时失败。你必须将不稳定测试视为一个错误，不是在应用中，而是在你的测试中。不稳定测试会带来许多问题：
- en: They are a waste of time. Nobody wants to merge a pull request with the tests
    in red. So, they will repeatedly run the tests until they get all the tests green.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们是浪费时间。没有人愿意将带有红色测试的拉取请求合并。因此，他们会反复运行测试，直到所有测试都变为绿色。
- en: Flaky tests are a false alarm. Suppose the developer doesn't know that the test
    is flaky. They might try to find a non-existent bug.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不稳定的测试是虚假的警报。假设开发者不知道测试是不稳定的。他们可能会尝试寻找一个不存在的错误。
- en: Flaky tests hurt your tests' reputation. The loss of reputation begins by skipping
    one flaky test. If you have more flaky tests, the team might move your tests to
    a nightly process. If your tests keep being flaky, they might be removed from
    the CI process. You lose, and your team losses.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不稳定测试损害了测试的声誉。声誉的损失始于跳过一次不稳定测试。如果你有更多不稳定测试，团队可能会将你的测试移动到夜间流程。如果你的测试持续不稳定，它们可能会从
    CI 流程中移除。你失去了，你的团队也失去了。
- en: Waiting for the right moment to act is the key to making stable UI tests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 等待正确的时机采取行动是制作稳定 UI 测试的关键。
- en: In this chapter, we will learn about the tools that Puppeteer provides to act
    at the right moment. We will also learn different techniques and approaches, so
    you can know how you can wait for the page to be ready, for an input to be visible,
    or for a request to be made, among many other things.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Puppeteer 提供的工具，以便在正确的时间采取行动。我们还将学习不同的技术和方法，以便你知道如何等待页面准备就绪、输入可见或请求被发起，以及其他许多事情。
- en: 'This chapter is about **waiting**, a key topic in web automation. I also want
    to show you a Puppeteer recorder so that you can add one more tool to your toolbox.
    We will cover the following topics in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论**等待**，这是网络自动化的一个关键主题。我还想向你展示一个Puppeteer录制器，这样你就可以在你的工具箱中添加一个额外的工具。在本章中，我们将涵盖以下主题：
- en: Waiting for the page to load
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待页面加载
- en: Waiting for elements
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待元素
- en: Waiting for network calls
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待网络调用
- en: Waiting for page events
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待页面事件
- en: 'Bonus: Headless Recorder'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奖励：无头录制器
- en: Let's start at the beginning. How do you know that the page is already loaded?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开始讲起。你是如何知道页面已经加载完成的？
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will find all the code of this chapter on the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter5` directory. Remember to run `npm install` on that directory
    and then go to the `Chapter5/vuejs-firebase-shopping-cart` directory and run `npm
    install` again.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库（[https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer)）的`Chapter5`目录下找到本章的所有代码。请记住在那个目录下运行`npm
    install`，然后进入`Chapter5/vuejs-firebase-shopping-cart`目录再次运行`npm install`。
- en: If you want to implement the code while following this chapter, you can start
    from the code you left in the `Chapter4` directory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在遵循本章内容的同时实现代码，你可以从`Chapter4`目录中留下的代码开始。
- en: Waiting for the page to load
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待页面加载
- en: 'In [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050), *Navigating
    through a website*, we talked about navigation through a site. We covered functions
    such as `goto`, `goBack`, `goForward`, and `reload`. One of the options these
    functions have is the `waitUntil` option. This option will help us determine when
    the function we are calling will be resolved. Let''s do a quick recap. We have
    four options there:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050)中，我们讨论了通过网站导航。我们涵盖了诸如`goto`、`goBack`、`goForward`和`reload`等函数。这些函数中的一个选项是`waitUntil`选项。这个选项将帮助我们确定我们调用的函数何时会解决。让我们快速回顾一下。我们有四个选项：
- en: '`domcontentloaded`, which relies on the `DOMContentLoaded` event.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domcontentloaded`，它依赖于`DOMContentLoaded`事件。'
- en: '`load`: If you pass this option, the `promise` will be resolved when the `load`
    event is fired.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`：如果你传递这个选项，当`load`事件被触发时，`promise`将被解决。'
- en: '`networkidle0` will resolve the promise *when there are no more network connections
    for the past 500 ms*.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`networkidle0`将在过去500毫秒内没有更多网络连接时解决`promise`。'
- en: '`networkidle2` will resolve the promise *when there are no more than 2 network
    connections for the past 500 ms*.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`networkidle2`将在过去500毫秒内没有超过2个网络连接时解决`promise`。'
- en: 'Let''s see how these options work with a site full of content such as [https://shop.mango.com/gb](https://shop.mango.com/gb).
    We are going to see what content is ready, depending on which `waitUntil` is used:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些选项如何与内容丰富的网站，如[https://shop.mango.com/gb](https://shop.mango.com/gb)一起工作。我们将看到根据使用的哪个`waitUntil`，哪些内容已经准备好了：
- en: '![Mango home page'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![芒果主页'
- en: '](img/Figure_5.01_B16113.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.01_B16113.jpg)'
- en: Mango home page
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 芒果主页
- en: 'The earliest option to be resolved is `DOMContentLoaded`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 需要最早解决的选项是`DOMContentLoaded`：
- en: '![DOM content loaded'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![DOM内容加载'
- en: '](img/Figure_5.02_B16113.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.02_B16113.jpg)'
- en: DOM content loaded
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DOM内容加载
- en: 'That page is not ready at all. Does that mean that `DOMContentLoaded` is useless?
    Well, it is useless in this case. If you do the same with Wikipedia, the page
    is so straightforward that it will be ready to automate:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那个页面根本就没有准备好。这意味着`DOMContentLoaded`就毫无用处了吗？嗯，在这个情况下确实是这样的。如果你用同样的方法来处理维基百科，页面非常直接，它会自动准备好：
- en: '![DOM content loaded in Wikipedia'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![维基百科中的DOM内容加载'
- en: '](img/Figure_5.03_B16113.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.03_B16113.jpg)'
- en: DOM content loaded in Wikipedia
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科中的DOM内容加载
- en: 'Going back to the Mango page. Waiting for the `load` event gives us all the
    content from the page:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 返回芒果页面。等待`load`事件给我们带来了页面的所有内容：
- en: '![Page after load'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![页面加载后'
- en: '](img/Figure_5.04_B16113.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.04_B16113.jpg)'
- en: Page after load
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后
- en: The background video is not there yet. And the subscribe popup didn't show up.
    But if we want to interact with the menu bar, use the login action, or test the
    cookies banner, the page is ready.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 背景视频还没有准备好。订阅弹出窗口也没有出现。但是，如果我们想要与菜单栏交互，使用登录操作，或者测试cookie横幅，页面就已经准备好了。
- en: 'It would be hard to find a page where `networkidle0` and `networkidle2` behave
    differently that you have to pick between one or the other. In this case, we''ll
    get an almost complete page:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很难找到一个页面，其中`networkidle0`和`networkidle2`的行为不同，以至于你必须在这两者之间选择。在这种情况下，我们将得到一个几乎完整的页面：
- en: '![Page using networkidle0 and networkidle2'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用networkidle0和networkidle2的页面'
- en: '](img/Figure_5.05_B16113.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.05_B16113.jpg)'
- en: Page using networkidle0 and networkidle2
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用networkidle0和networkidle2的页面
- en: The video is not being played yet, so if you want to take screenshots or generate
    PDF files, as we will see in [*Chapter 7*](B16113_07_Final_SK_ePub.xhtml#_idTextAnchor130),
    *Generating Content with Puppeteer*, this won't be enough. But we could say it's
    ready to be tested.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 视频尚未播放，因此如果你想要截图或生成PDF文件，正如我们将在[*第7章*](B16113_07_Final_SK_ePub.xhtml#_idTextAnchor130)中看到的，*使用Puppeteer生成内容*，这还不够。但我们可以说是准备好的进行测试。
- en: So, which one is better? Should we play safe and use `networkidle0` all the
    time? Shouldn't that be the default then?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，哪个更好？我们应该安全起见，始终使用`networkidle0`吗？难道那不应该成为默认设置吗？
- en: Here's where we need to find a balance. We could just wait 10 seconds between
    actions, and we wouldn't have any flaky tests. But, if you have 1,000 tests (remember,
    you will have over 1,000 tests) with 10 actions each, that would mean that the
    entire test suite would take almost 14 hours to run.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要找到平衡的地方。我们可以在操作之间等待10秒钟，这样就不会有任何不可靠的测试。但是，如果你有1,000个测试（记住，你将有超过1,000个测试），每个测试有10个操作，这意味着整个测试套件将需要近14个小时才能运行。
- en: '*To reduce flakiness, we need to find a balance between waiting for too long
    and going too fast.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了减少不可靠性，我们需要在等待时间过长和过快之间找到平衡。*'
- en: Sometimes getting the DOM from the server will be enough. If we were testing
    Wikipedia, our links would be ready for us on the `DOMContentLoaded` event. If
    we want to test our home page and we wait for `DOMContentLoaded`, images won't
    be ready yet, but we will get the stock and price values from the server. We don't
    need more than that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候从服务器获取DOM就足够了。如果我们正在测试维基百科，我们的链接会在`DOMContentLoaded`事件中为我们准备好。如果我们想测试我们的主页，并且等待`DOMContentLoaded`，图片可能还没有准备好，但我们会从服务器获取股票和价格值。我们不需要更多。
- en: Setting the right `waitUntil` will make your code less flaky, but unless you
    test a simple site such as Wikipedia, that won't be enough.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置正确的`waitUntil`将使你的代码更不可靠，但除非你测试一个像维基百科这样的简单网站，否则这还不够。
- en: The most effective way to make your code stable is by waiting for the element
    we want to interact with.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的代码最稳定的有效方法是等待我们想要与之交互的元素。
- en: Waiting for elements
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待元素
- en: 'Before acting on an element, you need to make sure of two things: first, that
    the element is there, it exists in the DOM; and second, you can act on that element.
    In other words, it''s visible to the user. Let''s see how we can wait for our
    element to be ready.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在对元素进行操作之前，你需要确保两件事：首先，该元素确实存在，它存在于DOM中；其次，你可以对该元素进行操作。换句话说，它对用户是可见的。让我们看看我们如何等待我们的元素准备好。
- en: You should wait for a selector after some kind of network call. You `goto` a
    page, wait for a selector, and then you act. You click on a button, wait for a
    selector, and then you act.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在某种网络调用之后等待选择器。你`跳转`到一个页面，等待选择器，然后进行操作。你点击一个按钮，等待选择器，然后进行操作。
- en: In some cases, the selector you need to wait for is easy to find. On our login
    page, we need to wait for the user name input. In other cases, such as our home
    page, we would need to wait for the `div` element containing all the products.
    It's just a little bit more complicated but still straightforward.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你需要等待的选择器很容易找到。在我们的登录页面上，我们需要等待用户名输入。在其他情况下，例如我们的主页，我们可能需要等待包含所有产品的`div`元素。这稍微复杂一点，但仍然直接。
- en: But what if we want to test Mango's newsletter popup? Maybe the pop-up HTML
    is on the page, but it's not visible. Here's where I start to consider waiting
    as a kind of art. It's not just about automating a page. It's not only about the
    tool. You need to find the right selectors to make your automation code stable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想测试Mango的时事通讯弹出窗口呢？也许弹出窗口的HTML已经在页面上，但它不可见。这就是我开始考虑等待作为一种艺术的地方。这不仅仅是自动化一个页面。这不仅仅是关于工具。你需要找到正确的选择器，使你的自动化代码稳定。
- en: 'We have two functions that will help us wait for elements: `waitForSelector`
    and `waitForXPath`. Both functions have a similar signature. `waitForSelector(selector,
    [options])` expects a CSS selector and an `options` object. `waitForXPath(XPath,
    [options])` expects an XPath expression and an `options` object.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个函数可以帮助我们等待元素：`waitForSelector`和`waitForXPath`。这两个函数具有相似的签名。`waitForSelector(selector,
    [options])`期望一个CSS选择器和`options`对象。`waitForXPath(XPath, [options])`期望一个XPath表达式和`options`对象。
- en: 'These are the available properties you will be able to set in the `options`
    argument:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在`options`参数中可以设置的可用属性：
- en: '`timeout`: We will find this option in all wait functions. We don''t want our
    tests to get stuck. This is another cause of flaky tests. If the timeout is reached,
    the promise will be rejected. If we don''t pass a timeout, the function will use
    the timeout set using `page.setDefaultTimeout(timeout)`. If `setDefaultTimeout`
    wasn''t used, it will default to **30 seconds**.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`：我们将在所有等待函数中找到这个选项。我们不希望我们的测试卡住。这是导致测试不可靠的另一个原因。如果达到超时时间，承诺将被拒绝。如果我们没有传递超时，函数将使用通过`page.setDefaultTimeout(timeout)`设置的超时。如果没有使用`setDefaultTimeout`，它将默认为**30秒**。'
- en: '`visible`: If `visible` is set to true, Puppeteer will not only check that
    the element exists in the DOM but that it is also visible. We would need to use
    that in our newsletter popup. This check won''t be performed by default. And,
    again, it''s something you might want to check or not, depending on your scenario.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visible`：如果`visible`设置为true，Puppeteer不仅会检查元素是否存在于DOM中，还会检查它是否可见。我们可能需要在我们的新闻通讯弹出窗口中使用它。默认情况下不会执行此检查。同样，这取决于你的场景，你可能想要检查或不要检查。'
- en: '`hidden`: If `hidden` is set to true, Puppeteer will check if the element is
    not visible or if the element is not in the DOM. This option is useful when you
    need to deal with loading animations. You know that the page is reading when the
    loading animation is hidden. [Twitter.com](http://Twitter.com) is a great example:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hidden`：如果`hidden`设置为true，Puppeteer将检查元素是否不可见或元素是否不在DOM中。这个选项在处理加载动画时很有用。你知道当加载动画隐藏时页面正在读取。[Twitter.com](http://Twitter.com)是一个很好的例子：'
- en: '![Loading animation on Twitter.com'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![Twitter.com上的加载动画'
- en: '](img/Figure_5.06_B16113.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.06_B16113.jpg)'
- en: Loading animation on Twitter.com
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter.com上的加载动画
- en: 'Both `waitForSelector` and `waitForXPath` will return a promise that can resolve
    to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForSelector`和`waitForXPath`都会返回一个可以解析为以下内容的承诺：'
- en: 'An `ElementHandle`: This element handle will be the element that eventually
    matches the CSS selector or the XPath.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElementHandle`：这个元素句柄将是最终匹配CSS选择器或XPath的元素。'
- en: 'Null: When `hidden` is set to true, and the element was not found in the DOM.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值：当`hidden`设置为true，且元素未在DOM中找到时。
- en: There are four approaches to waiting for elements. It's not about which one
    is the best. These approaches will help you in different scenarios.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种等待元素的方法。这并不是关于哪个是最好的。这些方法将帮助你在不同的场景中。
- en: Await a wait function
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待一个等待函数
- en: You will find the code used in this section in the `stackoverflow.tests.js`
    file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`stackoverflow.tests.js`文件中找到本节使用的代码。
- en: If we go to Stack Overflow ([https://stackoverflow.com/questions](https://stackoverflow.com/questions)),
    we will find that there are job postings on the right of the page. But as we can
    see, that's loaded after the page.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问Stack Overflow ([https://stackoverflow.com/questions](https://stackoverflow.com/questions))，我们会发现页面右侧有职位发布。但正如我们所见，这是在页面加载之后加载的。
- en: '![Listing while loading and list once loaded'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![在加载时列出和在加载后列出'
- en: '](img/Figure_5.07_B16113.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.07_B16113.jpg)'
- en: Listing while loading and list once loaded
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载时列出和在加载后列出
- en: Let's say that we want to test that the page has a list of jobs by default.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想测试页面默认有一个职位列表。
- en: 'We could just grab the `LI` elements using `$$` and then check whether the
    list is empty or not:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`$$`获取`LI`元素，然后检查列表是否为空：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Honestly, this will work most of the time using a decent network, but it could
    also get flaky. What we need to do is wait for the elements to be loaded before
    checking that list. What we could do is call the `waitForSelector` function before
    calling `$$`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在良好的网络环境下，这通常能起作用，但它也可能变得不可靠。我们需要做的是在检查列表之前等待元素加载。我们可以做的是在调用`$$`之前调用`waitForSelector`函数：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As I mentioned before, `waitForSelector` returns an `ElementHandle`. It uses`document.querySelector`.
    That's why we can't use the result of `waitForSelector`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，`waitForSelector`返回一个`ElementHandle`。它使用`document.querySelector`。这就是为什么我们不能使用`waitForSelector`的结果。
- en: 'But if we wanted to check whether the title is `waitForSelector` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想检查标题是否是 `waitForSelector` 函数：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I think that's the second time I have used the `evaluate` function. Patience
    – that will come in the next chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这是第二次使用 `evaluate` 函数了。耐心——这将在下一章中到来。
- en: In case you are wondering why we didn't use the result of `waitForSelector`
    in the job listing example, it turns out that `waitForSelector` uses `document.querySelector`
    to evaluate the CSS expression. That will make `waitForSelector` return only one
    item.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我们没有在职位列表示例中使用 `waitForSelector` 的结果，结果是 `waitForSelector` 使用 `document.querySelector`
    来评估 CSS 表达式。这将使 `waitForSelector` 只返回一个项目。
- en: The same happens with `waitForXpath`. Unlike `$x`, that returns an array of
    elements. `waitForXpath` will return only one element.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `waitForXpath` 一样，这也会发生。与 `$x` 不同，它返回一个元素数组。`waitForXpath` 只会返回一个元素。
- en: '`waitForSelector` and `waitForXPath` will save your day most of the time, but
    there are other scenarios we might want to consider. For instance, we might need
    to check network calls. We might want to wait for a request to be made or for
    a response to be received. Let''s see how to accomplish that.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForSelector` 和 `waitForXPath` 大多数时候都能帮到你，但还有其他我们可能需要考虑的场景。例如，我们可能需要检查网络调用。我们可能想要等待一个请求被发送或响应被接收。让我们看看如何完成这个任务。'
- en: Waiting for network calls
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待网络调用
- en: In [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050), *Navigating
    through a website*, we talked about **requests** and **responses**. Every page
    navigation begins with a request to a page. The server then processes that request
    and sends a response. That response generally is an HTML page, which has resources
    declared that need to be requested. The server will process each of those requests
    again and send many responses.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050) 中，*浏览网站*，我们讨论了 **请求**
    和 **响应**。每次页面导航都是从向页面发送请求开始的。服务器随后处理该请求并发送响应。该响应通常是包含需要请求的资源的一个 HTML 页面。服务器将再次处理这些请求并发送多个响应。
- en: 'But that''s not all. Modern apps will send requests to the server based on
    user actions. Take *Google Maps*: the user moves the mouse, and the page will
    need to request a new picture of the map without reloading the entire page.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不算全部。现代应用程序会根据用户操作向服务器发送请求。以 *Google Maps* 为例：用户移动鼠标，页面就需要请求新的地图图片，而无需重新加载整个页面。
- en: We don't work on the *Google Maps* teams, but many users have reported that
    the home page sometimes doesn't load the product image after login. So, we could
    write a test to check that *it should load an image*. Oh… you thought we were
    going to test *Google Maps*? Not this time, sorry.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不在 *Google Maps* 团队工作，但许多用户报告说，主页有时在登录后不会加载产品图片。因此，我们可以编写一个测试来检查 *它应该加载一个图片*。哦……你以为我们要测试
    *Google Maps*？不是这次，抱歉。
- en: 'In this case, we can use `waitForResponse(urlOrPredicate, [options])`. Let''s
    unpack these arguments:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用 `waitForResponse(urlOrPredicate, [options])`。让我们来分解这些参数：
- en: '`urlOrPredicate` can be a string with the URL we want to wait for. But it can
    also be a function. This should be a function expecting a response, which will
    be the response you will want to check and return a truthy value.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urlOrPredicate` 可以是一个包含我们想要等待的 URL 的字符串。但它也可以是一个函数。这个函数应该期望一个响应，这将是你想要检查并返回一个真值的结果。'
- en: 'The only option we have in this function is `timeout`. This property has the
    same conditions as the one in `waitForSelector`: If not passed, Puppeteer will
    use `page.setDefaultTimeout(timeout)`, and if that function wasn''t used, the
    default will be 30 seconds.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们唯一的选择是 `timeout`。这个属性的条件与 `waitForSelector` 中的相同：如果没有传递，Puppeteer 将使用
    `page.setDefaultTimeout(timeout)`，如果没有使用该函数，默认为 30 秒。
- en: Let's write our test. We need to log in and wait for the product image. To accomplish
    this, we are going to use the **Arrange, Act, Await** approach.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的测试。我们需要登录并等待产品图片。为了完成这个任务，我们将使用 **Arrange, Act, Await** 方法。
- en: Arrange, Act, Await
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arrange, Act, Await
- en: This name comes from the arrange, act, assert pattern we talked about in [*Chapter
    4*](B16113_04_Final_SK_ePub.xhtml#_idTextAnchor072), *Interacting with a page*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字来源于我们之前在 [*第 4 章*](B16113_04_Final_SK_ePub.xhtml#_idTextAnchor072) 中讨论的
    arrange, act, assert 模式，*与页面交互*。
- en: With this pattern, we try to prevent **race conditions**, a common issue in
    async programming, and a cause of flakiness. A race condition in async programming
    is when you are trying to do two or more tasks simultaneously, and the speed of
    one task (too fast or too slow) causes another task to never complete.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，我们试图防止**竞态条件**，这是异步编程中常见的问题，也是不稳定的原因。异步编程中的竞态条件是指你试图同时执行两个或多个任务，其中一个任务的速度（太快或太慢）导致另一个任务永远无法完成。
- en: 'Let''s take, for instance, this test:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以这个测试为例：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, notice something. We are not using asserts. The fact that the `waitForResponse`
    promise resolves is enough for us to know that the test was successful.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意一点。我们没有使用断言。`waitForResponse`承诺解决的事实就足以让我们知道测试是成功的。
- en: Another important concept here is that `waitForReponse` doesn't behave in the
    same way as `waitForSelector`. When we use `waitForSelector`, the function will
    resolve when the element we are waiting for is already in the DOM. But with `waitForResponse`,
    if the response we are waiting for has already happened, our `waitForResponse`
    will time out.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个重要的概念是`waitForResponse`的行为与`waitForSelector`不同。当我们使用`waitForSelector`时，函数会在我们等待的元素已经在DOM中时解决。但与`waitForResponse`不同，如果我们等待的响应已经发生，我们的`waitForResponse`将会超时。
- en: 'Our code there has a risk of flakiness. If our server is too fast serving the
    page after login, the image might have already been served before we wait for
    it. To solve that, we need to get the promise first, and then await it. This is
    how we could change our code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们那里的代码存在不稳定的隐患。如果我们的服务器在登录后响应页面过快，图片可能在我们等待之前就已经被发送了。为了解决这个问题，我们需要先获取承诺，然后再等待它。这就是我们如何修改代码的方式：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that instead of awaiting the promised returned by `waitForResponse`,
    we are assigning that promise to a variable. We call `waitForResponse`, we keep
    that promise, then we act (log in). After that, we await that promise, hoping
    that it will be resolved at one point after the login action is complete. You
    can find this test in the `login.tests.js` file. There, the test is called `Should
    load image after login`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不是在等待`waitForResponse`返回的承诺，而是将那个承诺赋值给一个变量。我们调用`waitForResponse`，保留那个承诺，然后采取行动（登录）。之后，我们等待那个承诺，希望它在登录操作完成后某个时刻被解决。你可以在这个`login.tests.js`文件中找到这个测试。在那里，测试被命名为`Should
    load image after login`。
- en: In the same way that we use `waitForResponse`, we can use `waitForRequest`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们使用`waitForResponse`一样，我们也可以使用`waitForRequest`。
- en: We would use `waitForRequest` instead of `waitForResponse` if we wanted to check
    whether the browser is sending a request to the server. As this function also
    expects a `predicate`, a function, as an argument, we can check not only for the
    URL but also the content of the request.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要检查浏览器是否向服务器发送请求，我们会使用`waitForRequest`而不是`waitForResponse`。因为这个函数也期望一个函数作为参数，我们可以检查不仅URL，还可以请求的内容。
- en: Let's say that we work at The Weather Channel ([https://weather.com/](https://weather.com/)).
    We want to check that the browser is sending our location. We found that the page
    is calling `redux-dal`. We want to wait for that request, parse the `params` object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在天气频道([https://weather.com/](https://weather.com/))工作。我们想要检查浏览器是否发送了我们的位置。我们发现页面正在调用`redux-dal`。我们想要等待那个请求，解析`params`对象。
- en: '![The weather channel'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![天气频道'
- en: '](img/Figure_5.08_B16113.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.08_B16113.jpg)'
- en: The weather channel
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 天气频道
- en: We are going to solve this using the **fire and forget** approach.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**火速发射，无需关注**的方法来解决这个问题。
- en: Fire and forget
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 火速发射，无需关注
- en: You will find the code used in this section in the `weather.tests.js` file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本节中使用的代码在`weather.tests.js`文件中找到。
- en: We call it a "fire and forget" when we call a function that returns a promise
    but we don't await that promise, and we don't even care about the result of that
    promise. "Fire and forget" is a military term that refers to a type of missile
    that does not require further guidance after launch. In our case, our missiles
    are Promises that we launch, but we don't care about the outcome of them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个返回承诺但又不等待该承诺，甚至不关心该承诺结果的函数时，我们称之为“火速发射，无需关注”。这是一个军事术语，指的是一种发射后无需进一步引导的导弹。在我们的情况下，我们的“导弹”是承诺，我们发射了它们，但我们不关心它们的结局。
- en: 'Let''s see how a fire and forget approach would look:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看火速发射的方法会是什么样子：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are many new things to learn here.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多新事物需要学习。
- en: We fire and forget the `goto` action. We call `goto`, but we don't wait for
    it to finish. Doing a fire and forget means that we won't care if the promise
    resolves or fails. In this case, we care about the `request` promise. If `goto`
    fails, the `waitForRequest` will fail, and the test will fail.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们触发并忘记`goto`操作。我们调用`goto`，但不会等待它完成。执行触发并忘记意味着我们不会关心promise是否解析或失败。在这种情况下，我们关心`request`
    promise。如果`goto`失败，`waitForRequest`将失败，测试将失败。
- en: 'The second new feature we can see here is that we are waiting for a request
    using a predicate, a function that expects a request and returns a truthy value:
    `r => r.url().includes(''redux-dal'')`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到的第二个新功能是，我们正在使用谓词等待一个请求，一个期望请求并返回一个真值的函数：`r => r.url().includes('redux-dal')`。
- en: The last thing we can learn here is that we are working with the request resolved
    by the `waitForRequest` promise. Once we get the request, we extract the payload
    using `postData`, parse it, and evaluate the content.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以学到的最后一件事是，我们正在使用由`waitForRequest` promise解析的请求。一旦我们得到请求，我们使用`postData`提取负载，解析它，并评估内容。
- en: The last feature we have to handle network calls is `waitForNavigation`. Imagine
    `waitForNavigation` as the `goto` function without the URL argument. It's `waitForNavigation([options])`.
    The options are the same options `goto` has. We can use this function to wait
    for navigation triggered by one action we perform.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理的最后一个网络调用功能是`waitForNavigation`。想象一下`waitForNavigation`是`goto`函数没有URL参数的形式。它是`waitForNavigation([options])`。选项与`goto`相同。我们可以使用这个函数等待由我们执行的一个操作触发的导航。
- en: Let's take, for example, the Packtpub site ([https://www.packtpub.com/](https://www.packtpub.com/)).
    We want to search for a book, press *Enter*, and wait for the page to be redirected
    to the results page.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以Packtpub网站（[https://www.packtpub.com/](https://www.packtpub.com/)）为例。我们想要搜索一本书，按*Enter*键，然后等待页面跳转到结果页面。
- en: 'For this test, we are going to use our fourth approach: `Promise.all`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我们将使用我们的第四种方法：`Promise.all`。
- en: Promise.all
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise.all
- en: You will find the code used in this section in the `packpub.tests.js` file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`packpub.tests.js`文件中找到本节使用的代码。
- en: Depending on the scenario, `Promise.all` could be a shortcut for Act, Arrange,
    Await. In fact, I would keep the latter for more complex scenarios and use `Promise.all`
    if I need to wait for two tasks at the same time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 根据场景，`Promise.all`可以是Act, Arrange, Await的快捷方式。实际上，我会保留后者用于更复杂的场景，并在需要同时等待两个任务时使用`Promise.all`。
- en: 'Our test code would look like this with a `Promise.all`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试代码将使用`Promise.all`看起来像这样：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first part is pretty straightforward. We go to the site, get the search
    input, and type "Puppeteer." But then, we wait for two Promises in the same `await`
    statement. We wait for navigation to be completed and the `press` function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分相当直接。我们访问网站，获取搜索输入，并输入“Puppeteer”。但是，我们会在同一个`await`语句中等待两个Promise。我们等待导航完成和`press`函数。
- en: Although it would be quite weird getting a race condition inside a `Promise.all`,
    I feel safer adding the `wait` function as the first argument of the `all` function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在`Promise.all`内部得到一个竞争条件会很奇怪，但我感觉在`all`函数的第一个参数中添加`wait`函数会更安全。
- en: As I mentioned in [*Chapter 1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Getting started with Puppeteer*, `Promise.all` will wait for all promises to
    finish. It will also resolve as soon as one promise fails.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[*第一章*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014)中提到的，*使用Puppeteer入门*，`Promise.all`将等待所有Promise完成。它也会在任何一个Promise失败时立即解析。
- en: 'Now we know how to wait for elements and network calls. But let me tell you
    a little secret: `waitForRequest` and `waitForResponse` are just wrappers around
    the request and response events the page offers. Puppeteer would create a Promise,
    start listening to an event, and then resolve the Promise when a condition is
    met. The good news is that we can use this same approach to wait for many other
    events.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何等待元素和网络调用。但让我告诉你一个小秘密：`waitForRequest`和`waitForResponse`只是页面提供的请求和响应事件的包装器。Puppeteer会创建一个Promise，开始监听一个事件，然后在满足条件时解析Promise。好消息是我们可以使用这种方法等待许多其他事件。
- en: Waiting for page events
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待页面事件
- en: Events are messages that a class sends when something happens. As a consumer,
    you can `page-event-demos.js` file inside the `Chapter5` directory. To run that
    demo, you just need to run `node page-event-demos.js`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是当某个事情发生时类发送的消息。作为消费者，你可以在`Chapter5`目录下的`page-event-demos.js`文件中找到这些事件。要运行这个演示，你只需要运行`node
    page-event-demos.js`。
- en: 'This is how you could listen to responses without the `waitForResponse`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何在没有`waitForResponse`的情况下监听响应：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first line, we say that we want to listen to the `response` event, and
    when a new response arrives, we want to print the URL in the console. Then, we
    call the `goto` function, and all the responses will start being written in the
    console.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们表示我们想要监听`response`事件，当新的响应到达时，我们想要在控制台打印URL。然后，我们调用`goto`函数，所有的响应都将开始写入控制台。
- en: 'Using the arrow (`=>`) is a simple way to write single-line functions. But,
    if you open a bracket, you can write more complex functions, like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头（`=>`）是编写单行函数的简单方法。但是，如果你打开一个括号，你可以编写更复杂的函数，如下所示：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you want to reuse a function, you can pass a function there:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要重用函数，你可以将其传递到那里：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, we can create a function, assign it to a variable – in this
    case, `listenToImages` – and then pass it to the `page.on` function. If you pass
    a function, you will be able to remove that listener:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们可以创建一个函数，将其分配给一个变量——在这个例子中，是`listenToImages`——然后将其传递给`page.on`函数。如果你传递一个函数，你将能够移除那个监听器：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `removeListener` function will detach the `listenToImages` function from
    the `response` event.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeListener`函数将`listenToImages`函数从`response`事件中分离。'
- en: 'There is one more feature to add to your toolbox. You can listen to an event
    only once, using – you guessed it – `once`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要给你的工具箱添加一个新功能。你可以使用`once`来监听一个事件，只发生一次：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`once` will attach your function to an event and remove it as soon as the first
    event arrives. Notice that `once` won''t evaluate the result of your function.
    You won''t be able to prevent `once` from removing your listener as soon as the
    first event arrives.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`once`将你的函数附加到事件上，并在第一个事件到达时立即将其移除。请注意，`once`不会评估你函数的结果。你将无法阻止`once`在第一个事件到达时立即移除你的监听器。'
- en: 'We can now try to make our own `waitForResponse` function. We will use the
    approach we mentioned in [*Chapter 1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Getting started with Puppeteer*: *Fulfill our own promises*. We can create a
    promise, and then we will resolve it when the condition we are waiting for is
    met:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试创建自己的`waitForResponse`函数。我们将使用我们在[*第1章*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014)中提到的方法，*使用Puppeteer入门*：*履行我们的承诺*。我们可以创建一个承诺，然后当等待的条件满足时，我们将解决它：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code, we created a promise that will be resolved when the `resolve`
    function is called. Inside that function, we attached to the response event and,
    when the URL matched, we called `resolve` passing that response.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个承诺，当`resolve`函数被调用时，它将被解决。在函数内部，我们附加到响应事件，当URL匹配时，我们调用`resolve`传递那个响应。
- en: In this case, using the `waitForResponse` function will be easier. But there
    are events that don't have a `waitFor` function, and you will need to use this
    approach to wait for them. Let's see what page events we have available.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用`waitForResponse`函数会更简单。但是，有些事件没有`waitFor`函数，你需要使用这种方法来等待它们。让我们看看我们有哪些页面事件可用。
- en: The close event
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭事件
- en: The `close` event is triggered when the page is closed. These days, it's not
    so common to have popups, mainly because they are not mobile-friendly. But we
    can still find some cases. For instance, when you want to add an account to your
    existing *Gmail* account.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面关闭时，会触发`close`事件。如今，弹出窗口并不常见，主要是因为它们对移动设备不友好。但我们仍然可以找到一些情况。例如，当你想要将账户添加到现有的*Gmail*账户时。
- en: '![Popup in Gmail'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![Gmail中的弹出窗口'
- en: '](img/Figure_5.09_B16113.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.09_B16113.jpg)'
- en: Popup in Gmail
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Gmail中的弹出窗口
- en: You will need to listen to that page's `close` event to know that the wizard
    process has finished.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要监听该页面的`close`事件，以了解向导过程是否完成。
- en: But that leaves us with another question. How do you get to that page? If we
    are testing the *Gmail* page and click on the **Create account** link, how do
    we get the popup?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但这又引出了另一个问题。你如何到达那个页面？如果我们正在测试*Gmail*页面并点击**创建账户**链接，我们如何获取弹出窗口？
- en: The popup event
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹出事件
- en: 'The page will trigger a `popup` event when it opens a new tab or window. We
    could do something like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面打开新标签页或窗口时，将触发`popup`事件。我们可以这样做：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One new thing we can learn here is that `promise.all` returns an array of all
    the responses. As we only care about the response of the first promise, we create
    an array with only one element `[newPage]`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以学到的一个新东西是`promise.all`返回所有响应的数组。因为我们只关心第一个承诺的响应，所以我们创建了一个只有一个元素的数组`[newPage]`。
- en: If you want to listen to new pages regardless of what triggered that new page,
    you can also listen to browser events.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要监听新页面，无论是什么触发了新页面，你也可以监听浏览器事件。
- en: Target created event
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标创建事件
- en: 'The `targetcreated` event is triggered when a new target (page) is created
    inside the browser. We could do something like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当在浏览器内部创建一个新的目标（页面）时，会触发`targetcreated`事件。我们可以做如下操作：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In most scenarios, this will work in the same way as the `popup` event. But
    it's good for you to know that you also have this tool available.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这将以与`popup`事件相同的方式工作。但了解你也有这个工具可用是好的。
- en: Let's go back to page events.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到页面事件。
- en: The console event
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制台事件
- en: 'The `console` event will be triggered every time a new line is printed on the
    browser console. In the same way the `response` event gives us a `response` object
    with all the information, the `console` event will give us a message class with
    the following functions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`console`事件将在浏览器控制台打印新行时被触发。与`response`事件以包含所有信息的`response`对象一样，`console`事件将给我们一个带有以下函数的消息类：'
- en: '`text()` with the text message.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`text()`函数传递文本消息。
- en: '`type(),` which will help us identify the type of the message. The most common
    types are: ''log'', ''debug'', ''info'', ''error,'' and ''warning''.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type()`，它将帮助我们识别消息的类型。最常见类型有：''log'', ''debug'', ''info'', ''error,'' 和 ''warning''。'
- en: '`location()`, giving us the source of the message.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location()`，给出消息的来源。'
- en: As `console.log` can expect objects as arguments, we can access those element
    handles with `args()`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`console.log`可以期望对象作为参数，我们可以使用`args()`函数访问这些元素句柄。
- en: You can use this event to check that there are no JavaScript errors during the
    test.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此事件来检查测试过程中没有JavaScript错误。
- en: The dialog event
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对话框事件
- en: The `dialog` event is important because dialogs stop the execution of a page.
    There are many types of dialogs, and each of them will require us to react differently.
    We can know the dialog type using the `type()` function. Let's take a look at
    the different dialog types and how we can react to them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`dialog`事件很重要，因为对话框会停止页面的执行。有许多类型的对话框，每种都需要我们以不同的方式做出反应。我们可以使用`type()`函数知道对话框类型。让我们看看不同的对话框类型以及我们如何对它们做出反应。'
- en: The alert type
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告类型
- en: '`Alert` is a dialog with only an `dialog.accept()`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Alert`是一个只有`dialog.accept()`的对话框：'
- en: '![Alert](img/Figure_5.10_B16113.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![警告](img/Figure_5.10_B16113.jpg)'
- en: Alert
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Confirm type
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确认类型
- en: '`Confirm` is a dialog with an `dialog.accept()` or `dialog.dismiss()` to cancel
    it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Confirm`是一个带有`dialog.accept()`或`dialog.dismiss()`来取消的对话框：'
- en: '![Confirm'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![确认'
- en: '](img/Figure_5.11_B16113.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.11_B16113.jpg)'
- en: Confirm
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 确认
- en: The prompt type
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示类型
- en: 'The `prompt` dialog is not common these days. It''s like the `confirm` dialog
    but it prompts an input that you can pass by passing a string to the `accept`
    function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`prompt`对话框在当今并不常见。它类似于`confirm`对话框，但会提示输入，你可以通过传递一个字符串给`accept`函数来通过：'
- en: '![Prompt](img/Figure_5.12_B16113.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![提示](img/Figure_5.12_B16113.jpg)'
- en: Prompt
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The beforeunload type
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`beforeunload`类型'
- en: 'You will see `beforeunload` these days, asking you if you want to leave the
    site without saving your changes. It works as a `confirm` dialog. You can interact
    with this dialog in the same way you would interact with the `prompt` dialog:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到`beforeunload`，询问你是否想要在不保存更改的情况下离开网站。它的工作方式与`confirm`对话框相同。你可以以与`prompt`对话框相同的方式与这个对话框交互：
- en: '![Before unload dialog'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![卸载前对话框'
- en: '](img/Figure_5.13_B16113.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.13_B16113.jpg)'
- en: Before unload dialog
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载前对话框
- en: 'Let''s wrap up this chapter with a new tool for our toolbox: **the headless
    recorder**.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个新的工具来结束这一章：**无头记录器**。
- en: The headless recorder
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无头记录器
- en: The headless recorder is a Chrome extension developed by *Checkly* ([https://www.checklyhq.com/](https://www.checklyhq.com/)).
    This extension will record the actions you perform on a page and generate Puppeteer
    code based on those actions. I think it's a great tool to get a first draft of
    a Puppeteer test, and from there, start working on the final code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 无头记录器是由*Checkly*（[https://www.checklyhq.com/](https://www.checklyhq.com/)）开发的Chrome扩展。此扩展将记录你在页面上的操作，并根据这些操作生成Puppeteer代码。我认为这是一个获取Puppeteer测试初稿的绝佳工具，并从这里开始编写最终代码。
- en: 'You can download this extension by going to the Chrome Web Store ([https://chrome.google.com/webstore](https://chrome.google.com/webstore))
    and searching for `Headless Recorder`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问Chrome Web Store（[https://chrome.google.com/webstore](https://chrome.google.com/webstore)）并搜索`Headless
    Recorder`来下载此扩展：
- en: '![Headless Recorder'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![无头记录器'
- en: '](img/Figure_5.14_B16113.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.14_B16113.jpg)'
- en: Headless Recorder
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 无头记录器
- en: 'Once installed, you will find a **recorder icon** at the top right of your
    browser. From there, you will have the **record button**, which will start to
    capture all the actions you perform on a page:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，你将在浏览器右上角找到一个**记录器图标**。从那里，你将有一个**记录按钮**，它将开始捕获你在页面上执行的所有操作：
- en: '![Record option'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![记录选项'
- en: '](img/Figure_5.15_B16113.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.15_B16113.jpg)'
- en: Record option
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 记录选项
- en: 'Once you finish performing your test actions, you click **stop**, and you''ll
    get the code almost ready to be used:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成测试操作的执行，你点击**停止**，你将得到几乎可以使用的代码：
- en: '![Headless Recorder result'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![无头记录器结果'
- en: '](img/Figure_5.16_B16113.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.16_B16113.jpg)'
- en: Headless Recorder result
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 无头记录器结果
- en: I say almost ready because the recorder can't guess your real intentions. It's
    just a guide. As you can see there are selectors such as `.mb-3:nth-child(1) >
    .thumbnail > .card-body > .row > .col-6 > .btn.` The recorder doesn't know what
    your intentions are behind clicking on a certain link. But it's a good start,
    and it can help you when your test requires many steps.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我说几乎准备好了，因为录音机无法猜测你的真实意图。它只是一个指南。正如你所见，有选择器，例如 `.mb-3:nth-child(1) > .thumbnail
    > .card-body > .row > .col-6 > .btn.` 录音机不知道你点击某个链接背后的意图是什么。但这是一个好的开始，并且当你的测试需要多个步骤时，它可以帮助你。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the concept of flaky tests, and we saw many techniques
    and tools to prevent having flaky tests in our test suites.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了易失性测试的概念，并看到了许多技术和工具来防止在我们的测试套件中存在易失性测试。
- en: While we were learning about these wait tools, we saw many page events without
    even noticing them. Now you can not only wait for selectors and network calls
    but you can also deal with dialogs and popups.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在学习这些等待工具时，我们甚至没有注意到就看到了许多页面事件。现在你不仅可以等待选择器和网络调用，还可以处理对话框和弹出窗口。
- en: The last section was short, but as promised, we now have another tool in our
    toolbox, a headless recorder.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分很短，但正如承诺的那样，我们现在在工具箱中又多了一个工具，一个无头记录器。
- en: In the next chapter, we will get into more advanced tools and learn how to execute
    JavaScript in the browser.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解更高级的工具，并学习如何在浏览器中执行JavaScript。
