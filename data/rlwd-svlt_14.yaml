- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Exploring Custom Transitions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索自定义过渡
- en: In this chapter, we will delve into the world of custom transitions in Svelte.
    So far, we have explored Svelte’s built-in transitions and how they can be used
    to create engaging and dynamic user interfaces. However, there may be situations
    where the built-in transitions don’t quite meet your requirements and you want
    to create something more unique. This is where custom transitions come into play.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨Svelte中的自定义过渡。到目前为止，我们已经探讨了Svelte的内置过渡以及如何使用它们创建引人入胜和动态的用户界面。然而，可能存在内置过渡无法完全满足你的要求，而你希望创建更独特的东西的情况。这就是自定义过渡发挥作用的地方。
- en: Custom transitions allow you to take full control over the animations and effects
    that you want to achieve in your Svelte application. This chapter will guide you
    through the process of creating your own custom transitions, whether they are
    CSS- or JavaScript-based. We will explore the transition contract, which serves
    as the foundation for creating custom transitions, and provide practical examples
    to help you get started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义过渡允许你完全控制你希望在Svelte应用程序中实现的动画和效果。本章将指导你创建自己的自定义过渡，无论它们是基于CSS还是JavaScript。我们将探讨过渡合约，它是创建自定义过渡的基础，并提供实际示例以帮助你入门。
- en: By the end of this chapter, you will have a solid understanding of how to create
    custom transitions in Svelte, and you will be equipped with the knowledge to implement
    them in your own projects, taking your user interfaces to the next level.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将牢固地理解如何在Svelte中创建自定义过渡，并且你将具备在项目中实现它们的知识，将你的用户界面提升到新的水平。
- en: 'This chapter includes sections on the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题的章节：
- en: The transition contract
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过渡合约
- en: Writing a custom CSS transition using the `css` function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`css`函数编写自定义CSS过渡
- en: Writing a custom JavaScript transition using the `tick` function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tick`函数编写自定义JavaScript过渡
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will be somewhat code-heavy, but don’t worry—you can find all the
    code samples used in this chapter on GitHub at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包含大量的代码，但请放心——你可以在GitHub上找到本章中使用的所有代码示例，网址为[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14)。
- en: The transition contract
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过渡合约
- en: 'Before we dive into creating custom transitions, it’s essential to understand
    the foundation upon which they are built: the transition contract.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入创建自定义过渡之前，了解它们建立的基础是至关重要的：过渡合约。
- en: If you’ve read [*Chapter 9*](B18887_09.xhtml#_idTextAnchor135), you’ll be familiar
    with the concept of a store contract. Just as a store is an object that adheres
    to a specific store contract, a transition is a function that follows a transition
    contract. By understanding and adhering to these contracts, you can create custom
    transitions that integrate seamlessly with Svelte’s built-in transition system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了[*第9章*](B18887_09.xhtml#_idTextAnchor135)，你将熟悉存储合约的概念。正如存储是一个遵循特定存储合约的对象一样，过渡是一个遵循过渡合约的函数。通过理解和遵守这些合约，你可以创建与Svelte内置过渡系统无缝集成的自定义过渡。
- en: 'The transition contract consists of a single function that is responsible for
    the transition. This function accepts two arguments:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡合约由一个负责过渡的单个函数组成。这个函数接受两个参数：
- en: '`node`: The target DOM element that the transition will be applied to'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`节点`：应用过渡的目标DOM元素'
- en: '`params`: An object containing configuration options'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`：包含配置选项的对象'
- en: The function should return an object that describes how the transition should
    be executed. We will delve into the details of this returned object later in the
    section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应返回一个描述如何执行过渡的对象。我们将在本节稍后深入探讨这个返回对象的细节。
- en: 'Here is an example of a custom transition that adheres to the transition contract:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个遵循过渡合约的自定义过渡示例：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code snippet, we have created a custom transition named `customTransition`.
    We did this by declaring a `customTransition` function that takes in two parameters:
    `node` and `params`. This function then returns an object—which we’ll refer to
    as `config`—that describes the transition.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个名为`customTransition`的自定义过渡。我们通过声明一个接受两个参数的`customTransition`函数来实现这一点：`node`和`params`。然后，这个函数返回一个对象——我们将称之为`config`——它描述了过渡。
- en: 'To relate the custom transition we’ve just created back to the usage of a transition
    in Svelte, here, we see how the `customTransition` function is applied to a `<``div>`
    element:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们刚刚创建的自定义过渡与 Svelte 中过渡的使用联系起来，这里我们看到 `customTransition` 函数是如何应用于 `<div>`
    元素的：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the `<div>` element is inserted or about to be removed from the DOM, Svelte
    will attempt to play the transition. Svelte does this by calling the `customTransition`
    function with a reference to the `<div>` element and the `config` object passed
    to the transition:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `<div>` 元素被插入或即将从 DOM 中移除时，Svelte 将尝试播放过渡。Svelte 通过调用 `customTransition` 函数并传递
    `<div>` 元素和传递给过渡的 `config` 对象来实现这一点：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `config` object returned by `customTransition` will determine how the transition
    is played out.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `customTransition` 返回的此 `config` 对象将决定过渡如何播放。
- en: Now, let’s focus on the requirements for the `config` object returned by the
    custom transition function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注自定义过渡函数返回的 `config` 对象的要求。
- en: 'The `config` object returned from a custom transition should include at least
    one of the following properties or methods:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从自定义过渡返回的 `config` 对象应至少包含以下属性或方法之一：
- en: '`delay`: A number specified in milliseconds. This specifies how long to wait
    before the transition begins.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`: 以毫秒为单位的数字。这指定了在过渡开始之前需要等待多长时间。'
- en: '`duration`: A number specified in milliseconds. The duration that the transition
    will play. This determines how fast or slow the animation appears to the user.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration`: 以毫秒为单位的数字。指定过渡播放的持续时间。这决定了动画对用户来说看起来有多快或多慢。'
- en: '`easing`: A function for easing the transition. This function determines the
    rate of change in the transition’s progress over time.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`easing`: 用于缓动的函数。此函数确定过渡进度随时间变化的速率。'
- en: '`css`: A function that is called with two parameters: `progress` and `remaining`.
    Here, `progress` is a value between `0` and `1` representing the progress of the
    transition, and the value of the `remaining` parameter is equal to `1 -` `progress`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css`: 一个带有两个参数的函数：`progress` 和 `remaining`。在这里，`progress` 是一个介于 `0` 和 `1`
    之间的值，表示过渡的进度，而 `remaining` 参数的值等于 `1 - progress`。'
- en: This function should return a string containing the CSS styles to be applied
    to the target DOM element.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数应返回一个包含要应用于目标 DOM 元素的 CSS 样式的字符串。
- en: '`tick`: A function that is called repeatedly during the transition with two
    parameters: `progress` and `remaining`. Here, `progress` is a value between `0`
    and `1` indicating the progress of the transition, and the value of the `remaining`
    parameter is equal to `1 -` `progress`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tick`: 一个在过渡期间重复调用的函数，带有两个参数：`progress` 和 `remaining`。在这里，`progress` 是一个介于
    `0` 和 `1` 之间的值，表示过渡的进度，而 `remaining` 参数的值等于 `1 - progress`。'
- en: This function can be used to update the DOM element’s styles based on the current
    progress.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数可用于根据当前进度更新 DOM 元素的样式。
- en: 'Here is a more complete sample of a custom transition that follows the transition
    contract:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个遵循过渡契约的更完整的自定义过渡示例：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, our custom transition, named `customTransition`,
    returns an object that describes the transition’s `duration`, `delay`, `easing`,
    and `css` styles.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们的自定义过渡（命名为 `customTransition`）返回一个对象，描述了过渡的 `duration`、`delay`、`easing`
    和 `css` 样式。
- en: 'We saw `delay`, `duration`, and `easing` in the previous chapter when applying
    transitions to an element. Since the behavior of these properties remains the
    same in this context, let us focus on something new: the `css` and `tick` functions.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们将过渡应用于元素时，我们看到了 `delay`、`duration` 和 `easing`。由于这些属性的行为在此上下文中保持不变，让我们关注一些新的内容：`css`
    和 `tick` 函数。
- en: The css function
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`css` 函数'
- en: As you might remember from the last section of the previous chapter, *How Svelte
    transitions work under the hood*, Svelte animates transitions using a combination
    of CSS and JavaScript. It leverages CSS `@keyframe` rules along with the `animation`
    property for CSS animations and the `requestAnimationFrame` function for JavaScript
    animations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能记得，在上一章的最后部分，*Svelte 过渡在底层是如何工作的*，Svelte 使用 CSS 和 JavaScript 的组合来动画化过渡。它利用
    CSS `@keyframe` 规则以及 CSS 动画的 `animation` 属性和 JavaScript 动画的 `requestAnimationFrame`
    函数。
- en: The `css` function is used to generate CSS `@keyframe` rules for custom transitions.
    If the `css` function is defined in the returned object of a custom transition,
    Svelte will call this function when an element is inserted into the DOM or about
    to be removed from the DOM. Svelte will call the `css` function as many times
    as necessary, depending on the duration and easing of the transition, in order
    to generate the appropriate `@``keyframe` rules.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`css`函数用于生成自定义过渡的CSS `@keyframe`规则。如果`css`函数定义在自定义过渡返回的对象中，Svelte将在元素被插入到DOM或即将从DOM中移除时调用此函数。Svelte将根据过渡的持续时间和缓动效果，多次调用`css`函数，以生成适当的`@keyframe`规则。'
- en: The first parameter of the `css` function relates to the progress of the transition.
    `progress` is a number between `0` and `1`, where `0` represents the element being
    out of view, and 1 represents the element being in its final position on the screen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`css`函数的第一个参数与过渡的进度相关。`progress`是一个介于`0`和`1`之间的数字，其中`0`表示元素不可见，`1`表示元素在屏幕上的最终位置。'
- en: For example, when transitioning an element in after it has been inserted into
    the DOM, the value of `progress` starts at `0` and moves toward `1`. Conversely,
    when transitioning an element out before it is removed from the DOM, the value
    of `progress` starts at `1` and moves toward `0`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当元素被插入到DOM中后进行过渡时，`progress`的值从`0`开始，逐渐移动到`1`。相反，当元素在从DOM中移除之前进行过渡时，`progress`的值从`1`开始，逐渐移动到`0`。
- en: You can use `progress` to calculate the CSS styles necessary to create your
    custom transition.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`progress`来计算创建自定义过渡所需的CSS样式。
- en: 'For example, if we want to create a transition that fades an element from transparent
    to fully visible, we can use `progress` to calculate the opacity value throughout
    the transition:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建一个将元素从透明渐变到完全可见的过渡效果，我们可以使用`progress`来计算过渡过程中的透明度值：
- en: When the element is out of view (value of `progress` is `0`), we want the element
    to be transparent (value of `opacity` should be `0`)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素不可见（`progress`的值为`0`）时，我们希望元素是透明的（`opacity`的值应为`0`）
- en: When the element is in view (value of `progress` is `1`), we want the element
    to be fully visible (value of `opacity` should be `1`)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素可见（`progress`的值为`1`）时，我们希望元素完全可见（`opacity`的值应为`1`）
- en: 'The relationship between `progress` and `opacity` can be represented by the
    diagram shown in *Figure 14**.1*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`progress`与`opacity`之间的关系可以用*图14**.1*中的图表表示：'
- en: 'igure 14.1: Relationship between progress and opacity'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：进度与透明度的关系
- en: 'We are going to derive the value of `opacity` from the value of `progress`
    in the `css` function, like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`css`函数中从`progress`的值推导出`opacity`的值，如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Applying the transition in the preceding code will give you an element that
    fades from transparent to visible when inserted into the DOM and fades back to
    transparent when removed from the DOM.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中应用过渡将使元素在插入DOM时从透明渐变到可见，并在从DOM中移除时渐变回透明。
- en: 'Let us take another example. Let us create a transition that flies the element
    from the right to its final position. Here, the translation of the element changes
    throughout the transition, and we can use `progress` to calculate the translation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子。让我们创建一个将元素从右侧飞到最终位置的过渡效果。在这里，元素的平移在整个过渡过程中发生变化，我们可以使用`progress`来计算平移：
- en: When the element is out of view (value of `progress` is `0`), we want the element
    to be on the right (value of `translateX` is `100px`)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素不可见（`progress`的值为`0`）时，我们希望元素位于右侧（`translateX`的值为`100px`）
- en: When the element is in view (value of `progress` is `1`), we want the element
    to be at its final position (value of `translateX` is `0px`)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素可见（`progress`的值为`1`）时，我们希望元素处于其最终位置（`translateX`的值为`0px`）
- en: 'Here’s a diagram depicting the relationship between `progress` and `translateX`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个描述`progress`与`translateX`之间关系的图表：
- en: 'igure 14.2: Relationship between progress and translateX'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：进度与translateX的关系
- en: 'Unlike the previous example, the value of `translateX` is the inverse of `progress`:
    when `progress` is `0`, `translateX` has a nonzero value; when `progress` is 1,
    `translateX` becomes `0`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子不同，`translateX`的值是`progress`的倒数：当`progress`为`0`时，`translateX`有一个非零值；当`progress`为`1`时，`translateX`变为`0`。
- en: 'So, to calculate the `translateX` value, we use `1 – progress` times a value,
    as you can see in the following code snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了计算`translateX`的值，我们使用`1 – progress`乘以一个值，如以下代码片段所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When applying the `customTransition` function in the preceding code snippet
    to an element, as the element is added to the DOM, the element will fly in from
    the right to its final position. And because calculating the inverse of `progress`
    (`1 – progress`) is so commonly done, the value is provided as a second argument
    of the `css` function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用前面的代码片段中的 `customTransition` 函数到元素上时，随着元素被添加到 DOM 中，该元素将从右侧飞入其最终位置。并且由于计算
    `progress` 的倒数（`1 – progress`）是如此常见，这个值被作为 `css` 函数的第二个参数提供。
- en: 'So, here is our custom transition again, but using the second argument instead
    to calculate the translation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里再次是我们的自定义转换，但这次使用第二个参数来计算平移：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `css` function returns a CSS string that can consist of multiple CSS declarations.
    You separate each CSS declaration with a semicolon, just as you would in a `style`
    attribute of an element. For example, let’s create a transition that combines
    fading in and translating from the right simultaneously:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`css` 函数返回一个可以包含多个 CSS 声明的 CSS 字符串。你用分号分隔每个 CSS 声明，就像在元素的 `style` 属性中做的那样。例如，让我们创建一个同时实现淡入和从右侧平移的转换：'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code snippet, we combine both fading in and translating from
    the right simultaneously. The returned CSS string contains multiple CSS declarations
    separated by semicolons, one for `opacity` and another for `transform`, that will
    be applied during the transition.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们同时实现了淡入和从右侧平移。返回的 CSS 字符串包含多个用分号分隔的 CSS 声明，一个用于 `opacity`，另一个用于
    `transform`，这些声明将在转换期间应用。
- en: Now that we have covered the `css` function, let us look at the `tick` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 `css` 函数，让我们来看看 `tick` 函数。
- en: The tick function
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`tick` 函数'
- en: The `tick` function serves as an alternative to the `css` function for creating
    custom transitions. Unlike the `css` function, which is used to generate CSS `@keyframe`
    rules for the animation, the `tick` function allows you to animate a transition
    using JavaScript. This can provide more fine-grained control over the transition,
    enabling the creation of more complex animations that may not be easily achieved
    with CSS alone.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`tick` 函数是创建自定义转换的 `css` 函数的替代品。与用于生成动画 CSS `@keyframe` 规则的 `css` 函数不同，`tick`
    函数允许你使用 JavaScript 动画化转换。这可以提供对转换的更精细控制，从而创建出仅使用 CSS 难以实现的更复杂的动画。'
- en: 'The `tick` function is called repeatedly during the transition through `requestAnimationFrame`.
    Similar to the `css` function, the `tick` function accepts two parameters: `progress`
    and `remaining`. The `progress` parameter is a value between `0` and `1`, where
    `0` represents the element being out of view, and 1 represents the element being
    in its final position on the screen, while the `remaining` parameter is equal
    to `1 – progress`. These parameters can be used to modify the DOM element the
    transition is applied to, based on the current progress of the transition.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`tick` 函数在通过 `requestAnimationFrame` 进行转换期间被反复调用。与 `css` 函数类似，`tick` 函数接受两个参数：`progress`
    和 `remaining`。`progress` 参数是一个介于 `0` 和 `1` 之间的值，其中 `0` 表示元素处于不可见状态，而 `1` 表示元素位于屏幕上的最终位置，而
    `remaining` 参数等于 `1 – progress`。这些参数可以根据转换的当前进度修改应用到的 DOM 元素。'
- en: 'For example, if we want to create a fade-in transition using the `tick` function,
    you can update the element’s opacity based on the progress value, as illustrated
    here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想使用 `tick` 函数创建淡入转换，可以根据进度值更新元素的透明度，如下所示：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Based on the preceding code snippet, Svelte triggers the `tick` function during
    every animation frame throughout the transition.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码片段，Svelte 在转换过程中的每一帧都会触发 `tick` 函数。
- en: When the element starts to appear, the `progress` value is `0`, and we use this
    `progress` value to set the initial `opacity` value of the element to `0`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素开始出现时，`progress` 值为 `0`，我们使用这个 `progress` 值将元素的初始 `opacity` 值设置为 `0`。
- en: As the transition continues, the `tick` function is called with `progress` values
    between `0` and `1`, and we update the element’s `opacity` value based on the
    `progress` value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随着转换的进行，`tick` 函数会使用介于 `0` 和 `1` 之间的 `progress` 值被调用，并且我们会根据 `progress` 值更新元素的
    `opacity` 值。
- en: At the end of the transition, the `tick` function is called one last time with
    a `progress` value of 1\. At this point, we set the element’s `opacity` value
    to its final value of 1.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换结束时，`tick` 函数最后一次使用 `progress` 值为 `1` 被调用。此时，我们将元素的 `opacity` 值设置为最终的 `1`。
- en: The `tick` function in the preceding code snippet operates similarly to the
    custom fade-in transition we created using the `css` function. Both approaches
    modify the element’s `opacity` value throughout the transition. The key difference
    lies in how they are executed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段中的`tick`函数与使用`css`函数创建的自定义淡入过渡操作类似。两种方法都在整个过渡过程中修改元素的`opacity`值。关键区别在于它们的执行方式。
- en: Svelte calls the `css` function multiple times with different progress values
    at the beginning of the transition to construct the CSS `@keyframe` rules. Once
    this is done, the `css` function is not called again during the transition. The
    newly created CSS `@keyframe` rule is then applied to the element through the
    CSS `animation` property. The element’s `opacity` value is then updated through
    CSS.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte在过渡开始时多次调用`css`函数，并使用不同的进度值来构建CSS的`@keyframe`规则。一旦完成，`css`函数在过渡期间不再被调用。新创建的CSS`@keyframe`规则随后通过CSS的`animation`属性应用于元素。然后通过CSS更新元素的`opacity`值。
- en: On the other hand, the `tick` function is called multiple times by Svelte during
    each animation frame throughout the transition. On every tick call, the element’s
    `opacity` value is modified by JavaScript.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`tick`函数在过渡的每个动画帧中由Svelte多次调用。在每次`tick`调用中，元素的`opacity`值通过JavaScript进行修改。
- en: Now that we have learned about the transition contract, let us use this knowledge
    to create a few more custom transitions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了过渡合约，让我们利用这些知识来创建更多自定义过渡。
- en: Writing a custom CSS transition using the css function
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`css`函数编写自定义CSS过渡
- en: The first custom transition we will be attempting to write together is an effect
    often witnessed in presentations, commonly referred to as the “color swipe.” This
    effect stands out due to its dynamic sweep of color that flows across the screen,
    creating a sense of energy that captivates the viewer’s attention.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要一起尝试编写的第一个自定义过渡是一种在演示中经常看到的效果，通常被称为“颜色滑动”。这种效果因其动态的颜色扫动而突出，这种扫动在屏幕上流动，创造出一种吸引观众注意力的能量感。
- en: The color swipe transition, as its name suggests, involves a sweeping change
    in color that takes place over an object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，颜色滑动过渡涉及在对象上发生的颜色扫动变化。
- en: 'Picture this: you’re looking at a static screen, possibly a section of a website.
    Suddenly, a new color begins to surface from one edge of the screen. Like a wave,
    this color spreads across the screen, enveloping it. As soon as the color completely
    covers the screen, it starts to recede from the edge of origin, revealing new
    content. When the color entirely withdraws, the new content is fully unveiled:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：你正在查看一个静态屏幕，可能是网站的一部分。突然，一种新颜色从屏幕的一边开始显现。就像波浪一样，这种颜色在屏幕上扩散，包围了整个屏幕。一旦颜色完全覆盖了屏幕，它开始从起始边缘退去，揭示新的内容。当颜色完全消失后，新的内容完全展现出来：
- en: 'igure 14.3: The color swipe transition'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：颜色滑动过渡
- en: The *swipe* can move in from any direction—it can move horizontally from left
    to right, vertically from top to bottom, or even diagonally.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*滑动*可以从任何方向移动——它可以水平地从左到右移动，垂直地从上到下移动，甚至可以斜向移动。'
- en: We are going to modify the color swipe transition to apply to paragraph (`<p>`)
    elements. When a `<p>` element is added to the DOM, a wave of color will sweep
    over it, unveiling the text within the `<p>` element upon completion of the transition.
    When the `<p>` element is removed from the DOM, the reverse of the transition
    is played, concealing the text upon completion of the transition.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改颜色滑动过渡，使其应用于段落（`<p>`）元素。当`<p>`元素被添加到DOM中时，一道颜色波将扫过它，在过渡完成后揭示`<p>`元素内的文本。当`<p>`元素从DOM中移除时，过渡将反向播放，在过渡完成后隐藏文本。
- en: 'A visualization of the transition can be seen here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡的视觉演示可以在这里看到：
- en: 'igure 14.4: The color swipe transition on paragraphs'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：段落上的颜色滑动过渡
- en: In this section, we will walk through step by step how to create this captivating
    color swipe transition using Svelte.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步介绍如何使用Svelte创建这种迷人的颜色滑动过渡。
- en: Since the transition that conceals the text when the `<p>` element is being
    removed from the DOM is the same as the transition that reveals the text when
    the `<p>` element is being added but played backward, we will focus on the transition
    played when a `<p>` element is added to the DOM. This is because when a transition
    is applied to an element, Svelte will play the same transition when the element
    is removed, but in reverse. Therefore, by focusing on the transition played when
    an element is added to the DOM, we effectively cover both scenarios.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当`<p>`元素从DOM中移除时隐藏文本的过渡与当`<p>`元素被添加时显示文本的过渡相同，但播放方向相反，因此我们将关注当`<p>`元素被添加到DOM时播放的过渡。这是因为当过渡应用于一个元素时，Svelte会在元素被移除时播放相同的过渡，但方向相反。因此，通过关注元素被添加到DOM时播放的过渡，我们实际上覆盖了两种情况。
- en: So, let us get started on creating a transition.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始创建一个过渡。
- en: 'Firstly, let us create the structure of our custom transition. Recall the transition
    contract—a transition is a function that returns an object describing the transition:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们自定义过渡的结构。回想一下过渡合约——一个过渡是一个返回描述过渡的对象的函数：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code snippet, we create a `colourSwipe` transition and apply
    it to the `<p>` element. Our current task is to implement the `colourSwipe` transition
    by populating the `config` object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个`colourSwipe`过渡并将其应用于`<p>`元素。我们当前的任务是实现`colourSwipe`过渡，通过填充`config`对象来完成。
- en: 'The first two fields that we are going to add to the `config` object are `duration`
    and `delay`. As shown in the following code snippet, we set the duration of the
    transition to 1 second, and the transition will have no delay to start:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加到`config`对象的前两个字段是`duration`和`delay`。如以下代码片段所示，我们将过渡的持续时间设置为1秒，并且过渡将没有延迟开始：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However, often when creating a custom transition, you may want to allow the
    user of the transition to customize the duration and delay based on where the
    transition is being applied.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在创建自定义过渡时，通常你可能希望允许过渡的使用者根据过渡应用的位置来自定义持续时间和延迟。
- en: 'For example, a user of the transition may want to have a delay of 200 milliseconds
    and a duration of 2 seconds by specifying them in the `transition:` directive,
    as shown in the following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个过渡的使用者可能希望通过在`transition:`指令中指定它们来有一个200毫秒的延迟和2秒的持续时间，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These custom delays and durations specified in the `transition:` directive
    will be passed into the `colourSwipe` transition as the second argument, which
    will use them in the `config` object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`transition:`指令中指定的这些自定义延迟和持续时间将作为第二个参数传递给`colourSwipe`过渡，它将在`config`对象中使用它们：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code snippet, we use the values of `params.duration` and `params.delay`
    in the `config` object and provide a default value when these parameters aren’t
    explicitly stated.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`config`对象中的`params.duration`和`params.delay`的值，并在这些参数没有明确指定时提供默认值。
- en: Now that we have specified the `delay` and the `duration` fields of the transition,
    let’s turn our attention to the next field—`easing`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经指定了过渡的`delay`和`duration`字段，让我们将注意力转向下一个字段——`easing`。
- en: 'We are going to use a `linear` easing, making the transition move at a constant
    speed, without any acceleration or deceleration. As we did with `duration` or
    `delay`, we are going to make `easing` customizable by the user. So, in the following
    code snippet, we set the value of `easing` based on the user-specified easing.
    If it is left unspecified, we fall back on our default easing—`linear` easing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`linear`（线性）缓动，使过渡以恒定速度移动，没有任何加速或减速。就像我们对`duration`或`delay`所做的那样，我们将使`easing`可由用户自定义。因此，在以下代码片段中，我们根据用户指定的缓动设置`easing`的值。如果它被省略，我们将回退到我们的默认缓动——`linear`缓动：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Typically, in the process of creating a custom transition, the `duration`, `delay`,
    and `easing` fields are the simplest to set up. More often than not, we determine
    default `duration`, `delay`, and `easing` values, and then offer the user the
    flexibility to tweak these to their liking.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在创建自定义过渡的过程中，`duration`（持续时间）、`delay`（延迟）和`easing`（缓动函数）字段是最容易设置的。大多数情况下，我们会确定默认的`duration`、`delay`和`easing`值，然后允许用户根据自己的喜好调整这些值。
- en: 'Having figured out the `duration`, `delay`, and `easing` values, we now delve
    into the crux of the transition: coming up with the CSS for the transitioning
    element.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了`duration`、`delay`和`easing`值之后，我们现在深入过渡的核心：为过渡元素编写CSS。
- en: 'If you observe the transition carefully, you will notice that the transition
    can be divided into two distinct stages: the initial half involves the color block
    expanding to envelop the entire `<p>` element, and the latter half corresponds
    to the color block retracting to unveil the text within the `<``p>` element:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察过渡，你会注意到过渡可以分为两个不同的阶段：前半部分涉及颜色块扩展以包围整个`<p>`元素，而后半部分则对应颜色块收缩以揭示`<p>`元素内的文本：
- en: 'igure 14.5: The color swipe transition split into two halves, separated by
    dotted lines'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：颜色滑动过渡分为两个部分，由虚线分隔
- en: Let’s explore how we can create these CSS rules to effectively bring to life
    these stages of the transition.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何创建这些CSS规则，以有效地实现过渡的各个阶段。
- en: 'Before we start, let us create a `css` function in our `colourSwipe` transition:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们在我们的`colourSwipe`过渡中创建一个`css`函数：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are going to fill in the `css` function in the preceding code snippet.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在前面的代码片段中填充`css`函数。
- en: It’s key to note that the `progress` value begins at `0` at the start of the
    transition and goes to 1 at the end of the transition. As we are splitting the
    transition into two stages, the first stage will see the `progress` value moving
    from `0` to `0.5`, while the second stage advances from `0.5` to `1`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的关键点是，`progress`值在过渡开始时从`0`开始，并在过渡结束时达到`1`。由于我们将过渡分为两个阶段，第一阶段将看到`progress`值从`0`移动到`0.5`，而第二阶段则从`0.5`推进到`1`。
- en: 'Hence, in our `css` function, we will implement different CSS rules for different
    stages of the transition:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的`css`函数中，我们将为过渡的不同阶段实现不同的CSS规则：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code snippet, you can see that we have added an `if` block
    in the `css` function, which uses the `progress` value to determine which sets
    of CSS rules to apply. For the first half of the transition (`progress` <= 0.5),
    the first set of CSS rules is implemented. For the latter half (`progress` > 0.5),
    the second set of rules is used. This way, we can customize the element’s appearance
    in distinct ways throughout the two stages of the transition.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到我们在`css`函数中添加了一个`if`块，该块使用`progress`值来确定要应用哪些CSS规则集。对于过渡的前半部分（`progress`
    <= 0.5），实现了第一组CSS规则。对于后半部分（`progress` > 0.5），使用第二组规则。这样，我们可以在过渡的两个阶段以不同的方式定制元素的外观。
- en: In the first half of our transition, we need to create a growing color block.
    To create this, we will apply a linear gradient on the background of the element.
    The gradient will transition from a solid color to a transparent color. By aligning
    the color stop point of the solid color and the transparent color at the same
    location, we can create a sharp hard line in the gradient transition.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的过渡的前半部分，我们需要创建一个增长的颜色块。为了创建这个，我们将在元素的背景上应用一个线性渐变。渐变将从实心颜色过渡到透明颜色。通过将实心颜色和透明颜色的颜色停止点对齐在相同的位置，我们可以在渐变过渡中创建一个尖锐的硬线。
- en: 'For example, if we want a solid red color block that occupies the left 25%
    of an element, we could apply the following CSS:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要一个占据元素左侧25%的实心红色颜色块，我们可以应用以下CSS：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding snippet, we have a linear gradient moving from left to right,
    with the red and transparent colors sharing the same color stops at the 25% point.
    This creates a solid red block on the leftmost 25% of the gradient, while the
    remaining 75% is transparent.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有一个从左到右移动的线性渐变，红色和透明颜色在25%的位置共享相同的颜色停止点。这就在渐变的左侧25%处创建了一个实心红色块，而剩余的75%是透明的。
- en: Our choice to use a linear gradient to achieve this color block, as opposed
    to superimposing another element, shows the simplicity of this approach. It eliminates
    the necessity of creating an additional element.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用线性渐变来实现这个颜色块，而不是叠加另一个元素，这显示了这种方法的高效性。它消除了创建额外元素的需要。
- en: Another benefit of setting a linear gradient on the background, instead of resizing
    the element, is to have a resizing color block effect without actually resizing
    an element, which would cause re-layout and layout shifts in the DOM. This way,
    the element with the applied CSS remains static in its original position and size
    throughout the transition.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在背景上设置线性渐变而不是调整元素大小的好处是，可以在不实际调整元素大小的情况下产生调整颜色块的效果，这避免了在DOM中引起重新布局和布局偏移。这样，应用了CSS的元素在整个过渡过程中保持在其原始位置和大小不变。
- en: So, now we’ve figured out the CSS to use, let’s incorporate it into our transition’s
    `css` function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经确定了要使用的CSS，让我们将其纳入我们过渡的`css`函数中。
- en: Before that, we need to do some math. We intend to use the value of `progress`
    to calculate the percentage of the element to be covered by the solid color block.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们需要做一些数学计算。我们打算使用 `progress` 的值来计算实色块应覆盖的元素百分比。
- en: In the first half of the transition, the value of `progress` goes from `0` to
    `0.5`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡的第一半中，`progress` 的值从 `0` 到 `0.5`。
- en: Within this phase of the transition, the percentage of the element that needs
    to be covered should range from 0% to 100%.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过渡阶段，需要覆盖的元素百分比应从 0% 到 100%。
- en: 'Consequently, by performing arithmetic calculations, we can conclude that the
    percentage value is 200 times the value of `progress`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过进行算术计算，我们可以得出结论，百分比值是 `progress` 值的 200 倍：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s now integrate this into our `css` function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将这个整合到我们的 `css` 函数中：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code snippet, we use the calculated percentage to control the
    size of the solid color block, making it grow from the left from 0% to 100% through
    the first half of the transition.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用计算出的百分比来控制实色块的大小，使其在过渡的第一半中从左侧的 0% 增长到 100%。
- en: Now, let’s turn our attention to the second half of the transition, where the
    solid color block contracts from full width toward the right edge of the element.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向过渡的第二部分，其中实色块从元素的全宽向右边缘收缩。
- en: An alternate way to envision this is by considering the expansion of the transparent
    portion from the left edge, covering from 0% to 100% of the element. This mirrors
    the first half of the transition, with the key difference being that it’s now
    the transparent color, not the solid one, that grows to fully envelop the element.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种设想这个问题的方法是考虑从左侧边缘开始的透明部分的扩展，覆盖从 0% 到 100% 的元素。这反映了过渡的第一半，关键区别在于现在增长到完全包围元素的是透明颜色，而不是实色。
- en: 'The formula for calculating the `percentage` value remains the same, but since
    the `progress` value now ranges from `0.5` to `1`, we need to subtract `0.5` from
    the `progress` value before multiplying it by 200\. So, the equation becomes this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 计算百分比值的公式保持不变，但由于 `progress` 值现在从 `0.5` 到 `1` 变化，我们需要在将其乘以 200 之前从 `progress`
    值中减去 `0.5`。因此，方程变为这个：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this modification, our `css` function now becomes this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修改，我们的 `css` 函数现在变成这样：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this updated function, the solid color block and transparent areas dynamically
    resize according to the calculated percentage during the transition, effectively
    creating the visual illusion of a color swipe.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的函数中，实色块和透明区域在过渡过程中根据计算出的百分比动态调整大小，有效地创造出颜色滑动的视觉错觉。
- en: Applying the transition to an element now, you might notice that although we
    have a functional solid color swipe transition effect, there are a few elements
    that could be refined for a smoother visual experience.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将过渡应用到元素上时，你可能会注意到，尽管我们有一个功能性的实色滑动过渡效果，但有一些元素可以进一步优化以获得更平滑的视觉体验。
- en: One prominent aspect is that the text within the element remains visible throughout
    the entire transition. Ideally, it should stay hidden in the first half of the
    transition, when the solid color block is expanding, and only be revealed in the
    second half as the color block shrinks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个突出的问题是，元素内的文本在整个过渡过程中都保持可见。理想情况下，它应该在过渡的第一半中保持隐藏，当实色块扩展时，只有在第二半中颜色块收缩时才被揭示。
- en: 'The following screenshot illustrates this issue:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了这个问题：
- en: 'igure 14.6: The text is not hidden in the first half of the transition'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6：在过渡的第一半中，文本没有隐藏
- en: 'To address this, we can set the text color to transparent during the first
    half of the transition, as shown in the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在过渡的第一半中将文本颜色设置为透明，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Another issue is that the solid color block remains red, regardless of the text
    color. Because we are using the CSS `background` property to create a swipe effect,
    the text remains at the forefront, while the solid color block is in the background.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在文本颜色的情况下，实色块仍然保持红色。因为我们使用 CSS 的 `background` 属性来创建滑动效果，所以文本保持在最前面，而实色块在背景中。
- en: This affects the text-revealing effect from the color block since the full text
    content becomes fully visible in the second half of the transition. If the solid
    color block shared the same color as the text, the text would blend with the background.
    This would create a visual illusion, giving the appearance that the text is being
    revealed as the color block contracts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这影响了从颜色块中揭示文本的效果，因为整个文本内容在过渡的第二半部分完全可见。如果实色块与文本颜色相同，文本就会与背景融合。这将产生一种视觉错觉，给人一种文本随着颜色块收缩而被揭示的印象。
- en: 'The following screenshot illustrates this issue:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图说明了这个问题：
- en: 'igure 14.7: The text and block color do not match'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7：文本和块颜色不匹配
- en: To resolve this, we need to find a way to obtain the color of the text and incorporate
    it into our linear gradient background.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要找到一种方法来获取文本的颜色并将其融入我们的线性渐变背景中。
- en: 'The `window.getComputedStyle()` function allows us to fetch the styles applied
    to an element. We can use this function to get the color of the text at the beginning
    of the transition and use that color for our gradient background:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.getComputedStyle()` 函数允许我们获取应用到元素上的样式。我们可以使用这个函数来获取过渡开始时文本的颜色，并使用这个颜色作为我们的渐变背景：'
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding revised code snippet, we replace `red` with the text color
    we fetched from the `node` element’s computed style.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的修改后的代码片段中，我们将 `red` 替换为从 `node` 元素的计算样式中获取的文本颜色。
- en: And there you have it—a customized color swipe effect, implemented as a Svelte
    transition. The complete code can be found at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14/01-css-transition](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14/01-css-transition).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，我们就得到了一个定制的颜色滑动效果，作为 Svelte 过渡实现。完整的代码可以在 [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14/01-css-transition](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14/01-css-transition)
    找到。
- en: We went step by step through creating a custom Svelte transition using CSS.
    Throughout the process, we learned how to implement user-customizable attributes
    into our transition, such as `duration`, `delay`, and `easing`. In our color swipe
    transition, we learned how to craft a multi-staged transition and how to segment
    the `progress` parameter into various stages, utilize its value to compute the
    CSS rules, and apply it to the element.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一步一步地通过使用 CSS 创建自定义 Svelte 过渡。在整个过程中，我们学习了如何将用户可定制的属性（如 `duration`、`delay`
    和 `easing`）集成到我们的过渡中。在我们的颜色滑动过渡中，我们学习了如何构建多阶段过渡，以及如何将 `progress` 参数分割成各个阶段，利用其值来计算
    CSS 规则，并将其应用到元素上。
- en: Hopefully, you are now equipped to create your own custom Svelte transition
    using CSS.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在已经准备好使用 CSS 创建自己的自定义 Svelte 过渡了。
- en: At the start of this chapter, we learned that a transition contract can include
    not only a `css` function but also a `tick` function. The `tick` function allows
    us to modify elements during the transition. We’ve explored how to use the `css`
    function to create a color swipe transition; in the next section, we’ll delve
    into creating another custom transition, this time using the `tick` function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们了解到过渡合约可以包括不仅是一个 `css` 函数，还可以是一个 `tick` 函数。`tick` 函数允许我们在过渡期间修改元素。我们已经探讨了如何使用
    `css` 函数创建颜色滑动过渡；在下一节中，我们将深入探讨创建另一个自定义过渡，这次使用 `tick` 函数。
- en: Writing a custom JavaScript transition using the tick function
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 tick 函数编写自定义 JavaScript 过渡
- en: The custom transition we will attempt to write in this section is a flipboard
    transition. The transition emulates the mechanics of vintage airport departure
    boards. During this transition, each letter of the text *flips*, cycling through
    characters until it finally lands on the correct one. The transition ends when
    all the letters have settled into the right character.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中尝试编写的自定义过渡是一个翻页过渡。这个过渡模仿了复古机场出发牌的机制。在这个过渡过程中，文本的每个字母都会翻转，循环遍历字符，直到最终落在正确的字母上。当所有字母都稳定在正确的字母上时，过渡结束。
- en: 'The following diagram illustrates how the flipboard transition works to reveal
    the phrase *Hello Svelte*, with the vertical axis representing the flow of time
    from top to bottom:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了翻页过渡如何揭示短语 *Hello Svelte*，其中垂直轴表示从上到下的时间流动：
- en: 'igure 14.8: Flipboard transition visualized'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8：翻页过渡可视化
- en: At the onset of the transition, letters begin to appear from left to right,
    starting as a dash (`-`) and then flipping through random characters before settling
    on the correct one. This flipping motion continues from left to right until all
    letters have aligned with their corresponding characters, unveiling the intended
    phrase.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡开始时，字母从左到右开始出现，最初显示为破折号（`-`），然后通过随机字符翻转，最终定位到正确的字母。这种翻转动作从左到右继续，直到所有字母都与其对应的字符对齐，揭示出预期的短语。
- en: The entire transition process involves modifying characters within the element,
    transitioning from a blank state through jumbled characters, and finally to the
    correct text. Since there are no style or layout changes needed, we are not using
    the `css` function to implement this transition. The `tick` function is the perfect
    candidate to implement this transition in Svelte.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过渡过程涉及修改元素内的字符，从空白状态过渡到混乱的字符，最后过渡到正确的文本。由于不需要样式或布局更改，我们没有使用`css`函数来实现这个过渡。`tick`函数是Svelte中实现这个过渡的完美候选者。
- en: Now that we’ve defined how the flipboard transition would look, let us start
    implementing this transition.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了翻页过渡的外观，让我们开始实现这个过渡。
- en: 'Building on what we learned with the color swipe transition in the previous
    section, the flipboard transition begins in a similar way. Here is the basic code
    structure for our flipboard transition:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在上一节中学习的颜色滑动过渡的基础上，翻页过渡以类似的方式开始。以下是我们的翻页过渡的基本代码结构：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code snippet, we have defined a `flipboard` function that adheres
    to the transition contract. It takes in two arguments, `node` and `params`, and
    returns a transition configuration—an object that describes the transition. As
    such, we are able to apply the `flipboard` function as a transition using the
    `transition:` directive on a `<``div>` element.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个`flipboard`函数，它遵循过渡契约。它接受两个参数，`node`和`params`，并返回一个过渡配置——一个描述过渡的对象。因此，我们能够将`flipboard`函数作为过渡应用于`<div>`元素上的`transition:`指令。
- en: Within the flipboard transition, we’ve set up the basic parameters, such as
    defining the `duration`, `delay`, and `easing` values, while leaving a placeholder
    for the `tick` function, where we will implement the transition.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在翻页过渡中，我们已经设置了基本参数，例如定义`duration`、`delay`和`easing`值，同时为`tick`函数留出一个占位符，我们将在这里实现过渡。
- en: To create a flipboard transition, we start by obtaining the text content of
    the element that will be transitioning. Then, each time the `tick` function is
    called, we determine the text to display based on the `progress` value and update
    the element accordingly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建翻页过渡，我们首先获取将要过渡的元素的文本内容。然后，每次调用`tick`函数时，我们根据`progress`值确定要显示的文本，并相应地更新元素。
- en: 'We can retrieve the text of an element using the following API:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下API检索元素的文本：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, to set the text content of an element, we assign it through the
    same property:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了设置元素的文本内容，我们通过相同的属性赋值：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Incorporating these into the flipboard transition, here’s what we get:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些整合到翻页过渡中，我们得到以下结果：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code snippet, we retrieve the text content of the element at
    the beginning of the `flipboard` function, right before the transition starts
    to play on the element. The `tick` function, called repeatedly on every animation
    frame, computes the new `text` value for the element, based on the original `text`
    value and current `progress` value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在`flipboard`函数开始播放元素上的过渡之前，在元素的开头检索文本内容。`tick`函数在每个动画帧上被反复调用，根据原始`text`值和当前的`progress`值计算元素的新的`text`值。
- en: The `tick` function’s task is to determine how each letter should be displayed,
    based on the `progress` value. Some letters might appear as a dash, some as random
    characters, some as their original value, and others might be hidden.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`tick`函数的任务是根据`progress`值确定每个字母应该如何显示。一些字母可能显示为破折号，一些可能显示为随机字符，一些可能显示为它们的原始值，而其他字母可能被隐藏。'
- en: For each letter, its display depends on its position relative to the full text’s
    length and the current `progress` value. For instance, if a letter is positioned
    at 30% from the left, and the current `progress` value is `0.5` (or 50%), then
    that letter should be displayed as is.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个字母，其显示取决于其在整个文本长度中的位置和当前的`progress`值。例如，如果一个字母位于从左边的30%，而当前的`progress`值是`0.5`（或50%），那么该字母应该按原样显示。
- en: How do we determine these rules? What leads us to the conclusions just drawn?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确定这些规则？是什么让我们得出刚才的结论？
- en: We want the element to reveal all its original characters at the end of the
    transition. This means that when the `progress` value reaches 1 (or 100%), all
    letters should display their original character. At the midpoint, with a `progress`
    value of `0.5` (or 50%), 50% of the letters from the left should show their original
    character, while the remaining 50% on the right should show either a dash, a random
    character, or nothing at all.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望元素在过渡结束时显示其所有原始字符。这意味着当`progress`值达到1（或100%）时，所有字母都应该显示其原始字符。在中间点，当`progress`值为`0.5`（或50%）时，左侧的50%字母应该显示其原始字符，而右侧剩余的50%应该显示破折号、随机字符或根本不显示。
- en: To generalize, if a letter’s position from the left is less than the `progress`
    value, it should display its original character. Otherwise, it may display a dash,
    a random character, or nothing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了概括，如果一个字母的左侧位置小于`progress`值，它应该显示其原始字符。否则，它可能显示破折号、随机字符或根本不显示。
- en: 'The following diagram illustrates how the `progress` value and the displayed
    text are related:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了`progress`值和显示文本之间的关系：
- en: 'igure 14.9: The red box shows which letters are displaying the original character
    at each progress value'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9：红色框显示在各个进度值下哪些字母显示原始字符
- en: The preceding diagram illustrates how the original characters are revealed at
    different values of `progress`. As the `progress` value increases, more letters
    in the word display their original characters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了在不同`progress`值下原始字符的显示方式。随着`progress`值的增加，单词中的更多字母会显示其原始字符。
- en: To implement the flipboard effect just described, we will loop through each
    character, determine its relative position, and then decide whether it should
    be displayed. For characters whose position is beyond the current `progress` value,
    we will display a blank space.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现刚才描述的翻页效果，我们将遍历每个字符，确定其相对位置，然后决定是否显示。对于位置超过当前`progress`值的字符，我们将显示空白空间。
- en: 'Here is the updated code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的代码：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this code, the flipboard transition now either shows the original characters
    or a blank space based on the progress value. When playing the transition, you
    will see the characters appear one by one from left to right.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，翻页过渡现在根据进度值显示原始字符或空白空间。在播放过渡时，你会看到字符一个接一个地从左到右出现。
- en: Having figured out when to show up the original characters, let us continue
    to determine when the text should display dashes or random characters.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了何时显示原始字符之后，让我们继续确定文本何时应该显示破折号或随机字符。
- en: Using a similar idea, we can determine whether a letter should display a random
    character, a dash, or nothing at all. We will introduce a constant number to manage
    the timing of these changes. If the letter’s position is beyond this constant
    multiplied by the `progress` value, it will show up as nothing. I’ve chosen a
    value of 2 for this constant, based on trial and error. It’s a value greater than
    1 but not too large, to create the effect of characters appearing gradually from
    the left.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的想法，我们可以确定一个字母是否应该显示随机字符、破折号或根本不显示。我们将引入一个常数来管理这些变化的时机。如果一个字母的位置超过这个常数乘以`progress`值，它将显示为空白。我根据试错选择了2这个常数，它大于1但不是太大，以创建字符从左到右逐渐出现的效果。
- en: Similarly, we could also introduce another constant to manage the display of
    dashes or random characters. If the letter’s relative position is greater than
    this new constant times the progress value, but less than 2, the letter will appear
    as a dash. Otherwise, it will be a random character. For this purpose, I have
    chosen 1.5, positioning it midway between 1 and 2.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以引入另一个常数来管理破折号或随机字符的显示。如果一个字母的相对位置大于这个新常数乘以进度值，但小于2，该字母将显示为破折号。否则，它将显示为随机字符。为此，我选择了1.5，将其定位在1和2之间。
- en: 'The following diagram visually represents these two constants and their effect
    on the transition:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表直观地表示了这两个常数及其对过渡的影响：
- en: 'igure 14.10: Relationship between the new text and the original text'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10：新文本与原始文本之间的关系
- en: In the preceding diagram, you can observe how the characters change during the
    transition. When the `progress` value is `0.4`, for example, letters at the 40%
    position are showing original characters, letters at 40% - 60% (`progress` * 1.5)
    are showing random characters, letters at 60% - 80% (`progress` * 2) are showing
    dashes, and anything beyond is not shown.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以观察到字符在过渡过程中的变化。例如，当 `progress` 值为 `0.4` 时，位于 40% 位置的字母显示原始字符，位于 40%
    - 60%（`progress` * 1.5）的字母显示随机字符，位于 60% - 80%（`progress` * 2）的字母显示破折号，而超出这个范围的则不显示。
- en: 'Here’s how the updated code for our flipboard transition looks:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的翻页过渡效果的更新代码：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code snippet, I’ve added two additional conditions to determine
    when to display dashes or random characters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我添加了两个额外的条件来确定何时显示破折号或随机字符。
- en: 'The `randomCharacter()` function returns a randomly selected character, implemented
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`randomCharacter()` 函数返回一个随机选择的字符，实现方式如下：'
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this code, you have a flipboard transition! Try it out with an element
    and observe the effect. The characters slowly appear one by one from left to right,
    starting as a dash, flipping through characters, and finally settling with the
    correct character.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，你就有了一个翻页过渡！尝试将其应用于一个元素，并观察效果。字符会一个接一个地从左到右缓慢出现，最初是破折号，然后翻转通过字符，最终稳定在正确的字符上。
- en: 'You may notice one small issue: not all characters are the same width, so the
    overall width of the text grows and shrinks. Since each letter is not aligned
    with its previous position, the flipping effect may not be immediately obvious.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到一个小问题：不是所有字符的宽度都相同，因此文本的整体宽度会随之增长和缩小。由于每个字母都没有与它之前的位置对齐，翻转效果可能不会立即明显。
- en: To fix this, you can use a monospace font. Monospace fonts, also known as fixed-width
    fonts, ensure that each letter occupies the same horizontal space. Applying a
    monospace font to an element enhances the flipping effect, making it more visually
    distinct.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以使用等宽字体。等宽字体，也称为固定宽度字体，确保每个字母占据相同的水平空间。将等宽字体应用于元素可以增强翻转效果，使其更加视觉上突出。
- en: 'For example, you can set the font as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以设置字体如下：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this section, we’ve explored how to create a flipboard transition, emulating
    the appearance of vintage airport departure boards. We’ve learned how to control
    the appearance of characters based on the progress of the transition, using random
    characters, dashes, and original text. And through modifying the text of an element,
    we created a transition that is visually engaging.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何创建翻页过渡，模拟了复古机场出发牌的外观。我们学习了如何根据过渡的进度来控制字符的显示，使用随机字符、破折号和原始文本。通过修改元素的文本，我们创建了一个视觉上吸引人的过渡。
- en: The complete code for this section can be found at here:[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的完整代码可以在以下链接找到：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13)。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored how to create custom transitions in Svelte.
    We went through two detailed examples that utilize the `css` function and the
    `tick` function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在 Svelte 中创建自定义过渡。我们详细介绍了两个示例，这两个示例都使用了 `css` 函数和 `tick` 函数。
- en: Hopefully, you now feel well equipped to write your own custom transition in
    Svelte, enabling you to craft a more engaging and unique user experience in Svelte.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在已经准备好在 Svelte 中编写自己的自定义过渡，从而能够制作出更具吸引力和独特性的用户体验。
- en: In our next and final chapter, we will delve into how transitions can impact
    the accessibility of your Svelte application, guiding you in the creation of an
    engaging and inclusive experience for all users.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的最后一章中，我们将深入探讨过渡如何影响 Svelte 应用的可访问性，指导你创建一个对所有用户都具有吸引力和包容性的体验。
