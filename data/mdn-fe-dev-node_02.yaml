- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Dividing Code into Modules and Packages
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码划分为模块和包
- en: One of the most important aspects to consider when writing professional software
    is reusability. Reusability means that parts of our code base can be purposed
    to work in several places or under different circumstances. This implies that
    we can actually use existing functionality quite easily.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写专业软件时，考虑最重要的方面之一是复用性。复用性意味着我们的代码库的某些部分可以在多个地方或不同情况下使用。这意味着我们实际上可以非常容易地使用现有的功能。
- en: As we learned, a key part of the Node.js success story is down to the fact that
    it comes with a module system. So far, we’ve only touched upon the basic concept
    of CommonJS, which is the default way of importing and exporting functionality
    from modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，Node.js 成功故事的关键部分在于它自带了一个模块系统。到目前为止，我们只触及了 CommonJS 的基本概念，这是从模块中导入和导出功能的方式。
- en: In this chapter, we’ll take the chance to become familiar with more module formats,
    including their history, use cases, and development models. We’ll learn how to
    divide our code into modules and packages efficiently. In addition to learning
    about CommonJS, we will see what a package is and how we can define our own packages.
    All in all, this will help us to achieve great reusability – not only for our
    tooling in Node.js but also for our applications running in the browser.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将有机会熟悉更多模块格式，包括它们的历史、用例和开发模型。我们将学习如何高效地将我们的代码划分为模块和包。除了学习 CommonJS，我们还将了解什么是包以及我们如何定义自己的包。总的来说，这将帮助我们实现高度的复用性——不仅适用于
    Node.js 中的工具，也适用于在浏览器中运行的应用程序。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下关键主题：
- en: Using the ESM standard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ESM 标准
- en: Learning the AMD specification
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 AMD 规范
- en: Being universal with UMD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容 UMD
- en: Understanding SystemJS and import maps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 SystemJS 和导入映射
- en: Knowing the `package.json` fundamentals
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `package.json` 的基础知识
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter02](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter02).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在 [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter02](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter02)
    找到。
- en: The CiA videos for this chapter can be accessed at [http://bit.ly/3FZ6ivk](http://bit.ly/3FZ6ivk).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以通过 [http://bit.ly/3FZ6ivk](http://bit.ly/3FZ6ivk) 访问。
- en: Using the ESM standard
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ESM 标准
- en: CommonJS has been a good solution for Node.js, but not a desirable solution
    for JavaScript as a language. For instance, in the browser, CommonJS does not
    work. Doing synchronous imports on URLs is just not possible. The module resolution
    of CommonJS was also way too flexible in terms of adding extensions and trying
    directories.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 对于 Node.js 来说是一个不错的解决方案，但并不是作为语言而言的期望解决方案。例如，在浏览器中，CommonJS 不起作用。在
    URL 上进行同步导入是不可能的。CommonJS 的模块解析在添加扩展和尝试目录方面也过于灵活。
- en: To standardize modules in JavaScript, the `require`, the whole module system
    relies on language constructs using reserved words. This way, the module system
    can be brought over to the browser, too.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 JavaScript 中标准化模块，`require` 整个模块系统依赖于使用保留字的语言结构。这样，模块系统也可以被带到浏览器中。
- en: 'The ECMAScript standard specified two keywords for this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 标准为此指定了两个关键字：
- en: '`import`: Used to import functionality from other modules'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import`：用于从其他模块导入功能'
- en: '`export`: Used to declare the functionality that can be imported into other
    modules'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export`：用于声明可以被其他模块导入的功能'
- en: The `import` keyword must appear at the beginning of a file – before any other
    code. The reason for this choice lies in the demand for ESM files to be used not
    only within Node.js, but also in the browser. By placing the `import` statements
    on top, each ESM file can safely wait until all the imports have been resolved.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 关键字必须出现在文件的开头——在所有其他代码之前。这种选择的原因在于 ESM 文件的需求，不仅要在 Node.js 中使用，还要在浏览器中使用。通过将
    `import` 语句放在顶部，每个 ESM 文件可以安全地等待所有导入都已解析。'
- en: 'Rewriting the example from the previous chapter, we get the following for `a.js`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一章的示例重写，我们得到以下 `a.js`：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The rewrite of the `b.js` file to be valid per the ESM standard is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 ESM 标准将 `b.js` 文件重写为有效格式如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are multiple possibilities with the `import` keyword. We can use the
    following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 关键字有多种可能性。我们可以使用以下方法：'
- en: Wildcard (using `*`) imports with a name selected by the developer
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由开发者选定的通配符（使用`*`）导入
- en: Named imports such as `myValue`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名导入，例如`myValue`
- en: Default imports with a name selected by the developer
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由开发者选定的具有名称的默认导入
- en: An empty import that does not get anything, but makes sure to run the module
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空的导入，不获取任何内容，但确保运行模块
- en: 'Using a named import, we can get a cleaner version of `a.js`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名导入，我们可以得到`a.js`的一个更干净的版本：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code is very similar to the destructuring assignment, which decomposes
    an object into its fields using the assignment operator (`=`). There are crucial
    differences, however. One of these differences is how to make aliases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与解构赋值非常相似，它使用赋值运算符（`=`）将对象分解为其字段。然而，存在一些关键的区别。其中之一是如何创建别名。
- en: 'For instance, when using a destructuring assignment, we can use the colon (`:`)
    to rename the variables, which would have the name of the respective fields by
    default. If we wanted to give the variable a different name (e.g., `otherValue`)
    from its original field (e.g., `myValue`), we’d have to write the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用解构赋值时，我们可以使用冒号（`:`）来重命名变量，这些变量默认会有相应字段的名称。如果我们想给变量一个不同于其原始字段（例如，`myValue`）的名称（例如，`otherValue`），我们必须编写以下内容：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With an `import` statement, you need to use the `as` keyword to achieve this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`import`语句时，你需要使用`as`关键字来实现这一点：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A topic that becomes relevant quite quickly is the notion of a default export.
    Especially when handling exports from an unknown module, there is a great need
    to define the export name. In CommonJS, developers therefore picked the whole
    module; however, this is no longer possible with ESM. Every export needs to be
    named.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很快就会变得相关的主题是默认导出的概念。特别是在处理未知模块的导出时，定义导出名称的需求非常强烈。因此，在CommonJS中，开发者选择了整个模块；然而，在ESM中这不再可能。每个导出都需要命名。
- en: 'Luckily, the standardization committee thought about the topic of default exports.
    An export is considered to be a default export if it uses the `default` keyword.
    For instance, changing the export in `b.js` to use default values could look as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，标准化委员会考虑了默认导出的主题。如果一个导出使用了`default`关键字，它就被认为是默认导出。例如，将`b.js`中的导出更改为使用默认值可能看起来如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Importing the default export is quite convenient, too. Here, we are free to
    select a name to refer to the default export within our module. Instead of being
    able to rename the import, we are forced to give it a name:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 导入默认导出也非常方便。在这里，我们可以在我们的模块内部自由选择一个名称来引用默认导出。而不是能够重命名导入，我们被迫给它一个名称：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The whole idea is to use default exports as much as possible. In the end, modules
    that are effectively written to revolve around exporting a single functionality
    are often considered the goal.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 整个想法是尽可能多地使用默认导出。最终，那些有效编写且围绕导出单个功能构建的模块通常被认为是目标。
- en: We’ve already learned that CommonJS does not work in the browser. In contrast,
    the modern ESM specification is supposed to work, as imports are declared in the
    beginning. This modification allows the browser to safely suspend module evaluation
    until the imports are fully processed. This kind of suspension to wait for the
    dependencies to finish loading was actually taken from another attempt at a module
    system called **Asynchronous Module** **Definition** (**AMD**).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到CommonJS在浏览器中不起作用。相比之下，现代ESM规范应该可以工作，因为导入在开始时就已经声明。这种修改允许浏览器在导入完全处理之前安全地挂起模块评估。这种等待依赖项加载完成的挂起实际上是从另一个名为**异步模块定义**（**AMD**）的模块系统尝试中借鉴的。
- en: Learning the AMD specification
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习AMD规范
- en: Before ESM was established, people tried to make modules work in the browser,
    too. One of the earliest attempts was a small library called `<head>` of a document.
    The script would then load and run a defined root module, which would process
    even more modules.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在ESM建立之前，人们也尝试让模块在浏览器中工作。最早的尝试之一是一个名为文档`<head>`的小型库。然后脚本会加载并运行一个定义的根模块，该模块会处理更多的模块。
- en: 'An example website using RequireJS is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RequireJS的一个示例网站如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'RequireJS was born at a time when promises had not yet been established in
    the JavaScript world. Therefore, the module loader was based on the next best
    thing: callbacks. Consequently, a module is loaded by calling a `requirejs` function
    defined by RequireJS. The whole process can then start loading modules asynchronously
    as shown in *Figure 2**.1*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS诞生于JavaScript世界尚未确立promises（承诺）的时期。因此，模块加载器基于下一个最佳选择：回调函数。因此，通过调用由RequireJS定义的`requirejs`函数来加载模块。整个过程可以像*图2.1*所示的那样异步加载模块。
- en: '![Figure 2.1 – Loading modules sequentially vs. asynchronously ](img/Figure_2.1_B18989.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 按顺序加载模块与异步加载模块](img/Figure_2.1_B18989.jpg)'
- en: Figure 2.1 – Loading modules sequentially vs. asynchronously
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 按顺序加载模块与异步加载模块
- en: To achieve asynchronous module loading, the `requirejs` function takes two arguments.
    The first argument is an array with all the dependencies. The second argument
    is a callback that receives the exports of the dependencies and returns the exports
    of the current module.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现异步模块加载，`requirejs`函数接受两个参数。第一个参数是一个包含所有依赖项的数组。第二个参数是一个回调函数，它接收依赖项的导出并返回当前模块的导出。
- en: The whole idea behind RequireJS is very similar to that of ESM today, which
    shifts the two parts (loading the dependencies and the code that uses the dependencies)
    into the same module – but still distinguishes between the `import` statements
    and all the other statements. Here, ESM leverages the fact that it’s actually
    a language construct.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS背后的整个理念与今天的ESM（模块化JavaScript）非常相似，它将两个部分（加载依赖项和使用依赖项的代码）合并到同一个模块中——但仍然区分`import`语句和其他所有语句。在这里，ESM利用了它实际上是一个语言构造的事实。
- en: 'In short, a module that uses RequireJS looks as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用RequireJS的模块看起来如下：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The shape of these modules was not arbitrarily decided. Instead, the RequireJS
    library is merely one implementation of a specification for an asynchronous module
    system. This specification is called AMD.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块的形状并非任意决定。相反，RequireJS库只是异步模块系统规范的一个实现。这个规范被称为AMD。
- en: 'Using AMD, the previous RequireJS-specific example could be rewritten as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AMD（异步模块定义），之前的RequireJS特定示例可以重写如下：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In addition to the two-argument variant of the `define` function, there is also
    a three-argument version, where the first argument helps to name the defined module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`define`函数的双参数版本之外，还有一个三参数版本，其中第一个参数有助于命名定义的模块。
- en: 'An example of the three-argument call to `define` is shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了`define`函数的三参数调用示例：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, the only thing left before we can use AMD universally is to learn how
    we can integrate it into Node.js. First, we need to grab `r.js` from the official
    download page: [https://requirejs.org/docs/download.html#rjs](https://requirejs.org/docs/download.html#rjs).
    Download it via the **Download** button as shown in *Figure 2**.2*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们能够普遍使用AMD之前，只剩下学习如何将其集成到Node.js中。首先，我们需要从官方下载页面获取`r.js`：[https://requirejs.org/docs/download.html#rjs](https://requirejs.org/docs/download.html#rjs)。通过*图2.2*中显示的**下载**按钮下载它：
- en: '![Figure 2.2 – The Download button for r.js on the RequireJS website ](img/Figure_2.2_B18989.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – RequireJS网站上的r.js下载按钮](img/Figure_2.2_B18989.jpg)'
- en: Figure 2.2 – The Download button for r.js on the RequireJS website
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – RequireJS网站上的r.js下载按钮
- en: 'Store the downloaded file in the directory where you have placed the scripts
    to run via `node`. Create a new `a.js` script in the same directory:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载的文件存储在您通过`node`运行脚本的目录中。在同一个目录中创建一个新的`a.js`脚本：
- en: a.js
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: a.js
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code here does not look so different from the CommonJS example. After all,
    only the initialization of the RequireJS loader has been added. The actual content
    of the module is now part of the callback.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码与CommonJS示例看起来并没有太大区别。毕竟，只是添加了RequireJS加载器的初始化。现在，模块的实际内容现在是回调函数的一部分。
- en: 'Let’s see what the transformed `b.js` looks like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看转换后的`b.js`是什么样子：
- en: b.js
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: b.js
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code for `b.js`, again, we have added the same envelope, just
    as in `a.js`. Remember that each module needs to be treated as standalone code.
    While how explicit this is may seem rather redundant, the real advantage becomes
    obvious once it’s used with an unknown number of other modules. In this case,
    we never know what has been loaded or used already. Being independent means being
    predictable in these scenarios.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`b.js`的前面代码中，我们又添加了与`a.js`相同的包装，记住每个模块都需要被视为独立的代码。虽然这样做可能看起来有些冗余，但一旦与未知数量的其他模块一起使用，真正的优势就变得明显。在这种情况下，我们永远不知道已经加载或使用了什么。独立意味着在这些场景中是可预测的。
- en: The problem with the preceding approach is that while this works in Node.js,
    it certainly does not work in the browser. Even though we’ve chosen AMD for this
    specific reason, we failed to make it work in the browser. The problem lies in
    the initial call to `require`, which uses CommonJS to obtain the AMD loader.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法的问题是，尽管它在Node.js中有效，但在浏览器中肯定不起作用。尽管我们选择了AMD，但未能使其在浏览器中工作。问题在于对`require`的初始调用，它使用CommonJS来获取AMD加载器。
- en: To mitigate the problem and use AMD in different JavaScript environments, the
    **Universal Module Definition** (**UMD**) specification was created.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这个问题，并在不同的JavaScript环境中使用AMD，创建了**通用模块定义**（**UMD**）规范。
- en: Being universal with UMD
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UMD实现通用性
- en: 'When the UMD specification was brought up, there was a lot of hype in the community.
    After all, the label *universal* already claims that UMD is the final module system
    – the one to rule them all. It tries to do this by supporting essentially three
    different kinds of JavaScript module formats:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当UMD规范被提出时，社区中有很多炒作。毕竟，标签*通用*已经声称UMD是最终的模块系统——统治所有模块的系统。它试图通过支持本质上三种不同的JavaScript模块格式来实现这一点：
- en: The classic way of doing things without a module system – that is, just by running
    JavaScript using `<script>` tags in the browser
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有模块系统做事的经典方式——也就是说，通过在浏览器中使用`<script>`标签运行JavaScript
- en: The CommonJS format that is used by Node.js
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js使用的CommonJS格式
- en: The previously discussed asynchronously loaded modules from the AMD specification
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前讨论的来自AMD规范的异步加载模块
- en: When you write a JavaScript file with the UMD specification in mind, you essentially
    make sure that every popular JavaScript runtime can read it. For instance, UMD
    works perfectly in Node.js and the browser.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以UMD规范编写JavaScript文件时，你实际上确保了每个流行的JavaScript运行时都可以读取它。例如，UMD在Node.js和浏览器中工作得非常好。
- en: To achieve this universality, UMD makes an educated guess regarding what module
    system can be used and selects it. For example, if a `define` function is detected,
    then AMD might be used. Alternatively, detecting something such as `exports` or
    `module` hints towards CommonJS. If nothing is found, then the assumption is that
    the module runs in the browser without AMD present. In this case, the exports
    of the module would be stored globally.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种通用性，UMD会做出一个关于可以使用哪种模块系统的合理猜测，并选择它。例如，如果检测到`define`函数，那么可能会使用AMD。或者，检测到`exports`或`module`等，则指向CommonJS。如果没有发现任何东西，那么假设该模块在没有AMD的情况下在浏览器中运行。在这种情况下，模块的导出将被存储在全局范围内。
- en: The main target group for UMD is library authors. When you build a library,
    you want it to be useful. Consequently, you’ll also need to make sure that the
    library can be used. By providing your library in the UMD format, you ensure that
    it can be used on pretty much all platforms – in Node.js and the browser.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: UMD的主要目标群体是库作者。当你构建一个库时，你希望它是有用的。因此，你还需要确保库可以被使用。通过以UMD格式提供你的库，你确保它可以在几乎所有平台上使用——在Node.js和浏览器中。
- en: 'So, how would our code from the previous example look if we used UMD as the
    format of choice? Let’s have a look:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们选择UMD作为首选格式，之前的示例代码会是什么样子呢？让我们看看：
- en: a.js
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: a.js
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As before, the preceding code consists of two sections. The first section establishes
    the module system and sets up the callback. The second section puts the actual
    content of our module into the callback.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，前面的代码由两部分组成。第一部分建立模块系统并设置回调。第二部分将我们模块的实际内容放入回调中。
- en: 'The only thing left is to see how we can mark our exports with UMD. For this
    part, we will look at `b.js` in the UMD format:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是看看我们如何用UMD标记我们的导出。对于这部分，我们将查看UMD格式的`b.js`：
- en: b.js
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: b.js
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With all the boilerplate code in place, the script is universal. The defined
    callback (named `factory` in the two examples in this section) is either called
    indirectly from the AMD runtime or directly in the other two cases.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有样板代码就绪后，脚本就变得通用。定义的回调（在本节两个示例中命名为`factory`）要么由AMD运行时间接调用，要么在其他两种情况下直接调用。
- en: Usually, we will not write the whole boilerplate code shown here ourselves.
    The boilerplate will be generated by tooling, which we will look into in [*Chapter
    6*](B18989_06.xhtml#_idTextAnchor057), *Building Web Apps with Bundlers*. Instead,
    the ideal option for writing modules in many cases is ESM. Since it’s syntax-based,
    we follow the language’s standard. The other formats can then be used by our tooling
    as output formats.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会自己编写这里显示的整个样板代码。样板代码将由工具生成，我们将在[*第6章*](B18989_06.xhtml#_idTextAnchor057)，“使用打包器构建Web应用”中探讨这一点。但在许多情况下，编写模块的理想选择是ESM。由于它是基于语法的，我们遵循语言的标准。其他格式然后可以作为输出格式由我们的工具使用。
- en: One more module format to have a closer look at is SystemJS. One of the reasons
    why SystemJS is interesting is that it brings support for import maps, which can
    simplify dealing with module systems.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要更仔细查看的模块格式是SystemJS。SystemJS有趣的一个原因是它带来了对导入映射的支持，这可以简化处理模块系统。
- en: Understanding SystemJS and import maps
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SystemJS和导入映射
- en: Earlier in this chapter, we learned that ESM is arguably the best module system
    for JavaScript. After all, it is integrated into the JavaScript language. One
    of the reasons why other formats are still relevant today is backward compatibility.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们了解到ESM可能是JavaScript最好的模块系统。毕竟，它是集成到JavaScript语言中的。其他格式今天仍然相关的一个原因之一是向后兼容性。
- en: Backward compatibility allows formats such as AMD or UMD to be used in older
    JavaScript runtimes, such as older versions of browsers such as Internet Explorer,
    but even if we don’t need backward compatibility, the alternative formats still
    have one or more advantages over ESM.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 向后兼容性允许像AMD或UMD这样的格式在较老的JavaScript运行时中使用，例如较老的浏览器版本，如Internet Explorer，即使我们不需要向后兼容性，这些替代格式仍然比ESM具有一个或多个优势。
- en: One of the core problems with ESM is that it does not define how modules are
    resolved. In fact, the only specified way to resolve a module is explicitly via
    the filesystem. When we used ESM, we explicitly stated our module imports, such
    as in `./b.js`. As mentioned, we are not allowed to implicitly use something such
    as `./b` or even just `b`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ESM（模块系统）的一个核心问题在于它没有定义模块是如何被解析的。实际上，解析模块的唯一指定方式是通过文件系统显式进行。当我们使用ESM时，我们会显式地声明我们的模块导入，例如在`./b.js`中。正如提到的，我们不允许隐式地使用像`./b`或仅仅是`b`这样的东西。
- en: When doing frontend development, the notion of dependencies has become quite
    elementary. From boilerplate libraries to UI frameworks, frontend developers make
    use of a wide array of given code. That code is usually packaged into libraries
    and then installed locally for development purposes, but how should these dependencies
    be used?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在做前端开发时，依赖性的概念已经变得相当基础。从样板库到UI框架，前端开发者使用大量现成的代码。这些代码通常被打包成库，然后为了开发目的在本地安装，但应该如何使用这些依赖项呢？
- en: 'Turns out that Node.js solved this problem already in the early stages of its
    development. We have seen that using CommonJS we are able to write code such as
    the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Node.js在其开发的早期阶段就已经解决了这个问题。我们已经看到，使用CommonJS，我们可以编写如下代码：
- en: host-cjs.js
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: host-cjs.js
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The reference to `os` is resolved by Node.js through CommonJS. In this special
    case, the reference leads to one framework library of Node.js. However, it could
    also lead to a third-party dependency that has been installed by us. In [*Chapter
    3*](B18989_03.xhtml#_idTextAnchor033), *Choosing a Package Manager*, we will see
    how this works.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`的引用是通过Node.js通过CommonJS解析的。在这个特殊情况下，引用指向Node.js的一个框架库。然而，它也可能指向我们安装的第三方依赖。在[*第3章*](B18989_03.xhtml#_idTextAnchor033)，“选择包管理器”中，我们将看到这是如何工作的。'
- en: 'Let’s translate the preceding code into ESM:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的代码翻译成ESM：
- en: host-esm.js
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: host-esm.js
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The conversion of the little snippet is not very complicated, with the exception
    of the module name. Previously, we used `os` as an identifier. Node.js has chosen
    to also allow this for backward compatibility – at least for now. The preferred
    way, however, is to use a custom protocol. In the case of Node.js framework libraries,
    the `node:` protocol has been chosen.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 转换这个小片段并不复杂，除了模块名称。之前，我们使用`os`作为标识符。Node.js选择为了向后兼容也允许这样做——至少目前是这样。然而，首选的方式是使用自定义协议。在Node.js框架库的情况下，已经选择了`node:`协议。
- en: Leveraging custom protocols to resolve dependencies is possible in the browser.
    However, it is also cumbersome. After all, the whole resolution would now need
    to be done by us. This also represents a classic chicken-egg problem. To define
    custom protocols, we need to have some JavaScript running; however, if this piece
    of JavaScript relies on third-party dependencies that are actually resolved via
    the custom protocol, then we cannot successfully implement the resolution of dependencies.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中利用自定义协议解析依赖项是可能的。然而，这也相当繁琐。毕竟，整个解析现在需要我们来做。这也代表了一个经典的“先有鸡还是先有蛋”的问题。要定义自定义协议，我们需要运行一些JavaScript；然而，如果这段JavaScript依赖于通过自定义协议实际解析的第三方依赖项，那么我们就无法成功实现依赖项的解析。
- en: One way that we can still use convenient references such as `os` is to define
    a so-called import map. An import map helps the browser map module names to actual
    URLs. It uses `imports` field.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用像`os`这样的方便引用的一种方法是为所谓的导入映射定义。导入映射帮助浏览器将模块名称映射到实际的URL。它使用`imports`字段。
- en: 'The following is an import map to find an implementation of the `os` module:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个导入映射，用于查找`os`模块的实现：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The URLs don’t have to be fully qualified. In the case of relative URLs, the
    module’s URL is computed from the base URL of the import map.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: URL不需要完全限定。在相对URL的情况下，模块的URL是从导入映射的基本URL计算得出的。
- en: 'The integration of import maps into a website is relatively simple. All we
    need to do is to specify a `<script>` tag with the type being `importmap`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将导入映射集成到网站中相对简单。我们只需要指定一个类型为`importmap`的`<script>`标签：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In addition, import maps may be loaded from external files, too. In any case,
    the specified mapping of module names to URLs only works for `import` statements.
    It will not work in other places where a URL is expected. For instance, the following
    example does not work:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，导入映射也可以从外部文件加载。无论如何，指定的模块名称到URL的映射仅适用于`import`语句。在其他需要URL的地方它将不起作用。例如，以下示例不起作用：
- en: fail.html
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: fail.html
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we have tried to load `/app.mjs` directly, which will
    fail. We need to use an `import` statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们尝试直接加载`/app.mjs`，这将失败。我们需要使用一个`import`语句：
- en: success.html
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: success.html
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There is a lot more that can be written about import maps; however, for now,
    the most important detail is that they only work partially – that is, without
    external files, in recent versions of *Google Chrome* (*89* and higher) and *Microsoft
    Edge* (*89* and higher). In most other browsers, the import map support is either
    not there or must explicitly be enabled.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导入映射可以写很多内容；然而，目前最重要的细节是它们只部分工作——也就是说，在没有外部文件的情况下，在最新版本的*Google Chrome*（*89*及以上）和*Microsoft
    Edge*（*89*及以上）中。在大多数其他浏览器中，导入映射的支持要么不存在，或者必须显式启用。
- en: The alternative is to use SystemJS. SystemJS is a module loader similar to RequireJS.
    The main difference is that SystemJS provides support for multiple module systems
    and module system capabilities, such as using import maps.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用SystemJS。SystemJS是一个类似于RequireJS的模块加载器。主要区别在于SystemJS提供了对多个模块系统和模块系统功能的支持，例如使用导入映射。
- en: 'While SystemJS also supports various formats such as ESM, it also comes with
    its own format. Without going into too much detail, the shape of a native SystemJS
    module looks as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SystemJS也支持各种格式，如ESM，但它也有自己的格式。不深入细节的话，一个原生的SystemJS模块的形状如下：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code is structurally quite similar to the AMD boilerplate, with
    the only difference being how the callback is structured. While AMD runs the module’s
    body in the callback, SystemJS specifies some more sections in the callback. These
    sections are then run on demand. The real body of a module is defined in the returned
    `execute` section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在结构上与AMD模板非常相似，唯一的区别在于回调的结构。虽然AMD在回调中运行模块的主体，但SystemJS在回调中指定了更多的部分。这些部分将在需要时运行。模块的实际主体定义在返回的`execute`部分中。
- en: As before, the short snippet already illustrates quite nicely that SystemJS
    modules are rarely written by hand. Instead, they are generated by tooling. We’ll
    therefore come back to SystemJS once we have more powerful tooling on hand to
    automate the task of creating valid SystemJS modules.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，简短的片段已经很好地说明了 SystemJS 模块很少是手动编写的。相反，它们是由工具生成的。因此，一旦我们有了更强大的工具来自动化创建有效
    SystemJS 模块的任务，我们就会再次回到 SystemJS。
- en: Now that we have heard enough about libraries and packages, we also need to
    know how we can define our own package. To indicate a package, the `package.json`
    file has to be used.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经足够了解库和包了，我们还需要知道如何定义我们自己的包。为了指示一个包，必须使用 `package.json` 文件。
- en: Knowing package.json fundamentals
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 package.json 基础知识
- en: 'The aggregation of multiple modules forms a package. A package is defined by
    a `package.json` file in a directory. This marks the directory as the root of
    a package. A minimal valid `package.json` to indicate a package is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 多个模块的聚合形成一个包。一个包由目录中的 `package.json` 文件定义。这标志着目录是包的根目录。表示包的最小有效 `package.json`
    如下所示：
- en: package.json
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Some fields, such as `name` or `version`, have special meanings. For instance,
    the `name` field is used to give the package a name. Node.js has some rules to
    decide what is a valid name and what is not.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字段，例如 `name` 或 `version`，具有特殊含义。例如，`name` 字段用于给包命名。Node.js 有一些规则来决定什么是一个有效的名称，什么不是。
- en: For now, it is sufficient to know that valid names can be formed with lowercase
    letters and dashes. Since package names may appear in URLs, a package name is
    not allowed to contain any non-URL-safe characters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只需知道有效的名称可以用小写字母和破折号组成。由于包名称可能出现在 URL 中，因此包名称不允许包含任何非 URL 安全字符。
- en: The `version` field has to follow the specification for **semantic versioning**
    (**semver**). The GitHub repository at [https://github.com/npm/node-semver](https://github.com/npm/node-semver)
    contains the Node.js implementation and many examples for valid versions. Even
    more important is that semver also allows you to select a matching version using
    a range notation, which is useful for dependencies.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`version` 字段必须遵循 **语义版本控制**（**semver**）的规范。GitHub 仓库 [https://github.com/npm/node-semver](https://github.com/npm/node-semver)
    包含了 Node.js 的实现和许多有效版本的示例。更重要的是，semver 还允许你使用范围表示法选择匹配的版本，这对于依赖项非常有用。'
- en: Semver
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Semver
- en: Besides the rules and constraints for version identifiers, the concept of semver
    is used to clearly communicate the impact of changes to package users when updating
    dependencies. According to semver, the three parts of a version (X.Y.Z – for example,
    1.2.3) all serve a different purpose.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了版本标识符的规则和约束之外，semver 的概念用于在更新依赖项时明确地与包用户沟通更改的影响。根据 semver，版本的三个部分（X.Y.Z –
    例如，1.2.3）各有不同的用途。
- en: The leading number (X) is the major version, which indicates the compatibility
    level. The middle number (Y) is the minor version, which indicates the feature
    level. Finally, the last number (Z) is the patch level, which is useful for hotfixes.
    Generally, patch-level changes should always be applied, while feature-level changes
    are optional. Compatibility-level changes should never be applied automatically,
    as they usually involve some refactoring.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前导数字（X）是主版本，它表示兼容性级别。中间的数字（Y）是次要版本，它表示功能级别。最后，最后一个数字（Z）是补丁级别，它对于热修复很有用。通常，补丁级别的更改应该始终应用，而功能级别的更改是可选的。兼容性级别的更改绝不应该自动应用，因为它们通常涉及一些重构。
- en: By default, if the same directory contains an `index.js` file, then this is
    considered the *main*, *root*, or *entry* module of the package. Alternatively,
    we can specify the main module of a package using the `main` field.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果同一目录下包含一个 `index.js` 文件，那么这个文件被认为是包的 *main*、*root* 或 *entry* 模块。或者，我们可以使用
    `main` 字段来指定包的主模块。
- en: 'To change the location of the main module of the package to an `app.js` file
    located within the `lib` subdirectory, we can write the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要将包的主模块位置更改为位于 `lib` 子目录中的 `app.js` 文件，我们可以编写以下内容：
- en: package.json
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Furthermore, the `package.json` can be used to include some metadata about the
    package itself. This can be very helpful for users of the package. Sometimes,
    this metadata is also used in tooling – for example, to automatically open the
    website of the package or the issue tracker or show other packages from the same
    author.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`package.json`可以用来包含有关包本身的元数据。这对包的用户非常有帮助。有时，这些元数据也用于工具中——例如，自动打开包的网站或问题跟踪器，或显示同一作者的其他包。
- en: 'Among the most useful metadata, we have the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在最有用的元数据中，我们有以下内容：
- en: '`description`: A description of the package, which will be shown on websites
    that list the package.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 包的描述，它将在列出该包的网站上显示。'
- en: '`license`: A license using a valid `ISC OR GPL-3.0`) are also possible. These
    will be shown on websites that list the package.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license`: 使用有效的`ISC OR GPL-3.0`等许可协议也是可能的。这些将在列出该包的网站上显示。'
- en: '`author`: Either a simple string or an object containing information about
    the author (for example, `name`, `email`, or `url`). Will be shown on websites
    that list the package.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author`: 可以是一个简单的字符串，或者是一个包含作者信息（例如，`name`、`email`或`url`）的对象。这些信息将在列出该包的网站上显示。'
- en: '`contributors`: Essentially, an array of authors or people who contributed
    in one way or another to the package.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contributors`: 实际上是一个作者或以某种方式为该包做出贡献的人的数组。'
- en: '`repository`: An object with the `url` and `type` (for example, `git`) of the
    code repository – that is, where the source code of the package is stored and
    maintained.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repository`: 一个包含代码仓库`url`和`type`（例如，`git`）的对象——即包的源代码存储和维护的地方。'
- en: '`bugs`: The URL of an issue tracker that can be used to report issues and make
    feature requests.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bugs`: 一个用于报告问题和提出功能请求的问题跟踪器的URL。'
- en: '`keywords`: An array of words that can be used to categorize the package. This
    is very useful for finding packages and is the main source of search engines.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keywords`: 一个可以用来对包进行分类的单词数组。这对于查找包非常有用，并且是搜索引擎的主要来源。'
- en: '`homepage`: The URL of the package’s website.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`homepage`: 包的网站URL。'
- en: '`funding`: An object with the `url` and `type` (for example, `patreon`) of
    the package’s financial support platform. This object is also integrated into
    tooling and websites showing the package.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`funding`: 一个包含包财务支持平台`url`和`type`（例如，`patreon`）的对象。此对象也集成到显示包的工具和网站上。'
- en: There are a couple more fields that are necessary to specify when dealing with
    third-party packages. We’ll cover those in [*Chapter 3*](B18989_03.xhtml#_idTextAnchor033),
    *Choosing a Package Manager*, when we discuss package managers in great detail.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理第三方包时，还有一些其他字段是必须指定的。当我们在详细讨论包管理器时，我们将在[*第三章*](B18989_03.xhtml#_idTextAnchor033)中介绍这些内容，即*选择包管理器*。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about a set of different module formats as alternatives
    to the CommonJS module format. You have been introduced to the current standard
    approach of writing ESMs, which brings a module system directly to the JavaScript
    language.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了一系列不同的模块格式，作为CommonJS模块格式的替代方案。你被介绍到了编写ESMs的当前标准方法，这直接将模块系统引入JavaScript语言。
- en: You also saw how alternative module formats such as AMD or UMD can be used to
    run JavaScript modules on other older JavaScript runtimes. We discussed that by
    using the specialized module loader, SystemJS, you can actually make use of truly
    convenient and current features as a web standard today. The need for import maps
    is particularly striking when talking about third-party dependencies.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你还看到了如何使用AMD或UMD等替代模块格式在较旧的JavaScript运行时上运行JavaScript模块。我们讨论了通过使用专门的模块加载器SystemJS，你实际上可以充分利用作为当今网络标准的真正便捷和当前的功能。在讨论第三方依赖项时，导入映射的需求尤为明显。
- en: You learned that most third-party dependencies are actually deployed in the
    form of packages. In this chapter, you also saw how a `package.json` file defines
    the root of a package and what kind of data may be included in `package.json`
    file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到大多数第三方依赖项实际上是以包的形式部署的。在本章中，你也看到了`package.json`文件如何定义包的根以及可能包含在`package.json`文件中的数据类型。
- en: In the next chapter, we will learn how packages using the discussed formats
    can be installed and managed by using special applications called package managers.
    We’ll see how these package managers operate under the hood and how we can use
    them to improve our development experience.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用被称为包管理器的特殊应用程序来安装和管理使用所讨论格式的包。我们将了解这些包管理器在底层是如何运作的，以及我们如何利用它们来提升我们的开发体验。
