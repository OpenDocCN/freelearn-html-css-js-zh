- en: Single Page Applications with Popular Frontend Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用受欢迎的前端框架的单页应用程序
- en: In this chapter, we will take a look at web application development from the
    frontend perspective, specifically with a **Single Page Application** (**SPA**),
    also referred to as a thick client app. With an SPA, a large chunk of the presentation
    layer is offloaded to the browser, and the browser is responsible for rendering
    pages, handling navigation, and making data calls to an API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从前端的角度来看待Web应用程序开发，特别是**单页应用程序**（**SPA**），也称为厚客户端应用程序。使用SPA，大部分的呈现层被卸载到浏览器中，浏览器负责呈现页面、处理导航，并向API发出数据调用。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Why do we use a frontend framework, such as Backbone.js, Ember.js, or Angular.js?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要使用前端框架，比如Backbone.js、Ember.js或Angular.js？
- en: What is a single page application exactly?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用程序到底是什么？
- en: Popular frontend development tools, such as Grunt, Gulp, Browserify, SAAS, and
    Handlebars
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受欢迎的前端开发工具，如Grunt、Gulp、Browserify、SAAS和Handlebars
- en: Test-driven development on the frontend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端的测试驱动开发
- en: Why use a frontend framework?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用前端框架？
- en: We use frameworks to increase our productivity, keep us sane, and generally,
    to make our development process more enjoyable. In most of the chapters throughout
    this book, we worked with the Express.js MVC framework for Node.js. This framework
    allows us to organize our code, and it extrapolates out a lot of boilerplate code,
    freeing up our time to focus on our custom business logic. The same should be
    said for the front of an application, as well. Any amount of complex code is eventually
    going to need to be properly organized, and we need to use a standard set of reusable
    tools to achieve common tasks. Express.js makes our life easy when writing our
    backend code with Node.js. There are a number of popular frontend frameworks that
    you can rely on as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用框架来提高我们的生产力，让我们保持理智，并且通常来说，让我们的开发过程更加愉快。在本书的大部分章节中，我们使用了Node.js的Express.js
    MVC框架。这个框架允许我们组织我们的代码，并且它将大量样板代码抽象出来，释放出我们的时间来专注于我们的自定义业务逻辑。同样的情况也适用于应用程序的前端。任何复杂的代码最终都需要得到适当的组织，我们需要使用一套标准的可重用工具来完成常见的任务。Express.js在编写我们的Node.js后端代码时让我们的生活变得轻松。同样，也有许多受欢迎的前端框架可以依赖。
- en: What is a single page application?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是单页应用程序？
- en: The current trend with sophisticated web applications is to emulate desktop
    applications and veer away from the feel of a traditional website. With traditional
    websites, every interaction with the server requires a full-page postback that
    makes a complete round trip. As our web applications become more sophisticated,
    the need to send and retrieve data to and from the server increases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的Web应用程序的当前趋势是模拟桌面应用程序，并远离传统网站的感觉。对于传统网站，与服务器的每次交互都需要一个完整的页面后退，这使得一个完整的往返。随着我们的Web应用程序变得更加复杂，发送和从服务器检索数据的需求增加了。
- en: If we rely on full-page postbacks every time, we need to facilitate one of these
    requests; our app will feel sluggish and unresponsive, as the user will have to
    wait for a full round trip with every request. Users demand more from their apps
    these days, and if you think about the application we've written, the Like button
    is a perfect example. Having to send a full-page postback to the server just because
    we wanted to increment a counter by one seems like a lot of unnecessary overhead.
    Fortunately, we were able to easily rectify this using jQuery and AJAX. This is
    a perfect example of how a single page application works (only on a much larger
    scale).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每次都依赖完整的页面后退，我们需要方便其中一个请求；我们的应用程序会感觉迟钝和无响应，因为用户将不得不等待每个请求的完整往返。用户现在对他们的应用程序有更多的需求，如果你考虑一下我们编写的应用程序，点赞按钮就是一个完美的例子。只是因为我们想要增加一个计数器，就必须向服务器发送完整的页面后退，这似乎是很多不必要的开销。幸运的是，我们能够很容易地使用jQuery和AJAX来纠正这一点。这是单页应用程序如何工作的一个完美例子（只是在一个更大的规模上）。
- en: A great example of one of the first, standout single page applications is Google's
    Gmail. Gmail gives you an interface that is similar to Microsoft Outlook or any
    traditional desktop-based email client. User interaction with the application
    feels just as responsive as with a desktop application--the *page* never reloads,
    you can switch panes and tabs within the application with ease, and data is constantly
    being refreshed and updated in real time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个突出的单页应用程序的一个很好的例子是谷歌的Gmail。Gmail为您提供了一个类似于Microsoft Outlook或任何传统基于桌面的电子邮件客户端的界面。用户与应用程序的交互感觉就像与桌面应用程序一样响应——*页面*永远不会重新加载，您可以轻松切换应用程序中的窗格和选项卡，并且数据在实时中不断刷新和更新。
- en: 'Creating an SPA typically involves having a single HTML page as the source
    of the application, which loads all of the necessary JavaScript in order to trigger
    a series of events that include:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建SPA通常涉及将单个HTML页面作为应用程序的源，该页面加载所有必要的JavaScript以触发一系列事件，包括：
- en: '**Bootstrapping the app**: This means connecting to the server via AJAX to
    download the necessary startup data'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导应用程序**：这意味着通过AJAX连接到服务器以下载必要的启动数据'
- en: '**Rendering the screens based on user actions**: This means monitoring events
    triggered by the user and manipulating the DOM so that sections of the app are
    hidden, revealed, or redrawn, which emulates the feel of a desktop application'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根据用户操作呈现屏幕**：这意味着监视用户触发的事件并操作DOM，以便隐藏、显示或重绘应用程序的部分，从而模拟桌面应用程序的感觉'
- en: '**Communicating with the server**: This means using AJAX to constantly send
    and receive data from the server, which maintains the illusion of a stateful connection
    via the browser'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与服务器通信**：这意味着使用AJAX不断地向服务器发送和接收数据，从而保持通过浏览器的有状态连接的幻觉'
- en: The TodoMVC project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TodoMVC项目
- en: When deciding which frontend framework to choose for your next large-scale frontend
    project, the decision making process can be crippling! Keeping track of all of
    the different frameworks and the pros and cons of each can seem like an exercise
    in futility. Luckily, people have answered the call, and a handy website exists
    to not only demonstrate the same application written in nearly every framework,
    but to also offer the complete annotated source code for each as well!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定为下一个大型前端项目选择哪个前端框架时，决策过程可能会让人不知所措！跟踪所有不同的框架以及每个框架的利弊似乎是徒劳的练习。幸运的是，人们已经回应了这一呼吁，有一个方便的网站不仅演示了几乎每个框架编写的相同应用程序，而且还为每个框架提供了完整的注释源代码！
- en: 'The TodoMVC project, [http://todomvc.com](http://todomvc.com), is a website
    that focuses on creating a simple, single page, to-do application, which is written
    using each of the proven JavaScript MVC frameworks; there''s even one written
    in vanilla JavaScript! So, the easiest way to jump into a framework would be to
    take a look at its TodoMVC code sample:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TodoMVC项目，[http://todomvc.com](http://todomvc.com)，是一个专注于创建一个简单的单页面待办事项应用程序的网站，使用了每个经过验证的JavaScript
    MVC框架编写；甚至有一个用原生JavaScript编写的！因此，跳入一个框架的最简单方法是查看其TodoMVC代码示例：
- en: '![](img/75bee610-53e1-45ed-9e70-80206a1ee6a6.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75bee610-53e1-45ed-9e70-80206a1ee6a6.png)'
- en: Definitely spend some time checking out the website and digging into each of
    the featured frameworks. You can get a really good feel for the different frameworks
    by seeing the same code written in completely different ways; no two are identical,
    and ultimately, it's up to you to evaluate and figure out which you prefer and
    why.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要花些时间查看网站并深入了解每个特色框架。通过以完全不同的方式编写相同的代码，您可以对不同的框架有一个很好的感觉；没有两个是相同的，最终，您需要评估并找出您更喜欢哪个以及原因。
- en: For the sake of brevity, I'm going to focus on the three that I personally like
    and believe are at the top of the current list of front runners.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我将专注于我个人喜欢并认为处于当前领先地位的三个。
- en: Backbone.js
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone.js
- en: '**Backbone.js** is an extremely lightweight (6.5 KB in production) MV* framework
    that has been around for a few years. It has an extremely large established user
    base, and many large-scale web applications have been written using this framework:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Backbone.js**是一个非常轻量级（生产中为6.5 KB）的MV*框架，已经存在了几年。它拥有一个非常庞大的用户群，并且许多大型网络应用程序都是使用这个框架编写的：'
- en: USA Today
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今日美国
- en: Hulu
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hulu
- en: LinkedIn
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领英
- en: Trello
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Trello
- en: Disqus
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Disqus
- en: Khan Academy
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可汗学院
- en: Walmart Mobile
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沃尔玛移动
- en: Backbone.js is a great framework to start with if you're comfortable with jQuery
    and have been using it for a while and want to start improving your code organization
    and modularity. Additionally, Backbone.js requires jQuery and integrates it pretty
    tightly, so that's one less thing to worry about learning as you ease into this
    new world of frontend development.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉jQuery并且已经使用它一段时间，并且想要开始改进您的代码组织和模块化，那么Backbone.js是一个很好的起点。此外，Backbone.js需要jQuery并且与之紧密集成，因此在您逐渐进入这个前端开发的新世界时，这就少了一件要担心学习的事情。
- en: 'Backbone.js works on the basic idea of models, collections, views, and routers.
    Take a look at the following points:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js的基本思想是模型、集合、视图和路由器。看一下以下几点：
- en: Models are the basic elements that store and manage all of the data in your
    application
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型是存储和管理应用程序中所有数据的基本元素
- en: Collections store models
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合存储模型
- en: Views render HTML to the screen, retrieving dynamic data from models and collections
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图将HTML呈现到屏幕上，从模型和集合中检索动态数据
- en: Routers power the URLs of your application, allowing each individual section
    of your application its own unique URL (without actually loading live URLs) and
    ultimately tying the whole thing together
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器为应用程序的URL提供动力，使每个应用程序的各个部分都有自己独特的URL（实际上不加载实时URL），最终将整个应用程序联系在一起
- en: 'As Backbone.js is so lightweight, an extremely small and simple set of sample
    code can be put together very quickly:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Backbone.js非常轻量级，可以非常快速地组合一个非常小而简单的示例代码集：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The one thing to notice is that Backbone.js, by its very nature, is so lightweight
    that it doesn't include most of the functionalities that you'd expect to work
    right out of the box. As you can see in the preceding code, in the `View` object
    that we created, we had to provide a `render` function that manually renders the
    HTML for us. For this reason, many people shy away from Backbone.js, but others
    embrace it for the raw power and flexibility it gives to developers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是，Backbone.js本质上是如此轻量级，以至于它不包括您期望立即使用的大多数功能。正如您在前面的代码中所看到的，在我们创建的`View`对象中，我们必须提供一个手动为我们呈现HTML的`render`函数。因此，许多人都对Backbone.js望而却步，但其他人则因其为开发人员提供的原始力量和灵活性而拥抱它。
- en: Traditionally, you wouldn't put all of your code into a single file, like in
    the earlier example. You would organize your models, collections, and views into
    individual folders in a structure, just like we organized the code in our Node.js
    application. Bundling all of the code together would be the job of a build tool
    (which will be discussed later in this chapter).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，您不会像在前面的示例中那样将所有代码放入单个文件中。您将把模型、集合和视图组织到单独的文件夹中，就像我们在Node.js应用程序中组织代码一样。将所有代码捆绑在一起将是构建工具的工作（这将在本章后面讨论）。
- en: You can learn more about Backbone.js by visiting its official website at [http://backbonejs.org](http://backbonejs.org).
    Also, don't forget to check out the Backbone.js implementation of the to-do application
    on the TodoMVC website!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问其官方网站[http://backbonejs.org](http://backbonejs.org)了解更多关于Backbone.js的信息。还要不要忘了在TodoMVC网站上检查待办应用程序的Backbone.js实现！
- en: I maintain a repository on GitHub that has a boilerplate web application with
    complete code that uses the full stack we've covered in this book, as well as
    Backbone.js with Marionette for the frontend. Feel free to check it out at [http://github.com/jkat98/benm](http://github.com/jkat98/benm)
    (Backbone, Express, Node, and MongoDB).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我在GitHub上维护了一个存储库，其中有一个使用我们在本书中涵盖的完整堆栈的样板Web应用程序的完整代码，以及用于前端的Backbone.js和Marionette。欢迎访问[http://github.com/jkat98/benm](http://github.com/jkat98/benm)（Backbone、Express、Node和MongoDB）。
- en: Ember.js
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ember.js
- en: Ember.js bills itself as the *framework for creating ambitious web applications*.
    Ember's goal is to target fairly large-scale SPAs, so the idea of using it to
    build something very simple might seem like overkill, but it is certainly doable.
    A fair assessment is to take a look at the production file size of the Ember library,
    which comes in at around 90 KB (versus 6.5 KB for Backbone.js). That being said,
    if you are building something very robust with a very large code base, the added
    90 KB might not be a big deal for you.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js自称为*创建雄心勃勃的Web应用程序的框架*。Ember的目标是针对相当大规模的单页应用程序，因此使用它构建非常简单的东西可能看起来有些大材小用，但这当然是可行的。一个公平的评估是查看Ember库的生产文件大小，大约为90
    KB（而Backbone.js为6.5 KB）。也就是说，如果你正在构建一个非常强大的、代码量很大的东西，那么额外的90 KB对你来说可能并不是什么大问题。
- en: 'Here is a very small sample application using Ember.js:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Ember.js的非常小的示例应用程序：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ember.js's code looks somewhat similar to that of Backbone.js, and it's no surprise
    that a lot of seasoned Backbone.js developers find themselves migrating to Ember.js
    as their need for more robust solutions increases. Ember.js uses familiar items,
    including views, models, collections, and routes, as well as an `Application`
    object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js的代码看起来与Backbone.js的代码有些相似，因此并不奇怪，许多经验丰富的Backbone.js开发人员发现随着对更强大解决方案的需求增加，他们开始迁移到Ember.js。Ember.js使用熟悉的项目，包括视图、模型、集合和路由，以及一个`Application`对象。
- en: Additionally, Ember.js features components, which is one of its more powerful
    and beloved features. Giving a sneak preview of the future of the web, components
    allow you to create small, modular, reusable HTML components that you can plug
    into your application as needed. With components, you can basically create your
    own custom HTML tags that look and behave exactly how you define them, and they
    can be reused easily throughout an application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Ember.js具有组件功能，这是它更强大和受欢迎的功能之一。通过组件，你可以创建小型、模块化、可重用的HTML组件，根据需要将其插入到应用程序中。使用组件，你基本上可以创建自己的自定义HTML标签，其外观和行为完全按照你定义的方式进行定义，并且可以在整个应用程序中轻松重用。
- en: Developing with Ember.js is all about convention. Unlike Backbone.js, Ember.js
    tries to get a lot of the boilerplate out of the way and makes certain assumptions
    for you. Because of this, you need to do things a certain way, and controllers,
    views, and routes need to follow a somewhat strict pattern with regards to naming
    conventions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ember.js开发完全遵循约定。与Backbone.js不同，Ember.js试图消除大量样板代码，并为你做出一些假设。因此，你需要以一定的方式进行操作，控制器、视图和路由需要遵循一定的命名约定。
- en: The Ember.js website features incredible online documentation and Getting Started
    guides. If you're interested in learning more about Ember.js, check it out at
    [http://emberjs.com/guides/](http://emberjs.com/guides/). Also, don't forget to
    take a look at the TodoMVC implementation!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js网站提供了令人难以置信的在线文档和入门指南。如果你对Ember.js想了解更多，请访问[http://emberjs.com/guides/](http://emberjs.com/guides)。另外，不要忘记查看TodoMVC的实现！
- en: React.js
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React.js
- en: 'There has never been such a great race for adapting new JavaScript technologies.
    It''s the best time for JavaScript. The Facebook team has a strong contender known
    as `React.js`. So, unlike other MVC frameworks such as Angular, `React.js` is
    just a view from Model-View-Controller. It is lightweight and renders with amazing
    speed. The basic encapsulated unit of code is called a component. These components
    are composed together, forming a whole UI. Let''s create a simple component using
    the es6 class for the greeting example, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从未有过如此激烈的竞争来适应新的JavaScript技术。现在是JavaScript的最佳时机。Facebook团队有一个强大的竞争者，名为`React.js`。因此，与Angular等其他MVC框架不同，`React.js`只是Model-View-Controller中的视图。它轻巧且渲染速度惊人。代码的基本封装单元称为组件。这些组件组合在一起，形成一个完整的UI。让我们使用es6类为打招呼的示例创建一个简单的组件，如下所示：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding snippet created a simple class to greet the users. We extended
    `React.component` to provide its public methods and variables to be accessible
    in the `Greet` class. Each component created requires a `render` method, which
    contains the html template of the respective component. The `props` is the public
    variable use to pass the data from containers to child components, and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段创建了一个简单的类来向用户打招呼。我们扩展了`React.component`以提供其公共方法和变量在`Greet`类中的访问权限。每个创建的组件都需要一个`render`方法，其中包含了相应组件的html模板。`props`是一个公共变量，用于从容器传递数据到子组件，依此类推。
- en: 'Now, we need to load the component in our HTML document. To do this, we need
    to register under the `reactDOM` API, which is provided globally by the `React.js`
    library. This can be done as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在HTML文档中加载组件。为了做到这一点，我们需要在`React.js`库全局提供的`reactDOM`API下注册。可以按照以下方式完成：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `render` method of the `ReactDOM` object requires two parameters. First
    the root node, and second, the root element. The root node is an element used
    to declare a host for the different parent components. The root element `<div
    id="root" />` is written in the body of our `index.html` to host the entire view
    of the `React` components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactDOM`对象的`render`方法需要两个参数。首先是根节点，其次是根元素。根节点是用于声明不同父组件的主机元素。根元素`<div id="root"
    />`写在我们的`index.html`的body中，用于承载`React`组件的整个视图。'
- en: '`reactDOM` is responsible for creating a virtual DOM and observes for any changes
    to be made to each component. Only the changed/acted on part is re-rendered, keeping
    other components intact. This boosts up the performance of application. The changes
    in the components we read about are also called states of the components maintained
    by different libraries such as `reflux.js` or `redux.js`. [](http://redux.js/)
    Another important feature is one-way binding using props. The props are only a
    way to pass data to the view. Once the scaffold and the data flow are set, the
    react projects provide great scalable code and ease of maintenance for complex
    projects. There is a huge list of projects on React.js [https://github.com/facebook/react/wiki/sites-using-react](https://github.com/facebook/react/wiki/sites-using-react).
    Once you get comfortable with the react web app, you can easily switch to react
    native which create amazing native mobile applications.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`reactDOM`负责创建虚拟DOM并观察每个组件的任何更改。只重新渲染已更改/操作的部分，保持其他组件不变。这提高了应用程序的性能。我们所了解的组件中的更改也称为组件的状态，由不同的库（如`reflux.js`或`redux.js`）维护。[](http://redux.js/)另一个重要的特性是使用props进行单向绑定。props只是将数据传递给视图的一种方式。一旦搭建和数据流设置好，React项目就能提供出色的可扩展代码和复杂项目的易维护性。React.js上有大量的项目列表[https://github.com/facebook/react/wiki/sites-using-react](https://github.com/facebook/react/wiki/sites-using-react)。一旦你熟悉了React
    web应用程序，你就可以轻松切换到React Native，创建令人惊叹的原生移动应用程序。'
- en: Angular
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular
- en: Angular exploded onto the scene because of the simple fact that it's built by
    Google (it is open source). Angular is basically like putting HTML on steroids.
    The applications and pages that you create use regular HTML that we're all used
    to, but they include a number of new and custom directives that extend the core
    functionality of HTML, giving it awesome new power.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Angular之所以如此火爆，主要是因为它是由谷歌（开源）构建的。Angular基本上就像是给HTML加上了类固醇。您创建的应用程序和页面使用我们都习惯的常规HTML，但它们包括许多新的和自定义指令，扩展了HTML的核心功能，赋予了它强大的新功能。
- en: Another great feature of Angular, which has seasoned non-web developers flocking
    to it is that it is built from the group to be heavily tested and supports dependency
    injection. It's a framework that doesn't make creating sophisticated web applications
    feel like traditional web development.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的另一个伟大特性是，它是由一群经验丰富的非Web开发人员构建的，因为它经过了严格测试并支持依赖注入。这是一个框架，它不会让创建复杂的Web应用程序感觉像传统的Web开发。
- en: Make no mistake, however; JavaScript still plays a huge role in the development
    of Angular. The new Angular 2.0, which is now 4.0, is already one of the most
    extensively used frameworks of today. It has not only introduced TypeScript for
    syntactical modularity of code, but also provides new semantics, such as components
    (instead of controllers), pipes, life cycle hooks, and more features. Let's learn
    more about Angular by implementing a simple client application that consumes the
    phone-API created in the previous chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要误解；JavaScript在Angular的开发中仍然扮演着重要角色。新的Angular 2.0，现在是4.0，已经成为当今最广泛使用的框架之一。它不仅引入了TypeScript来实现代码的语法模块化，还提供了新的语义，如组件（而不是控制器）、管道、生命周期钩子等功能。让我们通过实现一个简单的客户端应用程序来更多了解Angular，该应用程序使用了上一章中创建的phone-API。
- en: Unlike Angular.js, Angular 2.0 is a whole framework, rather than a single includable
    file. This framework comes with a bunch of features, such as rxJs, TypeScript,
    systemJs, and so on, which provide an integrated development of code. The Angular
    team has provided simple steps to set up Angular 2.0 seed application. However,
    a developer can also create a manual list of the minimal files required for Angular
    projects, though it is not recommended and is also time consuming. For our client
    prototype, we will follow the Angular quick-start steps provided by [angular.io](http://angular.io/)
    and then integrate our functionality in to it. Let's follow these steps.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与Angular.js不同，Angular 2.0是一个完整的框架，而不是一个可包含的单个文件。这个框架带有许多功能，如rxJs、TypeScript、systemJs等，提供了代码的集成开发。Angular团队提供了简单的步骤来设置Angular
    2.0种子应用程序。然而，开发人员也可以手动创建Angular项目所需的最小文件列表，尽管这并不被推荐，而且也很耗时。对于我们的客户原型，我们将按照[angular.io](http://angular.io/)提供的Angular快速入门步骤，然后将我们的功能集成到其中。让我们按照这些步骤进行。
- en: Scaffolding the Angular app
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搭建Angular应用程序
- en: 'Go to [https://angular.io/guide/quickstart](https://angular.io/guide/quickstart)
    and follow the three step procedure:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://angular.io/guide/quickstart](https://angular.io/guide/quickstart)并按照三个步骤进行操作：
- en: 'Install `Angular/cli`. It is globally installed with the command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`Angular/cli`。使用以下命令进行全局安装：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new project and name it `phonebook-app` with the following command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个名为`phonebook-app`的新项目：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Go to the `phonebook-app` directory by `cd phonebook-app`. Finally, serve the
    application with `ng serve --open`. The `ng serve` command is used to watch for
    changes while developing, transpiling, and rebuilding the app. `--open` is an
    optional command-line argument used to open the app in a browser tab. Here, in
    case you receive an error, make sure you reinstall npm packages by the **`npm
    install`** command.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`cd phonebook-app`进入`phonebook-app`目录。最后，使用`ng serve --open`来启动应用程序。`ng serve`命令用于在开发过程中监视更改、转译和重建应用程序。`--open`是一个可选的命令行参数，用于在浏览器选项卡中打开应用程序。在这里，如果出现错误，请确保通过**`npm
    install`**命令重新安装npm包。
- en: The Google definition of transpile is the process of converting source code
    in one language to another language, which has a similar level of abstraction.
    Simply, this means we will write code in TypeScript, which is to be converted
    to JavaScript (as it works in a browser).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌对转译的定义是将一种语言的源代码转换为另一种具有相似抽象级别的语言的过程。简单来说，这意味着我们将使用TypeScript编写代码，然后将其转换为JavaScript（因为它在浏览器中运行）。
- en: 'Explaining each file in the project is out of the context of this book, however,
    we will mainly focus on Angular basic building blocks to get it started. Our main
    concern is the `src/app` directory for now. Before we create the components, let''s
    add Twitter''s bootstrap link for the basic styling of our app[.](http://app.in/)
    In our `src` directory, we have `index.html`. Insert the following HTML code in
    the `header` tag:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解释项目中的每个文件超出了本书的范围，但是，我们主要关注Angular的基本构建块以便开始。我们目前的主要关注点是`src/app`目录。在创建组件之前，让我们为我们的应用程序添加Twitter的bootstrap链接以进行基本样式设置[.](http://app.in/)在我们的`src`目录中，我们有`index.html`。在`header`标签中插入以下HTML代码：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Understanding TypeScript and es6
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解TypeScript和es6
- en: TypeScript is a superset of JavaScript that compiles to clean the JavaScript
    output.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是JavaScript的超集，它编译成干净的JavaScript输出。
- en: '- [https://github.com/Microsoft/TypeScript](https://github.com/Microsoft/TypeScript)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://github.com/Microsoft/TypeScript](https://github.com/Microsoft/TypeScript)'
- en: 'As its name suggests, TypeScript implies type languages, which require us to
    specify data types during data declaration in code. This can be seen in different
    languages, such as Java, C#, and so on. In TypeScript, the declaration of a variable
    is done using an annotation colon, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，TypeScript意味着类型语言，这要求我们在代码中声明数据类型。这可以在不同的语言中看到，比如Java、C#等。在TypeScript中，变量的声明使用冒号注释，如下所示：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Secondly, JavaScript contains most (not all) of the object-oriented features.
    So, it can be implemented semantically, but there is no provision syntactically
    . For example, an important feature of OOP is the encapsulation; let''s compare
    it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，JavaScript包含大多数（但不是全部）面向对象的特性。因此，它可以在语义上实现，但在语法上没有规定。例如，面向对象编程的一个重要特性是封装；让我们来比较一下：
- en: '| **TypeScript code** | **JavaScript code (ES5)** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **TypeScript代码** | **JavaScript代码（ES5）** |'
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Eventually, the frameworks that uses TypeScript as its primary scripting language
    compiles (transpiles) it into es5 JavaScript. The new es6 acts as a bridge between
    es5 and TypeScript. To date, es6 has gradually implemented TypeScript features
    into JavaScript for example classes. Knowing this, it will be easy for us to understand
    the usage of TypeScript in Angular framework. For more in depth learning, we can
    refer [https://www.TypeScriptlang.org/docs/home.html](https://www.typescriptlang.org/docs/home.html).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，使用TypeScript作为其主要脚本语言的框架将其编译（转换）为es5 JavaScript。新的es6充当了es5和TypeScript之间的桥梁。到目前为止，es6已逐渐将TypeScript功能实现到JavaScript中，例如类。了解这一点，我们将很容易理解在Angular框架中使用TypeScript的用法。要进行更深入的学习，我们可以参考[https://www.TypeScriptlang.org/docs/home.html](https://www.typescriptlang.org/docs/home.html)。
- en: Modules and components
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和组件
- en: 'Angular 2.0 provides a component-based approach for the reusability of code,
    as well as its maintainability. By visualizing each functional group of elements
    as a component, it is easy to replicate or reuse them. Let''s create a wireframe
    for our project so that we can pick out those components from our project:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2.0提供了基于组件的方法来实现代码的重用性和可维护性。通过将每个功能组件化，可以轻松复制或重用它们。让我们为项目创建一个框架，以便我们可以从项目中挑选出这些组件：
- en: '![](img/cc8b87f6-1a38-4d03-bc22-63525f3858e0.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc8b87f6-1a38-4d03-bc22-63525f3858e0.jpg)'
- en: 'In our project structure, we already have `app.component.ts` as our component
    file. We already have our `app-root` component specified in the `selector` property
    of component metadata. This file will be used for handling the root or parent
    element. According to the preceding wireframe, this file contains the `app-root`
    component:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目结构中，我们已经有`app.component.ts`作为我们的组件文件。我们已经在组件元数据的`selector`属性中指定了我们的`app-root`组件。这个文件将用于处理根或父元素。根据前面的框架，这个文件包含了`app-root`组件：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Make sure we have a class attached for each component so that we can export
    a `component` class and register it as an Angular component in `app.modules.ts`.
    For brevity, we follow the standard naming convention of capitalizing the first
    letter of the class name, followed by importing the Angular class prefix that
    is a component. So in the app `module.ts` file, we have the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 确保每个组件都附加了一个类，这样我们就可以导出一个`component`类，并在`app.modules.ts`中将其注册为Angular组件。为了简洁起见，我们遵循标准的命名约定，即将类名的第一个字母大写，然后导入作为组件的Angular类前缀。因此，在app
    `module.ts`文件中，我们有以下代码：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once registered with `NgModule`, we need to pass the root component to the bootstrap
    method/property. Bootstrap handles the loading on to the platform we decide to
    use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在`NgModule`中注册，我们需要将根组件传递给bootstrap方法/属性。Bootstrap处理加载到我们决定使用的平台上。
- en: 'As per design, in app components, we just have an outline that will act as
    a container for other components, so accordingly, let''s create a template. Create
    a file with HTML code, `app.component.html` and its relative css file, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设计，在应用组件中，我们只有一个轮廓，它将作为其他组件的容器，因此，让我们创建一个模板。创建一个带有HTML代码的文件`app.component.html`和其相关的css文件，如下所示：
- en: '`app.component.html`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.component.html`'
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`app.component.css`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.component.css`'
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After running this code, we get a simple outline in the browser. Use `ng serve`
    to run the app.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，我们在浏览器中得到了一个简单的轮廓。使用`ng serve`来运行应用程序。
- en: Angular data flow architecture
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular数据流架构
- en: 'To get a brief idea of data flow, let''s make a comparative study of how MVC
    is implemented in Angular. Consider the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简要了解数据流，让我们比较一下MVC是如何在Angular中实现的。考虑以下图表：
- en: '![](img/5a089bd9-0472-4ee0-a62f-613e4bcd9e77.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a089bd9-0472-4ee0-a62f-613e4bcd9e77.jpg)'
- en: The diagram consists of basic blocks in Angular 2.0, and not all the facets.
    The model consists of static data or synchronous data classes, which are extended
    or imported in components. The components act as controllers that contain business
    logic. Each component has metadata, which connects it with templates. Finally,
    the data is bound to the `component` class variables and is available in templates.
    Now, for our application, we need the contact data list to be displayed; hence,
    we will be using this feature of data bindings in our new component file `list.component.ts`.
    This file provides the logic for listing the contacts in the phonebook. Always
    follow the three step procedure to include a component.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该图包含了 Angular 2.0 中的基本块，而不是所有的特性。该模型包含静态数据或同步数据类，这些类在组件中被扩展或导入。组件充当包含业务逻辑的控制器。每个组件都有元数据，它将其与模板连接起来。最后，数据绑定到`component`类变量，并在模板中可用。现在，对于我们的应用程序，我们需要显示联系人数据列表；因此，我们将在新的组件文件`list.component.ts`中使用数据绑定的这一特性。该文件提供了在电话簿中列出联系人的逻辑。始终遵循包含组件的三个步骤。
- en: 'Create a metadata and a class for the list component with its template. So,
    we have `list.component.ts`, which consists of the following code :'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为列表组件创建元数据和类以及其模板。因此，我们有`list.component.ts`，其中包含以下代码：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It also consists of its template, `list.component.html`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包括其模板`list.component.html`：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Include the component in `app.module` and register it within the declaration
    property, as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件包含在`app.module`中，并在声明属性中注册，如下所示：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This third step is to include the template for rendering the component. We
    already have our root component `root-app`. So, uncomment the `list` tag from
    `app.component.htm`. This can be done as follows :'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步是包含用于呈现组件的模板。我们已经有了我们的根组件`root-app`。因此，取消`app.component.htm`中的`list`标记。可以按照以下方式完成：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Services
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'The preceding snippet contains static data that is binded to the `phoneList`
    property and thus rendered accordingly, which is a synchronous operation. Now,
    what if we need the asynchronous data to be displayed? Let''s consume our phonebook
    APIs and create an HTTP service for our client so that we can display the asynchronous
    data. Let''s create a service file called `phonebook.service.ts`. This file contains
    all the HTTP `request` methods required to get and set the data. For now, let''s
    create a `getContactlist` method, which will get all the contact data present
    on the server. The required code is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述片段包含绑定到`phoneList`属性的静态数据，因此相应地呈现，这是一个同步操作。现在，如果我们需要显示异步数据怎么办？让我们消耗我们的电话簿
    API 并为我们的客户端创建一个 HTTP 服务，以便我们可以显示异步数据。让我们创建一个名为`phonebook.service.ts`的服务文件。该文件包含了获取和设置数据所需的所有
    HTTP `request` 方法。现在，让我们创建一个`getContactlist`方法，它将获取服务器上存在的所有联系人数据。所需的代码如下：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we imported the `HttpClient` service for making XML HTTP requests from
    our browser. The `Injectable` function is needed to make this file a service provider.
    The metadata in the injectable is not provided as Angular itself will emit the
    metadata. Next, we will be using this service by injecting it inside the component's
    `constructor`. We have passed a parameterized value in the constructor, which
    is referred to as the dependency injection.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了`HttpClient`服务，用于从浏览器发出 XML HTTP 请求。`Injectable`函数是必需的，以使此文件成为服务提供者。在可注入的元数据中没有提供元数据，因为
    Angular 本身将发出元数据。接下来，我们将通过在组件的`constructor`中注入它来使用此服务。我们在构造函数中传递了一个参数化值，这被称为依赖注入。
- en: 'Modify the current code to the following code of `list.components.ts`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前代码修改为`list.components.ts`的以下代码：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we need to register the service under the providers in `app.modules`,
    as we are using it across the app. At this step, we need to have the following
    code in `app.modules`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`app.modules`的提供者下注册服务，因为我们在整个应用程序中都在使用它。在这一步，我们需要在`app.modules`中有以下代码：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And include it in the providers list of `ngModule`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其包含在`ngModule`的提供者列表中：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For using the `Httpclient` service, we first need to register `httpModule` in
    `NgModules`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Httpclient`服务，我们首先需要在`NgModules`中注册`httpModule`。
- en: Also, make sure our phonebook API node server is already running. If not, start
    it using `npm start`, and once we start `ng serve --open`, we will be receiving
    the list of superheroes contacts from the server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保我们的电话簿 API 节点服务器已经在运行。如果没有，请使用`npm start`启动它，一旦我们启动`ng serve --open`，我们将从服务器接收超级英雄联系人列表。
- en: Forms
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单
- en: 'Last but not least, we need to create a form component called `add`, which
    adds a new phone record. In Angular, there are two ways to build a form: template-driven
    forms and reactive forms. As the reactive form is a new feature of Angular, we
    will be implementing it. To put it simply, reactive forms provide for the control
    of form directives through code logic and not in partials. Let''s check it out
    by implementing them for our phonebook app.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要创建一个名为`add`的表单组件，用于添加新的电话记录。在 Angular 中，有两种构建表单的方式：模板驱动表单和响应式表单。由于响应式表单是
    Angular 的一个新特性，我们将实现它。简而言之，响应式表单通过代码逻辑控制表单指令，而不是在部分中。让我们通过为我们的电话簿应用程序实现它来检查它。
- en: 'The new component files to be created are `add.component.ts` and its `.html`
    file, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建的新组件文件是`add.component.ts`及其`.html`文件，如下所示：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, you may observe some new facets of Angular. They are
    explained as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您可能会注意到一些 Angular 的新特性。它们的解释如下：
- en: '`FormControl` and `FormGroup`: Importing the `FormControl`, which is a directive
    that takes model data as an input and creates an instance of form elements. These
    form elements can be aggregated or grouped using `FormGroup`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl`和`FormGroup`：导入`FormControl`，它是一个指令，接受模型数据作为输入，并创建表单元素的实例。这些表单元素可以使用`FormGroup`进行聚合或分组。'
- en: '`Validators`: The class validators provide methods to validate the form elements.
    They are passed as a second optional argument to `FormControl`, to configure the
    validation of an element. It sets a Boolean property as valid, according to conditions
    applied.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Validators`：类验证器提供了验证表单元素的方法。它们作为第二个可选参数传递给`FormControl`，以配置元素的验证。根据应用的条件，它设置一个布尔属性作为有效。'
- en: 'The `Output` and `EventEmitter` will be explained later. So once we have our
    code ready, let''s create its template as follows:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Output`和`EventEmitter`将在后面解释。所以一旦我们的代码准备好了，让我们创建其模板如下：'
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we can investigate if `formGroup` is a directive that
    takes the public variable as input that is `newRecordForm`. We have an event handler
    called `ngSubmit` with public method `onSubmit`. This method is responsible for
    saving the contact details to our server. The last requirement here is that we
    map the properties of `newRecordForm` to `formControlName` so that the code logic
    is mapped to appropriate elements in the template. Classes such as `form-control`
    are used for HTML elements and are just bootstrap classes for a basic design.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以调查`formGroup`是否是一个以`newRecordForm`作为输入的指令。我们有一个名为`ngSubmit`的事件处理程序，其中包含一个名为`onSubmit`的公共方法。这个方法负责将联系人的详细信息保存到我们的服务器上。这里的最后一个要求是将`newRecordForm`的属性映射到`formControlName`，以便代码逻辑映射到模板中的适当元素。像`form-control`这样的类用于HTML元素，只是基本设计的bootstrap类。
- en: Component communication
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件通信
- en: 'Now, we need to add one more change in `app.component.html`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`app.component.html`中再添加一个更改：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to add a change in `app.component.ts`, which is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`app.component.ts`中添加一个更改，如下所示：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This change is required to communicate between two components. What is this
    communication required for?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化是为了在两个组件之间进行通信。这种通信是为了什么？
- en: 'When we add a new record in the `add` component, it needs to send the newly
    added data to the list component, which cannot be bound directly, so we use `@output`
    to bind the data back to the parent. The `EventEmitter` is used to emit the response
    data via the binding in the app template, which can be seen as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`add`组件中添加新记录时，它需要将新添加的数据发送到列表组件，但不能直接绑定，因此我们使用`@output`将数据绑定回父组件。`EventEmitter`用于通过应用模板中的绑定发出响应数据，如下所示：
- en: '`<add (onAdded)="onAddedData($event)"></add>`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`<add (onAdded)="onAddedData($event)"></add>`。'
- en: Here, the app component acts as a bridge between them. Once the parent receives
    the data in the `AddedData` method, it communicates to its child list component
    via the `@input` binding of the `listData` variable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，应用组件充当它们之间的桥梁。一旦父组件在`AddedData`方法中接收到数据，它通过`listData`变量的`@input`绑定与其子列表组件进行通信。
- en: Watch for the changes in the browser; the `form` component adds new data to
    the list and our phonebook app is ready for its first prototype.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 观察浏览器中的变化；`form`组件向列表中添加新数据，我们的电话簿应用程序已经准备好进行第一个原型。
- en: Frontend frameworks have recently taken on somewhat religious undertones. Post
    a negative comment or criticism about a particular framework and it's likely you'll
    get blasted by its supporters. Likewise, talk positively about a particular framework,
    and again, it's likely you'll get attacked about how much better a different framework
    handles the same topic. The bottom line when deciding which framework is right
    for you and/or your project is typically going to be about personal preference.
    Each of the frameworks featured on the TodoMVC website can clearly accomplish
    the same goals, each in its own unique way. Take some time to evaluate a few and
    decide for yourself!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前端框架最近已经带有了一些宗教色彩。发表关于特定框架的负面评论或批评，很可能会遭到支持者的抨击。同样，对特定框架进行积极的讨论，也很可能会遭到关于不同框架如何更好地处理相同主题的攻击。在决定哪种框架适合您和/或您的项目时，通常会涉及个人偏好。在TodoMVC网站上展示的每个框架都可以清楚地以其独特的方式实现相同的目标。花一些时间来评估一下，并自行决定！
- en: Frontend development tools
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端开发工具
- en: Due to the sophisticated nature of single page applications, there exists a
    growing suite of tools a frontend developer needs to be familiar with to manage
    many day-to-day, and sometimes, minute-to-minute tasks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单页应用程序的复杂性，前端开发人员需要熟悉许多日常甚至有时是每分钟的任务的工具套件。
- en: Automated build task managers
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化构建任务管理器
- en: 'A **build tool** is just what it sounds like--a tool used to build your application.
    When a frontend developer creates and maintains an application, there could be
    a number of tasks that need to be repeated literally every time a file is changed
    and saved. Using a build tool, a developer can free up time and mental resources
    by offloading the responsibility to an automated task manager that can watch files
    for changes and execute any number of tasks needed. These tasks might include
    any number of the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建工具**就是它听起来的样子——用于构建应用程序的工具。当前端开发人员创建和维护应用程序时，可能需要重复执行一些任务，每次文件更改和保存时都需要。使用构建工具，开发人员可以通过将责任转移到可以监视文件更改并执行所需的任意数量任务的自动化任务管理器来释放时间和精力。这些任务可能包括以下任意数量的任务：'
- en: Concatenation
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串联
- en: Minification
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩小
- en: Uglification and obfuscation
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丑化和混淆
- en: Manipulation
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵
- en: Dependency installation and preparation
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖安装和准备
- en: Custom script firing
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义脚本触发
- en: Concurrent watchers
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发观察者
- en: Server launching
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器启动
- en: Test automation
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试自动化
- en: Some of the more popular build tools today include Grunt, Gulp, and Broccoli.
    Grunt.js has been around for a number of years and is very well established in
    the development community. Gulp and Broccoli are fairly new but quickly gaining
    traction and work a little differently than Grunt. With Grunt, you define and
    manage your tasks using a configuration file, whereas with Gulp and Broccoli,
    you write Node.js code and use the raw power of streams. Many developers find
    working with Grunt's configuration file to be fairly convoluted and frustrating
    and find working with Gulp to be a refreshing change. However, it's hard to dispute
    Grunt's history and popularity.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 今天一些更受欢迎的构建工具包括Grunt、Gulp和Broccoli。Grunt.js已经存在多年，并且在开发社区中非常成熟。Gulp和Broccoli相对较新，但迅速获得了认可，并且与Grunt的工作方式有所不同。使用Grunt，您可以使用配置文件定义和管理任务，而使用Gulp和Broccoli，您可以编写Node.js代码并使用流的原始力量。许多开发人员发现使用Grunt的配置文件相当混乱和令人沮丧，并且发现使用Gulp是一种令人耳目一新的改变。但是，很难否认Grunt的历史和流行程度。
- en: All three are feature-extensive ecosystems of plugins that help automate literally
    everything and anything you can think of in your build process.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个都是功能丰富的插件生态系统，可以帮助您自动化构建过程中几乎一切和任何事情。
- en: 'Here is a sample output from a typical Grunt `build` command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型Grunt `build`命令的示例输出：
- en: '![](img/29c69e1a-9654-4c3c-a05f-e5857fb688e4.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29c69e1a-9654-4c3c-a05f-e5857fb688e4.jpg)'
- en: In a typical single page application, the build manager can be responsible for
    downloading and installing dependencies, concatenating multiple JavaScript files
    into a single file, compiling and shimming Browserify modules, linting JavaScript
    files for syntax errors, transpiling LESS files into production-ready CSS files,
    copying files to a runtime destination, watching files for changes to repeat any
    of the tasks again, and finally, running appropriate tests any time the code is
    changed--all from a single command!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的单页面应用程序中，构建管理器可以负责下载和安装依赖项，将多个JavaScript文件合并为单个文件，编译和shimming Browserify模块，对JavaScript文件进行语法错误的linting，将LESS文件转换为生产就绪的CSS文件，将文件复制到运行时目标，监视文件以重复任何任务，并最后，在代码更改时运行适当的测试-所有这些都可以通过单个命令完成！
- en: 'Grunt can be installed using `npm` and should be installed globally. Execute
    the following command to install the Grunt CLI on your machine:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt可以使用`npm`进行安装，并且应该全局安装。执行以下命令在您的机器上安装Grunt CLI：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Refer to the getting-started guide on the official Grunt.js website for more
    information at [http://gruntjs.com/getting-started](http://gruntjs.com/getting-started).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考官方Grunt.js网站上的入门指南[http://gruntjs.com/getting-started](http://gruntjs.com/getting-started)。
- en: 'Additionally, feel free to check out Gulp and Broccoli as well, for more information:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以查看Gulp和Broccoli，获取更多信息：
- en: '[http://gulpjs.com/](http://gulpjs.com/)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://gulpjs.com/](http://gulpjs.com/)'
- en: '[https://github.com/broccolijs/broccoli](https://github.com/broccolijs/broccoli)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/broccolijs/broccoli](https://github.com/broccolijs/broccoli)'
- en: Dependency management
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: There are literally millions of JavaScript libraries that exist to help you
    with everything from DOM manipulation (`jquery`) to timestamp formatting (`moment.js`).
    Managing these libraries and dependencies can sometimes be a bit of a headache.
    For the frontend, the dependency manager of choice is Bower.io.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有数百万个JavaScript库可用，可以帮助您处理从DOM操作（`jquery`）到时间戳格式化（`moment.js`）的一切。管理这些库和依赖项有时可能会有点麻烦。对于前端，首选的依赖管理器是Bower.io。
- en: Bower works in almost exactly the same way as npm; it manages the packages in
    the `bower.json` file. While working on the frontend (you need a known JavaScript
    library or plugin, such as underscore, for example), simply execute `bower install
    underscore` and the JavaScript files will be downloaded to a local `bower_components`
    folder in your project. From there, you can automate the inclusion of those scripts
    by updating your build process or by simply copying the file, including a script
    tag in your HTML; then, you're all set.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Bower的工作方式与npm几乎完全相同；它管理`bower.json`文件中的软件包。在前端工作时（例如，您需要一个已知的JavaScript库或插件，例如underscore），只需执行`bower
    install underscore`，JavaScript文件将下载到项目中的本地`bower_components`文件夹中。从那里，您可以通过更新构建过程或简单地复制文件并在HTML中包含脚本标签来自动包含这些脚本；然后，您就可以开始了。
- en: 'Bower can be installed using npm and should be installed globally. Execute
    the following command to install Bower on your machine:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Bower可以使用npm进行安装，并且应该全局安装。执行以下命令在您的机器上安装Bower：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Visit the Bower.io website ([http://bower.io](http://bower.io)) for more information,
    as well as the full directory of scripts available to be installed via `bower
    install`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Bower.io网站([http://bower.io](http://bower.io))，了解更多信息，以及可以通过`bower install`安装的完整脚本目录。
- en: Modularity
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化
- en: When writing large JavaScript applications, the key is to keep your source code
    well-organized and structurally sane. Unfortunately, JavaScript doesn't inherently
    support the idea of modular code very well right out of-the-box. To solve this
    problem, two popular libraries exist to allow you to write modular code and to
    rely on only the modules you need within each individual piece of code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写大型JavaScript应用程序时，关键是保持源代码组织良好和结构合理。不幸的是，JavaScript并不天生很好地支持模块化代码的概念。为了解决这个问题，存在两个流行的库，允许您编写模块化代码，并且只依赖于每个代码片段中需要的模块。
- en: 'An absolute must-read and incredible resource for frontend design patterns
    is Addy Osmandi''s *Learning JavaScript Design Patterns*, which you can read for
    free by visiting the following URL:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前端设计模式的必读资源是Addy Osmandi的*Learning JavaScript Design Patterns*，您可以通过访问以下URL免费阅读：
- en: '[http://addyosmani.com/resources/essentialjsdesignpatterns/book/](http://addyosmani.com/resources/essentialjsdesignpatterns/book/)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://addyosmani.com/resources/essentialjsdesignpatterns/book/](http://addyosmani.com/resources/essentialjsdesignpatterns/book/)'
- en: Require.js and Browserify are two of the most popular module loaders today.
    Each has a very unique syntax and its own set of benefits. Require.js follows
    asynchronous module definitions, which means each piece of code needs to define
    its own dependencies. Personally, I've worked with Require.js in the past, and
    I've recently found that I really like working with Browserify. One of Browserify's
    strengths is that it uses the same modular pattern as Node.js; so, writing frontend
    code using Browserify feels identical to that of Node. You use `module.exports`
    and `require` on the frontend, and you don't have to worry about the syntax context
    switching if you go back and forth between Node and the frontend within the same
    application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Require.js和Browserify是当今最流行的两种模块加载器。每种都有非常独特的语法和自己的一套好处。Require.js遵循异步模块定义，这意味着每段代码都需要定义自己的依赖关系。就我个人而言，我以前使用过Require.js，并且最近发现我真的很喜欢使用Browserify。Browserify的一个优势是它使用与Node.js相同的模块化模式；因此，使用Browserify编写前端代码与使用Node的感觉相同。您在前端使用`module.exports`和`require`，而且如果在同一个应用程序中在Node和前端之间来回切换，您不必担心语法上下文切换。
- en: Using a module loader in conjunction with one of the popular MVC frameworks
    mentioned earlier is almost a requirement, because the two go together like peanut
    butter and jelly!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前提到的流行MVC框架之一结合使用模块加载器几乎是必需的，因为两者像花生酱和果冻一样搭配得很好！
- en: 'For more information, visit the following links:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请访问以下链接：
- en: '[http://browserify.org/](http://browserify.org/)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://browserify.org/](http://browserify.org/)'
- en: '[http://requirejs.org/](http://requirejs.org/)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://requirejs.org/](http://requirejs.org/)'
- en: HTML template-rendering engines
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML模板渲染引擎
- en: Fortunately, we've already covered the idea of HTML template-rendering engines
    throughout the course of this book. The topics and concepts transfer directly
    to frontend applications as well. There are many different HTML template engines
    to choose from for use in the browser.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经在本书的整个过程中涵盖了HTML模板渲染引擎的概念。这些主题和概念直接转移到前端应用程序。在浏览器中有许多不同的HTML模板引擎可供选择。
- en: Many template engines will be mustache-based, meaning that they use `{{` and
    `}}` for merge variables. Handlebars is currently my personal favorite, mainly
    because it works so well in the backend and frontend of an application, and I
    really like working with its helpers. Underscore.js has a built-in `lite` template-rendering
    engine for use with Backbone.js, but its syntax uses `<%` and `%>` (much like
    classic ASP or ASP.net MVC Razor syntax). Typically, most frontend MVC frameworks
    allow you to customize the template-rendering engine and use any engine you want.
    For example, Backbone.js can be set up to use Handlebars.js very easily, instead
    of using Underscore.js by default.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模板引擎将基于mustache，这意味着它们使用`{{`和`}}`进行合并变量。Handlebars目前是我个人最喜欢的，主要是因为它在应用程序的后端和前端都能很好地工作，我真的很喜欢使用它的帮助程序。Underscore.js具有内置的`lite`模板渲染引擎，可与Backbone.js一起使用，但其语法使用`<%`和`%>`（与经典ASP或ASP.net
    MVC Razor语法非常相似）。通常，大多数前端MVC框架允许您自定义模板渲染引擎并使用任何您想要的引擎。例如，Backbone.js可以很容易地设置为使用Handlebars.js，而不是默认使用Underscore.js。
- en: 'Here''s just a small sample list of some of the currently available frontend
    template-rendering engines:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当前可用的一些前端模板渲染引擎的简单示例列表：
- en: "**Underscore.js**: [http://underscorejs.org\uFEFF](http://underscorejs.org)"
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: "**Underscore.js**：[http://underscorejs.org\uFEFF](http://underscorejs.org)"
- en: '**Handlebars**: [http://handlebarsjs.com](http://handlebarsjs.com)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Handlebars**：[http://handlebarsjs.com](http://handlebarsjs.com)'
- en: '**Mustache**: [http://mustache.github.io](http://mustache.github.io)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mustache**：[http://mustache.github.io](http://mustache.github.io)'
- en: '**Dust.js**: [http://akdubya.github.io/dustjs](http://akdubya.github.io/dustjs)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dust.js**：[http://akdubya.github.io/dustjs](http://akdubya.github.io/dustjs)'
- en: '**EJS**: [http://embeddedjs.com](http://embeddedjs.com)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EJS**：[http://embeddedjs.com](http://embeddedjs.com)'
- en: Some of these will work at the backend as well as on the frontend.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些将在后端和前端都起作用。
- en: CSS transpiling
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS转译
- en: The idea of using variables and logic within a CSS file sounds like a dream
    come true, right? We aren't quite there yet (in the browser, anyway); however,
    there are a few tools that will let us use variables and logic in our CSS files
    and compile them during our build step. LESS and SASS are two of the most popular
    CSS transpilers currently available. They behave almost identically, with only
    slight differences in syntax and features. The big difference is that LESS was
    written using JavaScript
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS文件中使用变量和逻辑的想法听起来像是梦想成真，对吧？我们还没有完全实现（至少在浏览器中）；但是，在我们的构建步骤中有一些工具可以让我们在CSS文件中使用变量和逻辑并对其进行编译。LESS和SASS是目前最流行的两种CSS转译器。它们的行为几乎相同，只是在语法和功能上略有不同。最大的区别是LESS是使用JavaScript编写的
- en: and Node, whereas SASS uses Ruby; therefore, each has different requirements
    to get running on your machine.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Node使用JavaScript，而SASS使用Ruby；因此，它们在您的计算机上运行需要不同的要求。
- en: 'Here is a sample SASS style sheet file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个SASS样式表文件示例：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Looking at the sample code, you can see that we have a few new elements that
    wouldn''t typically work in a regular CSS file. Some of these include:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例代码中可以看出，我们有一些通常在常规CSS文件中不起作用的新元素。其中一些包括：
- en: Defining custom variables for use throughout the style sheet
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为整个样式表定义自定义变量
- en: Defining mixins, which act as pseudo functions for reusable styles (with dynamic
    parameters)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义mixin，作为可重用样式的伪函数（带有动态参数）
- en: Mixins and variables within our style definitions
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的样式定义中定义mixin和变量
- en: Nesting styles with parent/child relationships
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用父/子关系嵌套样式
- en: When the previous code is transpiled using LESS (or in the case of the sample
    code SASS), the output is a standard `.css` style sheet that adheres to all the
    normal browser rules and syntax.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用LESS（或在示例代码中使用SASS）转译前面的代码时，输出是一个符合所有正常浏览器规则和语法的标准`.css`样式表。
- en: 'For more information on LESS and SASS, check out the following links:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有关LESS和SASS的更多信息，请查看以下链接：
- en: '[http://lesscss.org](http://lesscss.org)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://lesscss.org](http://lesscss.org)'
- en: '[http://sass-lang.com](http://sass-lang.com)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://sass-lang.com](http://sass-lang.com)'
- en: Testing and test-driven development
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和测试驱动开发
- en: The development of a sophisticated frontend application is no different than
    any other software application. The code is going to be complicated and robust,
    and there's no reason not to write tests, as well as a practice test-driven development.
    The availability of testing frameworks and languages for the frontend is just
    as robust as for any other language. All of the tools and concepts we've used
    for testing the Node.js code that we've written in this book can be used directly
    on the frontend as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 开发复杂的前端应用程序与任何其他软件应用程序并无二致。代码将会复杂而强大，因此写测试以及实践测试驱动开发是理所当然的。前端的测试框架和语言的可用性与任何其他语言一样强大。我们在本书中用于测试我们编写的
    Node.js 代码的所有工具和概念也可以直接用于前端。
- en: 'Some other tools to consider for testing your frontend JavaScript are:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑用于测试前端 JavaScript 的其他一些工具：
- en: '**Karma for running tests**: [http://karma-runner.github.io](http://karma-runner.github.io)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于运行测试的 Karma**: [http://karma-runner.github.io](http://karma-runner.github.io)'
- en: '**Jasmine for writing tests**: [http://jasmine.github.io](http://jasmine.github.io)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于编写测试的 Jasmine**: [http://jasmine.github.io](http://jasmine.github.io)'
- en: PhantomJS headless browser
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PhantomJS 无头浏览器
- en: One thing I'd like to point out with testing frontend code is that typically,
    the test runners want to run in a browser window. This is great and makes perfect
    sense, but in the real world, automating your tests or quickly executing them
    with TDD can be a bit painful when a browser window wants to open every time your
    test suite runs. PhantomJS is an available *headless* browser that works perfectly
    in this kind of scenario. A headless browser simply means it's a browser that
    runs from the command line, in memory, with no actual interface (like a typical
    browser).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出的一件事是，测试前端代码时，通常测试运行程序希望在浏览器窗口中运行。这很好，也很合理，但在现实世界中，自动化测试或使用 TDD 快速执行测试套件时，每次测试套件运行时都要打开浏览器窗口可能有点痛苦。PhantomJS
    是一种可用的 *无头* 浏览器，非常适合在这种情况下使用。无头浏览器简单地意味着它是一个可以在命令行中运行的浏览器，只存在于内存中，没有实际的界面（像典型的浏览器）。
- en: 'You can easily configure Karma to launch the test suite using PhantomJS instead
    of your browser of choice. When using PhantomJS as your browser, your tests execute
    behind the scenes, and only errors are reported. Here is a sample output of a
    test suite running with Karma using PhantomJS:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地配置 Karma，使用 PhantomJS 而不是您选择的浏览器来启动测试套件。当使用 PhantomJS 作为您的浏览器时，您的测试在后台执行，只报告错误。以下是使用
    Karma 使用 PhantomJS 运行的测试套件的示例输出：
- en: '![](img/b13ab011-5663-4bb3-9120-36d146cdaaf3.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b13ab011-5663-4bb3-9120-36d146cdaaf3.jpg)'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was a whirlwind tour of some of the most common frontend tools and frameworks
    used when doing typical web development. We took a look at the TodoMVC project
    and reviewed three popular JavaScript frameworks to build robust and sophisticated
    frontend applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于在进行典型的 Web 开发时使用的一些最常见的前端工具和框架的快速介绍。我们看了一下 TodoMVC 项目，并回顾了三种流行的 JavaScript
    框架，用于构建强大和复杂的前端应用程序。
- en: Popular build tools such as Grunt.js, Gulp, and Broccoli help developers streamline
    their workflow process by automating a lot of the repetitive tasks that need to
    occur every time a file is modified. From concatenating scripts into a single
    file, to minifying and compressing, to executing automated test suites, the task
    runners can be configured to handle pretty much everything under the sun!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如 Grunt.js、Gulp 和 Broccoli 等流行的构建工具帮助开发人员通过自动化许多需要在每次文件修改时发生的重复任务来简化其工作流程。从将脚本连接成单个文件，到最小化和压缩，再到执行自动化测试套件，任务运行程序可以配置为处理几乎所有事情！
- en: We took a look at two popular CSS transpilers with LESS and SASS and saw how
    they can make creating and managing CSS style sheets dynamic with the use of mixins,
    variables, and nesting.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了一下两种流行的 CSS 转译器 LESS 和 SASS，并看到它们如何通过使用混合、变量和嵌套使得创建和管理 CSS 样式表变得动态化。
- en: Finally, you learned about PhantomJS, the headless browser, and using it when
    running frontend tests so that the tests can be executed quickly and easily from
    the command line using a test runner like Karma.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您了解了 PhantomJS，无头浏览器，并在运行前端测试时使用它，以便可以使用像 Karma 这样的测试运行程序从命令行快速轻松地执行测试。
