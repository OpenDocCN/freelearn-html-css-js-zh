- en: '*Chapter 1*: Exploring the Core Concepts of JavaScript'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章* 探索 JavaScript 的核心概念'
- en: 'The JavaScript language was created (in the mid-1990s) to be executed in internet
    browsers, in order to make websites more fluid. It was originally used to control
    what was entered into input forms. For example, it was used to do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 语言是在 1990 年代中期创建的，用于在互联网浏览器中执行，以便使网站更加流畅。最初，它被用来控制输入表单中的内容。例如，它被用来做以下事情：
- en: Allow the entry of numeric characters in a field – and only numeric ones. Other
    characters, for example, letters, had to be rejected in this case. This made it
    possible, thanks to the JavaScript language included in the browser, not to validate
    the entry of the form and avoid sending data to the server, which would have indicated
    an entry error in this case.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在字段中输入数字字符——并且只有数字字符。在这种情况下，其他字符，例如字母，必须被拒绝。这使得由于浏览器中包含的 JavaScript 语言，可以不验证表单的输入并避免将数据发送到服务器，在这种情况下会表明输入错误。
- en: Check that the mandatory fields of the form were all entered, by checking all
    the fields before sending the form fields to the server.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将表单字段发送到服务器之前，检查表单的所有必填字段是否都已填写。
- en: These two examples (among many others) show that it is desirable to have a language
    that checks the validity of the data entered by the user before sending this data
    to the server. This avoids data transfers from the browser to the server, in the
    event that the data entered is not correct. For more complex checks, such as checking
    that two people do not have the same identifier, this can continue to be done
    on the server because it has access to all existing identifiers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例（以及其他许多示例）表明，在将用户输入的数据发送到服务器之前，检查数据的有效性是可取的。这避免了在输入的数据不正确的情况下，从浏览器到服务器的数据传输。对于更复杂的检查，例如检查两个人是否具有相同的标识符，这可以在服务器上继续进行，因为服务器可以访问所有现有的标识符。
- en: The goal was, therefore, at the beginning of JavaScript, to have the browser
    check as many things as possible and then transmit the information entered to
    the server in order to process it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JavaScript 的目标是在其初期，让浏览器尽可能多地检查，然后将输入的信息传输到服务器进行处理。
- en: 'For this, an internal browser language was created: the JavaScript language,
    whose name contained a very popular word at the time – “Java” (even though the
    two languages Java and JavaScript had nothing to do with each other).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，创建了一种内部浏览器语言：JavaScript 语言，其名称包含当时一个非常流行的词——“Java”（尽管 Java 和 JavaScript
    这两种语言之间没有任何关系）。
- en: Over the years, developers have had the idea of also associating it with the
    server side, to use the same language on the client side and on the server side.
    This allowed the creation of the Node.js server, which is widely used today.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，开发者们有了将之与服务器端关联起来的想法，以便在客户端和服务器端使用相同的语言。这允许创建 Node.js 服务器，它今天被广泛使用。
- en: Whether client-side or server-side, the JavaScript language uses a basic syntax
    that allows you to write your own programs. This is what we are going to discover
    in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是客户端还是服务器端，JavaScript 语言使用一种基本的语法，允许你编写自己的程序。这是我们将在本章中要探讨的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Types of variables used in JavaScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 中使用的变量类型
- en: Running a JavaScript program
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 JavaScript 程序
- en: Declaring variables in JavaScript
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 中声明变量
- en: Writing conditions for conditional tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写条件测试的条件
- en: Creating processing loops
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建处理循环
- en: Using functions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To develop in JavaScript, and write and then run the programs in this book,
    you will need the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 JavaScript 中开发，并在此书中编写和运行程序，你需要以下内容：
- en: A text editor for computer programs, for example, Notepad++, Sublime Text, EditPlus,
    or Visual Studio.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于计算机程序的文本编辑器，例如 Notepad++、Sublime Text、EditPlus 或 Visual Studio。
- en: An internet browser, for example, Chrome, Firefox, Safari, or Edge.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个互联网浏览器，例如 Chrome、Firefox、Safari 或 Edge。
- en: A PHP server, for example, XAMPP or WampServer. The PHP server will be used
    to execute JavaScript programs containing `import` statements in HTML pages because
    these `import` statements only work on an HTTP server.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 PHP 服务器，例如 XAMPP 或 WampServer。PHP 服务器将用于在 HTML 页面上执行包含 `import` 语句的 JavaScript
    程序，因为这些 `import` 语句只能在 HTTP 服务器上工作。
- en: 'A Node.js server: The Node.js server will be created through Node.js installation.
    We will also install and use the MongoDB database to associate the Node.js server
    with a database.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 服务器：Node.js 服务器将通过 Node.js 安装创建。我们还将安装并使用 MongoDB 数据库，以将 Node.js 服务器与数据库关联。
- en: 'You can find the code files for this chapter on GitHub at: [https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%201.zip](https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%201.zip).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件：[https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%201.zip](https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%201.zip)。
- en: Let’s now begin our discovery of JavaScript, by studying the different types
    of variables it offers us.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始探索 JavaScript，通过研究它为我们提供的不同类型的变量。
- en: Types of variables used in JavaScript
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 中使用的变量类型
- en: 'Like any language, JavaScript allows you to create variables that will be used
    to manipulate data. JavaScript is a very simple language so, for example, data
    types are very basic. We will thus have the following as the main data types:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何语言一样，JavaScript 允许你创建用于操作数据的变量。JavaScript 是一种非常简单的语言，因此，例如，数据类型非常基础。因此，我们将以下内容作为主要数据类型：
- en: Numerical values
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值
- en: Boolean values
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Character strings
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Arrays
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Objects
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Let’s take a quick look at these different types of data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览这些不同类型的数据。
- en: Numerical values
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值
- en: Numerical values can be positive or negative and even in decimal form (for example,
    0, -10, 10.45). All mathematical numbers called real numbers comprise numerical
    values or data points.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数值可以是正数或负数，甚至可以是小数形式（例如，0，-10，10.45）。所有称为实数的数学数都包含数值或数据点。
- en: Boolean values
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'These are of course the two Boolean values—true or false—that are found in
    most languages. These values are used to express conditions: if the condition
    is true, then we perform a particular process, otherwise, we perform an alternative
    one. The result of the condition is therefore a true or false value, which is
    symbolized by the two values `true` and `false`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是两种布尔值——true 或 false，这在大多数语言中都可以找到。这些值用于表达条件：如果条件为真，则执行特定过程，否则执行另一个过程。因此，条件的结果是
    true 或 false 值，分别用两个值 `true` 和 `false` 表示。
- en: We will see how to express conditions in the *Writing conditions* section, later
    in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的“编写条件”部分中看到如何表达条件。
- en: Character strings
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: Character strings refer to values such as `"a"`, `"abc"`, or `"Hello, how are
    you?"`. An empty character string will be represented by `""` (consecutive quotes
    with nothing inside). Note that you can use double quotes (`"`) or single quotes
    (`'`). Thus, the string `"abc"` can also be written as `'abc'` (with single quotes).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串指的是像 `"a"`，`"abc"` 或 `"Hello, how are you?"` 这样的值。空字符串将表示为 `""`（连续的引号，里面没有任何内容）。注意，你可以使用双引号（`"`）或单引号（`'`）。因此，字符串
    `"abc"` 也可以写成 `'abc'`（使用单引号）。
- en: Arrays
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays, such as `[10, "abc", -36]`, can contain values of any type, like here
    where we have both numeric values and character strings. An empty array will be
    represented by `[]`, which means that it contains no value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数组，如 `[10, "abc", -36]`，可以包含任何类型的值，例如这里我们既有数值也有字符串。空数组将表示为 `[]`，这意味着它不包含任何值。
- en: 'The values stored in an array are accessed by means of an index, varying from
    0 (to access the first element placed in the array) to the length of the array
    minus 1 (to access the last element of the array). So, if the array `[10, "abc",
    -36]` is represented, for example, by the variable `tab`, the following occurs:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在数组中的值通过索引访问，索引从 0（用于访问数组中放置的第一个元素）到数组的长度减 1（用于访问数组的最后一个元素）。因此，如果数组 `[10,
    "abc", -36]` 通过变量 `tab` 表示，例如，以下情况会发生：
- en: '`tab[0]` will allow access to the first element of the array: `10`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tab[0]` 将允许访问数组的第一个元素：`10`。'
- en: '`tab[1]` will allow access to the second element of the array: `"abc"`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tab[1]` 将允许访问数组的第二个元素：`"abc"`。'
- en: '`tab[2]` will allow access to the third and last element of the array: `-36`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tab[2]` 将允许访问数组的第三个和最后一个元素：`-36`。'
- en: Note
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Note that it is possible to add elements to an array, even if it is empty. So,
    if we access index 3 of the previous array `tab`, we can write `tab[3] = "def"`.
    The array `tab` will therefore now be `[10, "abc", -36, "def"]`.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你可以在数组为空的情况下向数组中添加元素。因此，如果我们访问前面数组 `tab` 的索引 3，我们可以写 `tab[3] = "def"`。因此，数组
    `tab` 现在将是 `[10, "abc", -36, "def"]`。
- en: Objects
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: Objects are similar to arrays. They are used to store arbitrary information,
    for example, the values `43`, `"Clinton"`, and `"Bill"`. But unlike arrays that
    use indexes, you must specify a name to access each of these values. This name
    is called the key, which thus allows access to the value it represents.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类似于数组。它们用于存储任意信息，例如，值`43`，`"Clinton"`，和`"Bill"`。但与使用索引的数组不同，你必须指定一个名称来访问这些值中的每一个。这个名称被称为键，因此它允许访问它所代表的值。
- en: 'Let’s suppose that the previous value `43` is that of a person’s age, while
    `"Clinton"` is their last name, and `"Bill"` is their first name. We would then
    write the object in the following form: `{ age: 43, lastname: "Clinton", firstname:
    "Bill" }`. The definition of the object is done by means of braces, and what is
    indicated inside is pairs of data of the form `key: value` separated by commas.
    This writing format is also called **JavaScript Object Notation** (**JSON**) format.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '假设之前的值`43`是某人的年龄，而`"Clinton"`是他们的姓，`"Bill"`是他们的名。那么我们将对象写成以下形式：`{ age: 43,
    lastname: "Clinton", firstname: "Bill" }`。对象的定义是通过花括号完成的，内部是`key: value`形式的键值对，由逗号分隔。这种书写格式也称为**JavaScript对象表示法**（**JSON**）格式。'
- en: So, if the previous object is associated with the variable `person`, we can
    access their age by writing `person["age"]` (which will therefore be `43` here),
    but we can also write `person.age`, which will also be `43`. Similarly, we can
    also write `person.lastname` or `person["lastname"]` and `person.firstname` or
    `person["firstname"]` to access the person’s last name and first name, respectively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果之前的对象与变量`person`相关联，我们可以通过编写`person["age"]`（在这里将是`43`）来访问他们的年龄，但也可以编写`person.age`，这也会是`43`。同样，我们也可以编写`person.lastname`或`person["lastname"]`以及`person.firstname`或`person["firstname"]`来分别访问该人的姓和名。
- en: The key is also called a property of the object. Thus, the `age` key is also
    called the `age` property. We can choose any name for the key; you just have to
    indicate the key and then use it under this name. So, if you specify `age` as
    a property in the `person` object, you must use the term `age` in the expressions
    `person.age` or `person["age"]`; otherwise it will not work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 键也被称为对象的属性。因此，`age`键也被称为`age`属性。我们可以为键选择任何名称；你只需指出键，然后使用这个名称。所以，如果你在`person`对象中将`age`指定为属性，你必须使用`person.age`或`person["age"]`中的术语；否则它将不起作用。
- en: Note that if you write `person[age]` instead of `person["age"]`, JavaScript
    considers `age` to be a variable with a previously defined value, which it is
    not here and therefore cannot work in this case. You would have to set the `age`
    variable to have the value `"age"` for this to work.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你写`person[age]`而不是`person["age"]`，JavaScript会将`age`视为一个具有先前定义值的变量，而在这里它不是，因此在这种情况下无法工作。你必须将`age`变量设置为具有值`"age"`才能使其工作。
- en: 'The elements of an array are ordered according to their index (starting from
    0, then 1, and so on), while the elements contained in an object are ordered according
    to the keys indicated for each element. But even though the `lastname` key is
    listed in the `person` object before the `firstname` key, this does not differentiate
    the object `{ age: 43, lastname: "Clinton", firstname: "Bill" }` from the object
    `{ firstname: "Bill", lastname: "Clinton", age: 43 }` because the order in which
    keys are written to an object is irrelevant.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '数组的元素按照它们的索引顺序排列（从0开始，然后是1，依此类推），而包含在对象中的元素按照每个元素指定的键顺序排列。尽管`lastname`键在`person`对象中列在`firstname`键之前，但这并不区分对象`{
    age: 43, lastname: "Clinton", firstname: "Bill" }`和对象`{ firstname: "Bill", lastname:
    "Clinton", age: 43 }`，因为键写入对象的顺序是不相关的。'
- en: Finally, there are empty objects, such as those containing no key (therefore
    no value). We write an empty object in the form `{ }`, indicating nothing is inside.
    We can then add one or more keys to an object, even if it is initially empty.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，存在空对象，例如那些不包含键（因此没有值）的对象。我们以`{ }`的形式写一个空对象，表示里面没有任何内容。然后我们可以向一个对象添加一个或多个键，即使它最初是空的。
- en: Now that we have seen the main variable types used in JavaScript, let’s see
    how to use them to define variables in our programs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了JavaScript中使用的的主要变量类型，让我们看看如何使用它们在我们的程序中定义变量。
- en: Running a JavaScript program
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行JavaScript程序
- en: JavaScript is a language that can be executed in a browser (Edge, Chrome, Firefox,
    Safari, and so on) or on a server with Node.js installed. Let’s see how to write
    JavaScript programs for these two types of configurations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种可以在浏览器（Edge、Chrome、Firefox、Safari 等等）或安装了 Node.js 的服务器上执行的语言。让我们看看如何为这两种配置编写
    JavaScript 程序。
- en: Running a JavaScript program in a browser
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在浏览器中运行 JavaScript 程序
- en: To run a JavaScript program in a browser, you must insert the JavaScript code
    into an HTML file. This HTML file will then be displayed in the browser, which
    will cause the execution of the JavaScript code included in the file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器中运行 JavaScript 程序，必须将 JavaScript 代码插入到 HTML 文件中。然后，该 HTML 文件将在浏览器中显示，这将导致文件中包含的
    JavaScript 代码执行。
- en: 'JavaScript code can be specified in the HTML file in two different ways:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码可以在 HTML 文件中以两种不同的方式指定：
- en: The first way is to write it between the `<script>` and `</script>` tags, directly
    in the HTML file. The `<script>` tag indicates the beginning of the JavaScript
    code, while the `</script>` tag indicates the end of it. Anything written between
    these two tags is considered JavaScript code.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方式是直接在 HTML 文件中的 `<script>` 和 `</script>` 标签之间编写。`<script>` 标签表示 JavaScript
    代码的开始，而 `</script>` 标签表示其结束。在这两个标签之间编写的任何内容都被认为是 JavaScript 代码。
- en: The second way is to write the JavaScript code in an external file and then
    include this external file in the HTML file. The external file is included in
    the HTML file by means of a `<script>` tag in which the `src` attribute is indicated,
    the value of which is the name of the JavaScript file that will be included in
    the HTML page.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方式是将 JavaScript 代码写入外部文件，然后将其包含在 HTML 文件中。外部文件通过在 HTML 文件中包含一个 `<script>`
    标签来包含，其中 `src` 属性指示的值是要包含在 HTML 页面中的 JavaScript 文件的名称。
- en: Let’s take a look at these two ways of writing the JavaScript code that will
    run in the browser.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这两种在浏览器中运行的 JavaScript 代码的编写方式。
- en: Writing JavaScript code between the <script> and </script> tags
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 <script> 和 </script> 标签之间编写 JavaScript 代码
- en: 'A file with an `.html` extension is used; for example, the `index.html` file.
    This file is a traditional HTML file, in which we have inserted the `<script>`
    and `</script>` tags, as shown in the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `.html` 扩展名的文件；例如，`index.html` 文件。这是一个传统的 HTML 文件，我们在其中插入了 `<script>` 和 `</script>`
    标签，如下面的代码片段所示：
- en: index.html file
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: index.html 文件
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have inserted the `<script>` tag (and its ending `</script>`) in the `<head>`
    section of the HTML page. The `<meta>` tag is used to indicate the encoding characters
    to use. In the preceding code, we have used `utf-8` so that accented characters
    can be displayed correctly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 HTML 页面的 `<head>` 部分插入了 `<script>` 标签（及其结束标签 `</script>`）。`<meta>` 标签用于指示要使用的字符编码。在前面的代码中，我们使用了
    `utf-8`，以便正确显示带重音的字符。
- en: The JavaScript code inserted here is rudimentary. We use the `alert()` function,
    which displays a dialog box on the browser screen, displaying the text of the
    message indicated in the first parameter of the function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处插入的 JavaScript 代码非常基础。我们使用了 `alert()` 函数，该函数会在浏览器屏幕上显示一个对话框，显示函数第一个参数中指示的消息文本。
- en: 'To run this HTML file, simply move it (by dragging and dropping) from the file
    manager to any browser; for example, Firefox. The following screen is then displayed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此 HTML 文件，只需将其（通过拖放）从文件管理器移动到任何浏览器；例如，Firefox。然后会显示以下屏幕：
- en: '![Figure 1.1 – Displaying a message in the browser window'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 在浏览器窗口中显示消息'
- en: '](img/Figure_1.1_B17416.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.1 – Displaying a message in the browser window](img/Figure_1.1_B17416.jpg)'
- en: Figure 1.1 – Displaying a message in the browser window
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 在浏览器窗口中显示消息
- en: The JavaScript code present in the `<script>` tag ran when the HTML page was
    loaded. The message indicated in the `alert()` function is therefore displayed.
    A click on the **OK** button validates the message displayed and continues the
    execution of the JavaScript code. As we can see, there is nothing more in the
    program; the program ends immediately by displaying a blank page on the screen
    (because no HTML code is inserted into the page).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<script>` 标签中存在的 JavaScript 代码在 HTML 页面加载时运行。因此，`alert()` 函数中指示的消息会被显示出来。点击
    **确定** 按钮验证显示的消息并继续执行 JavaScript 代码。正如我们所看到的，程序中没有任何其他内容；程序立即通过在屏幕上显示空白页面结束（因为没有将
    HTML 代码插入到页面中）。
- en: Writing JavaScript code to an external file
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 JavaScript 代码写入外部文件
- en: Rather than integrating the JavaScript code directly into the HTML file, we
    can put it in an external file, then insert this file into our HTML file by indicating
    its name in the `src` attribute of the `<script>` tag.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接将 JavaScript 代码集成到 HTML 文件中，我们可以将其放在一个外部文件中，然后通过在 `<script>` 标签的 `src`
    属性中指定其名称来将此文件插入到我们的 HTML 文件中。
- en: 'Let’s first write the file that will contain the JavaScript code. This file
    has the file extension `.js` and will be named `codejs.js`, for example, and will
    be coded as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先编写将包含 JavaScript 代码的文件。这个文件具有 `.js` 文件扩展名，将被命名为 `codejs.js`，例如，其代码如下：
- en: codejs.js file (in the same directory as index.html)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: codejs.js 文件（位于 index.html 同一目录下）
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `codejs.js` file contains the JavaScript code that we had previously inserted
    between the `<script>` and `</script>` tags.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`codejs.js` 文件包含我们之前在 `<script>` 和 `</script>` 标签之间插入的 JavaScript 代码。'
- en: 'The `index.html` file is modified to include the `codejs.js` file using the
    `src` attribute of the `<script>` tag as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 文件被修改以包含 `codejs.js` 文件，使用 `<script>` 标签的 `src` 属性如下：'
- en: index.html file
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: index.html 文件
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the use of the `<script>` and `</script>` tags. They are contiguous (that
    is, they have no spaces or newlines between them), which is necessary for this
    code to work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `<script>` 和 `</script>` 标签的使用。它们是连续的（也就是说，它们之间没有空格或换行符），这对于代码的正常运行是必要的。
- en: In the rest of our examples, we will mainly use the insertion of the JavaScript
    code directly in the code of the HTML file, but the use of an external file would
    produce the same results.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的示例中，我们将主要使用直接在 HTML 文件中插入 JavaScript 代码，但使用外部文件会产生相同的结果。
- en: Let’s now explain another way to display messages, without blocking the program
    as before with the `alert(message)` function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解释另一种显示消息的方法，这种方法不会像之前使用 `alert(message)` 函数那样阻塞程序。
- en: Using the console.log() method instead of the alert() function
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 console.log() 方法代替 alert() 函数
- en: The `alert()` function used earlier displays a window on the HTML page, and
    the JavaScript program hangs waiting for the user to click the **OK** button in
    the window. Thus, the function requires the intervention of the user to continue
    the execution of the program.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的 `alert()` 函数在 HTML 页面上显示一个窗口，JavaScript 程序会挂起等待用户在窗口中点击 **确定** 按钮。因此，该函数需要用户的干预才能继续程序的执行。
- en: An alternative makes it possible to use a display without blocking the execution
    of the program. This is the display in the console, using the `console.log()`
    method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方法使得可以在不阻塞程序执行的情况下使用显示。这是在控制台中，使用 `console.log()` 方法。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `console.log()` form of writing means that we use the `log()` method, which
    is associated with the `console` object. This will be explained in detail in the
    following chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log()` 写法意味着我们使用与 `console` 对象关联的 `log()` 方法。这将在下一章中详细解释。'
- en: 'Let’s write the program again using the `console.log()` method instead of the
    `alert()` function. The `index.html` file will be modified as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次编写程序，这次使用 `console.log()` 方法而不是 `alert()` 函数。`index.html` 文件将按如下方式修改：
- en: index.html file using console.log() method
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 console.log() 方法的 index.html 文件
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The use of comments in the JavaScript program requires placing `//` before what
    needs to be commented out (on the same line). You can also comment out several
    lines by enclosing them with `/*` at the beginning and `*/` at the end.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 程序中使用注释需要将 `//` 放在需要注释的内容之前（在同一行上）。您也可以通过在开头和结尾使用 `/*` 和 `*/` 来注释多行。
- en: Let’s run this program by pressing the *F5* key on the keyboard to refresh the
    window. A white screen will appear, with no message.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按键盘上的 *F5* 键来运行此程序以刷新窗口。会出现一个空白屏幕，没有任何消息。
- en: Indeed, the message is only displayed in the console. The console is only visible
    if you press the *F12* key (and can be removed by pressing *F12* again).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，消息只会在控制台中显示。控制台只有在您按下 *F12* 键时才会可见（可以通过再次按下 *F12* 来移除）。
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can go to the site [https://balsamiq.com/support/faqs/browserconsole/](https://balsamiq.com/support/faqs/browserconsole/),
    which explains how to display the console in the event that the *F12* key is inoperative.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问网站 [https://balsamiq.com/support/faqs/browserconsole/](https://balsamiq.com/support/faqs/browserconsole/)，该网站解释了在
    *F12* 键无效的情况下如何显示控制台。
- en: 'The following is what you will see when the console is displayed:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在控制台显示的内容：
- en: '![Figure 1.2 – Message displayed in the console'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – 控制台中显示的消息'
- en: '](img/Figure_1.2_B17416.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – 控制台中显示的消息'
- en: Figure 1.2 – Message displayed in the console
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 控制台中显示的消息
- en: The message is displayed in the lower part of the browser window.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 消息显示在浏览器窗口的下半部分。
- en: Now that we have learned how to run a JavaScript program in a browser, let’s
    move on to learning how to run a JavaScript program on a Node.js server.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在浏览器中运行 JavaScript 程序，接下来让我们学习如何在 Node.js 服务器上运行 JavaScript 程序。
- en: Running a JavaScript program on a Node.js server
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Node.js 服务器上运行 JavaScript 程序
- en: To run a JavaScript program on a Node.js server, you must first install the
    Node.js server. To install, simply go to [https://nodejs.org/](https://nodejs.org/)
    and download and install the server. Note that if you are using macOS, Node.js
    is already installed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Node.js 服务器上运行 JavaScript 程序，你必须首先安装 Node.js 服务器。要安装，只需访问 [https://nodejs.org/](https://nodejs.org/)
    并下载和安装服务器。请注意，如果你使用 macOS，Node.js 已经安装了。
- en: 'We can verify the correct installation of Node.js by just opening a shell and
    typing the command `node -h` in it. Node.js is correctly installed if the command
    help appears as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打开一个壳并输入命令 `node -h` 来验证 Node.js 的正确安装。如果命令帮助显示如下，则表示 Node.js 已正确安装：
- en: '![Figure 1.3 – node -h command that displays help'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.3 – node -h 命令显示帮助信息'
- en: '](img/Figure_1.3_B17416.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.3_B17416.jpg]'
- en: Figure 1.3 – node -h command that displays help
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 显示帮助信息的 node -h 命令
- en: Once Node.js is installed, it can run any JavaScript program you want. All you
    have to do is create a file containing JavaScript code, for example, `testnode.js`.
    The contents of this file will be executed by the server using the `node testnode.js`
    command.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Node.js，它就可以运行你想要的任何 JavaScript 程序。你所要做的就是创建一个包含 JavaScript 代码的文件，例如，`testnode.js`。该文件的内容将由服务器使用
    `node testnode.js` 命令执行。
- en: 'Here is a very simple example of a JavaScript file that can be executed by
    Node.js: It displays a message in the server console. The server console here
    represents the command interpreter in which you type the command to execute the
    `testnode.js` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非常简单的 JavaScript 文件示例，它可以由 Node.js 执行：它在服务器控制台中显示一条消息。这里的“服务器控制台”代表命令解释器，你在其中输入命令以执行
    `testnode.js` 文件：
- en: testnode.js file
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: testnode.js 文件
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let’s type the command `node testnode.js` in the preceding terminal window.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在前面的终端窗口中输入命令 `node testnode.js`。
- en: '![Figure 1.4 – Running a Node.js program'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.4 – 运行 Node.js 程序'
- en: '](img/Figure_1.4_B17416.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.4_B17416.jpg]'
- en: Figure 1.4 – Running a Node.js program
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 运行 Node.js 程序
- en: We see that the message is displayed directly in the command interpreter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到消息直接显示在命令解释器中。
- en: 'In the previous examples, we have written JavaScript code that runs both on
    the client side (the browser) and on the server side. The question that can be
    asked is: can the same code run in exactly the same way on the client side and
    on the server side?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们编写的 JavaScript 代码既可以在客户端（浏览器）运行，也可以在服务器端运行。可以提出的问题是：相同的代码是否可以在客户端和服务器端以完全相同的方式运行？
- en: Differences between JavaScript code written for the browser and the server
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为浏览器和服务器编写的 JavaScript 代码之间的差异
- en: Although the two pieces of code are similar, we cannot say that they are the
    same, because the issues to be managed are different in the two cases. Indeed,
    on the client side, we will mainly want to manage the user interface with JavaScript,
    while on the server side, we will rather want to manage files or databases. So,
    the libraries to use in these two cases will not be the same.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两段代码很相似，但我们不能说它们是相同的，因为在两种情况下要处理的问题不同。实际上，在客户端，我们主要会想用 JavaScript 管理用户界面，而在服务器端，我们更想管理文件或数据库。因此，在这两种情况下要使用的库将不会相同。
- en: On the other hand, we find in both cases the same basic language, which is the
    JavaScript language that we will be describing now.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们在两种情况下都找到了相同的基本语言，那就是我们将要描述的 JavaScript 语言。
- en: Declaring variables in JavaScript
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JavaScript 中声明变量
- en: Variables of the types previously described under the *Types of variables used
    in JavaScript* section, as we know, consist of numerical values, Boolean values,
    character strings, arrays, and objects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在“JavaScript 中使用的变量类型”部分之前描述的变量类型，如我们所知，包括数值、布尔值、字符字符串、数组和对象。
- en: JavaScript is a weakly typed language, which means that you can change the type
    of a variable at any time. For example, a numeric variable can be transformed
    into a character string, or even become an array.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种弱类型语言，这意味着你可以在任何时候更改变量的类型。例如，数值变量可以被转换成字符字符串，甚至可以变成数组。
- en: Of course, it is not advisable to make such voluntary changes in our programs,
    and it is prudent to maintain the type of a variable throughout the program, for
    comprehension. However, it is important to know that JavaScript allows changing
    variable types. A variant of JavaScript called *TypeScript* provides more security
    by preventing these type changes for variables.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在程序中做出这样的自愿更改是不明智的，并且为了理解，保持变量的类型在整个程序中是谨慎的。然而，重要的是要知道 JavaScript 允许更改变量类型。一种名为
    *TypeScript* 的 JavaScript 变体通过防止这些类型更改来提供更多的安全性。
- en: 'Now let’s learn how to define a variable. We will do so using one of the following
    keywords: `const`, `var`, or `let`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何定义变量。我们将使用以下关键字之一：`const`、`var` 或 `let`。
- en: Using the const keyword
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 const 关键字
- en: The `const` keyword is used to define a variable whose value will be constant.
    Any subsequent attempt to change the value will produce an error.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 关键字用于定义一个值将保持不变的变量。任何后续尝试更改值都将产生错误。'
- en: 'Let’s define the constant variable `c1` having the value `12`. Let’s try to
    modify the value by assigning it a new value: an error will be displayed in the
    console:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个常量变量 `c1`，其值为 `12`。尝试修改其值，给它赋予一个新的值：控制台将显示错误：
- en: Note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To say that we are defining a constant variable is an abuse of language. We
    should rather say that we are defining a constant value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们定义一个常量变量称为语言上的滥用。我们更应该说我们在定义一个常量值。
- en: Defining a constant value (index.html file)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 定义常量值（index.html 文件）
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After implementing the preceding code, we will also see the error displayed
    in the console (if the console is not visible, it can be displayed by pressing
    the *F12* key) of the browser as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现前面的代码后，我们还将看到控制台（如果控制台不可见，可以通过按 *F12* 键显示）中显示的错误如下：
- en: '![Figure 1.5 – Error when modifying a constant value'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.5 – 修改常量值时的错误'
- en: '](img/Figure_1.5_B17416.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.5_B17416.jpg](img/Figure_1.5_B17416.jpg)'
- en: Figure 1.5 – Error when modifying a constant value
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.5 – 修改常量值时的错误
- en: As we can see from the preceding figure, the first display of the constant `c1`
    displays the value `const` keyword should not be modified.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中我们可以看到，常量 `c1` 的第一次显示值为 `const`，关键字不应被修改。
- en: Using the var keyword
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 var 关键字
- en: 'Another way to define a variable (whose value can be modified) is to use the
    `var` keyword. Let’s see how using the following code example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 定义变量（其值可以修改）的另一种方式是使用 `var` 关键字。让我们通过以下代码示例来看看如何使用：
- en: Definitions of several variables
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 几个变量的定义
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We defined the variables `a`, `b`, `s1`, and `firstname` by preceding them with
    the keyword `var` and assigning them a default value. The variable `c` corresponds
    to the addition of the variables `a` and `b`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在变量前加上关键字 `var` 并赋予它们默认值来定义变量 `a`、`b`、`s1` 和 `firstname`。变量 `c` 对应于变量 `a`
    和 `b` 的和。
- en: Note
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The name of a variable consists of alphanumeric characters but must start with
    an alphabetic character. Lowercase and uppercase are important in writing the
    variable name (variables’ names are case sensitive). Thus, the variable `a` is
    different from the variable `A`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的名称由字母数字字符组成，但必须以字母字符开头。在编写变量名称时，大小写很重要（变量的名称是区分大小写的）。因此，变量 `a` 与变量 `A` 不同。
- en: 'The result of the previous program is displayed in the browser console (if
    it is not visible, it must be displayed by pressing the *F12* key):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个程序的结果在浏览器控制台中显示（如果不可见，必须通过按 *F12* 键显示）：
- en: '![Figure 1.6 – Using the var keyword'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.6 – 使用 var 关键字'
- en: '](img/Figure_1.6_B17416.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.6_B17416.jpg](img/Figure_1.6_B17416.jpg)'
- en: Figure 1.6 – Using the var keyword
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.6 – 使用 var 关键字
- en: In the preceding figure, we can see a result that may seem surprising. Indeed,
    the direct calculation of `a + b` produces the display of **1256** the first time,
    then **68** the second time.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个可能看起来令人惊讶的结果。确实，`a + b` 的直接计算第一次显示为 **1256**，然后第二次显示为 **68**。
- en: Indeed, when we write `console.log("a + b = " + a + b);` the fact that we’ve
    started to display characters by writing `"a + b = "` means that JavaScript will
    interpret the rest of the display in the form of a character string; in particular,
    the values `a` and `b`, which follow on the line. So, the values `a` and `b` are
    no longer interpreted as numeric values, but as the character strings `12` and
    `56`. When these character strings are connected by the `+` operator, this does
    not correspond to addition but to concatenation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当我们写 `console.log("a + b = " + a + b);` 时，我们开始通过写入 `"a + b = "` 来显示字符的事实意味着
    JavaScript 将将显示的其余部分解释为字符字符串；特别是，位于同一行的 `a` 和 `b` 的值。因此，`a` 和 `b` 的值不再被解释为数值，而是作为字符字符串
    `12` 和 `56`。当这些字符字符串通过 `+` 运算符连接时，这并不对应于加法，而是连接。
- en: Conversely, the calculation of the variable `c` does not involve character strings,
    so the result of `a + b` here is equal to the sum of the values of the variables
    `a` and `b`, therefore **68**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，变量 `c` 的计算不涉及字符字符串，因此这里 `a + b` 的结果是变量 `a` 和 `b` 的值的总和，因此 **68**。
- en: 'Note that the same program can be run on the Node.js server. To do so, we would
    write it in our `testnode.js` file as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，同样的程序可以在 Node.js 服务器上运行。为此，我们可以在 `testnode.js` 文件中这样编写：
- en: testnode.js file
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: testnode.js 文件
- en: '[PRE65]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can then execute the preceding code with the `node testnode.js` command.
    The result displayed under Node.js is similar to that displayed in the browser
    console:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `node testnode.js` 命令执行前面的代码。在 Node.js 下显示的结果与在浏览器控制台显示的结果相似：
- en: '![Figure 1.7 – Running the program under Node.js'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – 在 Node.js 下运行程序'
- en: '](img/Figure_1.7_B17416.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.7_B17416.jpg](img/Figure_1.7_B17416.jpg)'
- en: Figure 1.7 – Running the program under Node.js
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 在 Node.js 下运行程序
- en: We learned about the `const` and `var` keywords for defining variables; all
    that remains is for us to learn how to use the `let` keyword.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了用于定义变量的 `const` 和 `var` 关键字；现在我们还需要学习如何使用 `let` 关键字。
- en: Using the let keyword
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 let 关键字
- en: To understand the use of the `let` keyword and see the difference from the `var`
    keyword, we must use braces in our programs. Braces are used to create program
    blocks in which instructions are inserted, in particular after the conditional
    `if` and `else` instructions (which we will see in the *Writing conditions* section).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 `let` 关键字的使用并看到它与 `var` 关键字的区别，我们必须在我们的程序中使用大括号。大括号用于创建程序块，在其中插入指令，特别是在条件
    `if` 和 `else` 指令之后（我们将在 *编写条件* 部分看到）。
- en: 'Let’s write a simple `if(true)` condition that is always `true`: the code included
    in the braces following the condition is therefore always executed:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的 `if(true)` 条件，它总是 `true`：因此，条件后面的括号内的代码总是被执行：
- en: index.html file including a condition
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 包含条件的 index.html 文件
- en: '[PRE73]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In the preceding code, we have defined the variable `a` outside of any braces.
    This variable will therefore be accessible everywhere (in and out of braces) as
    soon as it is defined.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在任何大括号之外定义了变量 `a`。因此，一旦定义，这个变量将在任何地方（包括和不包括大括号）都是可访问的。
- en: The variables `b` and `c` are defined within braces following the condition.
    Variable `b` is defined using `var`, while variable `c` is defined using the `let`
    keyword. The difference between the two variables is visible as soon as you exit
    the block of braces. Indeed, the variable `c` (defined by `let`) is no longer
    known outside the block of braces where it is defined, unlike the variable `b`
    (defined by `var`), which is accessible even outside.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `b` 和 `c` 在条件之后的大括号内定义。变量 `b` 使用 `var` 定义，而变量 `c` 使用 `let` 关键字定义。两个变量之间的区别在退出大括号块时就会显现出来。确实，变量
    `c`（由 `let` 定义）在其定义的大括号块外部不再被识别，而变量 `b`（由 `var` 定义）即使在块外部也是可访问的。
- en: 'This can be checked by running the program in the browser as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在浏览器中按如下方式运行程序来检查：
- en: '![Figure 1.8 – The variable c defined by let is inaccessible outside the block
    where it is defined'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8 – 由 let 定义的变量 c 在其定义的块外部不可访问'
- en: '](img/Figure_1.8_B17416.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.8_B17416.jpg](img/Figure_1.8_B17416.jpg)'
- en: Figure 1.8 – The variable c defined by let is inaccessible outside the block
    where it is defined
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 由 let 定义的变量 c 在其定义的块外部不可访问
- en: 'Note that the same program gives a similar result on the Node.js server, as
    can be seen in the following screen: the variable `c` defined by `let` in a block
    becomes unknown outside the block.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，同样的程序在 Node.js 服务器上也会得到类似的结果，如下面的屏幕截图所示：使用 `let` 定义的变量 `c` 在块外部变得不可知。
- en: '![Figure 1.9 – The same results on the Node.js server'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – Node.js 服务器上的相同结果'
- en: '](img/Figure_1.9_B17416.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.9_B17416.jpg)'
- en: Figure 1.9 – The same results on the Node.js server
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – Node.js 服务器上的相同结果
- en: As we can see in the preceding screen, the variable `c`, defined by `let` in
    a block, becomes unknown outside the block.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的屏幕上所看到的，由 `let` 在块中定义的变量 `c` 在块外变得不可知。
- en: What if we don’t use var or let to define a variable?
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果我们不使用 var 或 let 来定义一个变量会怎样？
- en: 'It is possible not to use the `var` or `let` keywords to define a variable.
    We can simply write the variable’s name followed by its value (separated by the
    sign `=`). Let’s see how using the following example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能不使用 `var` 或 `let` 关键字来定义一个变量。我们可以简单地写出变量的名称，然后写出它的值（由 `=` 符号分隔）。让我们通过以下示例看看这样做会怎样：
- en: Creating variables without specifying var or let
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 不指定 var 或 let 创建变量
- en: '[PRE95]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the preceding example, where the variables are initialized without being
    preceded by `var` or `let`, these variables are global variables. As soon as they
    are initialized, they become accessible everywhere else in the program. This will
    become apparent when we study the functions in the *Using functions* section of
    this chapter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，变量在没有 `var` 或 `let` 前被初始化，这些变量是全局变量。一旦它们被初始化，它们就可以在程序的其他任何地方访问。当我们学习本章
    *使用函数* 部分的函数时，这一点将变得明显。
- en: Note
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is strongly advised to use as few global variables as possible in the programs,
    as this complicates the design and debugging of the programs that contain them.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议在程序中尽可能少地使用全局变量，因为这会复杂化包含它们的程序的设计和调试。
- en: What is an uninitialized variable worth?
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未初始化的变量有什么价值？
- en: 'Each of the preceding variables was declared by initializing its value, with
    the `=` sign, which is the assignment sign. Let’s see what happens if we don’t
    assign any value to the variable, but just declare it using `var` or `let` as
    follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的每个变量都是通过初始化其值（使用 `=` 符号，即赋值符号）来声明的。让我们看看如果我们不对变量赋值，只使用 `var` 或 `let` 声明会发生什么：
- en: Declaration of variables without initialization
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化的变量声明
- en: '[PRE99]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: In the preceding code, we have defined two variables, `a` and `b` – one using
    `var`, the other using `let`. Neither of the two variables has an initial value
    (that is, they’re not followed by an `=` sign).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个变量，`a` 和 `b` – 一个使用 `var`，另一个使用 `let`。这两个变量都没有初始值（也就是说，它们后面没有
    `=` 符号）。
- en: The result displayed in this case for these uninitialized variables is a JavaScript
    value called `undefined`. This corresponds to the value of a variable that does
    not yet have a value. The `undefined` value is an important keyword in the JavaScript
    language.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于这些未初始化的变量显示的结果是 JavaScript 中的一个值，称为 `undefined`。这对应于尚未有值的变量。`undefined`
    值是 JavaScript 语言中的一个重要关键字。
- en: Note
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The variables `a` and `b` are not initialized, and it is necessary to declare
    them using `var` or `let`. Indeed, you cannot simply write `a;` or `b;` as this
    would cause a runtime error.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `a` 和 `b` 没有被初始化，必须使用 `var` 或 `let` 来声明它们。实际上，你不能简单地写 `a;` 或 `b;`，因为这会导致运行时错误。
- en: 'Let’s run the preceding program in the browser and observe the results displayed
    in the console:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中运行前面的程序，并观察控制台显示的结果：
- en: '![Figure 1.10 – An uninitialized variable is undefined'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – 未初始化的变量是未定义的'
- en: '](img/Figure_1.10_B17416.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.10_B17416.jpg)'
- en: Figure 1.10 – An uninitialized variable is undefined
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 未初始化的变量是未定义的
- en: Note
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `undefined` value is also associated with an uninitialized variable if using
    server-side JavaScript with Node.js.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Node.js 服务器端的 JavaScript，`undefined` 值也与未初始化的变量相关联。
- en: We now know how to define variables in JavaScript. To create useful JavaScript
    programs, you have to write sequences of instructions. One of the most used instructions
    allows you to write conditional tests with the `if` statement, which we will talk
    about next.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了如何在 JavaScript 中定义变量。要创建有用的 JavaScript 程序，你必须编写一系列指令。最常用的指令之一允许你使用 `if`
    语句编写条件测试，我们将在下一节讨论这一点。
- en: Writing conditions for conditional tests
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写条件测试的条件
- en: 'JavaScript obviously allows you to write conditions in programs. The condition
    is expressed through the `if (condition)` statement:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 显然允许你在程序中编写条件。条件通过 `if (condition)` 语句表达：
- en: If the condition is `true`, the statement (or block in braces) that follows
    is executed.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果条件是 `true`，则执行后面的语句（或花括号中的块）。
- en: If the condition is `false`, the statement (or block) following the `else` keyword
    (if present) will be executed.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果条件为 `false`，则执行 `else` 关键字后面的语句（如果存在）。
- en: Forms of writing instructions
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写指令的形式
- en: 'We can use the following forms to express the conditions:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下形式来表示条件：
- en: Forms of conditional expressions with if (condition)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 if (condition) 的条件表达式形式
- en: '[PRE114]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Forms of conditional expressions with if (condition) … else …
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 if (condition) … else … 的条件表达式形式
- en: '[PRE123]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Note
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the process to be executed includes several instructions, these instructions
    are grouped together in a block surrounded by braces. A block can consist of only
    one statement, even if, as in this case, the block is optional (no need for braces).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要执行的过程包含多个指令，这些指令将组合在一起，用大括号括起来形成一个块。一个块可以只包含一个语句，即使在这个情况下，块是可选的（不需要大括号）。
- en: 'Let’s write the following program in the `testnode.js` file, which we will
    execute using the `node testnode.js` command in a command interpreter, as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `testnode.js` 文件中编写以下程序，我们将使用命令解释器中的 `node testnode.js` 命令来执行它，如下所示：
- en: testnode.js file
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: testnode.js 文件
- en: '[PRE141]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: In the preceding code, the condition is expressed in the form `a == 12`. Indeed,
    it is customary to test the equality between two values by means of the sign `=`
    repeated twice successively (hence `==`).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，条件以 `a == 12` 的形式表达。实际上，习惯上通过连续两次重复使用等号 `=` 来测试两个值之间的相等性（因此是 `==`）。
- en: Note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We use `==` for equality, `!=` for difference, `>` or `>=` to check superiority,
    and `<` or `<=` to check inferiority.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `==` 表示相等，`!=` 表示不等，`>` 或 `>=` 检查大于或等于，`<` 或 `<=` 检查小于或等于。
- en: 'In the preceding code, since the variable `a` is `12`, the following result
    can be seen:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，由于变量 `a` 的值为 `12`，可以看到以下结果：
- en: '![Figure 1.11 – Using conditional tests'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11 – 使用条件测试'
- en: '](img/Figure_1.11_B17416.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_1.11_B17416.jpg)'
- en: Figure 1.11 – Using conditional tests
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 使用条件测试
- en: 'If we assign the value `13` to the variable `a`, the `else` part of the statement
    will be executed:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将值 `13` 赋给变量 `a`，则语句的 else 部分将被执行：
- en: '![Figure 1.12 – Running the else part of the test'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12 – 运行测试的 else 部分'
- en: '](img/Figure_1.12_B17416.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_1.12_B17416.jpg)'
- en: Figure 1.12 – Running the else part of the test
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 运行测试的 else 部分
- en: We have seen how to execute one part of the code or another depending on a condition.
    Let’s now study how to write more complex conditions than those written previously.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何根据条件执行代码的一部分或另一部分。现在让我们研究如何编写比之前写过的更复杂的条件。
- en: Expressions used to write conditions
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于编写条件的表达式
- en: The condition written previously is a simple test of equality between two values.
    But the test to write can sometimes be more complex. The goal is to have the final
    result of the condition, which is `true` or `false`, which will then make it possible
    for the system to decide the next course of action.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 之前编写的条件是两个值之间简单相等性的测试。但有时需要编写的测试可能更复杂。目标是得到条件的最终结果，即 `true` 或 `false`，这将使系统能够决定下一步的行动。
- en: 'The condition is written in Boolean form with the *OR* keyword (written as
    `||`) or with the *AND* keyword (written as `&&`). Parentheses between the different
    conditions may be necessary to express the final condition as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 条件用布尔形式书写，使用 *OR* 关键字（写作 `||`）或使用 *AND* 关键字（写作 `&&`）。不同条件之间可能需要括号来表示最终条件，如下所示：
- en: Condition expressed with “or”
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 “or” 表达的条件
- en: '[PRE145]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: In the preceding code, since the variable `b` is greater than 50, the condition
    is `true`, as seen in *Figure 1.13*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，由于变量 `b` 大于 50，条件为 `true`，如 *图 1.13* 所示。
- en: Note
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In an *OR* condition, it suffices that one of the conditions is `true` for the
    final condition to be `true`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *OR* 条件中，只要其中一个条件为 `true`，最终条件就为 `true`。
- en: In an *AND* condition, all the conditions must be `true` for the final condition
    to be `true`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *AND* 条件中，所有条件都必须为 `true`，最终条件才为 `true`。
- en: '![Figure 1.13 – Condition with or'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.13 – 使用 or 条件'
- en: '](img/Figure_1.13_B17416.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_1.13_B17416.jpg)'
- en: Figure 1.13 – Condition with or
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – 使用 or 条件
- en: By default, the condition expressed in `if(condition)` is compared with the
    value `true`. We can sometimes prefer to compare with the value `false`. In this
    case, it suffices to precede the condition with the sign `!`, which corresponds
    to a negation of the following condition.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`if(condition)` 中表达的条件与值 `true` 进行比较。有时我们可能更喜欢与值 `false` 进行比较。在这种情况下，只需在条件前加上符号
    `!` 即可，这对应于对后续条件的否定。
- en: It is sometimes necessary to chain several tests in a row, depending on the
    results of the previous tests. We then have a succession of tests, called cascade
    tests.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要根据前一个测试的结果连续进行几个测试。这时，我们就有了一系列的测试，称为级联测试。
- en: Nested test suites
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套测试套件
- en: 'It is possible to chain tests in the processes to be performed. Here is an
    example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在要执行的过程中可以链式测试。以下是一个示例：
- en: Test nesting
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 测试嵌套
- en: '[PRE151]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The `else` part is composed of several statements and is grouped in a block
    surrounded by braces:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 部分由多个语句组成，并放在由大括号包围的块中：'
- en: '![Figure 1.14 – Test nesting'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.14 – 测试嵌套'
- en: '](img/Figure_1.14_B17416.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.14_B17416.jpg)'
- en: Figure 1.14 – Test nesting
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – 测试嵌套
- en: We learned about writing conditions in JavaScript programs. We are now going
    to learn how to write processing loops, which make it possible to write the instructions
    in the program only once. These instructions can, however, be executed as many
    times as necessary.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何在 JavaScript 程序中编写条件。现在我们将学习如何编写处理循环，这使得在程序中只需编写一次指令成为可能。然而，这些指令可以根据需要执行多次。
- en: Creating processing loops
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建处理循环
- en: It is sometimes necessary to repeat an instruction (or a block of instructions)
    several times. Rather than writing it several times in the program, we put it
    in a processing loop. These instructions will be repeated as many times as necessary.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要多次重复一个指令（或指令块）。而不是在程序中多次编写它，我们将其放入处理循环中。这些指令将根据需要重复执行多次。
- en: 'Two types of processing loops are possible in JavaScript:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中有两种处理循环类型：
- en: Loops with the `while()` statement
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `while()` 语句的循环
- en: Loops with the `for()` statement
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `for()` 语句的循环
- en: Let’s take a look at these two types of loops.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这两种循环类型。
- en: Loops with while()
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `while()` 循环
- en: The `while(condition)` instruction allows you to repeat the instruction (or
    the block of instructions) that follows. As long as the condition is `true`, the
    statement (or block) is executed. It stops when the condition becomes `false`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`while(condition)` 指令允许你重复执行后面的指令（或指令块）。只要条件为 `true`，就会执行该语句（或块）。当条件变为 `false`
    时停止执行。'
- en: 'Using this `while()` statement, let’s display the numbers from `0` to `5`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 `while()` 语句，让我们显示从 `0` 到 `5` 的数字：
- en: Displaying numbers from 0 to 5
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 显示从 0 到 5 的数字
- en: '[PRE161]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The preceding `console.log()` instruction is written only once in the program,
    but as it is inserted in a loop (`while()` instruction), it will be repeated as
    many times as the condition is `true`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `console.log()` 指令在程序中只写一次，但由于它被插入到循环（`while()` 指令）中，所以当条件为 `true` 时，它将被重复执行多次。
- en: 'The variable `i` allows you to manage the condition in the loop. The variable
    `i` is incremented by 1 (by `i++`) at each pass through the loop, and we stop
    when the value `5` is exceeded:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `i` 允许你在循环中管理条件。每次通过循环时，变量 `i` 都会增加 1（通过 `i++`），并且当值超过 `5` 时我们停止：
- en: '![Figure 1.15 – Displaying numbers from 0 to 5'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.15 – 显示数字从 0 到 5'
- en: '](img/Figure_1.15_B17416.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.15_B17416.jpg)'
- en: Figure 1.15 – Displaying numbers from 0 to 5
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 显示数字从 0 到 5
- en: 'We can verify that this program works in a similar way on the client side,
    that is to say in a web browser, as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证这个程序在客户端（即网页浏览器）中以类似的方式工作，如下所示：
- en: Displaying digits 0–5 in a browser console
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器控制台中显示数字 0–5
- en: '[PRE166]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The result is displayed similarly in the browser console:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在浏览器控制台中以类似的方式显示：
- en: '![Figure 1.16 – Displaying numbers from 0 to 5 in the browser console'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.16 – 在浏览器控制台中显示从 0 到 5 的数字'
- en: '](img/Figure_1.16_B17416.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.16_B17416.jpg)'
- en: Figure 1.16 – Displaying numbers from 0 to 5 in the browser console
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 在浏览器控制台中显示从 0 到 5 的数字
- en: Loops with for()
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `for()` 循环
- en: Another widely used form of loop is one with a `for()` statement. It simplifies
    the writing of the previous loop by reducing the number of instructions to write.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种广泛使用的循环形式是使用 `for()` 语句的循环。它通过减少要编写的指令数量来简化前面循环的编写。
- en: 'Let’s write the same program as before to display the numbers from 0 to 5 using
    a `for()` statement instead of the `while()` statement:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `for()` 语句而不是 `while()` 语句编写与之前相同的程序来显示从 0 到 5 的数字：
- en: '[PRE180]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: As we can see in the preceding code, a single line replaces several lines as
    in the previous instance.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，一行代码可以替代几行代码。
- en: 'The `for()` statement has three parts, separated by a `;`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`for()` 语句有三个部分，由 `;` 分隔：'
- en: The first corresponds to the initialization instruction. Here, it is the declaration
    of the variable `i` initialized to `0` (which is the beginning of the loop).
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个对应于初始化指令。在这里，它是变量 `i` 的声明，初始化为 `0`（这是循环的开始）。
- en: 'The second corresponds to the condition: as long as this condition is `true`,
    the statement (or the block that follows) is executed. Here, the condition corresponds
    to the fact that the variable `i` has not exceeded the final value `5`.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个对应于条件：只要这个条件是 `true`，就会执行语句（或随后的语句块）。在这里，条件对应于变量 `i` 没有超过最终值 `5`。
- en: The third corresponds to an instruction executed after each pass through the
    loop. Here, we increment the variable `i` by 1\. This ensures that at some point,
    the condition will be `false`, in order to exit the loop.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个对应于每次循环迭代后执行的指令。在这里，我们通过1增加变量 `i`。这确保了在某个时刻，条件将变为 `false`，以便退出循环。
- en: 'Let’s verify that it works identically to the `while()` statement:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证它是否与 `while()` 语句完全相同：
- en: '![Figure 1.17 – Loop with the for() statement'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.17 – 使用for()语句的循环'
- en: '](img/Figure_1.17_B17416.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.17_B17416.jpg)'
- en: Figure 1.17 – Loop with the for() statement
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17 – 使用for()语句的循环
- en: In this section, we learned how to write sequences of statements that will be
    executed multiple times, using the `while()` and `for()` statements. Now let’s
    look at how to group statements together, using what are called functions.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 `while()` 和 `for()` 语句编写将被多次执行的语句序列。现在让我们看看如何使用所谓的函数来组合语句。
- en: Using functions
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数
- en: 'A function is used to give a name to a block of instructions so that it can
    be used in different places in the program. In general, in a function, we group
    a set of instructions that are used to carry out a particular task, for example:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 函数用于给一组指令命名，以便可以在程序的不同地方使用。通常，在函数中，我们将一组用于执行特定任务的指令分组，例如：
- en: Display the list of the first 10 integers.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示前10个整数的列表。
- en: Calculate the sum of the first 10 numbers (from 0 to 9).
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算前10个数字（从0到9）的和。
- en: Calculate the sum of the first N numbers (from 0 to N-1). In this case, `N`
    would be a parameter of the function because it can change with each call (or
    use) of the function.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算前N个数字（从0到N-1）的和。在这种情况下，`N` 将是函数的一个参数，因为每次调用（或使用）函数时它都可能改变（或使用）。
- en: The functions described above are very simple but show that the role of functions
    is to encapsulate any process by summarizing in one sentence what is expected
    of this process. The name given to the function symbolizes the action expected
    in return, which allows the developer to easily understand the sequence of instructions
    (including for an external developer who has not participated in the development).
    Let’s discuss the three functions we listed one by one.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述的函数非常简单，但展示了函数的作用是通过总结一句话来封装任何过程。赋予函数的名称象征着期望执行的动作，这允许开发者轻松理解指令序列（包括未参与开发的外部开发者）。让我们逐一讨论我们列出的三个函数。
- en: Function displaying the list of the first 10 integers
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示前10个整数的函数
- en: Let’s write the first function, which displays the list of the first 10 integers.
    We will call this function `display_10_first_integers()`. The name must be as
    explicit as possible because a JavaScript program is composed of many functions
    whose names must be unique in the program (if two function names are the same,
    only the last one is taken into account because it overwrites the former).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写第一个函数，该函数显示前10个整数的列表。我们将把这个函数命名为 `display_10_first_integers()`。名称必须尽可能明确，因为一个JavaScript程序由许多函数组成，这些函数的名称在程序中必须是唯一的（如果两个函数名称相同，则只考虑最后一个，因为它会覆盖前面的）。
- en: A function is defined using the keyword `function`, followed by the name of
    the function, followed by parentheses. Then, we indicate in the braces that follow
    the instructions that make up the function. It is this instruction block that
    will be executed each time the function is called in the program.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是通过使用关键字 `function`，然后是函数的名称，然后是括号来定义的。然后，我们在随后的花括号中指示组成函数的指令。每次在程序中调用函数时，将执行这个指令块。
- en: 'Let’s write the function `display_10_first_integers()`, which displays the
    first 10 integers:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写函数 `display_10_first_integers()`，该函数显示前10个整数：
- en: Display first 10 integers with a function (testnode.js file)
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数显示前10个整数（testnode.js文件）
- en: '[PRE181]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: The function is defined using the `function` keyword, followed by the function
    name and parentheses.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用 `function` 关键字定义，后跟函数名和括号。
- en: The function statements are grouped in the block that follows between the braces.
    We find as instructions the previous `for()` loop, but it could also be the `while()`
    loop, which works in the same way.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明被分组在接下来的花括号之间的块中。我们找到了之前的 `for()` 循环作为指令，但它也可能是 `while()` 循环，它们的工作方式相同。
- en: 'Let’s run this program assuming it’s included in the `testnode.js` file:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 假设它包含在 `testnode.js` 文件中，让我们运行这个程序：
- en: '![Figure 1.18 – Using a function to display numbers from 1 to 10'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.18 – 使用函数显示 1 到 10 的数字'
- en: '](img/Figure_1.18_B17416.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.18_B17416.jpg)'
- en: Figure 1.18 – Using a function to display numbers from 1 to 10
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18 – 使用函数显示 1 到 10 的数字
- en: As we can see in the preceding figure, the screen remains blank as no display
    is registered in the console.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，屏幕保持空白，因为在控制台中没有注册任何显示。
- en: 'Indeed, we have simply defined the function, but we must also use it, that
    is, call it in our program. You can call it as many times as you want – this is
    the purpose of functions: we should be able to call (or use) them at any time.
    But it must be done at least once; otherwise, it is useless, as seen in the preceding
    figure.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们只是简单地定义了函数，但我们还必须使用它，即在程序中调用它。你可以按需多次调用它——这是函数的目的：我们应该能够在任何时间调用（或使用）它们。但至少必须调用一次；否则，它就毫无用处，如前图所示。
- en: 'Let’s add the function call following the function definition:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在函数定义之后添加函数调用：
- en: Definition and call of the function
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的定义和调用
- en: '[PRE184]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'The result of the preceding code can be seen in the following figure:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的结果可以在以下图中看到：
- en: '![Figure 1.19 – Call of the display_10_first_integers() function'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.19 – 调用 display_10_first_integers() 函数'
- en: '](img/Figure_1.19_B17416.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.19_B17416.jpg)'
- en: Figure 1.19 – Call of the display_10_first_integers() function
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19 – 调用 display_10_first_integers() 函数
- en: 'Interestingly, the function can be called in several places of the program.
    Let’s see how in the following example:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，函数可以在程序的多个地方调用。让我们在以下示例中看看如何：
- en: Successive calls to the display_10_first_integers() function
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 依次调用 display_10_first_integers() 函数
- en: '[PRE190]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'In the preceding code, the function is called three times in succession, which
    displays the list of the first 10 integers as many times. The order of the calls
    is indicated before each list as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，函数连续调用了三次，显示前 10 个整数的列表多次。每次调用前的顺序如下所示：
- en: '![Figure 1.20 – Successive calls to the display_10_first_integers() function'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.20 – 依次调用 display_10_first_integers() 函数'
- en: '](img/Figure_1.20_B17416.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.20_B17416.jpg)'
- en: Figure 1.20 – Successive calls to the display_10_first_integers() function
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – 依次调用 display_10_first_integers() 函数
- en: Function calculating the sum of the first 10 integers
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算前 10 个整数和的函数
- en: We now want to create a function that calculates the sum of the first 10 integers,
    that is, `1+2+3+4+5+6+7+8+9+10`. The result is `55`. This will allow us to show
    how a function can return a result to the outside (that is, to the program that
    uses it). Here, the function should return `55`.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要创建一个函数，该函数计算前 10 个整数的和，即 `1+2+3+4+5+6+7+8+9+10`。结果是 `55`。这将使我们能够展示函数如何将结果返回到外部（即使用它的程序）。在这里，函数应该返回
    `55`。
- en: 'Let’s call the function `add_10_first_integers()`. This can be written as follows:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用函数 `add_10_first_integers()`。它可以写成以下形式：
- en: Function that adds the first 10 integers
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 添加前 10 个整数的函数
- en: '[PRE201]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: We define the `total` variable in the function. This variable is a local variable
    to the function because it is defined using the `var` or `let` keyword. This allows
    this `total` variable to not be the same as the one defined outside the function,
    even if the names are the same.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数中定义了 `total` 变量。因为这个变量是使用 `var` 或 `let` 关键字定义的，所以它是函数的局部变量。这允许这个 `total`
    变量与函数外部定义的变量不同，即使名称相同。
- en: Note
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the `total` variable in the function was not defined using the `var` or `let`
    keyword, it would create a so-called global variable that would be directly accessible
    even outside the function. This is not good programming because you want to use
    global variables as little as possible.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数中的 `total` 变量不是使用 `var` 或 `let` 关键字定义的，它将创建一个所谓的全局变量，该变量即使在函数外部也可以直接访问。这不是好的编程，因为你希望尽可能少地使用全局变量。
- en: The function uses a `for()` loop to add the first 10 integers, then returns
    that total using the `return` keyword. This keyword makes it possible to make
    accessible, outside the function, the value of any variable, in our example, the
    `total` variable.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用 `for()` 循环来累加前 10 个整数，然后使用 `return` 关键字返回这个总和。这个关键字使得在函数外部可以访问任何变量的值，在我们的例子中，是
    `total` 变量。
- en: 'Let’s run the previous program. We should see the following output:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行之前的程序。我们应该看到以下输出：
- en: '![Figure 1.21 – Calculation of the sum of the first 10 integers'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.21 – 计算前 10 个整数的和'
- en: '](img/Figure_1.21_B17416.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.21_B17416.jpg)'
- en: Figure 1.21 – Calculation of the sum of the first 10 integers
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21 – 计算前 10 个整数的和
- en: Function calculating the sum of the first N integers
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算前 N 个整数和的函数
- en: The previous function is not very useful because it always returns the same
    result. A more useful function would be to calculate the sum of the first `N`
    integers, knowing that `N` can be different each time the function is called.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的函数不是很实用，因为它总是返回相同的结果。一个更有用的函数是计算前 `N` 个整数的和，其中 `N` 可以在每次函数调用时不同。
- en: '`N` would in this case be a parameter of the function. Its value is indicated
    in parentheses when using the function.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`N` 将是函数的一个参数。它的值在使用函数时在括号中指示。
- en: Let’s call the `add_N_first_integers()`function to calculate this sum. The `N`
    parameter would be indicated in parentheses following the function name. A function
    can use several parameters, and it suffices to indicate them in succession, separated
    by a comma. In our example, a single parameter is enough.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用 `add_N_first_integers()` 函数来计算这个和。参数 `N` 将在函数名称后面的括号中指示。一个函数可以使用多个参数，只需按顺序用逗号分隔即可。在我们的例子中，一个参数就足够了。
- en: 'Let’s write the `add_N_first_integers(n)`function and use that to calculate
    the sum of the first 10, then 25, then 100 integers. The values 10, 25, and 100
    will be used as parameters during successive calls to the function and will replace
    the parameter `n` indicated in the definition of the function:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写 `add_N_first_integers(n)` 函数，并使用它来计算前 10 个、然后 25 个、然后 100 个整数的和。在函数连续调用过程中，将使用值
    10、25 和 100 作为参数，并将替换函数定义中指示的参数 `n`：
- en: Function that adds the first N integers
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 添加前 N 个整数的函数
- en: '[PRE210]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: The `add_N_first_integers(n)` function is very similar to the `add_10_first_integers()`
    function written earlier. It uses the parameter `n` indicated between the parentheses
    and does not loop from `0` to `10` as before, but from `0` to `n`. Depending on
    the value of `n` that will be used when calling the function, the loop will thus
    be different, and the result returned by the function as well.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_N_first_integers(n)` 函数与之前编写的 `add_10_first_integers()` 函数非常相似。它使用括号中指示的参数
    `n`，并且不像之前那样从 `0` 到 `10` 循环，而是从 `0` 到 `n`。根据调用函数时使用的 `n` 的值，循环将不同，函数返回的结果也将不同。'
- en: 'When calling the function, it passes the parameters `10`, `25`, then `100`
    as desired. The result is returned by the function’s `total` variable, and then
    used by the `total_10`, `total_25`, and `total_100` variables outside the function:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数时，它传递参数 `10`、`25`，然后 `100`，正如所期望的那样。函数的 `total` 变量返回结果，然后由函数外部的 `total_10`、`total_25`
    和 `total_100` 变量使用：
- en: '![Figure 1.22 – Calculation of the sum of the first 10, then 25, then 100 integers'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.22 – 计算前 10 个、然后 25 个、然后 100 个整数的和'
- en: '](img/Figure_1.22_B17416.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.22_B17416.jpg)'
- en: Figure 1.22 – Calculation of the sum of the first 10, then 25, then 100 integers
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22 – 计算前 10 个、然后 25 个、然后 100 个整数的和
- en: Summary
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The basic features of JavaScript have been covered in this chapter: variables
    with different types, conditional tests, loops, and functions. They are used on
    the client side and on the server side.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 JavaScript 的基本特性：不同类型的变量、条件测试、循环和函数。它们在客户端和服务器端都得到应用。
- en: In the next chapter, we’ll take a look at some more in-depth features of JavaScript,
    such as object-oriented programming with JavaScript.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 JavaScript 的更多深入特性，例如使用 JavaScript 进行面向对象编程。
