- en: Onboarding Types with Primitive
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原始类型引入类型
- en: Primitive types are all the basic supported categories of value. Each type represents
    a domain of values in which the integrity of the format is enforced. JavaScript
    has a limited set of primitives that can only be inferred by the assignation of
    a value to a variable. For example, a value can be a number, a date, a Boolean,
    a string, and so on. The assignation of a subsequent value of a different model
    to a singular variable is permitted. The side effect is the mutation of the type,
    which increases the complexity of any JavaScript program. TypeScript, however,
    can enforce type immutability, which reduces the risk of a potential wrong value
    that misleads the proper execution of the application. Also, TypeScript provides
    support on which operation can be used, depending on which explicit type is attached
    to a particular value. This chapter illustrates the scoping of a variable, the
    subtlety between an undefined variable and a null variable, and how to make a
    variable optional or required. At the end of this chapter, the reader will be
    in a situation where all the variables will be declared properly, with an accurate
    type supported by TypeScript. The distinction between a primitive and a non-primitive
    type will no longer be a conundrum. The use of `enum` or symbol will be natural
    and the creation of new types will become a habit any time a new domain object
    is introduced in your system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型是所有基本支持的价值类别。每种类型代表一个值域，其中格式的一致性得到强制执行。JavaScript 有一个有限的原始类型集合，这些类型只能通过将值分配给变量来推断。例如，一个值可以是数字、日期、布尔值、字符串等。将不同模型的后继值分配给单个变量是允许的。副作用是类型的突变，这增加了任何
    JavaScript 程序的复杂性。然而，TypeScript 可以强制类型不可变性，这降低了潜在错误值误导应用程序正确执行的风险。此外，TypeScript
    根据附加到特定值的显式类型提供对哪些操作可以使用支持。本章说明了变量的作用域、未定义变量和空变量之间的细微差别，以及如何使变量可选或必需。在本章结束时，读者将处于所有变量都正确声明、由
    TypeScript 支持准确类型的情况。原始类型和非原始类型之间的区别将不再是一个难题。使用 `enum` 或 `symbol` 将变得自然，每当在系统中引入新的域对象时，创建新类型将变成一种习惯。
- en: 'This chapter will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: The difference between `var`, `let`, and `const`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`、`let` 和 `const` 之间的区别'
- en: How to be strongly typed without specifying the type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在不指定类型的情况下进行强类型声明
- en: The difference between var, let, and const
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: var、let 和 const 之间的区别
- en: 'TypeScript has many ways to declare a variable. You can define a variable at
    a function or global scope using one of the three following keywords: `var`, `let`,
    and `const`. Also, you can define a variable with `public`, `private`, or `protected`
    at the class level.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 有多种声明变量的方式。你可以使用以下三个关键字之一在函数或全局作用域中定义变量：`var`、`let` 和 `const`。此外，你还可以在类级别上使用
    `public`、`private` 或 `protected` 来定义变量。
- en: Declaring with var
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `var` 声明
- en: 'The most basic way to declare a variable is by using the keyword `var`.  It
    is the oldest declaration, but the least-preferred way because of some quirks.
    The main issue with `var` is that it gets declared in the execution context, which
    means inside the function scope or at the global scope. If, by accident a value
    is assigned to a variable not explicitly declared with `var`, then the scope of
    the variable is at the global scope. Here is an example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量的最基本方式是使用关键字 `var`。它是最古老的声明方式，但由于一些怪癖，它是最不受欢迎的方式。`var` 的主要问题是它在执行上下文中声明，这意味着在函数作用域或全局作用域内。如果意外地将值分配给未显式使用
    `var` 声明的变量，那么该变量的作用域就是全局作用域。以下是一个例子：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A `var` declaration can be made stricter with the strict mode in JavaScript
    so that TypeScript can turn on every file automatically by using `alwaysStrict`
    in its compiler''s options. Otherwise, you must remember that `var`–declared variables
    are created before the execution of the code. Variables without the keyword `var`
    do not exist until the code assigning them is executed. In JavaScript, it''s possible
    to assign a variable without declaring, which is not the case with TypeScript:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 声明可以通过 JavaScript 的严格模式变得更加严格，这样 TypeScript 可以通过编译器选项中的 `alwaysStrict`
    自动在每一个文件上开启。否则，你必须记住 `var` 声明的变量是在代码执行之前创建的。没有 `var` 关键字的变量直到分配给它们的代码执行时才存在。在
    JavaScript 中，可以不声明就分配变量，但在 TypeScript 中则不是这样：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While TypeScript can protect against an undeclared variable, it does not protect
    a `var` declaration against the side effect of **hoisting**. The issue comes from
    JavaScript, where a declaration with `var` is processed before other pieces of
    code, which brings the variable declaration to the top of the scope (function
    or global). The subtlety is that the declaration is moved up, but not the initialization.
    That being said, TypeScript will not let you use a variable defined under its
    usage:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 TypeScript 可以防止未声明的变量，但它不能防止 `var` 声明受到 **提升** 的影响。这个问题源于 JavaScript，其中使用
    `var` 的声明会在其他代码片段之前处理，将变量声明带到作用域（函数或全局）的顶部。微妙之处在于声明被提升，但初始化没有。也就是说，TypeScript
    不允许你使用在其使用下定义的变量：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, `var` lets you define the variable that overrides the initial declaration
    or initialization more than once:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`var` 允许你多次定义变量，以覆盖初始声明或初始化：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Generally, the use of `var` is a dated way to declare a variable. With TypeScript,
    there is a big incentive to rely on `let` or `const` because you can generate
    an older ECMAScript version that will generate `var` but in a proper and valid
    format.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用 `var` 来声明变量是一种过时的方法。在 TypeScript 中，有很大动力依赖 `let` 或 `const`，因为你可以生成一个较旧的
    ECMAScript 版本，该版本会生成 `var`，但格式正确且有效。
- en: Declaring with let
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `let` 声明
- en: 'A `let` declaration is scope-based. It cannot be declared more than once per
    scope, and it does not hoist the variable. It simplifies the readability of the
    code, and it avoids unexpected errors. Declaring with `let` also doesn''t set
    any values globally. Relying on `let` is the way to declare a variable when you
    expect the variable to be set more than once. In the following code, the variable
    `a` is defined three times. The code is legal, even with several declarations.
    The reason is that each declaration, with `let`, is defined in a different scope
    with curly braces. The first scope is the function scope. The second scope uses
    an unusual syntax, but it reflects how a `while`, `if`, or other scope feature
    works. The third scope is within an `if` statement:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 声明是作用域相关的。在同一个作用域内不能多次声明，并且它不会提升变量。它简化了代码的可读性，并避免了意外的错误。使用 `let` 声明也不会设置任何全局值。当你期望变量被多次设置时，依赖
    `let` 是声明变量的方式。在以下代码中，变量 `a` 被定义了三次。代码是合法的，即使有多个声明。原因是每个声明，使用 `let`，都在不同的作用域中定义，使用花括号。第一个作用域是函数作用域。第二个作用域使用了一种不寻常的语法，但它反映了
    `while`、`if` 或其他作用域功能的工作方式。第三个作用域在 `if` 语句内：'
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Furthermore, TypeScript ensures that once a declaration is done, the type associated
    with the variable is immutable. This means that a variable defined as a number
    will be a number for the rest of the lifespan of the variable:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，TypeScript 确保一旦完成声明，与变量关联的类型是不可变的。这意味着一个定义为数字的变量将保持为数字，直到变量的整个生命周期：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Declaring a variable with `let` in a `switch` case can be tricky. The reason
    is the scoping is not by `case` but for the `switch` that hosts all the cases.
    However, it is possible to conceive a scope by summoning a curly bracket inside
    each `case`. The following code is valid even if two variables `b` are declared:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `switch` 情况中使用 `let` 可能很棘手。原因是作用域不是由 `case` 决定的，而是由包含所有情况的 `switch` 决定的。然而，通过在每个
    `case` 中召唤一个花括号，可以构想一个作用域。以下代码是有效的，即使声明了两个变量 `b`：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, adding a subsequent case that also declares a variable `b` fails the
    compilation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，添加一个随后也声明变量 `b` 的情况会导致编译失败：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The workaround for the default scope from the `switch` is to create an artificial
    scope for each case. The construction of the scope can be done by adding curly
    brackets, as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `switch` 的默认作用域中找到的解决方案是为每个情况创建一个人工作用域。作用域的构建可以通过添加花括号来完成，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`let` is one of the most-used declarations and should always be used instead
    of `var` when `const` is not a valid option.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 是最常用的声明之一，并且当 `const` 不是一个有效选项时，应该始终使用 `let` 而不是 `var`。'
- en: const
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: const
- en: In the case where you know that the variable is set once and will not change,
    then using `const` is a better alternative. The reason is that it highlights to
    the reader of the code that the value cannot be set more than once—it is declared
    and initialized. TypeScript respects `let` and `const`, and the code will not
    compile if a variable is defined more than once or if a value is assigned twice
    when the variable is a constant.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道变量只设置一次且不会改变，那么使用`const`是一个更好的选择。原因是它向代码的读者表明该值不能被设置超过一次——它是声明和初始化的。TypeScript尊重`let`和`const`，如果变量被多次定义或当变量是常量时值被两次赋值，代码将无法编译：
- en: 'Conscribing a variable to stay with a single value may look restrictive, but
    in many situations, it is the right thing to do. The declaration of a primitive
    with `const` blocks the access of assigning with the equals sign (`=`), which
    means that it does not allow you to change the reference of the variable. However,
    you can change the content of the variable. For example, an array of primitives
    can add and remove values from the array, but cannot assign a new list of values:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量约束为保持单一值可能看起来很限制，但在许多情况下，这是正确的事情。使用`const`声明的原始类型阻止了使用等号（`=`）进行赋值，这意味着它不允许你更改变量的引用。然而，你可以更改变量的内容。例如，原始类型的数组可以添加和从数组中删除值，但不能分配新的值列表：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code shows that a member can be edited, even if the object is
    declared as a constant. However, the `myObj` is not assignable. It means that
    the reference will always remain the same:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示即使对象被声明为常量，成员也可以被编辑。然而，`myObj`是不可赋值的。这意味着引用将始终保持不变：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, TypeScript, with the use of `let` and `const`, ensures that the value
    assigned to a variable is associated with the desired variable, and any faulty
    assignation will cause the compiler returning an error. In the following code,
    two variables are clearly defined at the global scope, as well as the function
    scope. There is no doubt that they are two distinct variables with any collusion
    of value:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，TypeScript通过使用`let`和`const`确保分配给变量的值与期望的变量相关联，任何错误的赋值都会导致编译器返回错误。在下面的代码中，两个变量在全局作用域和函数作用域中都被明确定义，毫无疑问，它们是两个具有任何值冲突的独立变量：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Enhancing primitives with TypeScript
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript增强原始类型
- en: 'TypeScript has the same primitive variables as JavaScript. It is possible to
    declare a variable to hold a number, string, Boolean, and a symbol. Also, two
    primitives are available for a situation where no value is available: undefined
    and null. Finally, with these primitives, it''s possible to have an array of each
    of them.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript具有与JavaScript相同的原始变量。可以声明一个变量来存储数字、字符串、布尔值和符号。此外，还有两个原始类型可用于没有值的情况：`undefined`和`null`。最后，使用这些原始类型，可以有一个包含它们的数组。
- en: 'All primitives must use one declaration previously discussed with a unique
    variable name and use the colon followed by the word number. However, when used
    as a parameter of a function, the `declaration` keyword is avoided. There is no
    need to specify the scope of the variable because this one is for the function.
    The same goes for the visibility, which is only visible to the function receiving
    the parameter:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '所有原始类型都必须使用之前讨论过的唯一变量名进行声明，并使用冒号后跟单词`number`。然而，当用作函数的参数时，应避免使用`declaration`关键字。没有必要指定变量的作用域，因为这个变量是为函数准备的。同样，可见性也仅限于接收参数的函数： '
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Number
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Number
- en: 'TypeScript follows how JavaScript manipulates and carries the primitive type
    of a number by having a single type: number. A number can be an `integer`, a `float`,
    a `double`, negative, positive and even `NaN`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript遵循JavaScript如何通过单一类型：number来操作和携带数字的原始类型。一个数字可以是`整数`、`浮点数`、`双精度浮点数`、负数、正数甚至是`NaN`。
- en: 'A number cannot directly use a `boolean` value (neither `true`, neither `false`).
    A conversation by parsing the `boolean` is required:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数字不能直接使用`布尔`值（无论是`true`还是`false`）。需要通过解析`布尔`值来进行转换：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are many ways to convert a Boolean to a number. You can use the `Number`
    constructor that takes any value and converts it into a number of `1` for `true`
    and `0` for `false`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将布尔值转换为数字的方法有很多。你可以使用`Number`构造函数，它接受任何值并将其转换为`true`为`1`和`false`为`0`的数字：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can use the ternary operator and manually select the desired value, which
    can be beyond `1` and `0`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用三元运算符并手动选择所需的值，这些值可以超出`1`和`0`：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can use the `+` sign to start an addition to the value, which automatically
    converts the `boolean` value to a number:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `+` 符号来开始对数值的添加，这会自动将 `boolean` 值转换为数字：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A number cannot use a string directly either. Many techniques borrowed from
    JavaScript are available. The first one is using `Number`, and similar to the
    `boolean` case will parse the string into a number:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数字也不能直接使用字符串。许多从 JavaScript 借用的技术可用。第一种是使用 `Number`，类似于 `boolean` 的情况，会将字符串解析为数字：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second approach is using the `parseInt` function. The `parse` function
    has a second optional parameter that allows specifying the base. It is important
    to note that this should always be specified to avoid error with octal or hexadecimal:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用 `parseInt` 函数。`parse` 函数有一个可选的第二个参数，允许指定基数。需要注意的是，这应该始终指定，以避免与八进制或十六进制发生错误：
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can use the `+` sign to add to the value, which automatically converts
    the string value to a number:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `+` 符号来向值添加，这会自动将字符串值转换为数字：
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Converting a string into a number can be tricky if the string is written with
    **numeric separators**. A numeric separator allows writing a number in a human
    way by dividing the digit by an underscore. This increases the readability. For
    example, here are nine million one hundred:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串是用 **数字分隔符** 编写的，将字符串转换为数字可能会很棘手。数字分隔符允许通过在数字之间放置下划线以人类方式编写数字，从而提高可读性。例如，这里是九千一百万：
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Parsing a string with a numeric separator will fail, but this is also the case
    when using the `Number` approach as well as the `+` sign approach. The result
    is inconsistent and can be from `NaN` to parsing just the value before the first
    underscore. In that case, replacing all underscores and using one of the techniques
    previously mentioned would be the solution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数字分隔符解析字符串会失败，但这也适用于使用 `Number` 方法以及 `+` 符号方法的情况。结果是矛盾的，可以是 `NaN` 或仅解析第一个下划线之前的值。在这种情况下，替换所有下划线并使用之前提到的一种技术将是解决方案。
- en: 'A number can be written in a different base. As in JavaScript, TypeScript uses
    the `0x` literal for hexadecimal, `0b` for binary, and `0o` for octal:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可以用不同的基数表示。与 JavaScript 一样，TypeScript 使用 `0x` 字面量表示十六进制，`0b` 表示二进制，`0o` 表示八进制：
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: String
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'TypeScript is identical to JavaScript for a string. You can define a string
    between single quotes, double quotes, or backquotes. The single quote and double
    quote have the same function of assigning the string between the quotes to the
    variable:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 对于字符串与 JavaScript 相同。您可以使用单引号、双引号或反引号定义字符串。单引号和双引号具有将引号之间的字符串分配给变量的相同功能：
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The backquote, or backtick, has a special name, **string interpolation**, which
    allows injecting code inside the string. This is possible using a special syntax
    with the dollar sign and curly brackets:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号，或称为反引号，有一个特殊的名称，**字符串插值**，它允许在字符串中注入代码。这是通过使用带美元符号和大括号的特殊语法来实现的：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last example produces this output: Can invoke the variable function: s
    as well as any code like this addition: 2.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子产生以下输出：可以调用变量函数：s，以及任何类似这样的代码：2。
- en: 'Interpolation goes beyond just injecting other value and can run any TypeScript
    code. The previous example does an addition in the string. Another feature of
    string interpolation is that you can add a line break without having any compilation
    problem. With a single and a double quote, a string must be on the same line or
    be broken in several strings and concatenated with a `+` sign:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 插值不仅限于注入其他值，还可以运行任何 TypeScript 代码。前面的例子在字符串中执行了加法。字符串插值的另一个特性是，您可以在不出现任何编译问题时添加换行符。使用单引号和双引号，字符串必须在同一行上，或者可以分成几个字符串，并用
    `+` 符号连接：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Boolean
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔
- en: 'A `boolean` type allows the lowercase `true` and `false` only. No number is
    authorized, neither different capitalization of the value. It''s possible to convert
    a numeric value, that is `1` or `0`, by comparing it to `1`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 类型只允许小写的 `true` 和 `false`。不允许使用数字，也不允许值的不同的首字母大小写。可以通过将其与 `1` 进行比较来转换数值，即
    `1` 或 `0`：'
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is also possible to use the JavaScript `Boolean` construction to have a
    conversion. TypeScript doesn''t remove the quirks that come along with the parsing
    but returns a strongly typed `bool` value of the constructor. Here are some examples
    that barely any work for the case of a string with the value `false`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 JavaScript 的 `Boolean` 构造函数进行转换。TypeScript 不会移除解析过程中出现的怪癖，但返回构造函数的强类型
    `bool` 值。以下是一些几乎对具有 `false` 值的字符串情况不起作用的例子：
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Only the last two lines are a TypeScript specific solution where we cast the
    string to type and then back to a `boolean`. It is also one of the only solutions
    that work, other than comparing to the string directly as shown in the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 只有最后两行是TypeScript特有的解决方案，其中我们将字符串转换为类型，然后再转换回`boolean`。这也是除了直接比较字符串之外，唯一可行的解决方案之一，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preferred solution is to avoid casting to any. Casting opens the door to
    potential unexpected errors in most cases, even if in this particular situation,
    the casted value is controlled in this example, which could not be the case in
    a real scenario. The use of the `boolean` constructor is compelling but must be
    used carefully as the value `false` will result in a `boolean` `true` value. If
    the value is not controlled and part of a string, the safest way is to compare
    to use the `isTrue` function provided in this section of the book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案是避免进行任何类型的转换。在大多数情况下，转换会打开潜在意外错误的大门，即使在这个特定的例子中，转换的值是受控的，但在实际场景中可能并非如此。使用`boolean`构造函数很有吸引力，但必须谨慎使用，因为值`false`将导致`boolean`值为`true`。如果值不受控制且是字符串的一部分，最安全的方式是使用本书本节提供的`isTrue`函数进行比较。
- en: 'Null'
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空值
- en: 'The value `Null` can be assigned to a variable when the main value is not available.
    Without the compiler option, `strictNullChecks`, TypeScript allows having null
    or undefined. As a best practice, it''s always better to set the strict null check
    and assign manually which of the variables can have both values. The reason is
    that you can carefully craft each variable and type with the right amount of flexibility
    around what is of the specific type or null or undefined, without having a door
    wide open. Every time a variable can be null, a check to null will be required
    before being able to use the object''s properties:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当主要值不可用时，可以将`Null`值分配给变量。如果没有`strictNullChecks`编译器选项，TypeScript允许有`null`或`undefined`。作为一个最佳实践，始终设置严格的空值检查并手动指定哪些变量可以同时具有这两个值会更好。原因是你可以仔细构建每个变量和类型，围绕特定类型、`null`或`undefined`的灵活性进行适当的调整，而不留下一个敞开的大门。每次一个变量可以是`null`时，在使用对象属性之前都需要进行空值检查：
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The usage of `null` should be limited in TypeScript in favor of `undefined`.
    The reason will be explained in the *Undefined* section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，应该限制`null`的使用，而倾向于使用`undefined`。原因将在*未定义*部分解释。
- en: 'With `strictNullChecks` activated, the `null` value can only be assigned to
    a type allowing `null` or to a value of type any. To have a type accepting null,
    a union must be used:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当`strictNullChecks`被激活时，`null`值只能分配给允许`null`或任何类型的值。要有一个接受`null`的类型，必须使用联合类型：
- en: '[PRE29]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Undefined
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未定义
- en: 'The `undefined` can be assigned to a variable when the main value is not available,
    similar to `null`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当主要值不可用时，`undefined`可以被分配给变量，类似于`null`：
- en: '[PRE30]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, it has more cases. For example, an optional parameter (that we will
    discuss later in this book) is automatically set to `undefined` when not provided
    by the TypeScript. The reason is that when a property does not exist in JavaScript,
    it is undefined, not null:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有更多的情况。例如，当一个可选参数（我们将在本书后面讨论）在TypeScript中没有提供时，它会被自动设置为`undefined`。原因是当JavaScript中的属性不存在时，它是`undefined`，而不是`null`：
- en: '[PRE31]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As mentioned, `undefined` is also the value returned if you are using square
    brackets to access an object property that doesn''t exist using a string:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你使用方括号通过字符串访问一个不存在的对象属性，返回的值也是`undefined`：
- en: '[PRE32]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`undefined` is also the value assigned to a field variable of a class when
    the class has not yet set the initial value from the constructor. This is only
    reproducible if the compiler option `strictPropertyInitialization` is set to `false`,
    which is a bad practice. As a good way to avoid having a field that is not explicitly
    mentioning `undefined` to be undefined because of a lack of initialization, the
    compiler option should always be `true`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当类尚未从构造函数设置初始值时，`undefined`会被分配给类的字段变量。这只有在编译器选项`strictPropertyInitialization`设置为`false`时才会发生，这是一种不好的做法。为了避免因为初始化不足而导致字段未明确提及`undefined`而默认为`undefined`，编译器选项应始终设置为`true`。
- en: 'With `strictNullChecks` activated, the undefined value can only be assigned
    to a type allowing `undefined`, a type that is optional, or to a value of type
    any. To have a type accept `undefined`, a union must be used with the primitive
    and undefined. In the case of an optional, a function can use the question mark
    before the colon that specifies the primitive:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `strictNullChecks` 被激活时，未定义的值只能分配给允许 `undefined` 的类型、可选类型或 `any` 类型的值。要使一个类型接受
    `undefined`，必须使用原始类型和 `undefined` 的联合。对于可选类型，函数可以在指定原始类型的冒号前使用问号：
- en: '[PRE33]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An `undefined` can also use the optional notation in a class or an interface
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined` 也可以在类或接口中使用可选标记，如下所示：'
- en: '[PRE34]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Like a type in a union with `undefined`, an optional value can be verified
    by comparing against `undefined`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `undefined` 在联合类型中的类型一样，可选值可以通过与 `undefined` 进行比较来验证：
- en: '[PRE35]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Symbol
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Symbol
- en: 'A `Symbol` allows the creation of a value that is unique. A `Symbol` is different
    than a constant because two constants with the same value are equal, while this
    is not the case with two symbols with the same value. The constant variables work
    like any variable, by comparing the value. Comparisons with `Symbol` work differently.
    Every `Symbol` is unique, hence even with the same value, they are not the same.
    Let''s see some examples:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol` 允许创建一个唯一的值。`Symbol` 与常量不同，因为具有相同值的两个常量是相等的，而具有相同值的两个符号则不是。常量变量像任何变量一样工作，通过比较值。与
    `Symbol` 的比较则不同。每个 `Symbol` 都是唯一的，因此即使值相同，它们也不是相同的。让我们看看一些例子：'
- en: '[PRE36]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The use of `Symbol` can ensure that the value provided is absolutely the one
    desired. It is not able to pass another constant with the same value, neither
    a string with the same value. Only the exact same symbol must be used:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Symbol` 可以确保提供的值确实是期望的那个。它不能传递具有相同值的另一个常量，也不能传递具有相同值的字符串。必须使用完全相同的符号：
- en: '[PRE37]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, `Symbol` can be used as an insurance when defining a field to an object.
    With the symbol, you can be sure to define every field once. A `Symbol` is by
    nature immutable:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Symbol` 可以在定义对象字段时用作保险。有了这个符号，你可以确信每个字段只定义了一次。`Symbol` 本质上是不可变的：
- en: '[PRE38]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'TypeScript needs to know about the `Symbol` feature that was introduced in
    ES2015\. Before using the `Symbol` keyword, the `tsconfig.json` must add `lib` to
    the array:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 需要知道在 ES2015 中引入的 `Symbol` 功能。在使用 `Symbol` 关键字之前，`tsconfig.json`
    必须将 `lib` 添加到数组中：
- en: '[PRE39]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Non-primitive
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非原始类型
- en: There is also a more advanced group of variables beyond the primitives. The
    non-primitive group includes `void`, `string literal`, `tuple`, `any`, `unknown`,
    and `never`; we will now discuss these variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原始类型之外，还有更多更高级的变量类型。非原始类型组包括 `void`、`string literal`、`tuple`、`any`、`unknown`
    和 `never`；我们现在将讨论这些变量。
- en: What is void?
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 `void`？
- en: 'A `void` is a special and is used mainly for a function that returns no value.
    With an explicit return to `void`, the function cannot accept a return statement
    with a value that can occur with it; hence, it acts as a guard of potential error
    of returning a value. A `void` function can still have an empty return to leave
    the function before reaching the closing curly bracket. A `void` variable can
    only be assigned to `undefined`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`void` 是一个特殊类型，主要用于返回没有值的函数。当明确返回 `void` 时，函数不能接受一个带有值的返回语句；因此，它充当了返回值的潜在错误的保护。`void`
    函数仍然可以有空的返回，以便在到达闭合花括号之前离开函数。`void` 变量只能分配给 `undefined`：'
- en: '[PRE40]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is not useful, but it explains what happens if you return a function without
    a value to a `void` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能没有太大用处，但它解释了如果你向 `void` 函数返回一个没有值的函数会发生什么：
- en: '[PRE41]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is always a good practice to mark a function with `void` instead of using
    the implicit return value. The implicit return type for a function is a *weak*
    *void* because the function allows the returning of anything. The following function
    doesn''t have a return type and was initially returning nothing. However, in its
    life, the function changed (as you will see next) and now returns three different
    values that are not like the previous ones. The *implicit returns* value is not
    void anymore. Having an explicit return type define a contract and indicate to
    anyone touching the function what is the expected return type and that should
    be respected. In this example code, the function returns a union of a Boolean,
    number, and string:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 总是标记一个函数为`void`而不是使用隐式返回值是一个好习惯。函数的隐式返回类型是一个*弱* *void*，因为函数允许返回任何东西。以下函数没有返回类型，最初什么也不返回。然而，在其生命周期中，函数发生了变化（你将在下面看到），现在返回三个不同的值，这些值与之前的值不同。*隐式返回*的值不再是void。有一个显式返回类型定义了一个合同，并指示任何接触该函数的人预期的返回类型是什么，应该遵守。在这个示例代码中，函数返回一个布尔值、数字和字符串的联合类型：
- en: '[PRE42]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The reasons to avoid using any type
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用任何类型的理由
- en: 'The `any` is a wildcard type that allows not only `any` type but also to change
    the type at will. There are many problems with `any`. The first one is that it
    is hard to follow what type is a variable; we are back to how JavaScript is written:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`是一个通配符类型，它不仅允许`any`类型，还可以随意更改类型。`any`有很多问题。第一个问题是很难跟踪变量的类型；我们又回到了JavaScript的编写方式：'
- en: '[PRE43]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The use of `any` should be avoided because it can hold a value that is not
    as expected and still it can compile because TypeScript does not know the type
    and cannot perform validation:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 应该避免使用`any`，因为它可以持有不符合预期的值，并且仍然可以编译，因为TypeScript不知道类型并且无法执行验证：
- en: '[PRE44]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The only reason to use `any` is in two situations. The first one is that you
    are migrating code from JavaScript to TypeScript. Migrating code can take a long
    time and TypeScript is built naturally in a way that you can be in a hybrid mode
    for a while. It means that not only you can turn down some strictness of the compiler
    options, but also that you can create functions, variables, and types that are
    not fully detailed in terms of type by allowing `any`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`any`的唯一原因是在两种情况下。第一种情况是你正在将代码从JavaScript迁移到TypeScript。迁移代码可能需要很长时间，TypeScript自然地以这种方式构建，你可以保持混合模式一段时间。这意味着你不仅可以降低编译器选项的严格性，还可以通过允许`any`来创建在类型上不完全详细的函数、变量和类型。
- en: The second situation where `any` is potentially acceptable is when you are in
    a situation that you cannot figure out the type in some advanced scenario and
    you must move on. The latter should be a signpost and must have a follow-up because
    we do not want to make it a habit.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`可能被接受的第二种情况是你处于一个无法在某些高级场景中确定类型的情境，你必须继续前进。后者应该是一个路标，必须有一个后续行动，因为我们不希望让它成为一种习惯。'
- en: Usage of the never type
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`never`类型的用法'
- en: 'The `never` is a variable that should never be set. This might sound useless
    at first but can be useful in a case where you want to ensure that nothing falls
    into a particular code path. A function rarely returns `never`, but it can happen.
    This is the case if you are having a function that does not allow you to finish
    the method to execute or return any variable; hence, it never fully returns. This
    can be coded using an exception:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`never`是一个不应该被设置的变量。一开始这可能听起来没有用，但在你想要确保没有任何东西落入特定的代码路径时，它可能是有用的。一个函数很少返回`never`，但这种情况是可能发生的。如果你有一个不允许你完成方法执行或返回任何变量的函数；因此，它永远不会完全返回。这可以通过异常来编码：'
- en: '[PRE45]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`Never` occurs when you are writing code and you are writing a condition that
    cannot occur and that TypeScript infers the type by the usage of your code. This
    can happen if you have several conditions and that one englobe another making
    some variable fall into the `never` scenario. It can also happen if you have all
    the variable values covered by condition and have an `else` statement (or default
    with a `switch case`). The value cannot have any other value than *never been
    assigned*, since all values are checked. Here is an illustration of the possibility:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编写代码时，你编写了一个不可能发生的条件，TypeScript通过你的代码使用推断出类型。这可能发生在你有几个条件，其中一个包含另一个，使得某些变量落入`never`场景。如果所有变量值都被条件覆盖，并且有一个`else`语句（或带有`switch
    case`的默认值），也可能发生这种情况。值不能有任何其他值，只能是*从未被分配*的，因为所有值都被检查了。以下是一个说明这种可能性的示例：
- en: '[PRE46]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In practice, the `never` type is used for checking whether all values of an
    `enum` or a `union` have conditions that took care of all the values. This allows
    creating a validation when a developer adds a value to the `enum` or the `union`
    but forgets to add a condition. The lack of the condition makes the code fall
    through the exhaustive check. TypeScript is smart enough to verify all cases and
    understand that the code might go in the function that takes a `never` parameter,
    which is not allowed because nothing can be assigned to `never`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，`never`类型用于检查枚举或联合的所有值是否都处理了所有值。这允许在开发者在枚举或联合中添加值时忘记添加条件时创建验证。缺少条件会导致代码在详尽检查中失败。TypeScript足够智能，可以验证所有情况，并理解代码可能会进入接受`never`参数的函数，这是不允许的，因为不能将任何内容赋值给`never`：
- en: '[PRE47]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Unknown type to have a stricter any type
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`unknown`类型与更严格的`any`类型结合
- en: 'TypeScript `unknown` type is a new addition to reduce the usage of `any`. When
    a variable is of type `unknown`*,* everything can be set to the variable. However,
    the value `unknown` can only be set to another `unknown` type or `any` type. Here
    is a list of several rules about the `unknown` type:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的`unknown`类型是新增的功能，旨在减少`any`的使用。当一个变量是`unknown`类型时，可以将任何内容赋值给该变量。然而，`unknown`值只能赋值给另一个`unknown`类型或`any`类型。以下是关于`unknown`类型的几个规则：
- en: An `unknown` type can only be used with the equality operator; no other operator
    will compile.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unknown`类型只能与等号运算符一起使用；其他运算符将无法编译。'
- en: A function that returns `unknown` does not require to return anything.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`unknown`类型的函数不需要返回任何内容。
- en: An intersection with the `unknown` type is useless because the type on which
    the unknown is intersected will take over. However, when used in a `union`, it
    will always take precedence and override any other type in the union.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`unknown`类型的交集是没有用的，因为与`unknown`类型相交的类型将占主导地位。然而，当在联合中使用时，它将始终具有优先级并覆盖联合中的任何其他类型。
- en: A key of on an `unknown` type is always `never`.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unknown`类型的键总是`never`。'
- en: 'One use case of the type `unknown` is that it can be used when you do not know
    a type. Instead of relying on `any`*,* which can accept everything and be passed
    along any code, the use of` unknown` restricts the flow of the variable. Since
    an unknown variable cannot be set to another variable, it forces the developer
    to properly scope down the value to its type and continue further along. Without
    the `unknown` type, `any` would have been the only option. It opens the door wide
    to accept anything and to:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`unknown`类型的一个用例是，当不知道类型时可以使用它。而不是依赖于可以接受任何内容并通过任何代码传递的`any`，使用`unknown`限制了变量的流动。由于未知变量不能被设置到另一个变量中，这迫使开发者正确地将值缩小到其类型，并继续进一步。如果没有`unknown`类型，`any`将是唯一的选择。它打开了广泛接受任何内容的大门，并：'
- en: '[PRE48]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, the first function can take anything and expect to return a
    string. However, no cast or anything is required because a variable of type` any`
    can return a string. However, with an `unknown`, it must be handled. As mentioned,
    the reason is that the `unknown` type cannot be assigned to types other than` unknown`
    or `any`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一个函数可以接受任何类型并期望返回一个字符串。然而，不需要进行类型转换或任何操作，因为`any`类型的变量可以返回一个字符串。但是，对于`unknown`类型，必须进行处理。正如之前提到的，原因是`unknown`类型不能被赋值给除了`unknown`或`any`之外的任何类型。
- en: Enforcing a type in a list
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在列表中强制类型
- en: An array can be created in two different ways. The first is using the square
    brackets and by using the `Array` generic object. They are both interchangeable,
    and both of them can be typed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以通过两种不同的方式创建。第一种是使用方括号和`Array`泛型对象。它们可以互换使用，并且都可以进行类型注解。
- en: 'The square- bracket format is more compact, and it allows to specify the type
    before the squared brackets. The `Array` generic object specifies the type between
    the smaller/bigger sign:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号格式更紧凑，允许在方括号之前指定类型。`Array`泛型对象在较小/较大的符号之间指定类型：
- en: '[PRE49]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It is possible to have an array holding more than one type of a type by combining
    the array type with a union:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将数组类型与联合结合来创建包含多种类型的数组：
- en: '[PRE50]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'TypeScript acts the same as in JavaScript, other than specifying the type for
    the array. You can access the content by using the index position and using all
    the methods available that are automatically typed with the type of the type specified
    for the array:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的行为与JavaScript相同，除了指定数组的类型。您可以通过使用索引位置和所有自动使用指定数组类型的方法来访问内容：
- en: '[PRE51]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If a position doesn't contain a value, the type returned is undefined.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个位置不包含值，返回的类型是`undefined`。
- en: 'TypeScript allows to loop an array and retrieve for each position the element
    strongly typed. The type is optional because TypeScript can infer the type. It
    means that the following code can be written with or without the `number` type:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript允许循环数组并检索每个位置的强类型元素。类型是可选的，因为TypeScript可以推断类型。这意味着以下代码可以带有或不带有`number`类型：
- en: '[PRE52]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Defining a conscribed set of constants with enum
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`enum`定义一组常量
- en: 'TypeScript has a keyword `enum` that let you specify many possible values as
    a group where only a single item can be selected. Defining an `enum` can be done
    by providing potential keys that would automatically assign a sequential number
    from `0` to the first potential choice of the `enum` and so on:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript有一个关键字`enum`，允许你指定一组可能的值，其中只能选择一个项。定义一个`enum`可以通过提供潜在的键来完成，这些键将自动从`0`开始分配给`enum`的第一个潜在选择，依此类推：
- en: '[PRE53]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It is possible to specify a value to a key to have fine-grained control. Any
    missing value will be the next sequence value. In the following code example,
    `Sunny` is set to `100`, and `Cloudy` is automatically `101`, `Rainy` is `102`,
    and so on:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定一个值给键以获得更精细的控制。任何缺失的值将是下一个序列值。在下面的代码示例中，`Sunny`被设置为`100`，而`Cloudy`自动为`101`，`Rainy`为`102`，依此类推：
- en: '[PRE54]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It is possible to skip, in that case, you can only provide a bigger value and
    the value of the assigned one is sequential. In the following code example, the
    values are `100`, `101`, `200`, and `201`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以跳过，你只能提供一个更大的值，分配的值是顺序的。在下面的代码示例中，值是`100`、`101`、`200`和`201`：
- en: '[PRE55]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `enum` can also support string or a mix of a string and a number:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`也可以支持字符串或字符串和数字的混合：'
- en: '[PRE56]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `enum` can be accessed by the `enum` or by value. Accessing by the `enum`
    requires using the dot notation from the `enum` directly. The value returned is
    the `enum`. This is the common way to assign an `enum` in TypeScript. It is also
    possible to assign the value. The assignation by value is useful when data come
    from JSON. For example, the value is returned from an Ajax response. It bridges
    non-TypeScript into TypeScript:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`可以通过`enum`或通过值来访问。通过`enum`访问需要直接从`enum`使用点符号。返回的值是`enum`。这是在TypeScript中分配`enum`的常见方式。也可以分配值。当数据来自JSON时，值分配很有用。例如，值是从Ajax响应中返回的。它将非TypeScript与TypeScript连接起来：'
- en: '[PRE57]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the previous code, accessing the value from the with the square bracket only
    works when the value in the square bracket is the type, not the value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，只有当方括号中的值是类型而不是值时，使用方括号访问值才有效。
- en: 'In addition to `number` and `string`, `enum` supports bitwise values with the
    help of a bit shift operator. It allows to check whether a value contains a single
    or an aggregate of value with an ampersand (`&`). The reason is that with the
    pipe `|` you can create a variable that contains several values. The stacking
    values can also reside inside the `enum` for reusability purposes but is not required:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`number`和`string`之外，`enum`在位运算符的帮助下还支持位值。它允许使用和符号（`&`）检查值是否包含单个值或值的聚合。原因是，使用管道`|`可以创建包含多个值的变量。堆叠的值也可以位于`enum`中，用于重用目的，但不是必需的：
- en: '[PRE58]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A value can hold more than a single value. This is useful if we want to persist
    the existing value intact and you need to use the sign `|=`. To remove a particular
    status, you need to use `&= ~`. Using these operators will swap the value at the
    right position in its binary format without affecting the remaining parts of the
    number:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值可以保存多个值。如果我们想完整地保留现有值，并且需要使用符号`|=`，这很有用。要删除特定的状态，你需要使用`&= ~`。使用这些运算符将在其二进制格式中交换右位置的值，而不会影响数字的其余部分：
- en: '[PRE59]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, to check whether the variable is of a particular status, you must
    use the triple equals with the ampersand to the value you want to check against.
    The use of a single ampersand for comparison is a mistake. The ampersand returns
    a number, not a `boolean`. The comparison needs to be against the value that we
    want to check. It is possible to check against many values by creating a combined
    value in the comparison:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了检查变量是否具有特定的状态，你必须使用三个等号与你想检查的值旁边的和符号。使用单个和符号进行比较是一个错误。和符号返回一个数字，而不是`boolean`。比较需要与我们要检查的值进行比较。通过创建一个组合值在比较中，可以检查多个值：
- en: '[PRE60]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `enum` is a great way to define a set of potential value from a specific
    domain for a variable. It has the convenience of being clear by naming the choices
    at your convenience and letting you decide the value of each entry if needed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 是定义变量可能值的特定域集合的绝佳方式。它具有通过命名选择来清晰表达的优势，并在需要时允许你决定每个条目的值。'
- en: String literal and its difference compared to a string
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串字面量及其与字符串的区别
- en: 'A `string` is a type that allows any kind of characters. A `string literal`
    is the association of a particular `string` as a type. When a `string` is set
    to a type, it is possible to assign one value and change it later. The only value
    possible to set to a `string literal` is the exact string stamped at the declaration:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 是一种允许任何类型字符的类型。`字符串字面量` 是将特定的 `string` 与类型关联。当 `string` 被设置为类型时，可以分配一个值并在以后更改它。唯一可以设置到
    `字符串字面量` 的值是在声明时打印的精确字符串：'
- en: '[PRE61]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'TypeScript compiles the code into plain JavaScript, without types. A `string
    literal` ensures that while writing the code in TypeScript that only a single
    string value can be associated with a variable, and this is compiled into JavaScript
    objects with this mandatory value. The essence of this particularity is that we
    have in both languages the assurance that the value is unique. This becomes handy
    in a situation where you need to condition a type that will not be there once
    compiled. For example, the case of an interface and a piece of code that must
    act differently depending on the interface. Having a shared field (with the name)
    among the interfaces with a unique string literal allow comparison at design time
    and run-time. At design time, TypeScript will be able to narrow down the type
    and hence provide better support for the specified type and at run-time be able
    to conduct the execution flow at the right place:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将代码编译成纯 JavaScript，不包含类型。一个 `字符串字面量` 确保在 TypeScript 中编写代码时，只能将单个字符串值与变量关联，并且这个值会被编译成具有此强制值的
    JavaScript 对象。这种特性的本质在于，我们在两种语言中都有确保值是唯一的保证。这在需要条件化一个在编译后不会存在的类型的情况下非常有用。例如，接口和一段必须根据接口不同而采取不同行动的代码的情况。在接口之间共享一个具有唯一字符串字面量的字段，可以在设计时和运行时进行比较。在设计时，TypeScript
    将能够缩小类型范围，从而为指定的类型提供更好的支持，在运行时能够在正确的位置执行流程：
- en: '[PRE62]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The code example shows that two interfaces share a type that is a `string literal`.
    To be able to access the unique property of one or the other `interface` in the
    function, a comparison of a discriminator is required. Without the comparison,
    the function that takes both interfaces with the union as a parameter does not
    know which of the two types is passed. However, TypeScript analyzes the two interfaces
    and identifies a common field and allows you to use this before scoping down the
    type. Once TypeScript can find which type is treated, it allows using the specific
    field of the type. In the example, inside the condition, all the movie's `interface`
    fields are available. On the other side, the `else` allows all the book's `interface`
    fields only.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例显示，两个接口共享一个 `字符串字面量` 类型的类型。为了能够在函数中访问一个或另一个 `interface` 的唯一属性，需要进行一个判别器的比较。如果没有比较，接受联合作为参数的函数不知道传递的是两种类型中的哪一种。然而，TypeScript
    分析这两个接口，并识别出一个共同字段，允许你在缩小类型之前使用这个字段。一旦 TypeScript 能够找到处理哪种类型，它就允许使用该类型的特定字段。在示例中，在条件内部，所有电影的
    `interface` 字段都是可用的。另一方面，`else` 允许仅使用书籍的 `interface` 字段。
- en: 'A literal string is one type of three possible literals that TypeScript supports.
    TypeScript supports `number` and `boolean` on top of the string. Finally, when
    using `string literal`, always provide the type using the colon:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量字符串是 TypeScript 支持的三种可能的字面量中的一种。TypeScript 在字符串之上还支持 `number` 和 `boolean`。最后，当使用
    `字符串字面量` 时，始终使用冒号提供类型：
- en: '[PRE63]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Instead of relying on `let`, which opens the door to many assignations, the
    use of `const` can ensure a single assignation; hence, it will automatically infer
    a `literal` type for the three types:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖于 `let`（它打开了多种赋值的大门）不同，使用 `const` 可以确保单个赋值；因此，它将自动为这三种类型推断出 `字面量` 类型：
- en: '[PRE64]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It is possible to create a literal by omitting the type only if declared with
    `const` because the value cannot change; hence, TypeScript will scope to its most
    narrowed expression. However, a change from `const` to `let` in the future would
    change the type back to `string`. I suggest being as explicit as possible to avoid
    an undesired type of change.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能通过省略类型来创建一个字面量，但前提是必须使用`const`声明，因为值不能改变；因此，TypeScript将范围缩小到其最窄的表达式。然而，从`const`到`let`的未来变化会将类型恢复为`string`。我建议尽可能明确，以避免不希望的类型变化。
- en: Crafting a typed function
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个类型化函数
- en: '**Functions **are first-class citizens in JavaScript. Since the early versions
    of ECMAScript, functions were the main concept to execute code and create scope.
    TypeScript uses the function the same way but provides additional typing features.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**在JavaScript中是一等公民。自从ECMAScript的早期版本以来，函数一直是执行代码和创建作用域的主要概念。TypeScript以相同的方式使用函数，但提供了额外的类型化功能。'
- en: 'A function has a main signature that contains the name of this one, the list
    of parameters, and the return type. Parameters are defined in parentheses, as
    in JavaScript, but each parameter will be followed by its type using the colon
    syntax:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数有一个主要签名，包含该函数的名称、参数列表和返回类型。参数在括号中定义，就像JavaScript一样，但每个参数后面都会使用冒号语法跟随其类型：
- en: '[PRE65]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A `function` can have several parameters of a different type:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`函数`可以拥有多个不同类型的参数：
- en: '[PRE66]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It can also have a parameter that has more than one type using a union:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以有一个具有多个类型的参数，使用联合：
- en: '[PRE67]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A `function` has a single return declaration but that type can use a union
    to allow types:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`函数`只有一个返回声明，但该类型可以使用联合来允许类型：
- en: '[PRE68]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A function can have a complimentary signature to indicate to the consumer which
    parameters match together and with the return type. Having several function signatures
    for the same body is the concept of an overloaded function. When using an overloaded
    function, all signatures must be written from top to bottom from the most specific
    to the largest one. All the definition requires finishing with a semicolon expect
    the last one. The last signature always has a union that covers all possible types
    for each position. In the following code example, we specify that if the parameter
    is a `boolean`, then the function returns a string. If the parameter is a `Date`,
    then the return type is a `number`. The last signature contains a first parameter
    the union of both possible values (`boolean` and date) as well as a union for
    the return type between `string` and `number`):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以有一个互补的签名来指示消费者哪些参数匹配在一起以及与返回类型。为同一主体提供多个函数签名是重载函数的概念。当使用重载函数时，所有签名必须从上到下从最具体到最一般地编写。所有定义都需要以分号结束，除了最后一个。最后一个签名总是有一个联合，覆盖了每个位置的所有可能类型。在以下代码示例中，我们指定如果参数是`boolean`，则函数返回一个字符串。如果参数是`Date`，则返回类型是`number`。最后一个签名包含一个第一个参数，即两个可能值（`boolean`和日期）的联合，以及返回类型在`string`和`number`之间的联合）：
- en: '[PRE69]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A function can be anonymous. Here is an example with the *fat arrow* format
    and one example returning a `Function` constructor:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以是匿名的。以下是一个使用*胖箭头*格式和一个返回`Function`构造函数的示例：
- en: '[PRE71]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A `function` can be a `variable` function or a typical function. Here are three
    functions set in a `variable`. The `variable` can be called by using parentheses
    and the required parameter. The code example shows also two ways to return data
    with the *fat arrow* format. If the code returns directly without doing any *several*
    statements, the need for curly brackets and *return* *statement* is not needed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`函数`可以是`变量`函数或典型函数。以下是在`变量`中设置的三个函数。`变量`可以通过使用括号和所需的参数来调用。代码示例还展示了两种使用*胖箭头*格式返回数据的方式。如果代码直接返回而不执行任何*多个*语句，则不需要大括号和*返回*语句：
- en: '[PRE72]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A function can have an optional parameter and a default value parameter. An
    optional parameter is denoted by the use of question mark after the name of the
    parameter. An optional parameter allows avoiding passing a value. `TypeScript`
    automatically sets the parameter to `undefined`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以有一个可选参数和一个默认值参数。可选参数通过在参数名称后使用问号表示。可选参数允许避免传递值。`TypeScript`自动将参数设置为`undefined`：
- en: '[PRE73]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`Optional` is different than having the variable with a union to `undefined`
    because the union requires passing the value or undefined while optional allows
    passing the value, undefined or nothing:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`与将变量与`undefined`的联合不同，因为联合需要传递值或`undefined`，而可选允许传递值、`undefined`或无：'
- en: '[PRE74]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`Optional` can only be set after non-optional parameter. The reason is that
    other parameters are required but having `Optional` before or in the middle would
    make it hard to map `which` parameter is `which`. The following code example presents
    a case where the function does not compile because of that rule. However, it''s
    possible to have many optional parameters:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 只能在非可选参数之后设置。原因是其他参数是必需的，但如果在 `Optional` 之前或中间，就会很难映射 `哪个` 参数是 `哪个`。以下代码示例展示了由于该规则而导致函数无法编译的情况。然而，可以有多个可选参数：'
- en: '[PRE75]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'A `function` can be in a class (object-oriented is covered in a future chapter).
    When this happens, the syntax is different. It doesn''t use the keyword `function`.
    Instead, the visibility is provided, which is `public`, `private`, or `protected`.
    `TypeScript` allows avoiding access modifiers, which will result in a `public`
    function. As for a class variable, the omission of the visibility uses `public`
    as default:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以位于类中（面向对象的内容将在下一章中介绍）。当这种情况发生时，语法会有所不同。它不使用 `function` 关键字。相反，提供了可见性，即 `public`、`private`
    或 `protected`。`TypeScript` 允许避免使用访问修饰符，这将导致函数为 `public`。至于类变量，省略可见性默认使用 `public`：
- en: '[PRE76]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The basis remains the same with parameters and a return type that is strongly
    typed. It is also possible to create a variable that holds the function inside
    a class as seen in this chapter. Here are three examples of a `private` function
    defined as a `variable`. The first one is long and very explicit. The second example
    doesn''t define the type at the function level because it is already defined in
    the declaration. The last example doesn''t define the type of the variable and
    the variable is still strongly typed because it infers its signature from the
    initialization:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和强类型返回类型的基仍然相同。也可以创建一个变量，它包含类中的函数，如本章所示。以下是三个将 `private` 函数定义为 `variable`
    的示例。第一个示例很长且非常明确。第二个示例在函数级别没有定义类型，因为它已经在声明中定义了。最后一个示例没有定义变量的类型，但由于它从初始化中推断其签名，变量仍然是强类型的：
- en: '[PRE77]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: A `function` in a variable is technically called a **function expression**,
    while the more traditional `function` syntax is named a **function statement**.
    The usage of one or the other is the same in `TypeScript` than with `JavaScript`.
    Because it operates under JavaScript's law, it means that the expression function
    is not hoisted.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 变量中的 `function` 技术上称为 **函数表达式**，而更传统的 `function` 语法称为 **函数声明**。在 `TypeScript`
    中，使用一个或另一个的用法与 `JavaScript` 相同。因为它遵循 JavaScript 的规则，这意味着表达式函数不会被提升。
- en: How to be strongly typed without specifying the type
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在不指定类型的情况下进行强类型化
- en: TypeScript can have a type specified explicitly or you can have the type determined
    by TypeScript. The latter is called an **implicit type** or a type defined by
    inference. The action of inference is conducted by TypeScript depending on how
    a variable is initialized during declaration for the variable or what is returned
    for a function return type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 可以显式指定类型，或者你可以让 TypeScript 确定类型。后者称为 **隐式类型** 或由推断定义的类型。推断的动作由 TypeScript
    根据变量在声明时的初始化或函数返回类型返回的内容来执行。
- en: 'A variable inference is only possible when a value is assigned at the declaration.
    It means that you must set a value when using `var`/`let`/`const`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的推断仅在声明时赋值的情况下才可能。这意味着在使用 `var`/`let`/`const` 时，你必须设置一个值：
- en: '[PRE78]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the previous code example, the value `1` is assigned to the variables `x`
    and `y` during the initialization. This is valid even if the colon is not used.
    `TypeScript` will infer the type for both variables. In the case of not specifying
    a value, only `var` or `let` would compile because it allows in a future moment
    the assignation. The value is not specified, which means that the type is falling
    back to `any`. This is true even if the value is set within the scope of the variable
    life.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，值 `1` 在初始化时被分配给变量 `x` 和 `y`。即使没有使用冒号，这也是有效的。`TypeScript` 将为这两个变量推断类型。在未指定值的情况下，只有
    `var` 或 `let` 可以编译，因为它允许在未来某个时刻进行赋值。值未指定，这意味着类型回退到 `any`。即使在变量的作用域内设置了值，这也是正确的。
- en: 'In the previous code example, the value `1` was assigned to a constant and
    a variable. The type of both of these declarators is different. The constant type
    is not a number, it is a number literal of `1`. It means that the type is `1`
    and only `1` and not any other number. However, the type of the variable declared
    with `let` is `number`. The reason is that with the constant, TypeScript knows
    that it can only be initialized once and that the value cannot change. It scopes
    down the simplest type it can find which is the value of the primitive. On the
    contrary, the variable declared with `let` can change its value during the lifetime
    of the variable. The TypeScript scopes the type every number. This is `true` with
    a `number`, `string`, and `boolean`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，值`1`被分配给了一个常量和变量。这两个声明符的类型不同。常量类型不是一个数字，它是一个`1`的数字字面量。这意味着类型是`1`，仅`1`，而不是任何其他数字。然而，使用`let`声明的变量的类型是`number`。原因是，对于常量，TypeScript知道它只能初始化一次，并且其值不能改变。它会缩小到它能够找到的最简单类型，即原始值的类型。相反，使用`let`声明的变量可以在变量的生命周期内改变其值。TypeScript会为每个数字类型进行类型缩小。这对于`number`、`string`和`boolean`都是成立的：
- en: '[PRE79]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: However, a date will stay to the date type regardless of the declarator, the
    same for any class or interface because it is the smaller denominator. In the
    previous code example, both `c1` and `c2` are of the type of an object that must
    have a member named `m1` of a type number. This example illustrates how TypeScript
    can also infer type inside type. `m1` is a number by inference.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，日期将保持为日期类型，无论声明符如何，任何类或接口也是如此，因为它是较小的分母。在之前的代码示例中，`c1`和`c2`都是必须具有名为`m1`的数字类型成员的对象类型。这个例子说明了TypeScript也可以在类型内部推断类型。`m1`是通过推断得到的数字类型。
- en: 'Inference works with functions as well. However, it has some limitations. The
    first one is that parameter must be explicit. The reason is that you cannot infer
    by usage without having a potential room for error. In the following code, the
    argument `a` is implicit `any`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 推断也适用于函数。然而，它有一些限制。第一个限制是参数必须是显式的。原因是，没有潜在的错误空间，你不能通过使用来推断。在下面的代码中，参数`a`是隐式的`any`：
- en: '[PRE80]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'However, the return can be implicit. By returning a known type, the return
    type can be defined:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，返回可以是隐式的。通过返回一个已知类型，可以定义返回类型：
- en: '[PRE81]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the case of returning several values, TypeScript creates a union of all
    potential types. In the following code example, there are two return statements.
    TypeScript looks for each value returned and concludes that two different values are
    returned. The return type generated is `number | string`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回多个值的情况下，TypeScript会创建所有潜在类型的联合。在下面的代码示例中，有两个返回语句。TypeScript会查找每个返回的值，并得出结论，返回了两个不同的值。生成的返回类型是`number
    | string`：
- en: '[PRE82]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how TypeScript can declare variables and which declarator
    is be the best to use depending on the situation. We saw that TypeScript improves
    JavaScript's primitive type by enforcing the type during the lifetime of the variable.
    We explained how to transform a variable into a multiple type container with the
    concept of the union. TypeScript brings type to functions and we saw how we could
    improve the readability of a function that takes many combinations of arguments
    and return types with the overload function. TypeScript brings a new way to type
    variables with the popular `enum` borrowed from popular languages such as Java
    and C#. Finally, we glimpsed at how TypeScript is smart to infer types in different
    situations that can be advantageous to reduce lengthy definitions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了TypeScript如何声明变量，以及根据情况选择哪种声明符是最好的。我们看到了TypeScript通过在变量的生命周期内强制类型来改进JavaScript的原始类型。我们解释了如何通过联合的概念将变量转换为一个多类型容器。TypeScript将类型引入到函数中，我们看到了如何通过重载函数来提高接受许多参数组合和返回类型的函数的可读性。TypeScript通过从像Java和C#这样的流行语言中借用的流行`enum`引入了一种新的变量类型。最后，我们简要地了解了TypeScript在不同情况下如何智能地推断类型，这可以有利于减少冗长的定义。
- en: In the next chapter, we will see in detail the differences between many different
    object types and look at how we can manipulate types to have a strongly typed
    code flexible enough to fulfil our needs of defining our business models with
    TypeScript.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨许多不同对象类型之间的差异，并查看我们如何通过操作类型来拥有足够灵活的强类型代码，以满足我们使用TypeScript定义业务模型的需求。
