- en: Chapter 6. Data Binding, and Why You Should Embrace It
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 数据绑定，以及为什么你应该拥抱它
- en: The View layer of a single page application goes far beyond statically displaying
    HTML and data through JavaScript templating engines or other means. A modern JavaScript
    application must handle real-time updates and be imbued with reactivity. Some
    of the protocols described in [Chapter 4](ch04.html "Chapter 4. REST is Best –
    Interacting with the Server Side of Your App"), *REST is Best - Interacting with
    the Server Side of Your App* such as WebSockets, MQPP, and DDP can be used to
    actively retrieve updates to data for an application, but the ability to bind
    those changes to the DOM and display them in the View must be handled on the frontend
    of the application. This is where data binding comes into play.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用的视图层远远超出了通过JavaScript模板引擎或其他方式静态显示HTML和数据。一个现代的JavaScript应用必须处理实时更新并具有反应性。在[第4章](ch04.html
    "第4章。REST是最佳选择 - 与应用的客户端交互")中描述的一些协议，如WebSockets、MQPP和DDP，可以用来主动检索应用的数据更新，但将这些更改绑定到DOM并在视图中显示的能力必须在应用的前端处理。这就是数据绑定发挥作用的地方。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: What data binding is?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是数据绑定？
- en: The differences between one-way and two-way data binding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向和双向数据绑定的区别
- en: The AngularJS implementation of data binding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS的数据绑定实现
- en: Other popular implementations of data binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他流行的数据绑定实现
- en: How to implement data binding with native JavaScript?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用原生JavaScript实现数据绑定？
- en: What some use cases of data binding are?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定的某些用例是什么？
- en: What is data binding?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是数据绑定？
- en: At a high level, data binding is a software design pattern specifying the ability
    to directly tie changes to your underlying application data, or Model, to the
    View by visually reflecting those changes automatically. This can be done by any
    number of means using JavaScript, and it is really dependent upon what version
    of JavaScript you are using and its abilities and limitations. In the case of
    a web application, those abilities and limitations are governed by the user's
    browser, of course, and this is why there are so many implementations of data
    binding in the JavaScript community.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，数据绑定是一种软件设计模式，它指定了将更改直接绑定到你的底层应用数据，或模型，到视图的能力，通过视觉上自动反映这些更改。这可以通过使用JavaScript的多种方式来完成，并且这实际上取决于你使用的JavaScript版本及其能力和限制。在Web应用的情况下，这些能力和限制当然是由用户的浏览器控制的，这也是为什么在JavaScript社区中有如此多的数据绑定实现。
- en: If you have worked with any popular JavaScript frameworks, or at least have
    read about any of them, you have probably heard of data binding. You also have
    probably never attempted to implement it on your own, considering the number of
    libraries and frameworks out there that provide this capability. The advantage
    that some of these implementations give you is cross-browser compatibility by
    using multiple methods and feature detection in the browser for the delegation
    of those methods. Other frameworks, such as Ember.js and Knockout.js, use their
    own proprietary implementation of data binding that works across most browsers,
    but requires loading a potentially large library when all you want is the data
    binding feature.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过任何流行的JavaScript框架，或者至少阅读过关于它们的资料，你可能已经听说过数据绑定。你也可能从未尝试过自己实现它，考虑到现在有那么多库和框架提供了这种功能。这些实现中的一些给你带来的优势是通过在浏览器中使用多种方法和功能检测来提供跨浏览器兼容性。其他框架，如Ember.js和Knockout.js，使用它们自己的专有数据绑定实现，这些实现可以在大多数浏览器中工作，但如果你只想使用数据绑定功能，可能需要加载一个可能很大的库。
- en: Using a library or framework for complex data observation is often more desirable
    than writing custom JavaScript to do it yourself, which speaks to the popularity
    of frameworks such as AngularJS - often touted for its data binding features.
    Leveraging these features is one thing, but understanding how they work and what
    is going on under the hood of a framework is quite another. First, let's break
    down the concept of data binding a bit more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库或框架进行复杂的数据观察通常比编写自定义JavaScript来自己实现更受欢迎，这也说明了AngularJS等框架的流行——它经常因其数据绑定功能而受到赞誉。利用这些功能是一回事，但理解它们是如何工作的以及框架底层发生了什么则是另一回事。首先，让我们更深入地分解一下数据绑定的概念。
- en: One-way data binding
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单向数据绑定
- en: 'One-way, or unidirectional, data binding is when a change to an application''s
    data model is updated and subsequently reflected in the View. The initial change
    to the data model can come from anywhere, be it the submission of a form from
    the current user, the edit of a post of a different user on another computer,
    or a change in current data pushed directly from the application''s host server.
    When the change in that data is automatically merged with a dynamic template and
    updated in the View without intervention from the user, it is known as one-way
    data binding:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单向，或单向，数据绑定是指应用程序数据模型的更改被更新，并随后反映在视图中。数据模型的初始更改可能来自任何地方，无论是当前用户提交表单，还是另一台计算机上不同用户的帖子编辑，或者是应用程序的主服务器直接推送的当前数据变化。当数据的变化自动与动态模板合并并在视图中更新，而不需要用户的干预时，这被称为单向数据绑定：
- en: '![One-way data binding](img/B05228_06_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![单向数据绑定](img/B05228_06_01.jpg)'
- en: One-way data binding is visualized in a View from the merging of a ViewModel
    with a Template.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单向数据绑定通过将 ViewModel 与模板合并在视图中进行可视化。
- en: Here, you can see a simple representation of the one-way data binding design
    pattern. The manner in which the update to the View ultimately takes place relies
    entirely on how the application's frontend JavaScript is written, and can be done
    in any number of ways, but the conceptual pattern itself remains unvarying.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到单向数据绑定设计模式的一个简单表示。视图更新的方式完全取决于应用程序的前端 JavaScript 编写方式，可以以任何数量的方式完成，但概念模式本身保持不变。
- en: Using a JavaScript templating engine, like the ones discussed in *[Chapter 5](ch05.html
    "Chapter 5. Its All About the View")*, *Its All About the View* provides one-way
    data binding at the template level when expressions in the compiled templates
    are bound to dynamic data. Updating the view to reflect real-time changes to that
    data, however, must be handled with additional code that observes for model changes
    and triggers updates to the view accordingly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript 模板引擎，如第 5 章中讨论的，*关于视图的一切*在编译模板中的表达式绑定到动态数据时，在模板级别提供单向数据绑定。然而，要更新视图以反映数据的实时变化，必须使用额外的代码来观察模型更改并相应地触发视图更新。
- en: Two-way data binding
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向数据绑定
- en: 'Two-way, or bidirectional, data binding includes the one-way data binding pattern
    but additionally allows changes to the representation of data in the View by the
    user to be reflected in the underlying Model itself. With this pattern in place,
    the data displayed in the View is always a representation of the current state
    of the Model, even when the user makes changes to that data in the View without
    explicitly submitting it via forms or other means:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 双向，或双向，数据绑定包括单向数据绑定模式，但还允许用户更改视图中数据的表示，并反映在底层的模型本身中。有了这种模式，视图中显示的数据始终是模型当前状态的表示，即使用户在视图中更改了这些数据，而没有通过表单或其他方式明确提交：
- en: '![Two-way data binding](img/B05228_06_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![双向数据绑定](img/B05228_06_02.jpg)'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Two-way data binding is visualized in a View from changes to the ViewModel merged
    with a template, and changes by the user to the representations of the data in
    the View are merged back into the ViewModel.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 双向数据绑定通过从 ViewModel 的更改合并到模板中在视图中进行可视化，并且用户对视图中数据表示的更改会合并回 ViewModel。
- en: This diagram shows the two-way data binding design pattern. In order for this
    pattern to work, there must be some type of observer in place that is continuously
    watching for changes to the data and syncing it in both directions. This naturally
    requires a more complex frontend architecture, and popular frameworks such as
    AngularJS can be leveraged to take the reins.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了双向数据绑定设计模式。为了使此模式工作，必须有一些类型的观察者持续监视数据的变化，并在两个方向上同步它。这自然需要一个更复杂的客户端架构，并且可以使用流行的框架，如
    AngularJS，来掌握主动权。
- en: Data binding with modern JavaScript frameworks
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现代 JavaScript 框架进行数据绑定
- en: Due to the complexity that comes with data binding design patterns, there are
    some standalone JavaScript libraries, such as Rivets.js and Knockout.js, that
    can provide it for you. Many full-fledged JavaScript frameworks also include their
    own implementations of data binding as a core feature.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据绑定设计模式带来的复杂性，有一些独立的 JavaScript 库，例如 Rivets.js 和 Knockout.js，可以为你提供这项功能。许多完整的
    JavaScript 框架也包含它们自己的数据绑定实现，作为核心功能之一。
- en: Data binding with AngularJS
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AngularJS 进行数据绑定
- en: AngularJS, which is maintained by Google, is one of the most popular modern
    JavaScript frameworks. As discussed in [*Chapter 2*](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*
    it is a self-avowed MVW framework. In addition to its MVW architectural pattern
    implementation, it includes a powerful data binding design pattern, which is often
    its most touted feature.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由谷歌维护的AngularJS是现代JavaScript框架中最受欢迎的之一。正如在[*第二章*](ch02.html "第二章。模型-视图-任意")中讨论的，*模型-视图-任意*是一个自诩的MVW框架。除了其MVW架构模式的实现外，它还包括一个强大的数据绑定设计模式，这通常是它最被吹嘘的功能。
- en: One-way data binding with AngularJS
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AngularJS的单向数据绑定
- en: 'One-way data binding with AngularJS is achieved when an expression in the View
    is populated by a value from the Model associated with the Controller for that
    View. Consider the following Controller and Model data:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图中的一个表达式被与该视图关联的控制器中的模型值填充时，就实现了AngularJS的单向数据绑定。考虑以下控制器和模型数据：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The user Model that is defined on the scope for this Controller can be represented
    in the View with the following template markup:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在此控制器的作用域上定义的用户模型可以用以下模板标记在视图中表示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Just like with many other JavaScript templating engines, the double curly brace
    syntax is used to represent expressions to be evaluated in an AngularJS template.
    Additionally, AngularJS allows for the use of the ng-bind attribute on empty HTML
    elements to be used in place of the double curly brace syntax for expressions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多其他JavaScript模板引擎一样，AngularJS模板中使用双大括号语法来表示要评估的表达式。此外，AngularJS允许在空HTML元素上使用ng-bind属性，以替代双大括号语法来表示表达式：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This syntax is more verbose, but may be preferable to some. In either case,
    changes to the Model properties will be automatically updated in the View where
    those properties are bound by their respective template expressions. In this way,
    AngularJS provides the underlying DOM manipulation layer that wires Model changes
    to be updated in the View without any further code being necessary.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法更冗长，但可能对某些人来说更可取。在任何情况下，模型属性的更改都将自动更新到视图，这些属性通过它们各自的模板表达式绑定。这样，AngularJS提供了底层DOM操作层，将模型更改与视图更新连接起来，而无需任何其他代码。
- en: Two-way data binding with AngularJS
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AngularJS的双向数据绑定
- en: Two-way data binding with AngularJS is achieved when an editable value in the
    View, such as a text input, is assigned to a property on the Model for the current
    Controller scope. When the value for that property is changed by the user, the
    Model will be updated automatically, and that change will be propagated back to
    the View for any expression that is bound to that Model property.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图中的可编辑值，如文本输入，被分配给当前控制器作用域的模型属性时，就实现了AngularJS的双向数据绑定。当用户更改该属性的值时，模型将自动更新，并且该更改将传播回视图，以任何绑定到该模型属性的任何表达式。
- en: 'Using the Controller and Model from the previous example, consider the following
    template markup:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前一个示例中的控制器和模型，考虑以下模板标记：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The text inputs are given the ng-model attribute to assign a Model property
    as the value when the View is initially loaded. When the user changes the value
    for either of these inputs, the $scope.user Model will be updated, and the change
    will then be reflected in the paragraph block above the inputs where the same
    properties are bound to the DOM by their respective expressions. This round-trip
    from a change in the View to the Model and back to the View again is a simple
    example of two-way data binding.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 文本输入被赋予ng-model属性，在视图最初加载时将模型属性作为值分配。当用户更改这些输入中的任何一个的值时，$scope.user模型将被更新，然后该更改将在输入上方的段落块中反映出来，其中相同的属性通过它们各自的表达式绑定到DOM。从这个视图中的变化到模型，再到视图的往返是双向数据绑定的一个简单示例。
- en: Dirty checking with AngularJS
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AngularJS的脏检查
- en: 'AngularJS uses a method of polling for changes to find differences between
    the Model and the View, and this method is referred to as dirty checking. This
    checking is done on a defined interval, which is referred to as the digest cycle**.**
    For each digest cycle, special methods called watches are registered with listeners
    by the scope to watch for changes to bound expressions that are passed to them:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS使用轮询方法来查找模型和视图之间的差异，这种方法被称为脏检查。这种检查是在定义的间隔内进行的，这被称为消化周期**。**对于每个消化周期，作用域通过注册监听器来注册特殊方法，称为观察者，以监视传递给它们的绑定表达式的变化：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As explained in [Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*
    the *scope* is a JavaScript object that defines the Model context for variable
    expressions in the View. The watches compare bound Model expressions with their
    previous values and if any of them are found to be *dirty*, or different, the
    listener callbacks are executed and the changes are then synced to the View.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](ch02.html "第2章。模型-视图-Whatever")所述，*模型-视图-Whatever* 中的 *作用域* 是一个 JavaScript
    对象，它为视图中的变量表达式定义了模型上下文。观察者将绑定模型表达式与其先前值进行比较，如果其中任何一个被发现是 *脏的* 或不同的，则执行监听器回调，并将更改同步到视图。
- en: AngularJS allows dirty checking to be performed at multiple levels of depth
    for an object, depending on your needs. There are three types of watch provided
    for this, with three respective depths. These levels provide for flexible data
    binding features, but with more depth comes more performance concerns.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 允许根据您的需求在对象的多个深度级别上进行脏检查。为此提供了三种类型的观察，分别对应三个深度级别。这些级别提供了灵活的数据绑定功能，但深度越大，性能问题就越多。
- en: Dirty checking by reference
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过引用进行脏检查
- en: The standard method of dirty checking in AngularJS watches for the entire value
    of a bound expression to change to a new value. This is referred to as dirty checking
    by reference. If the expression represents an object or an array, and only changes
    to its properties or members are made, the change will not be detected. This is
    the lowest depth of dirty checking, and thereby the most performant.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 中脏检查的标准方法是在绑定表达式的整个值改变为新值时进行观察。这被称为通过引用进行脏检查。如果表达式表示一个对象或数组，并且只对其属性或成员进行更改，则更改将不会被检测到。这是脏检查的最深层次，因此性能最佳。
- en: 'As an example, consider a user object with multiple properties is applied to
    the scope:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个具有多个属性的用户对象被应用于作用域：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now a watch expression can be bound by reference to one of the object''s properties:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以绑定一个观察表达式，通过引用到对象的一个属性：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since user.firstName has changed, this will be picked up in the subsequent
    digest cycle and the listener function will be triggered. Now consider instead
    that we watch the user object itself:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 user.firstName 已更改，这将在后续的消化周期中被捕获，并将触发监听器函数。现在考虑相反的情况，我们观察用户对象本身：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, nothing is picked up by the watch after user.lastName is changed.
    This is because the watch is looking for the user object itself to change - not
    one of its individual properties:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在更改 user.lastName 之后，观察者没有捕获到任何内容。这是因为观察者正在寻找用户对象本身的更改 - 而不是其单个属性：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you were to instead replace the entire user object itself, the watch would
    find the value to be *dirty* and would then invoke the listener during the next
    digest cycle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要替换整个用户对象本身，观察者会发现值是 *脏的*，然后在下一个消化周期中调用监听器。
- en: Dirty checking by collection contents
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过集合内容进行脏检查
- en: 'If you need to watch for shallow changes to an object or an array, AngularJS
    provides another method for watching called `$watchCollection`. In this context,
    *shallow* means that the watch will only respond to changes at the first level
    of the object or array `**- deep**` property changes, or those of nested objects
    or arrays, will not be detected. AngularJS calls this dirty checking by collection
    contents:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要观察对象或数组的浅层更改，AngularJS 提供了另一种观察方法，称为 `$watchCollection`。在这种情况下，*浅层* 意味着观察者只会对对象或数组的第一个级别的更改做出响应，`**-
    深层**` 属性更改，或嵌套对象或数组的更改将不会被检测到。AngularJS 将此称为通过集合内容进行脏检查：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, changing a property of the user object from the previous example
    would be picked up by the watch and trigger the `listener`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，从上一个示例中更改用户对象的属性将被观察者捕获并触发 `监听器`：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Dirty checking by collection contents is not as performant as checking by reference
    because a copy of the watched object or array must be kept in memory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集合内容进行脏检查的性能不如通过引用进行脏检查，因为必须在内存中保留被观察对象或数组的副本。
- en: Dirty checking by value
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过值进行脏检查
- en: 'AngularJS also allows you to watch for changes on any nested data within an
    object or array. This is referred to as dirty checking by value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 还允许您观察对象或数组中任何嵌套数据的更改。这被称为通过值进行脏检查：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can implement this method of watching using the `$watch` method, just as
    you would with checking by reference, but with an added third parameter set to
    true. This parameter tells the watch whether you want to check for object equality
    or not, and it defaults to false. When the watch checks for equality by reference,
    it performs a simple `!==` conditional. When the third parameter of $watch is
    set to true, however, it uses the internal angular.equals method for a deep comparison.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`$watch`方法实现此监视方法，就像使用引用检查一样，但添加一个设置为true的第三个参数。此参数告诉监视器您是否想要检查对象相等性，它默认为false。当监视器通过引用检查相等性时，它执行简单的`!==`条件。然而，当$watch的第三个参数设置为true时，它使用内部angular.equals方法进行深度比较。
- en: The `angular.equals` method can be used to compare any two values, and it supports
    value types, regular expressions, objects, and arrays. If a property being compared
    is a function or its name begins with `$`, it will be ignored. The reason for
    ignoring functions is obvious, and as for the `$` prefix, it is likely done to
    avoid AngularJS internal functionality from being overwritten.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`angular.equals` 方法可以用来比较任何两个值，它支持值类型、正则表达式、对象和数组。如果被比较的属性是一个函数或其名称以 `$` 开头，它将被忽略。忽略函数的原因很明显，至于
    `$` 前缀，可能是为了避免AngularJS内部功能被覆盖。'
- en: Dirty checking by value is the most comprehensive form of data binding in AngularJS,
    but it is also the least performant. This is because a full copy of any complex
    object or array being compared must be held in memory, as is the case with dirty
    checking by collection contents, but additionally, a deep traversal of the entire
    object or array must be performed on each digest cycle. To maintain memory efficiency
    in your application, care should be taken when using this type of data binding
    with AngularJS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值进行脏检查是AngularJS中最全面的数据绑定形式，但同时也是性能最差的。这是因为必须将任何复杂对象或数组被比较的完整副本保留在内存中，就像通过集合内容进行脏检查一样，但除此之外，还必须在每个消化周期中对整个对象或数组进行深度遍历。为了在您的应用程序中保持内存效率，使用这种类型的数据绑定时应该格外小心。
- en: When to use dirty checking for data binding
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用脏检查进行数据绑定
- en: The dirty checking approach to data binding has its pros and cons. AngularJS
    assures us that memory is not a concern as long as you are not doing several thousand
    bindings in a single view. A downside is, however, that changes to the Model will
    not always show up in real time due to the latency of the digest cycle. If you
    are designing an application in which you would like to display true real-time,
    two-way data binding, then AngularJS may not be the solution for you.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定的脏检查方法有其优点和缺点。AngularJS向我们保证，只要您在一个视图中不进行数千次绑定，内存就不会成为问题。然而，缺点是，由于消化周期的延迟，模型的变化并不总是实时显示。如果您正在设计一个希望显示真正实时、双向数据绑定的应用程序，那么AngularJS可能不是您的解决方案。
- en: Data binding with Ember.js
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ember.js进行数据绑定
- en: Ember.js is a popular open source JavaScript framework for building web applications.
    It is similar to AngularJS in its provided features, but it takes quite a different
    approach to data binding.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js是一个流行的开源JavaScript框架，用于构建Web应用程序。它在提供的功能上与AngularJS相似，但在数据绑定方面采取了相当不同的方法。
- en: Ember.js runs an internal loop, similar to the digest cycle in AngularJS, called
    the `**run loop**`. It does not use dirty checking on bound Model data, but it
    maintains the run loop for other internal functionality, such as scheduling work
    queues to be performed in a particular order. The main reason behind scheduling
    operations within the run loop is to provide memory management and optimize the
    efficiency of the framework.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js运行一个内部循环，类似于AngularJS中的消化周期，称为`**运行循环**`。它不对绑定模型数据使用脏检查，但维护运行循环以执行其他内部功能，例如按特定顺序执行工作队列。在运行循环中安排操作的主要原因是提供内存管理和优化框架的效率。
- en: Ember.js uses property accessors to provide data binding, which means it uses
    direct object properties to get and set bound Model values. With this mechanism
    in place, it can forgo dirty checking to employ data binding.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js使用属性访问器来提供数据绑定，这意味着它使用直接对象属性来获取和设置绑定模型的值。有了这种机制，它可以放弃脏检查来使用数据绑定。
- en: Computed properties
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算属性
- en: 'Ember.js uses computed properties via object property accessors internally
    for setting and getting values. This means that properties are defined as functions
    that perform some type of manipulation to produce the final values that are returned.
    To do this, the native JavaScript object type is extended with the internal `Ember.Object.extend`
    method, and computed properties are returned using the `Ember.computed` method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js通过对象属性访问器内部使用计算属性来设置和获取值。这意味着属性被定义为执行某种类型操作以产生最终返回值的函数。为此，使用内部`Ember.Object.extend`方法扩展了原生的JavaScript对象类型，并使用`Ember.computed`方法返回计算属性：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For this extended `User` object, the `firstName` and `lastName` properties are
    static, but the `fullName` property is computed with the `'firstName'` and `'lastName'`
    strings passed to it as parameters. This tells the computed method that those
    properties of the extended object are to be used in computing the returned value
    for `fullName`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个扩展的`User`对象，`firstName`和`lastName`属性是静态的，但`fullName`属性是通过传递给它的参数`'firstName'`和`'lastName'`字符串计算得出的。这告诉计算方法，扩展对象的这些属性将用于计算`fullName`返回的值。
- en: 'Now, to access the value that is returned by `fullName`, a new User object
    must first be created with the static `firstName` and `lastName` properties defined:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要访问`fullName`返回的值，必须首先使用静态的`firstName`和`lastName`属性创建一个新的`User`对象：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once a `currentUser` object is created with a given `firstName` and `lastName`
    value, the `fullName` property can be computed and returned:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用给定的`firstName`和`lastName`值创建了一个`currentUser`对象，就可以计算并返回`fullName`属性：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This convention of extending objects is a bit verbose, but it allows Ember.js
    to handle the computed properties internally and track bound objects while also
    normalizing JavaScript inconsistencies across various user agents, or browsers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种扩展对象的约定有点冗长，但它允许Ember.js在内部处理计算属性，同时跟踪绑定对象，并在各种用户代理或浏览器之间规范化JavaScript的不一致性：
- en: One-way data binding with Ember.js
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ember.js通过对象属性访问器内部使用计算属性来设置和获取值。这意味着属性被定义为执行某种类型操作以产生最终返回值的函数。为此，使用内部`Ember.Object.extend`方法扩展了原生的JavaScript对象类型，并使用`Ember.computed`方法返回计算属性：
- en: 'Ember.js uses computed properties in its data binding implementation, which
    means that direct property accessors can be used and no dirty checking is necessary.
    For one-way bindings, you can get the property for an object, but you cannot set
    it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js在其数据绑定实现中使用计算属性，这意味着可以直接使用属性访问器，并且不需要进行脏检查。对于单向绑定，你可以获取对象的属性，但不能设置它：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, the `Ember.computed.oneWay` method is used to apply a one-way
    binding for the `nickName` property as an *alias* of the `firstName` property:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用`Ember.computed.oneWay`方法将`nickName`属性作为一个*别名*应用于`firstName`属性的单一方向绑定：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When a new User object is created, the `nickName` property for it can then
    be accessed:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的`User`对象时，可以访问它的`nickName`属性：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since this is only a one-way binding, however, the `nickName` property cannot
    be used to set the aliased `firstName` property:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个单向绑定，因此`nickName`属性不能用来设置别名的`firstName`属性：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Often, you may only need to return bound values in an application and not implicitly
    set them from the View. Wither Ember.js, the `Ember.computed.oneWay` method can
    be used for this purpose and will save you additional performance concerns.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能只需要在应用程序中返回绑定值，而不是从视图隐式设置它们。使用Ember.js，可以使用`Ember.computed.oneWay`方法来实现这个目的，并将节省你额外的性能担忧。
- en: Two-way data binding with Ember.js
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ember.js也通过计算属性提供双向数据绑定。
- en: 'Two-way data binding is also available with Ember.js via computed properties.
    This uses an alias paradigm as well; however, a computed two-way alias allows
    for both getting and setting an aliased property:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js也通过计算属性提供双向数据绑定。这也使用了一个别名范式；然而，计算的双向别名允许获取和设置别名的属性：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this instance, we are using the Ember.computed.alias method to employ two-way
    data binding for the aliased `firstName` property via the computed `nickName`
    property:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`Ember.computed.alias`方法通过计算`nickName`属性来为别名的`firstName`属性实现双向数据绑定：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When a new User object is created now, the `nickName` property can be accessed
    to both set and get the aliased `firstName` property:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当现在创建一个新的`User`对象时，可以通过`nickName`属性来设置和获取别名的`firstName`属性：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, with two-way data binding, View synchronization comes into play. One thing
    to note about Ember.js in this scenario is that, although it does not use dirty
    checking, it will not immediately update values bound to the Model after they
    are changed. Property accessors are indeed used to aggregate changes to bound
    data, but they are not synchronized until the next run loop, just as with AngularJS
    and its digest cycle. In this respect, you could surmise that data binding with
    AngularJS versus Ember.js is really no different, and neither framework provides
    any benefit over the other in this regard.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着双向数据绑定，视图同步开始发挥作用。在这个场景中关于 Ember.js 有一点需要注意，尽管它不使用脏检查，但在模型值改变后，它不会立即更新绑定到模型上的值。属性访问器确实用于聚合绑定数据的更改，但它们只有在下一个运行循环时才会同步，就像
    AngularJS 和其消化周期一样。在这方面，你可以推断出，与 Ember.js 相比，AngularJS 的数据绑定实际上并没有太大区别，并且在这方面的框架之间也没有任何优势。
- en: Keep in mind that the internal looping mechanisms implemented in these frameworks
    are designed around performance optimization. The difference in this case is that
    AngularJS uses its digest cycle to check for changes to bound values, in addition
    to its other internal operations, while Ember.js is always aware of changes to
    its bound values and only uses its run loop to synchronize them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些框架中实现的内部循环机制是为了性能优化而设计的。在这种情况下，区别在于 AngularJS 使用其消化周期来检查绑定值的更改，以及其其他内部操作，而
    Ember.js 总是知道其绑定值的更改，并且只使用其运行循环来同步它们。
- en: It is likely that each of these frameworks provides certain advantages over
    the other, depending upon what type of application you are building. When choosing
    a framework to build an application, it is always important to understand these
    internal mechanisms so that you can consider how they may affect performance in
    your particular use case.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，每个框架都提供了一些相对于其他框架的优势，这取决于你正在构建的应用类型。在选择框架来构建应用时，始终了解这些内部机制非常重要，这样你就可以考虑它们可能对你特定用例的性能产生的影响。
- en: Data binding with Rivets.js
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Rivets.js 的数据绑定
- en: Sometimes it is desirable to build an SPA with smaller, more modular libraries
    that provide you with specific functionality, rather than using a full-fledged
    frontend framework such as AngularJS or Ember.js. This could be because you are
    building a simple application that does not necessitate the complexity of an MVW
    architectural pattern, or you may just not want to be constrained by the conventions
    of a framework.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望使用更小、更模块化的库来构建一个单页应用（SPA），这些库为你提供特定的功能，而不是使用像 AngularJS 或 Ember.js
    这样的完整前端框架。这可能是因为你正在构建一个不需要 MVW 架构模式复杂性的简单应用，或者你可能只是不想受框架约定的限制。
- en: Rivets.js is a lightweight library that is primarily designed around data binding,
    and although it does provide some additional features, it makes very few assumptions
    about your application architecture. In this respect, it is a good choice if you
    are only looking to add a data binding layer to a modularized application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Rivets.js 是一个轻量级库，主要围绕数据绑定设计，尽管它提供了一些额外的功能，但它对你的应用架构几乎没有假设。在这方面，如果你只是想向模块化应用添加数据绑定层，它是一个不错的选择。
- en: One-way data binding with Rivets.js
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Rivets.js 的一向数据绑定
- en: Rivets.js uses an internal construct called a *binder* to define how the DOM
    should be updated in response to a change in a bound property's value. The library
    comes with a variety of built-in binders, but also allows you to define your own
    custom binders.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Rivets.js 使用一个内部构造，称为 *绑定器*，来定义在绑定属性值发生变化时如何更新 DOM。该库提供了一系列内置绑定器，但也允许你定义自己的自定义绑定器。
- en: One-way binders in Rivets.js update the DOM when a property on a bound Model
    changes. As you would expect in a one-way scenario, updating the View will not
    update the Model.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rivets.js 中，当绑定模型上的属性发生变化时，单向绑定器会更新 DOM。正如你所预期的单向场景一样，更新视图不会更新模型。
- en: 'Consider the following object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下对象：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using the binder syntax of Rivets.js, these properties can be bound to the
    View as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rivets.js 的绑定器语法，这些属性可以绑定到视图，如下所示：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Rivets.js uses the `rv-` custom attribute prefix on HTML elements to define
    behaviors for different types of binders. The `rv-`text attribute is a built-in
    binder that inserts a bound value directly into the DOM, just as any JavaScript
    templating engine might do. To that point, there is also an expression interpolation
    syntax that uses single curly braces:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Rivets.js使用`rv-`自定义属性前缀在HTML元素上定义不同类型绑定器的行为。`rv-`text属性是一个内置绑定器，它将绑定值直接插入DOM中，就像任何JavaScript模板引擎可能做的那样。就此而言，还有一个使用单括号的表达式插值语法：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With either of these examples, the View would render the following HTML:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个示例中的任何一个，视图将渲染以下HTML：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Changing any properties on the bound Model would also update the View:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更改绑定模型上的任何属性也会更新视图：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The rendered HTML in the View would then reflect these changes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 视图中渲染的HTML将反映这些更改：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Defining your own one-way binder
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义您自己的单向绑定器
- en: 'If none of the many predefined binders in Rivets.js fits your needs, you can
    always define your own:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Rivets.js中预定义的许多绑定器都无法满足您的需求，您始终可以定义自己的：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, we have created a binder called size, which can be used to
    dynamically change the CSS font-size property for an element based on a Model
    value:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了一个名为size的绑定器，可以根据模型值动态更改元素的CSS字体大小属性：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The custom binder can then be used in the View as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以在视图中如下使用自定义绑定器：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This would render the View with the `dog.favoriteThing` value displayed at twice
    the font-size of the body text, as defined in the bound dog Model.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使视图以`dog.favoriteThing`值显示，其字体大小是正文文本的两倍，正如在绑定的狗模型中定义的那样。
- en: Two-way data binding with Rivets.js
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Rivets.js进行双向数据绑定
- en: Two-way binders in Rivets.js behave just as one-way binders do when a Model
    is updated by synchronizing the bound values in the View, but they will also update
    the Model when bound values in the View are changed by the user. This behavior
    could be triggered by form input or some other type of event, such as clicking
    a button.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型通过同步视图中的绑定值更新时，Rivets.js中的双向绑定器的行为与单向绑定器相同，但它们也会在视图中的绑定值被用户更改时更新模型。这种行为可能由表单输入或其他类型的事件触发，例如点击按钮。
- en: 'There are some predefined two-way binders included with Rivets.js. As you might
    expect, it provides for the most common use case `- a` text input:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Rivets.js包含一些预定义的双向绑定器。正如您所期望的，它为最常见的用例提供支持——一个文本输入：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using the `rv-value` attribute to bind a Model property to an input element
    will prepopulate the value for that input with the bound Model value, and it will
    also update the Model value when the user changes the value of the input.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rv-value`属性将模型属性绑定到输入元素将使用绑定模型的值预先填充该输入的值，并且当用户更改输入的值时，它也会更新模型值。
- en: Defining your own two-way binder
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义您自己的双向绑定器
- en: 'To define a custom two-way binder in Rivets.js, a much more explicit approach
    must be taken, in contrast to one-way binders. This is because you must define
    how to bind and unbind to an element, as well as the data binding routine to run
    when the bound value changes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rivets.js中定义自定义的双向绑定器需要采取更明确的方法，与单向绑定器相比。这是因为您必须定义如何绑定和解除绑定到元素，以及当绑定值更改时运行的数据绑定例程：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using the special property definitions shown in this example, we are telling
    Rivets.js to bind to an input `onfocus` and to unbind from the input `onblur`.
    Additionally, we define a routine to run when the value changes in which a `className`
    of invalid is added to the input when the value is empty, and removed when it
    is populated.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此示例中显示的特殊属性定义，我们正在告诉Rivets.js绑定到`onfocus`输入，并在`onblur`输入时解除绑定。此外，我们定义了一个在值更改时运行的例程，当值为空时，向输入添加`className`为invalid，当值被填充时移除。
- en: Implementing data binding with native JavaScript
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原生JavaScript实现数据绑定
- en: 'Writing your own implementation of data binding can be done fairly easily using
    native JavaScript. If you don''t feel the need to use a comprehensive framework
    or library for your application and simply want the benefit of the data binding
    design pattern baked in, using native JavaScript to implement it is a logical
    course to take. This will provide you with several benefits, including the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生JavaScript编写自己的数据绑定实现可以相当容易地完成。如果您不需要为您的应用程序使用全面的框架或库，并且只想利用数据绑定设计模式的好处，使用原生JavaScript来实现它是合乎逻辑的选择。这将为您带来以下好处：
- en: You will understand how the data binding actually works under the hood
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将了解数据绑定实际上是如何在底层工作的
- en: You will have a less bloated frontend that doesn't include extraneous library
    code that you may not even use
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将拥有一个更精简的前端，它不包括你可能甚至没有使用的额外库代码。
- en: You won't be pigeonholed into an architecture defined by a particular framework
    when all you want is the added benefit of data binding
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你只想要数据绑定的额外好处时，你不会局限于由特定框架定义的架构。
- en: Object getters and setters
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象获取器和设置器
- en: The `Object` type in JavaScript has native `get` and `set` properties that can
    be used as `getters` and `setters` for any property name on a particular object.
    A `getter` is a method that returns a dynamically computed value from an object,
    and a `setter` is a method that is used to pass a value to a given property on
    an object as if you were assigning it that value. When a setter is defined and
    passed a value, the property name for that setter cannot actually hold a value
    itself; however, it can be used to *set* the value on a completely different variable.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`Object`类型具有原生的`get`和`set`属性，可以用作特定对象上任何属性名的`getter`和`setter`。`getter`是一个返回对象动态计算值的函数，而`setter`是一个用于将值传递给对象上给定属性的函数，就像你正在分配该值一样。当定义了设置器并传递了值时，该设置器的属性名本身实际上不能持有值；然而，它可以用来在完全不同的变量上`设置`值。
- en: The `get` and `set` properties default to `undefined`, just like any unassigned
    property on an object, so they can easily be defined as functions for any user-defined
    object without affecting JavaScript's native `Object` prototype. This can be a
    powerful tool when used in an appropriate manner within an intuitive design pattern
    such as data binding.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`和`set`属性默认为`undefined`，就像对象上的任何未分配属性一样，因此它们可以很容易地定义为任何用户定义对象的函数，而不会影响JavaScript的本地`Object`原型。当在直观的设计模式（如数据绑定）中适当使用时，这可以是一个强大的工具。'
- en: The object initializer
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象初始化器
- en: '`Getters` and `setters` can be defined for an object using an object initializer,
    which is most commonly performed by defining an object in literal notation. For
    example, suppose we want to create a `getter` and a `setter` for the `firstName`
    property on an object named user:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用对象初始化器为对象定义`getter`和`setter`，这通常是通过使用字面量表示法定义对象来完成的。例如，假设我们想在名为`user`的对象上为`firstName`属性创建一个`getter`和一个`setter`：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this instance, we can use the `user.firstName` property to `get` and `set`
    the value for the `firstName` variable by simply using standard object literal
    syntax:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以通过简单地使用标准对象字面量语法来使用`user.firstName`属性通过`get`和`set``firstName`变量的值：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, setting `user.firstName = 'Jarmond'` does not actually change
    the value of the `user.firstName` property; rather, it calls the property's defined
    setter method and instead sets the value for the standalone `firstName` variable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，设置`user.firstName = 'Jarmond'`实际上并没有改变`user.firstName`属性的值；相反，它调用了属性定义的设置器方法，并设置了独立的`firstName`变量的值。
- en: The Object.defineProperty() method
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Object.defineProperty()`方法'
- en: 'It may often be the case that you would like to modify an existing object to
    provide data binding for that object in your application. To do this, the `Object.defineProperty()`
    method can be used to add the getter and setter for a particular property on a
    predefined object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想要修改现有的对象，以便在你的应用程序中为该对象提供数据绑定。为此，可以使用`Object.defineProperty()`方法向预定义对象添加特定属性的`getter`和`setter`：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method takes the object you want to define a property for as the first
    argument, the property name you are defining as the second argument, and a `descriptor`
    object as the third argument. The descriptor object allows you to define the `getter`
    and `setter` for the property using the `get` and `set` key names, and it additionally
    allows some other keys to further describe the property.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将你想要定义属性的的对象作为第一个参数，你正在定义的属性名作为第二个参数，以及一个`descriptor`对象作为第三个参数。`descriptor`对象允许你使用`get`和`set`键名来定义属性的`getter`和`setter`，并且它还允许一些其他键来进一步描述属性。
- en: The `configurable` key, if `true`, allows the property's configuration to be
    changed and the property itself to be deleted. It defaults to `false`. The `enumerable`
    key, if `true`, allows the property to be visible when iterating over the parent
    object. It also defaults to `false`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`configurable`键为`true`，则允许更改属性的配置以及删除属性本身。它默认为`false`。如果`enumerable`键为`true`，则允许在遍历父对象时使属性可见。它也默认为`false`。
- en: Using `Object.defineProperty()` is a more concise way to declare the `getter`
    and `setter` for an object's property because you can explicitly configure the
    behavior for that property, in addition to being able to add the property to a
    predefined object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Object.defineProperty()`是一种更简洁的方式来声明对象的属性`getter`和`setter`，因为你可以明确配置该属性的行为，同时还能将属性添加到预定义的对象中。
- en: Designing a getter and setter data binding pattern
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计getter和setter数据绑定模式
- en: 'Now we can take this example further by creating a two-way binding between
    a DOM element and the `user` object for which we have defined a `getter` and `setter`.
    Let''s consider a text input element that is prepopulated with the `firstName`
    value initially when the page loads:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过创建一个DOM元素和我们已经定义了`getter`和`setter`的`user`对象之间的双向绑定来进一步扩展这个例子。让我们考虑一个文本输入元素，它在页面加载时预先填充了`firstName`值：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can define our `getter` and `setter` based on the value of this input
    so that there is a reactive binding between the Model and the View:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据这个输入的值来定义我们的`getter`和`setter`，以便在模型和视图之间建立响应式绑定：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you create a page with the input element and run the code above, you can
    then use the developer console in your browser to set the value of `user.firstName`
    and see it automatically update in the DOM for the value of the input element:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个包含输入元素的页面并运行上面的代码，然后你可以使用浏览器中的开发者控制台设置`user.firstName`的值，并看到它自动更新DOM中输入元素的值：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Additionally, if you change the value in the text input and then check the value
    of the `user.firstName` property in the developer console, you will see that it
    reflects the changed value of the input. With this simple use of a `getter` and
    `setter`, you have architecturally implemented two-way data binding with native
    JavaScript.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你在文本输入中更改了值，然后在开发者控制台中检查`user.firstName`属性的值，你会看到它反映了输入的更改值。通过这种简单的`getter`和`setter`的使用，你已经在架构上实现了使用原生JavaScript的双向数据绑定。
- en: Synchronizing data in the View
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 同步视图中的数据
- en: 'To further extend this example so that representations of the Model in the
    View always remain synchronized and work much like the Rivets.js data binding
    pattern, we can simply add an oninput event callback to our input to update the
    DOM in the desired fashion:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步扩展这个例子，使得模型在视图中的表示始终保持同步，并且工作方式类似于Rivets.js数据绑定模式，我们只需简单地给我们的输入添加一个oninput事件回调来以期望的方式更新DOM：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, if we want other places in the DOM where this data is represented to be
    updated upon changing the value of this input, all we need to do is add the desired
    behavior to the setter for the property. Let's use a custom HTML attribute called
    `data-bind` to convey the property's representation in the DOM outside of the
    text input itself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们希望当这个输入框的值发生变化时，DOM中其他表示这些数据的地方也能更新，我们只需要将所需的行为添加到该属性的setter中。让我们使用一个自定义的HTML属性`data-bind`来传达属性在DOM中的表示，而不仅仅是文本输入本身。
- en: 'First, create a static file with the following HTML:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个包含以下HTML的静态文件：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, below the HTML and just before the closing `</body>` tag of your document,
    add the following JavaScript within `<script>` tags:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在HTML下方，就在文档的`</body>`标签关闭之前，在`<script>`标签内添加以下JavaScript代码：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now load the page in your browser and observe that the `<strong data-bind="firstName">`
    element will be populated with the name `Udis` from the value of the input. This
    is achieved by calling the setter for the `user.firstName` property and assigning
    it to its corresponding `getter` as `user.firstName = user.firstName`. This may
    seem redundant, but what is actually occurring here is the code defined in the
    setter method is being executed with the given value from the text input, which
    is obtained from the `getter`. The setter looks for any element on the page with
    the `data-bind` property set to `firstName` and updates that element's content
    with the `firstName` value from the input, which is represented in the model as
    `user.firstName`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中加载页面，并观察`<strong data-bind="firstName">`元素将根据输入的值填充为`Udis`。这是通过调用`user.firstName`属性的setter并把它赋给相应的`getter`作为`user.firstName
    = user.firstName`来实现的。这看起来可能有些冗余，但实际上，这里正在执行的是setter方法中定义的代码，并使用从`getter`获取的给定值。setter会在页面上查找任何设置了`data-bind`属性为`firstName`的元素，并使用输入中的`firstName`值更新该元素的内容，该值在模型中表示为`user.firstName`。
- en: 'Next, place your cursor in the text input and change the value. Notice that
    the name represented within the `<strong>` element changes as you type, and each
    representation is in sync with the model. Finally, use your developer console
    to update the value of the model:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将光标放在文本输入中并更改值。注意，随着你输入，`<strong>` 元素中代表的名字会改变，每个表示都与模型保持同步。最后，使用你的开发者控制台更新模型的值：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that the representations both in the text input and the `<strong>` element
    are automatically updated and in sync. You have successfully created a two-way
    data binding and View synchronization design pattern using a small amount of native
    JavaScript.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到文本输入和 `<strong>` 元素中的表示都是自动更新并同步的。你已经成功使用少量原生 JavaScript 创建了一个双向数据绑定和视图同步设计模式。
- en: Abstracting the design pattern to a reusable method
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将设计模式抽象为可重用方法
- en: 'You can further abstract your data binding design pattern by creating a method
    that can be used to apply this behavior to a property for any predefined object:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个方法来进一步抽象你的数据绑定设计模式，该方法可以用于将此行为应用于任何预定义对象的属性：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we have created a method called `dataBind`, which takes an object and
    a property as its arguments. The property name is used as an identifier for elements
    in the DOM that are to be bound to the Model:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `dataBind` 的方法，它接受一个对象和一个属性作为参数。属性名称用作 DOM 中要绑定到模型的元素的标识符：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, simply define an object and call the `dataBind` method on it, additionally
    passing in the property name you want to bind to the DOM. This method also allows
    you to set the initial value for the property in the Model, and it will be reflected
    in the View upon binding if it is set. Otherwise, it will display the value set
    on the input itself, if any:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，只需定义一个对象，并在其上调用 `dataBind` 方法，此外还需要传入要绑定到 DOM 的属性名称。此方法还允许你在模型中设置属性的初始值，如果设置了，它将在绑定时反映在视图上。如果没有设置，它将显示输入本身设置的值（如果有的话）：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you modify the code in the page you just created to use the abstracted `dataBind`
    method, you will see that it works exactly as before, but it can now be reused
    to bind multiple object properties with multiple corresponding elements in the
    DOM. This pattern can certainly be further abstracted and combined with a modeling
    pattern in which it could be used as a powerful data binding layer within a JavaScript
    SPA. The open source library inbound.js is a good example of this pattern taken
    to the next level. You can learn more about it at [inboundjs.com](http://inboundjs.com).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改你刚刚创建的页面中的代码以使用抽象的 `dataBind` 方法，你会发现它的工作方式与之前完全相同，但现在它可以被重用来绑定 DOM 中多个相应元素与多个对象属性。这种模式当然可以进一步抽象化，并与建模模式结合，在其中它可以作为一个强大的数据绑定层在
    JavaScript SPA 中使用。开源库 inbound.js 是这种模式提升到更高层次的优秀例子。你可以在 [inboundjs.com](http://inboundjs.com)
    上了解更多信息。
- en: Accounting for DOM mutations
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑 DOM 变化
- en: One downfall of the previous example, when it comes to View synchronization,
    is that only user input will trigger the setting of the Model from the View. If
    you want comprehensive, two-way data binding in which any changes to bound values
    in the View sync to their respective Model properties, then you must be able to
    observe DOM mutations, or changes, by any means.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 之前例子中，在视图同步方面的一个缺点是，只有用户输入会触发从视图设置模型。如果你想要全面的、双向的数据绑定，其中视图中绑定值的任何更改都会同步到相应的模型属性，那么你必须能够通过任何方式观察
    DOM 变化或更改。
- en: 'Let''s take a look at the previous example again:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看之前的例子：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now if you edit the value of the text input, the `firstName` property on the
    Model will update, and the `<strong data-bind="firstName">` element''s contents
    will be updated as well:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你编辑文本输入的值，模型上的 `firstName` 属性将更新，并且 `<strong data-bind="firstName">` 元素的
    内容也将更新：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now let''s instead use the developer console and change the `<strong data-bind="firstName">`
    element''s `innerHTML`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们改用开发者控制台并更改 `<strong data-bind="firstName">` 元素的 `innerHTML`：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After doing this, you will notice that the value of the input has not updated,
    and neither has the Model data:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，你会注意到输入的值没有更新，模型数据也没有更新：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The DOM mutation you created by using the console has now broken your two-way
    data binding and View synchronization. Fortunately, there is a native JavaScript
    constructor that can be used to avoid this pitfall.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过控制台创建的 DOM 变化现在破坏了你的双向数据绑定和视图同步。幸运的是，有一个原生的 JavaScript 构造函数可以用来避免这个陷阱。
- en: MutationObserver
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MutationObserver
- en: The `MutationObserver` constructor provides the ability to observe changes to
    the DOM no matter where they are triggered from. In most cases, user input is
    likely sufficient for triggering Model updates, but if you are building an application
    that may have DOM mutations triggered from other sources, such as data being pushed
    via Websockets, you may want to sync those changes back to your Model.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutationObserver`构造函数提供了观察DOM变更的能力，无论这些变更是从哪里触发的。在大多数情况下，用户输入可能足以触发模型更新，但如果你正在构建一个可能由其他来源（如通过Websockets推送的数据）触发的DOM变更的应用程序，你可能希望将这些变更同步回你的模型。'
- en: MutationObserver works much like the native addEventListener by providing a
    special type of listener that triggers a callback upon DOM mutation. This event
    type is unique in that it is not often triggered by direct user interaction, unless
    the developer console is being used to manipulate the DOM. Instead, application
    code is typically what will be updating the DOM, and this event is triggered directly
    by those mutations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: MutationObserver通过提供一个特殊类型的监听器，在DOM变更时触发回调，其工作方式与原生的addEventListener类似。这种事件类型是独特的，因为它通常不会由直接的用户交互触发，除非开发者控制台被用来操作DOM。相反，通常是应用程序代码在更新DOM，而这个事件是由这些变更直接触发的。
- en: 'A simple `MutationObserver` can be instantiated as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`MutationObserver`可以如下实例化：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, a configuration must be defined to pass to the observe method of the
    new observer object:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，必须定义一个配置来传递给新观察者对象的`observe`方法：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This object is called `MutationObserverInit`. It defines special properties
    that are used by the `MutationObserver` implementation to specify how closely
    an element is to be observed. At least one of `attributes`, `childList`, or `characterData`
    must be set to true, or an error will be thrown:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象被称为`MutationObserverInit`。它定义了特殊属性，这些属性被`MutationObserver`实现用来指定元素应该被观察得多紧密。至少需要将`attributes`、`childList`或`characterData`中的一个设置为true，否则将抛出错误：
- en: '`attributes`: Tells the observer whether mutations to the element''s attributes
    should be observed or not'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes`：告诉观察者是否应该观察元素属性的变更。'
- en: '`childList`: Tells the observer whether the addition and removal of the element''s
    child nodes should be observed or not'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`childList`：告诉观察者是否应该观察元素子节点的添加和删除。'
- en: '`characterData`: Tells the observer whether mutations to the element''s data
    should be observed or not'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`characterData`：告诉观察者是否应该观察元素数据的变更。'
- en: 'There are also four additional, but optional, `MutationObserverInit` properties
    that can be defined:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以定义四个额外的、但可选的`MutationObserverInit`属性：
- en: '`subtree`: If true, tells the observer to watch for mutations to the element''s
    descendants, in addition to the element itself'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtree`：如果为true，告诉观察者除了元素本身外，还要观察元素后代的变更。'
- en: '`attributeOldValue`: If true in conjunction with attributes set to true, tells
    the observer to save the element attributes'' old values before mutation.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributeOldValue`：如果与属性设置为true一起为true，告诉观察者在变更之前保存元素属性的老值。'
- en: '`characterDataOldValue`: If true in conjunction with `characterData` set to
    true, tells the observer to save the element''s old data values before mutation.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`characterDataOldValue`：如果与`characterData`设置为true一起为true，告诉观察者在变更之前保存元素的老数据值。'
- en: '`attributeFilter`: An array specifying attribute names that should not be observed
    in conjunction with attributes set to true.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributeFilter`：一个数组，指定了不应与设置为true的属性一起观察的属性名称。'
- en: 'With the configuration defined, an observer can now be called on a DOM element:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 配置定义后，现在可以在一个DOM元素上调用观察者：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With this code in place, any mutations to the element with the attribute `data-bind="firstName"`
    will trigger the callback defined in the observer object's instantiation of the
    `MutationObserver` constructor, and it will log the mutation object passed to
    the iterator.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，任何对具有属性`data-bind="firstName"`的元素的变更都将触发在观察者对象的`MutationObserver`构造函数实例化中定义的回调，并且它将记录传递给迭代器的变更对象。
- en: Extending dataBind with MutationObserver
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用MutationObserver扩展dataBind
- en: 'Now let''s further extend our `dataBind` method with the `MutationObserver`
    constructor by using it to trigger callbacks when elements with the data-bind
    attribute are mutated:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过使用`MutationObserver`构造函数来触发具有data-bind属性的元素变更时的回调，进一步扩展我们的`dataBind`方法：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `MutationObserver` constructor takes a callback function as its only parameter.
    This callback is passed a mutations object, which can be iterated over to define
    callbacks for each mutation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutationObserver`构造函数仅接受一个回调函数作为其唯一参数。此回调函数传递一个突变对象，可以遍历以定义每个突变的回调：'
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that in the `MutationObserver` instantiation callback, we perform an inequality
    comparison of the bound Model property to the `mutation.target.innerHTML`, which
    is the content of the DOM element being observed, before we set the Model property.
    This is important because it provides that we only set the bound Model property
    when there is a DOM mutation triggered directly on this particular DOM node, and
    not as a result of a setter. If we did not perform this check, all setters would
    trigger the callback, which calls the setter again, and infinite recursion would
    ensue. This is, of course, not desirable.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`MutationObserver`实例化回调中，我们在设置模型属性之前，对绑定模型属性与`mutation.target.innerHTML`进行不等式比较，后者是被观察的DOM元素的内容。这是很重要的，因为它确保我们只在直接触发此特定DOM节点的DOM突变时设置绑定的模型属性，而不是作为设置器的结果。如果我们不执行此检查，所有设置器都会触发回调，这会再次调用设置器，从而导致无限递归。这当然是不希望的。
- en: 'Using the new version of the `dataBind` method, test the HTML page in a browser
    again and update the input value:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dataBind`方法的新版本，在浏览器中再次测试HTML页面并更新输入值：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, use the developer console to change the bound Model property and you
    will see it update in the DOM for both the input and the `<strong data-bind="firstName">`
    element, as originally expected:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用开发者控制台更改绑定的模型属性，你将看到它在DOM中的输入和`<strong data-bind="firstName">`元素中更新，正如预期的那样：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, use the developer console to change the innerHTML of the `<strong
    data-bind="firstName">` element and trigger a mutation event:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用开发者控制台更改`<strong data-bind="firstName">`元素的`innerHTML`并触发一个突变事件：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This time, you will see the value of the input element update as well. This
    is because the mutation event was triggered and detected by the observer object,
    which then fired the callback function. Within that callback function, the `obj[prop]
    !== val` comparison was made and found to be true, so the setter was called on
    the new value, subsequently updating the input value and the value returned from
    the `user.firstName` property:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你将看到输入元素的值也会更新。这是因为突变事件被观察对象触发并检测到，然后触发了回调函数。在回调函数内部，进行了`obj[prop] !== val`的比较，并发现为真，因此对新值调用了设置器，随后更新了输入值和从`user.firstName`属性返回的值：
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You have now implemented two-way data binding and comprehensive view synchronization
    using native `getters` and setters and the `MutationObserver` constructor. Keep
    in mind that the examples given here are experimental and have not been used in
    a real-world application. Care should be taken when employing these techniques
    in your own application, and testing should be paramount.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经实现了双向数据绑定和全面视图同步，使用了原生的`getters`和`setters`以及`MutationObserver`构造函数。请记住，这里给出的示例是实验性的，尚未在实际应用中使用。在您的应用中采用这些技术时应谨慎行事，并且测试应该是首要的。
- en: Why use data binding?
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用数据绑定？
- en: Data binding provides a layer of abstraction that can eliminate the need for
    a lot of additional application wiring, custom event publishing and subscribing,
    and Model evaluation against the View. These things are usually handled with custom
    application code that is specific to the application itself, when a framework
    or some type of data binding is not being used. Without careful planning and the
    use of defined architectural patterns, this can lead to a lot of adjunct code,
    and subsequently a code base that is not extensible, does not scale well, and
    is difficult for new developers to take on and learn.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定提供了一层抽象，可以消除大量额外应用连接、自定义事件发布和订阅以及模型对视图的评估的需求。当不使用框架或某种类型的数据绑定时，这些通常由针对应用本身特定的自定义应用代码处理。如果没有仔细规划和使用定义的架构模式，这可能会导致大量辅助代码，进而导致代码库不可扩展、扩展性不好，并且对新开发者来说难以接受和学习。
- en: If you feel that data binding is a component you'd like to include in your application,
    then consider your options, some of which we have laid out here, and choose accordingly.
    You may see the need to build your application with a full-fledged JavaScript
    framework such as AngularJS, or you may only want the added abstraction layer
    of data binding in combination with your own custom architecture. Also, consider
    the performance implications of your choices, and whether you need two-way data
    binding, which is more memory-intensive, or only one-way data binding, which will
    help to keep your application more performant.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为数据绑定是你想要包含在应用中的组件，那么考虑你的选择，其中一些我们已经在这里列出，并据此选择。你可能需要使用像AngularJS这样的完整JavaScript框架来构建你的应用，或者你可能只想结合你自己的定制架构使用数据绑定的附加抽象层。同时，考虑你选择带来的性能影响，以及你是否需要双向数据绑定，它更占用内存，或者只需要单向数据绑定，这有助于保持你的应用性能更优。
- en: Use cases for one-way data binding
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单向数据绑定的用例
- en: The most common form of data binding in modern single page applications is one-way
    data binding. At its most basic, one-way data binding need only consist of binding
    dynamic Model values to their respective expressions in a template at render time.
    If the model changes after a template has already been rendered, the synchronization
    of that data to the View is an added benefit of some frameworks such as AngularJS,
    Ember.js, and Rivets.js.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代单页应用中最常见的绑定形式是单向数据绑定。在最基本的情况下，单向数据绑定只需要在渲染时将动态模型值绑定到模板中相应的表达式。如果模型在模板已经渲染后发生变化，将数据同步到视图是某些框架（如AngularJS、Ember.js和Rivets.js）的附加好处。
- en: If you are building an application in which you want to display real-time, frequently
    changing data to a user, and that data does not need to be manipulated by the
    user, this is a good use case for one-way data binding with View synchronization.
    A more specific example of this is an application for tracking stock quotes and
    displaying the prices as they change in real time. The Model data in this case
    is meant entirely for viewing by the user, but no changes to the Model from the
    View are necessary since the stock quotes cannot be changed by the user. In a
    scenario like this, two-way data binding listeners would not be useful and would
    only generate additional and unnecessary overhead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个需要向用户显示实时、频繁变化的数据的应用，并且这些数据不需要被用户操作，这是一个使用带有视图同步的单向数据绑定的好例子。一个更具体的例子是跟踪股票报价并实时显示价格变化的应用。在这种情况下，模型数据完全是供用户查看的，但由于股票报价不能被用户更改，因此从视图到模型不需要任何更改。在这种情况下，双向数据绑定监听器将没有用，只会产生额外的和不必要的工作量。
- en: Use cases for two-way data binding
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向数据绑定的用例
- en: Two-way data binding is not as commonly used as one-way data binding in single
    page applications, but it does have its place. It is important to fully understand
    the needs of your application before you decide to attach two-way data binding
    behaviors to the DOM and use additional memory.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页应用中，双向数据绑定不像单向数据绑定那样常用，但它确实有其位置。在决定将双向数据绑定行为附加到DOM并使用额外内存之前，完全理解你应用的需求是很重要的。
- en: A live chat, or live messaging, application is one of the most common examples
    of two-way data binding. Whether the application provides one-to-one messaging
    or multiuser messaging, two-way data binding can be used to synchronize the View
    in both directions for each user. As a user is viewing the application, new messages
    from other users are added to the Model and displayed in the View. Likewise, the
    user viewing the application enters new messages in the View and they are added
    to the Model, downloaded to the server, and then displayed to the other users
    in their own Views.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在线聊天或实时消息应用是双向数据绑定最常见的例子之一。无论应用提供的是一对一消息还是多用户消息，双向数据绑定都可以用于同步每个用户的视图，实现双向同步。当用户查看应用时，其他用户的新消息会被添加到模型中，并在视图中显示。同样，查看应用的用户在视图中输入新消息，这些消息会被添加到模型中，下载到服务器，然后显示给其他用户在自己的视图中。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You have now learned what data binding is, the differences between one-way and
    two-way data binding, how data binding is implemented in some modern JavaScript
    frameworks and libraries, and what some use cases for data binding are in the
    real world. You have also learned about the architectural differences between
    one-way and two-way data binding implementations, and how to write your own data
    binding implementation using modern native JavaScript with getters and setters.
    Additionally, you have learned about the `MutationObserver` constructor and how
    it can be used to trigger behaviors in the DOM based on mutation events.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了什么是数据绑定，单向数据绑定和双向数据绑定的区别，数据绑定在现代 JavaScript 框架和库中的实现方式，以及数据绑定在现实世界中的某些用例。你还了解了单向和双向数据绑定实现之间的架构差异，以及如何使用现代原生
    JavaScript 中的获取器和设置器来编写自己的数据绑定实现。此外，你还学习了 `MutationObserver` 构造函数及其如何根据突变事件在 DOM
    中触发行为。
- en: Next, we will take everything that we have learned so far about different architectural
    components, including MongoDB, Express, AngularJS, and Node.js, and learn how
    to begin putting them all together to leverage the full MEAN stack.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把迄今为止关于不同架构组件所学的所有知识，包括 MongoDB、Express、AngularJS 和 Node.js，结合起来学习如何开始将它们全部整合起来，以充分利用
    MEAN 全栈。
