- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Replacing Behavior with a Side-By-Side Implementation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用并行实现替换行为
- en: In the previous two chapters you built out a fully formed repository and an
    API for accessing it. Now it’s time to complete the story arc by updating both
    the SvelteKit loader and form actions to use the API instead of the repository.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个章节中，您构建了一个完整的仓库和访问它的API。现在，是时候通过更新SvelteKit加载器和表单操作来使用API而不是仓库来完成故事弧了。
- en: 'It’s worth pointing out that this isn’t a necessary step: it would be perfectly
    acceptable to keep the SvelteKit server pieces pointing directly at the repository.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，这不是一个必要的步骤：保持SvelteKit服务器组件直接指向仓库是完全可接受的。
- en: 'But reworking our existing code to point at the new API endpoints will introduce
    you to two ideas: first, that of a **side-by-side implementation**, which is a
    way to use tests to replace the existing code while ensuring the test suite remains
    on *Green*. The second is the use of a test double to shield the unit tests from
    SvelteKit. The test double takes the place of the framework code, avoiding a real
    network call out to the API – which wouldn’t work anyway since the API isn’t running
    within our Vitest test suite.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但将现有代码重写以指向新的API端点将向您介绍两个想法：首先，是**并行实现**的概念，这是一种使用测试来替换现有代码的同时确保测试套件保持**绿色**的方法。第二个是使用测试替身来保护单元测试不受SvelteKit的影响。测试替身取代了框架代码的位置，避免了向API发起真正的网络调用——这本来就不可能工作，因为API没有在我们的Vitest测试套件中运行。
- en: '*Figure 11**.1* shows two views of our code base. The left side shows how the
    new architecture of our application code will look, with the SvelteKit route loaders
    and form actions pointing to the API endpoints. The right side shows how the unit
    tests for the router loaders and form actions will see the world. In this setup,
    the API endpoints are not accessed at all.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.1*显示了我们的代码库的两个视图。左侧显示了我们的应用程序代码的新架构将如何看起来，其中SvelteKit路由加载器和表单操作指向API端点。右侧显示了路由加载器和表单操作的单元测试将如何看待世界。在这个设置中，根本不会访问API端点。'
- en: '![Figure 11.1 – Using a test double to plug SvelteKit behavior within unit
    test suites](img/Figure_11.1_B19611.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 使用测试替身将SvelteKit行为插入单元测试套件](img/Figure_11.1_B19611.jpg)'
- en: Figure 11.1 – Using a test double to plug SvelteKit behavior within unit test
    suites
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 使用测试替身将SvelteKit行为插入单元测试套件
- en: After updating our SvelteKit components, we’ll wrap things up by updating the
    Playwright test to use the new API and stop the database seed data from appearing
    in test environments (both Playwright and Vitest).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新我们的SvelteKit组件后，我们将通过更新Playwright测试以使用新的API并停止在测试环境中（Playwright和Vitest）显示数据库种子数据来结束整个工作。
- en: 'This chapter covers the following key topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下关键主题：
- en: Updating the route loader to use the API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新路由加载器以使用API
- en: Updating the page form action to use the API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新页面表单操作以使用API
- en: Using a server hook to seed sample data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器钩子来生成样本数据
- en: By the end of the chapter, you’ll have seen how to use a **spy** (a form of
    test double) and the process of building a side-by-side implementation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将看到如何使用**间谍**（一种测试替身的形式）以及构建并行实现的过程。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter11/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter11/Start).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在网上找到，地址为[https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter11/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter11/Start)。
- en: Updating the route loader to use the API
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新路由加载器以使用API
- en: In this section, you’ll introduce a call to the `GET` `/api/birthdays` endpoint
    using the SvelteKit fetch function. That will involve using a spy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用SvelteKit的fetch函数引入对`GET` `/api/birthdays`端点的调用。这将涉及使用间谍。
- en: What is a test spy?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是测试间谍？
- en: A spy is a function that keeps a record of each time it is called, together
    with the arguments it is called with. It can then be inspected later to verify
    that it was called with the correct arguments. The spy is almost always a *stub*
    as well, meaning it avoids calling the real function entirely, instead returning
    a hardcoded – stubbed – value. The spy acts as a substitute for a real function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是一个记录每次被调用以及调用时传递的参数的函数。然后可以在之后检查以验证它是否以正确的参数被调用。间谍几乎总是也是一个*存根*，这意味着它完全避免了调用真实函数，而是返回一个硬编码的——存根——值。间谍充当真实函数的替代品。
- en: In Vitest, a spy is created by calling the `vi.fn` function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vitest中，通过调用`vi.fn`函数来创建间谍。
- en: When we use a test spy, you’ll have at least one test that checks the arguments
    passed to the spy. Then you’ll have at least one more test for each stubbed return
    value that the spy returns.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用测试间谍时，你至少会有一个测试来检查传递给间谍的参数。然后你至少会有一个针对间谍返回的每个存根返回值的额外测试。
- en: We will use a spy for the `fetch` function that mimics retrieving birthdays
    via the `GET` `/``api/birthdays` endpoint.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个间谍来模拟通过`GET` `/api/birthdays`端点检索生日。
- en: Understanding the SvelteKit fetch function
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 理解SvelteKit的fetch函数
- en: 'SvelteKit provides a `fetch` parameter to the user-defined `load` function
    and to the form actions. The value of this parameter is a function that has the
    same semantics as the standard Fetch API provided by browsers. The difference
    is in mechanics: SvelteKit’s `fetch` function is able to short-cut calls made
    on the server so that they don’t cause an HTTP request but instead feed directly
    into the `GET` function that matches the route specified.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SvelteKit为用户定义的`load`函数和表单操作提供了一个`fetch`参数。此参数的值是一个具有与浏览器提供的标准Fetch API相同语义的函数。区别在于机制：SvelteKit的`fetch`函数能够绕过对服务器的调用，以便它们不会引起HTTP请求，而是直接输入与指定路由匹配的`GET`函数。
- en: 'Let’s begin with a new factory method definition:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个新的工厂方法定义开始：
- en: 'Create a new file named `src/factories/fetch.js` and add the following definition.
    We will use this to build stub `Response` objects that the test spy will return:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/factories/fetch.js`的新文件，并添加以下定义。我们将使用它来构建测试间谍将返回的存根`Response`对象：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now open the test file at `src/routes/birthdays/page.server.test.js` and add
    an `import` statement to that function:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`src/routes/birthdays/page.server.test.js`中的测试文件，并添加一个`import`语句到该函数：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, update the Vitest `import` statement to include an import for `vi`, like
    this:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新Vitest的`import`语句以包含对`vi`的导入，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following test at the bottom of the `describe` block with the title
    `/birthdays - load`. In addition to creating a test spy with a call to `vi.fn()`,
    this also uses the `mockResolvedValue` function to specify that the spy should
    return a value wrapped in a `Promise` object. The test concludes with the `toBeCalledWith`
    matcher to verify that the spy is called in the right way:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`describe`块底部添加以下测试。除了通过调用`vi.fn()`创建测试间谍外，它还使用`mockResolvedValue`函数指定间谍应返回一个包装在`Promise`对象中的值。测试以`toBeCalledWith`匹配器结束，以验证间谍以正确的方式被调用：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make that pass, we’ll start with a side-by-side implementation. That means
    the previous implementation remains in place alongside the new implementation.
    In the `src/routes/birthdays/+page.server.js` file, modify the `load` function
    so that it takes a `fetch` argument and then invokes it as the first thing it
    does, like this:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，我们将从并行实现开始。这意味着之前的实现仍然与新的实现并存。在`src/routes/birthdays/+page.server.js`文件中，修改`load`函数，使其接受一个`fetch`参数，并将其作为第一件事调用，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will cause the original test case to fail due to a missing value for `fetch`.
    We are about to delete this test, but for now, let’s humor ourselves by fixing
    the test.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致原始测试用例因缺少`fetch`的值而失败。我们即将删除此测试，但暂时让我们通过修复测试来自我娱乐。
- en: 'Update the test case to use a very simple stub value for `fetch`, as shown
    in the following code. This highlights the fact that a Vitest spy created by `vi.fn`
    is not always necessary. If you’re not checking the spy, then a plain stub is
    enough:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新测试用例以使用一个非常简单的存根值`fetch`，如下所示。这突出了这样一个事实：由`vi.fn`创建的Vitest间谍并不总是必要的。如果你没有检查间谍，那么一个普通的存根就足够了：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Continue by writing the second test, which checks that the `load` function
    returns whatever data came back from `fetch`. This time, we need to pass an actual
    value to `fetchResponseOk`, and compare that to the `return` value:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续编写第二个测试，该测试检查`load`函数返回从`fetch`返回的任何数据。这次，我们需要向`fetchResponseOk`传递一个实际值，并将其与`return`值进行比较：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Go ahead and update the `load` function to return this value:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后更新`load`函数以返回此值：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You might have noticed this is in direct conflict with the original test we
    wrote. When we build a side-by-side implementation, the final step is often switching
    out the return value. When that happens, it’s time to delete the original test.
    So, go ahead and delete the original test – the only one titled *returns a fixture
    of two items* – since it no longer applies.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经注意到这与我们最初编写的测试直接冲突。当我们构建并排实现时，最后一步通常是替换返回值。当发生这种情况时，就是删除原始测试的时候了。所以，请删除原始测试——唯一一个标题为
    *返回两个项目的固定装置* 的测试——因为它不再适用。
- en: 'Finally, remove the `getAll` import from the `+``page.server.js` file:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从 `+``page.server.js` 文件中删除 `getAll` 导入：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You’ve now seen how to use `vi.fn` to create a test spy for testing `fetch`
    calls and a basic side-by-side implementation. The next section repeats the same
    process for the page form action, but this time the implementation is more complex.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了如何使用 `vi.fn` 创建一个用于测试 `fetch` 调用的测试间谍和一个基本的并排实现。下一节将重复相同的流程来测试页面表单操作，但这次实现更复杂。
- en: Updating the page form action to use the API
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新页面表单操作以使用 API
- en: In the section, we will update the page form action to use the new `POST` and
    `PUT` methods on the API endpoints instead of the `addNew` and `replace` functions
    of the repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新页面表单操作，使用 API 上的新 `POST` 和 `PUT` 方法，而不是存储库的 `addNew` 和 `replace` 函数。
- en: This will be done using the same side-by-side technique of the previous section,
    but this time it’s more involved. We still need tests to verify that the spy is
    called with the right parameters and that the return value is given. But now we
    also need to verify that errors are converted to SvelteKit form failures, since
    the form action has separate handling for errors.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用与上一节相同的并排技术来完成，但这次更复杂。我们仍然需要测试来验证间谍是否以正确的参数被调用，并且返回值被给出。但现在我们还需要验证错误是否被转换为
    SvelteKit 表单失败，因为表单操作对错误有单独的处理。
- en: Another important change here is that we will use two tests for checking the
    parameters passed to the `fetch` call. This is a powerful technique when faced
    with complex arguments where there are *clumps* of arguments that have separate
    meanings.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里另一个重要的变化是，我们将使用两个测试来检查传递给 `fetch` 调用的参数。当面对有 *团块* 参数具有不同意义的复杂参数时，这是一种强大的技术。
- en: 'In the case of fetch, the URL and the HTTP verb are one *clump*: we can have
    a single test that verifies, for example, that we’re calling the `POST` `/api/birthdays`
    endpoint. But there’s also the `body` property, and since that isn’t static data
    – it changes depending on the form action input parameters – it seems sensible
    to give that a test of its own.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `fetch` 的情况下，URL 和 HTTP 动词是一个 *团块*：我们可以有一个单独的测试来验证，例如，我们是否调用了 `POST` `/api/birthdays`
    端点。但还有 `body` 属性，由于这不是静态数据——它根据表单操作输入参数而变化——因此为它提供一个单独的测试似乎是合理的。
- en: Finally, since the API endpoints are performing data validation, we no longer
    need that functionality. So we’ll finish by deleting that implementation and its
    related tests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 API 端点正在执行数据验证，我们不再需要该功能。因此，我们将通过删除该实现及其相关测试来完成。
- en: 'Let’s get started by updating the existing `describe` block with some new setup:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始更新现有的 `describe` 块，添加一些新的设置：
- en: 'Find the `describe` block named `/birthdays - default action` and add the following
    three pieces of setup: a `fetch` variable that can be accessed in all tests; a
    new `beforeEach` block to set up the `fetch` response; and an updated `performFormAction`
    method that passes in the `fetch` argument:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到名为 `/birthdays - default action` 的 `describe` 块，并添加以下三件设置：一个可以在所有测试中访问的 `fetch`
    变量；一个新的 `beforeEach` 块来设置 `fetch` 响应；以及一个更新的 `performFormAction` 方法，该方法传递 `fetch`
    参数：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, add this new nested `describe` block with its single test below all the
    existing tests. It checks that the `fetch` spy has been called with the correct
    URL and `method` of `POST`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加这个新的嵌套 `describe` 块及其单个测试，位于所有现有测试的下方。它检查 `fetch` 间谍是否以正确的 URL 和 `POST`
    的 `method` 被调用：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To make that pass, start by adding the `fetch` argument into the form action:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使其通过，首先将 `fetch` 参数添加到表单操作中：
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, make a start on the side-by-side implementation. Find the call to `addNew`,
    and just below it, add a new call to `fetch`, as shown here:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，开始进行并排实现。找到对 `addNew` 的调用，并在其下方添加一个新的 `fetch` 调用，如下所示：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For the next test, we have a very similar test which is still testing the arguments
    to the `fetch` spy, but this time checking the varying portion of it: the `body`
    property. Add that test now:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们有一个非常相似的测试，它仍然在测试 `fetch` 间谍的参数，但这次检查的是它的可变部分：`body` 属性。现在添加这个测试：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code sample makes use of a helper function called `expect.anything`,
    which you also saw in [*Chapter 10*](B19611_10.xhtml#_idTextAnchor119), *Test-Driving
    API Endpoints*. Since we already have a previous test that checks the value of
    the first argument, we can avoid repeating ourselves by checking it here and simultaneously
    relax the expectation so that the tests are kept independent of each other.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例使用了名为 `expect.anything` 的辅助函数，您在 [*第 10 章*](B19611_10.xhtml#_idTextAnchor119)，*测试驱动
    API 端点* 中也看到了它。由于我们已经有了一个检查第一个参数值的先前测试，我们可以通过在这里进行检查来避免重复，同时放松期望，使测试彼此独立。
- en: 'Using this helper also aids with the readability of the test by focusing the
    reader’s attention on what’s specifically of interest: the second argument, not
    the first.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此辅助工具还有助于提高测试的可读性，因为它将读者的注意力集中在具体感兴趣的部分：第二个参数，而不是第一个。
- en: 'To make that pass, update the `fetch` call from *step 4* to include the `body`
    property:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使它通过，将 `fetch` 调用从 *步骤 4* 更新为包括 `body` 属性：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let’s handle the error case. For this, we need a new factory for an error
    response. In `src/factories/fetch.js`, add the following definition for `fetchResponseError`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们处理错误情况。为此，我们需要一个用于错误响应的新工厂。在 `src/factories/fetch.js` 中，添加以下 `fetchResponseError`
    的定义：
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then import it into your test suite:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将它导入到您的测试套件中：
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We’re ready for the next test. This test checks what happens when an error
    occurs. Since our spy has no real logic, we don’t care about the *specifics* of
    the error. We just need it to trigger the same behavior as the real code. That
    means having a non-`ok` status message, just like the `fetchResponseError` factory
    gives us. To make it clear that it’s not real logic, I’ve used an `error message`
    string as opposed to a real error message:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好进行下一个测试。这个测试检查当发生错误时会发生什么。由于我们的间谍没有真正的逻辑，我们不在乎错误的 *具体细节*。我们只需要它触发与真实代码相同的操作。这意味着有一个非
    `ok` 状态消息，就像 `fetchResponseError` 工厂给我们的一样。为了清楚地表明这不是真实逻辑，我使用了一个 `error message`
    字符串而不是真正的错误消息：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To make this pass, start by saving the response from the `fetch` call in the
    form action:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个通过，首先将 `fetch` 调用的响应保存到表单操作中：
- en: '[PRE18]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, add the following return clause *after* the existing error clause for
    the original `result` value. This is a trick of the side-by-side implementation.
    It ensures that the original implementation won’t fail on us:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在原始 `result` 值的现有错误子句之后添加以下返回子句。这是并行实现的一个技巧。这确保了原始实现不会在我们这里失败：
- en: '[PRE19]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All right, let’s do the same for the `replace` call. Add the following new
    nested `describe` block with a single test:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，让我们对 `replace` 调用也做同样的事情。添加以下新的嵌套 `describe` 块，包含一个测试：
- en: '[PRE20]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the application code, find the call to `replace`, and just below it, add
    a new call to `fetch`. After this, the test should pass:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序代码中，找到对 `replace` 的调用，并在其下方添加一个新的 `fetch` 调用。之后，测试应该通过：
- en: '[PRE21]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we’ll test the body of the `PUT` request. Because we’re not actually
    calling into the repository, it no longer matters whether the item exists or not.
    It’s all down to the test double setup:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将测试 `PUT` 请求的主体。因为我们实际上并没有调用到存储库，所以不再重要该项是否存在。一切都取决于测试双工设置：
- en: '[PRE22]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To make that pass, add the `body` property to the `fetch` call:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使它通过，将 `body` 属性添加到 `fetch` 调用中：
- en: '[PRE23]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the final test, repeat the same process used for the `POST` request. We
    use `mockResolvedValue` combined with the `fetchResponseError` factory to make
    the spy trigger our error flow:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后的测试，重复用于 `POST` 请求的相同过程。我们使用 `mockResolvedValue` 与 `fetchResponseError`
    工厂结合使用，以使间谍触发我们的错误流程：
- en: '[PRE24]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make that pass, simply save the result in the `response` variable. The code
    will then rely on the same return clause from *step 11*:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使它通过，只需将结果保存在 `response` 变量中。然后代码将依赖于与 *步骤 11* 相同的返回子句：
- en: '[PRE25]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now comes the satisfying bit. You can go ahead and delete the original implementation,
    first by deleting the tests, then by deleting the code itself. Delete all these
    tests:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是令人满意的部分。您可以继续删除原始实现，首先删除测试，然后删除代码本身。删除所有这些测试：
- en: '`adds a new birthday into` `the list`'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`将新的生日添加到列表中`'
- en: '`saves unique ids onto each` `new birthday`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`将唯一的 ids 保存到每个新的生日`'
- en: '`updates an entry that shares the` `same id`'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`更新具有相同 id 的条目`'
- en: '`when the name is` `not provided...`'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`当名称未提供时...`'
- en: '`when the date of birth in the` `wrong format...`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`当出生日期格式错误时...`'
- en: '`when the id` `is unknown...`'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`当id未知时...`'
- en: '`returns the id when an empty name` `is provided`'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`当提供空名称时返回id`'
- en: '`returns the id when an empty date of birth` `is provided`'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`当提供空出生日期时返回id`'
- en: Using the online code repository
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在线代码仓库
- en: This is a lot of code change. You can use the online repository to cross-check
    your changes as you go along.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一大堆代码更改。你可以使用在线仓库在过程中交叉检查你的更改。
- en: You can delete the import for `birthayRepository`, since you’re no longer using
    that, and the `storedId` method too. If you run your tests now, you should find
    they still pass.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以删除对`birthayRepository`的导入，因为你不再使用它，以及`storedId`方法。如果你现在运行测试，你应该会发现它们仍然通过。
- en: 'Go ahead and delete all the bits from the implementation that reference the
    birthday repository:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在就去删除实现中所有引用生日仓库的部分：
- en: The calls to `addNew` and `replace`
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`addNew`和`replace`的调用
- en: The `result` variable and the error handling
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result`变量和错误处理'
- en: The `import` statement for the `replace` function (although the `addNew` function
    is still needed; we’ll remove it in the next section)
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`函数的`import`语句（尽管`addNew`函数仍然需要；我们将在下一节中删除它）'
- en: That completes the new version of the page form actions. But before finishing,
    we need to do something about our seed data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了页面表单操作的新版本。但在完成之前，我们需要处理我们的种子数据。
- en: Using a server hook to seed sample data
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器钩子来生成样本数据
- en: In the early chapters of the book, we added seed data into the `/birthdays`
    route in the `src/routes/birthdays/+page.server.js` file. At the top, there are
    two calls to `addNew` to create two fake birthdays. We relied on this data within
    our Playwright tests. It’s now time to clean up.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们在`src/routes/birthdays/+page.server.js`文件中的`/birthdays`路由中添加了种子数据。在顶部，有两个对`addNew`的调用以创建两个虚假的生日。我们在Playwright测试中依赖这些数据。现在是时候清理了。
- en: Creating repeated data in the development environment
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中创建重复数据
- en: If you’ve been running the dev server while you edited files, you will have
    noticed that as SvelteKit reloaded your files, the fake birthdays were repeatedly
    created, resulting in many birthday objects in the system. This was because of
    those `addNew` calls at the top of the route’s `+page.server.js` file. Another
    problem caused by our seed data will now be fixed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编辑文件时一直在运行开发服务器，你将注意到，随着SvelteKit重新加载你的文件，虚假的生日被反复创建，导致系统中出现了许多生日对象。这是因为路由的`+page.server.js`文件顶部的那些`addNew`调用。现在我们将修复由我们的种子数据引起的另一个问题。
- en: First, we’ll update the Playwright tests to create all their test data via the
    API. Then we’ll remove the hardcoded seed data from our system. Finally, we will
    bring the seed data back when loading the development environment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更新Playwright测试，通过API创建所有测试数据。然后我们将从我们的系统中删除硬编码的种子数据。最后，当加载开发环境时，我们将重新引入种子数据。
- en: That means the seed data is available using the `npm run dev` command but won’t
    be there when running the automated tests or when launching in production mode.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着种子数据可以通过`npm run dev`命令使用，但在运行自动化测试或以生产模式启动时将不可用。
- en: 'Let’s start with the Playwright tests:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Playwright测试开始：
- en: 'Add the following to the top of `tests/birthdays.test.js`, which is a new function
    to make a `POST /api/birthdays` request to insert a birthday into the repository:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`tests/birthdays.test.js`的顶部，这是一个新函数，用于向仓库发送`POST /api/birthdays`请求以插入生日：
- en: '[PRE26]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, update the `list all birthdays` test so that it begins with two calls
    to `addBirthday`, like this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新`列出所有生日`测试，使其以两个对`addBirthday`的调用开始，如下所示：
- en: '[PRE27]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, update the `edits a birthday` test in the same way:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，以相同的方式更新`编辑生日`测试：
- en: '[PRE28]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before running the Playwright tests, we need to remove the seed data. In `src/routes/birthdays/+page.server.js`,
    delete the two calls to `addNew` and the `addNew` import statement.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行Playwright测试之前，我们需要删除种子数据。在`src/routes/birthdays/+page.server.js`中，删除对`addNew`的两个调用和`addNew`导入语句。
- en: Run the Playwright tests and verify they’ve passed.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Playwright测试并验证它们是否通过。
- en: 'All that’s left is to add a server hook for that data so that when you run
    the server in dev mode, you get some data. Create a new file named `src/hooks.server.js`
    with the following content. SvelteKit will automatically load this file when the
    web server is launched:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的就是添加一个服务器钩子来处理这些数据，这样当你在开发模式下运行服务器时，你就能得到一些数据。创建一个名为`src/hooks.server.js`的新文件，内容如下。SvelteKit将在启动网络服务器时自动加载此文件：
- en: '[PRE29]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That completes the removal of the hardcoded seed data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了对硬编码种子数据的移除。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the concept of a test double that can be used
    to block out unwanted framework behavior. In our case, that was the `fetch` call
    that, at runtime, will be magically hooked up to the API endpoints. But since
    we don’t have access to the SvelteKit runtime environment within a Vitest unit
    test, we stubbed it out.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了测试替身（test double）的概念，它可以用来屏蔽不想要的框架行为。在我们的例子中，那就是在运行时会被神奇地连接到API端点的`fetch`调用。但由于我们在Vitest单元测试中无法访问SvelteKit运行时环境，所以我们对其进行了存根化处理。
- en: You also learned how a side-by-side implementation is used to keep your test
    suites on *Green* while you systematically replace the internals of a function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了如何使用并排实现来保持您的测试套件处于*绿色*状态，同时您有系统地替换函数的内部结构。
- en: The next chapter continues the theme of test doubles with a detailed look at
    component mocks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续探讨测试替身主题，详细介绍了组件模拟。
