- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: As human beings, we all go through various stages of development. With each
    stage we reach, even if it seems like the best at the time, we later realize we
    still have a long way to go. Each period has its problems, and depending on their
    size and nature, they require different solutions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类，我们都会经历各种发展阶段。随着我们达到每个阶段，即使当时看起来是最好的，我们后来会意识到我们还有很长的路要走。每个时期都有其问题，根据其大小和性质，它们需要不同的解决方案。
- en: We humans tend to simplify things. That is why we build our lives around problems
    and their corresponding solutions. Finding solutions to problems has been our
    main goal throughout history, perhaps due to our instinct to survive.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类倾向于简化事物。这就是为什么我们围绕问题和相应的解决方案来构建我们的生活。寻找问题的解决方案一直是我们的主要目标，这也许是因为我们生存的本能。
- en: If we consider each piece of software as an individual, they also have problems
    to solve. Depending on the size and shape of the problems, software has a different
    structure, which we call **architecture**. The size and nature of the problems
    directly affect the architecture of the software. One of these architectural approaches
    we use is called microservices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将每块软件视为一个个体，它们也有需要解决的问题。根据问题的规模和形状，软件具有不同的结构，我们称之为**架构**。问题的规模和性质直接影响软件的架构。我们使用的这些架构方法之一就是微服务。
- en: '**Microservices** are important when it comes to building scalable distributed
    applications that respond to modern-day concerns. It is also a de facto requirement
    for most huge companies when they interview you as a developer. The vast majority
    of technologies we use nowadays try to support microservice development out of
    the box. So, being a software engineer without microservice knowledge doesn’t
    make you an ideal candidate in the modern IT world.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**在构建可扩展的分布式应用程序、响应现代问题方面非常重要。当作为开发者被大多数大型公司面试时，这也是一个事实上的要求。我们今天使用的绝大多数技术都试图默认支持微服务开发。因此，在现代IT世界中，没有微服务知识的软件工程师并不理想。'
- en: Starting from this chapter, we’re going to dive into the world of microservices.
    We will build strong theoretical knowledge before moving on to practical sections.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将深入微服务的世界。在进入实践部分之前，我们将构建坚实的理论知识。
- en: First, we will go back and try to understand what type of popular approaches
    were there before microservices. Microservices are important, but understanding
    the need to apply them is foremost.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将回顾并尝试理解在微服务之前有哪些流行的方法。微服务很重要，但理解应用它们的必要性更为重要。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing microservices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍微服务
- en: Exploring the monolith approach
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索单体方法
- en: What is service-oriented architecture?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是面向服务的架构？
- en: The differences between SOA and microservices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOA与微服务之间的区别
- en: Advantages of microservices
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的优势
- en: Disadvantages of microservices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的缺点
- en: Introducing microservices
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍微服务
- en: A microservice architecture decomposes an application into loosely coupled,
    independently deployable services that own their data and communicate through
    lightweight protocols. It breaks down large applications into smaller, self-contained
    business capabilities, enabling faster development, easier scaling, and better
    fault tolerance. Microservices enable continuous delivery and agile development
    by allowing teams to independently build, test, and deploy features. You can imagine
    an application as an orchestra, where each microservice is a musician playing
    their part, but in perfect harmony with the others, to create a beautiful symphony.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构将应用程序分解为松散耦合、独立部署的服务，这些服务拥有自己的数据并通过轻量级协议进行通信。它将大型应用程序分解为更小、自包含的业务能力，从而实现更快的开发、更容易的扩展和更好的容错性。微服务通过允许团队独立构建、测试和部署功能，实现了持续交付和敏捷开发。你可以想象一个应用程序就像一个乐团，其中每个微服务都是一位演奏自己部分的乐手，但与其他人完美和谐，共同创作出美妙的交响乐。
- en: What we’ve just mentioned sounds like a *silver bullet* but as you know, nothing
    is free and there is no one-size-fits-all solution to the problems we face. The
    same applies to microservices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才提到的是一种*银弹*，但正如你所知，没有什么是免费的，也没有一种适合所有问题的解决方案。微服务也是如此。
- en: We, as software developers, love to learn new trends and try to apply them to
    our practice. But after delving into the details, we understand that every trend
    is just an encapsulation of old knowledge. Before applying any architecture to
    software, it is always better to engage in careful planning, discussion, collaboration,
    and analysis.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为软件开发者，喜欢学习新的趋势并尝试将它们应用到实践中。但当我们深入了解细节后，我们理解每个趋势只是旧知识的封装。在将任何架构应用到软件之前，进行仔细的计划、讨论、协作和分析总是更好的。
- en: Moving toward microservices
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向微服务迈进
- en: Creating software is more than just learning a programming language and applying
    syntactical elements of it to code, to build things. It’s like wielding a hammer
    and nails; having them in your arsenal doesn’t make you a skilled builder. Similarly,
    having all the tools doesn’t make you a good software developer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建软件不仅仅是学习一门编程语言并将其语法元素应用到代码中，以构建事物。这就像拿着锤子和钉子；拥有它们并不意味着你是一个熟练的建造者。同样，拥有所有工具并不意味着你是一个优秀的软件开发者。
- en: As you embark on creating a basic `hello world` type application, it remains
    just that – *basic*. However, it is important to understand that such simple applications
    don’t warrant payment. If you want your application to have value, it must address
    tangible real-world challenges – in short, it should hold business value. Adding
    more business value also brings complexity. In most cases, more business means
    more complexity. After some time, you’ll realize that instead of dealing with
    a business, you’re starting to deal with the complexity that your business brought
    to your application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始创建一个基本的 `hello world` 类型应用程序时，它仍然只是那样——*基本的*。然而，重要的是要理解，这样的简单应用程序并不值得付费。如果你想让你的应用程序具有价值，它必须解决有形的现实世界挑战——简而言之，它应该具有商业价值。增加更多的商业价值也会带来复杂性。在大多数情况下，更多的商业意味着更多的复杂性。过了一段时间，你会发现，你开始处理的不再是业务，而是你的业务带给应用程序的复杂性。
- en: In navigating complexity, we aim to break it down into smaller, maintainable,
    extensible, and reusable components. Only by doing so can we effectively handle
    the complexity and future changes. In programming, the only true constant is the
    need to embrace changes, a principle that remains as-is, not just during the process
    of creating the application, but until the end.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航复杂性时，我们的目标是将其分解成更小、可维护、可扩展和可重用的组件。只有这样做，我们才能有效地处理复杂性和未来的变化。在编程中，唯一真正的常数是需要拥抱变化，这一原则不仅在创建应用程序的过程中保持不变，而且在整个过程中都保持不变。
- en: This constant change forces us to not only master the selected programming language
    but also to have an understanding of the business domain. Naturally, this leads
    to us adopting a design-oriented mindset. Without having good knowledge of business,
    it is almost impossible to develop valuable software.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不断的变化迫使我们必须不仅掌握选定的编程语言，还要了解业务领域。自然地，这导致我们采取以设计为导向的思维模式。如果没有对业务的良好了解，几乎不可能开发出有价值的软件。
- en: Although the simple applications we write to learn a language may seem useless,
    when we connect the dots, we get closer to the truth. Isn’t our whole life spent
    in search of truth? Soon, you’ll realize that the software that meets the customer’s
    business requirements is the software that matters, and that reflects the truth.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们为了学习一门语言而编写的简单应用程序可能看似无用，但当我们连接这些点时，我们就更接近真理。难道我们的一生不都是在寻找真理吗？很快，你就会意识到满足客户业务需求的软件才是重要的软件，它反映了真理。
- en: 'If you start your development process without carefully analyzing and designing,
    you’re going to pay a higher price throughout the development itself. The earlier
    you start with design and analysis, the less likely you are to run into a bigger
    problem at a later stage. We call our first not properly analyzed and designed
    application **a big ball of mud** that uses *spaghetti-driven development*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始开发过程而没有仔细分析和设计，你将在整个开发过程中付出更高的代价。你越早开始设计和分析，你遇到更大问题的可能性就越小。我们称我们的第一个没有经过适当分析和设计的应用程序为**一团糟**，它使用*意大利面驱动的开发*：
- en: In software design, the phrase *a big ball of mud* is used to draw attention
    to an **anti-pattern** or a design approach that produces undesirable results.
    Let’s understand this phrase in more depth.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计中，短语“一团糟”用来引起人们对**反模式**或产生不良结果的**设计方法**的关注。让我们更深入地理解这个短语。
- en: Understanding a big ball of mud
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解一团糟
- en: The main issue with a big ball of mud is the lack of structure and organization.
    The absence of modularity and distinct issue separation in the code base leads
    to a complex network of interconnected files and functions. Imagine a house that
    is just a disorganized jumble of rooms and materials with no walls or other distinguishing
    features. Because everything in it is connected, changes that are made in one
    part could have a disastrous effect on other parts. It’s like pulling on a loose
    thread in a badly tailored sweater – you run the risk of the entire garment coming
    apart. Similarly code fragments are dispersed throughout the code base, which
    causes inefficiencies when performing maintenance.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大泥球（big ball of mud）的主要问题在于缺乏结构和组织。代码库中缺乏模块化和明确的问题分离，导致了一个复杂的相互连接的文件和函数网络。想象一下一栋房子，它只是一堆没有墙壁或其他区分特征的杂乱无章的房间和材料。因为里面的一切都是相互连接的，对某一部分的改动可能会对其他部分产生灾难性的影响。这就像在一件糟糕定制的毛衣上拉扯一根松散的线——你冒着整件衣服都散架的风险。同样，代码片段散布在整个代码库中，这在进行维护时会导致低效。
- en: Due to the absence of structure and documentation, maintaining the code base
    and adding new features is challenging for developers. Imagine attempting to navigate
    a house devoid of layout or labels; it’s nearly impossible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏结构和文档，维护代码库和添加新功能对开发者来说具有挑战性。想象一下试图在一个没有布局或标签的房子中导航；这几乎是不可行的。
- en: Because of their close coupling, changes in one area can unintentionally disturb
    seemingly unrelated components. Because of its fragility, the software is prone
    to mistakes and regressions. Imagine a house built with weak, interconnected supports
    so that even a small outside force could result in serious harm.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们紧密耦合，某一区域的改动可能会无意中干扰看似无关的组件。由于其脆弱性，软件容易出错和回退。想象一下用薄弱、相互连接的支撑构建的房子，即使是微小的外部力量也可能造成严重损害。
- en: A big ball of mud may seem like the right choice at first in small, simple projects,
    but as the project grows and develops, its complexity quickly increases. To guarantee
    long-term maintainability, scalability, and developer satisfaction, this design
    approach must be avoided at all costs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 大泥球可能一开始看起来是小型简单项目中的正确选择，但随着项目的增长和发展，其复杂性会迅速增加。为了保证长期的可维护性、可扩展性和开发者满意度，这种设计方法必须不惜一切代价避免。
- en: Guess what? I already know that you’ve gone through this stage – the stage of
    applying and failing with a big ball of mud. These difficulties helped you learn
    more rather than learn from success.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？我已经知道你已经经历过这个阶段——使用大泥球尝试并失败的阶段。这些困难帮助你学到了更多，而不是从成功中学习。
- en: Every difficulty teaches us something, right? Until one year in my life, I was
    always grateful for the good things in my life. But over time, I realized that
    it was those difficulties that made me who I am. After I changed my way of thinking,
    I began to thank the difficulties in my life and those who made me suffer. If
    you could go back and remove the difficulties in your life, believe me, you would
    also remove your present self. Difficulties strengthen you and make you a strong
    person.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个困难都教会我们一些东西，对吧？直到我生命中的某一年，我总是对我的生活感到感激。但随着时间的推移，我意识到正是那些困难塑造了我。在我改变思维方式之后，我开始感谢生活中的困难和那些让我受苦的人。如果你能回到过去，移除生活中的困难，相信我，你也会移除你现在的自己。困难使你变得更强大，让你成为一个坚强的人。
- en: Mankind is a creature that rarely listens to advice. We have to get into trouble
    – we have to experiment with trouble. I know that the downsides I mentioned about
    a big ball of mud in this section only make sense to those who have gone through
    this difficulty. In the end, we all learn through experimenting.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 人类是一种很少听取建议的生物。我们必须陷入麻烦——我们必须尝试麻烦。我知道本节中提到的关于大泥球的缺点，只有经历过这种困难的人才能理解。最终，我们都是通过实验来学习的。
- en: As a novice software developer, it’s beneficial to experiment with a big ball
    of mud at some point. You’ll quickly discover that while it provides a swift start,
    its efficiency dwindles over time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件新手开发者，在某个时候尝试一下大泥球是有益的。你会很快发现，虽然它提供了一个快速的开始，但它的效率会随着时间的推移而下降。
- en: 'Let’s try to summarize the disadvantages of a big ball of mud:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试总结一下大泥球的缺点：
- en: '**Unplanned and chaotic**: The appearance of a big ball of mud is the result
    of poor design and coding techniques rather than a deliberate architectural decision.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未计划且混乱**：大泥球的出现是设计不佳和编码技术的结果，而不是一个故意的架构决策。'
- en: '**Tight coupling**: The code is tightly interconnected; changes that are made
    to one section run the risk of having unexpected effects in unrelated areas.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密耦合**：代码紧密相连；对某一部分的修改可能会在无关区域产生意外的效果。'
- en: '**Difficulty in understanding and maintaining**: The code base is messy and
    lacks documentation, making it hard for developers to grasp and modify.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解和维护困难**：代码库混乱且缺乏文档，使得开发者难以理解和修改。'
- en: '**Error-prone and fragile**: The code base leads to unpredictable errors and
    regressions with modifications. In a big ball of mud system, everything is tightly
    connected like a big mess of wires. This makes it hard to know what happens when
    you change one part, like trying to fix one loose wire in a tangled mess. This
    can easily lead to unexpected problems and things breaking, like causing a short
    circuit in the tangled wires, making it harder to develop and maintain the system
    in the long run.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易出错且脆弱**：代码库导致修改时出现不可预测的错误和回归。在泥球式系统中，一切紧密相连，就像一团乱糟糟的电线。这使得当你改变一个部分时，很难知道会发生什么，就像试图在混乱的电线中修复一根松动的电线。这很容易导致意外问题和东西损坏，就像在混乱的电线中造成短路，使得长期开发和维护系统变得更加困难。'
- en: '**Reduced developer productivity**: You spend more time on maintaining the
    code base instead of focusing on new features.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低开发者生产力**：你花费更多的时间在维护代码库上，而不是专注于新功能。'
- en: '**Limited scaling and growth**: A rigid code structure makes it difficult to
    introduce new features or adapt to changes:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的扩展和增长**：僵化的代码结构使得引入新功能或适应变化变得困难：'
- en: '![Figure 1.1: A quality diagram of a big ball of mud](img/B09148_01_001.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：泥球式软件的质量图](img/B09148_01_001.jpg)'
- en: 'Figure 1.1: A quality diagram of a big ball of mud'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：泥球式软件的质量图
- en: When writing a program, we see that it becomes more of a problem than a solution
    within a short time (see *Figure 1**.1*). The preceding graph tracks how a project
    progresses over time. Time is on the bottom (X-axis) and features added are on
    the side (Y-axis).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写程序时，我们会发现它在短时间内就变成了问题而不是解决方案（见*图1.1*）。前面的图表跟踪了项目随时间的发展。时间在底部（X轴）上，添加的功能在旁边（Y轴）上。
- en: Starting a project without a clear plan, such as using the big ball of mud approach,
    might seem easy at first. Imagine building with blocks – no instructions are needed
    and you can put things together quickly. But for these projects, as they get more
    features (higher Y-axis value), the overall quality suffers (gets worse).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有明确计划的情况下开始一个项目，例如使用泥球式方法，一开始可能看起来很简单。想象一下用积木搭建——不需要指令，你可以快速组合东西。但对于这些项目，随着它们的功能越来越多（Y轴值越高），整体质量就会下降（变得更差）。
- en: In the short term (a few weeks), both well-designed projects and big ball of
    mud projects might seem similar. But over time, the quality of the messy project
    goes downhill.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在短期内（几周内），设计良好的项目和泥球式项目可能看起来很相似。但时间久了，混乱项目的质量就会下降。
- en: Overall, while a big ball of mud approach might seem faster initially, it ultimately
    creates more problems in the long run. It’s like taking a shortcut that might
    save you time now but leads to bigger issues later on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，虽然泥球式方法一开始可能看起来更快，但从长远来看，它最终会带来更多问题。这就像走捷径，现在可能节省了时间，但后来却导致更大的问题。
- en: One of the factors that turned our code into a big ball of mud over time was
    a lack of planning and organization. Planning and organizational structure are
    the attributes we usually use when building microservice architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们的代码变成泥球式的一个因素是缺乏规划和组织。规划和组织结构是我们构建微服务架构时通常使用的属性。
- en: Understanding the software development process
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解软件开发过程
- en: 'The development process not only covers coding – it is also about business,
    communication, discussion, analyzing, designing, testing, and deploying. Let’s
    call these the **attributes** of the software development process (see *Figure
    1**.2*). Software development is much more than just writing code lines. While
    coding is certainly an important part, it’s only one piece of the puzzle. Because
    of that, it is essential to understand the core needs and goals of the business:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 开发过程不仅涵盖编码——它还涉及业务、沟通、讨论、分析、设计和部署。让我们把这些称为软件开发过程的**属性**（见*图1.2*）。软件开发远不止是编写代码行。虽然编码当然是一个重要的部分，但它只是拼图中的一块。正因为如此，理解业务的核心需求和目标是至关重要的：
- en: '![Figure 1.2: Software development life cycle](img/B09148_01_002.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：软件开发生命周期](img/B09148_01_002.jpg)'
- en: 'Figure 1.2: Software development life cycle'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：软件开发生命周期
- en: 'The following list provides comprehensive insights into the software development
    process:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了对软件开发过程的全面洞察：
- en: The need to solve specific problems and think in terms of the business landscape
    is what drives software development. For developers to create software solutions
    that are not only relevant, but also meaningful, they must have a deep understanding
    of market dynamics, industry, and user requirements.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决特定问题和从商业景观的角度思考是推动软件开发的动力。为了创建既相关又有意义的软件解决方案，开发者必须对市场动态、行业和用户需求有深刻的理解。
- en: Effective collaboration and transparent communication are the backbone of success
    at every stage. Developers engage with a range of stakeholders, including business
    analysts, designers, testers, and clients. Clear communication ensures that everyone
    is on the same page regarding objectives, requirements, and project milestones.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的协作和透明的沟通是每个阶段成功的基石。开发者与包括业务分析师、设计师、测试人员和客户在内的各种利益相关者进行互动。清晰的沟通确保每个人都对目标、需求和项目里程碑保持一致。
- en: Discussing the ideas, obstacles, and potential solutions is very important.
    Effective brainstorming sessions, code reviews, and attentive user feedback all
    contribute to the quality of software. Open communication makes problem-solving
    more efficient.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论想法、障碍和潜在解决方案非常重要。有效的头脑风暴会议、代码审查和细致的用户反馈都有助于提高软件质量。开放沟通使问题解决更加高效。
- en: It is essential to carry out a thorough analysis of the requirements, user behavior
    patterns, and data insights. To create a solid software design strategy, developers
    must carefully analyze existing solutions, identify user needs, and break down
    complex problems.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对需求、用户行为模式和数据分析进行彻底分析是至关重要的。为了创建一个稳固的软件设计策略，开发者必须仔细分析现有解决方案，识别用户需求，并分解复杂问题。
- en: Careful consideration must be given to the architecture, functionality, and
    user interface of the software. Software that has been carefully designed is easy
    to use, effective, and maintain. A friendly user experience is the result of close
    collaboration between developers and designers.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件的架构、功能性和用户界面必须经过仔细考虑。经过精心设计的软件易于使用、有效且易于维护。友好的用户体验是开发者和设计师之间紧密合作的结果。
- en: Strict testing procedures are essential to guarantee the functionality, dependability,
    and conformity of the software regarding user expectations. Different testing
    approaches address different areas, such as performance benchmarks and core functionality.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格的测试程序对于保证软件的功能性、可靠性和符合用户期望至关重要。不同的测试方法针对不同的领域，如性能基准和核心功能。
- en: Ensuring that end users can access the software is the last step. This is usually
    called **deployment**. This includes setting up the infrastructure, taking stringent
    security precautions, and, if needed, providing thorough user training to optimize
    usability and adoption rates.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保最终用户能够访问软件是最后一步。这通常被称为**部署**。这包括设置基础设施、采取严格的预防措施，并在需要时提供全面的用户培训，以优化可用性和采用率。
- en: Now that we understand the software development process, let’s take a deeper
    look at the monolith approach to software development.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了软件开发过程，让我们更深入地探讨单体软件开发方法。
- en: Exploring the monolith approach
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索单体方法
- en: 'Say we have an e-commerce site with a single code base that was developed years
    ago. Over time, features and functionalities were added randomly, leading to messy
    code that contains duplication, is hard to maintain, and is difficult to troubleshoot.
    Here is the first suggested transition so that you can make your application responsive
    or alive again:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个单一代码库的电子商务网站，这个网站是几年前开发的。随着时间的推移，功能和功能被随机添加，导致代码混乱，包含重复内容，难以维护，且难以调试。以下是一个建议的过渡方案，以便您使您的应用程序响应或重新活跃起来：
- en: '**Analyze the current state of your application**: You need to identify key
    pain points affecting developer productivity and user experience. Try to divide
    the problem into smaller pieces. Trying to cover everything at once will lead
    you to more difficulties. Focus on specific modules or functionalities within
    the larger code base for initial refactoring. You need to understand dependencies,
    duplication, and complexity in your application.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析应用程序的当前状态**: 您需要识别影响开发效率和用户体验的关键痛点。尝试将问题分解成更小的部分。试图一次性覆盖所有内容将导致您遇到更多困难。关注更大代码库中的特定模块或功能，进行初步重构。您需要了解应用程序中的依赖关系、重复和复杂性。'
- en: '**Communication and collaborative planning**: The next steps are identifying
    the areas for improvement and agreeing on common architectural principles. Emphasize
    the phased approach, starting with small, isolated modules and demonstrating progress
    before moving on.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沟通和协作规划**: 下一步是确定改进领域并就共同架构原则达成一致。强调分阶段的方法，从小型、隔离的模块开始，在继续前进之前展示进度。'
- en: '**Choose a monolith architecture**: Decide which architectural style and pattern
    (layered, tiered, MVC, MVVM, and so on) aligns best with your needs in the given
    context.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择单体架构**: 决定哪种架构风格和模式（分层、分层、MVC、MVVM等）最适合您在特定环境中的需求。'
- en: '**Start small and iterate**: Set small goals and apply iterative development.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从小处着手，逐步迭代**: 设定小目标并应用迭代开发。'
- en: '**Make improvements**: Eliminate code duplication, clean up spaghetti code
    (a term that’s used for unstructured and difficult-to-understand programming code),
    and improve documentation.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进行改进**: 消除代码重复，清理乱麻代码（用于描述无结构且难以理解的编程代码的术语），并改进文档。'
- en: '**Application**: After each refactoring step, it is better to apply unit, integration,
    and regression testing to ensure code functionality and identify potential regression
    in your application.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用**: 在每个重构步骤之后，最好应用单元测试、集成测试和回归测试，以确保代码功能并识别应用程序中的潜在回归。'
- en: '**Feedback**: Gather feedback from developers and users throughout the process
    to adapt and refine the approach.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈**: 在整个过程中收集开发人员和用户的反馈，以适应和改进方法。'
- en: Welcome – you’re in the world of monoliths! But what is the concept of monolith?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到单体世界！但单体是什么概念呢？
- en: '![Figure 1.3: Monolith architecture](img/B09148_01_003.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3: 单体架构](img/B09148_01_003.jpg)'
- en: 'Figure 1.3: Monolith architecture'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '图1.3: 单体架构'
- en: Many online articles delve into the specifics of monolith architecture but rarely
    touch upon the broader concept, called the monolith approach. This isn’t surprising
    as the architecture has clear-cut characteristics. We love to be concrete and
    as developers, we are rarely theory lovers. However, it’s important to keep in
    mind that the monolith approach covers a greater variety of options.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 许多在线文章深入探讨了单体架构的细节，但很少涉及更广泛的概念，即单体方法。这并不奇怪，因为这种架构具有明确的特征。我们喜欢具体，作为开发者，我们很少是理论爱好者。然而，重要的是要记住，单体方法涵盖了更广泛的选择。
- en: The **monolith approach** is a broader concept that refers to a general way
    of building software as a single, self-contained unit. It can be implemented using
    various architectures, not just the traditional monolith architectures we know.
    It highlights simplicity, rapid development, and tight integration. The monolith
    approach is architecture-agnostic, meaning it can be implemented using various
    architectural styles or patterns, or even without a specific architectural framework
    at all, so long as the core principle of consolidating components into a single
    unit is maintained.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**单体方法**是一个更广泛的概念，指的是将软件作为一个单一、自包含的单元进行构建的一般方式。它可以使用各种架构实现，而不仅仅是我们所知的传统单体架构。它强调简单性、快速开发和紧密集成。单体方法是架构无关的，这意味着可以使用各种架构风格或模式实现，甚至可以在没有任何特定架构框架的情况下实现，只要保持将组件合并为单一单元的核心原则。'
- en: On the other hand, **monolith architecture** (see *Figure 1**.3*) is a specific
    software architecture where everything, from UI to business logic to data access,
    is built as a single, tightly coupled unit. It often uses a single code base,
    programming language, and database.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**单体架构**（见*图1.3*）是一种特定的软件架构，其中从UI到业务逻辑到数据访问，所有内容都被构建为一个单一、紧密耦合的单元。它通常使用单个代码库、编程语言和数据库。
- en: Monolith architecture refers to the specific architectural design or pattern
    that’s used to implement the monolith approach. It includes all of the technological
    choices and structural design of the monolithic system, including the arrangement
    of modules, the interactions between components, and the data management process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构指的是用于实现单体方法的特定架构设计或模式。它包括单体系统的所有技术选择和结构设计，包括模块的排列、组件之间的交互以及数据管理过程。
- en: 'The monolith approach itself doesn’t dictate a specific architecture. However,
    certain architectural styles and patterns naturally align with and support the
    monolith approach more effectively than others. Examples include the layered architecture,
    the MVC architecture, and the N-tier architecture. The monolith approach can also
    be implemented without strictly adhering to a specific architecture, especially
    for smaller projects. The key feature here is to maintain a single code base and
    deployment unit. Whether you choose a structured style or a more organic approach,
    the core principle remains: build a cohesive software unit. Understanding this
    distinction forces you to make informed decisions when navigating the vast world
    of software architectures. So, while the monolith approach promotes the development
    of software as a unified entity, the monolith architecture determines how that
    unity is achieved and maintained. Knowing this difference allows you to navigate
    the wide world of software architectures with knowledge and confidence.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 单体方法本身并不指定特定的架构。然而，某些架构风格和模式与单体方法更自然地一致，并更有效地支持它，比其他方法更有效。例如，分层架构、MVC架构和N层架构。单体方法也可以在不严格遵循特定架构的情况下实现，特别是对于小型项目。这里的关键特征是保持单一的代码库和部署单元。无论你选择结构化风格还是更有机的方法，核心原则保持不变：构建一个统一的软件单元。理解这种区别迫使你在导航软件架构的广阔世界中做出明智的决定。因此，虽然单体方法促进了软件作为一个统一实体的开发，但单体架构决定了这种统一是如何实现和维持的。了解这种差异使你能够带着知识和信心在软件架构的广阔世界中导航。
- en: 'While not without its drawbacks, the monolith approach offers several advantages,
    particularly for certain types of projects. These advantages are listed here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单体方法并非没有缺点，但它为某些类型的项目提供了几个优点。以下列出了这些优点：
- en: '**Simplicity and speed**: Monolith architecture enables faster development
    and deployment cycles by consolidating the entire system into a single codebase,
    reducing the overhead of managing multiple services.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁与速度**：单体架构通过将整个系统整合到一个单一的代码库中，实现了更快的开发和部署周期，减少了管理多个服务带来的开销。'
- en: '**Maintainability and control**: Having everything in one place allows for
    easier management, control over application performance, and a unified approach
    to maintaining and securing the system'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性和控制**：所有内容都在一个地方，使得管理、控制应用性能以及维护和保障系统的方式更加统一。'
- en: '**Performance and cost**: This architecture offers the advantage of reduced
    complexity, leading to lower infrastructure costs and optimized performance for
    applications with straightforward requirements.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和成本**：这种架构提供了降低复杂性的优势，导致基础设施成本降低，并优化了具有简单要求的应用的性能。'
- en: '**Additional benefits**: It provides practical advantages for simpler projects,
    making it easier to manage data and application operations, especially for smaller
    teams.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外优势**：它为简单的项目提供了实际的优势，使得管理和应用操作更加容易，尤其是对于小型团队来说。'
- en: 'Even though the monolithic approach has benefits, such as speed and simplicity,
    not all projects can benefit from it. To help determine whether the monolithic
    approach is right for your project, consider these general guidelines:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 即使单体方法有诸如速度和简单性等好处，但并非所有项目都能从中受益。为了确定单体方法是否适合你的项目，请考虑以下一般性指南：
- en: '**Simple and well-defined applications**: A monolith works well in applications
    that have a defined scope and few functionalities. Simple mobile apps, internal
    tools, and basic e-commerce sites are a few examples.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单且定义明确的应用**：单体架构在具有明确范围和少量功能的应用中表现良好。简单的移动应用、内部工具和基本的电子商务网站是一些例子。'
- en: '**Quick product launches and idea testing**: This is made possible by the agility
    of a monolithic architecture, which is useful if your project requires for quick
    development cycles or frequent prototyping.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速产品发布和想法测试**：这是由单体架构的敏捷性实现的，如果你的项目需要快速的开发周期或频繁的原型制作，这将非常有用。'
- en: '**Small teams with limited experience**: Initially, managing and maintaining
    a monolith may be more manageable for teams that lack experience with distributed
    systems or microservices.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型团队和有限的经验**：最初，对于缺乏分布式系统或微服务经验的团队来说，管理和维护单体可能更容易。'
- en: '**Tight data coupling and consistency**: Monolithic architectures are advantageous
    for applications that rely heavily on consistent data across multiple functionalities.
    It guarantees data integrity throughout the application and simplifies data management.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密的数据耦合和一致性**：对于依赖于多个功能之间一致数据的应用程序，单体架构具有优势。它保证了整个应用程序的数据完整性，并简化了数据管理。'
- en: '**Limited scalability requirements**: Without the hassle of scaling microservices,
    a monolithic architecture might be able to satisfy your scalability requirements
    if your application expects stable user traffic and moderate growth projections.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的可扩展性需求**：在没有扩展微服务的麻烦的情况下，如果您的应用程序预期用户流量稳定且增长预期适中，单体架构可能能够满足您的可扩展性需求。'
- en: The best architecture depends on your specific application’s requirements. Here,
    you must consider factors such as scalability, complexity, technology needs, and
    development team structure. As we mentioned previously, there’s no one-size-fits-all
    solution in software development.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳架构取决于您特定应用程序的需求。在这里，您必须考虑诸如可扩展性、复杂性、技术需求以及开发团队结构等因素。正如我们之前提到的，软件开发中没有一种适合所有情况的解决方案。
- en: 'While the monolith approach has its benefits, it’s not suitable for every application.
    It’s better not to use monolith when it comes to the following aspects:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单体方法有其优点，但它并不适合每个应用程序。在以下方面，最好不要使用单体：
- en: Building a highly scalable application
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建高度可扩展的应用程序
- en: Applications with constantly evolving features, modularity, and independent
    deployment
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有不断演变的功能、模块化和独立部署的应用程序
- en: If your application requires integrating diverse technologies or frameworks,
    also referred to as heterogeneous technologies
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的应用程序需要集成不同的技术或框架，也称为异构技术
- en: If high availability and resilience are critical and one of the important attributes
    for your system is fault-tolerance
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果高可用性和弹性至关重要，并且您的系统的一个重要属性是容错性
- en: If different teams work on distinct functionalities – that is, if there is independent
    development and deployment across teams
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不同的团队负责不同的功能——也就是说，如果团队之间有独立开发和部署
- en: When you have large teams and distributed development
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您拥有大型团队和分布式开发
- en: Besides its pros and cons, Monolith is usually a preferable architecture for
    getting started but not the only architecture to build better applications. We
    have another preferable architecture called **service-oriented approach** (**SOA**)
    that we plan to dive into details starting from the next page.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其优缺点之外，单体通常是一个适合入门的架构，但并非构建更好应用程序的唯一架构。我们还有另一个首选架构，称为**面向服务的架构**（**SOA**），我们计划从下一页开始深入了解。
- en: What is service-oriented architecture?
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是面向服务的架构？
- en: A monolithic architecture unifies all of the components/elements – including
    the user interface and data access – into a single code base, promoting simplicity
    and quick development. Although it’s not impossible, combining different technologies
    into *one system* can be difficult to maintain and unfeasible at times. In the
    absence of contemporary methodologies such as feature flags and blue-green deployment,
    it becomes necessary to deploy the entire application every time you want to update
    a monolithic application. There are difficulties with organizing and delivering
    the application smoothly, which could mess up its launch.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构将所有组件/元素——包括用户界面和数据访问——统一到一个代码库中，促进了简单性和快速开发。尽管并非不可能，但将不同的技术结合到*一个系统*中可能难以维护，有时甚至不可行。在没有当代方法如功能标志和蓝绿部署的情况下，每次您想要更新单体应用程序时，都必须部署整个应用程序。在组织和顺利交付应用程序方面存在困难，这可能会搞乱其发布。
- en: On the other hand, SOA (see *Figure 1**.4*) focuses on modularity and reuse,
    breaking down functionalities into independent services that communicate with
    each other through **application programming** **interfaces** (**API**s).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，SOA（见*图1**.4*）侧重于模块化和重用，将功能分解为相互通信的独立服务，这些服务通过**应用程序编程** **接口**（**API**s）进行通信。
- en: SOA can be defined as multiple, smaller, and often coarser-grained services,
    each with a specific function. This modularity offers advantages such as flexibility
    and scalability. Services in SOA can be deployed and scaled independently, meaning
    you can update or scale one service without affecting others. This is a key benefit
    of SOA.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: SOA可以被定义为多个较小且通常粒度较粗的服务，每个服务都有特定的功能。这种模块化提供了诸如灵活性和可扩展性等优势。SOA中的服务可以独立部署和扩展，这意味着您可以更新或扩展一个服务而不会影响其他服务。这是SOA的一个关键优势。
- en: 'The analogy from moving from monolith to SOA can be described like this: You
    have a big method/function that does everything (similar to a monolith). After
    some time, some other parts of your functionalities are required so that these
    functionalities can be reused. Instead of copying it, you’re breaking this giant
    method into reusable parts (similar to SOA). In this case, the method calls are
    going to be our API calls:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从单体到SOA的类比可以这样描述：您有一个做所有事情的大方法/函数（类似于单体）。过了一段时间，您的功能的一些其他部分被需要，以便这些功能可以被重用。而不是复制它，您将这个巨大的方法分解成可重用的部分（类似于SOA）。在这种情况下，方法调用将成为我们的API调用：
- en: '![Figure 1.4: An overview of service-oriented approach](img/B09148_01_004.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4：面向服务方法概述](img/B09148_01_004.jpg)'
- en: 'Figure 1.4: An overview of service-oriented approach'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：面向服务方法概述
- en: Consider multiple applications (as shown in *Figure 1**.4* – account management,
    CRM, and sales management) that need to share common functionalities. Instead
    of duplicating them for every application, we provide a service-oriented approach.
    At first glance, it may look like they are *perfect* grained services, but our
    focus is just to *share* common behavior that supports scaling and reusing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑多个应用程序（如图*图1.4* – 账户管理、CRM和销售管理）需要共享公共功能。而不是为每个应用程序复制它们，我们提供面向服务的方法。乍一看，它们可能看起来是*完美*粒度的服务，但我们的重点是仅仅*共享*支持扩展和重用的公共行为。
- en: To encapsulate communication complexity, we may use a service bus, which allows
    us to write additional logic and move the complexity to the outside of the application,
    which acts as a mediator. This is one of the signs that we should use architectural
    mediators in applications.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装通信复杂性，我们可能会使用服务总线，这允许我们编写额外的逻辑并将复杂性移动到应用程序的外部，该应用程序充当调解者。这是我们应在应用程序中使用架构调解器的迹象之一。
- en: Think of two functions within a single program and one directly calls the other.
    In SOA, each function becomes a standalone service, communicating through a defined
    interface. This enables independent deployment, updates, and even development
    by different teams.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在一个程序中存在两个函数，其中一个直接调用另一个。在SOA中，每个函数都成为一个独立的服务，通过定义的接口进行通信。这使它们能够独立部署、更新，甚至由不同的团队进行开发。
- en: 'Imagine building with Lego bricks instead of monolithic blocks. That’s the
    essence of SOA: breaking down applications into reusable, independent services,
    each focused on a specific task. Instead of hard-coded connections, they communicate
    through standard protocols such as **REST** or **SOAP**, making them platform-agnostic
    and adaptable.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下用乐高积木而不是单体块来构建。这就是SOA的本质：将应用程序分解为可重用、独立的、专注于特定任务的服务。而不是硬编码的连接，它们通过标准协议（如**REST**或**SOAP**）进行通信，使它们具有平台无关性和适应性。
- en: 'SOA offers numerous advantages that can significantly improve the flexibility,
    agility, and efficiency of your organization’s IT infrastructure. Let’s discover
    its key benefits:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SOA提供了许多优势，可以显著提高您组织IT基础设施的灵活性、敏捷性和效率。让我们来发现它的关键好处：
- en: '**Business agility**: SOA supports fast development and deployment, helping
    businesses quickly adapt to market changes and align their software with evolving
    business objectives.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务敏捷性**：SOA支持快速开发和部署，帮助企业快速适应市场变化，并使软件与不断发展的业务目标保持一致。'
- en: '**Technical advantages**: SOA offers flexibility and scalability, allowing
    for easier integration, upgrades, and reuse of components across the system without
    disrupting the overall functionality.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术优势**：SOA提供了灵活性和可扩展性，允许在不干扰整体功能的情况下，更容易地集成、升级和跨系统重用组件。'
- en: '**Operational benefits**: SOA streamlines operations by reducing maintenance
    overhead and improving system reliability, while enhancing security through centralized
    management.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运营优势**：SOA通过减少维护开销和提高系统可靠性来简化操作，同时通过集中式管理增强安全性。'
- en: 'Although SOA has many advantages, there are drawbacks as well:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SOA有许多优势，但也有缺点：
- en: '**Enhanced complexity**: SOA introduces more complexity by requiring careful
    coordination between independent services, demanding skilled personnel, and detailed
    planning for development, testing, and maintenance.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的复杂性**：SOA通过要求独立服务之间的仔细协调、需要熟练的人员以及详细的发展、测试和维护规划，引入了更多的复杂性。'
- en: '**Possible problems with performance**: SOA can introduce latency due to network-based
    service interactions, adding complexity when ensuring secure and efficient communication
    between services.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能可能存在的问题**：SOA可能会由于基于网络的交互而引入延迟，在确保服务之间安全高效通信时增加复杂性。'
- en: '**Other difficulties**: SOA comes with high upfront costs and requires skilled
    professionals, making it challenging to maintain service coordination, manage
    responsibilities, and ensure smooth integration as the system evolves.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他困难**：SOA具有高昂的前期成本，需要熟练的专业人员，这使得维护服务协调、管理责任和确保系统演变过程中的平滑集成具有挑战性。'
- en: SOA is one step toward microservices. Most of the core ideas of microservices
    come from SOA.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SOA是迈向微服务的一步。微服务的许多核心思想都来自SOA。
- en: In the final section of this chapter, we’ll understand the benefits and challenges
    of the microservices architecture.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将了解微服务架构的益处和挑战。
- en: The differences between SOA and microservices
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOA和微服务之间的区别
- en: Microservices architecture simplifies building distributed, flexible, and scalable
    software. Instead of one monolithic system, it divides an application into small,
    standalone services, each of them focused on a specific task. These services communicate
    through simple interfaces, allowing for independent deployment and easy integration.
    When developing properly designed microservices, we get loosely coupled, reusable,
    extensible, and easily maintainable applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构简化了构建分布式、灵活和可扩展的软件。它不是使用一个单体系统，而是将应用程序划分为小型、独立的微服务，每个微服务专注于特定的任务。这些服务通过简单的接口进行通信，允许独立部署和易于集成。在正确设计微服务时，我们得到松散耦合、可重用、可扩展且易于维护的应用程序。
- en: 'When comparing microservices to SOA, they may seem similar in concept. SOA
    and microservices architecture are both architectural styles that are used for
    building distributed systems, but they have some key differences. Let’s compare
    them:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较微服务和SOA时，它们在概念上可能看起来很相似。SOA和微服务架构都是用于构建分布式系统的架构风格，但它们有一些关键的区别。让我们来比较一下：
- en: '**Scope and granularity**: Services in SOA are like big boxes containing multiple
    functionalities that are meant to be reused across different applications. Microservices
    are like tiny, specialized tools, each focusing on one specific task or feature
    within an application.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围和粒度**：SOA中的服务就像包含多个功能的大盒子，这些功能旨在在不同的应用程序之间重用。微服务就像小型、专业的工具，每个工具都专注于应用程序中的一个特定任务或功能。'
- en: '**Communication protocols**: Services in SOA mostly communicate using strict
    protocols, such as **SOAP**, **XML-RPC**, **WSDL**, and **UDDI**. Microservices
    prefer lightweight protocols such as **RESTful HTTP** or messaging queues, allowing
    for more flexible communication.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信协议**：SOA中的服务主要使用严格的协议进行通信，例如**SOAP**、**XML-RPC**、**WSDL**和**UDDI**。微服务更倾向于使用轻量级协议，如**RESTful
    HTTP**或消息队列，以实现更灵活的通信。'
- en: '**Technology stack**: SOA can work with different technologies and platforms.
    Microservices often use containerization tools such as **Docker** and orchestration
    tools such as **Kubernetes** for easier deployment and management.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术堆栈**：SOA可以与不同的技术和平台协同工作。微服务通常使用容器化工具，如**Docker**，以及编排工具，如**Kubernetes**，以实现更简单的部署和管理。'
- en: '**Dependency management**: Services in SOA can have intricate dependencies
    that require careful coordination. Microservices strive for loose coupling, reducing
    dependencies between services to simplify development and deployment.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖管理**：SOA中的服务可能具有复杂的依赖关系，需要仔细协调。微服务追求松散耦合，减少服务之间的依赖关系，以简化开发和部署。'
- en: '**Deployment and scaling**: Services in SOA are often centrally deployed and
    scaled at the service level. Microservices are deployed separately, allowing individual
    scaling and better resource utilization.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署和扩展**：在SOA中，服务通常在服务级别进行集中部署和扩展。微服务是独立部署的，允许单独扩展并更好地利用资源。'
- en: '**Organizational impact**: Once SOA is implemented, significant organizational
    changes may be required for coordination and management. Microservices promote
    decentralization of management by giving small, cross-disciplinary teams the autonomy
    to control their services.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织影响**：一旦实施了SOA，可能需要重大的组织变化以进行协调和管理。微服务通过给予小型、跨学科团队控制其服务的自主权来促进管理的去中心化。'
- en: The difference between *approach* and *architecture*, especially regarding microservices,
    is important.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务方面，*方法*和*架构*之间的区别非常重要。
- en: 'The microservice approach is all about how we think when designing software.
    It’s like having a mindset or philosophy of breaking down big, complicated systems
    into smaller, easier-to-handle parts. Each of these parts focuses on one specific
    task. It’s somewhat abstract and emphasizes concepts such as **modularity** (allowing
    for simple replacement), **scalability** (allowing for increased work), and **flexibility**
    (allowing for change adaptation):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务方法全部关乎我们在设计软件时的思维方式。这就像拥有一种心态或哲学，即把大而复杂的系统分解成更小、更容易处理的部件。每个部分都专注于一项特定任务。这有点抽象，并强调诸如**模块化**（允许简单替换）、**可伸缩性**（允许增加工作量）和**灵活性**（允许适应变化）等概念：
- en: '![Figure 1.5: Microservices architecture](img/B09148_01_005.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5：微服务架构](img/B09148_01_005.jpg)'
- en: 'Figure 1.5: Microservices architecture'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：微服务架构
- en: Every approach has its pros and cons. Nothing is ideal. To identify it from
    the Microservices perspective, let’s talk about the advantages and disadvantages
    of Microservices.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其优点和缺点。没有什么是完美的。从微服务的角度来看，让我们来谈谈微服务的优缺点。
- en: Advantages of microservices
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的优点
- en: 'In this section, we’ll look at the many reasons that make microservices an
    important part of software development:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨许多使微服务成为软件开发重要部分的原因：
- en: '**Scalability**: You can scale each microservice independently based on demand,
    ensuring resources are allocated where needed for optimal performance and cost-effectiveness.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：可以根据需求独立扩展每个微服务，确保资源分配到需要的地方，以实现最佳性能和成本效益。'
- en: '**Flexibility and agility**: Teams can work on different services simultaneously,
    speeding up development and making updates easier. Being agile is essential to
    adapting to the ever-shifting demands and markets of businesses.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性和敏捷性**：团队可以同时处理不同的服务，从而加快开发速度并使更新更容易。对业务不断变化的需求和市场的适应能力是敏捷性的关键。'
- en: '**Fault isolation**: If one microservice fails, it doesn’t necessarily affect
    others, thanks to their independence. This isolation improves system reliability
    by minimizing downtime.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障隔离**：由于它们的独立性，如果一个微服务失败，它并不一定会影响其他服务。这种隔离通过最小化停机时间来提高系统可靠性。'
- en: '**Technology diversity**: Multiple programming languages and technologies can
    be used in a single application thanks to microservices. Teams are encouraged
    to explore and be creative by selecting the finest tools for each service.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术多样性**：由于微服务，可以在单个应用程序中使用多种编程语言和技术。团队被鼓励通过为每个服务选择最佳工具来探索和发挥创造力。'
- en: '**Easy maintenance and updates**: Compared to huge monolithic programs, smaller
    services are easier to comprehend, manage, and update. Risks are decreased because
    modifications to one service won’t inadvertently affect others.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于维护和更新**：与庞大的单体程序相比，较小的服务更容易理解、管理和更新。由于对某一服务的修改不会无意中影响其他服务，因此风险降低。'
- en: '**Scalable development****teams**: Small, cross-functional teams can now own
    separate services thanks to microservices. This configuration promotes creativity,
    accelerates decision-making, and heightens accountability.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展的开发团队**：得益于微服务，小型、跨职能团队现在可以拥有独立的服务。这种配置促进了创造力，加速了决策过程，并提高了责任感。'
- en: '**Improved fault tolerance**: Microservices make it simpler to implement redundancy
    and failover techniques at the service level. This increases the system’s ability
    to withstand setbacks.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高容错性**：微服务使得在服务级别实现冗余和故障转移技术变得更加简单。这增加了系统承受挫折的能力。'
- en: '**Improved deployment practices**: **Continuous integration** and **continuous
    deployment** (**CI/CD**), two contemporary deployment techniques, mesh nicely
    with **microservices** architecture. Time to market is shortened by the release
    process being streamlined by automated deployment pipelines for every service.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的部署实践**：**持续集成**和**持续部署**（**CI/CD**）这两种当代部署技术与**微服务**架构完美结合。通过为每个服务的自动化部署管道简化发布流程，可以缩短上市时间。'
- en: '**Improved use of resources**: Resource allocation based on the unique requirements
    of each service is made possible by granular scaling, which maximizes resource
    efficiency and reduces costs.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源利用改进**：通过细粒度扩展，可以根据每个服务的独特需求进行资源分配，从而最大化资源效率并降低成本。'
- en: '**Encouragement of cooperation**: Encouraging cooperation between the development
    and operations teams through microservices makes it easier to implement DevOps
    principles. At the service level, feedback loops, automation, and monitoring can
    be put into place to improve overall quality and efficiency.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鼓励合作**：通过微服务鼓励开发和运维团队之间的合作，使得实施DevOps原则变得更加容易。在服务层面，可以通过反馈循环、自动化和监控来提高整体质量和效率。'
- en: '**Huge and complicated systems**: Microservices can help you simplify huge
    and complex applications as you can divide them into smaller, more manageable
    parts.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理庞大且复杂的系统**：微服务可以帮助你简化庞大且复杂的应用程序，因为你可以将它们分解成更小、更易于管理的部分。'
- en: '**Handles many users**: Because microservices allow you to scale each component
    individually to effectively handle the load, they are ideal for apps that experience
    high traffic or a large number of users.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理大量用户**：由于微服务允许你单独扩展每个组件以有效处理负载，因此它们非常适合经历高流量或拥有大量用户的应用程序。'
- en: '**Requires frequent updates or new features**: Microservices allow you to swiftly
    react to changing needs by allowing you to change individual components without
    affecting the entire application.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要频繁更新或添加新功能**：微服务允许你通过更改单个组件而不影响整个应用程序来迅速响应变化的需求。'
- en: '**Uses different technologies**: Microservices let you use different tools
    and programming languages for different parts of your app so that you can pick
    the best one for each job.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用不同的技术**：微服务允许你为应用程序的不同部分使用不同的工具和编程语言，以便为每个任务选择最佳选项。'
- en: '**Built by many teams**: If your app is being worked on by lots of different
    teams, microservices let each team work on their part, without getting in each
    other’s way.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由多个团队构建**：如果你的应用程序由许多不同的团队共同开发，微服务允许每个团队专注于自己的部分，而不会相互干扰。'
- en: '**Needs to stay running**: Microservices help your app stay up and running,
    even if one part fails. This is because each part is separate. As a result, problems
    in one area don’t crash the whole thing.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要持续运行**：微服务有助于你的应用程序保持运行状态，即使某个部分失败也是如此。这是因为每个部分都是独立的。因此，一个区域的问题不会导致整个系统崩溃。'
- en: '**Works in the cloud**: Microservices are a good fit for apps that run in the
    cloud because they’re designed to work well with cloud technology. Plus, tools
    such as containers and orchestrators make it even easier to manage them in the
    cloud.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适用于云环境**：由于微服务设计得与云技术良好配合，因此它们非常适合在云中运行的应用程序。此外，容器和编排器等工具使得在云中管理它们变得更加容易。'
- en: In summary, microservices provide a modern, flexible method for developing software,
    allowing businesses to innovate rapidly, grow effectively, and release high-caliber
    software products into the market more quickly. However, don’t attempt to use
    them for every kind of application you’re creating.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，微服务提供了一种现代、灵活的软件开发方法，使企业能够快速创新、有效增长，并能更快地将高质量的软件产品推向市场。然而，不要试图将它们用于你创建的每一种应用程序。
- en: Although microservices offer many advantages, you should be aware that they
    also come with some additional complexity, such as having to manage several moving
    components and more communication being required between services.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微服务提供了许多优点，但你应该意识到它们也带来了一些额外的复杂性，例如需要管理多个移动组件以及服务之间需要更多的通信。
- en: Disadvantages of microservices
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的缺点
- en: Throughout this chapter, we learned that the main reason for having various
    architectures in software development is a sign that there is no single truth
    and that depending on the requirements, architecture may vary. Every approach
    in design has its disadvantages and before applying any architecture, you should
    carefully analyze and understand them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到软件开发中存在各种架构的主要原因是没有单一真理的迹象，并且根据需求，架构可能有所不同。设计中的每一种方法都有其缺点，在应用任何架构之前，您应该仔细分析和理解它们。
- en: 'Here are some important disadvantages of microservices:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是微服务的一些重要缺点：
- en: '**Increased complexity in development**: Breaking down a system into smaller
    services can lead to increased complexity in development, deployment, and testing.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发中的复杂性增加**：将系统拆分为更小的服务可能导致开发、部署和测试的复杂性增加。'
- en: '**Interservice communication**: Managing communication between microservices
    can become complex, requiring careful design and implementation of APIs and protocols.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务间通信**：管理微服务之间的通信可能会变得复杂，需要仔细设计和实现API和协议。'
- en: '**Infrastructure complexity**: Managing and deploying a large number of microservices
    can introduce operational overhead, including the need for sophisticated orchestration
    and monitoring tools.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施复杂性**：管理和部署大量微服务可能会引入运营开销，包括需要复杂的编排和监控工具。'
- en: '**Infrastructure cost**: The overhead of managing multiple services and the
    associated infrastructure can lead to increased costs, particularly in terms of
    hosting and operational expenses.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施成本**：管理多个服务和相关基础设施的开销可能导致成本增加，尤其是在托管和运营费用方面。'
- en: '**Security issues**: A larger number of services means a larger attack surface,
    potentially increasing the security risk.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全问题**：服务数量越多，攻击面就越大，可能增加安全风险。'
- en: '**Communication security**: Securing communication between microservices requires
    additional attention to prevent unauthorized access.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信安全**：确保微服务之间的通信安全需要额外的关注，以防止未经授权的访问。'
- en: '**Coordination and communication**: Teams need to coordinate effectively to
    ensure that changes in one service do not adversely affect others.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协调和通信**：团队需要有效协调，以确保一个服务的更改不会对其他服务产生不利影响。'
- en: '**Data consistency**: Maintaining consistency across microservices can be challenging,
    especially when dealing with distributed databases. Ensuring data integrity and
    consistency becomes a complex task.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据一致性**：在微服务之间保持一致性可能具有挑战性，尤其是在处理分布式数据库时。确保数据完整性和一致性成为一个复杂任务。'
- en: '**Team expertise**: Developers need expertise in both the domain and technology
    stack of their specific microservice, potentially limiting flexibility in task
    assignments.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队专长**：开发者需要在特定微服务的领域和技术堆栈方面都有专长，这可能会限制任务分配的灵活性。'
- en: Therefore, we should carefully consider if microservices are the correct choice
    for our project based on the expertise of our team, the requirements of our application,
    and the readiness of our organization for the shift.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该根据我们团队的专长、我们应用程序的需求以及我们组织对转变的准备情况，仔细考虑微服务是否是我们项目的正确选择。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to microservices. We talked about coding without
    proper design and analysis, which brings us to a big ball of mud. Having no clear
    architecture is similar to having no map in the middle of the ocean.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了微服务。我们讨论了缺乏适当设计和分析的编码，这导致我们陷入了一个大泥球。没有清晰的架构就像在海洋中间没有地图一样。
- en: Our first step was starting with monoliths. We talked about the advantages and
    disadvantages of the monolith approach and tried to understand the differences
    between approach and architecture.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是从单体开始。我们讨论了单体方法的优缺点，并试图理解方法和架构之间的差异。
- en: Nowadays, requirements for applications are broader and more complex, and always
    trying to deal with them using a monolith approach may not be a good solution.
    To add important attributes, such as “distributed,” to the architecture, we considered
    SOA while discussing its pros and cons.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序的需求更加广泛和复杂，总是试图使用单体方法来处理它们可能不是一个好的解决方案。为了向架构中添加“分布式”等重要属性，我们在讨论其优缺点时考虑了SOA。
- en: The final destination for us was microservices. We provided a clear definition
    for it and tried to understand the advantages and disadvantages of using them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的目标是微服务。我们为其提供了一个明确的定义，并试图了解使用它们的优缺点。
- en: Microservices bring a lot of interesting challenges to our lives and one of
    them is communication. Dividing a big problem into smaller chunks is good but
    making proper communication between the chunks isn’t easy. When you’re ready,
    turn to the next chapter to explore it with me.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务给我们的生活带来了许多有趣的挑战，其中之一就是通信问题。将大问题分解成小块是好的，但要在这些小块之间建立适当的通信并不容易。当你准备好了，翻到下一章，和我一起探索这个问题。
