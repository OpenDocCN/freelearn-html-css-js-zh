- en: Using Modern JavaScript Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现代JavaScript特性
- en: 'The recipes we will be covering in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的食谱如下：
- en: Adding types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加类型
- en: Working with strings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理字符串
- en: Enhancing your code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强您的代码
- en: Defining functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数
- en: Programming functionally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Doing async calls compactly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧凑地进行异步调用
- en: Working with objects and classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理对象和类
- en: Organizing code in modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块中组织代码
- en: Determining a feature's availability
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定功能的可用性
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we set up our working environment with many tools that
    we will be using throughout this book. In this chapter, we will get ourselves
    prepared for the rest of this book, and we will be considering some interesting
    and powerful modern features of JavaScript that can you help be more effective
    and write better code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了许多工具来设置我们的工作环境，这些工具将贯穿本书的整个过程。在本章中，我们将为本书的其余部分做好准备，并考虑一些有趣和强大的现代JavaScript特性，可以帮助您更有效地编写更好的代码。
- en: We will be considering several new language features that will come handy—but
    definitely not everything! JS has really grown into a big language, and there
    are some features that you're not likely to ever need. From the very start, we
    will also work more seriously with `Flow`, aiming to forego the usage of *untyped
    JS*, for a safer way of developing code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑一些新的语言特性，这些特性将会很方便，但肯定不是所有！JS确实已经发展成为一门大语言，有一些特性您可能永远不会需要。从一开始，我们也将更认真地使用`Flow`，旨在放弃使用*无类型JS*，以更安全地开发代码。
- en: 'It may be important to highlight that JS has evolved through the years, and
    that there isn''t a single standard version. The most recent one is (formally)
    called ECMAScript 2018, which is usually shortened to ES2018\. The current list
    of versions of the language is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要强调JS已经在这些年里发展了，并且没有一个单一的标准版本。最近的一个版本（正式上）被称为ECMAScript 2018，通常缩写为ES2018。语言的当前版本列表如下：
- en: ECMAScript 1, June 1997
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 1，1997年6月
- en: ECMAScript 2, June 1998, essentially equal to the previous version
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 2，1998年6月，基本上与上一个版本相同
- en: ECMAScript 3, December 1999, adding several new functionalities
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 3，1999年12月，添加了几个新功能
- en: ECMAScript 5, December 2009 (there never was an ECMAScript 4; that version was
    abandoned) also known as JS5
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 5，2009年12月（从未有过ECMAScript 4；那个版本被放弃了），也称为JS5
- en: ECMAScript 5.1, June 2011
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 5.1，2011年6月
- en: ECMAScript 6 (ES2015 or ES6), June 2015
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 6（ES2015或ES6），2015年6月
- en: ECMAScript 7 (ES2016), June 2016
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 7（ES2016），2016年6月
- en: ECMAScript 8 (ES2017), June 2017
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 8（ES2017），2017年6月
- en: ECMAScript 9 (ES2018), June 2018
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 9（ES2018），2018年6月
- en: '**ECMA** was originally an acronym meaning **European Computer Manufacturers Association**,
    but nowadays the name is simply considered a name by itself. You can go to its
    site at [https://www.ecma-international.org/](https://www.ecma-international.org/) and
    view the standard language specification at [https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**ECMA** 最初是欧洲计算机制造商协会的首字母缩写，但现在这个名字被认为是一个独立的名字。您可以访问它的网站[https://www.ecma-international.org/](https://www.ecma-international.org/)，并在[https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm)上查看标准语言规范。'
- en: Whenever we refer to JS in this text without further specification, the latest
    version (that is, ES2018) is what we mean. No browsers fully implement this version,
    and further on in this book, we'll solve this problem by using `Babel`, a tool
    that will convert the modern features into equivalent, but older and compatible
    code, so even if you program in the latest fashion, users with older browsers
    will still be able to run your code. The tools we'll be using will install `Babel`
    on their own, so we won't have to do that, but if you're curious, you can read
    more at [https://babeljs.io/](https://babeljs.io/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在本文中提到JS而没有进一步的规定时，我们指的是最新版本（即ES2018）。没有浏览器完全实现这个版本，在本书的后面，我们将通过使用`Babel`来解决这个问题，这是一个工具，可以将现代特性转换为等效的、但更老的和兼容的代码，因此即使您以最新的方式编程，使用较旧的浏览器的用户仍然能够运行您的代码。我们将使用的工具将自行安装`Babel`，因此我们不需要这样做，但如果您感兴趣，可以在[https://babeljs.io/](https://babeljs.io/)上阅读更多信息。
- en: A very good source for all JS-related things is the **Mozilla Developer Network**
    (**MDN**), which has been going strong with all sorts of web documentation for
    over ten years. Take a look to their site at [https://developer.mozilla.org/bm/docs/Web/JavaScript](https://developer.mozilla.org/bm/docs/Web/JavaScript);
    we'll be frequently making reference to it. You can also read [http://es6-features.org/](http://es6-features.org/)
    for a wealth of examples of ES6 features.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与JS相关的很好的来源是**Mozilla开发者网络**（**MDN**），它已经有十多年的各种网络文档。请访问他们的网站[https://developer.mozilla.org/bm/docs/Web/JavaScript](https://developer.mozilla.org/bm/docs/Web/JavaScript)；我们将经常参考它。您还可以阅读[http://es6-features.org/](http://es6-features.org/)，了解ES6功能的丰富示例。
- en: Adding types
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加类型
- en: In the previous chapter, we installed `Flow` so that we could add data types
    check to JS, but we didn't really get into its syntax or rules. Let's get into
    that now, before getting into JS-specific features.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们安装了`Flow`，以便我们可以为JS添加数据类型检查，但我们并没有真正涉及其语法或规则。让我们现在进入这个话题，然后再进入JS特定的功能。
- en: Getting started
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Starting with Flow''s controls, you just have to specify what data type you
    expect any variable to be, and `Flow` will check that it''s always used correctly.
    Fortunately, `Flow` is also capable of determining data types by value; for example,
    if you assign a string to a variable, it will assume that this variable is meant
    to contain strings. Adapting an example from [https://flow.org/en/docs/usage/](https://flow.org/en/docs/usage/), you
    could write the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从Flow的控制开始，您只需指定您期望任何变量的数据类型，`Flow`将检查它是否始终被正确使用。幸运的是，`Flow`也能够通过值确定数据类型；例如，如果您将一个字符串赋给一个变量，它将假定这个变量是用来包含字符串的。从[https://flow.org/en/docs/usage/](https://flow.org/en/docs/usage/)中调整一个例子，您可以写如下内容：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `:?number` and `:string` annotations specify that `x` is an optional numeric
    parameter, and that `foo` should return a string. Can you see two problems with
    the rest of the code? If you use `npm run flow`, you''ll get a report showing
    what the problem is. First, you cannot `return x`, because of the data types mismatch
    between the variable and the expected return value:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`:?number`和`:string`注释指定`x`是一个可选的数值参数，并且`foo`应该返回一个字符串。您能看到代码的其余部分有两个问题吗？如果您使用`npm
    run flow`，您将得到一个报告，显示问题所在。首先，您不能`return x`，因为变量和预期返回值之间的数据类型不匹配：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Second, you are trying to call a function but passing a parameter of the wrong
    type:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您正在尝试调用一个函数，但传递了错误类型的参数：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All of the preceding code is (except for the type declarations) valid JS, so
    it would have been accepted; `Flow` tells you about the problems so that you can
    fix them. Now, let's get into greater detail, and see all of the possibilities
    that this tool gives us.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的所有代码（除了类型声明）都是有效的JS代码，因此它将被接受；`Flow`会告诉您问题所在，以便您可以解决它们。现在，让我们更详细地了解一下，看看这个工具给我们提供了所有的可能性。
- en: If you want to ignore Flow's warnings for any line, precede it with a comment
    like `// @FlowFixMe` and follow with the reason why you want to skip that situation.
    See [https://flow.org/en/docs/config/options/#toc-suppress-comment-regex](https://flow.org/en/docs/config/options/#toc-suppress-comment-regex) for
    more on this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想忽略`Flow`对任何行的警告，请在其前面加上注释，如`// @FlowFixMe`，并在后面说明为什么要跳过该情况。有关更多信息，请参阅[https://flow.org/en/docs/config/options/#toc-suppress-comment-regex](https://flow.org/en/docs/config/options/#toc-suppress-comment-regex)。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: There are many ways to define types so that you can deal with simple and complex
    cases with no problems. Let's start with the simpler, basic types, and then move
    on to more specific cases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种方法来定义类型，以便您可以处理简单和复杂的情况而不会出现问题。让我们从更简单的基本类型开始，然后再转向更具体的情况。
- en: Basic types in Flow
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flow中的基本类型
- en: 'The possible data types definitions can be found at [https://flow.org/en/docs/types/](https://flow.org/en/docs/types/)—we
    won''t copy them all here, but rather show you the main ones through a few examples.
    Please look at the full documentation because there''s a great variety of possibilities
    that you should be aware of:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://flow.org/en/docs/types/](https://flow.org/en/docs/types/)找到可能的数据类型定义——我们不会在这里全部复制，而是通过一些示例向您展示主要的数据类型。请查看完整的文档，因为有许多可能性，您应该了解：
- en: '| `:boolean` | Boolean values. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `:boolean` | 布尔值。 |'
- en: '| `:number` | Numeric values. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `:number` | 数值。 |'
- en: '| `:string` | Strings. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `:string` | 字符串。 |'
- en: '| `:null` | Null values. You wouldn''t just be declaring that a certain variable should
    always be null; rather,you''ll be using these with advanced types such as *unions*,
    which we''ll get to see in the next section. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `:null` | 空值。您不仅会声明某个变量应该始终为null；而是，您将与高级*联合*类型一起使用这些，我们将在下一节中看到。 |'
- en: '| `:void` | Void (undefined) value. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `:void` | 空（未定义）值。 |'
- en: '| `:mixed` | Any type, but will still get checked for consistency. For instance, if
    at one point `Flow` knows that the variable is a Boolean, then using it as a string would
    be flagged as wrong. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `:mixed` | 任何类型，但仍会进行一致性检查。例如，如果在某一点`Flow`知道变量是布尔值，那么将其用作字符串将被标记为错误。 |'
- en: '| `:any` | Any type, and `Flow` won''t do any checks for it.This amounts to disabling
    type checks onwhatever is of *any* type. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `:any` | 任何类型，`Flow`不会对其进行任何检查。这相当于在任何*类型的任何*上禁用类型检查。 |'
- en: '| `function foo(x: ?boolean)` | A function with an optional `boolean` parameter.
    This is the same as declaring that the argumentcan either be a `boolean`, `null`,
    or also `undefined`. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `function foo(x: ?boolean)` | 一个带有可选`boolean`参数的函数。这与声明参数可以是`boolean`、`null`或`undefined`是一样的。
    |'
- en: '| `function bar() :string` | A function that returns a string result. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `function bar() :string` | 返回字符串结果的函数。 |'
- en: '| `{ property ?: number }` | An optional object property; if present, it could
    be numeric or undefined, but not `null`. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `{ property ?: number }` | 可选的对象属性；如果存在，它可以是数字或未定义，但不能是`null`。 |'
- en: '| `: Array&lt;number>` `: number[]` | An array of numbers, in two different
    styles. If you want to deal with fixed length arrays, *tuples* may apply; go to [https://flow.org/en/docs/types/tuples/](https://flow.org/en/docs/types/tuples/) to
    find out more. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `: Array&lt;number>` `: number[]` | 两种不同风格的数字数组。如果您想处理固定长度的数组，*元组*可能适用；请访问[https://flow.org/en/docs/types/tuples/](https://flow.org/en/docs/types/tuples/)了解更多信息。
    |'
- en: We will find out how to assign or define types for these definitions in the *Defining
    types for arrow functions* recipe, later in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的*为箭头函数定义类型*中找出如何为这些定义分配或定义类型。
- en: 'We can see some examples of the definitions in the following code. I disabled
    ESLint''s rule about unused variables to avoid obvious problems:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码中看到一些定义的示例。我禁用了ESLint关于未使用变量的规则，以避免明显的问题：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `addTwo()` definition has a hidden problem: are you sure that `x` and `y` will
    always be of the same type? Actually, `x` could be a number and `y` could be a
    string, and `Flow` wouldn''t complain. We have no easy way of testing this, and
    a runtime check for `typeof x === typeof y` would be needed.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`addTwo()`的定义存在一个隐藏的问题：您确定`x`和`y`始终是相同类型吗？实际上，`x`可以是一个数字，`y`可以是一个字符串，`Flow`不会抱怨。我们没有简单的方法来测试这一点，需要运行时检查`typeof
    x === typeof y`。'
- en: 'When you define an object, you should provide data types for all of its properties
    and methods. Object definitions are considered to be *sealed*, meaning that you
    cannot change the object types. If you cannot or won''t do this, start with an
    empty object, and then `Flow` will let you add properties at will:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '当您定义一个对象时，应为其所有属性和方法提供数据类型。对象定义被认为是*sealed*，这意味着您不能更改对象类型。如果您不能或不想这样做，请从一个空对象开始，然后`Flow`将允许您随意添加属性： '
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If a function expects an object with some properties, and it receives an object
    with those properties plus some extra ones, `Flow` won't complain. If you don't
    want this, use *exact objects*; see [https://flow.org/en/docs/types/objects/#toc-exact-object-types](https://flow.org/en/docs/types/objects/#toc-exact-object-types).
    However, this also causes problems, such as disabling the spread operator; see [https://github.com/facebook/flow/issues/2405](https://github.com/facebook/flow/issues/2405)
    for a (two year long!) discussion.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数期望一个带有一些属性的对象，并且它接收到一个带有这些属性以及一些额外属性的对象，`Flow`不会报错。如果你不想要这样，可以使用*exact
    objects*；参见[https://flow.org/en/docs/types/objects/#toc-exact-object-types](https://flow.org/en/docs/types/objects/#toc-exact-object-types)。然而，这也会导致问题，比如禁用spread操作符；参见[https://github.com/facebook/flow/issues/2405](https://github.com/facebook/flow/issues/2405)进行（长达两年的）讨论。
- en: Now, let's turn to more complex definitions, which you will probably end up
    using, since they better match usual business requirements and program specifications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向更复杂的定义，你可能最终会使用它们，因为它们更符合通常的业务需求和程序规范。
- en: Union types
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型
- en: The basic definitions of the previous section may be enough for plenty of code,
    but as you start working with more complex problems, you'll need some more advanced
    `Flow` features, and you may want to define types separately so that you can reuse
    them elsewhere. Due to this, in this and the following sections, we'll look at
    more advanced types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的基本定义可能足够用于大量的代码，但是当你开始处理更复杂的问题时，你将需要一些更高级的`Flow`特性，并且你可能希望单独定义类型，以便在其他地方重用它们。因此，在本节和接下来的几节中，我们将看一些更高级的类型。
- en: 'In JS, it''s common that a variable may have, at different times, different
    data types. For that situation, you can use *union* *types*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在JS中，一个变量可能在不同的时间具有不同的数据类型是很常见的。对于这种情况，你可以使用*union* *types*：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For some occasions in which you have objects that have different properties
    depending on some internal value, you can also use *disjoint* unions; see [https://flow.org/en/docs/types/unions/](https://flow.org/en/docs/types/unions/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能有对象，这些对象根据某些内部值具有不同的属性，你也可以使用*disjoint* unions；参见[https://flow.org/en/docs/types/unions/](https://flow.org/en/docs/types/unions/)。
- en: Class types
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类类型
- en: '`Flow` supports classes and mostly in an automatic way. Every time you define
    a class, it becomes a type by itself, so you don''t have to do anything else;
    you can just use it elsewhere. (We''ll be seeing more about classes in a short
    while, in the *Working with Objects and Classes* section.) You can assign types
    to properties and methods in the same way as for objects and functions. Using
    our `Person` class again as an example, the following code shows how to define
    it with `Flow`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow`支持类，并且大部分是自动的。每当你定义一个类，它就成为一个独立的类型，所以你不需要做其他任何事情；你可以在其他地方直接使用它。（我们将在不久的将来在*使用对象和类*部分中更多地了解类。）你可以像为对象和函数一样为属性和方法分配类型。再次以`Person`类为例，以下代码展示了如何在`Flow`中定义它：'
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, there is a problem you may encounter. If you have distinct classes,
    even with exactly the same shape, they won''t be considered equivalent by `Flow`.
    For instance, even if `Animal` and `Pet` are equivalent, the assignment of `Pet`
    to `Animal` (or vice versa) won''t be allowed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会遇到一个问题。如果你有不同的类，即使它们的形状完全相同，`Flow`也不会认为它们是等价的。例如，即使`Animal`和`Pet`是等价的，也不允许将`Pet`赋值给`Animal`（反之亦然）：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this particular case, if you were to say that `Pet` extends `Animal`, then
    you could assign `Pet` to `Animal`, but not the other way round. A more general
    solution would involve creating an `interface` and using it in several places:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，如果你说`Pet`扩展`Animal`，那么你可以将`Pet`赋值给`Animal`，但反过来不行。一个更一般的解决方案将涉及创建一个`interface`并在多个地方使用它：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the `interface` definition, which includes three fields, doesn't exempt
    you from declaring those fields when you define `Animal2` or `Pet2`; in fact,
    if you were to forget some of these fields, `Flow` would point out the error,
    because neither of the three is marked as optional.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，包括三个字段的`interface`定义并不意味着在定义`Animal2`或`Pet2`时免除你声明这些字段；事实上，如果你忘记了其中一些字段，`Flow`会指出错误，因为这三个字段都没有标记为可选的。
- en: Type aliases
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'When your types become more complex or when you want to reuse the same definition
    in several places, you can create a type alias:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的类型变得更加复杂，或者当你想要在多个地方重用相同的定义时，你可以创建一个类型别名：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After defining types in this fashion, you can just use them anywhere, even
    in the definition of new types, as we did in `complexObject`, where we defined
    a field to be of the previously defined `simpleFlag` type:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方式中定义类型之后，你可以在任何地方使用它们，甚至在定义新类型时也可以，就像我们在`complexObject`中定义字段为之前定义的`simpleFlag`类型一样：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Type aliases can even be generic, as we'll see in the next section. You can
    also export types from a module, and import them for usage anywhere; we'll get
    to that in the *Working with libraries* section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名甚至可以是泛型的，我们将在下一节中看到。你还可以从一个模块中导出类型，并在任何地方导入它们进行使用；我们将在*使用库*部分讨论这个问题。
- en: Generic types
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: 'In functional programming, it''s quite usual to work with the `identity` function,
    which is defined as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，通常会使用`identity`函数，它的定义如下：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In combinatory logic, which we won't be going into, this corresponds with the
    I *combinator*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合逻辑中，这对应于I *combinator*。
- en: 'How would you write a type definition for this function? If the argument is
    a number, it will return a number; if it''s a string, it''ll return a string and
    so on. Writing all possible situations would be a chore and not very **Don''t
    Repeat Yourself** *(***DRY**). `Flow` provides a solution, with *generic types*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何为这个函数编写类型定义？如果参数是一个数字，它将返回一个数字；如果是一个字符串，它将返回一个字符串，依此类推。写出所有可能的情况将是一件苦差事，也不太符合**不要重复自己**（***DRY**）。`Flow`提供了一个解决方案，使用*泛型类型*：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, `T` stands for the generic type. Both the argument of the function
    and the result of the function itself are defined to be of `T` type, so `Flow`
    will know that whatever type the argument is, the result type will be the same.
    A similar syntax would be used for the more usual way of defining functions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`T`代表通用类型。函数的参数和函数本身的结果都被定义为`T`类型，因此`Flow`将知道参数的类型是什么，结果类型也将是相同的。对于更常见的定义函数的方式，将使用类似的语法：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Flow` also checks that you don''t accidentally restrict a generic type. In
    the following case, you would always be returning a number, while `T` might actually
    be any other different type:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow`还会检查您是否意外地限制了通用类型。在以下情况下，您将始终返回一个数字，而`T`实际上可能是任何其他不同的类型：'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You need not restrict yourself to a single generic type; the following nonsense
    example shows a case with two types:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必限制自己只使用单个通用类型；以下荒谬的例子显示了两种类型的情况：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It''s also possible to define a parametric type with a generic type that can
    later be specified. In the following example, the type definition for `pair` allows
    you to further create new types, each of which will always produce pairs of values
    of the same type:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用带有通用类型的参数化类型，稍后可以对其进行指定。在以下示例中，对于`pair`的类型定义允许您进一步创建新类型，每种类型将始终生成相同类型的值对：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are more ways you can use generic types; check [https://flow.org/en/docs/types/generics/](https://flow.org/en/docs/types/generics/) for
    a complete description of available possibilities.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用通用类型的更多方式；请查看[https://flow.org/en/docs/types/generics/](https://flow.org/en/docs/types/generics/)，了解可用可能性的完整描述。
- en: Opaque types for safer coding
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不透明类型用于更安全的编码
- en: 'In `Flow` (and TypeScript as well), types that are structurally the same are
    considered to be compatible and one can be used instead of the other. Let''s consider
    an example. In Uruguay, there is a national identification card with a DNI code:
    this is a string that''s formed by seven digits, a dash, and a check digit. You
    could have an application that lets you update people''s data:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Flow`（以及TypeScript）中，结构上相同的类型被认为是兼容的，可以使用其中一个来代替另一个。让我们考虑一个例子。在乌拉圭，有一张带有DNI代码的国民身份证：这是一个由七位数字、一个破折号和一个检查位组成的字符串。您可以有一个应用程序，让您更新人们的数据：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What could happen? If you don't define better types, there's nothing preventing
    you from doing a call such as `updateClient(229, "Kari Nordmann", "1234567-8")`;
    can you spot the switched values? Since both `dniType` and `nameType` are just
    bottom strings, even though they imply totally different concepts, `Flow` won't
    complain. `Flow` ensures that types are used correctly, but since it doesn't handle
    semantics, your code can still be obviously wrong.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 会发生什么？如果您没有定义更好的类型，那么您可能会执行诸如`updateClient(229, "Kari Nordmann", "1234567-8")`这样的调用；您能发现交换的值吗？由于`dniType`和`nameType`都只是底层字符串，即使它们暗示完全不同的概念，`Flow`也不会抱怨。`Flow`确保类型的正确使用，但由于它不处理语义，因此您的代码仍然可能显然错误。
- en: '*Opaque* types are different, since they obscure their internal implementation
    details from the outside, and have much stricter compatibility rules. You could
    have a file called `opaque_types.js` with the following definitions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不透明类型是不同的，因为它们从外部隐藏了内部实现细节，并且具有更严格的兼容性规则。您可以有一个名为`opaque_types.js`的文件，其中包含以下定义：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, in a different source file, we could attempt the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个源文件中，我们可以尝试以下操作：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'How can we fix this? Not even changing the definition of `newDni` would help:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？即使更改`newDni`的定义也无济于事：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Even after this change, `Flow` would still complain that a string isn''t a
    DNI. When we work with opaque types, if we want to do type conversions, we must
    provide them on our own. In our case, we should add such a function to our file
    with type definitions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在进行此更改后，`Flow`仍然会抱怨字符串不是DNI。当我们使用不透明类型时，如果我们想要进行类型转换，我们必须自己提供。在我们的情况下，我们应该在我们的类型定义文件中添加这样的函数：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can work! Let''s see the code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始工作了！让我们看看代码：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is still not optimal. We know that all DNI values are strings, so we should
    be able to use them as such, right? This isn''t the case:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不是最佳的。我们知道所有DNI值都是字符串，所以我们应该能够将它们用作字符串，对吧？事实并非如此：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `anotherDni` variable is of `dniType`, but as opaque types carry no information
    as to the real types, trying to use it as a `string` fails. You could, of course,
    write a `dniToString()` function, but that seems to be overkill—and would quickly
    get out of control in a system with potentially dozens of data types! We have
    a fallback: we can add a subtyping constraint, which will allow the opaque type
    to be used as a different type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`anotherDni`变量是`dniType`，但是由于不透明类型不包含有关真实类型的信息，因此尝试将其用作`string`会失败。当然，您可以编写一个`dniToString()`函数，但这似乎有些过度——在一个潜在包含数十种数据类型的系统中，这种方式很快就会失控！我们有一个备选方案：我们可以添加一个子类型约束，这将允许将不透明类型用作不同的类型：'
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means that `dniType` may be used as `string`, but not vice versa. Using
    opaque types will add safety to your code, since more errors will be caught, but
    you can also get a certain measure of flexibility through these constraints, which
    will make your life easier.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`dniType`可以用作`string`，但反之则不行。使用不透明类型将增加代码的安全性，因为将捕获更多的错误，但通过这些约束也可以获得一定程度的灵活性，这将使您的生活更轻松。
- en: Working with libraries
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用库
- en: Today, it's highly likely that any project you create will depend on third-party
    libraries, and it's very likely that those weren't written with `Flow`. By default,
    `Flow` will ignore these libraries and won't do any type checking. This means
    that any data type errors you might commit when using the library will be unrecognized,
    and you'll have to deal with them in the old-fashioned way, through testing and
    debugging—a throwback to worse times!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，您创建的任何项目都很可能依赖于第三方库，而且很可能这些库并不是用`Flow`编写的。默认情况下，`Flow`将忽略这些库，并且不会进行任何类型检查。这意味着您在使用库时可能会犯任何数据类型错误，这些错误将不会被识别，您将不得不通过测试和调试来处理它们——这是一个倒退到更糟糕时代的现象！
- en: To solve this problem, `Flow` lets you work with **library definitions** (**libdefs**)
    (see [https://flow.org/en/docs/libdefs/](https://flow.org/en/docs/libdefs/)) that
    describe the data types, interfaces, or classes for a library, separately from
    the library itself, like header files in C++ and other languages. Libdefs are `.js` files,
    but they are placed in a `flow-typed` directory at the root of your project.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，`Flow`让您使用**库定义**（**libdefs**）（请参阅[https://flow.org/en/docs/libdefs/](https://flow.org/en/docs/libdefs/)）来描述库的数据类型、接口或类，与库本身分开，就像C++和其他语言中的头文件一样。Libdefs是`.js`文件，但它们放在项目根目录下的`flow-typed`目录中。
- en: You can change this directory by editing the `.flowconfig` configuration file,
    but we won't meddle with it. If you are interested in effecting such a change,
    see the `[libs]` documentation at [https://flow.org/en/docs/config/](https://flow.org/en/docs/config/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过编辑`.flowconfig`配置文件来更改此目录，但我们不会干涉它。如果您有兴趣进行这样的更改，请参阅[https://flow.org/en/docs/config/](https://flow.org/en/docs/config)上的`[libs]`文档。
- en: There exists a repository of library definitions, `flow-typed`, in which you
    can find already made files for many popular libraries; see [https://github.com/flowtype/flow-typed](https://github.com/flowtype/flow-typed) for
    more information. However, you don't need to directly deal with that, because
    there is a tool that does the work for you, though at some times it will pass
    the buck back to you!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个库定义的存储库`flow-typed`，在其中您可以找到许多流行库的已经制作好的文件；有关更多信息，请参阅[https://github.com/flowtype/flow-typed](https://github.com/flowtype/flow-typed)。但您不需要直接处理它，因为有一个工具可以为您完成这项工作，尽管有时它会把责任推给您！
- en: The main objection against `Flow` these days, and a point for TypeScript, is
    that the list of supported libraries in terms of data type descriptions is far
    greater for the latter. There are some projects that attempt to make `Flow` work
    with TypeScript's descriptions, but so far this is still pending, though some
    good results have been shown.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天对`Flow`的主要反对意见，以及TypeScript的一个观点，是在数据类型描述方面，对于后者来说，支持的库列表要大得多。有一些项目试图使`Flow`与TypeScript的描述一起工作，但到目前为止，这仍然是悬而未决的，尽管已经显示了一些良好的结果。
- en: 'First, install the new tool:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装新工具：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, add a script in `package.json` to simplify the work:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`package.json`中添加一个脚本来简化工作：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using `npm run addTypes` will scan your project and attempt to add all possible
    libdefs. If it cannot find an appropriate definition for a library (this isn''t
    unusual, I''m sorry to say), it will create a basic definition using `any` everywhere.
    For instance, I added the `moment` library to the project:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm run addTypes`将扫描您的项目并尝试添加所有可能的libdefs。如果它找不到库的适当定义（很抱歉，这并不罕见），它将在所有地方使用`any`创建一个基本定义。例如，我将`moment`库添加到项目中：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After this, the `flow-typed` directory was added to the project root. In it,
    there a lot of files appeared, including `moment_v2.3.x.js` with the type definitions
    for the `moment` library. For libraries without a libdef, files were also created,
    but you may ignore them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`flow-typed`目录被添加到项目根目录。在其中，出现了许多文件，包括`moment_v2.3.x.js`，其中包含了`moment`库的类型定义。对于没有libdef的库，也创建了文件，但您可以忽略它们。
- en: If you need a libdef, and it doesn't exist, you may be able to create it by
    yourself. (And, please, contribute your work to the `flow-typed` project!) I added `npm
    install fetch --save`, but when I tried to get the libdef, it wasn't found. So,
    I can either keep working without the definitions (the standard situation!) or
    I can try to create the appropriate file; none is really an optimal situation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个libdef，但它不存在，您可能可以自己创建它。（并且，请将您的工作贡献给`flow-typed`项目！）我添加了`npm install
    fetch --save`，但当我尝试获取libdef时，它找不到。因此，我可以继续在没有定义的情况下工作（标准情况！），或者我可以尝试创建适当的文件；没有一个真正是最佳情况。
- en: I would suggest adding the `flow-typed` directory to `.gitignore` so that those
    files won't get uploaded to Git. Since it's standard practice to do `npm install` every
    time you pull from the repository, now you also have to use `npm run addTypes`—or,
    better yet, create a script that will do both commands!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议将`flow-typed`目录添加到`.gitignore`中，以便这些文件不会上传到Git。因为每次从存储库中拉取时都要执行`npm install`是标准做法，现在您还必须使用`npm
    run addTypes`——或者更好的是，创建一个将执行这两个命令的脚本！
- en: Working with strings
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字符串
- en: Strings have been a feature of JS since the very first version, but nowadays
    there are some more features available.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 自从第一个版本以来，字符串一直是JS的一个特性，但现在有一些更多的功能可用。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the following sections, we'll see many functions that we'll be using through
    the rest of this book, such as interpolation (to build up strings out of several
    parts) or tagged strings (which we'll use to style components in the *Creating
    StyledComponents for inline styling* section of [Chapter 7](c2de8e53-ee4c-414c-8c67-f908021652cc.xhtml),
    *Enhancing Your Application*), to show just two examples.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到许多函数，我们将在本书的其余部分中使用这些函数，例如插值（从几个部分构建字符串）或标记字符串（我们将在[第7章](c2de8e53-ee4c-414c-8c67-f908021652cc.xhtml)的*为内联样式创建StyledComponents*部分中使用它们来为组件设置样式），这只是两个例子。
- en: Interpolating in template strings
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板字符串中插值
- en: 'Everybody has, at one time or another, used common operators to build up a
    string, as in the following code fragment:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都曾经使用常见的运算符来构建字符串，就像下面的代码片段一样：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'JS has now added *template literals*, providing an easy way to include variable
    text and produce multiple line strings. String interpolation is quite simple,
    and the preceding code could be rewritten as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript现在已经添加了*模板文字*，提供了一种简单的方法来包含变量文本并生成多行字符串。字符串插值非常简单，前面的代码可以重写如下：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Template literals were earlier known as *template strings*, but current JS specifications
    don't use that expression any more. For more information, go to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 模板文字以前被称为*模板字符串*，但当前的JS规范不再使用该表达式。有关更多信息，请访问[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)。
- en: 'Template literals are delimited by back-tick characters (``...``). You use `${...}` wherever
    you want some value or expression to be substituted:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 模板文字由反引号字符（``...``）界定。您可以在任何需要替换值或表达式的地方使用`${...}`：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Of course, it''s easy to go overboard and start pushing too much logic when
    interpolating. I would recommend avoiding code such as the following for just
    that reason:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当插值时，当然很容易过度并开始推送太多逻辑。出于这个原因，我建议避免以下代码：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If `list` had been empty, `"Visiting no cities"` would have been produced instead.
    It''s far clearer if you push logic out of templates; even if the resulting code
    is somewhat larger, it will gain in clarity:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`list`为空，将生成`"访问没有城市"`。如果将逻辑推出模板，将会更清晰；即使生成的代码有点大，也会在清晰度上获得优势：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We'll fight the temptation to include logic in templates later, when we work
    in `React` (from [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml), *Developing
    with React*, to [Chapter 10](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml), *Testing
    your Application*) and see how we can render components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以后的模板中避免在`React`中包含逻辑，（从[第6章](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml)的*使用React开发*到[第10章](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml)的*测试您的应用程序*），并看看如何渲染组件。
- en: Tagged templates
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记模板
- en: 'A tagged template is a more advanced form of the templates we''ve been looking
    at. Basically, it''s another way to call a function, but with a syntax similar
    to a template string. Let''s look at an example and then explain it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 标记模板是模板的更高级形式，我们一直在看。基本上，这是另一种调用函数的方式，但语法类似于模板字符串。让我们看一个例子，然后解释一下：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `showAge()` function is called with the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`showAge()`函数被以下方式调用：'
- en: An array of strings, corresponding to each constant part of the template, so
    `strings[0]` is `The` and `strings[2]` is `.` in the first case, for example
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串数组，对应于模板的每个常量部分，因此在第一个案例中，`strings[0]`是`The`，`strings[2]`是`.`
- en: A parameter for each expression included; in our case, there's two of them
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个表达式都包含一个参数；在我们的例子中，有两个
- en: The function may do any calculations and return any type of value—possibly not
    a string! In our example, the function produces an *enhanced* version of the original
    string, adding how many years ago something happened—when a comic strip character
    was created or an automobile was bought, for example.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可以进行任何计算并返回任何类型的值——可能不是字符串！在我们的例子中，该函数生成原始字符串的*增强*版本，添加了多少年前发生的事情——例如，漫画角色被创建或购买汽车。
- en: We'll be using tagged templates in the *Creating StyledComponents for inline
    styling* section of [Chapter 7](c2de8e53-ee4c-414c-8c67-f908021652cc.xhtml), *Enhancing
    Your Application*; the styled-component library we'll use depends totally on this
    feature to allow for more readable code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](c2de8e53-ee4c-414c-8c67-f908021652cc.xhtml)的*为内联样式创建StyledComponents*部分中使用标记模板，*增强您的应用程序*；我们将使用的styled-component库完全依赖于此功能，以实现更可读的代码。
- en: Writing multiline strings
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写多行字符串
- en: 'Another feature of the new template literals is that they can span several
    lines. With earlier versions of JS, if you wanted to produce multiple lines of
    text, you had to insert newline characters (`"\n"`) in the output string, like
    so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 新模板文字的另一个特性是它们可以跨越多行。在JS的早期版本中，如果要生成多行文本，您必须在输出字符串中插入换行字符（`"\n"`），如下所示：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With template strings, you can just write the line as desired:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板字符串，您可以按照所需的方式编写该行：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, I would recommend against this practice. Even if the code may seem
    more legible, when it gets indented, the result looks ugly, since continuation
    lines *must* start at the first column—do you see why? Check out the following
    code—the continuation lines are pushed to the left, breaking the visual continuity
    of the indented code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我建议不要这样做。即使代码可能看起来更易读，但当它缩进时，结果看起来很丑陋，因为续行*必须*从第一列开始——您明白为什么吗？看看以下代码——续行被推到了左边，打破了缩进代码的视觉连续性：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can use a backslash to escape characters that are not meant to be part
    of templating:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用反斜杠来转义不应成为模板的一部分的字符：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You might want to look into `String.raw` (see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw))
    for an alternative to this way of avoiding templating. You can just avoid templating
    altogether, since an informal poll has shown that practically no developers know
    of it and it isn't such a great advantage after all.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想了解`String.raw`（请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw)）作为避免模板化的替代方法。您可以完全避免模板化，因为一项非正式调查显示，几乎没有开发人员知道它，而且它并不是一个很大的优势。
- en: Repeating strings
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复字符串
- en: Let's finish with several new string-related functions. Most are pretty simple
    to understand, so the explanations will mostly be brief. For a complete list of
    all available string functions, both old and new, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以几个新的与字符串相关的函数结束。大多数都很容易理解，因此解释大多数都会很简短。有关所有可用字符串函数的完整列表，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)。
- en: 'You can iterate any string using the `.repeat(...)` method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`.repeat(...)`方法迭代任何字符串：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Padding strings
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充字符串
- en: 'You can pad a string to a given length by adding repeated strings either at
    the left or at the right of the original text by using `.padStart(...)` and `.padEnd(...)`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`.padStart(...)`和`.padEnd(...)`在原始文本的左侧或右侧添加重复的字符串来将字符串填充到给定长度：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Among possible uses, you may pad a number with zeroes to the left. We have
    to transform the number into a string because the padding methods are only available
    for strings:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的用途中，您可以在数字左侧用零填充。我们必须将数字转换为字符串，因为填充方法仅适用于字符串：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The reason for using `padStart` and `padEnd` instead of `padLeft` and `padRight` has
    to do with left-to-right and right-to-left languages. It was felt that start and
    end were not ambiguous, while left and right would be. For example, in Hebrew,
    the start of a string is printed at the right and its end is to the left.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`padStart`和`padEnd`而不是`padLeft`和`padRight`的原因与从左到右和从右到左的语言有关。人们认为start和end不会产生歧义，而left和right会产生歧义。例如，在希伯来语中，字符串的开始在右侧打印，结束在左侧。
- en: Searching in strings
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在字符串中搜索
- en: 'There are new functions to determine whether a strings starts with, ends with,
    or includes a given string. This can give you much relief from using `indexOf(...)` and
    length-related calculations:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有新的功能可以确定字符串是否以给定字符串开头，结尾或包含。这可以让你摆脱使用`indexOf(...)`和与长度相关的计算：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each of these methods has a position as an optional second parameter, which
    specifies where to do the search; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith), [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith),
    and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) for
    more information.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都有一个位置作为可选的第二个参数，指定在哪里进行搜索；有关更多信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith)，[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)，和[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes)。
- en: Trimming strings
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修剪字符串
- en: 'You may trim a string at both ends, or only at one, by using `.trim(...)`, `.trimStart(...)`,
    and `.trimEnd(...)`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`.trim(...)`，`.trimStart(...)`和`.trimEnd(...)`在两端或一端修剪字符串：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Originally, `.trimStart()` was `.trimLeft()`, and `.trimEnd()` was `.trimRight()`,
    but the names were changed for the same reason as `.padStart()` and `.padEnd()` were.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`.trimStart()`是`.trimLeft()`，而`.trimEnd()`是`.trimRight()`，但名称已更改，原因与`.padStart()`和`.padEnd()`相同。
- en: Iterating over strings
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历字符串
- en: 'Strings are now iterable objects (such as arrays are), meaning that you can
    use `for...of` to iterate over them, character by character:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串现在是可迭代对象（例如数组），这意味着您可以使用`for...of`逐个字符地对它们进行迭代：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The spread operator (read about it in depth, in the *Spreading and joining
    values* section of this chapter) will also work, hence transforming a string into
    an array of single characters:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符（在本章的*扩展和连接值*部分深入了解）也可以工作，因此将字符串转换为单个字符的数组：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Enhancing your code
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强您的代码
- en: Now, let's go over several useful new functions of JS, which have to do with
    basic needs and features. This won't be exhaustive, since JS is quite big, after
    all! However, we will touch on the most interesting features that you will be
    likely to use.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看JS的几个有用的新功能，这些功能与基本需求和特性有关。这不会是详尽无遗的，毕竟JS很大！但是，我们将涉及您可能会使用的最有趣的功能。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The features in this section aren't linked by a common thread, apart from the
    fact that they will help you to write shorter, more concise code and help you
    to avoid possible common errors.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的功能没有共同的主题，除了它们将帮助您编写更短，更简洁的代码，并帮助您避免可能的常见错误。
- en: Working in strict mode
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在严格模式下工作
- en: 'Let''s start with a change that you probably won''t need! JS was somewhat cavalier
    as to some errors and, instead of warning or crashing, it would just silently
    ignore them. In 2015, a new *strict* mode was included, which changed the JS engine''s
    behavior to start reporting these errors. To enable the new mode, you had to include
    a single line before anything else, with a simple string:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个您可能不需要的更改开始！JS对某些错误有些漫不经心，而不是警告或崩溃，它只是悄悄地忽略它们。2015年，新增了一个*严格*模式，改变了JS引擎的行为，开始报告这些错误。要启用新模式，您必须在任何其他内容之前包含一行简单的字符串：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Including this string would enforce strict mode for your code. What errors
    were caught? A brief list includes the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 包含此字符串将强制执行代码的严格模式。捕获了哪些错误？简要列表包括以下内容：
- en: You cannot create a global variable by accident. If you misspelled a variable's
    name in a function, JS would have created a new global variable and just moved
    on; in strict mode, an error is produced.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能意外创建全局变量。如果您在函数中拼错了变量的名称，JS会创建一个新的全局变量并继续进行；在严格模式下，会产生一个错误。
- en: You cannot use `eval()` to create variables.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能使用`eval()`来创建变量。
- en: You cannot have function parameters with duplicate names, as in `function doIt(a,
    b, a, c)`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能有重复名称的函数参数，例如`function doIt(a, b, a, c)`。
- en: You cannot delete non-writable object properties; for example, you cannot delete
    `someObject.prototype`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能删除不可写对象属性；例如，您不能删除`someObject.prototype`。
- en: You cannot write to some variables; for instance, you cannot do `undefined=22` or
    `NaN=9`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能写入某些变量；例如，您不能执行`undefined=22`或`NaN=9`。
- en: The `with` statement is forbidden.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`语句是被禁止的。'
- en: Some words (such as `interface` or `private`, for example) were reserved for
    keywords in future versions of JS.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些单词（例如`interface`或`private`）被保留为JS未来版本的关键字。
- en: The previous list isn't complete and there're a few more changes and restrictions.
    For full details, read [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的列表并不完整，还有一些更改和限制。有关完整详情，请阅读[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。
- en: Should you use this? For your main script, `"use strict"` is optional, but for
    modules and classes, it's implied. So, most code will always run in strict mode,
    so you'd really get used to including that string. That said, if you are using
    `Babel`, the required string is already provided for you by the transpiler. On
    the other hand, Node's modules will require it, as we'll see in the next chapter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用这个吗？对于你的主脚本，`"use strict"`是可选的，但对于模块和类，它是隐含的。因此，大多数代码将始终在严格模式下运行，所以你真的会习惯包含那个字符串。也就是说，如果你使用`Babel`，转译器已经为你提供了所需的字符串。另一方面，Node的模块将需要它，我们将在下一章中看到。
- en: Scoping variables
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量作用域
- en: 'The concept of *scope* is associated with the idea of *visibility*: scope is
    the context in which defined elements (such as variables or functions) can be
    referenced or used. Clasically, JS provided only two types of scope: *global*
    scope (accessible everywhere) and *function* scope (accessible only within the
    function itself). Since scopes have been around since the beginning of JS, let''s
    just remember a couple of rules, with not much elaboration:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*作用域*的概念与*可见性*的概念相关联：作用域是定义元素（如变量或函数）可以被引用或使用的上下文。经典上，JS只提供了两种类型的作用域：*全局*作用域（可在任何地方访问）和*函数*作用域（只能在函数内部访问）。由于作用域从JS开始就存在，让我们只记住一些规则，不做太多阐述：'
- en: Scopes are hierarchically arranged, and *child* scopes can access everything
    in the *parent* scope, but not the other way round.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域是按层次排列的，*子*作用域可以访问*父*作用域中的所有内容，但反之则不行。
- en: Access to the *parent* scope will be disabled if you redefine something at an
    inner scope. References will always be to the child definition, and you cannot
    access the equally named element in the outer, encompassing scope.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在内部作用域重新定义了某个东西，那么对*父*作用域的访问将被禁用。引用将始终指向子定义，你无法访问外部包围作用域中同名的元素。
- en: 'JS5 introduced a new type of scope, called *block* scope, that lets you work
    in a more careful way. This allows you to create variables for a single block,
    without existence outside of it, even in the rest of the function or method where
    they were defined. With this concept, two new ways of defining variables, other
    than using `var`, were added: `let` and `const`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: JS5引入了一种新类型的作用域，称为*块*作用域，它让你以更谨慎的方式工作。这允许你为单个块创建变量，而这些变量在块之外甚至在定义它们的函数或方法的其余部分中都不存在。有了这个概念，除了使用`var`之外，还添加了两种定义变量的新方法：`let`和`const`。
- en: The new declarations are not subject to *hoisting*, so if you are not used to
    declaring all variables at the top of your code before they are used, you may
    have problems. Since the usual practice is starting functions with all declarations,
    this isn't likely to affect you. See [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
    for more details.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 新的声明不受*提升*的影响，所以如果你不习惯在使用之前在代码顶部声明所有变量，可能会遇到问题。由于通常的做法是在函数开始时进行所有声明，这不太可能影响你。更多细节请参阅[https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)。
- en: 'The first option, `let`, allows you to declare a variable that will be limited
    to the block or statement where it is used. The second option, `const`, adds the
    proviso that the variable isn''t supposed to change value, but rather be constant;
    if you try to assign a new value to a constant, an error will be produced. The
    following simple examples show the new behaviors:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项`let`允许你声明一个变量，该变量将被限制在使用它的块或语句中。第二个选项`const`添加了这样一个规定，即变量不应该改变值，而应该是常量；如果你尝试给常量赋新值，将会产生错误。以下简单示例展示了新的行为：
- en: Using `const` for a constant value needs little explanation, but what about `let`?
    The reason harkens back to the origin of the `BASIC` programming language. In
    that language, you assigned values to variables with code like `37 LET X1 = (B1*A4
    - B2*A2) / D`; this particular line was taken from Darmouth College's `BASIC`
    manual facsimile, dated October 1964\. See [http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf](http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf) for
    more information.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`来表示常量值需要很少的解释，但是`let`呢？原因可以追溯到`BASIC`编程语言的起源。在那种语言中，你可以使用类似`37 LET
    X1 = (B1*A4 - B2*A2) / D`的代码为变量赋值；这行代码来自达特茅斯学院1964年10月的`BASIC`手册复印件。更多信息请参阅[http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf](http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf)。
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Using `let` also solves a classic problem. What would the following code do? Here
    it is:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`也解决了一个经典问题。以下代码会做什么？在这里：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you were expecting a countdown to zero (`10... 9... 8...` down to `2...
    1... 0!`) with suitable one second delays, you''ll be surprised, because this
    code emits `-1`! eleven times! The problem has to do with closures; by the time
    the loop ends, the `i` variable is `-1`, so when the waiting (timeout) functions
    run, `i` has *that* value. This can be solved in several ways, but using `let`
    instead of `var` is the simplest solution; each closure will capture a different
    copy of the loop variable, and the countdown will be correct:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望一个倒计时从十到零（`10... 9... 8...`一直到`2... 1... 0!`）并且每秒递减一次，你会感到惊讶，因为这段代码会输出`-1`！十一次！这个问题与闭包有关；当循环结束时，`i`变量已经是`-1`，所以当等待（超时）函数运行时，`i`就有了*那个*值。这可以通过几种方式解决，但是使用`let`而不是`var`是最简单的解决方案；每个闭包将捕获循环变量的不同副本，倒计时将是正确的：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For more on blocks and `let`/`const`, check out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block), [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)
    and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)
    at MDN.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有关块和`let`/`const`的更多信息，请查看[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block)，[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)和[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)在MDN上。
- en: Spreading and joining values
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展和连接值
- en: 'A new operator, `...`, lets you expand an array, string, or object, into independent
    values. This is harder to explain than to show, so let''s see some basic examples:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的运算符，`...`，允许你将数组、字符串或对象展开为独立的值。这比解释更难，所以让我们看一些基本的例子：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can also use it to copy arrays or concatenate them:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以用它来复制数组或连接它们：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you apply the spread operator to a string, the effect is to separate it into
    individual characters, much as if you had used `.split()`; for instance, `console.log(..."JS")`
    shows `["J", "S"]`, so this case isn't particularly interesting.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将扩展运算符应用到一个字符串，效果就是将它分隔成单独的字符，就像你使用了`.split()`一样；例如，`console.log(..."JS")`显示`["J",
    "S"]`，所以这种情况并不特别有趣。
- en: 'You can also use it to clone or modify objects; in fact, this is a usage we''re
    going to meet again later, in [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml),
    *Expanding Your Application*, mostly when we use `Redux`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以用它来克隆或修改对象；事实上，这是我们稍后要遇到的用法，主要是在[第8章](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml)，*扩展你的应用*中，当我们使用`Redux`时：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is also useful for writing functions with an undefined number of arguments,
    avoiding the old style usage of the `arguments` pseudo-array. Here, instead of
    splitting an element into many, it joins several distinct elements into a single
    array. Note, however, that this usage only applies to the last arguments of a
    function; something such as `function many(a, ...several, b, c)` wouldn''t be
    allowed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于编写具有未定义数量参数的函数也很有用，避免了`arguments`伪数组的旧式用法。在这里，它不是将一个元素拆分成多个，而是将几个不同的元素合并成一个数组。然而，请注意，这种用法仅适用于函数的最后一个参数；像`function
    many(a, ...several, b, c)`这样的东西是不允许的：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you are wondering why I called `arguments` a pseudo-array, the reason is
    because it *looks* somewhat like an array, but only provides the `.length` property;
    see more at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments).
    In any case, you won't be dealing with it, thanks to the spread operator.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我称`arguments`为伪数组，原因是因为它*看起来*有点像一个数组，但只提供`.length`属性；更多信息请参见[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)。无论如何，由于扩展运算符，你不会与它打交道。
- en: Destructuring arrays and objects
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构数组和对象
- en: 'Another powerful construct provided by JS nowadays is the destructuring assignment.
    This is also harder to explain than to show, so once again let''s directly get
    to some examples! The simplest case lets you split an array into variables:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: JS现在提供的另一个强大的构造是解构赋值。这也比解释更难，所以让我们直接看一些例子！最简单的情况可以让你将数组拆分为变量：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'More interesting still is that you can swap or twiddle variables around! Following
    on from the preceding example, we''d have the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，你可以交换或调整变量！继续前面的例子，我们会得到以下结果：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can also assign default values to missing variables, ignore values you
    don''t care for, and even apply the `rest` operator:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为缺失的变量分配默认值，忽略你不关心的值，甚至应用`rest`运算符：
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This can also be applied to objects, letting you pick attributes and even renaming
    them, as with the flag and name in the following code. Assigning values by default
    is also possible:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以应用于对象，让你选择属性，甚至重命名它们，就像下面代码中的flag和name一样。默认情况下分配值也是可能的：
- en: '[PRE59]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'One interesting usage of this is allowing a function to return many values
    at once. If you want to return, say, two values, you can either return an array
    or an object and use destructuring to separate the returned values in a single
    sentence:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个有趣的用法是允许函数一次返回多个值。如果你想返回两个值，你可以返回一个数组或一个对象，并使用解构将返回的值分开成一个句子：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Alternatively, you can use an object and an arrow function just for variety;
    note the extra parentheses we used, since we are returning an object. We are also
    renaming attributes, by the way:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用一个对象和箭头函数来增加变化；注意我们使用的额外括号，因为我们正在返回一个对象。顺便说一下，我们也重命名了属性：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can find many examples of spreading and destructuring in MDN if you visit
    the following links:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问以下链接，你可以在MDN上找到许多关于扩展和解构的例子：
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)'
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)'
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)'
- en: Doing powers
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行幂运算
- en: 'Finally, let''s introduce a newly added operator, `**`, which stands for power
    calculations:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们介绍一个新添加的运算符`**`，表示幂运算：
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This is just a shortcut for the existing `Math.pow()` function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是现有的`Math.pow()`函数的快捷方式：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'An exponential assignment operator also exists, which is similar to `+=`, `-=`,
    and the rest:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在一个指数赋值运算符，类似于`+=`，`-=`等等：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is an operator that you won''t probably using very often, unless you deal
    with interest calculations and financial formulas. A final reminder: just as in
    math, the exponentiation operator groups from right to left, so `2 ** 3 ** 4`
    is calculated as `2 ** (3 ** 4)`; be careful!'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你可能不经常使用的运算符，除非你处理利息计算和金融公式。最后提醒一下：就像数学中的指数运算符从右到左分组一样，所以`2 ** 3 ** 4`计算为`2
    ** (3 ** 4)`；小心！
- en: Defining functions
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数
- en: JS isn't a functional programming language by definition, but it includes practically
    everything that a full-fledged functional language would provide. In our case,
    we won't be delving too deeply into this programming paradigm, but let's see some
    important features that will simplify your work.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: JS并不是一个函数式编程语言，但它包含几乎所有一个完整的函数式语言所提供的东西。在我们的情况下，我们不会深入探讨这种编程范式，但让我们看看一些将简化你工作的重要特性。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: JS has always included functions, which can be defined in many ways, but now
    there is yet one more function definition style that will provide several advantages;
    read on.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: JS一直包括函数，可以以许多方式定义，但现在又有一种函数定义样式，将提供几个优势；继续阅读。
- en: Writing arrow functions
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写箭头函数
- en: 'After reading the preceding paragraph, did you try to count how many ways there
    are to define a function in JS? There are actually far more than you probably
    think, including at least the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读前面的段落后，你是否尝试计算JS中有多少种方式可以定义函数？实际上有比你想象的更多，至少包括以下几种：
- en: '*A named function declaration*: `function one(...) {...}`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个命名函数声明*：`function one(...) {...}`'
- en: '*An anonymous function expression*: `var two = function(...) {...}`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个匿名函数表达式*：`var two = function(...) {...}`'
- en: '*A named function expression*: `var three = function someName(...) {...}`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个命名函数表达式*：`var three = function someName(...) {...}`'
- en: '*An immediately-invoked expression*: `var four = (function() { ...; return
    function(...) {...}; })()`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*立即调用的表达式*：`var four = (function() { ...; return function(...) {...}; })()`'
- en: '*A function constructor*: `var five = new Function(...)`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数构造函数*：`var five = new Function(...)`'
- en: '*The new style, an arrow function*: `var six = (...) => {...}`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*新样式，箭头函数*：`var six = (...) => {...}`'
- en: 'You are probably quite used to the first trio, while the two that follow may
    be not so common. However, what we now care about is the last style, called an
    *arrow function*. Arrow functions work pretty much in the same fashion as functions
    defined in the other ways, but there are three key differences:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经习惯了前面的三种方式，而后面的两种可能不太常见。然而，我们现在关心的是最后一种样式，称为*箭头函数*。箭头函数的工作方式与其他方式定义的函数基本相同，但有三个关键区别：
- en: Arrow functions do not have an `arguments` object
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数没有`arguments`对象
- en: Arrow functions may implicitly return a value, even if no `return` statement
    is provided
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数可能会隐式返回一个值，即使没有提供`return`语句
- en: Arrow functions do not bind the value of `this`
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数不绑定`this`的值
- en: In fact, there are some more differences, including the fact that you cannot
    use arrow functions as constructors, they don't have a prototype property, and
    they cannot be used as generators. For more on this, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有一些更多的区别，包括不能将箭头函数用作构造函数，它们没有原型属性，也不能用作生成器。有关更多信息，请参见[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)。
- en: The first difference is handled simply by using the spread operator, as we saw
    earlier in this chapter. So, let's focus on the last two items, which are more
    interesting, instead.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别可以简单地通过使用展开运算符来处理，就像我们在本章前面看到的那样。因此，让我们专注于最后两项，这两项更有趣。
- en: Returning values
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: 'An arrow function may have a block of code with some return statements in it
    or it may just be an expression. The former case is most similar to the standard
    way of defining a function; for example, we could write a function to add three
    numbers as follows, using both styles. We should add data types to the definitions,
    but we''ll get to that soon:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数可以有一段代码，其中包含一些返回语句，或者它可能只是一个表达式。前一种情况最类似于定义函数的标准方式；例如，我们可以编写一个函数来添加三个数字，如下所示，使用两种样式。我们应该在定义中添加数据类型，但我们很快就会解决这个问题：
- en: '[PRE65]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you can do this just by returning an expression, you can then write an equivalent
    version; just write whatever you want to return immediately after the arrow:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以通过返回一个表达式来做到这一点，那么你可以写一个等效的版本；只需在箭头后面立即写出你想要返回的内容：
- en: '[PRE66]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'There''s a special case: if you are returning an object, then you must place
    it within parentheses because otherwise JS will confuse it with a block of code.
    For `Redux` (which we''ll be seeing in the *Managing State with Redux* section
    of [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml), *Expanding Your Application*),
    you might want to write an *action creator* that returns an *action, *namely an
    object with a `type` attribute and possibly some more:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊情况：如果你要返回一个对象，那么你必须将它放在括号中，否则JS会将其与一段代码块混淆。对于`Redux`（我们将在[第8章](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml)的*使用Redux管理状态*部分中看到），你可能想编写一个返回*action*的*action
    creator*，即一个带有`type`属性和可能更多属性的对象：
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'What''s happening here? JS is interpreting the braces as a block, and then
    `type` and `data` are considered to be *labels* (see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)
    if you don''t remember these!), so the whole *object* is really a block that just
    doesn''t return anything, and JS returns an `undefined` result. Just placing the
    object in parentheses will work as expected:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？JS将大括号解释为一个块，然后`type`和`data`被视为*标签*（如果您不记得，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)！），因此整个*对象*实际上是一个不返回任何内容的块，JS返回一个`undefined`结果。将对象放在括号中将按预期工作：
- en: '[PRE68]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Handling this in arrow functions
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在箭头函数中处理this
- en: 'A well-known JS problem is how to handle `this`, because its value isn''t always
    what you expect! Modern JS solves this with arrow functions that, unlike common
    functions, inherit the proper `this` value. A well-known example is as follows:
    you would expect the following code to display `JAVASCRIPT` after a few seconds,
    but rather `undefined` will be shown (don''t mind the fact that you could have
    coded `show()` in a simpler way; I wanted to highlight a general problem and not
    a particular solution):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一个众所周知的JS问题是如何处理`this`，因为它的值并不总是你期望的！现代JS通过箭头函数解决了这个问题，与普通函数不同，箭头函数继承了正确的`this`值。一个众所周知的例子如下：您期望以下代码在几秒钟后显示`JAVASCRIPT`，但实际上会显示`undefined`（不要在意您可以以更简单的方式编写`show()`；我想强调的是一个一般性问题而不是一个特定的解决方案）：
- en: '[PRE69]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'There are three ways of solving this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有三种方法：
- en: Using `.bind()` to properly bind the timeout function to the correct value of
    `this`
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.bind()`来正确绑定超时函数到`this`的正确值
- en: Using a closure and defining a local variable (usually called `that`) to store
    and save the original value of `this`
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闭包和定义一个本地变量（通常称为`that`）来存储和保存`this`的原始值
- en: Using arrow functions, which will work without any extra work
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用箭头函数，无需额外工作即可工作
- en: 'We can see these three solutions in the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码中看到这三种解决方案：
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We will get to see the `.bind()` idea in React in the *Defining Components* section
    of [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml), *Developing with React,*
    where we will deal with `this` related problems.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml)的*使用React开发*中看到在React中定义组件的`.bind()`思想，我们将处理与`this`相关的问题。
- en: Defining types for arrow functions
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为箭头函数定义类型
- en: 'Finally, let''s see how types would be defined for arrow functions. We can
    have a couple more implementations of the `toString()` function we saw earlier
    in the *Basic types in Flow* section:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何为箭头函数定义类型。我们可以在*Flow中的基本类型*部分中看到的`toString()`函数的另外几个实现：
- en: '[PRE71]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Defining default argument values
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义默认参数值
- en: 'An interesting new feature for functions is the possibility of defining default
    values for missing arguments. We could write a function to calculate *n^(th)* roots
    that, by default, would calculate square roots:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的一个有趣的新特性是定义缺失参数的默认值的可能性。我们可以编写一个函数来计算*n*次方根，默认情况下会计算平方根：
- en: '[PRE72]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As seen in the third example, passing `undefined` is equivalent to omitting
    the value. This means that you can provide default values for any parameter: a
    call such as `someFunction(undefined, 22, undefined)` would use default values
    for the first and third arguments, and 22 as the second one.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如第三个示例所示，传递`undefined`等同于省略该值。这意味着您可以为任何参数提供默认值：例如`someFunction(undefined, 22,
    undefined)`的调用将使用第一个和第三个参数的默认值，第二个参数为22。
- en: 'Default values can also be used for methods and constructors. In the following
    `Counter` class, the `inc()` method, if not provided with a number, will increment
    the counter by `1`. Also, when constructing the counter, if you don''t provide
    an initial value, zero will be used:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值也可以用于方法和构造函数。在以下`Counter`类中，如果未提供数字，`inc()`方法将使计数器递增`1`。此外，当构造计数器时，如果您没有提供初始值，将使用零：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'As a last detail, you can use values from previous arguments to calculate the
    default values of later ones. A simple nonsense example shows this; I''ll skip
    type declarations since they are not relevant here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个细节，您可以使用先前参数的值来计算后面参数的默认值。一个简单的无意义的例子显示了这一点；我会跳过类型声明，因为它们在这里并不重要：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Using default values is a very practical way to simplify the usage of functions,
    particularly in the case of complex APIs with many parameters, but allowing sensible
    values for whatever the user omits.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认值是简化函数使用的一种非常实用的方式，特别是在具有许多参数的复杂API的情况下，但允许用户省略任何合理值。
- en: Programming functionally
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Functional programming is often more declarative than imperative, with higher
    level functions that can do complete processing in a simpler, straightforward
    way. Here, let's look at several functional programming techniques that you should
    really adopt for your own code.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程通常比命令式更具声明性，具有更高级的函数，可以以更简单，直接的方式完成完整的处理。在这里，让我们看看您应该真正采用的几种函数式编程技术。
- en: How to do it...
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Functional programming has always been present in JS, but recent versions of
    the language have added well-known features of other languages that you can use
    to shorten your code, also making it simpler to understand.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程一直存在于JS中，但语言的最新版本已经添加了其他语言的众所周知的特性，您可以使用这些特性来缩短代码，使其更容易理解。
- en: Reducing arrays to values
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数组减少为值
- en: 'A simple question: how many times have you looped through an array to, say,
    add its numbers? The odds are, many times! This kind of operation —going through
    an array element by element performing some calculation to arrive at a final result—is
    the first one we will be implementing in a functional way, with `.reduce()`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的问题：您有多少次循环遍历数组，例如，添加它的数字？很可能有很多次！这种操作——逐个遍历数组元素执行一些计算以得出最终结果——是我们将以函数方式实现的第一个操作，使用`.reduce()`。
- en: 'The name `.reduce()` pretty much tells us what it does: it *reduces* a complete
    array to a single value. In other languages, this operation is called *fold*.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`.reduce()`基本上告诉我们它的作用：将完整的数组*减少*为一个单一的值。在其他语言中，这个操作被称为*fold*。
- en: 'The most usual example, which most texts and articles show, is summing all
    of the elements of an array, and, since I''m traditionally minded, let''s do just
    that! You must provide an initial value for your calculation (in this case, since
    we want a sum, it would be a zero) and a function that will update the calculated
    value when accessing each array element:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的例子，大多数文本和文章都展示了，是对数组的所有元素求和，而且由于我传统，让我们就这样做吧！您必须为您的计算提供一个初始值（在本例中，因为我们想要一个总和，所以它将是零），以及一个在访问每个数组元素时将更新计算值的函数：
- en: '[PRE75]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'How does it work? Internally, `.reduce()` starts by taking your initial value
    (zero, in this case) and then it calls the reducing function, giving it the accumulated
    total (`acc`) and the first element of the array (`val`). The function must update
    the accumulated total: in this case, it would calculate *0* + *22*, so the next
    total would be `*22*`. After, `.reduce()` would call the function again, passing
    it 22 (the updated total) and `9` (the second array element), and `31` would become
    the new accumulated total. This will proceed systematically through the complete
    array, until the final value (`163`) is computed. Note that all aspects of loop
    control are automatic, so there is no way you can err somewhere, and the code
    is quite declarative: you could almost read it as "reduce `someArray` to a value
    by summing all elements, starting with zero".'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？在内部，`.reduce()`首先采用您的初始值（在本例中为零），然后调用减少函数，给它累积总数（`acc`）和数组的第一个元素（`val`）。函数必须更新累积总数：在这种情况下，它将计算*0*
    + *22*，所以下一个总数将是`*22*`。之后，`.reduce()`会再次调用该函数，传递22（更新后的总数）和`9`（第二个数组元素），`31`将成为新的累积总数。这将系统地进行整个数组，直到计算出最终值（`163`）。请注意，循环控制的所有方面都是自动的，因此您不可能在某个地方出错，而且代码相当声明性：您几乎可以将其阅读为"通过对所有元素求和，从零开始，将`someArray`减少为一个值"。
- en: 'There are some more possibilities for `.reduce()`: check out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) for
    more information. You can also use `.reduceRight()`, which essentially works in
    the same fashion, but starting at the end of the array and proceeding backwards;
    see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight) for
    more information.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`.reduce()`还有一些更多的可能性：查看[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)获取更多信息。您还可以使用`.reduceRight()`，它基本上以相同的方式工作，但是从数组的末尾开始并向后进行；请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight)获取更多信息。'
- en: 'Of course, you are not limited to processing arrays of numbers; you can deal
    with any data type, and the final result can also be any type. For example, you
    could use `.reduce()` to turn an array of names into an HTML bulleted list, as
    follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不仅限于处理数字数组；您可以处理任何数据类型，并且最终结果也可以是任何类型。例如，您可以使用`.reduce()`将一个名字数组转换为HTML项目符号列表，如下所示：
- en: '[PRE76]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: With a little practice, it's safe to say that you'll probably be able to transform
    any kind of calculation over an array into a `.reduce()` call with shorter, clearer
    code.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 稍加练习，可以肯定地说，您可能能够将数组上的任何类型的计算转换为一个`.reduce()`调用，从而获得更短、更清晰的代码。
- en: Mapping arrays
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射数组
- en: 'A second type of very common operation is to go through an array and produce
    a new array by doing some kind of process to each element. Fortunately, we also
    have a way to do that functionally by using `.map()`. The way this function works
    is simple: given an array and a function, it applies the function to each element
    of the array and produces a new array with the results of each call.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种非常常见的操作是遍历数组，并通过对每个元素进行某种处理来生成一个新数组。幸运的是，我们也有一种函数式的方法来实现这个功能，即使用`.map()`。这个函数的工作方式很简单：给定一个数组和一个函数，它将该函数应用于数组的每个元素，并生成一个包含每次调用结果的新数组。
- en: 'Suppose we called a web service and got back an array with people data. We
    just wanted their ages so that we are able to do some other process; say, calculate
    the average age of the people who used the service. We can manage this simply:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们调用了一个Web服务，并得到了一个包含人员数据的数组。我们只想要他们的年龄，以便我们能够进行其他处理；比如，计算使用该服务的人员的平均年龄。我们可以简单地处理这个问题：
- en: '[PRE77]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Using `.map()` is, like `.reduce()`, a much shorter and safer way to process
    an array. In fact, most times, the two operations are used one after the other,
    with some possible `.filter()` operations mixed in to select what should or should
    not be processed; let's get into that now.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.map()`就像`.reduce()`一样，是处理数组的一种更短、更安全的方式。事实上，大多数情况下，这两种操作是连续使用的，中间可能混合一些`.filter()`操作来选择应该或不应该被处理的内容；让我们现在来看看这个。
- en: The `.map()` operation also has some extra features; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
    for a complete description. Also, if you really want to affect the original array,
    rather than producing a new one, take a look at the `.forEach()` method at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()`操作还有一些额外的特性；请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)获取完整的描述。此外，如果您真的想影响原始数组，而不是生成一个新数组，请查看[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)中的`.forEach()`方法。'
- en: Filtering arrays
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤数组
- en: 'The third operation we are considering is `.filter()`, which will scan a complete
    array and generate a new one, but only with the elements that satisfy some condition,
    as given by you via a function. Following our example, we could pick only the
    males in the service result by writing the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在考虑的第三个操作是`.filter()`，它将扫描整个数组并生成一个新数组，但只包含满足某些条件的元素，这些条件是由您通过函数给出的。根据我们的例子，我们可以通过编写以下内容来从服务结果中选择只有男性：
- en: '[PRE78]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Having these three operations makes it simple to do sequences of calls and
    generate results with little code. For example, could we find out the age of the
    eldest of the males in the family? Yes, quickly—with just a few lines of code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这三个操作，就可以轻松地进行调用序列并生成少量代码的结果。例如，我们可以找出家庭中年龄最大的男性吗？是的，只需几行代码就可以：
- en: '[PRE79]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This style of chained operations is quite common: in this case, we first select
    the males, then we pick their ages, and then we reduce the array to a single value,
    the maximum: neat!'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这种链式操作的风格非常常见：在这种情况下，我们首先选择男性，然后选择他们的年龄，然后将数组减少到一个单一值，即最大值：简洁！
- en: Producing functions from functions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从函数生成函数
- en: 'Let''s finish this section on functional aspects by looking at a quintessential
    functional programming tool: **Higher Order Functions** (**HOFs**): functions
    that produce functions as results! In later chapters, we''ll actually meet more
    usages of HOFs; here, let''s work out a simple example.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一个典型的函数式编程工具来完成本节的功能方面：**高阶函数**（**HOFs**）：生成函数作为结果的函数！在后面的章节中，我们将实际上遇到更多HOF的用法；在这里，让我们解决一个简单的例子。
- en: The following example is taken from my previous book for Packt, *Mastering JavaScript
    Functional Programming*. Chapter 2, *Thinking Functionally - A First Example*,
    and Chapter 6, *Producing Functions - Higher-Order Functions* will be of particular
    interest with regard to HOFs. See more at [www.packtpub.com/web-development/mastering-javascript-functional-programming](https://www.packtpub.com/web-development/mastering-javascript-functional-programming).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例摘自我之前为Packt撰写的书籍《精通JavaScript函数式编程》。第2章，*函数式思维-第一个例子*，第6章，*生成函数-高阶函数*将特别涉及到HOFs。更多信息请参见[www.packtpub.com/web-development/mastering-javascript-functional-programming](https://www.packtpub.com/web-development/mastering-javascript-functional-programming)。
- en: 'Suppose you have developed an e-commerce site. The user selects products, adds
    them to his/her shopping cart, and at the end clicks on a BILL ME button so that
    his/her credit card will be charged. However, if the user were to click twice
    or more, he/she would be billed several times rather than once. Your application
    might have something along these lines in its HTML:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您开发了一个电子商务网站。用户选择产品，将它们添加到购物车中，最后点击“BILL ME”按钮，以便对其信用卡进行扣款。但是，如果用户点击两次或更多次，他/她将被多次而不是一次计费。您的应用程序可能在其HTML中有以下内容：
- en: '[PRE80]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Somewhere among your scripts, there would be some code like the following.
    I''m not including data type declarations because they are not relevant to our
    code; we don''t really know or care what the arguments to `billUser()` would be:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的脚本中的某个地方，会有以下类似的代码。我没有包含数据类型声明，因为它们与我们的代码无关；我们实际上并不知道或关心`billUser()`的参数是什么：
- en: '[PRE81]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, what could you do in order to avoid repeated clicks on the button? There
    are several not-quite-so-good solutions, such as the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了避免重复点击按钮，您可以采取什么措施？有几种不太好的解决方案，例如以下：
- en: Do nothing, just warn the user, and hope they pay attention!
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么都不做，只是警告用户，并希望他们注意！
- en: Use a global flag to signal the fact that the user clicked once.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局标志来表示用户点击一次的事实。
- en: Remove the `onclick` handler from the button after the user clicks.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户点击后，从按钮中删除`onclick`处理程序。
- en: Change the `onclick` handler to something else that won't bill the user.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`onclick`处理程序更改为其他不会向用户收费的内容。
- en: 'However, all of these solutions are somewhat lacking, depend on global objects,
    need you to mess with the billing function, are tightly linked with the user view,
    and so on. Since requiring that some functions are executed only once isn''t such
    an outlandish requirement, let''s specify the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些解决方案都有些不足，依赖于全局对象，需要您干预计费功能，与用户视图紧密相关等。由于要求某些函数仅执行一次并不是一个奇特的要求，让我们指定以下内容：
- en: The original function should be unchanged and do its thing—nothing more
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始函数应保持不变并执行其功能-仅此而已
- en: We want a new function that will call the original one, but only once
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望有一个新函数，它将调用原始函数，但只调用一次
- en: We want a general solution so that we can apply it in different situations
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望有一个通用的解决方案，这样我们就可以在不同的情况下应用它
- en: 'We will write a function, `once()`, that will take a function as its argument
    and produce a new function, but that will *do its thing* only once. The logic
    is not long, but study it carefully:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为`once()`的函数，它将以一个函数作为参数并生成一个新函数，但是只会执行一次。逻辑并不复杂，但请仔细研究：
- en: '[PRE82]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Some analysis of our new function is as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新函数的一些分析如下：
- en: The definition shows that `once()` takes a generic function (`fn()`) as an argument
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义显示`once()`将一个通用函数(`fn()`)作为参数
- en: The `return` statement shows that `once()` returns another function
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`语句表明`once()`返回另一个函数'
- en: We are using the spread operator to deal with functions with any number of arguments
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用展开运算符来处理具有任意数量参数的函数
- en: We are using a closure for the `done` variable, which remembers whether `fn()`
    was invoked or not
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用闭包来处理`done`变量，它会记住`fn()`是否被调用
- en: 'I left out type definitions for clarity, but in the source code provided with
    this book, full definitions are provided. Can you work them out on your own? A
    tip: the output of the `once()` function should be the same type as the input
    to it.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我省略了类型定义，但在本书提供的源代码中，提供了完整的定义。您能自己解决吗？提示：`once()`函数的输出应与其输入的类型相同。
- en: 'With this new function, you could have coded the button as follows. When the
    user clicks on the button, the function that will get called with `(sales, data)`
    as arguments isn''t `billUser()`, but rather the result of having applied `once()`
    to `billUser()`—and that would have resulted in a new function that would have
    called `billUser()` only once:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个新函数，你可以将按钮编码如下。当用户点击按钮时，将调用带有`(sales, data)`作为参数的函数不是`billUser()`，而是将`once()`应用于`billUser()`的结果——这将导致产生一个只调用`billUser()`一次的新函数：
- en: '[PRE83]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This is the concept of a higher order function: a function that receives functions
    as arguments and produces a new function as a result. Usually, there are three
    kinds of possible transformations that we could desire:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是高阶函数的概念：一个接收函数作为参数并产生一个新函数作为结果的函数。通常，我们可能希望进行三种可能的转换：
- en: '*Wrapping functions*: We do this so that they keep their original functionality,
    but add some new feature; for example, we could add logging or timing so that
    the original function still does its thing, but log its parameters or produce
    timing information'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包装函数*：我们这样做是为了保持它们的原始功能，但添加一些新功能；例如，我们可以添加日志记录或计时，以便原始函数仍然执行其功能，但记录其参数或生成时间信息。'
- en: '*Altering functions*: We do this so that they will differ in some key point
    with the original version; this is what we did with `once()`, which produces a
    new version of a function that runs only a single time'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修改函数*：我们这样做是为了使它们在某些关键点上与原始版本不同；这就是我们对`once()`所做的事情，它会生成一个仅运行一次的新版本的函数'
- en: '*Other changes*: These changes include turning a function into a promise (we''ll
    see this when we get to `Node`, in the *Using Promises instead of error first
    callbacks* section of [Chapter 3](f2d2d72d-2137-4f67-8d72-9a113dc3d09c.xhtml),
    *Developing with Node*) and more'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*其他更改*：这些更改包括将函数转换为promise（我们将在`Node`中看到这一点，在[第3章](f2d2d72d-2137-4f67-8d72-9a113dc3d09c.xhtml)的*使用promise代替错误优先回调*部分，*使用Node进行开发*）等等'
- en: Doing async calls compactly
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧凑地进行异步调用
- en: 'When Ajax started appearing, it was commonly used with callbacks, which themselves
    could have callbacks of their own, with more callbacks within, which eventually
    led to coining the term *callback hell*. As a way out of that impractical programming
    style, two other styles of working with services and asynchronous calls appeared:
    promises and `async`/`await`—though in truth, the latter also use promises!'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当Ajax开始出现时，它通常与回调一起使用，这些回调本身可能有自己的回调，内部还有更多的回调，最终导致了“回调地狱”的术语的产生。作为摆脱这种不切实际的编程风格的一种方式，出现了另外两种处理服务和异步调用的方式：promises和`async`/`await`——尽管事实上，后者也使用promises！
- en: Getting started
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'Let''s see both styles by using a simple example. This book was written in
    three different cities: Pune, India; London, England; and Montevideo, Uruguay,
    so let''s do some work related to those cities. We will write code that will get
    weather information for those cities:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来看看这两种风格。这本书是在三个不同的城市写的：印度的普纳、英格兰的伦敦和乌拉圭的蒙得维的亚，所以让我们做一些与这些城市相关的工作。我们将编写代码来获取这些城市的天气信息：
- en: For Montevideo alone
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅对蒙得维的亚
- en: For London and then for Pune, in series, so that the second call won't start
    until the first is done
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先是伦敦，然后是普纳，这样第二个调用将在第一个完成后才开始
- en: For the three cities in parallel, so that all three requests will be processed
    at the same time, gaining time by the overlap
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对三个城市进行并行处理，以便三个请求将同时进行处理，通过重叠来节省时间
- en: 'We will not get into details such as using this or that API, getting a private
    key, and so on, and we''ll just fake it by accessing the free *The Weather Channel* page.
    We will use the following definitions for all our coding, which we''ll do in `Node`,
    using the `axios` module; don''t worry about the details now:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论诸如使用这个或那个API、获取私钥等细节，我们将通过访问免费的*天气频道*页面来进行伪装。我们将使用以下定义来进行所有的编码，我们将在`Node`中使用`axios`模块来完成，现在不要担心细节：
- en: '[PRE84]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `BASE_URL` constant provides the basic web address, to which you must attach
    the coordinates (latitude, longitude) of the desired city. On its own, we would
    get a page like the one shown in the following screenshot:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`BASE_URL`常量提供基本的网址，您必须将所需城市的坐标（纬度、经度）附加到其中。单独使用时，我们将得到一个类似于以下截图的页面：'
- en: '![](img/f27bb572-7800-4640-8d02-86e62e9c0190.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f27bb572-7800-4640-8d02-86e62e9c0190.png)'
- en: we will be using Ajax to get weather information for cities
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Ajax来获取城市的天气信息
- en: In real life, we would not be getting a web page but rather an API, and then
    process the returned results. In our case, since we don't actually care for the
    data, but for the methods we'll use to do the calls, we'll be content with just
    showing some banal information, such as how many bytes were sent back. Totally
    useless, I agree, but this is enough for our example!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们不会获取网页，而是获取API，然后处理返回的结果。在我们的情况下，由于我们实际上并不关心数据，而是关心我们将用来进行调用的方法，我们将满足于显示一些无聊的信息，比如发送回多少字节。我同意，这完全没有用，但对于我们的例子来说已经足够了！
- en: We'll be using `axios` in several places in this book, so you may want to read
    its documentation, which can be found at [https://github.com/axios/axios](https://github.com/axios/axios).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中的几个地方我们将使用`axios`，所以您可能希望阅读它的文档，可以在[https://github.com/axios/axios](https://github.com/axios/axios)找到。
- en: How to do it...
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Using functions as callbacks is the most classic way of dealing with async calls,
    but this has several disadvantages, such as code that is harder to read and series
    difficulties in dealing with some not-too-uncommon cases. Here, we'll look at
    two alternative ways of working.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数作为回调是处理异步调用的最经典方式，但这有几个缺点，比如代码难以阅读以及在处理一些不太常见的情况时出现系列困难。在这里，我们将看看两种替代的工作方式。
- en: Doing Ajax calls with promises
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用promises进行Ajax调用
- en: The first way we can do web service calls is by using promises, and they were
    (up to the appearance of the more modern `async`/`await` statements, which we'll
    be seeing in the next section) the favorite method. Promises were available some
    time back (first around 2011 through jQuery's deferred objects, and afterwards
    by means of libraries such as `BlueBird` or `Q`), but in recent JS versions, they
    became native. Since promises cannot really be considered something new, let's
    just see some examples so that we can move on to more modern ways of working—no, we
    won't be even considering going further back than promises, and directly work
    with callbacks!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行网络服务调用的第一种方法是使用promises，它们是（直到更现代的`async`/`await`语句出现，我们将在下一节中看到）最受欢迎的方法。promises在一段时间内就已经可用（最早是在2011年通过jQuery的deferred对象，之后是通过`BlueBird`或`Q`等库），但在最近的JS版本中，它们变成了原生的。由于promises实际上不能被认为是新东西，让我们看一些例子，以便我们可以继续使用更现代的工作方式——不，我们甚至不会考虑比promises更早的工作方式，而是直接使用回调！
- en: Do native promises imply that libraries won't be needed again? That's a tricky
    question! JS promises are quite basic, and most libraries add several methods
    that can simplify your coding. (See [http://bluebirdjs.com/docs/api-reference.html](http://bluebirdjs.com/docs/api-reference.html) or [https://github.com/kriskowal/q/wiki/API-Reference](https://github.com/kriskowal/q/wiki/API-Reference)
    for such features from `Bluebird` or `Q`.) Hence, while you may do perfectly well
    with native promises, in some circumstances, you may want to keep using a library.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 原生promises意味着不再需要库吗？这是一个棘手的问题！JS promises相当基础，大多数库都添加了几种可以简化编码的方法。（请参阅[http://bluebirdjs.com/docs/api-reference.html](http://bluebirdjs.com/docs/api-reference.html)或[https://github.com/kriskowal/q/wiki/API-Reference](https://github.com/kriskowal/q/wiki/API-Reference)了解`Bluebird`或`Q`的这些功能。）因此，虽然您可能可以完全使用原生promises，但在某些情况下，您可能希望继续使用库。
- en: 'Getting the weather data for Montevideo is simple if we use the `getWeather()`
    function that we defined previously:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 获取Montevideo的天气数据很简单，如果我们使用之前定义的`getWeather()`函数：
- en: '[PRE85]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `getWeather()` function actually returns a promise; its `.then()` method
    corresponds to the success case and `.catch()` corresponds to any error situations.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWeather()`函数实际上返回一个promise；它的`.then()`方法对应于成功情况，`.catch()`对应于任何错误情况。'
- en: 'Getting data for two cities in a row is also simple. We don''t want to start
    the second request until the first one has been successful, and that leads to
    the following scheme:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 连续获取两个城市的数据也很简单。我们不希望在第一个请求成功之前开始第二个请求，这导致以下方案：
- en: '[PRE86]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This is not the only way to program such a series of calls, but since we won't
    actually be directly working with promises, let's just skip the alternatives.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是编写这样一系列调用的唯一方法，但由于我们实际上不会直接使用promises，让我们跳过其他方法。
- en: 'Finally, in order to do calls in parallel and optimize time, the `Promise.all()`
    method will be used to build up a new promise out of the three individual ones
    for each city. If all calls succeed, the bigger promise will also do; should any
    of the three calls fail, then failure will also be the global result:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了并行调用和优化时间，`Promise.all()`方法将用于构建一个新的promise，由三个单独的promise组成。如果所有调用都成功，那么更大的promise也会成功；如果其中任何一个调用失败，那么失败也将是全局结果：
- en: For more information on `Promise.all()`, check out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all).
    If you'd rather build a promise that succeeds when *any* (instead of *all*) of
    the involved promises succeeds, you should use `Promise.race()`; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Promise.all()`的更多信息，请查看[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)。如果您更愿意构建一个promise，当*任何一个*（而不是*所有*）涉及的promises成功时，您应该使用`Promise.race()`；请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)。
- en: '[PRE87]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Note how we use a destructuring assignment to get the data for each city. The
    result of calling these functions may be as follows; I added some spacing for
    clarity:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何使用解构赋值来获取每个城市的数据。调用这些函数的结果可能如下；我为了清晰起见添加了一些间距：
- en: '[PRE88]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Organizing web calls with promises is a straightforward method, but the usage
    of possibly nested `.then()` methods can become hard to understand, so we really
    should give a look to an alternative. We'll do just that in the next section.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 使用promises组织网络调用是一种简单直接的方法，但可能嵌套的`.then()`方法的使用可能变得难以理解，因此我们真的应该看看其他方法。我们将在下一节中做到这一点。
- en: Doing Ajax calls with async/await
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用async/await进行Ajax调用
- en: 'The second way, `async`/`await`, is more modern but, deep inside, actually
    also works with promises, but simplifyies the job. There are some important definitions
    that we should take into account:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法`async`/`await`更现代，但实际上也是使用promises，但简化了工作。有一些重要的定义我们应该考虑：
- en: An `async` function will contain some `await` expressions, depending on promises
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`函数将包含一些`await`表达式，取决于promises'
- en: '`await` expressions pause the execution of the `async` function until the promise''s
    resolution'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await`表达式暂停`async`函数的执行，直到promise解决。'
- en: After the promise's resolution, processing is resumed, with the returned value
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: promise解决后，将恢复处理，返回值
- en: If an error is produced, it can be caught with `try ... catch`
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生错误，可以使用`try ... catch`捕获
- en: '`await` can only be used in async functions'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await`只能在async函数中使用'
- en: 'How does this affect our coding? Let''s review our three examples. Getting
    information for a single city is simple:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何影响我们的编码？让我们回顾一下我们的三个例子。获取单个城市的信息很简单：
- en: '[PRE89]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We are still using a promise (the one returned by `axios` via the `getWeather()`
    call), but now the code looks more familiar: you wait for results to come, and
    then you process them—it almost looks as if the call were a synchronous one!'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然使用承诺（通过`axios`通过`getWeather()`调用返回的承诺），但现在代码看起来更加熟悉：您等待结果出现，然后处理它们——它几乎看起来就像是同步调用一样！
- en: 'Getting data for London and then Pune in sequence is also quite direct: you
    wait for the first city''s data, then you wait for the second''s, and then you
    do your final process; what could be simpler? Let''s see the code:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序获取伦敦和普纳的数据也非常直接：您等待第一个城市的数据，然后等待第二个城市的数据，然后进行最终处理；还有什么比这更简单的呢？让我们看看代码：
- en: '[PRE90]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Finally, getting all data in parallel also depends on the `Promise.all()` method
    we saw in the previous section:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，同时获取所有数据还取决于我们在上一节中看到的`Promise.all()`方法：
- en: '[PRE91]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The parallel call code is really quite similar to the pure promises'' version:
    the only difference here is that you `await` results, instead of using `.then()`.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 并行调用代码与纯承诺版本非常相似：这里唯一的区别是您`await`结果，而不是使用`.then()`。
- en: We have seen two ways of dealing with asynchronous service calls. Both are very
    much in use, but in this text, we'll tend to favor `async`/`await`, given that
    the resulting code seems clearer, with less extra baggage.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了处理异步服务调用的两种方法。这两种方法都被广泛使用，但在本文中，我们倾向于使用`async`/`await`，因为生成的代码似乎更清晰，附带的额外负担更少。
- en: Working with objects and classes
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象和类
- en: 'If you want to start a lively discussion, ask a group of web developers: is
    *JavaScript an object oriented language, or merely an object based one?*, and
    retreat quickly! This discussion, while possibly arcane, has gone on year after
    year, and will probably continue for a while. A usual argument for the *object-based*
    opinion has to do with the fact that JS didn''t include classes and inheritance
    and was prototype oriented. This argument has been voided now because the latest
    versions of JS provide two new keywords, `class` and `extends`, which behave in
    pretty much the same way as their counterparts in other *official* OO languages.
    However, keep in mind that the new classes are just *syntactical sugar* over the
    existing prototype-based inheritance; no new paradigm or model was truly introduced.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想开始一场热烈的讨论，请问一群Web开发人员：*JavaScript是面向对象的语言，还是仅仅是基于对象的语言？*，然后迅速撤退！这种讨论，虽然可能有些深奥，但已经进行了多年，可能还会继续一段时间。支持*基于对象*观点的常见论点与JS没有包括类和继承，而是基于原型。这个论点现在已经无效，因为JS的最新版本提供了两个新关键字，`class`和`extends`，它们的行为方式与其他*官方*面向对象语言中的对应物基本相同。但是，请记住，新类只是现有基于原型的继承的*语法糖*；没有真正引入新的范例或模型。
- en: JS could do inheritance, but it was harder. To see how this was achieved in
    the old fashioned way, look at [https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance),
    and you'll have to agree that using `class` and `extends` is much better than
    assigning prototypes and constructors by hand!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: JS可以进行继承，但更难。要了解如何以老式方式实现这一点，请查看[https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance)，您会同意使用`class`和`extends`要比手动分配原型和构造函数好得多！
- en: How to do it...
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: If you have worked with other common programming languages, such as Java, C++,
    and Python, the concepts of classes and objects should already be clear to you;
    we'll assume that's the case and look at how these concepts apply in modern JS.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用过其他常见的编程语言，如Java、C++和Python，那么类和对象的概念对您来说应该已经很清楚；我们将假设是这种情况，并看看这些概念如何应用于现代JS。
- en: Defining classes
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类
- en: 'Let''s start with the basics and look at how classes are defined in modern
    JS. Afterwards, we''ll move to other features that are interesting, but that you
    might not use that often. To define a class, we simply write something like the
    following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始，看看现代JS中如何定义类。之后，我们将转向其他有趣的特性，但您可能不经常使用。要定义一个类，我们只需编写类似以下内容的内容：
- en: '[PRE92]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The new syntax is much clearer than using functions for constructors, as in
    older versions of JS. We wrote a `.constructor()` method, which will initialize
    new objects, and we defined two methods, `.initials()` and `.fullName()`, which
    will be available for all instances of the `Person` class.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语法比在旧版本的JS中使用函数作为构造函数要清晰得多。我们编写了一个`.constructor()`方法，它将初始化新对象，并且我们定义了两个方法，`.initials()`和`.fullName()`，它们将对`Person`类的所有实例可用。
- en: We are following the usual convention of using an initial uppercase letter for
    class names and initial lowercase letters for variables, functions, methods, and
    so on.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循使用大写字母开头的类名和使用小写字母开头的变量、函数、方法等的通常约定。
- en: Extending classes
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类
- en: 'We can also extend a previously existing class. To refer to the original constructor,
    use `super()`, and to refer to the parent''s method, use `super.method()`; see
    the redefinition of `.fullName()` here:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扩展先前存在的类。要引用原始构造函数，请使用`super()`，要引用父类的方法，请使用`super.method()`；请参阅此处的`.fullName()`的重新定义：
- en: '[PRE93]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You are not limited to extending your own classes; you can also extend the
    JS ones, too:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅限于扩展自己的类；您也可以扩展JS类：
- en: '[PRE94]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If you don't need a special constructor, you can omit it; the parent's constructor
    will be called by default.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要特殊的构造函数，可以省略它；默认情况下将调用父类的构造函数。
- en: Implementing interfaces
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口
- en: JS doesn't allow multiple inheritance, and it doesn't provide for implementing
    interfaces either. However, you can build your own ersatz interfaces by using
    *mixins*, using a higher order function (as we saw earlier, in the *Producing
    functions from functions* section), but with a class as a parameter, and adding
    methods (but not properties) to it. Even if you don't get to actually use it,
    let's look at a short example, because it gives another example of working in
    a functional way.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: JS不允许多重继承，也不提供实现接口的方法。但是，您可以通过使用*mixins*构建自己的伪接口，使用高阶函数（正如我们之前在*从函数生成函数*部分看到的那样），但参数是一个类，并向其添加方法（但不是属性）。即使您实际上不使用它，让我们看一个简短的例子，因为它提供了另一个以函数方式工作的例子。
- en: Read [https://developer.mozilla.org/en-US/docs/Glossary/Mixin](https://developer.mozilla.org/en-US/docs/Glossary/Mixin) for
    a definition. As an alternative, you can use TypeScript; see [https://www.typescriptlang.org/docs/handbook/interfaces.html](https://www.typescriptlang.org/docs/handbook/interfaces.html) for
    the latter.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读[https://developer.mozilla.org/en-US/docs/Glossary/Mixin](https://developer.mozilla.org/en-US/docs/Glossary/Mixin)以获取定义。作为替代方案，您可以使用TypeScript；有关后者的更多信息，请参阅[https://www.typescriptlang.org/docs/handbook/interfaces.html](https://www.typescriptlang.org/docs/handbook/interfaces.html)。
- en: 'Let''s take our `Person` class from earlier, once again. Let''s imagine a couple
    of interfaces: one could provide an object with a method that produced the JSON
    version of itself, and another could tell you how many properties an object has.
    (OK, none of these examples are too useful, but bear with me; the method we''ll
    use is what matters.) We will define two functions that receive a class as an
    argument and return an extended version of it as a result:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次从之前获取的`Person`类开始。让我们想象一些接口：一个可以提供一个具有生成自身的JSON版本的方法的对象，另一个可以告诉您对象具有多少属性。（好吧，这些示例都不太有用，但请忍耐；我们将使用的方法才是重要的。）我们将定义两个接收类作为参数并返回其扩展版本的函数：
- en: '[PRE95]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, we can create a new `PersonWithMixins` class (not a very good name, is
    it?) by using these two mixins, and we can even provide a different implementation,
    as with the `.toJson()` method. A very important detail is that the class to extend
    is actually the result of a function call; check it out:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用这两个mixins创建一个新的`PersonWithMixins`类（不是一个很好的名称，对吧？），甚至可以提供不同的实现，就像`.toJson()`方法一样。一个非常重要的细节是要扩展的类实际上是函数调用的结果；看一下：
- en: '[PRE96]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Being able to add methods to an object in this way can be a workaround for the
    problem of being able to implement interfaces. This is important to show how JS
    can let you work in an advanced style, seemingly beyond what the language itself
    provides, so that you won't be feeling that the language hinders you when trying
    to solve a problem.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式向对象添加方法可以解决无法实现接口的问题。这很重要，因为它展示了JS如何让您以高级方式工作，似乎超出了语言本身提供的范围，这样当您尝试解决问题时，您不会感到语言在阻碍您。
- en: Using `Flow`, we will get to use the usual Java-style implements and interface
    declarations, but they will only be used for type checking; see the *Implementing
    interfaces* section for more details.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Flow`，我们将使用通常的Java风格的implements和接口声明，但它们只用于类型检查；有关更多详细信息，请参阅*实现接口*部分。
- en: Static methods
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'Often, you have some utility functions that are related to a class, but not
    to specific object instances. In this case, you can define such functions as static
    methods, and they will be available in an easy way. For instance, we could create
    a `.getMonthName()` method, which will return the name of a given month:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可能有一些与类相关但不属于特定对象实例的实用函数。在这种情况下，您可以将这些函数定义为静态方法，并且它们将以一种简单的方式可用。例如，我们可以创建一个`.getMonthName()`方法，它将返回给定月份的名称：
- en: '[PRE97]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Static methods must be accessed by giving the class name; since they do not
    correspond to objects, they cannot be used with this or an object itself.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法必须通过给出类名来访问；因为它们不对应对象，所以不能与this或对象本身一起使用。
- en: Using getters and setters
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用getter和setter
- en: 'JS now lets you define *dynamic* properties that, instead of being a stored
    value in the object, are calculated on the spot. For example, with the previous
    `Person` class, we could have a *getter* for `lastFirst`, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: JS现在允许您定义*动态*属性，而不是对象中存储的值，而是在现场计算的值。例如，对于先前的`Person`类，我们可以有一个用于`lastFirst`的*getter*，如下所示：
- en: '[PRE98]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'With this definition, you could access a `.lastFirst` property as if it actually
    were an attribute of the object; no parentheses are needed:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此定义，您可以访问`.lastFirst`属性，就好像它实际上是对象的属性一样；不需要括号：
- en: '[PRE99]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: You can complement a getter with a *setter*, and it will perform any operations
    you want it to. For example, we may want let the user assign a value to `.lastFirst` and
    then change `.first` and `.last` appropriately.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*setter*来补充getter，并且它将执行任何您希望执行的操作。例如，我们可能希望让用户为`.lastFirst`分配一个值，然后相应地更改`.first`和`.last`。
- en: 'Working somewhat cavalierly (no checks on arguments!), we could add the following
    definition to our `Person` class:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 有点鲁莽地工作（没有对参数进行检查！），我们可以将以下定义添加到我们的`Person`类中：
- en: '[PRE100]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Of course, having a property and having a getter or a setter for the same property
    is not allowed. Also, getter functions cannot have parameters, and setter functions
    must have exactly one.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，拥有属性并拥有相同属性的getter或setter是不允许的。此外，getter函数不能有参数，setter函数必须恰好有一个。
- en: You can find more information on getters and setters at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)
    and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set),
    respectively.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)和[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set)找到有关getter和setter的更多信息。
- en: The previous sections do not exhaust all of the possibilities of JS as to classes
    and objects (not by a long shot!), but I opted to go over the most likely ones
    for clarity.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分并没有穷尽JS关于类和对象的所有可能性（远远不够！），但我选择了最可能的一些来让它更清晰。
- en: Organizing code in modules
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化代码
- en: As today's JS applications become more and more complex, working with namespaces
    and dependencies becomes ever more difficult to handle. A key solution to this
    problem was the concept of *modules*, which allows you to partition your solution
    in independent parts, taking advantage of encapsulation to avoid conflict between
    different modules. In this section, we'll look at how to work in this fashion.
    However, we'll start with a previous JS pattern, which may become useful in its
    own way.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 随着今天的JS应用程序变得越来越复杂，处理命名空间和依赖关系变得越来越难。解决这个问题的关键是*模块*的概念，它允许你将解决方案分成独立的部分，利用封装来避免不同模块之间的冲突。在本节中，我们将看看如何以这种方式工作。然而，我们将从以前的JS模式开始，这种模式可能以自己的方式变得有用。
- en: '`Node`, which we''ll be working with starting with the next chapter, also does
    modules but in a different fashion, so we''ll postpone the discussion of its modules
    for now.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node`，我们将从下一章开始使用它，也有模块，但方式不同，所以我们暂时不讨论它的模块。'
- en: How to do it...
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Organizing code is such a basic need when dealing with hundreds or thousands
    of or even larger code bases, and so many ways of dealing with the problem were
    designed before JS finally defined a standard. First, we'll look at the more classic
    *iffy* way (we'll see what this means soon) and then move on to more modern solutions,
    but be aware that you may encounter all of these styles when reading other people's
    code!
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数百甚至数千行代码时，组织代码是一种基本需求，因此在JS最终定义标准之前，设计了许多处理问题的方式。首先，我们将看看更经典的*iffy*方式（我们很快就会知道这意味着什么），然后转向更现代的解决方案，但请注意，阅读其他人的代码时可能会遇到所有这些风格！
- en: Doing modules the IIFE way
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以IIFE方式进行模块化
- en: 'Before modules became widely available, there was a fairly common pattern in
    use, which basically provided the same features that today''s modules do. First,
    let''s introduce a sample fragment of code, and then examine its properties:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块广泛可用之前，有一种相当常见的模式，基本上提供了今天模块提供的相同功能。首先，让我们介绍一小段代码片段，然后检查它的属性：
- en: '[PRE101]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Defining a function and immediately calling it is called an IIFE, pronounced
    *iffy*, and stands for *Immediately Invoked Function Expression*.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数并立即调用它称为IIFE，发音为*iffy*，代表*Immediately Invoked Function Expression*。
- en: IIFEs are also known as *Self-Executing Anonymous Functions*, which doesn't
    sound as good as *iffy*!
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE也被称为*Self-Executing Anonymous Functions*，这听起来不如*iffy*好听！
- en: 'We defined a function (the one starting with `name => ...`), but we immediately
    called it (with `("Clicks")` afterwards). Therefore, what gets assigned to `myCounter`
    is not a function, but its returned value, that is, an object. Let''s analyze
    this object''s contents. Because of the scoping rules for functions, whatever
    you define inside isn''t visible from the outside. In our particular case, this
    means that `count`, `get()`, `inc()`, and `toString()` won''t be accessible. However,
    since our IIFE returns an object including the two latter functions, those two
    (and only those two) are usable from the outside: this is called the *revealing
    module pattern*.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数（以`name => ...`开头的函数），但我们立即调用它（之后跟着`("Clicks")`）。因此，`myCounter`被分配的不是一个函数，而是它的返回值，也就是一个对象。让我们分析一下这个对象的内容。由于函数的作用域规则，你在内部定义的任何东西都不会从外部可见。在我们的特定情况下，这意味着`count`、`get()`、`inc()`和`toString()`都不可访问。然而，由于我们的IIFE返回了一个包含后两个函数的对象，这两个函数（仅限这两个函数）可以从外部使用：这就是*揭示模块模式*。
- en: 'A question: where is the `"Clicks"` value stored, and why isn''t the value
    of `count` lost from call to call? The answer to both questions has to do with
    a well-known JS feature, *closures*, which has been in the language since its
    beginning. See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
    for more information on this.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题：`"Clicks"`值存储在哪里，为什么从调用到调用`count`的值不会丢失？这两个问题的答案都与一个众所周知的JS特性有关，*闭包*，这个特性从语言开始就存在。更多信息请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)。
- en: 'If you have followed on so far, the following should be clear to you:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你迄今为止一直在跟进，那么以下内容对你来说应该是清楚的：
- en: Whatever variables or functions are defined in the module aren't visible or
    accessible from the outside, unless you voluntarily reveal them
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你自愿揭示它们，否则在模块中定义的任何变量或函数都不会从外部可见或可访问
- en: Whatever names you decide to use in your module won't conflict with outside
    names because of normal lexical scoping rules
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你在模块中决定使用什么名称，都不会与外部名称冲突，因为正常的词法作用域规则
- en: The captured variables (in our case, `name`) persist so that the module can
    store information and use it later
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获的变量（在我们的例子中是`name`）会持续存在，以便模块可以存储信息并在以后使用
- en: 'All in all, we must agree that IIFEs are a *poor man''s module* and their usage
    is quite common. Browse the web for a bit; you are certain to find examples of
    it. However, ES6 introduced a more general (and clearer and easier to understand)
    way of defining modules, which is what we''ll be using: let''s talk about this
    next.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们必须同意IIFE是*穷人的模块*，它们的使用非常普遍。浏览一下网络；你肯定会找到它的例子。然而，ES6引入了一种更通用（更清晰、更易理解）的定义模块的方式，这就是我们将要使用的：让我们下面来谈谈这个。
- en: Redoing our IIFE module in the modern way
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以现代方式重新做我们的IIFE模块
- en: 'The key concept in modules is that you''ll have separate files, each of which
    will represent a module. There are two complementary concepts: importing and exporting.
    Modules will import the features they require from other modules, which must have
    exported them so that they are available.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中的关键概念是你将有单独的文件，每个文件代表一个模块。有两个互补的概念：导入和导出。模块将从其他模块导入它们需要的功能，这些功能必须已经导出，以便它们可用。
- en: 'First, let''s look at the equivalent of our counter module from the previous
    section, and then comment on the extra features we can use:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看前一节中计数器模块的等价物，然后评论我们可以使用的额外功能：
- en: '[PRE102]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: How would we use this module? Let's hold on the explanations about some internal
    aspects and answer that first.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这个模块？让我们先搁置一些内部方面的解释，先回答这个问题。
- en: 'To use this module in some other file from our application, we would write
    something as follows, with a new source file that imports the functions that our
    module exported:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们应用程序的其他文件中使用这个模块，我们将编写如下内容，使用一个新的源文件来导入我们的模块导出的函数：
- en: '[PRE103]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: OK, so using this module to provide a counter isn't so different after all.
    The main difference with the IIFE version is that here, we cannot do an initialization. A
    common pattern to provide this is to export a `init()` function that will do whatever
    is needed. Whoever uses the module must, first of all, call `init()` to set things
    up properly.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以使用这个模块来提供一个计数器并没有那么不同。与IIFE版本的主要区别在于，这里我们无法进行初始化。提供这一功能的常见模式是导出一个`init()`函数，该函数将执行所需的操作。使用模块的人必须首先调用`init()`来正确设置事物。
- en: There's no need to immediately call the `init()` function, as would happen with
    the IIFE version, and you could delay it until necessary. Also, the `init()` function
    could be called more times in order to reset the module. These possibilities provide
    extra functionality.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 无需立即调用`init()`函数，就像IIFE版本那样，你可以推迟到必要时再调用。此外，`init()`函数可以被多次调用以重置模块。这些可能性提供了额外的功能。
- en: Adding initialization checks
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加初始化检查
- en: 'If you wish, you can make the `.init()` function more powerful by having the
    module crash if used without initialization:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以通过使`.init()`函数更强大，使模块在未经初始化时崩溃。
- en: '[PRE104]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In this fashion, we can ensure proper usage of our module. Note that the idea
    of assigning a new function to replace an old one is very typical of the Functional
    Programming style; functions are first class objects that can be passed around,
    returned, or stored.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以确保正确使用我们的模块。请注意，将新函数赋值以替换旧函数的想法是函数式编程风格的典型特征；函数是一等对象，可以传递、返回或存储。
- en: Using more import/export possibilities
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更多的导入/导出可能性
- en: 'In the previous section, we exported a single item from our module by using
    what is called a default export: one per module. There is also another kind of
    export, *named* exports, of which you can have several per module. You can even
    mix them in the same module, but it''s usually clearer to not mix them up. For
    example, say you needed a module to do some distance and weight conversions. Your
    module could be as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们通过使用所谓的默认导出来从我们的模块中导出了一个单一项：每个模块一个。还有另一种导出方式，*命名*导出，每个模块可以有多个。你甚至可以在同一个模块中混合它们，但通常最好不要混在一起。例如，假设你需要一个模块来进行一些距离和重量转换。你的模块可能如下所示：
- en: '[PRE105]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: You can have as many definitions as you want, and you can export any of them;
    in our case, we are exporting six functions and one constant. You do not need
    to pack everything into a single `export`; you can have several, as we have already
    shown you. Exports are usually grouped together at the end of a module to help
    a reader quickly find everything that the module exports, but sometimes you may
    find them all throughout the code; we won't be doing that. You can also export
    something in the same line where you define it, as in `export const LENGTH_OF_YEAR_IN_DAYS
    = 365.2422`, but we won't use that style either, for consistency.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有任意多的定义，并且你可以导出其中的任何一个；在我们的例子中，我们导出了六个函数和一个常量。你不需要将所有内容打包到一个单独的`export`中；你可以有多个，就像我们已经向你展示的那样。通常，导出通常会被分组放在模块的末尾，以帮助读者快速找到模块导出的所有内容，但有时你可能会在整个代码中找到它们；我们不会这样做。你也可以在定义的同一行导出某些内容，就像`export
    const LENGTH_OF_YEAR_IN_DAYS = 365.2422`，但出于一致性的考虑，我们也不会使用这种风格。
- en: 'When importing a module with named exports, you just have to say which of the
    exports you want. You can import from different modules; you''ll just require
    several `import` statements. It''s a standard practice to group all of them at
    the start of your source file. You can also rename an `import`, as in the case
    of `poundsToKg` in the following code, which we''ll use as `p_to_kg`. In reality,
    you would do this if you had identically named imports from two different modules;
    in our particular example, it doesn''t really make sense:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入具有命名导出的模块时，你只需要说明你想要导出的内容。你可以从不同的模块中导入；你只需要多个`import`语句。通常的做法是在源文件的开头将它们分组。你也可以重命名一个`import`，就像下面的代码中的`poundsToKg`，我们将使用`p_to_kg`。实际上，如果你从两个不同的模块中导入了同名的导出，你会这样做；在我们的特定例子中，这并没有太多意义：
- en: '[PRE106]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: So far, we have seen how to export JS elements—functions and constants in our
    example—but you could also export classes, objects, arrays, and so on. In the
    next section, we'll get back to Flow, and see how types can also be exported and
    imported.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何导出JS元素——在我们的例子中是函数和常量，但你也可以导出类、对象、数组等等。在下一节中，我们将回到Flow，并看看类型也可以被导出和导入。
- en: Using Flow types with modules
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块的Flow类型
- en: 'Exporting data types (including generics, interfaces, and so on) is quite similar
    to normal exports, except that you must include the word `type`. If you wanted
    to use the conversion type elsewhere, in the original module, you would add the
    following:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 导出数据类型（包括泛型、接口等）与普通导出非常相似，只是你必须包含`type`这个词。如果你想在原始模块中的其他地方使用转换类型，你可以添加以下内容：
- en: '[PRE107]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Correspondingly, wherever you wanted to import that type, you would add something
    like this:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，无论你想在哪里导入该类型，你都可以添加类似于这样的内容：
- en: '[PRE108]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Note, however, an important detail: you cannot export or import data types
    in the same sentence in which you deal with standard JS elements: `export` and
    `export type` are distinct, separate statements, and so are `import` and `import
    type`.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个重要的细节是：你不能在处理标准JS元素的同一句中导出或导入数据类型：`export`和`export type`是不同的、独立的语句，`import`和`import
    type`也是如此。
- en: Determining a feature's availability
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定功能的可用性
- en: To round off this chapter, let me introduce two web tools that can help you
    be aware about what features you can safely use and which will make a transpiler
    (such as `Babel`, which we mentioned at the start of this chapter) necessary.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，让我介绍两个网络工具，可以帮助你了解你可以安全使用哪些功能，以及哪些功能将需要转译器（比如我们在本章开头提到的`Babel`）。
- en: How to do it...
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Your first resource will be [https://kangax.github.io/compat-table/](https://kangax.github.io/compat-table/),
    which provides very thorough and complete tables showing, feature by feature,
    what is supported on JS engines everywhere. Depending on your specific needs,
    you might be able to totally dispense with transpiling, but it's certain you should
    be careful before taking such a measure!
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个资源将是[https://kangax.github.io/compat-table/](https://kangax.github.io/compat-table/)，它提供非常全面和完整的表格，逐个功能地显示了JS引擎在各处的支持情况。根据你的具体需求，你可能完全可以不需要转译，但在采取这样的措施之前，你应该谨慎考虑！
- en: 'The following screenshot shows Kangax at work:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Kangax的工作：
- en: '![](img/52bf1c0f-fdcd-4da4-a707-e985222f7f50.png)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52bf1c0f-fdcd-4da4-a707-e985222f7f50.png)'
- en: The Kangax website lets you determine what features are (or are not) provided
    by browsers, versions of Node, and so on
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: Kangax网站可以让你确定浏览器、Node版本等提供了哪些功能或者没有提供哪些功能
- en: 'A second web tool that you should be aware of is *Can I use...* at [https://caniuse.com/](https://caniuse.com/).
    In this site, you can search for any feature (be it JS, HTML, or CSS), and you''ll
    get to see what browser versions support it or not. A comment is relevant: this
    site only provides information for desktop and mobile browsers; you cannot see
    if a feature is supported in `Node`, for example. The following screenshot shows *Can
    I use...* at work:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个你应该知道的网络工具是*Can I use...*，网址是[https://caniuse.com/](https://caniuse.com/)。在这个网站上，你可以搜索任何功能（无论是JS、HTML还是CSS），你将看到哪些浏览器版本支持它或者不支持它。一个需要注意的评论是：这个网站只提供桌面和移动浏览器的信息；例如你无法看到一个功能在`Node`中是否被支持。以下截图显示了*Can
    I use...*的工作：
- en: '![](img/1a5da347-88de-44da-aa06-07052b82694f.png)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a5da347-88de-44da-aa06-07052b82694f.png)'
- en: The *Can I Use...* site lets you find out what browsers support (or don't) a
    given feature
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '*Can I Use...* 网站可以让你找出哪些浏览器支持（或不支持）某个功能'
