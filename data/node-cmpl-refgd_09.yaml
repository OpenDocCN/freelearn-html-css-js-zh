- en: Dynamic Client/Server Interaction with Socket.IO
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Socket.IO 实现动态客户端/服务器交互
- en: The original design model of the web is similar to the way that mainframes worked
    in the 1970s. Both old-school dumb terminals, such as the IBM 3270, and web browsers,
    follow a request-response paradigm. The user sends a request and the far-off computer
    sends a response screen. While web browsers can show more complex information
    than old-school dumb terminals, the interaction pattern in both cases is a back
    and forth of user requests, each resulting in a screen of data sent by the server
    screen after screen or, in the case of web browsers, page after page.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的原始设计模型类似于20世纪70年代大型机的工作方式。老式的哑终端，如IBM 3270，和Web浏览器都遵循请求-响应范式。用户发送请求，远端计算机发送响应屏幕。虽然Web浏览器可以显示比老式的哑终端更复杂的信息，但在两种情况下，交互模式都是用户请求的来回，每次都导致服务器屏幕或，在Web浏览器的情况下，页面发送一屏或一页数据。
- en: 'In case you''re wondering what this history lesson is about, that request-response
    paradigm is evident in the Node.js HTTP Server API, as shown in the following
    code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道这个历史课是关于什么的，那么请求-响应范式在Node.js HTTP服务器API中是显而易见的，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The paradigm couldn't be more explicit than this. The `request` and the `response`
    are right there.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种范式再明确不过了。`请求`和`响应`就在那里。
- en: The first web browsers were an advancement over text-based user interfaces,
    with HTML mixing images, and text with varying colors, fonts, and sizes. As CSS
    came along, HTML improved, iframes allowed embedded media of all kinds, and JavaScript
    improved, so we have a quite different paradigm. The web browser is still sending
    requests and receiving a page of data, but that data can be quite complex and,
    more importantly, JavaScript adds interactivity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的Web浏览器是在基于文本的用户界面之上的一个进步，HTML混合了图像、不同颜色、字体和尺寸的文本。随着CSS的出现，HTML得到了改进，iframe允许嵌入各种类型的媒体，JavaScript也得到了改进，所以我们有了相当不同的范式。Web浏览器仍然在发送请求并接收数据页面，但这些数据可以非常复杂，更重要的是，JavaScript增加了交互性。
- en: One new technique is keeping an open connection to the server for continual
    data exchange between server and client. This change in the web application model
    is called, by some, the real-time web. In some cases, websites keep an open connection
    to the web browser, with real-time updates to web pages being one goal.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一种新技术是保持与服务器之间的开放连接，以便在服务器和客户端之间进行持续的数据交换。这种Web应用程序模型的变化被称为实时网络。在某些情况下，网站保持与Web浏览器的开放连接，实时更新网页是其中一个目标。
- en: Some observe that traditional web applications can untruthfully display their
    data; that is, if two people are looking at a page, and one person edits that
    page, that person's browser will update with the correct copy of the page, while
    the other browser is not updated. The two browsers show different versions of
    the page, one of which is untruthful. The second browser can even show a page
    that no longer exists, if the user at the first browser deletes that page. Some
    think it would be better if the other person's browser is refreshed to show the
    new content as soon as the page is edited.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些观察者认为，传统的Web应用程序可能会不真实地显示其数据；也就是说，如果两个人正在查看一个页面，而一个人编辑了该页面，那么那个人的浏览器将更新为页面的正确副本，而另一个浏览器则没有更新。两个浏览器显示页面的不同版本，其中一个是不真实的。如果第一个浏览器的人删除了该页面，第二个浏览器甚至可以显示一个不再存在的页面。有些人认为，如果其他人的浏览器在页面编辑后立即刷新以显示新内容会更好。
- en: This is one possible role of the real-time web; pages that update themselves
    as page content changes. All kinds of systems support real-time interactivity
    between folks on the same website. Whether it's seeing Facebook comments pop up
    as they're written, or collaboratively edited documents, there's a new interactivity
    paradigm on the web.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实时网络的一个可能作用；页面在页面内容变化时自动更新。各种系统都支持同一网站上的用户之间的实时交互。无论是看到Facebook评论在撰写时弹出，还是协作编辑的文档，Web上出现了一种新的交互范式。
- en: We're about to implement this behavior in the Notes application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将在笔记应用程序中实现这种行为。
- en: One of the original purposes for inventing Node.js was to support the real-time
    web. The **Comet** application architecture (Comet is related to AJAX, and both
    happen to be names of household cleaning products) involves holding the HTTP connection
    open for a long time, with data flowing back and forth between browser and server
    over that channel. The term Comet was introduced by Alex Russell in his blog in
    2006 ([http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/](http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/))
    as a general term for the architectural pattern to implement this real-time, two-way
    data exchange between client and server. That blog post called for the development
    of a programming platform very similar to Node.js.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创造 Node.js 的一个原始目的是支持实时网络。**Comet** 应用程序架构（Comet 与 AJAX 有关，而且巧合的是，这两个名字也是家庭清洁产品的名称）涉及长时间保持
    HTTP 连接打开，数据通过该通道在浏览器和服务器之间来回流动。术语 Comet 由 Alex Russell 在 2006 年的博客文章中引入（[http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/](http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/))，作为实现客户端和服务器之间这种实时双向数据交换的架构模式的通用术语。那篇博客文章呼吁开发一个与
    Node.js 非常相似的编程平台。
- en: To simplify the task, we'll lean on the `Socket.IO` library ([http://socket.io/](http://socket.io/)).
    This library simplifies two-way communication between the browser and server,
    and can support a variety of protocols with fallback to old-school web browsers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化任务，我们将依赖 `Socket.IO` 库 ([http://socket.io/](http://socket.io/))。这个库简化了浏览器和服务器之间的双向通信，并且可以支持各种协议，并为老旧的浏览器提供回退。
- en: 'We''ll be covering the following topics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Real-time communications in modern web browsers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代网络浏览器中的实时通信
- en: The `Socket.IO` library
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Socket.IO` 库'
- en: Integrating `Socket.IO` with an Express application to support real-time communication
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Socket.IO` 集成到 Express 应用程序以支持实时通信
- en: User experience for real-time communication
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时通信的用户体验
- en: Introducing Socket.IO
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Socket.IO
- en: The aim of `Socket.IO` is to make real-time apps possible in every browser and
    mobile device*. *It supports several transport protocols, choosing the best one
    for the specific browser.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Socket.IO` 的目标是使每个浏览器和移动设备都能实现实时应用*。*它支持多种传输协议，并为特定浏览器选择最佳协议。'
- en: If you were to implement your application with WebSockets, it would be limited
    to the modern browsers supporting that protocol. Because `Socket.IO` falls back
    on so many alternate protocols (WebSockets, Flash, XHR, and JSONP), it supports
    a wide range of web browsers, including some old crufty browsers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 WebSockets 实现你的应用程序，它将仅限于支持该协议的现代浏览器。因为 `Socket.IO` 落后于许多备用协议（WebSockets、Flash、XHR
    和 JSONP），它支持广泛的网络浏览器，包括一些老旧的浏览器。
- en: As the application author, you don't have to worry about the specific protocol
    `Socket.IO` uses in a given browser. Instead, you can implement the business logic
    and the library takes care of the details for you.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序的作者，你不必担心 `Socket.IO` 在特定浏览器中使用的具体协议。相反，你可以实现业务逻辑，而库会为你处理细节。
- en: '`Socket.IO` requires that a client library make its way into the browser. That
    library is provided, and is easy to instantiate. You''ll be writing code on both
    the browser side and server side using similar `Socket.IO` APIs at each end.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Socket.IO` 要求客户端库能够进入浏览器。这个库已经提供，并且易于实例化。你将在浏览器端和服务器端使用相似的 `Socket.IO` API
    进行代码编写。'
- en: The model that `Socket.IO` provides is similar to the `EventEmitter` object.
    The programmer uses the `.on` method to listen for events and the `.emit` method
    to send them. The emitted events are sent between the browser and the server with the
    `Socket.IO` library taking care of sending them back and forth.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Socket.IO` 提供的模型类似于 `EventEmitter` 对象。程序员使用 `.on` 方法来监听事件，使用 `.emit` 方法来发送它们。通过
    `Socket.IO` 库，这些事件在浏览器和服务器之间发送，库负责来回传递。'
- en: Information about `Socket.IO` is available at [https://socket.io/](https://socket.io/).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Socket.IO` 的信息可在 [https://socket.io/](https://socket.io/) 找到。
- en: Initializing Socket.IO with Express
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Express 初始化 Socket.IO
- en: '`Socket.IO` works by wrapping itself around an HTTP Server object. Think back
    to [Chapter 4](2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml), *HTTP Servers and
    Clients*, where we wrote a module that hooked into HTTP Server methods so that
    we could spy on HTTP transactions. The HTTP Sniffer attaches a listener to every
    HTTP event to print out the events. But what if you used that idea to do real
    work? Socket.IO uses a similar concept, listening to HTTP requests and responding
    to specific ones by using the Socket.IO protocol to communicate with client code
    in the browser.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Socket.IO` 通过将自己包装在 HTTP 服务器对象周围来工作。回想一下 [第 4 章](2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml)，*HTTP
    服务器和客户端*，在那里我们编写了一个模块，该模块挂钩到 HTTP 服务器方法，以便我们可以监视 HTTP 事务。HTTP Sniffer 为每个 HTTP
    事件附加一个监听器以打印出事件。但如果你用这个想法来做实际的工作呢？Socket.IO 使用一个类似的概念，通过监听 HTTP 请求并使用 Socket.IO
    协议与浏览器中的客户端代码通信来响应特定的请求。'
- en: To get started, let's first make a duplicate of the code from the previous chapter. If
    you created a directory named `chap08` for that code, create a new directory named
    `chap09` and copy the source tree there.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们首先复制上一章的代码。如果你为那个代码创建了一个名为 `chap08` 的目录，创建一个新的名为 `chap09` 的目录并将源树复制到那里。
- en: We won't make changes to the user authentication microservice, but we will use
    it for user authentication, of course.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会对用户身份验证微服务进行更改，但当然我们会使用它进行用户身份验证。
- en: 'In the Notes source directory, install these new modules:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Notes 源目录中，安装这些新模块：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will incorporate user authentication with the `passport` module, used in
    Chapter 8, *Multiuser Authentication the Microservice Way*, into some of the real-time
    interactions we'll implement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第 8 章，*多用户身份验证的微服务方式*中使用的 `passport` 模块，将用户身份验证集成到我们将要实现的某些实时交互中。
- en: To initialize `Socket.IO`, we must do some major surgery on how the Notes application
    is started. So far, we used the `bin/www.mjs` script along with `app.mjs`, with
    each script hosting different steps of launching Notes. `Socket.IO` initialization
    requires that these steps occur in a different order to what we've been doing.
    Therefore, we must merge these two scripts into one. What we'll do is copy the
    content of the `bin/www.mjs` script into appropriate sections of `app.mjs`, and
    from there, we'll use `app.mjs` to launch Notes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化 `Socket.IO`，我们必须对 Notes 应用程序的启动方式做一些重大的修改。到目前为止，我们使用了 `bin/www.mjs` 脚本和
    `app.mjs`，每个脚本托管 Notes 启动步骤的不同部分。`Socket.IO` 初始化要求这些步骤按照与我们之前所做不同的顺序发生。因此，我们必须将这两个脚本合并为一个。我们将做的是将
    `bin/www.mjs` 脚本的内容复制到 `app.mjs` 的适当部分，然后我们将使用 `app.mjs` 来启动 Notes。
- en: 'At the beginning of `app.mjs`, add this to the `import` statements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.mjs` 的开头，添加以下 `import` 语句：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `passport.socketio` module integrates `Socket.IO` with PassportJS-based
    user authentication. We'll configure this support shortly. The configuration for
    session management is now shared between `Socket.IO`, Express, and Passport. These
    lines centralize that configuration to one place in `app.mjs`, so we can change
    it once to affect every place it's needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`passport.socketio` 模块将 `Socket.IO` 与基于 PassportJS 的用户身份验证集成。我们将很快配置此支持。会话管理的配置现在在
    `Socket.IO`、Express 和 Passport 之间共享。这些行将配置集中到 `app.mjs` 中的一个地方，因此我们可以更改一次以影响需要它的所有地方。'
- en: 'Use this to initialize the HTTP Server object:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法初始化 HTTP 服务器对象：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This moves the `export default app` line from the bottom of the file to this
    location. Doesn't this location make more sense?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `export default app` 行从文件的底部移动到这个位置。这个位置不是更有意义吗？
- en: The `io` object is our entry point into the `Socket.IO` API. We need to pass
    this object to any code that needs to use that API. It won't be enough to simply
    require the `socket.io` module in other modules because the `io` object is what
    wraps the `server` object. Instead, we'll be passing the `io` object into whatever
    modules are to use it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`io` 对象是我们进入 `Socket.IO` API 的入口点。我们需要将此对象传递给任何需要使用该 API 的代码。仅仅在其他模块中 require
    `socket.io` 模块是不够的，因为 `io` 对象是包装 `server` 对象的东西。相反，我们将把 `io` 对象传递给任何需要使用它的模块。'
- en: 'The `io.use` function installs in `Socket.IO` functions similar to Express
    middleware. In this case, we integrate Passport authentication into `Socket.IO`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.use` 函数在 `Socket.IO` 中安装了类似于 Express 中间件的函数。在这种情况下，我们将 Passport 身份验证集成到
    `Socket.IO` 中：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code is copied from `bin/www.mjs`, and sets up the port to listen to.
    It relies on three functions that will also be copied into `app.mjs` from `bin/www.mjs`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码是从 `bin/www.mjs` 复制的，并设置监听端口。它依赖于三个也将从 `bin/www.mjs` 复制到 `app.mjs` 的函数：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This changes the configuration of Express session support to match the configuration
    variables we set up earlier. It's the same variables used when setting up the
    `Socket.IO` session integration, meaning they're both on the same page.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这改变了 Express 会话支持的配置，以匹配我们之前设置的配置变量。这些变量与设置 `Socket.IO` 会话集成时使用的变量相同，这意味着它们都在同一页面上。
- en: 'Use this to initialize `Socket.IO` code in the router modules:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法在路由模块中初始化 `Socket.IO` 代码：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is where we pass the `io` object into modules that must use it. This is
    so that the Notes application can send messages to the web browsers about changes
    in Notes. What that means will be clearer in a second. What's required is analogous
    to the Express router functions, and therefore the code to send/receive messages
    from `Socket.IO` clients will also be located in the router modules.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将 `io` 对象传递给必须使用它的模块的地方。这样，Notes 应用程序就可以向网络浏览器发送有关 Notes 变更的消息。这意味着什么将在下一部分中变得清晰。所需的是类似于
    Express 路由函数的，因此从 `Socket.IO` 客户端发送/接收消息的代码也将位于路由模块中。
- en: 'We haven''t written either of these functions yet (have patience). To support
    this, we need to make a change in an `import` statement at the top:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有编写这两个函数（请耐心等待）。为了支持这一点，我们需要在顶部的 `import` 语句中进行更改：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each router module will export a function named `socketio`, which we'll have
    to rename as shown here. This function is what will receive the `io` object, and
    handle any `Socket.IO`-based communications. We haven't written these functions
    yet.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由模块将导出一个名为 `socketio` 的函数，我们将需要将其重命名，如下所示。这个函数将接收 `io` 对象，并处理任何基于 `Socket.IO`
    的通信。我们还没有编写这些函数。
- en: 'Then, at the end of `app.mjs`, we''ll copy in the remaining code from `bin/www.mjs`
    so the HTTP Server starts listening on our selected port:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `app.mjs` 文件的末尾，我们将复制来自 `bin/www.mjs` 的剩余代码，这样 HTTP 服务器就会在我们的选定端口上监听：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, in `package.json`, we must start `app.mjs` rather than `bin/www.mjs`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `package.json` 文件中，我们必须启动 `app.mjs` 而不是 `bin/www.mjs`：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this point, you can delete `bin/www.mjs` if you like. You can also try starting
    the server, but it'll fail because the `indexSocketio` function does not exist
    yet.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你愿意，可以删除 `bin/www.mjs`。你也可以尝试启动服务器，但它会失败，因为 `indexSocketio` 函数尚不存在。
- en: Real-time updates on the Notes homepage
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Notes 主页的实时更新
- en: The goal we're working towards is for the Notes home page to automatically update
    the list of notes, as notes are edited or deleted. What we've done so far is to
    restructure the application startup so that `Socket.IO` is initialized in the
    Notes application. There's no change of behavior yet, except that it will crash
    due to a missing function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在努力实现的目标是 Notes 主页能够自动更新笔记列表，当笔记被编辑或删除时。我们迄今为止所做的是重构应用程序启动，以便在 Notes 应用程序中初始化
    `Socket.IO`。目前还没有行为上的变化，除了它将因为缺少函数而崩溃。
- en: The approach is for the Notes model classes to send messages whenever a note
    is created, updated, or deleted. In the router classes, we'll listen to those
    messages, then send a list of note titles to all browsers attached to the Notes
    application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是在笔记被创建、更新或删除时，Notes 模型类发送消息。在路由类中，我们将监听这些消息，然后将笔记标题列表发送给所有连接到 Notes 应用的浏览器。
- en: Where the Notes model so far has been a passive repository of documents, it
    now needs to emit events to any interested parties. This is the listener pattern
    and, in theory, there will be code that is interested in knowing when notes are
    created, edited, or destroyed. At the moment, we'll use that knowledge to update
    the Notes home page, but there are many potential other uses of that knowledge.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Notes 模型一直是一个被动的文档存储库，现在它需要向任何感兴趣的各方发出事件。这是监听器模式，从理论上讲，将会有代码对了解笔记何时被创建、编辑或销毁感兴趣。目前，我们将利用这一知识来更新
    Notes 主页，但还有许多其他潜在的应用。
- en: The Notes model as an EventEmitter class
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Notes 模型作为一个 `EventEmitter` 类
- en: 'The `EventEmitter` is the class that implements listener support. Let''s create
    a new module, `models/notes-events.mjs`, containing the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` 是实现监听器支持的类。让我们创建一个新的模块，`models/notes-events.mjs`，包含以下内容：'
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This module maintains the listeners to Notes-related events for us. We've created
    a subclass of `EventEmitter` because it already knows how to manage the listeners.
    An instance of that object is exported as the default export.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块为我们维护与 Notes 相关事件的监听器。我们创建了一个 `EventEmitter` 的子类，因为它已经知道如何管理监听器。该对象的实例作为默认导出。
- en: Let's now update `models/notes.mjs` to use `notes-events` to emit events. Because
    we have a single module, `notes.mjs`, to dispatch calls to the individual Notes
    models, this module provides a key point at which we can intercept the operations
    and send events. Otherwise, we'd have to integrate the event-sending code into
    every Notes model.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新 `models/notes.mjs` 以使用 `notes-events` 来发送事件。因为我们有一个单独的模块 `notes.mjs`，用于将调用分发给各个
    Notes 模型，这个模块提供了一个关键点，我们可以在这里拦截操作并发送事件。否则，我们就必须将事件发送代码集成到每个 Notes 模型中。
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We need to `import` this module for use here, but also export it so that other
    modules can also emit Notes events. By doing this, another module that imports
    Notes can call `notes.events.function` to use the `notes-events` module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `import` 这个模块以在此处使用，同时也需要导出它，以便其他模块也可以发送 Notes 事件。通过这样做，另一个导入 Notes 的模块可以调用
    `notes.events.function` 来使用 `notes-events` 模块。
- en: This technique is called **re-exporting**. Sometimes, you need to export a function
    from module *A* that is actually defined in module *B*. Module *A* therefore imports
    the function from module *B*, adding it to its exports.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为 **重新导出**。有时，你需要从模块 *A* 导出一个实际上定义在模块 *B* 中的函数。因此，模块 *A* 从模块 *B* 导入该函数，并将其添加到其导出中。
- en: 'Then we do a little rewriting of these functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对这些函数进行了一些修改：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The contract for the Notes model functions is that they return a `Promise,`
    and therefore our caller will be using `await` to resolve the `Promise.` There
    are three steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Notes 模型函数的合约是它们返回一个 `Promise`，因此我们的调用者将使用 `await` 来解析这个 `Promise`。这里有三个步骤：
- en: Call the corresponding function in the current `model` class, and `await` its
    result
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用当前 `model` 类中的相应函数，并 `await` 它的结果
- en: Send the corresponding message to our listeners
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的监听器发送相应的消息
- en: Return the value, and because this is an `async` function, the value will be
    received as a `Promise` that fulfills the contract for these functions
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回值，因为这是一个 `async` 函数，所以值将以 `Promise` 的形式接收，并满足这些函数的合约
- en: Real-time changes in the Notes home page
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Notes 主页的实时更改
- en: The Notes model now sends events as Notes are created, updated, or destroyed.
    For this to be useful, the events must be displayed to our users. Making the events
    visible to our users means the controller and view portions of the application
    must consume those events.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Notes 模型现在在 Notes 创建、更新或销毁时发送事件。为了使其有用，这些事件必须显示给我们的用户。让事件对用户可见意味着应用程序的控制器和视图部分必须消费这些事件。
- en: 'Let''s start making changes to `routes/index.mjs`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改 `routes/index.mjs` 开始：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We need to reuse part of the original routing function, to use it in another
    function. Therefore, we''ve pulled code that used to be in this block into a new
    function, `getKeyTitlesList`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重用原始路由函数的一部分，以便在另一个函数中使用它。因此，我们将原本位于此块中的代码抽取到一个新的函数中，名为 `getKeyTitlesList`：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This portion of the original routing function is now its own function. It generates
    an array of items containing the `key` and `title` for all existing Notes, using
    `Promise.all` to manage the process of reading everything.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 原始路由函数的这一部分现在是一个独立的函数。它使用 `Promise.all` 来管理读取所有内容的流程，生成一个包含所有现有 Notes 的 `key`
    和 `title` 的项目数组。
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here is the `socketio` function we discussed while modifying `app.mjs`. We receive
    the `io` object, then use it to emit a `notestitles` event to all connected browsers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们在修改 `app.mjs` 时讨论的 `socketio` 函数。我们接收 `io` 对象，然后使用它向所有连接的浏览器发出 `notestitles`
    事件。
- en: The `io.of('/namespace')` method restricts whatever follows to the given namespace.
    In this case, we're emitting a `notestitle` message to the `/home` namespace.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.of(''/namespace'')` 方法限制了后续操作只能在该指定的命名空间内进行。在这种情况下，我们向 `/home` 命名空间发送了一个
    `notestitle` 消息。'
- en: The `io.of` method defines what `Socket.IO` calls a namespace. Namespaces limit
    the scope of messages sent through `Socket.IO`. The default namespace is `/`,
    and namespaces look like pathnames, in that they're a series of slash-separated
    names. An event emitted into a namespace is delivered to any socket listening
    to that namespace.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.of` 方法定义了 `Socket.IO` 所称的命名空间。命名空间限制了通过 `Socket.IO` 发送的消息的作用域。默认命名空间是 `/`，命名空间看起来像路径名，因为它们是一系列由斜杠分隔的名称。向命名空间发出的任何事件都会发送到监听该命名空间的任何套接字。'
- en: The code, in this case, is fairly straightforward. It listens to the events
    we just implemented, `notecreated`, `noteupdate`, and `notedestroy`. For each
    of these events, it emits an event, `notetitles`, containing the list of note
    keys and titles.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码，在这种情况下，相当直接。它监听我们刚刚实现的事件，`notecreated`、`noteupdate` 和 `notedestroy`。对于这些事件中的每一个，它都会发出一个包含笔记键和标题列表的事件
    `notetitles`。
- en: That's it!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！
- en: As Notes are created, updated, and destroyed, we ensure that the homepage will
    be refreshed to match. The homepage template, `views/index.hbs`, will require
    code to receive that event and rewrite the page to match.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 随着笔记的创建、更新和删除，我们确保主页会相应刷新。主页模板`views/index.hbs`将需要代码来接收该事件并重写页面以匹配。
- en: Changing the homepage and layout templates
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改主页和布局模板
- en: '`Socket.IO` runs on both client and server, with the two communicating back
    and forth over the HTTP connection. This requires loading the client JavaScript
    library into the client browser. Each page of the Notes application in which we
    seek to implement `Socket.IO` services must load the client library and have custom
    client code for our application.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Socket.IO`在客户端和服务器上运行，两者通过HTTP连接来回通信。这需要在客户端浏览器中加载客户端JavaScript库。我们希望在实现`Socket.IO`服务的笔记应用的每个页面上，都必须加载客户端库并具有针对我们应用的定制客户端代码。'
- en: Each page in Notes will require a different `Socket.IO` client implementation,
    since each page has different requirements. This affects how we load JavaScript
    code in Notes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Notes中的每个页面都需要不同的`Socket.IO`客户端实现，因为每个页面有不同的要求。这影响了我们在Notes中加载JavaScript代码的方式。
- en: Initially, we simply put JavaScript code at the bottom of `layout.hbs`, because
    every page required the same set of JavaScript modules. But now we've identified
    the need for a different set of JavaScript on each page. Furthermore, some of
    the JavaScript needs to be loaded following the JavaScript currently loaded at
    the bottom of `layout.hbs`. Specifically, jQuery is loaded currently in `layout.hbs`,
    but we want to use jQuery in the `Socket.IO` clients to perform DOM manipulations
    on each page. Therefore, some template refactoring is required.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们只是在`layout.hbs`的底部放置JavaScript代码，因为每个页面都需要相同的JavaScript模块集。但现在我们已经确定了每个页面需要不同的JavaScript集合。此外，一些JavaScript需要在`layout.hbs`底部当前加载的JavaScript之后加载。具体来说，jQuery目前是在`layout.hbs`中加载的，但我们希望在`Socket.IO`客户端中使用jQuery在每个页面上执行DOM操作。因此，需要进行一些模板重构。
- en: 'Create a file, `partials/footerjs.hbs`, containing:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文件，`partials/footerjs.hbs`，包含以下内容：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This had been at the bottom of `views/layout.hbs`. We now need to modify that
    file as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这之前是在`views/layout.hbs`的底部。我们现在需要按照以下方式修改该文件：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, at the bottom of every template (`error.hbs`, `index.hbs`, `login.hbs`,
    `notedestroy.hbs`, `noteedit.hbs`, and `noteview.hbs`), add this line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每一个模板（`error.hbs`、`index.hbs`、`login.hbs`、`notedestroy.hbs`、`noteedit.hbs`和`noteview.hbs`）的底部添加以下行：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So far, this hasn't changed what will be loaded in the pages, because `footerjs`
    contains exactly what was already at the bottom of `layout.hbs`. But it gives
    us the freedom to load `Socket.IO` client code after the scripts in `footerjs`
    are loaded.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这还没有改变页面中将要加载的内容，因为`footerjs`包含的正是`layout.hbs`底部的原有内容。但它给了我们加载`Socket.IO`客户端代码的自由，在`footerjs`中的脚本加载之后。
- en: 'In `views/index.hbs` add this at the bottom, after the `footerjs` partial:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views/index.hbs`的底部添加以下内容，在`footerjs`部分之后：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line is where we load the `Socket.IO` client library. You'll notice
    that we never set up any Express route to handle the `/socket.io` URL. Instead,
    the `Socket.IO` library did that for us.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是我们加载`Socket.IO`客户端库的地方。你会注意到我们从未设置任何Express路由来处理`/socket.io` URL。相反，`Socket.IO`库为我们完成了这项工作。
- en: Because we've already loaded jQuery (to support Bootstrap), we can easily ensure
    that this code is executed once the page is fully loaded using `$(document).ready`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经加载了jQuery（以支持Bootstrap），我们可以轻松确保使用`$(document).ready`在页面完全加载后执行此代码。
- en: This code first connects a `socket` object to the `/home` namespace. That namespace
    is being used for events related to the Notes homepage. We then listen for the
    `notetitles` events, for which some jQuery DOM manipulation erases the current
    list of Notes and renders a new list on the screen.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先将一个`socket`对象连接到`/home`命名空间。该命名空间用于与笔记主页相关的事件。然后我们监听`notetitles`事件，对于该事件，一些jQuery
    DOM操作会清除当前笔记列表并在屏幕上渲染新的列表。
- en: That's it. Our code in `routes/index.mjs` listened to various events from the
    Notes model, and, in response, sent a `notetitles` event to the browser. The browser
    code takes that list of note information and redraws the screen.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们`routes/index.mjs`中的代码监听了笔记模型的各种事件，并相应地向浏览器发送了`notetitles`事件。浏览器代码接收该笔记信息列表并重新绘制屏幕。
- en: You might notice that our browser-side JavaScript is not using ES-2015/2016/2017
    features. This code would, of course, be cleaner if we were to do so. How can
    we know whether our visitors use a browser modern enough for those language features? 
    We could use Babel to transpile ES-2015/2016/2017 code into ES5 code capable of
    running on any browser. However, it may be a useful trade-off to still write ES5
    code in the browser.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我们的浏览器端JavaScript没有使用ES-2015/2016/2017特性。当然，如果我们这样做，代码会更为简洁。我们如何知道我们的访客是否使用足够现代的浏览器来支持这些语言特性呢？我们可以使用Babel将ES-2015/2016/2017代码转换为任何浏览器都能运行的ES5代码。然而，在浏览器中仍然编写ES5代码可能是一个有用的权衡。
- en: Running Notes with real-time homepage updates
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行带有实时主页更新的笔记
- en: We now have enough implemented to run the application and see some real-time
    action.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了足够的功能来运行应用程序并看到一些实时动作。
- en: 'As you did earlier, start the user information microservice in one window:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你之前做的那样，在一个窗口中启动用户信息微服务：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, in another window, start the Notes application:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个窗口中，启动笔记应用程序：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, in a browser window, go to `http://localhost:3000` and log in to the Notes
    application. To see the real-time effects, open multiple browser windows. If you
    can use Notes from multiple computers, then do that as well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在浏览器窗口中，转到`http://localhost:3000`并登录到笔记应用程序。为了看到实时效果，请打开多个浏览器窗口。如果您可以从多台计算机上使用笔记，那么也请这样做。
- en: In one browser window, start creating and deleting notes, while leaving the
    other browser windows viewing the home page. Create a note, and it should show
    up immediately on the home page in the other browser windows. Delete a note and it
    should disappear immediately as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个浏览器窗口中，开始创建和删除笔记，同时让其他浏览器窗口查看主页。创建一个笔记，它应该立即在另一个浏览器窗口的主页上显示。删除一个笔记，它应该立即消失。
- en: Real-time action while viewing notes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看笔记时的实时动作
- en: 'It''s cool how we can now see real-time changes in a part of the Notes application.
    Let''s turn to the `/notes/view` page to see what we can do. What comes to mind
    is this functionality:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到笔记应用中某个部分的实时变化真是太酷了。让我们转到`/notes/view`页面看看我们能做什么。想到的功能如下：
- en: Update the note if someone else edits it
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其他人编辑了笔记，则更新笔记
- en: Redirect the viewer to the home page if someone else deletes the note
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其他人删除了笔记，则将查看者重定向到主页
- en: Allow users to leave comments on the note
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户在笔记上留下评论
- en: For the first two features, we can rely on the existing events coming from the
    Notes model. The third feature will require a messaging subsystem, so we'll get
    to that later in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前两个功能，我们可以依赖于来自笔记模型的现有事件。第三个功能将需要一个消息子系统，所以我们将在本章稍后讨论。
- en: 'In `routes/notes.mjs`, add this to the end of the module:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/notes.mjs`中，将以下内容添加到模块的末尾：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'At the top of `app.mjs,` make this change:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.mjs`的顶部，进行以下修改：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Uncomment that line of code in `app.mjs` because we''ve now implemented the
    function we said we''d get to later:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.mjs`中取消注释那一行代码，因为我们现在已经实现了我们稍后要实现的功能：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This sets up the Notes application to send `noteupdate` and `notedestroy` messages
    when notes are updated or destroyed. The destination is the `/view` namespace.
    We'll need to make a corresponding modification to the note view template so it
    does the right thing. This means any browser viewing any note in the application
    will connect to this namespace. Every such browser will receive events about any
    note being changed, even those notes that are not being viewed. This means that
    the client code will have to check the key, and only take action if the event
    refers to the note being displayed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得笔记应用程序在笔记更新或销毁时发送`noteupdate`和`notedestroy`消息。目的地是`/view`命名空间。我们需要对笔记视图模板进行相应的修改，以便它能够正确处理。这意味着任何查看应用程序中任何笔记的浏览器都将连接到这个命名空间。每个这样的浏览器都将接收到有关任何笔记更改的事件，即使这些笔记没有被查看。这意味着客户端代码将不得不检查键，并且只有当事件指的是正在显示的笔记时才采取行动。
- en: Changing the note view template for real-time action
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为实时动作更改笔记视图模板
- en: 'As we did earlier, in order to make these events visible to the user, we must
    not only add client code to the template, `views/noteview.hbs`; we need a couple
    of small changes to the template:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，为了使用户能够看到这些事件，我们不仅需要在模板中添加客户端代码到`views/noteview.hbs`，还需要对模板进行一些小的修改：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We connect to the `/view` namespace where the messages are sent. As `noteupdate`
    or `notedestroy` messages arrive, we check the key to see whether it matches the
    key for the note being displayed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们连接到`/view`命名空间，消息就是从这里发送的。当`noteupdate`或`notedestroy`消息到达时，我们检查键值以确定它是否与正在显示的笔记的键值匹配。
- en: A technique is used here that's important to understand. We have mixed JavaScript
    executed on the server, with JavaScript executed in the browser. We must compare
    the `notekey` received by the client code against the `notekey` for the note being
    viewed by this page. The latter `notekey` value is known on the server, while
    the former is known in the client.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了一种重要的技术，需要理解。我们在服务器上混合了执行的JavaScript，以及在浏览器中执行的JavaScript。我们必须将客户端代码接收到的`notekey`与该页面正在查看的笔记的`notekey`进行比较。后者`notekey`值在服务器上是已知的，而前者是在客户端知道的。
- en: 'Remember that code within the `{{ .. }}` delimiters is interpreted by the Handlebars
    template engine on the server. Consider the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在`{{ .. }}`定界符内的代码是由服务器上的Handlebars模板引擎进行解释的。考虑以下内容：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This comparison is between the `notekey` value in the browser, which arrived inside
    the message from the server, and the `notekey` variable on the server. That variable
    contains the key of the note being displayed. Therefore, in this case, we are
    able to ensure these code snippets are executed only for the note being shown
    on the screen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较是在浏览器中到达的消息中的`notekey`值和服务器上的`notekey`变量之间进行的。该变量包含正在显示的笔记的键值。因此，在这种情况下，我们能够确保这些代码片段仅针对屏幕上显示的笔记执行。
- en: For the `noteupdate` event, we take the new note content and display it on the
    screen. For this to work, we had to add `id=` attributes to the HTML so we could
    use jQuery selectors in manipulating the DOM.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`noteupdate`事件，我们取新的笔记内容并在屏幕上显示。为了实现这一点，我们必须添加`id=`属性到HTML中，这样我们就可以使用jQuery选择器来操作DOM。
- en: For the `notedestroy` event, we simply redirect the browser window back to the
    home page. The note being viewed has been deleted, and there's no point the user
    continuing to look at a note that no longer exists.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`notedestroy`事件，我们简单地让浏览器窗口返回主页。被查看的笔记已被删除，用户继续查看一个不再存在的笔记是没有意义的。
- en: Running Notes with real-time updates while viewing a note
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在查看笔记的同时运行带有实时更新的笔记
- en: At this point, you can now rerun the Notes application and try this out.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你现在可以重新运行笔记应用并尝试这个功能。
- en: Launch the user authentication server and the Notes application as before. Then,
    in the browser, open multiple windows on the Notes application. This time, have
    one viewing the home page, and two viewing a note. In one of those windows, edit
    the note to make a change, and see the text change on both the home page and the
    page viewing the note.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的方式启动用户身份验证服务器和笔记应用。然后在浏览器中，打开多个笔记应用的窗口。这次，让一个窗口显示主页，另外两个窗口显示笔记。在其中一个窗口中编辑笔记以进行更改，并观察主页和查看笔记的页面上的文本是否发生了变化。
- en: Then delete the note, and watch it disappear from the home page, and the browser
    window that had viewed the note is now on the home page.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后删除笔记，观察它从主页消失，以及查看笔记的浏览器窗口现在显示在主页上。
- en: Inter-user chat and commenting for Notes
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为笔记实现用户间聊天和评论
- en: This is cool! We now have real-time updates in Notes as we edit delete or create
    notes. Let's now take it to the next level and implement something akin to inter-user
    chatting.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷！我们现在在编辑、删除或创建笔记时，笔记中有了实时更新。现在让我们将其提升到下一个层次，并实现类似用户间聊天的功能。
- en: It's possible to pivot our Notes application concept and take it in the direction
    of a social network. In the majority of such networks, users post things (notes,
    pictures, videos, and so on), and other users comment on those things. Done well,
    these basic elements can develop a large community of people sharing notes with
    each other. While the Notes application is kind of a toy, it's not too terribly
    far from being a basic social network. Commenting the way we will do now is a
    tiny step in that direction.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将笔记应用的概念进行转型，并朝着社交网络的方向发展。在大多数这样的网络中，用户发布内容（笔记、图片、视频等），其他用户对这些内容进行评论。如果做得好，这些基本元素可以发展成为一个大型社区，人们相互分享笔记。虽然笔记应用有点像玩具，但它并不太远离成为一个基本社交网络。我们现在进行的评论方式是朝着这个方向迈出的一小步。
- en: On each note page, we'll have an area to display messages from Notes users.
    Each message will show the username, a timestamp, and their message. We'll also
    need a method for users to post a message, and we'll also allow users to delete
    messages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个笔记页面上，我们将有一个区域来显示Notes用户的消息。每条消息将显示用户名、时间戳以及他们的消息。我们还需要一个方法让用户发布消息，并允许用户删除消息。
- en: Each of those operations will be performed without refreshing the screen. Instead,
    code running inside the web page will send commands to/from the server and take
    actions dynamically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作将在不刷新屏幕的情况下执行。相反，运行在网页内部的代码将向服务器发送命令并动态地采取行动。
- en: Let's get started.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Data model for storing messages
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储消息的数据模型
- en: We need to start by implementing a data model for storing messages. The basic fields
    required are a unique ID, the username of the person sending the message, the
    namespace the message is sent to, their message, and finally a timestamp for when
    the message was sent. As messages are received or deleted, events must be emitted
    from the model so we can do the right thing on the web page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先实现一个用于存储消息的数据模型。所需的基本字段包括一个唯一的ID、发送消息的人的用户名、消息发送到的命名空间、他们的消息，以及最后一条消息发送的时间戳。当收到或删除消息时，模型必须发出事件，以便我们可以在网页上执行正确的操作。
- en: This model implementation will be written for `Sequelize`. If you prefer a different
    storage solution, you can , by all means, re-implement the same API on other data
    storage systems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型实现将针对`Sequelize`编写。如果你更喜欢其他存储解决方案，你可以完全在其他的数据库存储系统中重新实现相同的API。
- en: 'Create a new file, `models/messages-sequelize.mjs`, containing the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`models/messages-sequelize.mjs`，包含以下内容：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This sets up the modules being used and also initializes the `EventEmitter`
    interface. We''re also exporting the `EventEmitter` as `emitter` so other modules
    can use it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了正在使用的模块，并初始化了`EventEmitter`接口。我们还导出了`EventEmitter`作为`emitter`，以便其他模块可以使用它：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This defines our message schema in the database. We'll use the same database
    that we used for Notes, but the messages will be stored in their own table.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了我们在数据库中的消息模式。我们将使用与Notes相同的数据库，但消息将存储在自己的表中。
- en: 'The `id` field won''t be supplied by the caller; instead, it will be autogenerated.
    Because it is an `autoIncrement` field, each message that''s added will be assigned a
    new `id` number by the database:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`字段将由调用者提供；相反，它将自动生成。因为它是一个`autoIncrement`字段，所以数据库将为添加的每条消息分配一个新的`id`号：'
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is to be called when a user posts a new comment/message. We first store
    it in the database, and then we emit an event saying the message was created:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户发布新的评论/消息时，应该调用此操作。我们首先将其存储在数据库中，然后发出一个事件表示消息已被创建：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is to be called when a user requests that a message should be deleted.
    With `Sequelize`, we must first find the message and then delete it by calling
    its `destroy` method. Once that''s done, we emit a message saying the message
    was destroyed:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户请求删除消息时，应该调用此操作。使用`Sequelize`，我们必须首先找到消息，然后通过调用其`destroy`方法来删除它。一旦完成，我们发出一个消息表示消息已被销毁：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While this is meant to be called when viewing a note, it is generalized to work
    for any Socket.IO namespace. It finds the most recent 20 messages associated with
    the given namespace and returns a cleaned-up list to the caller.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是在查看笔记时调用的，但它被通用化以适用于任何Socket.IO命名空间。它找到与给定命名空间关联的最新的20条消息，并将清理后的列表返回给调用者。
- en: Adding messages to the Notes router
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Notes路由添加消息
- en: Now that we can store messages in the database, let's integrate this into the
    Notes router module.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在数据库中存储消息了，让我们将其集成到Notes路由模块中。
- en: 'In `routes/notes.mjs`, add this to the `import` statements:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/notes.mjs`中，将以下内容添加到`import`语句中：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you wish to implement a different data storage model for messages, you''ll
    need to change this `import` statement. You should consider using an environment
    variable to specify the module name, as we''ve done elsewhere:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望为消息实现不同的数据存储模型，你需要更改这个`import`语句。你应该考虑使用环境变量来指定模块名称，就像我们在其他地方所做的那样：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This pair of routes, `/notes/make-comment` and `/notes/del-message`, is used
    to post a new comment or delete an existing one. Each calls the corresponding
    data model function and then sends an appropriate response back to the caller.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这对路由`/notes/make-comment`和`/notes/del-message`用于发布新的评论或删除现有的评论。每个都调用相应的数据模型函数，然后向调用者发送适当的响应。
- en: Remember that `postMessage` stores a message in the database, and then it turns
    around and emits that message to other browsers. Likewise, `destroyMessage` deletes
    the message from the database, then emits a message to other browsers saying that
    the message has been deleted. Finally, the results from `recentMessages` will
    reflect the current set of messages in the database.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`postMessage`将消息存储在数据库中，然后它转身向其他浏览器发出该消息。同样，`destroyMessage`从数据库中删除消息，然后向其他浏览器发出一条消息，表示该消息已被删除。最后，`recentMessages`的结果将反映数据库中的当前消息集。
- en: 'Both of these will be called by AJAX code in the browser:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都会由浏览器中的AJAX代码调用：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is the Socket.IO glue code, which we will add to the code we looked at
    earlier.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要添加到之前查看的代码中的Socket.IO粘合代码。
- en: The `getnotemessages` message from the browser requests the list of messages
    for the given Note. This calls the `recentMessages` function in the model. This
    uses a feature of Socket.IO where the client can pass a callback function, and
    server-side Socket.IO code can invoke that callback, giving it some data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 来自浏览器的`getnotemessages`消息请求给定笔记的消息列表。这调用模型中的`recentMessages`函数。这使用了Socket.IO的一个特性，客户端可以传递一个回调函数，服务器端Socket.IO代码可以调用该回调，并给它一些数据。
- en: We also listen to the `newmessage` and `destroymessage` messages emitted by
    the messages model, sending corresponding messages to the browser. These are sent
    using the method described earlier.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还监听由消息模型发出的`newmessage`和`destroymessage`消息，向浏览器发送相应的消息。这些消息使用之前描述的方法发送。
- en: Changing the note view template for messages
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改消息视图模板
- en: We need to dive back into `views/noteview.hbs` with more changes so that we
    can view, create, and delete messages. This time, we will add a lot of code, including
    using a Bootstrap modal popup to get the message, several AJAX calls to communicate
    with the server, and, of course, more Socket.IO stuff.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要回到`views/noteview.hbs`进行更多更改，以便我们可以查看、创建和删除消息。这次，我们将添加很多代码，包括使用Bootstrap
    modal弹出窗口获取消息，几个与服务器通信的AJAX调用，当然，还有更多的Socket.IO内容。
- en: Using a Modal window to compose messages
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Modal窗口来撰写消息
- en: The Bootstrap framework has a Modal component that serves a similar purpose to
    Modal dialogs in desktop applications. You pop up the Modal, it prevents interaction
    with other parts of the web page, you enter stuff into fields in the Modal, and
    then click a button to make it close.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap框架有一个Modal组件，它在桌面应用程序的Modal对话框中起到类似的作用。你弹出Modal，它阻止与其他网页部分的交互，你将内容输入到Modal中的字段，然后点击一个按钮使其关闭。
- en: 'This new segment of code replaces the existing segment defining the Edit and Delete
    buttons, in `views/noteview.hbs`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码替换了在`views/noteview.hbs`中定义的现有编辑和删除按钮段：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This adds support for posting comments on a note. The user will see a Modal
    pop-up window in which they write their comment. We'll show the code for the Modal
    later.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了在笔记上发布评论的支持。用户将看到一个Modal弹出窗口，在其中他们可以写下他们的评论。我们稍后会展示Modal的代码。
- en: We added a new button labeled Comment that the user will click to start the
    process of posting a message. This button is connected to the Modal by way of
    the element ID specified in the `data-target` attribute. The ID will match the
    outermost `div` wrapping the Modal. This structure of `div` elements and class
    names are from the Bootstrap website at [http://getbootstrap.com/docs/4.0/components/modal/](http://getbootstrap.com/docs/4.0/components/modal/).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的按钮，标签为“评论”，用户将点击它以开始发布消息的过程。这个按钮通过`data-target`属性中指定的元素ID与Modal连接。ID将与包裹Modal的最外层`div`匹配。这种`div`元素和类名的结构来自Bootstrap网站[http://getbootstrap.com/docs/4.0/components/modal/](http://getbootstrap.com/docs/4.0/components/modal/)。
- en: Let's add the code for the Modal at the bottom of `views/noteview.hbs`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`views/noteview.hbs`的底部添加Modal的代码。
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The key portion of this is the HTML form contained within the `div.modal-body`
    element. It's a straightforward, normal Bootstrap, augmented form with a normal
    Submit button at the bottom. A few hidden `input` elements are used to pass extra
    information inside the request.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键部分是包含在`div.modal-body`元素内的HTML表单。它是一个简单、正常的Bootstrap增强表单，底部有一个正常的提交按钮。几个隐藏的`input`元素用于在请求中传递额外信息。
- en: With the HTML set up this way, Bootstrap will ensure that this Modal is triggered
    when the user clicks on the Comment button. The user can close the Modal by clicking
    on the Close button. Otherwise, it's up to us to implement code to handle the
    form submission using AJAX so that it doesn't cause the page to reload.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式设置HTML后，Bootstrap将确保当用户点击评论按钮时触发此模态。用户可以通过点击关闭按钮来关闭模态。否则，我们需要实现代码来处理表单的AJAX提交，以避免页面重新加载。
- en: Sending, displaying, and deleting messages
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送、显示和删除消息
- en: Note that these code snippets are wrapped with `{{#if}}` statements, so that
    certain user interface elements are displayed only to sufficiently privileged
    users. A user that isn't logged in certainly shouldn't be able to post a message.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些代码片段被`{{#if}}`语句包裹，这样只有足够权限的用户才能显示某些用户界面元素。未登录的用户当然不应该能够发布消息。
- en: 'Now we have a lot of Socket.IO code to add:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有很多Socket.IO代码要添加：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's another code section to handle the `noteupdate` and `notedestroy` messages.
    This new section has to do with messages that manage the comments.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个代码部分用于处理`noteupdate`和`notedestroy`消息。这个新部分与处理评论的消息有关。
- en: 'We need to handle the form submission for posting a new comment, get the recent
    messages when first viewing a note, listen for events from the server about new
    messages or deleted messages, render the messages on the screen, and handle requests
    to delete a message:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理发布新评论的表单提交，在首次查看笔记时获取最近的消息，监听来自服务器的新消息或删除消息的事件，在屏幕上渲染消息，并处理删除消息的请求：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The code within `$('form#submit-comment').submit` handles the form submission
    for the comment form. Because we already have jQuery available, we can use its
    AJAX support to POST a request to the server without causing a page reload.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(''form#submit-comment'').submit`中的代码处理评论表单的表单提交。因为我们已经有了jQuery，我们可以使用它的AJAX支持向服务器发送请求，而不会导致页面重新加载。'
- en: Using `event.preventDefault`, we ensure that the default action does not occur.
    For the FORM submission, that means the browser page does not reload. What happens
    is an HTTP POST is sent to `/notes/make-comment` with a data payload consisting
    of the values of the form's `input` elements. Included in those values are three
    hidden inputs, `from`, `namespace`, and `key`, providing useful identification
    data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`event.preventDefault`，我们确保默认操作不会发生。对于表单提交，这意味着浏览器页面不会重新加载。实际上，会向`/notes/make-comment`发送一个HTTP
    POST请求，其中包含表单`input`元素的值作为数据负载。这些值中包含三个隐藏的输入，`from`、`namespace`和`key`，提供了有用的标识数据。
- en: If you refer to the `/notes/make-comment` route definition, this calls `messagesModel.postMessage`
    to store the message in the database. That function then posts an event, `newmessage`,
    which our server-side code forwards to any browser that's connected to the namespace.
    Shortly after that, a `newmessage` event will arrive in browsers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参考了`/notes/make-comment`路由定义，这将调用`messagesModel.postMessage`将消息存储到数据库中。然后该函数发布一个事件，`newmessage`，我们的服务器端代码将其转发到连接到命名空间的任何浏览器。在此之后不久，浏览器将收到一个`newmessage`事件。
- en: The `newmessage` event adds a message block, using the `formatMessage` function.
    The HTML for the message is `prepend`ed to `#noteMessages`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`newmessage`事件通过`formatMessage`函数添加一个消息块。消息的HTML被`prepend`到`#noteMessages`。'
- en: When the page is first loaded, we want to retrieve the current messages. This
    is kicked off with `io('/view').emit('getnotemessages', ..`. This function, as
    the name implies, sends a `getnotemessages` message to the server. We showed the
    implementation of the server-side handler for this message earlier, in `routes/notes.mjs`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面首次加载时，我们希望检索当前的消息。这是通过`io('/view').emit('getnotemessages', ..`触发的。这个函数，正如其名所示，向服务器发送一个`getnotemessages`消息。我们之前已经展示了处理此消息的服务器端处理程序的实现，在`routes/notes.mjs`中。
- en: If you remember, we said that Socket.IO supports the provision of a callback
    function that is called by the server in response to an event. You simply pass
    a function as the last parameter to a `.emit` call. That function is made available
    at the other end of the communication, to be called when appropriate. To make
    this clear, we have a callback function on the browser being invoked by server-side
    code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们说过Socket.IO支持提供由服务器在响应事件时调用的回调函数。你只需将一个函数作为`.emit`调用的最后一个参数传递。该函数在通信的另一端可用，以便在适当的时候调用。为了使这一点更清晰，我们在浏览器端有一个由服务器端代码调用的回调函数。
- en: In this case, the server-side calls our callback function with a list of messages.
    The message list arrives in the client-side callback function, which displays
    them in the `#noteMessages` area. It uses jQuery DOM manipulation to erase any
    existing messages, then renders each message into the messages area using the
    `formatMessage` function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务器端调用我们的回调函数，传递一个消息列表。消息列表到达客户端回调函数，它在`#noteMessages`区域显示它们。它使用jQuery
    DOM操作擦除任何现有消息，然后使用`formatMessage`函数将每条消息渲染到消息区域。
- en: The message display template, in `formatMessage`, is straightforward. It uses
    a Bootstrap `card` to give a nice visual effect. And, there is a button for deleting
    messages.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 消息显示模板在`formatMessage`中很简单。它使用Bootstrap `card`来提供良好的视觉效果。还有一个用于删除消息的按钮。
- en: In `formatMessage` we created a Delete button for each message. Those buttons
    need an event handler, and the event handler is set up using the `connectMsgDelButton`
    function. In this case, we send an HTTP POST request to `/notes/del-message`.
    We again use the jQuery AJAX support to post that HTTP request.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`formatMessage`中，我们为每条消息创建了一个删除按钮。这些按钮需要一个事件处理程序，事件处理程序是通过`connectMsgDelButton`函数设置的。在这种情况下，我们向`/notes/del-message`发送一个HTTP
    POST请求。我们再次使用jQuery AJAX支持来发送该HTTP请求。
- en: The `/notes/del-message` route in turn calls `messagesModel.destroyMessage`
    to do the deed. That function then emits an event, `destroymessage`, which gets
    sent back to the browser. As you see here, the `destroymessage` event handler
    causes the corresponding message to be removed using jQuery DOM manipulation.
    We were careful to add an `id=` attribute to every message to make removal easy.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`/notes/del-message`路由反过来调用`messagesModel.destroyMessage`来完成这项任务。该函数随后发出一个事件，`destroymessage`，该事件被发送回浏览器。正如你所看到的，`destroymessage`事件处理程序使用jQuery
    DOM操作移除相应的消息。我们小心地为每条消息添加了一个`id`属性，以便于移除。'
- en: Since the flip side of destruction is creation, we need to have the `newmessage`
    event handler sitting next to the `destroymessage` event handler. It also uses
    jQuery DOM manipulation to insert the new message into the `#noteMessages` area.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于毁灭的背面是创造，我们需要让`newmessage`事件处理程序紧挨着`destroymessage`事件处理程序。它还使用jQuery DOM操作将新消息插入到`#noteMessages`区域。
- en: Running Notes and passing messages
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行笔记并传递消息
- en: That was a lot of code, but we now have the ability to compose messages, display
    them on the screen, and delete them, all with no page reloads.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很多，但我们现在有了编写消息、在屏幕上显示它们以及删除它们的能力，而且无需页面刷新。
- en: 'You can run the application as we did earlier, first starting the user authentication
    server in one command-line window and the Notes application in another:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像我们之前做的那样运行应用程序，首先在一个命令行窗口中启动用户认证服务器，然后在另一个窗口中启动笔记应用程序：
- en: '![](img/e3ac8ba6-abbb-4615-8d9a-9af3c4f8a538.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3ac8ba6-abbb-4615-8d9a-9af3c4f8a538.png)'
- en: 'While entering a message, the Modal looks like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入消息时，模态窗口看起来是这样的：
- en: '![](img/2a33f878-6dae-46fd-8e49-c12b911d91e5.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a33f878-6dae-46fd-8e49-c12b911d91e5.png)'
- en: Try this with multiple browser windows viewing the same note or different notes.
    This way, you can verify that notes show up only on the corresponding note window.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用多个浏览器窗口查看相同的笔记或不同的笔记。这样，你可以验证笔记只出现在相应的笔记窗口中。
- en: Other applications of Modal windows
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态窗口的其他应用
- en: We used a Modal and some AJAX code to avoid one page reload due to a form submission.
    In the Notes application, as it stands, a similar technique could be used when
    creating a new note, editing existing notes, and deleting existing notes. In each
    case, we would use a Modal, some AJAX code to handle the form submission, and
    some jQuery code to update the page without causing a reload.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模态和一些AJAX代码来避免由于表单提交而导致的页面刷新。在当前的笔记应用程序中，当创建新笔记、编辑现有笔记和删除现有笔记时，可以使用类似的技术。在这种情况下，我们会使用模态、一些AJAX代码来处理表单提交，以及一些jQuery代码来更新页面而不会引起刷新。
- en: But wait, that's not all. Consider the sort of dynamic real-time user interface
    wizardry on the popular social networks. Imagine what events and/or AJAX calls
    are required.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等，这还不是全部。考虑一下在流行的社交网络上常见的动态实时用户界面魔法。想象一下需要哪些事件和/或AJAX调用。
- en: When you click on an image in Twitter, it pops up, you guessed it, a Modal window
    to show a larger version of the image. The Twitter Compose new Tweet window is
    also a Modal window. Facebook uses many different Modal windows, such as when
    sharing a post, reporting a spam post, or while doing a lot of other things Facebook's
    designers deem to require a pop-up window.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Twitter 上点击一张图片时，它会弹出一个模态窗口，展示图片的更大版本。Twitter 新发推文窗口也是一个模态窗口。Facebook 使用了许多不同的模态窗口，例如在分享帖子、举报垃圾邮件帖子或进行
    Facebook 设计师认为需要弹出窗口的其他许多操作时。
- en: Socket.IO, as we've seen, gives us a rich foundation of events passing between
    server and client that can build multiuser, multichannel communication experiences
    for your users.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Socket.IO 为我们提供了一个丰富的服务器和客户端之间事件传递的基础，这可以构建为用户提供的多用户、多通道通信体验。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While we came a long way in this chapter, maybe Facebook doesn't have anything
    to fear from the baby steps we took toward converting the Notes application into
    a social network. This chapter gave us the opportunity to explore some really
    cool technology for pseudo real-time communication between browser sessions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本章中我们已经取得了很大的进步，但也许 Facebook 并不需要担心我们向将笔记应用转化为社交网络迈出的这些小步。本章为我们提供了探索一些真正酷的伪实时通信技术的机会，这些技术可以在浏览器会话之间进行。
- en: Look up the technical definition for the phrase *real time* and you'll see the
    real-time web is not truly real time. The actual meaning of real time involves
    software with strict time boundaries that must respond to events within a specified
    time constraint. Real-time software is typically used in embedded systems to respond
    to button presses, for applications as diverse as junk food dispensers and medical
    devices in intensive care units. Eat too much junk food and you could end up in
    intensive care, and be served by real-time software in both cases. Try and remember
    the distinction between different meanings for this phrase.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 查找“实时”这个词的技术定义，你会发现真正的实时网络并非真正意义上的实时。实时软件的实际含义涉及具有严格时间边界的软件，它必须在指定的时间约束内对事件做出响应。实时软件通常用于嵌入式系统，以响应按钮按下，应用于各种不同的应用，如垃圾食品分配器和重症监护室中的医疗设备。吃太多垃圾食品可能会导致你进入重症监护室，在这两种情况下，你都会由实时软件提供服务。试着记住这个短语的不同含义之间的区别。
- en: In this chapter, you learned about using Socket.IO for pseudo real-time web
    experiences, using the `EventEmitter` class to send messages between parts of
    an application, jQuery, AJAX, and other browser-side JavaScript technologies,
    while avoiding page reloads while making AJAX calls.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 Socket.IO 来实现伪实时网络体验，使用 `EventEmitter` 类在应用程序的不同部分之间发送消息，jQuery、AJAX
    以及其他浏览器端的 JavaScript 技术，同时避免在发起 AJAX 调用时刷新页面。
- en: In the next chapter, we will look into Node.js application deployment on real
    servers. Running code on our laptop is cool, but to hit the big time, the application
    needs to be properly deployed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在真实服务器上部署 Node.js 应用程序。在我们的笔记本电脑上运行代码很酷，但要达到更高的水平，应用程序需要得到适当的部署。
