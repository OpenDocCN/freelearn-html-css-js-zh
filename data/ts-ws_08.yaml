- en: 7\. Decorators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 装饰器
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter first establishes the motivation for decorators and then describes
    the various decorator types available in TypeScript. We'll take a look at how
    decorators are used and how they are customized to fit your specific needs. We'll
    also cover writing your own decorators. By the end of this chapter, you will be
    able to use decorators to alter the behavior of your code, and use decorator factories
    to customize the decorators that are being used. You will also learn how to create
    your own decorators, to be used by your code or that of others.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先确立了装饰器的动机，然后描述了 TypeScript 中可用的各种装饰器类型。我们将探讨装饰器的使用方法和如何根据特定需求进行定制。我们还将涵盖编写自己的装饰器。到本章结束时，你将能够使用装饰器来改变代码的行为，并使用装饰器工厂来定制正在使用的装饰器。你还将学习如何创建自己的装饰器，以便在代码中使用或供他人使用。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapters, you saw how to create types and classes and how to
    compose them into a proper class hierarchy using interfaces, inheritance, and composition.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你看到了如何创建类型和类，以及如何使用接口、继承和组合将它们组合成一个合适的类层次结构。
- en: Using the TypeScript type system, you can create some very elegant models of
    the domains of your applications. However, models do not live by themselves; they
    are part of a larger picture – they are part of an application. And classes need
    to be aware that they live in a larger world, with many other parts of the system
    running in tandem with them, with concerns that go beyond the scope of a given
    class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript 类型系统，你可以创建一些非常优雅的应用程序领域模型。然而，模型并非孤立存在；它们是更大图景的一部分——它们是应用程序的一部分。类需要意识到它们生活在一个更大的世界中，与许多其他系统部分并行运行，并且关注点超出了特定类的范围。
- en: Adding behaviors to or modifying classes to account for the preceding scenario
    is not always easy. And this is where decorators come to the rescue. Decorators
    are special declarations that can be added to class declarations, methods, and
    parameters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理上述场景，向类添加行为或修改类并不总是容易。这正是装饰器大显身手的地方。装饰器是一些特殊的声明，可以添加到类声明、方法和参数中。
- en: In this chapter, we'll learn how you can use a technique called **decorators**
    to transparently add complicated and common behaviors to your classes, without
    getting your application logic all cluttered up with additional code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用一种称为**装饰器**的技术，透明地给类添加复杂且常见的功能，而不会让你的应用程序逻辑因为额外的代码而变得混乱。
- en: Decorators are one of the features that are available and widely used in TypeScript
    but are not available in JavaScript. There is a proposal for decorators in JavaScript
    ([https://github.com/tc39/proposal-decorators](https://github.com/tc39/proposal-decorators)),
    but it's still not part of the standard. The decorators that you will use in TypeScript
    are closely modeled to function just like the proposal.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是 TypeScript 中可用且广泛使用的功能之一，但在 JavaScript 中不可用。JavaScript 中有一个装饰器的提案([https://github.com/tc39/proposal-decorators](https://github.com/tc39/proposal-decorators))，但它还不是标准的一部分。你将在
    TypeScript 中使用的装饰器与该提案非常相似，功能上几乎一样。
- en: The TypeScript approach has its good and bad aspects. One good aspect is that
    once decorators become a standard feature in JavaScript, you can seamlessly transfer
    your decorating skill over to JavaScript, and the code that the TypeScript compiler
    (`tsc`) generates will be an even more idiomatic JavaScript. The bad thing is
    that until it becomes a standard feature, the proposal can and will change. That's
    why, by default, the usage of decorators is turned off in the compiler, and in
    order to use them, you need to pass in a flag, either as a command-line option
    or as part of your `tsconfig.json`. However, before you get into the details of
    how to do this, you first need to understand the concept of reflection, which
    will be explored in the following section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 方法有其优点和缺点。一个优点是，一旦装饰器成为 JavaScript 的标准功能，你就可以无缝地将你的装饰技能转移到 JavaScript
    上，TypeScript 编译器（`tsc`）生成的代码将更加符合 JavaScript 习惯用法。坏处是，直到它成为标准功能，提案可能会改变。这就是为什么默认情况下，编译器中关闭了装饰器的使用，并且为了使用它们，你需要传递一个标志，无论是作为命令行选项还是作为
    `tsconfig.json` 的一部分。然而，在你深入了解如何实现之前，你首先需要理解反射的概念，这将在下一节中探讨。
- en: Reflection
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射
- en: The concept of decorating your code is tightly coupled with a concept called
    **reflection**. In a nutshell, reflection is the capability of a certain piece
    of code to examine and be introspective about itself – in a sense, to do some
    navel-gazing. It means that a piece of code can have access to things such as
    the variables, functions, and classes defined inside it. Most languages provide
    us with some kind of reflection API that enables us to treat the code itself as
    if it was data, and since TypeScript is built upon JavaScript, it inherits the
    JavaScript reflection capabilities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰代码的概念与一个称为**反射**的概念紧密相连。简而言之，反射是指某段代码能够检查和反思自身的能力——在某种意义上，进行自我审视。这意味着一段代码可以访问其内部定义的变量、函数和类。大多数语言都为我们提供了一些反射API，使我们能够将代码本身视为数据，由于TypeScript建立在JavaScript之上，因此它继承了JavaScript的反射能力。
- en: JavaScript does not have an extensive reflection API, but there is a proposal
    ([https://tc39.es/ecma262/#sec-reflection](https://tc39.es/ecma262/#sec-reflection))
    to add proper metadata (data about data) support to the language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有广泛的反射API，但有一个提议（[https://tc39.es/ecma262/#sec-reflection](https://tc39.es/ecma262/#sec-reflection)）要将适当的元数据（关于数据的数据）支持添加到语言中。
- en: Setting Up Compiler Options
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置编译器选项
- en: TypeScript's decorators use the aforementioned proposed feature, and in order
    to use them, you have to enable the TypeScript compiler (`tsc`) accordingly. As
    covered in the preface, there are two ways to do this. You can either add the
    necessary flags on the command line when you invoke `tsc` or you can configure
    the necessary options inside the `tsconfig.json` file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的装饰器使用了上述提议的功能，为了使用它们，你必须相应地启用TypeScript编译器（`tsc`）。如前言所述，有两种方法可以做到这一点。你可以在调用`tsc`时在命令行上添加必要的标志，或者你可以在`tsconfig.json`文件中配置必要的选项。
- en: 'There are two flags concerning decorators. The first one, `experimentalDecorators`,
    is needed to use decorators at all. If you have a file where you''re using a decorator
    and try to compile it without specifying it, you get the following error:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个与装饰器相关的标志。第一个是`experimentalDecorators`，这是使用装饰器所必需的。如果你有一个使用装饰器的文件，并且尝试在不指定它的情况下编译，你会得到以下错误：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you specify the flag, you can compile successfully:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了标志，你可以成功编译：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to avoid specifying the flags all the time, add the following flags
    in the `tsconfig.json` file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每次都指定标志，请在`tsconfig.json`文件中添加以下标志：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before you begin executing the examples, exercises, and activities, we suggest
    that you make sure the preceding complier options have been enabled in your `tsconfig.json`
    file. Alternatively, you can use the file provided here: [https://packt.link/hoeVy](https://packt.link/hoeVy).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始执行示例、练习和活动之前，我们建议你确保前面的编译器选项已经在你的`tsconfig.json`文件中启用。或者，你可以使用这里提供的文件：[https://packt.link/hoeVy](https://packt.link/hoeVy)。
- en: Importance of Decorators
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器的重要性
- en: 'So, now you''re ready to start decorating. But why would you want to do that?
    Let''s run through a simple example that mimics the real-world scenarios you will
    be encountering later. Let''s say that you are building a simple class that will
    encapsulate the score for a basketball game:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你已经准备好开始装饰了。但为什么你想这样做呢？让我们通过一个简单的例子来模拟你将在以后遇到的真实场景。假设你正在构建一个简单的类，该类将封装篮球比赛的得分：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our class has two teams, each of which has a name and a numerical score. You''re
    initializing your team in the class constructor, and you have a method that will
    provide the current score. However, you don''t have a method that will update
    the score. Let''s add one:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类有两个团队，每个团队都有一个名称和数值得分。你在类构造函数中初始化你的团队，并且有一个提供当前得分的方法。然而，你没有更新得分的方法。让我们添加一个：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This method accepts the number of points to add and a Boolean. If the Boolean
    is `true`, you''re updating the first team''s score, and if it''s `false`, you''re
    updating the second team''s score. You can take your class for a spin, as here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受要添加的点数和一个布尔值。如果布尔值为`true`，你正在更新第一支球队的得分，如果为`false`，你正在更新第二支球队的得分。你可以尝试运行你的类，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code will show us that the Lakers are losing `7:8` against the Celtics
    (*Game 7 of the 2010 finals, if anyone wants to know*).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将向我们展示湖人队在对阵凯尔特人的比赛中以`7:8`失利（如果有人想知道，这是2010年总决赛的第7场比赛）。
- en: The Problem of Cross-Cutting Concerns
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 横切关注点问题
- en: So far so good, and your class is fully operational – as far as its own functionalities
    are concerned. However, as your class will be living within a whole application,
    you have other concerns as well. One of those concerns is authorization – will
    just anyone be able to update the score? Of course not, as the common use case
    is that you have a single person that is allowed to update the score and multiple
    people, maybe millions, that just watch the score change.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，你的类在自身功能方面完全可用。然而，由于你的类将存在于整个应用程序中，你还有其他一些担忧。其中之一就是授权——是否任何人都能够更新分数？当然不是，因为常见的用例是只有一个被允许更新分数的人，而可能有成千上万的人只是观看分数的变化。
- en: 'Let''s add that concern to the code using a hypothetical function, `isAuthorized`,
    that will check whether the current user is actually authorized to change the
    score. You will call this function and if it returns `true`, we''ll continue with
    the regular logic of the method. If it returns `false`, then we''ll just issue
    an appropriate message. The code will look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个假设的函数`isAuthorized`来添加这个担忧，该函数将检查当前用户是否实际上被授权更改分数。你将调用这个函数，如果它返回`true`，我们将继续执行方法的常规逻辑。如果返回`false`，那么我们只需发出适当的消息。代码将如下所示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, this will work nicely, albeit increasing the code size of your method
    from five lines of code to nine lines of code and adding some complexity. And,
    to be honest, the added lines are not really relevant to counting the score, but
    they had to be added in order to support authorization.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这将很好地工作，尽管它将你的方法代码行数从五行增加到九行，并增加了一些复杂性。坦白说，增加的行与计分无关，但它们必须被添加以支持授权。
- en: 'So, is that it? Of course not. Even if you know that somebody is authorized,
    it does not mean that your operator will be able to update the score whenever
    they want. The auditor will need detailed information of when and with what parameters
    the `updateScore` method was called. No problem, let''s add that as well using
    a hypothetical function called `audit`. And you''ll also need to add some verification
    for whether the `byPoints` parameter is a legal value (in basketball, you can
    only have 1-, 2-, or 3-point increments). And you could add some code that logs
    the performance of the method in order to have a trace of how long it takes to
    execute. So, your nice, clear, five-line method will become a 17-line monstrosity:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这就结束了？当然不是。即使你知道某人被授权，这也并不意味着你的操作员可以随时更新分数。审计员需要详细的信息，包括何时以及使用什么参数调用`updateScore`方法。没问题，我们可以使用一个假设的函数`audit`来添加这些信息。你还需要添加一些验证，以确保`byPoints`参数是一个合法的值（在篮球中，你只能有1分、2分或3分的加成）。你还可以添加一些代码来记录方法执行的性能，以便追踪执行所需的时间。因此，你那清晰、简洁的五行方法将变成一个17行的怪物：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And inside all that complexity, you still have your simple and clear piece of
    logic that if the Boolean is `true`, will update the Lakers' score, and if it's
    `false`, will update the Celtics' score.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些复杂性中，你仍然有你简单、清晰的逻辑，如果布尔值为`true`，则更新湖人队的分数，如果为`false`，则更新凯尔特人队的分数。
- en: The important part here is that the added complexity does not come from your
    specific business model – the basketball game still works the same. All the added
    functionalities stem from the system in which the class lives. The basketball
    game, by itself, does not need authorization, or performance metrics, or auditing.
    But the scoreboard application does need all of those and more.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，增加的复杂性并非来自你的特定商业模式——篮球比赛本身仍然有效。所有增加的功能都源于类所在的系统。篮球比赛本身不需要授权、性能指标或审计。但记分牌应用程序确实需要所有这些以及更多。
- en: Note that all the added logic is already encapsulated within methods (`audit`,
    `isAuthorized`, `logDuration`), and the code that actually performs all the aforementioned
    operations is outside your method. The code you inserted into your function does
    the bare minimum – yet it still complicated your code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有添加的逻辑都已经封装在方法（`audit`、`isAuthorized`、`logDuration`）中，而实际执行上述所有操作的代码位于你的方法之外。你插入到函数中的代码只做了最基本的工作——然而，它仍然使你的代码变得复杂。
- en: In addition, authorization, performance metrics, and auditing will be needed
    in many places within your application, and in none of those places will that
    code be instrumental to the actual working of the code that is being authorized
    or measured or audited.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，授权、性能指标和审计将在你的应用程序的许多地方需要，而在这些地方，代码对授权、测量或审计的实际代码的工作并不起作用。
- en: The Solution
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Let''s take a better look at one of the concerns from the previous section,
    the performance metric, that is, the duration measurement. This is something that
    is very important to an application, and to add it to any specific method, you
    need a few lines of code at the beginning and a few lines at the end of the method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看上一节中的一个关注点，即性能指标，也就是持续时间测量。这对应用程序非常重要，要将它添加到任何特定的方法中，你需要在方法的开头和结尾添加几行代码：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We'll need to add this to each and every method you need to measure. It's very
    repetitive code, and each time you write it in, you're opening the possibility
    of doing it slightly wrong. Moreover, if you need to change it, that is, by adding
    a parameter to the `logDuration` method, you'll need to change hundreds, if not
    thousands, of call sites.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其添加到你需要测量的每个方法中。这是一段非常重复的代码，每次你编写它时，你都在打开做错的可能性。此外，如果你需要更改它，即向`logDuration`方法添加参数，你将需要更改数百甚至数千个调用点。
- en: 'In order to avoid that kind of risk, what you can do is to wrap the actual
    code of the method inside some other function that will still call it. That function
    might look something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种风险，你可以做的是将方法的实际代码包裹在另一个函数中，该函数仍然会调用它。这个函数可能看起来像这样：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `wrapWithDuration` function (whose details you can ignore for now) will
    take a method and return a function that has the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapWithDuration`函数（其细节你现在可以忽略）将接受一个方法并返回一个具有以下功能的函数：'
- en: The same `this` reference
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的`this`引用
- en: The same method name
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的方法名
- en: The same signature (parameters and return type)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的签名（参数和返回类型）
- en: All the behavior that the original method has
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始方法所具有的所有行为
- en: Extended behavior as it will measure the duration of the actual method
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展行为，因为它将测量实际方法的持续时间
- en: Since it will actually call the original method, when looking from outside,
    the new function is totally indistinguishable from the original. You have added
    some behavior while keeping everything that already was. Now, you can replace
    the original method with the new improved one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它实际上会调用原始方法，从外部看，新函数与原始函数完全无法区分。你在保持所有已有内容的同时添加了一些行为。现在，你可以用新的改进版本替换原始方法。
- en: 'What you will get with this approach is this: the original method won''t know
    or care about the cross-cutting concerns of the application, instead focusing
    on its own business logic – the application can "upgrade" the method at runtime
    with one that has all the necessary business logic as well as all the required
    additions.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，你将得到的是：原始方法不会知道或关心应用程序的横切关注点，而是专注于自己的业务逻辑——应用程序可以在运行时用具有所有必要业务逻辑以及所有所需添加的函数“升级”该方法。
- en: This kind of transparent "upgrade" is often termed a **decoration**, and the
    method that does the decorating is called a **decorator** method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种透明的“升级”通常被称为**装饰**，而执行装饰的方法被称为**装饰器方法**。
- en: What has been shown here is just one form that a decoration can take. There
    can be as many solutions as there are developers, and none of them will be simple
    and straightforward. Some standards should be put in place, and the TypeScript
    design team decided to use the proposed JavaScript syntax.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所展示的只是装饰可以采取的一种形式。解决方案的数量可以与开发者的数量一样多，而且它们都不会简单直接。应该制定一些标准，TypeScript设计团队决定采用提议的JavaScript语法。
- en: The rest of the chapter will use that syntax, and you can ignore the solution
    given here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将使用该语法，你可以忽略这里给出的解决方案。
- en: Decorators and Decorator Factories
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器和装饰器工厂
- en: 'As we''ve seen so far, decorators are just special wrapping functions that
    add behavior to your regular methods, classes, and properties. What''s special
    about them is how they can be used in TypeScript. TypeScript supports the following
    decorator types:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，装饰器只是特殊的包装函数，它们为你的常规方法、类和属性添加行为。它们特殊之处在于在TypeScript中的使用方式。TypeScript支持以下装饰器类型：
- en: '**Class decorators**: These are attached to a class declaration.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类装饰器**：这些装饰器附加到类声明上。'
- en: '**Method decorators**: These are attached to a method declaration.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法装饰器**：这些装饰器附加到方法声明上。'
- en: '**Accessor decorators**: These are attached to a declaration of an accessor
    of a property.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问器装饰器**：这些装饰器附加到属性的访问器声明上。'
- en: '**Property decorators**: These are attached to a property itself.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性装饰器**：这些装饰器附加到属性本身。'
- en: '**Parameter decorators**: These are attached to a single parameter in a method declaration.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数装饰器**：这些装饰器附加到方法声明中的单个参数上。'
- en: 'And consequently, there are five different places where you can use decorators,
    so that means that there are five different kinds of special functions that can
    be used to decorate your code. All of them are shown in the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你有五个不同的地方可以使用装饰器，这意味着有五种不同类型的特殊函数可以用来装饰你的代码。所有这些都在下面的示例中展示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The sample decorators are functions that are defined as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 样本装饰器是按照以下方式定义的函数：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Decorator Syntax
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器语法
- en: 'The syntax for adding a decorator to an item is that you have to use the special
    symbol `@` followed by the name of the decorators. The decorator is placed before
    the code that it decorates, so in the preceding example, you have performed the
    following decorations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 向项目添加装饰器的语法是使用特殊的符号 `@` 后跟装饰器的名称。装饰器放置在它装饰的代码之前，所以在前面的示例中，你执行了以下装饰：
- en: '`@ClassDecorator` is immediately before the `SampleClass` class and is a class
    decorator.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ClassDecorator` 紧接在 `SampleClass` 类之前，是一个类装饰器。'
- en: '`@PropertyDecorator` is immediately before the `public sampleProperty` and
    is a property decorator.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PropertyDecorator` 紧接在 `public sampleProperty` 之前，是一个属性装饰器。'
- en: '`@AccessorDecorator` is immediately before the `public get sampleField()` and
    is a `get` accessor decorator.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AccessorDecorator` 紧接在 `public get sampleField()` 之前，是一个 `get` 访问器装饰器。'
- en: '`@MethodDecorator` is immediately before the `public sampleMethod()` and is
    a method decorator.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@MethodDecorator` 紧接在 `public sampleMethod()` 之前，是一个方法装饰器。'
- en: '`@ParameterDecorator` is immediately before `paramName: string` and is a parameter
    decorator.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ParameterDecorator` 紧接在 `paramName: string` 之前，是一个参数装饰器。'
- en: While the decorators themselves are regular functions, it's conventional that
    the names use `PascalCase` instead of `lowerCamelCase`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然装饰器本身是常规函数，但按照惯例，它们的名称使用 `PascalCase` 而不是 `lowerCamelCase`。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on `PascalCase` and `lowerCamelCase`, visit [https://techterms.com/definition/camelcase](https://techterms.com/definition/camelcase)
    and [https://techterms.com/definition/pascalcase](https://techterms.com/definition/pascalcase).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 `PascalCase` 和 `lowerCamelCase` 的信息，请访问 [https://techterms.com/definition/camelcase](https://techterms.com/definition/camelcase)
    和 [https://techterms.com/definition/pascalcase](https://techterms.com/definition/pascalcase)。
- en: Decorator Factories
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器工厂
- en: You can see that you did not specify any parameters for the set of sample decorators
    in the previous section, yet the decorator function takes between one and three
    parameters. Those parameters are handled by TypeScript itself and are provided
    automatically when your code runs. This means that there is no way to configure
    your decorators directly, for example, by passing additional parameters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在前面的示例中，你没有为样本装饰器集合指定任何参数，然而装饰器函数接受一个到三个参数。这些参数由 TypeScript 本身处理，并在代码运行时自动提供。这意味着你无法直接配置装饰器，例如，通过传递额外的参数。
- en: Fortunately, you can use a construct called `@` symbol specifying a decorator,
    it will evaluate the expression that follows. So, instead of providing the name
    of a function that fits the special decorator requirements, you can provide an
    expression that will evaluate to such a function. In other words, decorator factories
    are simply higher-order functions that will return a decorator function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用一个称为 `@` 符号的构造来指定装饰器，它将评估随后的表达式。因此，你不需要提供符合特殊装饰器要求的函数名称，而是可以提供一个将评估为该函数的表达式。换句话说，装饰器工厂仅仅是返回装饰器函数的高阶函数。
- en: 'For example, let''s create a simple function that will take a message as a
    parameter and log a message to the console. The return value of that function,
    whose input parameters do not conform to the class decorator signature, will be
    another function, whose input parameters do conform to the class decorator signature.
    The resulting function will also simply log the message to the console as well.
    Consider the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个简单的函数，它将接受一个消息作为参数并将消息记录到控制台。该函数的返回值，其输入参数不符合类装饰器签名，将是一个函数，其输入参数符合类装饰器签名。这个生成的函数也将简单地记录消息到控制台。考虑以下代码：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In essence, the `ClassDecoratorFactory` function is not a decorator, but its
    return value is. This means that you cannot use `ClassDecoratorFactory` as a decorator
    itself, but if you call it, for example, `ClassDecoratorFactory("Hi")`, that value
    will indeed be a decorator. You can use that to decorate a couple of classes using
    this syntax. The following example will help you understand this much better:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`ClassDecoratorFactory`函数本身不是一个装饰器，但它的返回值是。这意味着你不能直接将`ClassDecoratorFactory`用作装饰器，但如果你调用它，例如`ClassDecoratorFactory("Hi")`，那么这个值确实是一个装饰器。你可以使用它用这种语法装饰几个类。以下示例将帮助你更好地理解这一点：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, instead of using an expression such as `@ClassDecorator` as before, you
    use `@ClassDecoratorFactory("hi")` or `@ClassDecoratorFactory("hello")`. Since
    the result of the execution of the `ClassDecoratorFactory` function is a class
    decorator, this is operational, and the decorators successfully decorate the code.
    You will see the following output when you run your code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你不再使用之前的`@ClassDecorator`这样的表达式，而是使用`@ClassDecoratorFactory("hi")`或`@ClassDecoratorFactory("hello")`。由于`ClassDecoratorFactory`函数的执行结果是一个类装饰器，这是可行的，并且装饰器成功地装饰了代码。当你运行代码时，你会看到以下输出：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that most decorators that you will use and make will in essence be decorator
    factories, as it's extremely useful to add parameters when decorating. Most sources
    and even some documentation will not differentiate between the terms.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你将使用的大多数装饰器实际上都是装饰器工厂，因为装饰时添加参数非常有用。大多数资料甚至一些文档都不会区分这两个术语。
- en: Class Decorators
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类装饰器
- en: A class decorator is a decorator function that is applied to the whole class.
    It can be used to observe, change, or replace wholesale a class definition. When
    a class decorator is called, it receives a single parameter – the constructor
    function of the calling class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器是一个应用于整个类的装饰器函数。它可以用来观察、更改或完全替换类定义。当一个类装饰器被调用时，它接收一个参数——调用类的构造函数。
- en: Property Injection
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性注入
- en: 'Property injection is one of the common scenarios that class decorations are
    used for. For example, let''s say you''re building a system that will model a
    school. You will have a class called `Teacher` that will have the properties and
    model the behavior of a teacher. The constructor for this class will take two
    parameters, an `id` number of the teacher, and the `name` of the teacher. This
    is how the class will look:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 属性注入是类装饰器常用的场景之一。例如，假设你正在构建一个将模拟学校的系统。你将有一个名为`Teacher`的类，它将具有属性并模拟教师的行为。这个类的构造函数将接受两个参数，即教师的`id`和教师的`name`。这个类将看起来是这样的：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's say we build the system and it's up and running. Everything is great,
    but after a while, it's time to update it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们构建了系统并且它正在运行。一切都很顺利，但过了一段时间，就需要更新它。
- en: 'We want to implement an access control system using tokens. Since the new system
    is not related to the teaching process, it is much better to add it without changing
    the code of the class itself, so you can use a decorator for this, and your decorator
    can inject an extra Boolean property to the prototype of the `Teacher` class.
    The `Teacher` class can be changed in the following way:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用令牌实现一个访问控制系统。由于新系统与教学过程无关，最好在不更改班级本身代码的情况下添加它，这样你可以使用一个装饰器来完成这个任务，并且你的装饰器可以给`Teacher`类的原型注入一个额外的布尔属性。`Teacher`类可以按照以下方式更改：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Token` decorator can be defined with the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用以下方式定义`Token`装饰器：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, consider the following code, which creates instances of the class and
    prints a message:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码，它创建了类的实例并打印一条消息：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running all this code will give the following result on the console:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有这些代码将在控制台给出以下结果：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the injection scenario, you use the provided `constructor` parameter but
    do not return anything from your function. In this case, the class continues working
    as it did before. Usually, we'll be using the prototype of the constructor to
    add fields and properties to the object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入场景中，您使用提供的 `constructor` 参数，但您的函数不返回任何内容。在这种情况下，类将继续像以前一样工作。通常，我们将使用构造函数的原型来向对象添加字段和属性。
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For all exercises and activities in this chapter, before executing the code
    file, you need to install all dependencies using `npm i` in the target directory.
    Then, you can execute the file by running `npx ts-node 'filename'` in the target
    directory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有练习和活动中，在执行代码文件之前，您需要使用 `npm i` 在目标目录中安装所有依赖项。然后，您可以在目标目录中运行 `npx ts-node
    'filename'` 来执行文件。
- en: 'Exercise 7.01: Creating a Simple Class Decorator Factory'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.01：创建简单的类装饰器工厂
- en: In this exercise, you will be creating a simple decorator factory for the `Token`
    decorator. Starting from the `Teacher` class code, we'll create a class called
    `Student` that will need to be decorated using the `Token` decorator. We'll extend
    the decorator to take a parameter, and decorate both classes using the created
    decorator factory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个简单的 `Token` 装饰器工厂。从 `Teacher` 类的代码开始，我们将创建一个名为 `Student` 的类，该类需要使用
    `Token` 装饰器进行装饰。我们将扩展装饰器以接受一个参数，并使用创建的装饰器工厂装饰这两个类。
- en: 'The following steps will help you with the solution:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您找到解决方案：
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before you begin, make sure you have set up the correct compiler options as
    mentioned in the *Setting Up Compiler Options* section. The code file for this
    exercise can also be downloaded from [https://packt.link/UpdO9](https://packt.link/UpdO9).
    This repository contains two files: `school-token.start.ts` and `school-token.end.ts`.
    The former contains the code up to *step 6* of this exercise, and the latter contains
    the final code of the exercise.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保您已设置正确的编译器选项，如 *设置编译器选项* 部分所述。此练习的代码文件也可以从 [https://packt.link/UpdO9](https://packt.link/UpdO9)
    下载。此存储库包含两个文件：`school-token.start.ts` 和 `school-token.end.ts`。前者包含此练习的 *步骤 6*
    之前的代码，后者包含练习的最终代码。
- en: Open Visual Studio Code, create a new file in a new directory (`Exercise01`),
    and save it as `school-token.ts`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code，在新的目录（`Exercise01`）中创建一个新文件，并将其保存为 `school-token.ts`。
- en: 'Enter the following code in `school-token.ts`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `school-token.ts` 中输入以下代码：
- en: '[PRE20]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Execute the code, and notice that it outputs `true` to the console.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码，并注意它在控制台输出 `true`。
- en: 'Add a `Student` class at the end of the file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾添加一个 `Student` 类：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add code that creates a student and tries to print its `token` property:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码以创建一个学生并尝试打印其 `token` 属性：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Execute the code, and notice that it outputs `true` and `undefined` to the console.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码，并注意它在控制台输出 `true` 和 `undefined`。
- en: 'Add the `Token` decorator to the `Student` class:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Token` 装饰器添加到 `Student` 类中：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Execute the code, and notice that it outputs `true` twice to the console.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码，并注意它在控制台输出 `true` 两次。
- en: 'Change the `Token` function to a factory function that takes a Boolean parameter:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Token` 函数更改为一个接受布尔参数的工厂函数：
- en: '[PRE24]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Modify the `Teacher` class `Token` decorator to have a `true` Boolean parameter:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Teacher` 类的 `Token` 装饰器以包含一个 `true` 布尔参数：
- en: '[PRE25]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify the `Student` class `Token` decorator to have a `false` Boolean parameter:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Student` 类的 `Token` 装饰器以包含一个 `false` 布尔参数：
- en: '[PRE26]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Execute the code by running `npx ts-node` `school-token.ts` on the console,
    and notice that it outputs `true` and `false` to the console as shown:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在控制台运行 `npx ts-node` `school-token.ts` 来执行代码，并注意它按如下所示输出 `true` 和 `false`：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this exercise, you saw how to add a class decorator that adds a property
    to a decorated class. You then changed the decorator to use a factory and added
    two different parameters for two decorated classes. At the end, you verified that
    the injected properties exist on the decorated classes via the prototype chain
    and that they have the values you specified.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了如何添加一个类装饰器，该装饰器向装饰过的类添加一个属性。然后，你将装饰器更改为使用工厂，并为两个装饰过的类添加了两个不同的参数。最后，你验证了注入的属性确实存在于装饰过的类中，并且通过原型链具有你指定的值。
- en: Constructor Extension
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数扩展
- en: Using property injection enabled you to add behaviors and data to the objects
    you decorate using their prototypes. That is OK, but sometimes you might want
    to add data to the constructed objects themselves. You can accomplish this with
    inheritance, but you can also wrap the inheritance with a decorator.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性注入，你能够通过它们的原型向你装饰的对象添加行为和数据。这是可以的，但有时你可能想直接向构造对象本身添加数据。你可以通过继承来实现这一点，但你也可以用装饰器包装继承。
- en: 'If you return a function from the decorator, that function will be used as
    a replacement constructor for the class. While this gives you the superpower to
    change the class completely, the main goal of this approach is to enable you to
    augment the class with some new behaviors or data, so let''s use automatic inheritance
    to add properties to the class. A decorator that will add the `token` property
    not on the prototype but on the constructed objects themselves would look like
    this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从装饰器返回一个函数，该函数将用作类的替换构造函数。虽然这给了你完全改变类的超级能力，但这种方法的主要目标是让你能够通过添加一些新的行为或数据来增强类。让我们使用自动继承来向类添加属性。一个将
    `token` 属性添加到构造对象本身而不是原型的装饰器看起来像这样：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The syntax for doing that looks a bit strange at first, as you are using a
    generic parameter to make sure that the class you return from your decorator will
    still be compatible with the constructor that was passed as a parameter. Aside
    from the syntax, the important part to remember is that the code `token: boolean
    = hasToken;` will be executed in addition to the regular constructor.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '首次看到这样做时，语法可能看起来有点奇怪，因为你正在使用一个泛型参数来确保从你的装饰器返回的类仍然与传递给构造函数的构造函数兼容。除了语法之外，需要记住的重要部分是代码
    `token: boolean = hasToken;` 将在常规构造函数之外执行。'
- en: 'Exercise 7.02: Using a Constructor Extension Decorator'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.02：使用构造函数扩展装饰器
- en: 'In this exercise, you will be creating a constructor extension decorator factory
    for the `Token` decorator. Starting from the `Teacher` class code, we''ll add
    a token factory called `Token` that will augment the class by adding a `token`
    Boolean property. We''ll create an object of the provided class and verify that
    the object indeed has its own `token` property. The following steps will help
    you with the solution:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个用于 `Token` 装饰器的构造函数扩展装饰器工厂。从 `Teacher` 类代码开始，我们将添加一个名为 `Token`
    的工厂，通过添加一个 `token` 布尔属性来增强类。我们将创建一个提供的类对象，并验证该对象确实有自己的 `token` 属性。以下步骤将帮助你找到解决方案：
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before you begin, make sure you have set up the correct compiler options as
    mentioned in the *Setting Up Compiler Options* section. The code file for this
    exercise can also be downloaded from [https://packt.link/DhVfC](https://packt.link/DhVfC).
    This repository contains two files: `school-token.start.ts` and `school-token.end.ts`.
    The former contains the code up to *step 3* of this exercise, and the latter contains
    the final code of the exercise.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保你已经设置了如 *设置编译器选项* 部分所述的正确编译器选项。此练习的代码文件也可以从 [https://packt.link/DhVfC](https://packt.link/DhVfC)
    下载。此存储库包含两个文件：`school-token.start.ts` 和 `school-token.end.ts`。前者包含此练习的 *步骤 3*
    之前的代码，后者包含练习的最终代码。
- en: Open Visual Studio Code, create a new file in a new directory (`Exercise02`),
    and save it as `school-token.ts`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code，在新的目录（`Exercise02`）中创建一个新文件，并将其保存为 `school-token.ts`。
- en: 'Enter the following code in `school-token.ts`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `school-token.ts` 文件中输入以下代码：
- en: '[PRE29]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Execute the code, and notice that it outputs `undefined` and `false` to the console:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码，并注意它将输出 `undefined` 和 `false` 到控制台：
- en: '[PRE30]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a `Token` function at the end of the file:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾添加一个 `Token` 函数：
- en: '[PRE31]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Decorate the `Teacher` class using the `Token` decorator factory:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Token` 装饰器工厂装饰 `Teacher` 类：
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Execute the code, and notice that it outputs `true` twice to the console:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码，并注意它将输出 `true` 两次到控制台：
- en: '[PRE33]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this exercise, you saw how to change the provided class constructor to run
    custom code while instantiating an object. You used that to inject a property
    on the constructed object itself, and then you verified that the injected properties
    exist on objects of the decorated class and that they have the value you specified.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了如何更改提供的类构造函数以在实例化对象时运行自定义代码。你使用了这一点来在构造对象本身上注入属性，然后验证注入的属性存在于装饰类的对象上，并且它们的值是你指定的。
- en: Constructor Wrapping
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数包装
- en: Another common scenario for class decorators is the need to just run some code
    when an instance of a class is being created, for example, to add some logging
    when an instance of a class is created. You do not need or want to change the
    class behavior in any way, but you do want to be able to somehow piggyback on
    the process. This means that you need to execute some code whenever a class constructor
    is being run – you don't need to change the existing constructor.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类装饰器来说，另一个常见的场景是在创建类的实例时只需运行一些代码，例如，在创建类的实例时添加一些日志记录。你不需要或想要以任何方式更改类的行为，但你确实希望能够以某种方式依赖这个过程。这意味着你需要在类构造器运行时执行一些代码——你不需要更改现有的构造器。
- en: 'In this case, the solution is to have the decorator function return a new constructor
    that executes the new code needed by the decorator itself as well as the original
    constructor. For example, if you want to write some text to the console each time
    you instantiate a decorated class, you can use this decorator:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，解决方案是让装饰器函数返回一个新的构造器，该构造器执行装饰器本身所需的新代码以及原始构造器。例如，如果你想每次实例化装饰过的类时都向控制台写入一些文本，你可以使用这个装饰器：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This decorator factory will generate a decorator using a provided message. Since
    you're returning a new constructor, you have to use a generic parameter to make
    sure that the constructor you return from your decorator will still be compatible
    with the constructor that was passed as a parameter. You can create a new `wrappedConstructor`
    function within which you can both call custom code (the `Decorating` and `Decorated`
    messages) and actually create the object by calling `new` on the original constructor,
    passing in the original arguments.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器工厂将使用提供的信息生成一个装饰器。由于你返回了一个新的构造器，你必须使用一个泛型参数来确保从你的装饰器返回的构造器仍然与传递给参数的原始构造器兼容。你可以在`wrappedConstructor`函数内部创建一个新的函数，在其中你可以调用自定义代码（`Decorating`和`Decorated`消息），并通过在原始构造器上调用`new`来实际创建对象，传递原始参数。
- en: 'You should note the following here: it''s possible to add custom code both
    pre- and post-creation of the object. In the preceding example, the `Decorating`
    message will be printed to the console before the object is created, while the
    `Decorated` message will be printed to the console after the creation is finished.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在这里注意以下内容：你可以在对象创建前后添加自定义代码。在前面的例子中，`Decorating`消息将在对象创建之前打印到控制台，而`Decorated`消息将在创建完成后打印到控制台。
- en: Another very important thing is that this kind of wrapping breaks the prototype
    chain of the original object. If the object you decorate thus uses any properties
    or methods that were available through the prototype chain, they would be missing,
    changing the behavior of the decorated class. Since that is exactly the opposite
    of what you wanted to achieve with constructor wrapping, you need to reset the
    chain. That is done by setting the `prototype` property of the newly created wrapper
    function to the prototype of the original constructor.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的事情是，这种包装会破坏原始对象的原型链。如果你装饰的对象使用了通过原型链可用的任何属性或方法，它们将丢失，改变装饰类的行为。由于这与你想通过构造器包装实现的目标正好相反，你需要重置链。这是通过将新创建的包装函数的`prototype`属性设置为原始构造器的原型来完成的。
- en: 'So, let''s use a decorator on a client class, like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在客户端类上使用装饰器，如下所示：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, you can create an object of the `Teacher` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以创建一个`Teacher`类的对象：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When you run the file, you will see the following written to the console:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行文件时，你将在控制台看到以下内容：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Exercise 7.03: Creating a Logging Decorator for a Class'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.03：为类创建一个日志装饰器
- en: 'In this exercise, you''ll be creating a constructor wrapping decorator factory
    for the `LogClass` decorator. Starting from the `Teacher` class code, you''ll
    add a decorator factory called `LogClass` that will wrap the class constructor
    with some logging code. You''ll create an object of the provided class and verify
    that the logging methods are actually called. The following steps will help you
    with the solution:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个用于`LogClass`装饰器的构造器包装装饰器工厂。从`Teacher`类的代码开始，你将添加一个名为`LogClass`的装饰器工厂，它将使用一些日志代码包装类构造器。你将创建提供的类的对象，并验证日志方法确实被调用。以下步骤将帮助你找到解决方案：
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you begin, make sure you have set up the correct compiler options as
    mentioned in the *Setting Up Compiler Options section.* The code file for this
    exercise can also be downloaded from [https://packt.link/vBLMg](https://packt.link/vBLMg).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，请确保你已经设置了如 *设置编译器选项* 部分所述的正确编译器选项。此练习的代码文件也可以从 [https://packt.link/vBLMg](https://packt.link/vBLMg)
    下载。
- en: Open Visual Studio Code, create a new file in a new directory (`Exercise03`),
    and save it as `teacher-logging.ts`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code，在新的目录（`Exercise03`）中创建一个新文件，并将其保存为 `teacher-logging.ts`。
- en: 'Enter the following code in `teacher-logging.ts`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `teacher-logging.ts` 中输入以下代码：
- en: '[PRE38]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Execute the code, and notice that it outputs `Constructing a teacher` to the
    console.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码，注意它会将 `Constructing a teacher` 输出到控制台。
- en: 'Next, create the decorator. First, you need to add the `Constructable` type definition:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建装饰器。首先，你需要添加 `Constructable` 类型定义：
- en: '[PRE39]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, add a definition of your decorator factory:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加你的装饰器工厂的定义：
- en: '[PRE40]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, the constructor takes in a string parameter and returns
    a decorator function. The decorator function itself will initially just return
    the original, unchanged constructor of the decorated class.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，构造函数接受一个字符串参数并返回一个装饰器函数。装饰器函数本身最初只会返回被装饰类的原始、未更改的构造函数。
- en: 'Decorate the `Teacher` class using the `LogClass` decorator with an appropriate
    message parameter:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有适当消息参数的 `LogClass` 装饰器装饰 `Teacher` 类：
- en: '[PRE41]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Execute the code, and notice that there are no changes to the behavior.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码，注意行为没有任何变化。
- en: 'Now, add a logger object to your application:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向你的应用程序添加一个日志对象：
- en: '[PRE42]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In actual production-grade code implementation, you might log to a database,
    a file, a third-party service, and so on. In the preceding step, you are simply
    logging to the console.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实际的生产级代码实现中，你可能需要将日志记录到数据库、文件、第三方服务等。在上一个步骤中，你只是将日志记录到控制台。
- en: 'Next, use the `logger` object to add a wrapping constructor to your decorator:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `logger` 对象向你的装饰器添加一个包装构造函数：
- en: '[PRE43]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Execute the code and verify that you get a logging message to the console:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码并验证你是否在控制台收到日志消息：
- en: '[PRE44]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Construct a few more objects and verify that the constructor runs each time
    an object is created:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造几个更多的对象并验证每次创建对象时构造函数都会运行：
- en: '[PRE45]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You''ll see the following output when you execute the file:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你执行文件时，你会看到以下输出：
- en: '[PRE46]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this exercise, you saw how to wrap the provided class constructor so that
    it can run custom code, but without changing the construction of the objects.
    Through wrapping, you added logging capabilities to a class that did not have
    any. You constructed objects of that class and verified that the logging functionality
    was operational.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了如何包装提供的类构造函数，以便它可以运行自定义代码，但又不改变对象的构造。通过包装，你向一个没有任何日志功能的类添加了日志功能。你构造了这个类的对象，并验证了日志功能是可操作的。
- en: Method and Accessor Decorators
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法和访问器装饰器
- en: 'A method decorator is a decorator function that is applied to a single method
    of a class. In a method decorator, you can observe, modify, or outright replace
    a method definition with one provided by the decorator. When a method decorator
    is called, it receives three parameters: `target`, `propertyKey`, and `descriptor`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 方法装饰器是一个应用于类单个方法的装饰器函数。在方法装饰器中，你可以观察、修改或完全用装饰器提供的定义替换方法定义。当方法装饰器被调用时，它接收三个参数：`target`、`propertyKey`
    和 `descriptor`：
- en: '`target`: Since methods can be both instance methods (defined on instances
    of the class) and static methods (defined on the class itself), `target` can be
    two different things. For instance methods, it''s the prototype of the class.
    For static methods, it''s the constructor function of the class. Usually, you
    type this parameter as `any`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`: 由于方法可以是实例方法（在类的实例上定义）和静态方法（在类本身上定义），`target` 可以是两件不同的事情。对于实例方法，它是类的原型。对于静态方法，它是类的构造函数。通常，你将此参数键入为
    `any`。'
- en: '`propertyKey`: This is the name of the method you''re decorating.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyKey`: 这是你要装饰的方法的名称。'
- en: '`descriptor`: This is the property descriptor of the method you''re decorating.
    The `PropertyDescriptor` interface is defined with this:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descriptor`: 这是你要装饰的方法的属性描述符。`PropertyDescriptor` 接口定义如下：'
- en: '[PRE47]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This interface defines the value of an object property, as well as the property''s
    properties (whether the property is configurable, enumerable, and writable). We''ll
    also be using a typed version of this interface, `TypedPropertyDescriptor`, which
    is defined as shown:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口定义了对象属性的值，以及属性的属性（属性是否可配置、可枚举和可写）。我们还将使用此接口的强类型版本，`TypedPropertyDescriptor`，其定义如下所示：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that, in JavaScript, and subsequently TypeScript, property accessors are
    just special methods that manage access to a property. Everything that is applicable
    to decorating methods is also applicable to decorating accessors. Any accessor
    specifics will be covered separately.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在JavaScript和随后的TypeScript中，属性访问器只是管理属性访问的特殊方法。适用于装饰方法的一切也适用于装饰访问器。任何访问器特定的内容将单独介绍。
- en: 'If you set up a decorator on a method, we''ll be getting the `PropertyDescriptor`
    instance of the method itself, and the `value` property of the descriptor will
    give us access to its body. If you set up a decorator on an accessor, we''ll be
    getting the `PropertyDescriptor` instance of the corresponding property, with
    its `get` and `set` properties respectively set to the getter and setter accessors.
    This means that if you''re decorating property accessors, you don''t have to separately
    decorate the getter and the setter, as any decoration of one is a decoration on
    the other. In fact, TypeScript will issue the following error if you do so:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个方法上设置了一个装饰器，我们将得到该方法的`PropertyDescriptor`实例，并且描述符的`value`属性将给我们访问其主体的权限。如果你在一个访问器上设置了一个装饰器，我们将得到相应属性的`PropertyDescriptor`实例，其`get`和`set`属性分别设置为获取器和设置器访问器。这意味着如果你正在装饰属性访问器，你不需要分别装饰获取器和设置器，因为对其中一个的任何装饰都是对另一个的装饰。实际上，如果你这样做，TypeScript将发出以下错误：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The method decorators do not have to return a value, as most of the time you
    can do the desired actions by modifying the property descriptor. If you do return
    a value, however, that value will replace the originally provided property descriptor.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 方法装饰器不需要返回值，因为大多数情况下，你可以通过修改属性描述符来完成所需操作。然而，如果你返回一个值，那么这个值将替换最初提供的属性描述符。
- en: Decorators on Instance Functions
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例函数上的装饰器
- en: 'As described in the preceding section, any function that takes the `target`,
    `propertyKey`, and `descriptor` parameters can be used to decorate methods and
    property accessors. So, let''s have a function that will simply log the `target`,
    `propertyKey`, and `descriptor` parameters to the console:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，任何接受`target`、`propertyKey`和`descriptor`参数的函数都可以用来装饰方法和属性访问器。所以，让我们有一个将简单地记录`target`、`propertyKey`和`descriptor`参数到控制台的功能：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can use this function to decorate a class' methods. This is an extremely
    simple decorator, but you can use it to investigate the usage of method decorators.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个函数来装饰类的成员方法。这是一个极其简单的装饰器，但你可以用它来调查方法装饰器的使用情况。
- en: 'Let''s start with a simple class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的类开始：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The class has a constructor, a method called `teach`, and a `title` property
    with a defined getter and setter. The accessors simply pass through control to
    the `_title` private field. You can add the decorator to the `teach` methods using
    the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个构造函数，一个名为`teach`的方法，以及一个具有定义的获取器和设置器的`title`属性。访问器只是将控制权传递给`_title`私有字段。你可以使用以下代码将装饰器添加到`teach`方法上：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When you run your code (no need to instantiate the class), you''ll get the
    following output on the console:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行你的代码（不需要实例化类）时，你将在控制台得到以下输出：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Consider the following snippets in which you apply the decorator to the setter
    or getter (either one will work fine, but not both):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，其中你将装饰器应用于设置器或获取器（任何一个都可以正常工作，但不能同时使用）：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Or:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You will get the following output when you run the code using either of the
    preceding suggestions:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用上述任何一种建议运行代码时，你将得到以下输出：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that you cannot add a method decorator on the constructor itself, as you
    will get an error:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你无法在构造函数本身上添加方法装饰器，因为这会导致错误：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If you need to change the behavior of the constructor, you should use class decorators.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更改构造函数的行为，你应该使用类装饰器。
- en: 'Exercise 7.04: Creating a Decorator That Marks a Function Enumerable'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.04：创建一个标记函数可枚举的装饰器
- en: In this exercise, you will create a decorator that will be able to change the
    `enumerable` state of the methods and accessors that it decorates. You will use
    this decorator to set the `enumerable` state of some functions in a class that
    you'll write, and finally, you'll verify that when you enumerate the properties
    of the object instance, you get the modified methods as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个装饰器，它将能够改变它所装饰的方法和访问器的`enumerable`状态。你将使用这个装饰器来设置你将要编写的类中一些函数的`enumerable`状态，最后，你将验证当你枚举对象实例的属性时，你也会得到修改后的方法。
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before you begin, make sure you have set up the correct compiler options as
    mentioned in the *Setting Up Compiler Options* section. The code file for this
    exercise can also be downloaded from [https://packt.link/1nAff](https://packt.link/1nAff).
    This repository contains two files: `teacher-enumerating.start.ts` and `teacher-enumerating.end.ts`.
    The former contains the code up to *step 5* of this exercise, and the latter contains
    the final code of the exercise.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，请确保你已经设置了正确的编译器选项，如*设置编译器选项*部分所述。这个练习的代码文件也可以从[https://packt.link/1nAff](https://packt.link/1nAff)下载。这个存储库包含两个文件：`teacher-enumerating.start.ts`和`teacher-enumerating.end.ts`。前者包含这个练习的*步骤5*之前的代码，后者包含练习的最终代码。
- en: Open Visual Studio Code, create a new file in a new directory (`Exercise04`),
    and save it as `teacher-enumerating.ts`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio Code，在新的目录（`Exercise04`）中创建一个新文件，并将其保存为`teacher-enumerating.ts`。
- en: 'Enter the following code in `teacher-enumerating.ts`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`teacher-enumerating.ts`中输入以下代码：
- en: '[PRE58]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Write code that will instantiate an object of this class:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以实例化这个类的对象：
- en: '[PRE59]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Write code that will enumerate all the keys in the created object:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以枚举创建的对象中的所有键：
- en: '[PRE60]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Execute the file and verify that the only keys that are displayed on the console
    are `name` and `_title`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行文件并验证在控制台上显示的唯一键是`name`和`_title`。
- en: 'Add a decorator factory that takes a Boolean parameter and generates a method
    decorator that will set the `enumerable` status to the provided parameter:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个接受布尔参数的装饰器工厂，该工厂将生成一个设置提供的参数的`enumerable`状态的函数装饰器：
- en: '[PRE61]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Use the decorator to decorate the `title` getter or setter accessors and the
    `teach` method:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用装饰器装饰`title`获取器或设置器访问器以及`teach`方法：
- en: '[PRE62]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Rerun the code and verify that the `title` and `teach` properties are being enumerated:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并验证`title`和`teach`属性是否被枚举：
- en: '[PRE63]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this exercise, you saw how to add a create a method decorator factory and
    how to apply it to an instance method or an instance property accessor. You learned
    how to make a property enumerable, and you used that knowledge to set the `enumerable`
    state of the functions of a class. Finally, you enumerated all the properties
    of a class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了如何添加一个方法装饰器工厂并将其应用于实例方法或实例属性访问器。你学习了如何使属性可枚举，并使用这些知识来设置类中函数的`enumerable`状态。最后，你枚举了一个类的所有属性。
- en: Decorators on Static Functions
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态函数上的装饰器
- en: 'Just like with instance methods, decorators can be used with static methods
    as well. You add a static method to your `Teacher` class like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 就像实例方法一样，装饰器也可以用于静态方法。你可以这样向你的`Teacher`类添加一个静态方法：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We are allowed to use method decorators on the static methods as well. So,
    you can add the `DecorateMethod` decorator using the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样允许在静态方法上使用方法装饰器。因此，你可以使用以下代码添加`DecorateMethod`装饰器：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When you run the code, you will get output similar to this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你将得到类似以下的输出：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The principal difference with the instance methods is the `target` parameter.
    Instance methods and accessors are generated on the class prototype, and consequently,
    when using a method/accessor decorator, you receive the class prototype as a `target`
    parameter. Static methods and accessors are generated on the class variable itself,
    and consequently, when using a method/accessor decorator, you receive the class
    variable in the guise of the constructor function as a `target` parameter.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例方法的主要区别是`target`参数。实例方法和访问器是在类原型上生成的，因此，当使用方法/访问器装饰器时，你会收到类原型作为`target`参数。静态方法和访问器是在类变量本身上生成的，因此，当使用方法/访问器装饰器时，你会收到类变量作为构造函数的化身作为`target`参数。
- en: Note that this is the exact same object that you're getting as a class decorator
    parameter. You can even use it in much the same way. However, in method decorators,
    the focus should be on the actual property we've decorated. It is considered a
    bad practice to manipulate the constructor inside a non-class decorator.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这正是你作为类装饰器参数得到的确切相同的对象。你甚至可以用几乎相同的方式使用它。然而，在方法装饰器中，焦点应该放在我们实际装饰的属性上。在非类装饰器内部操作构造函数被认为是一种不好的做法。
- en: Method Wrapping Decorators
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法包装装饰器
- en: The most common usage of method decorators is to use it to wrap the original
    method, adding some custom cross-cutting code. Examples would be adding some general
    error handling or adding automatic logging capabilities.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 方法装饰器的最常见用法是将其用于包装原始方法，添加一些自定义的横切代码。例如，添加一些通用的错误处理或添加自动日志记录功能。
- en: In order to do that, you need to change the function that is being called. You
    can do that using the `value` property of method property descriptors, and by
    using the `get` and `set` properties of the property accessor descriptors.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要更改被调用的函数。你可以通过使用方法属性描述符的 `value` 属性，以及使用属性访问器描述符的 `get` 和 `set` 属性来实现这一点。
- en: 'Exercise 7.05: Creating a Logging Decorator for a Method'
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.05：为方法创建日志装饰器
- en: 'In this exercise, you''ll be creating a decorator that will log each time a
    decorated method or accessor is called. You will use this decorator to add logging
    to the `Teacher` class and you''ll verify that each time you use the decorated
    methods and property accessors, you get an appropriate log entry:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个装饰器，每次调用被装饰的方法或访问器时都会记录日志。你将使用这个装饰器向 `Teacher` 类添加日志记录，并验证每次使用被装饰的方法和属性访问器时，都会得到适当的日志条目：
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you begin, make sure you have set up the correct compiler options as
    mentioned in the *Setting Up Compiler Options* section. The code file for this
    exercise can also be downloaded from [https://packt.link/rmEZi](https://packt.link/rmEZi).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，请确保你已经设置了正确的编译器选项，如 *设置编译器选项* 部分所述。此练习的代码文件也可以从 [https://packt.link/rmEZi](https://packt.link/rmEZi)
    下载。
- en: Open Visual Studio Code, create a new file in a new directory (`Exercise05`),
    and save it as `teacher-logging.ts`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code，在新的目录（`Exercise05`）中创建一个新文件，并将其保存为 `teacher-logging.ts`。
- en: 'Enter the following code in `teacher-logging.ts`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `teacher-logging.ts` 文件中输入以下代码：
- en: '[PRE67]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Execute the code, and notice that it outputs `John Smith is teaching` and `Mr.
    John Smith` to the console.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码，注意它将输出 `John Smith is teaching` 和 `Mr. John Smith` 到控制台。
- en: 'Create a method decorator factory that can wrap any method, getter or setter,
    with a logging statement. It will take a string parameter and return a decorator
    function. Initially, you won''t make any changes to the property descriptor:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法装饰器工厂，可以包装任何方法、获取器或设置器，并添加一个日志语句。它将接受一个字符串参数并返回一个装饰器函数。最初，你不会对属性描述符进行任何更改：
- en: '[PRE68]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Decorate the `teach` method and the `title` get accessor using the `LogMethod`
    decorator with an appropriate message parameter:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有适当消息参数的 `LogMethod` 装饰器装饰 `teach` 方法和 `title` 获取器：
- en: '[PRE69]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Execute the code, and notice that there are no changes to the behavior.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码，注意行为没有发生变化。
- en: 'Now, add a `logger` object to your application:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向你的应用程序添加一个 `logger` 对象：
- en: '[PRE70]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In an actual production-grade implementation, you might log to a database, a
    file, a third-party service, and so on. In the preceding step, you are simply
    logging to the console.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实际的生产级实现中，你可能需要将日志记录到数据库、文件、第三方服务等等。在上一个步骤中，你只是将日志记录到控制台。
- en: 'Add code to the decorator factory that will wrap the property descriptors,
    `value`, `get`, and `set` properties (if they are present):'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向装饰器工厂添加代码，用于包装属性描述符，包括 `value`、`get` 和 `set` 属性（如果存在）：
- en: '[PRE71]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Execute the code and verify that you get logging messages to the console when
    you call the method as well as when you use the `title` property:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码并验证，当你调用方法以及使用 `title` 属性时，都会在控制台得到日志消息。
- en: '[PRE72]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this exercise, you saw how to wrap the provided definitions of methods and
    property accessors class in such a way that you could run custom code on every
    invocation without changing the behavior of the functions themselves. You used
    that to add logging capabilities to functions that did not have any. You constructed
    objects of that class and verified that the logging functionality is operational.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了如何包装提供的方法和属性访问器类的定义，以便在每次调用时运行自定义代码，而不改变函数本身的行为。你使用了这一点来为没有任何日志记录功能的函数添加日志记录功能。你构建了这个类的对象并验证了日志功能的运行情况。
- en: 'Activity 7.01: Creating Decorators for Call Counting'
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动第 7.01 部分：创建用于调用计数的装饰器
- en: As a developer of a backend service for a website, you are tasked with creating
    a solution that will enable the operations department to have clear auditing on
    the behavior of the service. For that, the app is required to have a tally of
    all class instantiations and method invocations.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网站后端服务的开发者，你被要求创建一个解决方案，使运营部门能够清楚地审计服务的操作行为。为此，应用程序需要统计所有类的实例化和方法调用。
- en: In this activity, you're going to create class and method decorators that can
    be used to count class instantiations and method invocations. You will create
    a class that contains data about a person and use the decorators to count how
    many such objects were created and how many times each method was called. After
    you have constructed several objects and used their properties, take a look at
    the values of the counters.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将创建类和方法装饰器，这些装饰器可以用来统计类的实例化和方法调用次数。你将创建一个包含有关个人信息的数据的类，并使用装饰器来统计创建了多少个这样的对象以及每个方法被调用了多少次。在你构建了几个对象并使用它们的属性之后，查看计数器的值。
- en: The aim of this activity is to demonstrate the uses of class and method decorators
    in order to address a cross-cutting concern of your application, without changing
    the functionality of the given class. You should have a detailed statistic of
    the life cycles of your objects, without adding any complexity to the business
    logic.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目的是展示类和方法装饰器的用途，以便解决应用程序的横切关注点，而不改变给定类的功能。你应该有关于你的对象生命周期的详细统计信息，而不增加任何业务逻辑的复杂性。
- en: 'The following steps should help you with the solution:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你解决问题：
- en: Note
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you begin, make sure you have set up the correct compiler options as
    mentioned in the *Setting Up Compiler Options* section. The code file for this
    activity can also be downloaded from [https://packt.link/UK49t](https://packt.link/UK49t).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保你已经设置了如 *设置编译器选项* 部分所述的正确编译器选项。此活动的代码文件也可以从 [https://packt.link/UK49t](https://packt.link/UK49t)
    下载。
- en: Create a class called `Person` with public properties named `firstName`, `lastName`,
    and `birthday`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Person` 的类，具有名为 `firstName`、`lastName` 和 `birthday` 的公共属性。
- en: Add a constructor that initializes the properties via the constructor parameters.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个构造函数，通过构造函数参数初始化属性。
- en: Add a private field called `_title` and expose it via a getter and setter as
    a property called `title`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `_title` 的私有字段，并通过名为 `title` 的属性作为getter和setter公开它。
- en: Add a method called `getFullName` that will return the full name of a person.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `getFullName` 的方法，它将返回一个人的全名。
- en: Add a method called `getAge` that will return the current age of the person
    (by subtracting the birthday from the current year).
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `getAge` 的方法，它将返回人的当前年龄（通过从当前年份减去生日）。
- en: Create a global object called `count` and initialize it to the empty object.
    This will be your state variable, where you store the counts for every instantiation
    and invocation.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个全局对象 `count` 并将其初始化为空对象。这将作为你的状态变量，用于存储每个实例化和调用的计数。
- en: Create a constructor wrapping decorator factory called `CountClass` that will
    take a string parameter called `counterName`. We'll use that parameter as a key
    into the `count` object.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `CountClass` 的构造函数包装装饰器工厂，它将接受一个名为 `counterName` 的字符串参数。我们将使用该参数作为 `count`
    对象的键。
- en: Inside the wrapping code, increase the `count` object's property defined in
    the `counterName` parameter by 1.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包装代码内部，通过 `counterName` 参数定义的 `count` 对象的属性增加 1。
- en: Don't forget to set the prototype chain of the wrapped constructor.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记设置包装构造函数的原型链。
- en: Create a method wrapping decorator factory called `CountMethod` that will take
    a string parameter called `counterName`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `CountMethod` 的方法包装装饰器工厂，它将接受一个名为 `counterName` 的字符串参数。
- en: Add checks for whether the `descriptor` parameter has `value`, `get`, and `set`
    properties. You need to cover both the cases where this decorator is used as an
    accessor and as a method decorator.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加检查以确定`descriptor`参数是否具有`value`、`get`和`set`属性。您需要涵盖两种情况，即此装饰器用作访问器和方法装饰器时的情况。
- en: In each respective branch, add code that wraps the method.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个相应的分支中，添加包装方法的代码。
- en: Inside the wrapping code, increase the `count` object's property defined in
    the `counterName` parameter by 1.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包装代码内部，将`counterName`参数中定义的`count`对象的属性增加1。
- en: Decorate the class using the `CountClass` decorator, with a `person` parameter.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CountClass`装饰器装饰类，并带有`person`参数。
- en: Decorate `getFullName`, `getAge`, and the `title` property getter with the `CountMethod`
    decorator, using the `person-full-name`, `person-age`, and `person-title` parameters,
    respectively. Note that you need to decorate only one of the property accessors.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CountMethod`装饰器分别装饰`getFullName`、`getAge`和`title`属性获取器，参数分别为`person-full-name`、`person-age`和`person-title`。请注意，您只需要装饰一个属性访问器。
- en: Write code outside the class that will instantiate three `person` objects.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类外部编写代码，以实例化三个`person`对象。
- en: Write code that will call the `getFullName` and `getAge` methods on the objects
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码，调用对象的`getFullName`和`getAge`方法。
- en: Write code that will check whether the `title` property is empty and set it
    to something if it is.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码，检查`title`属性是否为空，如果为空则设置它。
- en: Write code that will log the `count` object to the console in order to see if
    your decorators are running correctly.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码，将`count`对象记录到控制台，以查看您的装饰器是否运行正确。
- en: 'The expected output is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This activity demonstrates the power of using decorators to extend and augment
    the capabilities of your classes without polluting the code. You were able to
    inject custom code execution into your objects, without changing any of the underlying
    business logic.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动展示了使用装饰器扩展和增强类功能而不污染代码的能力。您能够在不更改任何底层业务逻辑的情况下，向对象中注入自定义代码执行。
- en: Note
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to the activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor416).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的解决方案可以通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor416)找到。
- en: Using Metadata in Decorators
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在装饰器中使用元数据
- en: 'So far, you''ve been decorating classes and methods. These are basically pieces
    of code that get executed, and you have been able to change and augment the code
    that got executed. But your code consists not only of "active," live code, but
    of other definitions as well – in particular, your classes have fields, and your
    methods have parameters. In the activity before this section, you were able to
    detect whenever the `title` property was accessed because you had a method that
    was getting the value, and a method that was setting the value – so you piggybacked
    your code to the already existing "active" code. But how do you decorate the "passive"
    parts of your program? You cannot attach code that runs when your "passive" code
    gets executed, because frankly there''s nothing to execute in `public firstName:
    string`. It''s a simple definition.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，您一直在装饰类和方法。这些基本上是执行中的代码片段，您已经能够更改和增强执行中的代码。但您的代码不仅包括“活跃”的代码，还包括其他定义——特别是，您的类有字段，您的方
    法有参数。在上一节的活动之前，您能够检测到何时访问`title`属性，因为您有一个获取值的方法和一个设置值的方法——所以您将代码附加到已经存在的“活跃”代码上。但您如何装饰程序的“被动”部分呢？您不能附加在“被动”代码执行时运行的代码，因为坦白地说，在`public
    firstName: string`中没有什么可以执行的。这是一个简单的定义。'
- en: 'You cannot attach any code that gets executed for your "passive code," but
    what you can do using decorators is add some data to some global object regarding
    the decorated "passive" piece of code. In *Activity 7.01: Creating Decorators
    for Call Counting*, you defined a global `count` object and used that in your
    decorators to keep track of the executions. That approach works, but it requires
    creating a global variable, which is bad in most cases. It would be much cleaner
    if you were able to define some kind of properties on the methods and classes
    themselves. But, on the other hand, you don''t want to add too many properties
    that are available alongside the business logic code – the possibility of incidental
    error is too high. What you need is to be able to somehow add metadata to your
    classes and methods.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能为您的“被动代码”附加任何执行代码，但您可以使用装饰器向有关装饰的“被动”代码片段的某个全局对象添加一些数据。在 *活动 7.01：为调用计数创建装饰器*
    中，您定义了一个全局 `count` 对象，并在装饰器中使用它来跟踪执行。这种方法是可行的，但它需要创建一个全局变量，这在大多数情况下都是不好的。如果您能够在方法和类本身上定义某种属性，那就更干净利落了。但另一方面，您不希望添加太多与业务逻辑代码并存的属性——意外错误的概率太高。您需要能够以某种方式向您的类和方法添加元数据。
- en: Fortunately, this is a common problem and there is a proposal to add proper
    metadata support to JavaScript. In the meantime, there is a polyfill library called
    **reflect-metadata** that can be used.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是一个常见问题，并且有一个提议要为 JavaScript 添加适当的元数据支持。在此期间，有一个名为 **reflect-metadata**
    的 polyfill 库可以用来。
- en: Note
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: For more information on the `reflect-metadata` library, visit [https://www.npmjs.com/package/reflect-metadata](https://www.npmjs.com/package/reflect-metadata).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `reflect-metadata` 库的更多信息，请访问 [https://www.npmjs.com/package/reflect-metadata](https://www.npmjs.com/package/reflect-metadata)。
- en: What this library does, in essence, is attach a special property to your classes
    that gives us a place to store, retrieve, and work with metadata about your class.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库本质上所做的，是向您的类附加一个特殊属性，为我们提供了一个存储、检索和处理有关类元数据的地方。
- en: In TypeScript, in order to use this feature, you have to specify an additional
    compiler flag, either via the command line or via `tsconfig.json`. That is the
    `emitDecoratorMetadata` flag, which needs to be set to `true` in order to work
    with the metadata methods.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，为了使用此功能，您必须指定一个额外的编译器标志，无论是通过命令行还是通过 `tsconfig.json`。这就是 `emitDecoratorMetadata`
    标志，需要将其设置为 `true` 以便与元数据方法一起使用。
- en: Reflect Object
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Reflect 对象
- en: 'The API of the `reflect-metadata` library is straightforward, and mostly you
    can focus on the following methods:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect-metadata` 库的 API 很简单，您主要可以关注以下方法：'
- en: '`Reflect.defineMetadata`: Defines a piece of metadata on a class or a method'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.defineMetadata`: 在类或方法上定义元数据'
- en: '`Reflect.hasMetadata`: Returns a Boolean indicating whether a certain piece
    of metadata is present'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.hasMetadata`: 返回一个布尔值，指示是否存在某个特定的元数据'
- en: '`Reflect.getMetadata`: Returns the actual piece of metadata, if present'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.getMetadata`: 如果存在，返回实际的元数据'
- en: 'Consider the following code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE74]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here you have a class called `Teacher` that has a simple private field, `_title`,
    which has `get` and `set` accessor methods for a property called `title`, and
    a method called `teach` that logs to the console that the teacher is, in fact,
    teaching.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个名为 `Teacher` 的类，它有一个简单的私有字段 `_title`，该字段为名为 `title` 的属性提供了 `get` 和 `set`
    访问器方法，还有一个名为 `teach` 的方法，该方法将向控制台记录教师实际上正在教学。
- en: 'You can define a metadata key called `call-count` on the `Teacher` class and
    set its value to `0` by executing the following call to `defineMetadata`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `Teacher` 类上定义一个名为 `call-count` 的元数据键，并通过执行以下 `defineMetadata` 调用来将其值设置为
    `0`：
- en: '[PRE75]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If you want to add a metadata key called `call-count`, not on the `Teacher`
    class itself but on the `teach` method, you could do so with the following call
    to `defineMetadata`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 `teach` 方法上而不是在 `Teacher` 类本身上添加一个名为 `call-count` 的元数据键，您可以使用以下 `defineMetadata`
    调用来实现：
- en: '[PRE76]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This will define a metadata key called `call-count` on the `Teacher` class''
    `teach` property and set its value to `10`. You can retrieve these values using
    the following commands:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `Teacher` 类的 `teach` 属性上定义一个名为 `call-count` 的元数据键，并将其值设置为 `10`。您可以使用以下命令检索这些值：
- en: '[PRE77]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In essence, you can create a method that will register a call of a method with
    the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，您可以使用以下代码创建一个方法，该方法将方法调用注册为：
- en: '[PRE78]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This code will first call the `hasMetadata` method, to check whether you have
    already defined a value for the `call-count` metadata. If that is `true`, the
    `hasMetadata` method will call `getMetadata` to get the current value and then
    call `defineMetadata` to re-define the metadata property with an increased (`value+1`)
    value. If you did not have such a metadata property, the `defineMetadata` method
    will define it with a value of 1\.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将首先调用`hasMetadata`方法，以检查你是否已经为`call-count`元数据定义了一个值。如果是`true`，则`hasMetadata`方法将调用`getMetadata`以获取当前值，然后调用`defineMetadata`以重新定义元数据属性，其值为增加的（`value+1`）。如果你没有这样的元数据属性，则`defineMetadata`方法将使用值为1来定义它。
- en: When called with `increaseCallCount(Teacher, "teach");`, it will successfully
    increase the call count of the `teach` method of the `Teacher` class. The metadata
    added to the class will in no way hinder the behaviors that the class already
    has, so any code that is being executed won't be affected.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`increaseCallCount(Teacher, "teach");`调用时，它将成功增加`Teacher`类中`teach`方法的调用次数。添加到类中的元数据将不会以任何方式阻碍类已有的行为，因此正在执行的任何代码都不会受到影响。
- en: 'Exercise 7.06: Adding Metadata to Methods via Decorators'
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.06：通过装饰器添加方法元数据
- en: 'In this exercise, we''ll create a simple class and apply some metadata for
    describing its methods. After you have done this, you will write a function that
    given a class, will display its available descriptions:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个简单的类并为其方法添加一些元数据。完成此操作后，你将编写一个函数，给定一个类，将显示其可用的描述：
- en: Note
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you begin, make sure you have set up the correct compiler options as
    mentioned in the *Setting Up Compiler Options* section. The code file for this
    exercise can also be downloaded from [https://packt.link/JG4F8](https://packt.link/JG4F8).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，请确保你已经设置了如*设置编译器选项*部分中提到的正确编译器选项。此练习的代码文件也可以从[https://packt.link/JG4F8](https://packt.link/JG4F8)下载。
- en: Open Visual Studio Code, create a new file in a new directory (`Exercise06`),
    and save it as `calculator-metadata.ts`.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code，在新的目录（`Exercise06`）中创建一个新文件，并将其保存为`calculator-metadata.ts`。
- en: 'Enter the following code in `calculator-metadata.ts`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`calculator-metadata.ts`中输入以下代码：
- en: '[PRE79]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, add metadata descriptions for the class and some of its methods:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为类及其一些方法添加元数据描述：
- en: '[PRE80]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Define a function that when given a class will reflect upon it and extract
    and display the class'' `description` metadata:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，当给定一个类时，将对其反思并提取并显示该类的`description`元数据：
- en: '[PRE81]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Call the function using `showDescriptions(Calculator);` and verify that it
    will display the following output:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`showDescriptions(Calculator);`调用该函数，并验证它将显示以下输出：
- en: '[PRE82]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In order to get a list of all methods of a class, we'll have to use the `Object.getOwnPropertyNames`
    function. Additionally, since the methods are actually defined on the prototype
    of the class, the correct line that gets all methods names of a class is `const
    methodNames = Object.getOwnPropertyNames(target.prototype);`.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了获取类的所有方法列表，我们必须使用`Object.getOwnPropertyNames`函数。此外，由于方法实际上是在类的原型上定义的，因此获取类所有方法名称的正确行是`const
    methodNames = Object.getOwnPropertyNames(target.prototype);`。
- en: 'Next, loop over the returned array and check each method for a description.
    The `showDescription` function will now have the following format:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，遍历返回的数组并检查每个方法是否有描述。`showDescription`函数现在将具有以下格式：
- en: '[PRE83]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Call the function again and verify that it will display the following output:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用该函数并验证它将显示以下输出：
- en: '[PRE84]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note that you're not displaying anything for the `multiply` method, as you did
    not add any metadata for it.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你没有为`multiply`方法显示任何内容，因为你没有为其添加任何元数据。
- en: In this exercise, you learned how to add metadata to classes and methods and
    how to check its existence and, if present, to retrieve it. You also managed to
    get a list of all the methods of a given class.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你学习了如何向类和方法添加元数据，以及如何检查其存在性，如果存在，则检索它。你还成功获取了给定类的所有方法的列表。
- en: Property Decorators
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性装饰器
- en: A property decorator is a decorator function that is applied to a single property
    of a class. Unlike in a method or class decorators, you cannot modify or replace
    the property definition, but you can indeed observe it.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 属性装饰器是一个应用于类单个属性的装饰器函数。与方法或类装饰器不同，你不能修改或替换属性定义，但你确实可以观察它。
- en: Note
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since you receive the constructor function in the decorator, this is not strictly
    true. You could change the code of the class, but it's extremely inadvisable.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在装饰器中接收构造函数，这并不完全正确。你可以更改类的代码，但这非常不推荐。
- en: 'When a property decorator is called, it receives two parameters: `target` and `propertyKey`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用属性装饰器时，它接收两个参数：`target`和`propertyKey`：
- en: '`target`: Since properties can be both instance properties (defined on instances
    of the class) and static properties (defined on the class itself), `target` can
    be two different things. For instance properties, it''s the prototype of the class.
    For static properties, it''s the constructor function of the class. Usually, you
    would type this parameter as `any`.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`: 由于属性可以是实例属性（在类的实例上定义）和静态属性（在类本身上定义），因此`target`可以是两件不同的事情。对于实例属性，它是类的原型。对于静态属性，它是类的构造函数。通常，你会将此参数类型指定为`any`。'
- en: '`propertyKey`: This is the name of the property you''re decorating.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyKey`: 这是你要装饰的属性的名称。'
- en: In contrast to the method decorators, you're not receiving a property descriptor
    parameter, because, plainly, there isn't one available. Also, because you do not
    return any code that can be replaced, the return value of a property decorator
    is ignored.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 与方法装饰器不同，你不会收到属性描述符参数，因为显然没有可用的参数。另外，因为你没有返回任何可以替换的代码，所以属性装饰器的返回值被忽略。
- en: 'For example, you can define a simple property decorator factory that just logs
    a message to the console to notify that the property is actually decorated:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以定义一个简单的属性装饰器工厂，它只是将消息记录到控制台以通知属性实际上已被装饰：
- en: '[PRE85]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Consider the following class definitions:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类定义：
- en: '[PRE86]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can annotate the `id` and `name` properties using the following code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码注释`id`和`name`属性：
- en: '[PRE87]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If you now execute the code (we don''t need to call anything; it will be called
    by the TypeScript engine), you obtain the following output:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在执行代码（我们不需要调用任何东西；TypeScript 引擎将调用它），你将获得以下输出：
- en: '[PRE88]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that you did not create any objects of the teacher class, or call any methods.
    The decorators executed when the class was defined. Since property decorators
    are passive, usually you'll use them to feed some kind of data into some mechanism
    that will use it. One of the common approaches is to combine the passive decorators
    with one or several active decorators, that is, class and method decorators.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你没有创建任何教师类的对象，也没有调用任何方法。装饰器在定义类时执行。由于属性装饰器是被动型的，通常你会使用它们将某种数据输入到某种机制中，该机制将使用这些数据。常见的方法之一是将被动装饰器与一个或多个主动装饰器（即类和方法的装饰器）结合使用。
- en: Note
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is the case in Angular, for example, where the passive `@Input` and `@Output`
    decorators are combined with the active `@Component` decorator.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Angular中，这是常见的情况，其中被动的`@Input`和`@Output`装饰器与主动的`@Component`装饰器结合使用。
- en: Another common use case is to have an additional mechanism that will get the
    data provided by the decorators and use it. For example, you can have the decorators
    recording some metadata, and then have another function that reads and uses that metadata.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的用例是有一个额外的机制来获取装饰器提供的数据并使用它。例如，装饰器可以记录一些元数据，然后有另一个函数读取并使用这些元数据。
- en: 'Exercise 7.07: Creating and Using a Property Decorator'
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.07：创建和使用属性装饰器
- en: 'In this exercise, you''ll create a simple property decorator factory that will
    provide each property with a description. After you have done this, you will write
    a function that given a class will display its available descriptions:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个简单的属性装饰器工厂，将为每个属性提供一个描述。完成此操作后，你将编写一个函数，该函数给定一个类将显示其可用的描述：
- en: Note
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you begin, make sure you have set up the correct compiler options as
    mentioned in the *Setting Up Compiler Options* section. The code file for this
    exercise can also be downloaded from [https://packt.link/1WU6d](https://packt.link/1WU6d).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保你已经设置了如*设置编译器选项*部分所述的正确编译器选项。此练习的代码文件也可以从[https://packt.link/1WU6d](https://packt.link/1WU6d)下载。
- en: Open Visual Studio Code, create a new file in a new directory (`Exercise07`),
    and save it as `teacher-properties.ts`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio Code，在新的目录（`Exercise07`）中创建一个新文件，并将其保存为`teacher-properties.ts`。
- en: 'Enter the following code in `teacher-properties.ts`:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`teacher-properties.ts`文件中输入以下代码：
- en: '[PRE89]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Add a decorator factory that takes a string parameter and generates a property
    decorator that will add a metadata `description` field to the class for the given property:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个装饰器工厂，它接受一个字符串参数并生成一个属性装饰器，该装饰器将为给定属性添加一个元数据`description`字段：
- en: '[PRE90]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, annotate the properties of the `Teacher` class using the description:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下描述注释`Teacher`类的属性：
- en: '[PRE91]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Define a function that, when given an object, will reflect upon it and extract
    and display the `description` metadata for the object''s properties:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，当给定一个对象时，将反思该对象并提取并显示该对象的`description`元数据：
- en: '[PRE92]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create an object of the `Teacher` class:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Teacher`类的对象：
- en: '[PRE93]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Pass that object to the `showDescriptions` function:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该对象传递给`showDescriptions`函数：
- en: '[PRE94]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Execute the code and verify that the descriptions are displayed:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码并验证描述是否已显示：
- en: '[PRE95]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In this exercise, you learned how to add metadata to properties using property
    decorators and how to use property decorators to add quick basic documentation
    to your classes.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你学习了如何使用属性装饰器为属性添加元数据，以及如何使用属性装饰器为你的类添加快速的基本文档。
- en: Parameter Decorators
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数装饰器
- en: A parameter decorator is a decorator function that is applied to a single parameter
    of a function call. Just like property decorators, parameter decorators are passive,
    that is, they can be used only to observe values, but not to inject and execute
    code. The return value of a parameter decorator is similarly ignored. As a consequence,
    parameter decorators are almost exclusively used in conjunction with other, active decorators.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 参数装饰器是一个应用于函数调用单个参数的装饰器函数。就像属性装饰器一样，参数装饰器是被动型的，也就是说，它们只能用来观察值，但不能注入和执行代码。参数装饰器的返回值同样被忽略。因此，参数装饰器几乎总是与其他主动装饰器一起使用。
- en: 'When a parameter decorator is called, it receives three parameters: `target`,
    `propertyKey`, and `parameterIndex`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用参数装饰器时，它接收三个参数：`target`、`propertyKey`和`parameterIndex`：
- en: '`target`: The behavior for this parameter is identical to the decorators on
    the corresponding method. There is an exception if the parameter is on a class''
    constructor, but that is explained shortly.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：这个参数的行为与相应的方法装饰器相同。如果参数在类的构造函数上，则有一个例外，但这将在稍后解释。'
- en: '`propertyKey`: This is the name of the method whose parameter you''re decorating
    (the constructor exception is explained shortly).'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyKey`：这是你要装饰的方法的名称（类的构造函数例外将在稍后解释）。'
- en: '`parameterIndex`: This is the ordinal index of the parameter in the function''s
    parameter list (starting with zero for the first parameter).'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameterIndex`: 这是在函数参数列表中参数的序号索引（第一个参数从零开始）。'
- en: 'So, let''s have a function that will simply log the `target`, `propertyKey`,
    and `parameterIndex` parameters to the console:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们有一个函数，它将简单地记录`target`、`propertyKey`和`parameterIndex`参数到控制台：
- en: '[PRE96]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You can use this function to decorate a function''s parameters and can investigate
    the usage of parameter decorators. Let''s start with a simple class:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个函数来装饰函数的参数，并调查参数装饰器的使用情况。让我们从一个简单的类开始：
- en: '[PRE97]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The class has a constructor that takes two parameters, `id` and `name`, and
    a method called `getFullName`, which takes two parameters, `title` and `suffix`.
    Say you add your decorator to the first parameter of the `getFullName` methods,
    using this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有一个接受两个参数`id`和`name`的构造函数，以及一个名为`getFullName`的方法，该方法接受两个参数`title`和`suffix`。假设你将装饰器添加到`getFullName`方法的第一个参数上，如下所示：
- en: '[PRE98]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If you run your code (no need to instantiate the class), you''ll get the following
    output on the console:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行你的代码（不需要实例化类），你将在控制台上得到以下输出：
- en: '[PRE99]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can also apply parameter decorators to the parameters of the constructor
    function itself. Say you decorate the second constructor parameter, like this:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将参数装饰器应用于构造函数本身的参数。比如说，你装饰第二个构造函数参数，如下所示：
- en: '[PRE100]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You will get the following output when you run the code:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你会得到以下输出：
- en: '[PRE101]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note that in this case, the target is not the prototype of the class, but the
    class constructor itself. Also, when decorating constructor parameters, the name
    of the property is `undefined`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，目标不是类的原型，而是类构造函数本身。另外，当装饰构造函数参数时，属性的名称是`undefined`。
- en: 'Exercise 7.08: Creating and Using a Parameter Decorator'
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.08：创建和使用参数装饰器
- en: 'In this exercise, you will create a parameter decorator that will indicate
    that a certain parameter is required; that is, it should not have an empty value.
    You will also create a validation decorator for the method, so that the validation
    can actually take place. We''ll create a class that uses the decorators, and you
    will try to call the method with both valid and invalid values:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个参数装饰器，它将指示某个参数是必需的；也就是说，它不应该有空的值。你还将创建一个用于方法的验证装饰器，以便验证实际上可以发生。我们将创建一个使用装饰器的类，你将尝试使用有效和无效的值调用该方法：
- en: Note
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you begin, make sure you have set up the correct compiler options as
    mentioned in the *Setting Up Compiler Options* section.The code file for this
    exercise can also be downloaded from [https://packt.link/Hf3fv](https://packt.link/Hf3fv).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保你已经设置了如*设置编译器选项*部分所述的正确编译器选项。此练习的代码文件也可以从[https://packt.link/Hf3fv](https://packt.link/Hf3fv)下载。
- en: Open Visual Studio Code, create a new file in a new directory (`Exercise08`),
    and save it as `teacher-parameters.ts`.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio Code，在新的目录（`Exercise08`）中创建一个新文件，并将其保存为`teacher-parameters.ts`。
- en: 'Enter the following code in `teacher-parameters.ts`:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`teacher-parameters.ts`中输入以下代码：
- en: '[PRE102]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create a parameter decorator called `Required` that will add the index of the
    parameter to the `required` metadata field to the class for the given property:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Required`的参数装饰器，它将给定的属性的索引添加到类的`required`元数据字段中：
- en: '[PRE103]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here, if the metadata already exists, that means that there is another required
    parameter. If so, you load it and concatenate your `parameterIndex`. If there
    is no previous metadata, you define it with an array consisting of your `parameterIndex`.
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，如果元数据已经存在，这意味着还有一个必需的参数。如果是这样，你加载它并将你的`parameterIndex`连接起来。如果没有先前的元数据，你使用包含你的`parameterIndex`的数组定义它。
- en: 'Next, create a method decorator that will wrap the original method and check
    all required parameters *before* calling the original method:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个方法装饰器，它将包装原始方法并在调用原始方法之前检查所有必需参数：
- en: '[PRE104]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If any of your required parameters has a falsy value, instead of executing the
    original method, your decorator will throw an error.
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的任何必需参数有一个假值，那么你的装饰器将不会执行原始方法，而是抛出一个错误。
- en: 'After that, annotate the `title` parameter of the `getFullName` method with
    the `Required` decorator and the method itself with the `Validate` decorator:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`Required`装饰器注释`getFullName`方法的`title`参数，并使用`Validate`装饰器注释该方法本身：
- en: '[PRE105]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Create an object of the `Teacher` class:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Teacher`类的对象：
- en: '[PRE106]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Try to call the `getFullName` method with an empty string as the first parameter:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用空字符串作为第一个参数调用`getFullName`方法：
- en: '[PRE107]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Execute the code and verify that the error message is displayed instead:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码并验证是否显示错误消息：
- en: '[PRE108]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In this exercise, you covered how to create parameter decorators and how to
    use them to add metadata. You also orchestrated the usage of the same metadata
    into another decorator, and build a basic validation system.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你了解了如何创建参数装饰器以及如何使用它们来添加元数据。你还协调了将相同的元数据用于另一个装饰器，并构建了一个基本的验证系统。
- en: Application of Multiple Decorators on a Single Target
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单个目标上应用多个装饰器
- en: It is often necessary to apply more than one decorator on a single target. And
    as decorators can (and do) change the code that actually gets executed, it's important
    to have an understanding of how different decorators play together.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要在单个目标上应用多个装饰器。由于装饰器可以（并且确实）更改实际执行的代码，因此了解不同装饰器如何协同工作是很重要的。
- en: Basically, decorators are functions, and you're using them to compose your targets.
    This means that, in essence, decorators will be applied and executed bottom-up,
    with the decorator that's closest to the target going first and providing the
    result for the second decorators, and so on. This is similar to functional composition;
    that is, when we're trying to calculate `f(g(x))`, first the `g` function will
    be called, and then the `f` function will be called.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，装饰器是函数，你使用它们来组合你的目标。这意味着本质上，装饰器将自下而上地应用和执行，最接近目标的目标装饰器先执行并提供结果给下一个装饰器，依此类推。这类似于函数式组合；也就是说，当我们试图计算`f(g(x))`时，首先调用`g`函数，然后调用`f`函数。
- en: 'There is a small catch when using decorator factories, though. The composition
    rule only applies to the decorators themselves – and decorator factories are not
    decorators per se. They are functions that need to be executed in order to return
    a decorator. This means that they are executed in source code order, that is, top-down.
    Imagine that you have two decorator factories:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用装饰器工厂时，有一个小陷阱。组合规则仅适用于装饰器本身——而装饰器工厂本身不是装饰器。它们是需要执行以返回装饰器的函数。这意味着它们按照源代码顺序执行，即自上而下。想象一下，你有两个装饰器工厂：
- en: '[PRE109]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Second decorator factory:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个装饰器工厂：
- en: '[PRE110]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now imagine that they are applied on a single target:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象它们被应用于单个目标：
- en: '[PRE111]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The generation process will generate the first decorator before the second,
    but in the application process, the second will be applied, and then the first:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 生成过程将在第二个装饰器之前生成第一个装饰器，但在应用过程中，第二个装饰器将被应用，然后才是第一个：
- en: '[PRE112]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Activity 7.02: Using Decorators to Apply Cross-Cutting Concerns'
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第 7.02 部分：使用装饰器应用横切关注点
- en: In this activity, we're going full circle to the basketball game example (`Example_Basketball.ts`).
    You are tasked with adding all the necessary cross-cutting concerns, such as authentication,
    performance metrics, auditing, and validation to the `Example_Basketball.ts` file
    in a maintainable manner.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将完整地回到篮球游戏示例 (`Example_Basketball.ts`)。您需要以可维护的方式向 `Example_Basketball.ts`
    文件添加所有必要的横切关注点，例如身份验证、性能指标、审计和验证。
- en: 'You can begin the activity with the code that you already have in the `Example_Basketball.ts.`
    First, take stock of the elements that are already present in the file:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用已经在 `Example_Basketball.ts.` 中存在的代码开始活动。首先，盘点一下文件中已经存在的元素：
- en: The interface that describes the team.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述团队的接口。
- en: The class for the game itself. You have a constructor that creates the team
    objects given the team names. You also have a `getScore` function that displayed
    the score and a simple `updateScore` method that updates the score of the game,
    taking the scoring team and the score value as parameters.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏本身的类。您有一个构造函数，根据团队名称创建团队对象。您还有一个 `getScore` 函数，用于显示得分，以及一个简单的 `updateScore`
    方法，该方法更新游戏的得分，并接受得分团队和得分值作为参数。
- en: Now you need to add the cross-cutting concerns as mentioned previously without
    changing the code of the class itself, only by using decorators.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要在不更改类本身代码的情况下，仅通过使用装饰器添加之前提到的横切关注点。
- en: Earlier in `Example_Basketball.ts`, you had to completely subsume the business
    logic of keeping score under the code that was needed to address everything else
    (such as authorization, auditing, metrics, and so on). Now apply all the decorator
    skills that are needed so that the application runs properly but still has a crisp
    and clear codebase.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Example_Basketball.ts` 中更早的时候，您必须完全将计分业务逻辑包含在处理其他所有事情（如授权、审计、指标等）所需的代码中。现在应用所有需要的装饰器技能，以便应用程序能够正常运行，同时代码库仍然清晰简洁。
- en: Note
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code file for this activity can also be downloaded from [https://packt.link/7KfCx](https://packt.link/7KfCx).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的代码文件也可以从 [https://packt.link/7KfCx](https://packt.link/7KfCx) 下载。
- en: 'The following steps should help you with the solution:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您解决问题：
- en: Create the code for the `BasketBallGame` class.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `BasketBallGame` 类创建代码。
- en: Create a class decorator factory called `Authenticate` that will take a `permission`
    parameter and return a class decorator with constructor wrapping. The class decorator
    should load the `permissions` metadata property (array of `strings`), then check
    if the passed parameter is an element of the array. If the passed parameter is
    not an element of the array, the class decorator should throw an error, and if
    it's present, it should continue with the class creation.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Authenticate` 的类装饰器工厂，它将接受一个 `permission` 参数并返回一个具有构造函数包装的类装饰器。类装饰器应加载
    `permissions` 元数据属性（字符串数组），然后检查传递的参数是否为数组的元素。如果传递的参数不是数组的元素，类装饰器应抛出错误；如果存在，则继续进行类创建。
- en: Define a metadata property of the `BasketballGame` class called `permissions`
    with the value `["canUpdateScore"]`.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `permissions` 的 `BasketballGame` 类元数据属性，其值为 `["canUpdateScore"]`。
- en: Apply the class decorator factory on the `BasketballGame` class with a parameter
    value of `canUpdateScore`.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数值为 `canUpdateScore` 的类装饰器工厂对 `BasketballGame` 类进行应用。
- en: Create a method decorator called `MeasureDuration` that will use method wrapping
    to start a timer before the method body is executed and stop it after it's done.
    It should calculate the duration and push it to a metadata property called `durations`
    for the method.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MeasureDuration` 的方法装饰器，它将使用方法包装在方法体执行之前启动计时器，并在完成后停止计时。它应计算持续时间并将其推送到名为
    `durations` 的方法元数据属性中。
- en: Apply the `MeasureDuration` method decorator on the `updateScore` method.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `updateScore` 方法上应用 `MeasureDuration` 方法装饰器。
- en: Create a method decorator factory called `Audit` that will take a `message`
    parameter and return a method decorator. The method decorator should use method
    wrapping to get the arguments and the return value of the method. After the successful
    execution of the original method, it should display the audit log to the console.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Audit` 的方法装饰器工厂，它将接受一个 `message` 参数并返回一个方法装饰器。该方法装饰器应使用方法包装来获取方法的参数和返回值。在原始方法成功执行后，它应在控制台显示审计日志。
- en: Apply the `Audit` method decorator factory on the `updateScore` method, with
    a parameter value of `Updated score`.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Audit` 方法装饰器工厂应用于 `updateScore` 方法，参数值为 `Updated score`。
- en: Create a parameter decorator called `OneTwoThree` that will add the decorated
    parameter in the `one-two-three` metadata property.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `OneTwoThree` 的参数装饰器，它将装饰的参数添加到 `one-two-three` 元数据属性中。
- en: Create a method decorator called `Validate` that will use method wrapping to
    load all values for the `one-two-three` metadata property, and for all marked
    parameters check their value. If the value is `1`, `2`, or `3`, it should continue
    the execution of the original method. If not, it should stop the execution with
    an error.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Validate` 的方法装饰器，它将使用方法包装来加载 `one-two-three` 元数据属性的值，并对所有标记的参数检查它们的值。如果值为
    `1`、`2` 或 `3`，则应继续执行原始方法。如果不是，则应停止执行并显示错误。
- en: 'Apply the `OneTwoThree` decorator to the `byPoints` parameter of `updateScore`
    and apply the `Validate` decorator to the `updateScore` method:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `OneTwoThree` 装饰器应用于 `updateScore` 的 `byPoints` 参数，并将 `Validate` 装饰器应用于 `updateScore`
    方法：
- en: '[PRE113]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Note
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For ease of presentation, only a section of the expected output is shown here.
    The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor418).
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了便于展示，这里只展示了预期输出的部分。本活动的解决方案可以通过[这个链接](B14508_Solution_ePub.xhtml#_idTextAnchor418)找到。
- en: In this activity, you are leveraging decoration to quickly and efficiently implement
    complicated cross-cutting concerns. When you have successfully completed the activity,
    you will have implemented multiple kinds of decorators, according to the needs
    of the application, and thus will have widened the functionalities of your code
    without sacrificing clarity and readability.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你利用装饰来快速高效地实现复杂的横切关注点。当你成功完成活动后，你将根据应用需求实现多种类型的装饰器，从而在不牺牲清晰度和可读性的情况下扩展代码的功能。
- en: Summary
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you looked at a technique called **decorating** that is natively
    supported in TypeScript. The chapter first established the motivation for the
    use of decorators and then looked at the multiple types of decorators in TypeScript
    (class, method, accessor, property, and parameter decorators), along with examining
    the possibilities of each. You learned how to swap or change the complete constructor
    of a class with a class decorator, how to wrap a single method or property accessor
    with a method decorator, and how to enrich the available metadata using property
    and parameter decorators.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了一种称为 **装饰** 的技术，它在 TypeScript 中是原生支持的。本章首先确立了使用装饰器的动机，然后探讨了 TypeScript
    中的多种装饰器类型（类、方法、访问器、属性和参数装饰器），并考察了每种的可能性。你学习了如何使用类装饰器交换或更改类的完整构造函数，如何使用方法装饰器包装单个方法或属性访问器，以及如何使用属性和参数装饰器丰富可用的元数据。
- en: The chapter also discussed the differences between active and passive decorators,
    which boil down to a difference between code and definition. You implemented several
    common variants of each of the decorator types and demonstrated how different
    decorator types can nicely complement each other. This chapter should help you
    easily manage the usage and creation of decorators both from third-party libraries
    such as Angular and from decorator factories created by yourself. In the next
    chapter, we will begin our foray into dependency injection in TypeScript.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了主动装饰器和被动装饰器之间的区别，这归结为代码和定义之间的区别。你实现了每种装饰器类型的几个常见变体，并展示了不同类型的装饰器如何很好地相互补充。本章应有助于你轻松管理来自第三方库（如
    Angular）以及你自己创建的装饰器工厂中装饰器的使用和创建。在下一章中，我们将开始探索 TypeScript 中的依赖注入。
