- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Builds and Adapters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和适配器
- en: In the previous four chapters, we’ve spent a significant amount of time discussing
    various routing techniques. From simple routing to pages that can be rendered
    as static HTML and speed up our application, to more complex tactics where we
    ensure the data is of an expected type through the use of regular expressions.
    While these techniques represent core features of SvelteKit, they are not all
    there is to it. Another useful quality found in SvelteKit is its ability to run
    in nearly any environment through the use of adapters. Before we dive into various
    adapters and their configurations, we’ll analyze the process involved when creating
    a production build of a SvelteKit application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前四章中，我们花费了大量时间讨论各种路由技术。从简单的路由到可以渲染为静态HTML并加快我们应用速度的页面，再到更复杂的策略，通过使用正则表达式确保数据是预期的类型。虽然这些技术代表了SvelteKit的核心功能，但它们并不是全部。SvelteKit中另一个有用的特性是它能够通过适配器在几乎任何环境中运行。在我们深入探讨各种适配器和它们的配置之前，我们将分析创建SvelteKit应用程序生产构建所涉及的过程。
- en: Firstly, we’ll need to address how to build our application for a production
    environment. Vite makes this step simple, so we’ll then pivot to how we can use
    different adapters to adjust builds for various environments. While each adapter
    has its own requirements, it would quickly become repetitive to discuss them all.
    Instead, we’ll focus on three different adapters that are each suited to unique
    environments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要解决如何为生产环境构建我们的应用程序。Vite使这一步变得简单，然后我们将转向如何使用不同的适配器调整不同环境的构建。虽然每个适配器都有自己的要求，但讨论它们所有很快就会变得重复。相反，我们将专注于三个不同的适配器，它们各自适合独特的环境。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a Build
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建构建
- en: Adapting the App
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配应用
- en: Once complete, you’ll be able to build and deploy your very own applications
    to a multitude of platform types, including static hosts, Node.js, and a plethora
    of serverless environments.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，你将能够构建和部署你自己的应用程序到多种平台类型，包括静态主机、Node.js以及众多无服务器环境。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter08](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter08).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter08](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter08)。
- en: Creating a Build
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建构建
- en: In other books about web development frameworks, a section related to creating
    a production build of the application usually doesn’t come until the very end.
    But because SvelteKit and Vite make it so simple, there’s really no reason to
    wait. I’m sure you’re eager to get your application available as soon as possible,
    so let’s get straight to it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他关于Web开发框架的书籍中，关于创建应用程序生产构建的部分通常要到书的最后才出现。但鉴于SvelteKit和Vite使这一过程变得如此简单，实际上没有等待的理由。我相信你急于尽快让你的应用程序可用，所以让我们直接进入正题。
- en: 'So far, we’ve only worked with our application in the development environment.
    In essence, Vite started a development server on the local machine when we ran
    the `npm run dev` command. To shut down the development server, we use *Ctrl*
    + *C*. To prepare a production build of our application, we can use the provided
    `npm` script:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在我们开发环境中工作过我们的应用程序。本质上，当我们运行`npm run dev`命令时，Vite在本地机器上启动了一个开发服务器。要关闭开发服务器，我们使用*Ctrl*
    + *C*。为了准备我们应用程序的生产构建，我们可以使用提供的`npm`脚本：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you open the project’s `package.json`, you’ll notice this particular script
    runs the `vite build` command. It does exactly what it sounds like by kicking
    off Vite’s build process, which involves the bundling process from Rollup, packaging
    static assets, and running the configured adapter. Upon completion of the command,
    you’ll notice the output in your terminal lists various files as well as their
    size. If there are any errors in the build, they will be shown here.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开项目的`package.json`文件，你会注意到这个特定的脚本运行了`vite build`命令。它确实做了它听起来像的事情，通过启动Vite的构建过程，这涉及到Rollup的打包过程、打包静态资源以及运行配置的适配器。命令完成后，你会在终端中看到各种文件及其大小。如果有任何构建错误，它们将在这里显示。
- en: 'By default, the fully built application will be output to `.svelte-kit/`. To
    change this directory, we can open `svelte.config.js` and pass in the preferred
    directory name to the `config.kit.outDir` option. When opening the `build` folder,
    you’ll notice that the built application has a different structure compared to
    our source code. This is, of course, by design and varies based on the adapter
    we’re using. To confirm that our production build works, we can preview it using
    the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，完全构建的应用程序将被输出到 `.svelte-kit/` 目录。要更改此目录，我们可以打开 `svelte.config.js` 文件，并将首选的目录名称传递给
    `config.kit.outDir` 选项。当打开 `build` 文件夹时，您会注意到构建的应用程序结构与我们的源代码不同。这当然是出于设计考虑，并且根据我们使用的适配器而有所不同。为了确认我们的生产构建工作正常，我们可以使用以下命令进行预览：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once run, Vite will alert us to the new URL and port that our application can
    be accessed from. We can view and use the application there just as we can when
    running our development server. What differs is that file changes will not be
    automatically updated, as the files being used to run this version of the application
    need to be regenerated on each build – that is, unless `build.watch` has been
    set in the `vite.config.js` project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，Vite 将提醒我们应用程序可以访问的新 URL 和端口。我们可以在那里查看和使用应用程序，就像运行我们的开发服务器时一样。不同之处在于，文件更改不会自动更新，因为用于运行此版本应用程序的文件需要在每次构建时重新生成——除非在
    `vite.config.js` 项目中设置了 `build.watch`。
- en: 'Having run the first official build of our application, there are a few things
    to make note of before we begin discussing adapters. Firstly, think back to [*Chapter
    4*](B19024_04_Final_AM.xhtml#_idTextAnchor060) when we covered `ssr` in the root
    `+layout.js` file. Just keep in mind that prerendering takes place during the
    build of the application. As such, any `fetch()` requests that happen on prerendered
    pages will happen at build time. We can confirm this with a simple change to our
    `fetch` example. Where we previously set `ssr = false`, change it now to `prerender
    =` `true;`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们应用程序的第一个官方构建之后，在开始讨论适配器之前，有一些事情需要注意。首先，回想一下[*第4章*](B19024_04_Final_AM.xhtml#_idTextAnchor060)，我们在根目录的
    `+layout.js` 文件中介绍了 `ssr`。只需记住，预渲染发生在应用程序构建过程中。因此，在预渲染页面上发生的任何 `fetch()` 请求都会在构建时发生。我们可以通过简单更改我们的
    `fetch` 示例来确认这一点。在我们之前设置 `ssr = false` 的地方，现在将其更改为 `prerender = true;`：
- en: src/routes/(site)/fetch/+page.js
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/(site)/fetch/+page.js
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once we’ve enabled prerendering on this particular route, we can go ahead and
    rebuild the application. Now, when we open our `build` folder, we should see the
    file at the `.svelte-kit/output/prerendered/pages/fetch.html` path. Upon opening
    this file, we’ll see the image element as well as all of the other data pulled
    from the NASA API shown as static HTML. This confirms to us that prerendering
    happens during the build process. It is very much something developers need to
    be cognizant of when preparing their applications for production environments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在这个特定路由上启用了预渲染，我们就可以继续重新构建应用程序。现在，当我们打开我们的 `build` 文件夹时，我们应该看到位于 `.svelte-kit/output/prerendered/pages/fetch.html`
    路径的文件。打开此文件后，我们将看到图像元素以及从 NASA API 拉取的所有其他数据，这些数据以静态 HTML 的形式显示。这证实了预渲染发生在构建过程中。这对于开发者在为生产环境准备应用程序时需要非常注意的事情。
- en: 'There are a few other idiosyncrasies to take note of when building your application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建您的应用程序时，还有一些其他的特点需要注意：
- en: Disabling `csr` and `ssr` will result in an empty page being rendered.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用 `csr` 和 `ssr` 将导致渲染一个空白的页面。
- en: It is not possible to prerender pages that rely on form actions as the page
    relies on HTTP `POST` requests.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于表单操作的页面无法进行预渲染，因为页面依赖于 HTTP `POST` 请求。
- en: It is also not possible to prerender pages that make use of `url.searchParams.`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `url.searchParams.` 的页面也无法进行预渲染。
- en: It is possible to prerender pages that load data based on dynamic parameters
    in the route; however, SvelteKit will need to observe links to those endpoints
    to do so.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于路由中的动态参数加载数据的页面可以进行预渲染；然而，SvelteKit 需要观察这些端点的链接才能进行预渲染。
- en: As demonstrated, preparing an application for production is quite simple. Vite
    bundles dependencies quickly and even provides a means to preview the application.
    That being said, there are a few things to keep in mind before packaging the application.
    In the next section, we’ll look at a few commonly used adapters and how they each
    produce builds specific to the intended environment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如演示所示，为生产环境准备应用程序相当简单。Vite快速打包依赖项，甚至提供了预览应用程序的方法。尽管如此，在打包应用程序之前，还有一些事情需要考虑。在下一节中，我们将查看一些常用的适配器以及它们如何为预期的环境生成特定的构建。
- en: Adapting the app
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配应用程序
- en: 'Now that we know how to build our application, we can explore some of the adapters
    that transform it for specified environments. For the entire time we’ve worked
    on our project, we’ve been using the `@sveltejs/adapter-auto` package. So far,
    we haven’t run into any issues, but if we want to build and deploy our application
    to a real production environment, we’ll need to get more specific. While `adapter-auto`
    is great, it doesn’t accept any configuration options and only works with Cloudflare
    Pages, Vercel, Netlify, and Azure Static Web Apps. If we wanted to host our application
    on a Node.js server or elsewhere, we would need to use a different adapter. Let’s
    explore a few of the different options available in the following section. The
    adapters we’ll look at are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何构建我们的应用程序，我们可以探索一些将应用程序转换为特定环境的适配器。在我们整个项目开发过程中，我们一直在使用`@sveltejs/adapter-auto`包。到目前为止，我们没有遇到任何问题，但如果我们想要构建并部署我们的应用程序到真实的生产环境，我们需要更加具体。虽然`adapter-auto`很好，但它不接受任何配置选项，并且仅与Cloudflare
    Pages、Vercel、Netlify和Azure Static Web Apps兼容。如果我们想在Node.js服务器或其他地方托管我们的应用程序，我们需要使用不同的适配器。让我们在下一节中探索一些可用的不同选项。我们将查看的适配器如下：
- en: '`adapter-node`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adapter-node`'
- en: '`adapter-cloudflare`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adapter-cloudflare`'
- en: '`adapter-static`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adapter-static`'
- en: This list is not comprehensive, as the SvelteKit project supports many more
    environments. Meanwhile, the SvelteKit community continues creating and releasing
    adapters for a variety of platforms. Be sure to check the Svelte community resources
    before building your own adapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不全面，因为SvelteKit项目支持许多其他环境。同时，SvelteKit社区继续为各种平台创建和发布适配器。在构建自己的适配器之前，请务必检查Svelte社区资源。
- en: adapter-node
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: adapter-node
- en: 'To begin, we’ll start with `adapter-node`, as most web developers have at least
    some familiarity with Node.js environments. This adapter can be installed by running
    the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`adapter-node`开始，因为大多数Web开发者至少对Node.js环境有些熟悉。可以通过运行以下命令来安装此适配器：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once installed, we can add it to our project by importing it into our `svelte.config.js`
    and specifying the adapter accordingly:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们可以通过将其导入到我们的`svelte.config.js`文件中并相应地指定适配器来将其添加到我们的项目中：
- en: svelte.config.js
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: svelte.config.js
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As before, this configuration only differs in that it imports `adapter-node`
    instead of `adapter-auto`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，这个配置的不同之处在于它导入的是`adapter-node`而不是`adapter-auto`。
- en: Once the adapters have been switched out, we can build the application for a
    Node.js environment by running `npm run build` in the terminal. By default, this
    adapter will output the built application to the `build/` directory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更换了适配器，我们就可以通过在终端中运行`npm run build`来为Node.js环境构建应用程序。默认情况下，此适配器将构建的应用程序输出到`build/`目录。
- en: 'So far in this project, we’ve only included one dependency, and that was `bcrypt`.
    If we hadn’t included that dependency, we wouldn’t even need to do this next step.
    But because it seems rare to find a project that’s not using other dependencies,
    we’d better cover it. To ensure our Node.js production environment has access
    to all the required dependencies, we’ll need to install them. We do this by copying
    `package.json` and `package-lock.json` to the `build/` directory. To ensure our
    build works successfully, we’ll simulate an automated deployment. We can do this
    by copying the entire `build/` directory (which now also includes `package.json`
    and `package-lock.json`) to another location on our machine. Once done, we can
    use npm’s clean install command in the same directory to download the required
    production dependencies. This is the recommended installation method for automated
    deployments and continuous integration environments. We don’t need development
    dependencies, as SvelteKit is now bundled into pure JS so the command looks like
    this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这个项目中，我们只包含了一个依赖项，那就是 `bcrypt`。如果我们没有包含这个依赖项，我们甚至不需要进行下一步。但是，由于找到不使用其他依赖项的项目似乎很少见，所以我们最好还是涵盖这一点。为了确保我们的
    Node.js 生产环境能够访问所有必需的依赖项，我们需要安装它们。我们通过将 `package.json` 和 `package-lock.json` 复制到
    `build/` 目录来实现这一点。为了确保我们的构建能够成功运行，我们将模拟自动化部署。我们可以通过将整个 `build/` 目录（现在也包括 `package.json`
    和 `package-lock.json`）复制到机器上的另一个位置来实现这一点。一旦完成，我们就可以在相同的目录中使用 npm 的 clean install
    命令来下载所需的生成依赖项。这是自动化部署和持续集成环境的推荐安装方法。我们不需要开发依赖项，因为 SvelteKit 现在已经打包成纯 JS，所以命令看起来是这样的：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Running this command in the same directory as our build will download the dependencies
    required.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建所在的同一目录下运行此命令将下载所需的依赖项。
- en: 'We can then launch the application with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令启动应用程序：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this instance, `build` is the name of the directory we would like Node.js
    to target. We’ve also specified the `ORIGIN` environment variable so that `adapter-node`
    can correctly determine the URL of the application. Without this, SvelteKit would
    block any `POST` requests as a means of protection against `0.0.0.0:3000`. To
    change the IP address or listening port, we can set those environment variables
    before running `node build`. For instance, launching the application at `127.0.0.1:8000`
    would look like `HOST=127.0.0.1 PORT=8000 ORIGIN=http://127.0.0.1:8000` `node
    build`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`build` 是我们希望 Node.js 定位的目录名称。我们还指定了 `ORIGIN` 环境变量，以便 `adapter-node`
    可以正确确定应用程序的 URL。如果没有这个，SvelteKit 会阻止任何 `POST` 请求，作为对 `0.0.0.0:3000` 的保护措施。要更改
    IP 地址或监听端口，我们可以在运行 `node build` 之前设置这些环境变量。例如，在 `127.0.0.1:8000` 上启动应用程序将看起来像这样：`HOST=127.0.0.1
    PORT=8000 ORIGIN=http://127.0.0.1:8000` `node build`。
- en: 'To further customize your builds, this adapter provides the following options:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步自定义构建，此适配器提供了以下选项：
- en: '`out` – A string specifying the directory the build should be output to. It
    defaults to `build` and should not have a `/` character at the end.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out` – 一个字符串，指定构建应该输出的目录。默认为 `build`，且不应在末尾包含 `/` 字符。'
- en: '`precompress` – A Boolean value that defaults to `false` and controls whether
    or not assets and prerendered pages should be compressed using `gzip` and `brotli`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precompress` – 一个默认为 `false` 的布尔值，控制是否使用 `gzip` 和 `brotli` 对资源和预渲染页面进行压缩。'
- en: '`envPrefix` – A string value specifying a prefix applied to environment variables,
    which proves quite useful when your hosting provider doesn’t provide you with
    access to the standard environment variables such as `HOST` or `PORT`. Setting
    this will allow you to create your own environment variables.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`envPrefix` – 一个字符串值，指定应用于环境变量的前缀，这在你的托管提供商不提供标准环境变量访问（如 `HOST` 或 `PORT`）时非常有用。设置此值将允许你创建自己的环境变量。'
- en: '`polyfill` – A Boolean value defaulting to `true` that allows you to specify
    whether or not your build should include polyfills that add functionality not
    available in older Node.js releases.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polyfill` – 一个默认为 `true` 的布尔值，允许你指定构建是否应该包含添加了在旧版 Node.js 版本中不可用功能的 polyfills。'
- en: After everything we’ve just covered, you should be able to deploy your own SvelteKit
    application to just about any Node.js environment. And if the destination environment
    limits your control, you should be able to customize the build using various options.
    Because Node.js environments are so prevalent, it would have been a huge mistake
    to not explain some of the functionality behind `adapter-node` and how it can
    streamline your deployment process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚讨论的所有内容之后，你应该能够将你的SvelteKit应用程序部署到几乎任何Node.js环境中。如果目标环境限制了你的控制权限，你应该能够使用各种选项自定义构建。由于Node.js环境如此普遍，不解释`adapter-node`背后的某些功能以及它如何简化你的部署过程将是一个巨大的错误。
- en: adapter-cloudflare
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: adapter-cloudflare
- en: While `adapter-node` is great for when we’re running Node.js applications, there
    are adapters that allow us to deploy without needing to manage, configure, or
    maintain a server. Platforms such as Vercel, Netlify, and Cloudflare all provide
    these services and empower developers to ship their code faster than ever before.
    For demonstration purposes, let’s look at how easy it is to deploy to Cloudflare
    Pages.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`adapter-node`在运行Node.js应用程序时很棒，但还有一些适配器允许我们无需管理、配置或维护服务器即可部署。例如，Vercel、Netlify和Cloudflare等平台都提供这些服务，并赋予开发者比以往任何时候都更快地交付代码的能力。为了演示目的，让我们看看部署到Cloudflare
    Pages有多简单。
- en: 'To begin, we’ll install the adapter just like we have done with other packages:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将像安装其他包一样安装适配器：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once done, we can change our `svelte.config.js` to reflect the new adapter.
    Again, we simply need to import the new adapter:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以更改我们的`svelte.config.js`以反映新的适配器。同样，我们只需要导入新的适配器：
- en: svelte.config.js
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: svelte.config.js
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before delving too deep, it’s important to note that the application we have
    built thus far `bcrypt` package earlier, our application will fail to build as
    `bcrypt` makes extensive use of Node.js APIs. To successfully build and deploy
    the application, we will need to make a couple of changes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨之前，重要的是要注意，我们迄今为止构建的应用程序`bcrypt`包之前，我们的应用程序将无法构建，因为`bcrypt`广泛使用了Node.js
    API。为了成功构建和部署应用程序，我们需要做一些更改。
- en: 'If you’d prefer not to make these changes in your application, you can create
    a fork of this book’s code repository found under the *Technical requirements*
    section listed at the beginning of each chapter. In that repository, there is
    a branch labeled `cloudflare` that has all of the necessary changes. When forking
    the repository, be sure to `cloudflare` branch. As for the necessary changes,
    let’s take a brief detour and examine them now:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在你的应用程序中做出这些更改，你可以在每章开头列出的*技术要求*部分下找到这本书的代码仓库的分支创建一个分支。在那个仓库中，有一个标记为`cloudflare`的分支，其中包含了所有必要的更改。在创建分支时，请确保选择`cloudflare`分支。至于必要的更改，让我们先简要地考察一下：
- en: Uninstall `bcrypt` with the `npm uninstall` `bcrypt` command.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm uninstall`命令卸载`bcrypt`。
- en: Remove references to `bcrypt` in `src/routes/(app)/login/+page.server.js`, as
    shown in the following code snippet.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下代码片段所示，在`src/routes/(app)/login/+page.server.js`中移除对`bcrypt`的引用。
- en: 'Change `src/lib/users.json` passwords to plaintext values:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`src/lib/users.json`中的密码更改为纯文本值：
- en: src/routes/(app)/login/+page.server.js
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/(app)/login/+page.server.js
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This new version of `+page.server.js` simply removes references to the `bcrypt`
    package and instead compares the text supplied in the `password` field to the
    plain text values in the `src/lib/users.json` file. **It cannot be stressed how
    terrible this is from a security standpoint and I am trusting you to never do
    this outside of this** **particular demonstration**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`+page.server.js`的新版本只是简单地移除了对`bcrypt`包的引用，并改为将`password`字段中提供的文本与`src/lib/users.json`文件中的纯文本值进行比较。**从安全角度来看，这有多么糟糕是毋庸置疑的，我信任你永远不会在这个**
    **特定演示** **之外这样做**。
- en: Now that we have removed all dependencies that require Node.js, we can proceed
    with our deployment to Cloudflare. Firstly, we should log in to a Cloudflare account,
    navigate to `cloudflare` here. Typically, this would be the `main` branch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经移除了所有需要Node.js的依赖项，我们可以继续将我们的部署到Cloudflare。首先，我们应该登录到Cloudflare账户，导航到这里的`cloudflare`。通常，这将是`main`分支。
- en: 'From there, we can set up a few options. Cloudflare makes this next step a
    breeze by asking whether we’re using a framework, which we are. Selecting **SvelteKit**
    from the **Framework preset** dropdown will auto-populate the **Build command**
    and **Build output directory** fields with the appropriate values. See *Figure
    8**.1* for more information:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以设置几个选项。Cloudflare通过询问我们是否使用框架来简化下一步，而我们确实在使用框架。从**框架预设**下拉菜单中选择**SvelteKit**将自动填充**构建命令**和**构建输出目录**字段。更多信息请参见*图8.1*：
- en: '![Figure 8.1 – Cloudflare Pages project settings](img/B19024_08_01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – Cloudflare Pages项目设置](img/B19024_08_01.jpg)'
- en: Figure 8.1 – Cloudflare Pages project settings
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – Cloudflare Pages项目设置
- en: Because the source code for the project we’re attempting to deploy from is in
    a subdirectory of the Git repository, we’ll have to specify that directory in
    the `NODE_VERSION` in the **Environment variables** section. Though SvelteKit
    only requires Node.js 16.14 or higher, we’ve specified version 18 as that is the
    current latest Long-Term Support version of SvelteKit as well as the version used
    throughout the development of this book. Once everything has been filled out appropriately,
    you can save and deploy the project!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尝试部署的项目源代码位于Git仓库的子目录中，我们必须在**环境变量**部分指定该目录的`NODE_VERSION`。尽管SvelteKit只需要Node.js
    16.14或更高版本，但我们指定了版本18，因为这也是SvelteKit当前的最新长期支持版本，也是本书开发过程中使用的版本。一旦所有内容都填写正确，你就可以保存并部署项目了！
- en: Cloudflare will then check out your code and attempt to build it. If everything
    is successful, you’ll be provided with a URL pointing to your application. For
    reference, a version of the application we’ve created thus far is live at [https://sveltekit-up-and-running.pages.dev/](https://sveltekit-up-and-running.pages.dev/).
    Deploying an update to an application is as simple as pushing code to the appropriate
    branch in the project repository.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Cloudflare将检查你的代码并尝试构建它。如果一切顺利，你将获得一个指向你应用程序的URL。为了参考，我们迄今为止创建的应用程序版本可在[https://sveltekit-up-and-running.pages.dev/](https://sveltekit-up-and-running.pages.dev/)上找到。将更新部署到应用程序就像将代码推送到项目仓库的适当分支一样简单。
- en: As you can see, deploying a SvelteKit application can be almost effortless once
    set up on serverless platforms such as Cloudflare Pages. The Vercel and Netlify
    adapters have similar processes, which you are encouraged to explore at your leisure.
    While our particular project ran into a slight issue with an included dependency
    requiring Node.js, this example hopefully demonstrated how using the right adapter
    can simplify deployments.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦在无服务器平台如Cloudflare Pages上设置好，部署SvelteKit应用程序几乎可以毫不费力。Vercel和Netlify适配器有类似的过程，你可以在空闲时探索。虽然我们的特定项目遇到了一个包含的依赖项需要Node.js的轻微问题，但这个例子希望展示了使用正确的适配器可以简化部署。
- en: adapter-static
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: adapter-static
- en: While we only ran into one minor problem with our previous adapter, we’ll most
    certainly run into problems with `adapter-static`. The reason for that is that
    this adapter is intended to only be used on platforms that can host static content
    – that is, platforms where no server backend logic exists. If you have a host
    that can serve static HTML, CSS, and JS, you can host an entire SvelteKit application
    there using this adapter. A common example is GitHub pages, but Cloudflare and
    many others also support this method. Hosting static applications has the added
    benefit of increased speed since no server backend exists to communicate with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前只遇到了一个小的适配器问题，但我们肯定会遇到`adapter-static`的问题。原因在于这个适配器旨在仅在可以托管静态内容的平台上使用——也就是说，在这些平台上不存在服务器后端逻辑。如果你有一个可以提供静态HTML、CSS和JS的主机，你可以使用这个适配器在那里托管整个SvelteKit应用程序。一个常见的例子是GitHub
    pages，但Cloudflare和其他许多也支持这种方法。托管静态应用程序的好处是速度更快，因为没有服务器后端需要与之通信。
- en: 'Since we won’t be able to get `adapter-static` working with our project, we
    won’t attempt to install it on our existing project. But it is still an adapter
    worth discussing. Just like other adapters, it is easily installed via this command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法在我们的项目中使用`adapter-static`，我们不会尝试在我们的现有项目中安装它。但这是一个值得讨论的适配器。就像其他适配器一样，它可以通过以下命令轻松安装：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And again, it can then be imported in `svelte.config.js`. This adapter varies
    from the others in that it prerenders the entire application. It is able to do
    this because we will insert `export let prerender = true;` at the lowest level
    layout of our application. In each case, this will be `src/routes/+layout.js`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，它可以在 `svelte.config.js` 中导入。此适配器与其他适配器不同，因为它预渲染整个应用程序。它能够做到这一点，因为我们将在应用程序最低级别的布局中插入
    `export let prerender = true;`。在每种情况下，这将是 `src/routes/+layout.js`。
- en: 'To customize the builds produced with this adapter, we’re provided with a few
    options. These options are passed to the adapter in `svelte.config.js`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自定义此适配器生成的构建，我们提供了一些选项。这些选项通过 `svelte.config.js` 传递给适配器：
- en: '`pages` – A string value defaulting to `build` that determines where prerendered
    pages will be output to.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages` – 一个默认为 `build` 的字符串值，它确定预渲染页面将被输出到何处。'
- en: '`assets` – A string value defaulting to the value provided to `pages` that
    determines where static assets should be output to.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assets` – 一个默认为 `pages` 提供的值的字符串值，它确定静态资源应该输出到何处。'
- en: '`fallback` – A string value specifying a fallback file to use when SSR has
    been disabled sitewide. Disabling SSR application-wide enables `index.html`, `200.html`,
    or `404.html`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fallback` – 一个字符串值，指定当全局禁用SSR时使用的回退文件。全局禁用SSR将启用 `index.html`、`200.html` 或
    `404.html`。'
- en: '`precompress` – A Boolean value that determines whether files should be compressed
    using `brotli` and `gzip` compression algorithms.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precompress` – 一个布尔值，确定是否应该使用 `brotli` 和 `gzip` 压缩算法压缩文件。'
- en: '`strict` – A Boolean value that prevents the application from building if certain
    endpoints will not exist when prerendered. It can be useful to disable if your
    application makes use of pages that exist only in specific circumstances.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strict` – 一个布尔值，防止应用程序在预渲染时某些端点不存在时构建。如果你的应用程序使用了仅在特定情况下存在的页面，禁用此功能可能很有用。'
- en: 'If you’re interested in trying `adapter-static` for yourself, consider creating
    a new SvelteKit application using the `skeleton` template. You can try with the
    *Demo App*, but will run into issues with server routes unable to be prerendered.
    These can be removed to get it working, but if your goal is to simply see how
    the static adapter works, it will likely be easier to deploy from the `skeleton`
    template. Again, the steps for building a static application are fairly straightforward:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣亲自尝试 `adapter-static`，考虑使用 `skeleton` 模板创建一个新的 SvelteKit 应用程序。你可以尝试使用
    *演示应用程序*，但会遇到服务器路由无法预渲染的问题。这些可以通过删除来解决以使其工作，但如果你的目标是简单地了解静态适配器的工作原理，从 `skeleton`
    模板部署可能会更容易。再次强调，构建静态应用程序的步骤相当简单：
- en: Install the adapter with `npm install -``D @sveltejs/adapter-static`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm install -``D @sveltejs/adapter-static` 安装适配器。
- en: Import the adapter in `svelte.config.js`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `svelte.config.js` 中导入适配器。
- en: Ensure the application is entirely prerenderable by adding `export let prerender
    = true;` in `src/routes/+layout.js`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `src/routes/+layout.js` 中添加 `export let prerender = true;` 确保应用程序完全可预渲染。
- en: Run the `npm run` `build` command!
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm run build` 命令！
- en: Once your application has been built, you can simply copy it to anywhere that
    can serve static files. Of course, certain hosts may have their own requirements
    so be sure to read their documentation as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用程序构建完成，你可以简单地将其复制到任何可以提供静态文件的服务器上。当然，某些主机可能有它们自己的要求，所以请务必阅读它们的文档。
- en: A great way to learn about SvelteKit is by working with it. If you don’t already
    have a personal website, consider creating one using the SvelteKit static adapter.
    Not only does it not require a database or backend but it can also be deployed
    to almost any hosting provider. If you’re wondering where to start, Josh Collinsworth
    created a fantastic project using the static adapter. It enables users to add
    blog posts using Markdown while still existing as a static site. This means that
    hosting can be done for free on platforms such as GitHub Pages. You can find a
    link to Josh’s project in the *Resources* section at the end of this chapter.
    While our project and many others cannot make use of `adapter-static` as they
    are not prerenderable, the value that this particular adapter provides for generating
    static sites is clear.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与SvelteKit一起工作是一种了解它的好方法。如果你还没有个人网站，可以考虑使用SvelteKit静态适配器来创建一个。这不仅不需要数据库或后端，而且几乎可以部署到任何托管提供商。如果你想知道从哪里开始，Josh
    Collinsworth使用静态适配器创建了一个出色的项目。它允许用户使用Markdown添加博客文章，同时仍然作为一个静态网站存在。这意味着可以在GitHub
    Pages等平台上免费托管。你可以在本章末尾的 *资源* 部分找到Josh项目的链接。虽然我们的项目以及许多其他项目无法使用 `adapter-static`，因为它们不是可预渲染的，但这个特定适配器在生成静态网站方面的价值是显而易见的。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Having covered how the SvelteKit build process works, we then observed how we
    can preview our builds locally. We also looked at how page options can affect
    our builds. We took what we learned about the build process and saw how we can
    tailor our application to various platforms by selecting the right adapter. The
    application we’ve built so far is best suited to Node.js environments but we’ve
    also seen how simple it is to deploy to Cloudflare Pages and platforms such as
    Netlify or Vercel. By using the correct adapter and development strategies, we
    can even turn our application into a static website. Now that you’ve seen how
    to prepare your application for different production environments, you can go
    forth and release your SvelteKit applications into the wild.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了SvelteKit构建过程的工作原理后，我们观察了如何在本地预览我们的构建。我们还探讨了页面选项如何影响我们的构建。我们学习了构建过程，并看到如何通过选择正确的适配器来调整我们的应用程序以适应各种平台。我们构建的应用程序最适合Node.js环境，但我们也已经看到将其部署到Cloudflare
    Pages、Netlify或Vercel等平台是多么简单。通过使用正确的适配器和开发策略，我们甚至可以将我们的应用程序转变为静态网站。现在你已经看到了如何为不同的生产环境准备你的应用程序，你可以继续发布你的SvelteKit应用程序到野外。
- en: In the next chapter, we’ll learn how we can manipulate requests across our entire
    application through the use of hooks. We’ll also address how we can utilize these
    hooks to assist in managing errors. Because no application is perfect, we’ll address
    how SvelteKit lets us customize the user experience when issues do arise.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过使用钩子（hooks）来操作整个应用程序中的请求。我们还将讨论如何利用这些钩子来帮助管理错误。因为没有任何应用程序是完美的，所以我们将探讨SvelteKit如何让我们在出现问题时自定义用户体验。
- en: Resources
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: '*Svelte Society* – A central resource that provides many community-maintained
    Svelte-related projects including adapters: [https://sveltesociety.dev/](https://sveltesociety.dev/)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Svelte Society* – 一个提供许多社区维护的Svelte相关项目，包括适配器的中心资源：[https://sveltesociety.dev/](https://sveltesociety.dev/)'
- en: '*How Cloudflare Workers* *Work*: [https://developers.cloudflare.com/workers/learning/how-workers-works](https://developers.cloudflare.com/workers/learning/how-workers-works)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cloudflare Workers如何工作*：[https://developers.cloudflare.com/workers/learning/how-workers-works](https://developers.cloudflare.com/workers/learning/how-workers-works)'
- en: '*SvelteKit Blog Starter* by Josh Collinsworth: [https://github.com/josh-collinsworth/sveltekit-blog-starter](https://github.com/josh-collinsworth/sveltekit-blog-starter)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Josh Collinsworth编写的 *SvelteKit Blog Starter*：[https://github.com/josh-collinsworth/sveltekit-blog-starter](https://github.com/josh-collinsworth/sveltekit-blog-starter)
