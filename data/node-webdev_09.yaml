- en: Data Storage and Retrieval
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储和检索
- en: In the previous two chapters, we built a small and somewhat useful application
    for storing notes, and then made it work on mobile devices. While our application
    works reasonably well, it doesn't store these notes anywhere on a long-term basis,
    meaning the notes are lost when you stop the server, and if you run multiple instances
    of `Notes`, each instance has its own set of notes. Our next step is to introduce
    a database tier to persist the notes to long-term storage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们构建了一个小型且有些有用的存储笔记的应用程序，然后使其在移动设备上运行。虽然我们的应用程序运行得相当不错，但它并没有将这些笔记存储在长期基础上，这意味着当您停止服务器时，笔记会丢失，并且如果您运行多个`Notes`实例，每个实例都有自己的笔记集。我们的下一步是引入一个数据库层，将笔记持久化到长期存储中。
- en: In this chapter, we will look at database support in Node.js, with the goal
    being to gain exposure to several kinds of databases. For the `Notes` application,
    the user should see the same set of notes for any `Notes` instance accessed, and
    the user should be able to reliably access notes at any time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究Node.js中的数据库支持，目标是获得对几种数据库的暴露。对于`Notes`应用程序，用户应该在访问任何`Notes`实例时看到相同的笔记集，并且用户应该能够随时可靠地访问笔记。
- en: 'We''ll start with the `Notes` application code used in the previous chapter.
    We started with a simple in-memory data model, using an array to store the notes,
    and then made it mobile-friendly. In this chapter, we will cover the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从前一章中使用的`Notes`应用程序代码开始。我们从一个简单的内存数据模型开始，使用数组来存储笔记，然后使其适用于移动设备。在本章中，我们将涵盖以下主题：
- en: The relationship between databases and asynchronous code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库和异步代码之间的关系
- en: Configuring the logging of operational and debugging information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置操作和调试信息的记录
- en: Catching important system errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获重要的系统错误
- en: Using `import()` to enable the runtime selection of the database to use
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`import()`来启用运行时选择要使用的数据库
- en: Implementing data persistence for the `Notes` objects using several database
    engines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个数据库引擎为`Notes`对象实现数据持久化
- en: Designing simple configuration files with YAML
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计简单的配置文件与YAML
- en: The first step is to duplicate the code from the previous chapter. For instance,
    if you were working in `chap06/notes`, duplicate it and change its name to `chap07/notes`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是复制上一章的代码。例如，如果你在`chap06/notes`中工作，复制它并将其更改为`chap07/notes`。
- en: Let's start by reviewing a little theory on why database code in Node.js is
    asynchronous.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾一下在Node.js中为什么数据库代码是异步的一些理论开始。
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Remembering that data storage requires asynchronous code
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住数据存储需要异步代码
- en: By definition, external data storage systems require asynchronous coding techniques,
    such as the ones we discussed in previous chapters. The core principle of the
    Node.js architecture is that any operation that requires a long time to perform
    must have an asynchronous API in order to keep the event loop running. The access
    time to retrieve data from a disk, another process, or a database always needs
    to take sufficient time to require deferred execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，外部数据存储系统需要异步编码技术，就像我们在前几章中讨论的那样。Node.js架构的核心原则是，任何需要长时间执行的操作必须具有异步API，以保持事件循环运行。从磁盘、另一个进程或数据库检索数据的访问时间总是需要足够的时间来要求延迟执行。
- en: The existing `Notes` data model is an in-memory datastore. In theory, in-memory
    data access does not require asynchronous code and, therefore, the existing model
    module could use regular functions, rather than `async` functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的`Notes`数据模型是一个内存数据存储。理论上，内存数据访问不需要异步代码，因此现有的模型模块可以使用常规函数，而不是`async`函数。
- en: We know that `Notes` should use databases and it requires an asynchronous API
    to access the `Notes` data. For this reason, the existing `Notes` model API uses
    `async` functions, so in this chapter, we can persist the Notes data to databases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`Notes`应该使用数据库，并且需要一个异步API来访问`Notes`数据。因此，现有的`Notes`模型API使用`async`函数，所以在本章中，我们可以将Notes数据持久化到数据库中。
- en: That was a useful refresher. Let's now talk about one of the administrative
    details required for a production application—using a logging system to store
    the usage data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的复习。现在让我们谈谈生产应用程序所需的一个管理细节——使用日志系统来存储使用数据。
- en: Logging and capturing uncaught errors
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录和捕获未捕获的错误
- en: 'Before we get into databases, we have to address one of the attributes of a
    high-quality web application—managing logged information, including normal system
    activity, system errors, and debugging information. Logs give us an insight into
    the behavior of the system. They answer the following questions for the developers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入数据库之前，我们必须解决高质量Web应用程序的一个属性——管理记录信息，包括正常系统活动、系统错误和调试信息。日志为开发人员提供了对系统行为的洞察。它们为开发人员回答以下问题：
- en: How much traffic is the application getting?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的流量有多大？
- en: If it's a website, which pages are people hitting the most?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是一个网站，人们最常访问哪些页面？
- en: How many errors occur and of what kind? Do attacks occur? Are malformed requests
    being sent?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生了多少错误，以及是什么类型的错误？是否发生了攻击？是否发送了格式不正确的请求？
- en: Log management is also an issue. Unless managed well, log files can quickly
    fill the disk space. So, it becomes high priority to process old logs, hopefully
    extracting useful data before deleting the old logs. Commonly, this includes **log
    rotation**, which means regularly moving the existing log file to an archive directory
    and then starting with a fresh log file. Afterward, processing can occur to extract
    useful data, such as errors or usage trends. Just as your business analyst looks
    at profit/loss statements every few weeks, your DevOps team needs various reports
    to know whether there are enough servers to handle the traffic. Furthermore, log
    files can be screened for security vulnerabilities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 日志管理也是一个问题。如果管理不当，日志文件很快就会填满磁盘空间。因此，在删除旧日志之前，处理旧日志变得非常重要，希望在删除旧日志之前提取有用的数据。通常，这包括**日志轮换**，即定期将现有日志文件移动到存档目录，然后开始一个新的日志文件。之后，可以进行处理以提取有用的数据，如错误或使用趋势。就像您的业务分析师每隔几周查看利润/损失报表一样，您的DevOps团队需要各种报告，以了解是否有足够的服务器来处理流量。此外，可以对日志文件进行筛查以查找安全漏洞。
- en: 'When we used the Express generator to initially create the `Notes` application,
    it configured an activity-logging system using `morgan` with the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Express生成器最初创建`Notes`应用程序时，它使用以下代码配置了一个活动日志系统，使用了`morgan`：
- en: '[PRE0]js\1'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]js\1'
- en: 'This is the pattern we are following throughout this book; namely, to have
    a default value baked into the application and to use an environment variable
    to override the default. If we don''t supply a configuration value through the
    environment variable, the program uses the `dev` format. Next, we need to run
    `Notes`, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在整本书中遵循的模式；即将默认值嵌入应用程序，并使用环境变量来覆盖默认值。如果我们没有通过环境变量提供配置值，程序将使用`dev`格式。接下来，我们需要运行`Notes`，如下所示：
- en: '[PRE1]js\1'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]js\1'
- en: However, this has a problem; it's impossible to perform log rotation without
    killing and restarting the server. The phrase *log rotation* refers to a DevOps
    practice of keeping log file snapshots, where each snapshot covers a few hours
    of activity. Typically, an application server will not keep a file handle continuously
    open to the log file, and the DevOps team can write a simple script that runs
    every few hours and uses the `mv` command to move log files around and the `rm`
    command to delete old files. Unfortunately, `morgan`, when configured as it is
    here, keeps a continuously open file handle to the log file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这存在一个问题；无法在不关闭和重新启动服务器的情况下执行日志轮换。术语“日志轮换”指的是DevOps实践，其中每个快照覆盖了几小时的活动。通常，应用服务器不会持续打开文件句柄到日志文件，DevOps团队可以编写一个简单的脚本，每隔几个小时运行一次，并使用`mv`命令移动日志文件，使用`rm`命令删除旧文件。不幸的是，`morgan`在这里配置时，会持续打开文件句柄到日志文件。
- en: Instead, we'll use the `rotating-file-stream` package. This package even automates
    the log rotation task so that the DevOps team doesn't have to write a script for
    that purpose.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用`rotating-file-stream`包。这个包甚至自动化了日志轮换任务，这样DevOps团队就不必为此编写脚本。
- en: For the documentation on this, refer to the package page at [https://www.npmjs.com/package/rotating-file-stream](https://www.npmjs.com/package/rotating-file-stream).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此内容的文档，请参阅包页面[https://www.npmjs.com/package/rotating-file-stream](https://www.npmjs.com/package/rotating-file-stream)。
- en: 'First, install the package:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装包：
- en: '[PRE2]js\1'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]js\1'
- en: In the `import` section at the top, we're loading `rotating-file-stream` as
    `rfs`. If the `REQUEST_LOG_FILE` environment variable is set, we'll take that
    as the filename to record to. The `stream` argument to `morgan` simply takes a
    writable stream. If `REQUEST_LOG_FILE` is not set, we use a `?:` operator to supply
    the value of `process.stdout` as the writable stream. If it is set, then we use
    `rfs.createStream` to create a writable stream that handles log rotation through
    the `rotating-file-stream` module.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部的`import`部分，我们将`rotating-file-stream`加载为`rfs`。如果设置了`REQUEST_LOG_FILE`环境变量，我们将把它作为要记录的文件名。`morgan`的`stream`参数只需接受一个可写流。如果`REQUEST_LOG_FILE`没有设置，我们使用`?:`运算符将`process.stdout`的值作为可写流。如果设置了，我们使用`rfs.createStream`创建一个可写流，通过`rotating-file-stream`模块处理日志轮换。
- en: In `rfs.createStream`, the first argument is the filename of the log file and
    the second is an `options` object describing the behavior to use. Quite a comprehensive
    set of options are available for this. The configuration shown here rotates the
    log file when it reaches 10 megabytes in size (or after 1 day) and the rotated
    log file is compressed using the `gzip` algorithm.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rfs.createStream`中，第一个参数是日志文件的文件名，第二个是描述要使用的行为的`options`对象。这里提供了一套相当全面的选项。这里的配置在日志文件达到10兆字节大小（或1天后）时进行日志轮换，并使用`gzip`算法压缩旋转的日志文件。
- en: 'It''s possible to set up multiple logs. For example, if we wanted to log to
    the console, in addition to logging to the file, we could add the following `logger`
    declaration:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置多个日志。例如，如果我们想要将日志记录到控制台，除了记录到文件中，我们可以添加以下`logger`声明：
- en: '[PRE3]js\1'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]js\1'
- en: 'With this configuration, an Apache format log will be created in `log.txt`.
    After making a few requests, we can inspect the log:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个配置，将在`log.txt`中创建一个Apache格式的日志。在进行一些请求后，我们可以检查日志：
- en: '[PRE4]js\1'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]js\1'
- en: This is pretty useful if you want to debug Express. However, we can use this
    in our own code as well. This works similarly to inserting `console.log` statements,
    but without having to remember to comment out the debugging code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要调试Express，这非常有用。但是，我们也可以在我们自己的代码中使用这个。这类似于插入`console.log`语句，但无需记住注释掉调试代码。
- en: 'To use this in our code, add the following declaration to the top of any module
    where you want the debugging output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的代码中使用这个，需要在任何想要调试输出的模块顶部添加以下声明：
- en: '[PRE5]js\1'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]js\1'
- en: When debugging is enabled for the current module, this causes a message to be
    printed. If debugging is not enabled for the current module, no messages are printed.
    Again, this is similar to using `console.log`, but you can dynamically turn it
    on and off without modifying your code, simply by setting the `DEBUG` variable
    appropriately.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当为当前模块启用调试时，这会导致消息被打印出来。如果当前模块未启用调试，则不会打印任何消息。再次强调，这类似于使用`console.log`，但您可以动态地打开和关闭它，而无需修改您的代码，只需适当设置`DEBUG`变量。
- en: The `DEBUG` environment variable contains a specifier describing which code
    will have debugging enabled. The simplest specifier is `*`, which is a wildcard
    that turns on every debugger. Otherwise, debug specifiers use the `identifer:identifier` format.
    When we said to use `DEBUG=express:*`, the specifier used `express` as the first
    identifier and used the `*` wildcard for the second identifier.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEBUG`环境变量包含描述哪些代码将启用调试的标识符。最简单的标识符是`*`，它是一个通配符，可以打开每个调试器。否则，调试标识符使用`identifer:identifier`格式。当我们说要使用`DEBUG=express:*`时，该标识符使用`express`作为第一个标识符，并使用`*`通配符作为第二个标识符。'
- en: By convention, the first identifier should be the name of your application or
    library. So, we used `notes:debug` and `notes:error` earlier as specifiers. However,
    that's just a convention; you can use any specifier format you like.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，第一个标识符应该是您的应用程序或库的名称。因此，我们之前使用`notes:debug`和`notes:error`作为标识符。但是，这只是一个惯例；您可以使用任何您喜欢的标识符格式。
- en: 'To add debugging to `Notes`, let''s add a little more code. Add the following
    to the bottom of `app.mjs`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`Notes`添加调试，让我们添加一些代码。将以下内容添加到`app.mjs`的底部：
- en: '[PRE6]js\1'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]js\1'
- en: This will output an error trace on any errors captured by Express.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Express捕获的任何错误上输出错误跟踪。
- en: 'Then, change `onListening` to the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`onListening`更改为以下内容：
- en: '[PRE7]js\1'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]js\1'
- en: Look at this carefully and you'll see that the output is both the logging output
    from `morgan` and the debugging output from the `debug` module. The debugging
    output, in this case, starts with `notes:debug`. The logging output is, because
    of the `REQUEST_LOG_FORMAT` variable, in Apache format.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下，你会发现输出既是来自`morgan`的日志输出，也是来自`debug`模块的调试输出。在这种情况下，调试输出以`notes:debug`开头。由于`REQUEST_LOG_FORMAT`变量，日志输出是以Apache格式的。
- en: We now have a debug tracing system that's ready to be used. The next task to
    cover is seeing whether it's possible to capture this or other console output
    in a file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个准备好使用的调试跟踪系统。下一个任务是看看是否可能在文件中捕获这个或其他控制台输出。
- en: Capturing stdout and stderr
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获stdout和stderr
- en: Important messages can be printed to `process.stdout` or `process.stderr`, which
    can be lost if you don't capture the output. It is best practice to capture this
    output for future analysis because there can be useful debugging information contained
    in it. An even better practice is to use a system facility to capture these output
    streams.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要消息可以打印到`process.stdout`或`process.stderr`，如果您不捕获输出，这些消息可能会丢失。最佳做法是捕获这些输出以供将来分析，因为其中可能包含有用的调试信息。更好的做法是使用系统设施来捕获这些输出流。
- en: A **system facility** can include a process manager application that launches
    applications while connecting the standard output and standard error streams to
    a file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统设施**可以包括启动应用程序并将标准输出和标准错误流连接到文件的进程管理应用程序。'
- en: While it lacks this sort of facility, it turns out that JavaScript code running
    in Node.js can intercept the `process.stdout` and `process.stderr` streams. Among
    the available packages, let's look at `capture-console`. For a writable stream,
    this package will invoke a callback function that you provided for any output.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它缺乏这种设施，但事实证明，在Node.js中运行的JavaScript代码可以拦截`process.stdout`和`process.stderr`流。在可用的包中，让我们看看`capture-console`。对于可写流，该包将调用您提供的回调函数来处理任何输出。
- en: Refer to the `capture-console` package page for the relevant documentation at [https://www.npmjs.com/package/capture-console](https://www.npmjs.com/package/capture-console).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考`capture-console`包页面，了解相关文档：[https://www.npmjs.com/package/capture-console](https://www.npmjs.com/package/capture-console)。
- en: The last administrative item to cover is ensuring we capture otherwise uncaught
    errors.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个行政事项是确保我们捕获其他未捕获的错误。
- en: Capturing uncaught exceptions and unhandled rejected Promises
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获未捕获的异常和未处理的拒绝的Promises
- en: Uncaught exceptions and unhandled rejected Promises are other areas where important
    information can be lost. Since our code is supposed to capture all errors, anything
    that's uncaught is an error on our part. Important information might be missing
    from our failure analysis if we do not capture these errors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 未捕获的异常和未处理的拒绝的Promises是其他重要信息可能丢失的地方。由于我们的代码应该捕获所有错误，任何未捕获的错误都是我们的错误。如果我们不捕获这些错误，我们的失败分析可能会缺少重要信息。
- en: Node.js indicates these conditions with events sent by the process object, `uncaughtException` and
    `unhandledRejection`. In the documentation for these events, the Node.js team
    sternly says that in either condition, the application is in an unknown state
    because something failed and that it may not be safe to keep the application running.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js通过进程对象发送的事件指示这些条件，`uncaughtException`和`unhandledRejection`。在这些事件的文档中，Node.js团队严厉地表示，在任何一种情况下，应用程序都处于未知状态，因为某些事情失败了，可能不安全继续运行应用程序。
- en: 'To implement these handlers, add the following to `appsupport.mjs`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些处理程序，请将以下内容添加到`appsupport.mjs`中：
- en: '[PRE8]js\1'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]js\1'
- en: We'll use this to convert the `Note` objects into and from JSON-formatted text.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个将`Note`对象转换为JSON格式的文本，以及从JSON格式的文本转换为`Note`对象。
- en: The `JSON` method is a getter, which means it retrieves the value of the object.
    In this case, the `note.JSON` attribute/getter (with no parentheses) will simply
    give us the JSON representation of the note. We'll use this later to write to
    JSON files.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON`方法是一个getter，这意味着它检索对象的值。在这种情况下，`note.JSON`属性/getter（没有括号）将简单地给我们提供笔记的JSON表示。我们稍后将使用它来写入JSON文件。'
- en: '`fromJSON` is a static function, or factory method, to aid in constructing
    the `Note` objects if we have a JSON string. Since we could be given anything,
    we need to test the input carefully. First, if the string is not in JSON format,
    `JSON.parse` will fail and throw an exception. Secondly, we have what the TypeScript
    community calls a **type guard**, or an `if` statement, to test whether the object
    matches what is required of a `Note` object. This checks whether it is an object
    with the `key`, `title`, and `body` fields, all of which must be strings. If the
    object passes these tests, we use the data to construct a `Note` instance.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromJSON` 是一个静态函数，或者工厂方法，用于帮助构造 `Note` 对象，如果我们有一个 JSON 字符串。由于我们可能会得到任何东西，我们需要仔细测试输入。首先，如果字符串不是
    JSON 格式，`JSON.parse` 将失败并抛出异常。其次，我们有 TypeScript 社区所谓的**类型保护**，或者 `if` 语句，来测试对象是否符合
    `Note` 对象所需的条件。这检查它是否是一个带有 `key`、`title` 和 `body` 字段的对象，这些字段都必须是字符串。如果对象通过了这些测试，我们使用数据来构造一个
    `Note` 实例。'
- en: 'These two functions can be used as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数可以如下使用：
- en: '[PRE9]js\1'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]js\1'
- en: This imports the required modules; one addition is the use of the `fs-extra`
    module. This module is used because it implements the same API as the core `fs`
    module while adding a few useful additional functions. In our case, we are interested
    in `fs.ensureDir`, which verifies whether the named directory structure exists
    and if not, a directory path is created. If we did not need `fs.ensureDir`, we
    would simply use `fs.promises` since it, too, supplies filesystem functions that
    are useful in `async` functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这导入了所需的模块；一个额外的添加是使用 `fs-extra` 模块。这个模块被用来实现与核心 `fs` 模块相同的 API，同时添加了一些有用的额外函数。在我们的情况下，我们对
    `fs.ensureDir` 感兴趣，它验证指定的目录结构是否存在，如果不存在，则创建一个目录路径。如果我们不需要 `fs.ensureDir`，我们将简单地使用
    `fs.promises`，因为它也提供了在 `async` 函数中有用的文件系统函数。
- en: For the documentation on `fs-extra`, refer to [https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `fs-extra` 的文档，请参考 [https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra)。
- en: 'Now, add the following to `models/notes-fs.mjs`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下内容添加到 `models/notes-fs.mjs` 中：
- en: '[PRE10]js\1'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: The `crupdate` function is used to support both the `update` and `create` methods.
    For this `Notes` store, both of these methods are the same and write the content
    to the disk as a JSON file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`crupdate` 函数用于支持 `update` 和 `create` 方法。对于这个 `Notes` 存储，这两种方法都是相同的，它们将内容写入磁盘作为一个
    JSON 文件。'
- en: As the code is written, the notes are stored in a directory determined by the
    `notesDir` function. This directory is either specified in the `NOTES_FS_DIR` environment
    variable or in `notes-fs-data` within the `Notes` root directory (as learned from
    the `approotdir` variable). Either way, `fs.ensureDir` is used to make sure that
    the directory exists.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中，笔记存储在由 `notesDir` 函数确定的目录中。这个目录可以在 `NOTES_FS_DIR` 环境变量中指定，也可以在 `Notes` 根目录中的
    `notes-fs-data` 中指定（从 `approotdir` 变量中得知）。无论哪种方式，我们都使用 `fs.ensureDir` 来确保目录存在。
- en: The pathname for `Notes` is calculated by the `filePath` function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “Notes” 的路径名是由 `filePath` 函数计算的。
- en: Because the pathname is `${notesDir}/${key}.json`, the key cannot use characters
    that cannot be used in filenames. For that reason, `crupdate` throws an error
    if the key contains a `/` character.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路径名是 `${notesDir}/${key}.json`，因此键不能使用文件名中不能使用的字符。因此，如果键包含 `/` 字符，`crupdate`
    将抛出错误。
- en: The `readJSON` function does what its name suggests—it reads a `Note` object
    as a JSON file from the disk.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`readJSON` 函数的功能与其名称所示的一样——它从磁盘中读取一个 `Note` 对象作为 JSON 文件。'
- en: 'We''re also adding another dependency:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了另一个依赖项：
- en: '[PRE11]js\1'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: However, our intent is to use ES6 modules, and so let's see how this works within
    that context. Because in the regular `import` statement the module name cannot
    be an expression like this, we need to load modules using `dynamic import`. The
    `dynamic import` feature—the `import()` function, in other words—does allow us
    to dynamically compute a module name to load.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的意图是使用 ES6 模块，因此让我们看看在这种情况下它是如何工作的。因为在常规的 `import` 语句中，模块名不能像这样是一个表达式，所以我们需要使用
    `动态导入` 来加载模块。`动态导入` 功能——即 `import()` 函数——允许我们动态计算要加载的模块名。
- en: 'To implement this idea, let''s create a new file, `models/notes-store.mjs`,
    containing the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个想法，让我们创建一个新文件 `models/notes-store.mjs`，其中包含以下内容：
- en: '[PRE12]js\1'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: Any module implementing `AbstractNotesStore` will export the defined class as
    the default export.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现 `AbstractNotesStore` 的模块都将默认导出定义的类。
- en: 'In `app.mjs`, we need to make another change to call this `useModel` function.
    In [Chapter 5](582d3898-0135-430c-8b6e-8326f287e18b.xhtml), *Your First Express
    Application*, we had `app.mjs` import `models/notes-memory.mjs` and then set up
    `NotesStore` to contain an instance of `InMemoryNotesStore`. Specifically, we
    had the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.mjs` 中，我们需要对调用这个 `useModel` 函数进行另一个更改。在[第5章](582d3898-0135-430c-8b6e-8326f287e18b.xhtml)中，*你的第一个
    Express 应用程序*，我们让 `app.mjs` 导入 `models/notes-memory.mjs`，然后设置 `NotesStore` 包含
    `InMemoryNotesStore` 的一个实例。具体来说，我们有以下内容：
- en: '[PRE13]js\1'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: We are importing `useModel`, renaming it `useNotesModel`, and then calling it
    by passing in the `NOTES_MODEL` environment variable. In case the `NOTES_MODEL`
    variable is not set, we’ll default to the “memory” `NotesStore`. Since `useNotesModel`
    is an `async` function, we need to handle the resulting Promise. `.then` handles
    the success case, but there is nothing to do, so we supply an empty function.
    What's important is that any errors will shut down the application, so we have
    added `.catch`, which calls `onError` to do so.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `useModel`，将其重命名为 `useNotesModel`，然后通过传入 `NOTES_MODEL` 环境变量来调用它。如果 `NOTES_MODEL`
    变量未设置，我们将默认使用“memory” `NotesStore`。由于 `useNotesModel` 是一个 `async` 函数，我们需要处理生成的
    Promise。`.then` 处理成功的情况，但由于没有需要执行的操作，所以我们提供了一个空函数。重要的是任何错误都会关闭应用程序，因此我们添加了 `.catch`，它调用
    `onError` 来处理错误。
- en: 'To support this error indicator, we need to add the following to the `onError`
    function in `appsupport.mjs`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个错误指示器，我们需要在 `appsupport.mjs` 的 `onError` 函数中添加以下内容：
- en: '[PRE14]js\1'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: We are importing the `NotesStore` export from `notes-store.mjs`, renaming it
    `notes`. Therefore, in both of the router modules, we will make calls such as `notes.keylist()`
    to access the dynamically selected `AbstractNotesStore` instance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`notes-store.mjs`中导入`NotesStore`导出，并将其重命名为`notes`。因此，在两个路由模块中，我们将进行诸如`notes.keylist()`的调用，以访问动态选择的`AbstractNotesStore`实例。
- en: This layer of abstraction gives the desired result—setting an environment variable
    that lets us decide at runtime which datastore to use.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象层提供了期望的结果——设置一个环境变量，让我们在运行时决定使用哪个数据存储。
- en: Now that we have all the pieces, let's run the `Notes` application and see how
    it behaves.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有的部件，让我们运行`Notes`应用程序并看看它的行为。
- en: Running the Notes application with filesystem storage
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文件系统存储运行Notes应用程序
- en: 'In `package.json`, add the following to the `scripts` section:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中，将以下内容添加到`scripts`部分：
- en: '[PRE15]js\1'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: We can use the application at `http://localhost:3000` as before. Because we
    did not change any template or CSS files, the application will look exactly as
    you left it at the end of [Chapter 6](db8b0ab8-181f-4d8d-9088-a9962ec461b8.xhtml),
    *Implementing the Mobile-First Paradigm*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以前一样在`http://localhost:3000`上使用应用程序。因为我们没有更改任何模板或CSS文件，所以应用程序看起来与您在[第6章](db8b0ab8-181f-4d8d-9088-a9962ec461b8.xhtml)结束时一样。
- en: Because debugging is turned on for `notes:*`, we'll see a log of whatever the
    `Notes` application is doing. It's easy to turn this off by simply not setting
    the `DEBUG` variable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`notes:*`的调试已打开，我们将看到`Notes`应用程序正在执行的任何操作的日志。通过简单地不设置`DEBUG`变量，可以轻松关闭此功能。
- en: You can now kill and restart the `Notes` application and see the exact same
    notes. You can also edit the notes in the command line using regular text editors
    such as **vi**. You can now start multiple servers on different ports, using the
    `fs-server1` and `fs-server2` scripts, and see exactly the same notes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以关闭并重新启动`Notes`应用程序，并查看完全相同的注释。您还可以使用常规文本编辑器（如**vi**）在命令行中编辑注释。您现在可以在不同端口上启动多个服务器，使用`fs-server1`和`fs-server2`脚本，并查看完全相同的注释。
- en: As we did at the end of [Chapter 5](582d3898-0135-430c-8b6e-8326f287e18b.xhtml), *Your
    First Express Application*, we can start the two servers' separate command windows.
    This runs two instances of the application, each on different ports. Then, visit
    the two servers in separate browser windows, and you will see that both browser
    windows show the same notes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第5章](582d3898-0135-430c-8b6e-8326f287e18b.xhtml)结束时所做的那样，*您的第一个Express应用程序*，我们可以在两个单独的命令窗口中启动两个服务器。这将在不同的端口上运行两个应用程序实例。然后，在不同的浏览器窗口中访问这两个服务器，您会发现两个浏览器窗口显示相同的注释。
- en: Another thing to try is specifying `NOTES_FS_DIR` to define a different directory
    to store notes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个尝试的事情是指定`NOTES_FS_DIR`以定义一个不同的目录来存储注释。
- en: The final check is to create a note where the key has a `/` character. Remember
    that the key is used to generate the filename where we store the note, and so
    the key cannot contain a `/` character. With the browser open, click on ADD Note
    and enter a note, ensuring that you use a `/` character in the `key` field. On
    clicking the Submit button, you'll see an error saying that this isn't allowed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的检查是创建一个带有`/`字符的键的注释。请记住，键用于生成我们存储注释的文件名，因此键不能包含`/`字符。在浏览器打开的情况下，单击“添加注释”，并输入一条注释，确保在“键”字段中使用`/`字符。单击提交按钮后，您将看到一个错误，指出这是不允许的。
- en: We have now demonstrated adding persistent data storage to `Notes`. However,
    this storage mechanism isn't the best, and there are several other database types
    to explore. The next database service on our list is LevelDB.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经演示了向`Notes`添加持久数据存储。但是，这种存储机制并不是最好的，还有其他几种数据库类型可以探索。我们列表中的下一个数据库服务是LevelDB。
- en: Storing notes with the LevelDB datastore
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LevelDB数据存储存储注释
- en: 'To get started with actual databases, let''s look at an extremely lightweight, small-footprint
    database engine: `level`. This is a Node.js-friendly wrapper that wraps around
    the LevelDB engine and was developed by Google. It is normally used in web browsers
    for local data persistence and is a non-indexed, NoSQL datastore originally designed
    for use in browsers. The Level Node.js module uses the LevelDB API and supports
    multiple backends, including leveldown, which integrates the C++ LevelDB database
    into Node.js.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用实际数据库，让我们看一下一个极其轻量级、占用空间小的数据库引擎：`level`。这是一个Node.js友好的包装器，它包装了LevelDB引擎，并由Google开发。它通常用于Web浏览器进行本地数据持久化，并且是一个非索引的NoSQL数据存储，最初是为在浏览器中使用而设计的。Level
    Node.js模块使用LevelDB API，并支持多个后端，包括leveldown，它将C++ LevelDB数据库集成到Node.js中。
- en: Visit [https://www.npmjs.com/package/level](https://www.npmjs.com/package/level)
    for information on this module.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://www.npmjs.com/package/level](https://www.npmjs.com/package/level)了解有关此模块的信息。
- en: 'To install the database engine, run the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装数据库引擎，请运行以下命令：
- en: '[PRE16]js\1'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: We start the module with the `import` statements and a couple of declarations.
    The `connectDB` function is used for what the name suggests—to connect with a
    database. The `createIfMissing` option also does what it suggests, which is creating
    a database if there isn't one already one with the name that is used. The import from
    the module, `level`, is a constructor function that creates a `level` instance
    connected to the database specified by the first argument. This first argument
    is a location in the filesystem—a directory, in other words—where the database
    will be stored.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`import`语句和一些声明开始模块。`connectDB`函数用于连接数据库，`createIfMissing`选项也是如其名所示，如果不存在具有所使用名称的数据库，则创建一个数据库。从模块`level`导入的是一个构造函数，用于创建与第一个参数指定的数据库连接的`level`实例。这个第一个参数是文件系统中的位置，换句话说，是数据库将被存储的目录。
- en: The `level` constructor returns a `db` object through which to interact with
    the database. We're storing `db` as a global variable in the module for ease of
    use. In `connectDB`, if the `db` object is set, we just return it immediately;
    otherwise, we open the database using the constructor, as just described.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`level`构造函数通过返回一个`db`对象来与数据库进行交互。我们将`db`作为模块中的全局变量存储，以便于使用。在`connectDB`中，如果`db`对象已经设置，我们立即返回它；否则，我们使用构造函数打开数据库，就像刚才描述的那样。'
- en: The location of the database defaults to `notes.level` in the current directory.
    The `LEVELDB_LOCATION` environment variable can be set, as the name implies, to
    specify the database location.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的位置默认为当前目录中的`notes.level`。`LEVELDB_LOCATION`环境变量可以设置，如其名称所示，以指定数据库位置。
- en: 'Now, let''s add the rest of this module:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加这个模块的其余部分：
- en: '[PRE17]js\1'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]js\1'
- en: 'Finally, you can run the `Notes` application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以运行`Notes`应用程序：
- en: '[PRE18]js\1'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]js\1'
- en: We import `NotesStore` so that we can call its methods, and `server` was already
    imported elsewhere.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`NotesStore`以便可以调用其方法，`server`已经在其他地方导入。
- en: The first three `process.on` calls listen to operating system signals. If you're
    familiar with Unix process signals, these terms will be familiar. In each case,
    the event calls the `catchProcessDeath` function, which then calls the `close`
    function on `NotesStore` and, for good measure, on `server`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个`process.on`调用监听操作系统信号。如果您熟悉Unix进程信号，这些术语会很熟悉。在每种情况下，事件调用`catchProcessDeath`函数，然后调用`NotesStore`和`server`上的`close`函数，以确保关闭。
- en: Then, to have a measure of confirmation, we attached an `exit` listener so that
    we can print a message when the process is exiting. The Node.js documentation
    says that the `exit` listeners are prohibited from doing anything that requires
    further event processing, so we cannot close database connections in this handler.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了确认一些事情，我们附加了一个`exit`监听器，这样当进程退出时我们可以打印一条消息。Node.js文档表示，`exit`监听器被禁止执行需要进一步事件处理的任何操作，因此我们不能在此处理程序中关闭数据库连接。
- en: 'Let''s try it out by running the `Notes` application and then immediately pressing
    *Ctrl* + *C*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下运行`Notes`应用程序，然后立即按下*Ctrl* + *C*：
- en: '[PRE19]js\1'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]js\1'
- en: This, of course, installs the `sqlite3` package.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会安装`sqlite3`包。
- en: To manage a SQLite3 database, you'll also need to install the SQLite3 command-line
    tools. The project website has precompiled binaries for most operating systems.
    You'll also find the tools available in most package management systems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理SQLite3数据库，您还需要安装SQLite3命令行工具。该项目网站为大多数操作系统提供了预编译的二进制文件。您还会发现这些工具在大多数软件包管理系统中都是可用的。
- en: One management task that we can use is setting up the database tables, as we
    will see in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的一个管理任务是设置数据库表，我们将在下一节中看到。
- en: The SQLite3 database schema
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite3数据库模式
- en: Next, we need to make sure that our database is configured with a database table
    suitable for the `Notes` application. This is an example database administrator
    task, as mentioned at the end of the previous section. To do this, we'll use the
    `sqlite3` command-line tool. The `sqlite3.org` website has precompiled binaries,
    or the tool can be installed through your operating system's package management
    system—for example, you can use `apt-get` on Ubuntu/Debian and MacPorts on macOS.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保我们的数据库配置了适合`Notes`应用程序的数据库表。这是上一节末尾提到的一个示例数据库管理员任务。为此，我们将使用`sqlite3`命令行工具。`sqlite3.org`网站有预编译的二进制文件，或者该工具可以通过您的操作系统的软件包管理系统安装——例如，您可以在Ubuntu/Debian上使用`apt-get`，在macOS上使用MacPorts。
- en: For Windows, make sure you have installed the Chocolatey package manager tool
    from [https://chocolatey.org](https://chocolatey.org/). Then start a PowerShell
    with Administrator privileges, and run "`choco install sqlite`". That installs
    the SQLite3 DLL's and its command-line tools, letting you run the following instructions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，请确保已经安装了Chocolatey软件包管理工具，然后以管理员权限启动PowerShell，并运行"`choco install
    sqlite`"。这将安装SQLite3的DLL和其命令行工具，让您可以运行以下指令。
- en: 'We''re going to use the following SQL table definition for the schema (save
    it as `models/schema-sqlite3.sql`):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下的SQL表定义作为模式（将其保存为`models/schema-sqlite3.sql`）：
- en: '[PRE20]js\1'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]js\1'
- en: While we can do this, however, the best practice is to automate all the administrative
    processes. To that end, we should instead write a little bit of script to initialize
    the database.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以这样做，但最佳实践是自动化所有管理过程。为此，我们应该编写一小段脚本来初始化数据库。
- en: 'Fortunately, the `sqlite3` command offers us a way to do this. Add the following
    to the `scripts` section of `package.json`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`sqlite3`命令为我们提供了一种方法来做到这一点。将以下内容添加到`package.json`的`scripts`部分：
- en: '[PRE21]js\1'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]js\1'
- en: This isn't fully automated since we have to press *Ctrl* + *D* at the `sqlite`
    prompt, but at least we don't have to use our precious brain cells to remember
    how to do this. We could have easily written a small Node.js script to do this;
    however, by using the tools provided by the package, we have less code to maintain
    in our own project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是完全自动化，因为我们必须在`sqlite`提示符下按*Ctrl* + *D*，但至少我们不必费心去记住如何做。我们本可以轻松地编写一个小的Node.js脚本来做到这一点；然而，通过使用软件包提供的工具，我们在自己的项目中需要维护的代码更少。
- en: With the database table set up, let's move on to the code to interface with
    SQLite3.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了数据库表的设置，让我们继续编写与SQLite3交互的代码。
- en: The SQLite3 model code
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite3模型代码
- en: We are now ready to implement an `AbstractNotesStore` implementation for SQLite3.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备为SQLite3实现一个`AbstractNotesStore`实现。
- en: 'Create the `models/notes-sqlite3.mjs` file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`models/notes-sqlite3.mjs`文件：
- en: '[PRE22]js\1'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]js\1'
- en: 'Since there are many member functions, let''s talk about them individually:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有许多成员函数，让我们逐个讨论它们：
- en: '[PRE23]js\1'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]js\1'
- en: We are now justified in defining to have separate `create` and `update` operations for the `Notes` model because
    the SQL statement for each function is different. The `create` function, of course,
    requires an `INSERT INTO` statement, while the `update` function, of course, requires
    an `UPDATE` statement.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有理由定义`Notes`模型的`create`和`update`操作是分开的，因为每个函数的SQL语句是不同的。`create`函数当然需要一个`INSERT
    INTO`语句，而`update`函数当然需要一个`UPDATE`语句。
- en: The `db.run` function, which is used several times here, executes a SQL query
    while giving us the opportunity to insert parameters in the query string.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.run`函数在这里使用了多次，它执行一个SQL查询，同时给我们机会在查询字符串中插入参数。'
- en: This follows a parameter substitution paradigm that's common in SQL programming
    interfaces. The programmer puts the SQL query in a string and then places a question
    mark anywhere that the aim is to insert a value in the query string. Each question
    mark in the query string has to match a value in the array provided by the programmer.
    The module takes care of encoding the values correctly so that the query string
    is properly formatted, while also preventing SQL injection attacks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了SQL编程接口中常见的参数替换范式。程序员将SQL查询放在一个字符串中，然后在查询字符串中的任何位置放置一个问号，以便在查询字符串中插入一个值。查询字符串中的每个问号都必须与程序员提供的数组中的一个值匹配。该模块负责正确编码这些值，以便查询字符串格式正确，同时防止SQL注入攻击。
- en: 'The `db.run` function simply runs the SQL query it is given and does not retrieve any
    data:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.run`函数只是运行它所给出的SQL查询，并不检索任何数据。'
- en: '[PRE24]js\1'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]js\1'
- en: 'In our `destroy` method, we simply use `db.run` to execute the `DELETE FROM`
    statement to delete the database entry for the associated note:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`destroy`方法中，我们只需使用`db.run`执行`DELETE FROM`语句来删除相关笔记的数据库条目：
- en: '[PRE25]js\1'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]js\1'
- en: In `count`, the task is similar, but we simply need a count of the rows in the
    table. SQL provides a `count()` function for this purpose, which we've used, and
    then because this result only has one row, we can again use `db.get`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`count`中，任务类似，但我们只需要表中行的计数。SQL提供了一个`count()`函数来实现这个目的，我们已经使用了，然后因为这个结果只有一行，我们可以再次使用`db.get`。
- en: This enables us to run `Notes` with `NOTES_MODEL` set to `sqlite3`. With our
    code now set up, we can now proceed to run `Notes` with this database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用`NOTES_MODEL`设置为`sqlite3`运行`Notes`。现在我们的代码已经设置好，我们可以继续使用这个数据库运行`Notes`。
- en: Running Notes with SQLite3
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQLite3运行Notes
- en: 'We''re now ready to run the `Notes` application with SQLite3\. Add the following
    code to the `scripts` section of `package.json`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备使用SQLite3运行`Notes`应用程序。将以下代码添加到`package.json`的`scripts`部分：
- en: '[PRE26]js\1'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]js\1'
- en: You can now browse the application at `http://localhost:3000` and run it through
    its paces, as before.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在`http://localhost:3000`上浏览应用程序，并像以前一样运行它。
- en: Because we still haven't made any changes to the `View` templates or CSS files, the
    application will look the same as before.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们还没有对`View`模板或CSS文件进行任何更改，所以应用程序看起来和以前一样。
- en: 'Of course, you can use the `sqlite` command, or other SQLite3 client applications,
    to inspect the database:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用`sqlite`命令，或其他SQLite3客户端应用程序来检查数据库：
- en: '[PRE27]js\1'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]js\1'
- en: The first obviously installs the Sequelize package. The second, `js-yaml`, is
    installed so that we can implement a YAML-formatted file to store the Sequelize
    connection configuration. YAML is a human-readable **data serialization language**,
    which simply means it is an easy-to-use text file format to describe data objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个安装了Sequelize包。第二个`js-yaml`是安装的，以便我们可以实现一个以YAML格式存储Sequelize连接配置的文件。YAML是一种人类可读的**数据序列化语言**，这意味着它是一种易于使用的文本文件格式，用于描述数据对象。
- en: Perhaps the best place to learn about YAML is its Wikipedia page, which can
    be found at [https://en.wikipedia.org/wiki/YAML](https://en.wikipedia.org/wiki/YAML).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最好了解YAML的地方是它的维基百科页面，可以在[https://en.wikipedia.org/wiki/YAML](https://en.wikipedia.org/wiki/YAML)找到。
- en: Let's start this by learning how to configure Sequelize, then we will create
    an `AbstractNotesStore` instance for Sequelize, and finally, we will test `Notes`
    using Sequelize.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习如何配置Sequelize开始，然后我们将为Sequelize创建一个`AbstractNotesStore`实例，最后，我们将使用Sequelize测试`Notes`。
- en: Configuring Sequelize and connecting to a database
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Sequelize并连接到数据库
- en: We'll be organizing the code for Sequelize support a little differently from
    before. We foresee that the `Notes` table is not the only data model that the
    `Notes` application will use. We could support additional features, such as the
    ability to upload images for a note or to allow users to comment on notes. This
    means having additional database tables and setting up relationships between database
    entries. For example, we might have a class named `AbstractCommentStore` to store
    comments, which will have its own database table and its own modules to manage
    the commented data. Both the `Notes` and `Comments` storage areas should be in
    the same database, and so they should share a database connection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与以前不同的方式组织Sequelize支持的代码。我们预见到`Notes`表不是`Notes`应用程序将使用的唯一数据模型。我们可以支持其他功能，比如上传笔记的图片或允许用户评论笔记。这意味着需要额外的数据库表，并建立数据库条目之间的关系。例如，我们可能会有一个名为`AbstractCommentStore`的类来存储评论，它将有自己的数据库表和自己的模块来管理评论数据。`Notes`和`Comments`存储区域都应该在同一个数据库中，因此它们应该共享一个数据库连接。
- en: 'With that in mind, let''s create a file, `models/sequlz.mjs`, to hold the code
    to manage the Sequelize connection:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们创建一个文件`models/sequlz.mjs`，来保存管理Sequelize连接的代码：
- en: '[PRE28]js\1'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE28]js\1'
- en: The `params.dialect` value determines what type of database to use; in this
    case, we're using SQLite3\. Depending on the dialect, the `params` object can
    take different forms, such as a connection URL to the database. In this case,
    we simply need a filename, which is given here.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`params.dialect`的值决定了要使用的数据库类型；在这种情况下，我们使用的是SQLite3。根据方言的不同，`params`对象可以采用不同的形式，比如连接到数据库的连接URL。在这种情况下，我们只需要一个文件名，就像这样给出的。'
- en: The `authenticate` call is there to test whether the database connected correctly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate` 调用是为了测试数据库是否正确连接。'
- en: The `close` function does what you expect—it closes the database connection.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`close` 函数做你期望的事情——关闭数据库连接。'
- en: 'With this design, we can easily change the database to use other database servers,
    just by adding a runtime configuration file. For example, it is easy to set up
    a MySQL connection; we just create a new file, such as `models/sequelize-mysql.yaml`,
    containing something similar to the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设计，我们可以很容易地通过添加一个运行时配置文件来更改数据库以使用其他数据库服务器。例如，很容易设置一个 MySQL 连接；我们只需创建一个新文件，比如
    `models/sequelize-mysql.yaml`，其中包含类似以下代码的内容：
- en: '[PRE29]js\1'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE29]js\1'
- en: Running Sequelize against the other databases it supports, such as PostgreSQL, is
    just as simple. Just create a configuration file, install the Node.js driver,
    and install/configure the database engine.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Sequelize 对其支持的其他数据库，如 PostgreSQL，同样简单。只需创建一个配置文件，安装 Node.js 驱动程序，并安装/配置数据库引擎。
- en: The object returned from `connectDB` is a database connection, and as we'll
    see that it is used by Sequelize. So, let's get going with the real goal of this
    section—to define the `SequelizeNotesStore` class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `connectDB` 返回的对象是一个数据库连接，正如我们将看到的，它被 Sequelize 使用。因此，让我们开始这一部分的真正目标——定义 `SequelizeNotesStore`
    类。
- en: Creating a Sequelize model for the Notes application
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Notes 应用程序创建一个 Sequelize 模型
- en: As with the other data storage engines we've used, we need to create a subclass
    of `AbstractNotesStore` for Sequelize. This class will manage a set of notes using
    a Sequelize `Model` class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用的其他数据存储引擎一样，我们需要为 Sequelize 创建一个 `AbstractNotesStore` 的子类。这个类将使用 Sequelize
    `Model` 类来管理一组注释。
- en: 'Let''s create a new file, `models/notes-sequelize.mjs`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新文件，`models/notes-sequelize.mjs`：
- en: '[PRE30]js\1'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]js\1'
- en: The first thing to note is that in each function, we call static methods defined
    in the `SQNote` class to perform database operations. Sequelize model classes
    work this way, and there is a comprehensive list of these static methods in its
    documentation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，在每个函数中，我们调用在 `SQNote` 类中定义的静态方法来执行数据库操作。Sequelize 模型类就是这样工作的，它的文档中有一个全面的这些静态方法的列表。
- en: When creating a new instance of a Sequelize model class—in this case, `SQNote`—there
    are two patterns to follow. One is to call the `build` method and then to create
    the object and the `save` method to save it to the database. Alternatively, we
    can, as is done here, use the `create` method, which does both of these steps.
    This function returns an `SQNote` instance, called `sqnote` here, and if you consult
    the Sequelize documentation, you will see that these instances have a long list
    of methods available. The contract for our `create` method is to return a note,
    so we construct a `Note` object to return.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Sequelize 模型类的新实例时——在本例中是 `SQNote`——有两种模式可供选择。一种是调用 `build` 方法，然后创建对象和 `save`
    方法将其保存到数据库。或者，我们可以像这样使用 `create` 方法，它执行这两个步骤。此函数返回一个 `SQNote` 实例，在这里称为 `sqnote`，如果您查阅
    Sequelize 文档，您将看到这些实例有一长串可用的方法。我们的 `create` 方法的约定是返回一个注释，因此我们构造一个 `Note` 对象来返回。
- en: In this, and some other methods, we do not want to return a Sequelize object
    to our caller. Therefore, we construct an instance of our own `Note` class in
    order to return a clean object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个和其他一些方法中，我们不想向调用者返回一个 Sequelize 对象。因此，我们构造了我们自己的 `Note` 类的实例，以返回一个干净的对象。
- en: Our `update` method starts by calling `SQNote.findOne`. This is done to ensure
    that there is an entry in the database corresponding to the key that we're given.
    This function looks for the first database entry where `notekey` matches the supplied
    key. Following the happy path, where there is a database entry, we then use `SQNote.update`
    to update the `title` and `body` values, and by using the same `where` clause,
    it ensures the `update` operation targets the same database entry.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `update` 方法首先调用 `SQNote.findOne`。这是为了确保数据库中存在与我们给定的键对应的条目。此函数查找第一个数据库条目，其中
    `notekey` 匹配提供的键。在快乐路径下，如果存在数据库条目，我们然后使用 `SQNote.update` 来更新 `title` 和 `body`
    值，并通过使用相同的 `where` 子句，确保 `update` 操作针对相同的数据库条目。
- en: 'The Sequelize `where` clause offers a comprehensive list of matching operators.
    If you ponder this, it''s clear it roughly corresponds to SQL as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 的 `where` 子句提供了一个全面的匹配操作符列表。如果您仔细考虑这一点，很明显它大致对应于以下 SQL：
- en: '[PRE31]js\1'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE31]js\1'
- en: This sets up commands to run a single server instance (or two).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了命令以运行单个服务器实例（或两个）。
- en: 'Then, run it as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按以下方式运行它：
- en: '[PRE32]js\1'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]js\1'
- en: This creates a data directory and then runs the MongoDB daemon against the directory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个数据目录，然后运行 MongoDB 守护程序来对该目录进行操作。
- en: 'In another command window, you can test it as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个命令窗口中，您可以按以下方式进行测试：
- en: '[PRE33]js\1'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE33]js\1'
- en: This sets us up with the driver package and adds it to `package.json`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们设置了驱动程序包，并将其添加到 `package.json`。
- en: 'Now, create a new file, `models/notes-mongodb.mjs`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个新文件，`models/notes-mongodb.mjs`：
- en: '[PRE34]js\1'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34]js\1'
- en: MongoDB stores all documents in collections. A *collection* is a group of related
    documents and is analogous to a table in a relational database. This means creating
    a new document or updating an existing one starts by constructing it as a JavaScript
    object and then asking MongoDB to save the object to the database. MongoDB automatically
    encodes the object into its internal representation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 将所有文档存储在集合中。*集合* 是一组相关文档，类似于关系数据库中的表。这意味着创建一个新文档或更新现有文档始于将其构造为 JavaScript
    对象，然后要求 MongoDB 将对象保存到数据库中。MongoDB 自动将对象编码为其内部表示形式。
- en: The `db().collection` method gives us a `Collection` object with which we can
    manipulate the named collection. In this case, we access the `notes` collection
    with `db().collection('notes')`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`db().collection` 方法为我们提供了一个 `Collection` 对象，我们可以使用它来操作命名集合。在这种情况下，我们使用 `db().collection(''notes'')`
    访问 `notes` 集合。'
- en: For the documentation of the `Collection` class, see the MongoDB Node.js driver
    documentation referenced earlier.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `Collection` 类的文档，请参阅之前引用的 MongoDB Node.js 驱动程序文档。
- en: In the `create` method, we use `insertOne`; as the method name implies, it inserts
    one document into the collection. This document is used for the fields of the
    `Note` class. Likewise, in the `update` method, the `updateOne` method first finds
    a document (in this case, by looking up the document with the matching `notekey`
    field) and then changes fields in the document, as specified, before saving the
    modified document back to the database.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create`方法中，我们使用`insertOne`；顾名思义，它将一个文档插入到集合中。这个文档用于`Note`类的字段。同样，在`update`方法中，`updateOne`方法首先找到一个文档（在这种情况下，通过查找具有匹配`notekey`字段的文档），然后根据指定的内容更改文档中的字段，然后将修改后的文档保存回数据库。
- en: The `read` method uses `db().findOne` to search for the note.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法使用`db().findOne`来搜索笔记。'
- en: The `findOne` method takes what is called a *query selector*. In this case,
    we are requesting a match against the `notekey` field. MongoDB supports a comprehensive
    set of operators for query selectors.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOne`方法采用所谓的*查询选择器*。在这种情况下，我们要求与`notekey`字段匹配。MongoDB支持一套全面的查询选择器操作符。'
- en: On the other hand, the `updateOne` method takes what is called a *query filter*.
    As an `update` operation, it searches the database for a record that matches the
    filter, updates its fields based on the update descriptor, and then saves it back
    to the database.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`updateOne`方法采用所谓的*查询过滤器*。作为一个`update`操作，它在数据库中搜索与过滤器匹配的记录，根据更新描述符更新其字段，然后将其保存回数据库。
- en: For an overview of the MongoDB CRUD operations, including inserting documents,
    updating documents, querying for documents, and deleting documents, refer to [https://docs.mongodb.com/manual/crud/](https://docs.mongodb.com/manual/crud/).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于MongoDB CRUD操作的概述，包括插入文档、更新文档、查询文档和删除文档，请参阅[https://docs.mongodb.com/manual/crud/](https://docs.mongodb.com/manual/crud/)。
- en: For the documentation on query selectors, refer to [https://docs.mongodb.com/manual/reference/operator/query/#query-selectors](https://docs.mongodb.com/manual/reference/operator/query/#query-selectors).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有关查询选择器的文档，请参阅[https://docs.mongodb.com/manual/reference/operator/query/#query-selectors](https://docs.mongodb.com/manual/reference/operator/query/#query-selectors)。
- en: For the documentation on query filters, refer to [https://docs.mongodb.com/manual/core/document/#query-filter-documents](https://docs.mongodb.com/manual/core/document/#query-filter-documents).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有关查询过滤器的文档，请参阅[https://docs.mongodb.com/manual/core/document/#query-filter-documents](https://docs.mongodb.com/manual/core/document/#query-filter-documents)。
- en: For the documentation on update descriptors, refer to [https://docs.mongodb.com/manual/reference/operator/update/](https://docs.mongodb.com/manual/reference/operator/update/).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更新描述符的文档，请参阅[https://docs.mongodb.com/manual/reference/operator/update/](https://docs.mongodb.com/manual/reference/operator/update/)。
- en: MongoDB has many variations of base operations. For example, `findOne` is a
    variation on the basic `find` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB有许多基本操作的变体。例如，`findOne`是基本`find`方法的一个变体。
- en: In our `destroy` method, we see another `find` variant, `findOneAndDelete`.
    As the name implies, it finds a document that matches the query descriptor and
    then deletes the document.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`destroy`方法中，我们看到另一个`find`变体，`findOneAndDelete`。顾名思义，它查找与查询描述符匹配的文档，然后删除该文档。
- en: In the `keylist` method, we need to process every document in the collection,
    and so the `find` query selector is empty. The `find` operation returns a `Cursor`,
    which is an object used to navigate query results. The `Cursor.forEach` method
    takes two callbacks and is not a Promise-friendly operation, so we have to use
    a Promise wrapper. The first callback is called for every document in the query
    result, and in this case, we simply push the `notekey` field into an array. The
    second callback is called when the operation is finished, and we notify the Promise
    whether it succeeded or failed. This gives us our array of keys, which is returned
    to the caller.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`keylist`方法中，我们需要处理集合中的每个文档，因此`find`查询选择器为空。`find`操作返回一个`Cursor`，这是一个用于导航查询结果的对象。`Cursor.forEach`方法采用两个回调函数，不是一个Promise友好的操作，因此我们必须使用一个Promise包装器。第一个回调函数对查询结果中的每个文档都会调用，而在这种情况下，我们只是将`notekey`字段推送到一个数组中。第二个回调函数在操作完成时调用，并且我们通知Promise它是成功还是失败。这给我们了我们的键数组，它返回给调用者。
- en: For the documentation on the `Cursor` class, refer to [http://mongodb.github.io/node-mongodb-native/3.1/api/Cursor.html](http://mongodb.github.io/node-mongodb-native/3.1/api/Cursor.html).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Cursor`类的文档，请参阅[http://mongodb.github.io/node-mongodb-native/3.1/api/Cursor.html](http://mongodb.github.io/node-mongodb-native/3.1/api/Cursor.html)。
- en: In our `count` method, we simply call the MongoDB `count` method. The `count`
    method takes a query descriptor and, as the name implies, counts the number of
    documents that match the query. Since we've given an empty query selector, it
    ends up counting the entire collection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`count`方法中，我们简单地调用MongoDB的`count`方法。`count`方法采用查询描述符，并且顾名思义，计算与查询匹配的文档数量。由于我们给出了一个空的查询选择器，它最终计算整个集合。
- en: This allows us to run Notes with `NOTES_MODEL` set to `mongodb` to use a MongoDB
    database.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以将`NOTES_MODEL`设置为`mongodb`来使用MongoDB数据库运行Notes。
- en: Now that we have everything coded for MongoDB, we can proceed with testing `Notes`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为MongoDB编写了所有的代码，我们可以继续测试`Notes`。
- en: Running the Notes application with MongoDB
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MongoDB运行Notes应用程序
- en: 'We are ready to test `Notes` using a MongoDB database. By now, you know the
    drill; add the following to the `scripts` section of `package.json`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备使用MongoDB数据库测试`Notes`。到目前为止，你知道该怎么做；将以下内容添加到`package.json`的`scripts`部分：
- en: '[PRE35]js\1'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE35]js\1'
- en: The `MONGO_URL` environment variable should contain the URL for connecting with
    your MongoDB database. The URL shown here is correct for a MongoDB server started
    on the local machine, as would be the case if you started MongoDB at the command
    line as shown at the beginning of this section. Otherwise, if you have a MongoDB
    server provisioned somewhere else, you will have been told what the access URL
    is, and your `MONGO_URL` variable should have that URL.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`MONGO_URL`环境变量应包含与您的MongoDB数据库连接的URL。这里显示的URL对于在本地机器上启动MongoDB服务器是正确的，就像您在本节开始时在命令行上启动MongoDB一样。否则，如果您在其他地方提供了MongoDB服务器，您将被告知访问URL是什么，您的`MONGO_URL`变量应该有该URL。'
- en: You can start two instances of the `Notes` application and see that both share
    the same set of notes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以启动两个`Notes`应用程序实例，并查看它们都共享相同的笔记集。
- en: 'We can verify that the MongoDB database ends up with the correct value.  First,
    start the MongoDB client program as so:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证MongoDB数据库最终是否具有正确的值。首先，这样启动MongoDB客户端程序：
- en: '```js'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '```js'
- en: Again, this is assuming the MongoDB configuration presented so far, and if your
    configuration differs then add the URL on the command line. This starts the interactive
    MongoDB shell, connected to the database configured for use by Notes. To inspect
    the content of the database, simply enter the command:  `db.notes.find()`. That
    will print out every database entry.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是基于迄今为止所呈现的MongoDB配置，如果您的配置不同，请在命令行上添加URL。这将启动与Notes配置的数据库连接的交互式MongoDB
    shell。要检查数据库的内容，只需输入命令：`db.notes.find()`。这将打印出每个数据库条目。
- en: With that, we have completed support not only for MongoDB but also for several
    other databases in the `Notes` application, and so we are now ready to wrap up
    the chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一点，我们不仅完成了对`Notes`应用程序中MongoDB的支持，还支持了其他几种数据库，因此我们现在准备结束本章。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through a real whirlwind of different database technologies.
    While we looked at the same seven functions over and over, it's useful to be exposed
    to the various data storage models and ways of getting things done. Even so, we
    only touched on the surface of options for accessing databases and data storage
    engines in Node.js.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了不同的数据库技术的真正风暴。虽然我们一遍又一遍地看了同样的七个函数，但接触到各种数据存储模型和完成任务的方式是有用的。即便如此，在Node.js中访问数据库和数据存储引擎的选项只是触及了表面。
- en: By abstracting the model implementations correctly, we were able to easily switch
    data storage engines without changing the rest of the application. This technique
    lets us explore how subclassing works in JavaScript and the concept of creating
    different implementations of the same API. Additionally, we got a practical introduction
    to the `import()` function and saw how it can be used to dynamically choose which
    module to load.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过正确抽象模型实现，我们能够轻松地在不改变应用程序其余部分的情况下切换数据存储引擎。这种技术让我们探索了JavaScript中子类化的工作原理，以及创建相同API的不同实现的概念。此外，我们还对`import()`函数进行了实际介绍，并看到它可以用于动态选择要加载的模块。
- en: In real-life applications, we frequently create abstractions for a similar purpose.
    They help us hide details or allow us to change implementations while insulating
    the rest of the application from the change. A dynamic import, which we used for
    our app, is useful for dynamically stitching together an application; for example,
    to load each module in a given directory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中的应用程序中，我们经常为类似的目的创建抽象。它们帮助我们隐藏细节或允许我们更改实现，同时使应用程序的其余部分与更改隔离。我们用于我们的应用程序的动态导入对于动态拼接应用程序非常有用；例如，加载给定目录中的每个模块。
- en: We avoided the complexity of setting up database servers. As promised, we'll
    get into that in [Chapter 10,](176ce11c-dd6f-4ebf-ba14-529be6db28da.xhtml) *Deploying
    Node.js Applications to Linux Servers*, when we explore the production deployment
    of Node.js applications.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免了设置数据库服务器的复杂性。正如承诺的那样，当我们探索将Node.js应用程序部署到Linux服务器时，我们将在[第10章](176ce11c-dd6f-4ebf-ba14-529be6db28da.xhtml)中进行讨论，*将Node.js应用程序部署到Linux服务器*。
- en: By focusing our model code for the purpose of storing data, both the model and
    the application should be easier to test. We'll look at this in more depth in
    [Chapter 13](1c1eb7f2-8b1a-4f70-9f0a-94d865c739ef.xhtml), *Unit Testing and Functional
    Testing*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的模型代码专注于存储数据，模型和应用程序应该更容易测试。我们将在[第13章](1c1eb7f2-8b1a-4f70-9f0a-94d865c739ef.xhtml)中更深入地研究这一点，*单元测试和功能测试*。
- en: In the next chapter, we'll focus on supporting multiple users, allowing them
    to log in and out, and authenticating users using OAuth 2.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于支持多个用户，允许他们登录和退出，并使用OAuth 2对用户进行身份验证。
