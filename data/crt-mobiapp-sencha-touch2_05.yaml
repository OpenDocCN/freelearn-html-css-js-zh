- en: 'Chapter 5. On Deck: Using Sencha.io'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。在牌组中：使用Sencha.io
- en: In our previous chapters we have typically used local storage for maintaining
    our data. This offers a number of advantages with its ease of use and simplicity.
    The store and the model do all of the heavy lifting for us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中，我们通常使用本地存储来维护我们的数据。这以其易用性和简单性提供了许多优势。存储和模型为我们做了所有繁重的工作。
- en: However, there are a number of disadvantages to local storage as well. First
    and foremost, it is very much local to the device. This means that if your user
    has more than one device (a phone, desktop, and a tablet computer), then they
    will have a separate set of data for each device.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本地存储也有一些缺点。首先，它非常本地化。这意味着如果你的用户有多个设备（一部手机、桌面和一台平板电脑），那么他们将为每个设备有一组独立的数据。
- en: This can be confusing to the user and it negates the advantage of having a single
    application that is accessible from multiple devices. Additionally, the data can
    be deleted by the user when they clear the local browser data. This can make local
    storage a bit problematic for a robust application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会使用户感到困惑，并抵消了拥有一个可以从多个设备访问的单个应用程序的优势。此外，用户在清除本地浏览器数据时可以删除数据。这可能会使本地存储对健壮的应用程序有些问题。
- en: 'In this chapter we are going to look at solving this issue with an external
    API called Sench.io. Here''s what we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用名为Sench.io的外部API来解决此问题。以下是我们将要涵盖的内容：
- en: Setting up the basic application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置基本应用程序
- en: Getting started with Sencha.io
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Sencha.io
- en: Updating the basic application to work with Sencha.io
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基本应用程序更新为与Sencha.io一起工作
- en: The basic application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本应用程序
- en: Our basic application is designed to present a set of flash cards to the user
    in a random order. Each set of flash cards comprises a deck. The user can add
    new decks and new cards to each deck. The decks and the cards will reside in a
    remote storage service called **Sencha.io**. Using this service, the user will
    also be able to log in from any number of devices and access their cards and decks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本应用程序旨在以随机顺序向用户展示一组闪卡。每一组闪卡包含一副牌。用户可以为每副牌添加新的牌。这些牌和牌组将存储在一个名为**Sencha.io**的远程存储服务中。使用此服务，用户还可以从任何数量的设备登录并访问他们的牌和牌组。
- en: '![The basic application](img/8901OS_05_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![基本应用程序](img/8901OS_05_01.jpg)'
- en: We will start off our application with the models and stores.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始我们的应用程序，从模型和存储开始。
- en: Creating the models and stores
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型和存储
- en: 'The model for our deck is very simple and only needs two pieces of information.
    We will use an ID to link cards to a specific deck and a name for display purposes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的牌组模型非常简单，只需要两块信息。我们将使用一个ID将牌链接到特定的牌组，并使用名称进行显示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The card model needs an ID of its own so that we can uniquely identify it and
    a `deckID` value so that we know which deck it''s a part of. We will also need
    the question and answer for each card:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 牌模型需要它自己的ID，以便我们可以唯一地识别它，以及一个`deckID`值，以便我们知道它是哪个牌组的一部分。我们还需要为每张牌提供问题和答案：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the two stores, we will initially use a local storage `proxy` as we have
    in previous chapters. This will let us test our application before we start using
    the Sencha.io service.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个存储，我们最初将使用与之前章节中相同的本地存储`proxy`。这将让我们在开始使用Sencha.io服务之前测试我们的应用程序。
- en: 'Our deck store looks like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的牌组存储看起来是这样的：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you have worked your way through the first chapter, this basic setup should
    look pretty familiar to you. We extend the basic store, require our `model` file,
    and then set up our configuration. The configuration sets the store to load when
    it is created, tells it which model to use, sets up our local storage `proxy`,
    and tells it which `fields` to expect.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了第一章，这个基本设置应该对你来说相当熟悉。我们扩展了基本存储，需要我们的`model`文件，然后设置我们的配置。配置设置在创建时加载存储，告诉它使用哪个模型，设置我们的本地存储`proxy`，并告诉它期望哪些`fields`。
- en: 'Our card store is almost an exact duplicate:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的牌存储几乎是一个完全的副本：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we have just changed the name from `Deck` to `Card`, and specified our
    card fields in place of our deck fields.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将名称从`Deck`更改为`Card`，并用我们的牌字段替换了牌组字段。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you configure your store with a model, you don't actually have to specify
    the fields. We are doing so here just for the sake of completeness.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用模型配置存储，实际上你不必指定字段。我们在这里这样做只是为了完整性。
- en: As mentioned before, we will be revisiting these stores once we get things set
    up with `Sencha.io`, but first we need to get our display together for our lists,
    cards, and editing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一旦我们在 `Sencha.io` 上设置好一切，我们就会重新访问这些商店，但首先我们需要为我们的列表、卡片和编辑准备显示。
- en: Creating the views
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图
- en: 'For our main view, we will be using a tab panel with two containers, one for
    our decks and one for our cards. We will use sheets for editing and adding new
    decks and cards. Our initial `main.js` file looks like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的主视图，我们将使用一个包含两个容器的选项卡面板，一个用于我们的牌组，另一个用于我们的卡片。我们将使用表单进行编辑和添加新的牌组和卡片。我们的初始
    `main.js` 文件如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Remember to add this file into your `app.js` file and set the launch function
    to create a copy of the component when the application starts (if you are using
    Sencha Architect, then this should happen automatically). Your `app.js` file should
    look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将此文件添加到你的 `app.js` 文件中，并将启动函数设置为在应用程序启动时创建组件的副本（如果你使用 Sencha Architect，则此操作应自动完成）。你的
    `app.js` 文件应如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next we need to add the two containers to our `main.js` view. In the empty
    items section, add the following container:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将两个容器添加到我们的 `main.js` 视图中。在空项部分，添加以下容器：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will be the list for our decks. The overall container has a `fit` layout
    so the items will fill the entire width and height of the container. We have given
    the container a title and an `iconCls` value, which will be used to label the
    tab in our `Main` tab panel.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的牌组列表。整体容器具有 `fit` 布局，因此项目将填充容器的整个宽度和高度。我们给容器添加了一个标题和 `iconCls` 值，这些值将用于在
    `Main` 选项卡面板中标记标签。
- en: The container has a `list` view that uses our `DeckStore` store and a simple
    `itemTpl` template that displays the name of each deck in a separate `div` tag.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器有一个 `list` 视图，使用我们的 `DeckStore` 存储和简单的 `itemTpl` 模板，在单独的 `div` 标签中显示每个牌组的名称。
- en: We have also added a title bar where we can display a button for adding new
    decks and a title to let the user know what they are looking at.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个标题栏，其中可以显示用于添加新牌组的按钮，以及一个标题，让用户知道他们正在查看的内容。
- en: 'Our second container follows the same pattern as our first, but instead of
    a list, we have a separate container with a `carousel` layout, as shown in the
    following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个容器遵循与第一个相同的模式，但与列表不同，我们有一个单独的容器，其中包含 `carousel` 布局，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This container has a `titlebar` control that will be set to display the name
    of the current deck at the top and pull the cards into our `carousel` layout.
    We also have a second button that will shuffle the current deck of cards.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器有一个 `titlebar` 控件，将设置为在顶部显示当前牌组的名称，并将卡片拉入 `carousel` 布局。我们还有一个第二个按钮，可以随机排列当前的牌组卡片。
- en: 'Next we need to set up the two sheets for adding cards and decks. The deck
    sheet is a simple sheet with a `textfield` element for naming the deck, a `button`
    element for saving, and another `button` element for canceling:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置用于添加卡片和牌组的两个表单。牌组表单是一个简单的表单，包含用于命名牌组的 `textfield` 元素，用于保存的 `button`
    元素，以及用于取消的另一个 `button` 元素：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We also add a listener for the `Cancel` button that will hide the sheet without
    saving the values. The listener delegates the `tap` event to our `cancelDeckButton`
    delegate and calls the `hideDeckSheet` function when the `tap` event occurs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个监听器来监听 `Cancel` 按钮，该按钮会在不保存值的情况下隐藏表单。监听器将 `tap` 事件委托给我们的 `cancelDeckButton`
    委托，并在 `tap` 事件发生时调用 `hideDeckSheet` 函数。
- en: The `hideDeckSheet` function receives the `button` element as part of its arguments.
    We can then travel up the DOM structure from the button, find the sheet, and hide
    it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`hideDeckSheet` 函数接收 `button` 元素作为其参数的一部分。然后我们可以从按钮开始，沿着 DOM 结构向上移动，找到该表单，并将其隐藏。'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**A note about using up and down**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于上下使用的注意事项**'
- en: The `up` and `down` functions in Sencha Touch are extremely useful when you
    have a component and you need to get to either a sub component or a parent component.
    However, it should be noted that both `up` and `down` only return the first component
    that matches. For example, if a `button` element is inside of a `container` element,
    which is itself inside another `container` element, then `button.up('container')`
    would return the first container and not the second, outer container.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个组件并且需要到达子组件或父组件时，Sencha Touch 中的 `up` 和 `down` 函数非常有用。然而，需要注意的是，`up` 和
    `down` 只返回第一个匹配的组件。例如，如果 `button` 元素位于 `container` 元素内部，而 `container` 元素本身又位于另一个
    `container` 元素内部，那么 `button.up('container')` 将返回第一个容器而不是第二个，外部的容器。
- en: 'Our card sheet is a duplicate of the deck sheet, but with text fields for `question`
    and `answer`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的卡片表单是牌组表单的副本，但包含 `问题` 和 `答案` 的文本字段：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As before, we have our **Save** and **Cancel** buttons, with the **Cancel**
    button hiding the sheet when tapped.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们有 **保存** 和 **取消** 按钮，当点击 **取消** 按钮时将隐藏表单。
- en: 'You should now be able to start the application and test the different views
    as shown:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够启动应用程序并测试不同的视图，如所示：
- en: '![Creating the views](img/8901OS_05_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![创建视图](img/8901OS_05_02.jpg)'
- en: Before we can get things working further in the application, we need to get
    set up with Sencha.io.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够在应用程序中进一步工作之前，我们需要设置 Sencha.io。
- en: Getting started with Sencha.io
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Sencha.io
- en: The Sencha.io service will allow us to store our data using Sencha's cloud service.
    We will need to register a new account, add our application and user groups using
    the Sencha.io dashboard, and then configure our application to use the service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha.io 服务将允许我们使用 Sencha 的云服务来存储我们的数据。我们需要在 Sencha.io 控制台中注册一个新账户，添加我们的应用程序和用户组，然后配置我们的应用程序以使用该服务。
- en: The sign-up process
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册流程
- en: 'To register a new account, go to [https://manage.sencha.io](https://manage.sencha.io)
    and click on the **Register** link at the bottom of the page. Fill out the forms
    with your information and submit. Once your account is created, log in to the
    Sencha.io dashboard at the same address you used for registration, and you will
    see something similar to the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册一个新账户，请访问 [https://manage.sencha.io](https://manage.sencha.io) 并点击页面底部的**注册**链接。填写表格并提交。一旦你的账户创建成功，使用注册时相同的地址登录
    Sencha.io 控制台，你将看到以下截图类似的内容：
- en: '![The sign-up process](img/8901OS_05_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![注册流程](img/8901OS_05_03.jpg)'
- en: Downloading and installing the Sencha.io SDK
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载和安装 Sencha.io SDK
- en: Now that you have an account you can download and install the Sencha.io SDK.
    There is a download link in the first part of the **Getting Started** page (which
    should be where you first start when you log in).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了账户，你可以下载并安装 Sencha.io SDK。在**入门**页面的第一部分有一个下载链接（当你登录时应该首先开始的地方）。
- en: 'Download the SDK to your computer and unzip the file. Move it into your web
    directory (someplace where you can easily reference it from your application).
    Next we need to add these files to our application. You can begin by opening your
    main `app.html` file and adding the following lines in the `head` section of the
    file (with your other script includes):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将 SDK 下载到您的计算机上并解压文件。将其移动到您的网页目录（您可以从应用程序中轻松引用的地方）。接下来，我们需要将这些文件添加到我们的应用程序中。您可以从打开主
    `app.html` 文件并在文件的 `head` 部分添加以下行开始（与您的其他脚本包含一起）：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we have copied all of the Sencha.io files into a folder called
    `io` in the `lib` directory of our application. If your path is different, you
    will need to adjust the lines above to fit your setup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将所有 Sencha.io 文件复制到了应用程序 `lib` 目录下的一个名为 `io` 的文件夹中。如果你的路径不同，你需要调整上面的行以适应你的设置。
- en: 'Now that we have included the two main files we need for Sencha.io, we also
    need to set some options in `app.js` so that the autoloader picks up these files
    as well. At the top of the `app.js` file, add the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经包含了 Sencha.io 所需的两个主要文件，我们还需要在 `app.js` 中设置一些选项，以便自动加载器也能收集这些文件。在 `app.js`
    文件的顶部，添加以下代码：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once we have this information set, our application should be able to pick up
    all the files it needs to work with Sencha.io, but we still need to register our
    application before we can continue building.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了这些信息，我们的应用程序应该能够收集到它需要与 Sencha.io 一起工作的所有文件，但在我们继续构建之前，我们仍然需要注册我们的应用程序。
- en: Registering your application and Auth group
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册你的应用程序和 Auth 组
- en: Registering your application and Auth group with Sencha.io provisions the application
    with its own data storage and an authorized user base. As with most API services,
    your application needs a way to uniquely identify itself to the remote system
    so that it will know where to store your data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sencha.io 上注册你的应用程序和 Auth 组将为应用程序提供其自己的数据存储和授权用户基础。与大多数 API 服务一样，你的应用程序需要一种方式来唯一标识自己以远程系统，这样它就会知道在哪里存储你的数据。
- en: 'With Sencha.io, we will get two pieces of information when we register our
    application: an `appID` value and an `appSecret` value. These two pieces of information
    will be added to `app.js` to identify our application to the Sencha.io system.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sencha.io，当注册我们的应用程序时，我们将获得两块信息：一个 `appID` 值和一个 `appSecret` 值。这两块信息将被添加到
    `app.js` 中，以标识我们的应用程序给 Sencha.io 系统。
- en: Let's start by adding an Auth group. The Auth group sets up a group where users
    can register to use your application. If you have multiple applications, you can
    set up one Auth group for each application or set up a single Auth group to be
    shared across multiple applications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加一个认证组开始。认证组设置了一个用户可以注册以使用您的应用程序的组。如果您有多个应用程序，可以为每个应用程序设置一个认证组，或者设置一个共享多个应用程序的单个认证组。
- en: From the **Dashboard** section of your Sencha.io account ([http://manage.sencha.io](http://manage.sencha.io)),
    click on the **Auth Groups** link at the top of the page and choose **Create Auth
    Group**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的 Sencha.io 账户的 **仪表板** 部分 ([http://manage.sencha.io](http://manage.sencha.io))，点击页面顶部的
    **认证组** 链接，然后选择 **创建认证组**。
- en: '![Registering your application and Auth group](img/8901OS_05_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![注册应用程序和认证组](img/8901OS_05_04.jpg)'
- en: Enter a name for your Auth group and click on **Save**. The name is arbitrary,
    but if you are using the group for a single application, it's probably best to
    name it something like `myAppNameUsers` so that you can keep track of which application
    this is for.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您的认证组名称，然后点击 **保存**。名称是任意的，但如果您为单个应用程序使用该组，最好将其命名为类似 `myAppNameUsers` 的名称，这样您可以跟踪这是为哪个应用程序。
- en: The Auth group also controls how the users authenticate in your application.
    Once you have saved the Auth group, you can edit it and change the way users log
    in to your application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 认证组还控制用户在您的应用程序中的认证方式。一旦保存了认证组，您就可以编辑它并更改用户登录应用程序的方式。
- en: '![Registering your application and Auth group](img/8901OS_05_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![注册应用程序和认证组](img/8901OS_05_05.jpg)'
- en: You can choose to have users authenticate before the application fully downloads
    or afterwards. You can also choose to let users log in with a valid Facebook,
    Twitter, or Sencha.io account.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择在应用程序完全下载之前或之后让用户进行认证。您还可以选择让用户使用有效的 Facebook、Twitter 或 Sencha.io 账户登录。
- en: If you choose the **Sencha.io** login option, then the SDK will automatically
    handle both user registration and authentication within your application, no extra
    coding required.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择 **Sencha.io** 登录选项，那么 SDK 将自动处理应用程序内的用户注册和认证，无需额外编码。
- en: If you choose the **Facebook** or **Twitter** login option, Sencha.io will handle
    the authentication automatically. Users will have to be registered with either
    service before they can access the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择 **Facebook** 或 **Twitter** 登录选项，Sencha.io 将自动处理认证。用户在能够访问应用程序之前必须先在任一服务中注册。
- en: '![Registering your application and Auth group](img/8901OS_05_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![注册应用程序和认证组](img/8901OS_05_06.jpg)'
- en: 'Now that we have a set of users for the application, we need to register the
    application itself. From the Sencha.io dashboard, click on **Apps** and then click
    on **Create App**. As before, we only need to enter a name for the application.
    For this application we chose the name **OnDeck** as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为应用程序设置了一组用户，我们需要注册应用程序本身。从 Sencha.io 仪表板，点击 **应用**，然后点击 **创建应用**。和之前一样，我们只需要输入应用程序的名称。对于这个应用程序，我们选择了
    **OnDeck** 这个名称，如下截图所示：
- en: '![Registering your application and Auth group](img/8901OS_05_07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![注册应用程序和认证组](img/8901OS_05_07.jpg)'
- en: Next we need to select our **Authentication Group** name from the drop-down
    menu. This tells Sencha.io to authenticate and assign users from this group to
    our application. There is an optional **CNAME** field for setting the domain your
    application will reside on, as well as a field for the path to the `index.html`
    file. This should be set if you are using the `app.html` file instead of `index.html`,
    or if you have your application hosted inside a sub directory on your server.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从下拉菜单中选择我们的 **认证组** 名称。这会告诉 Sencha.io 对此组进行认证并将用户分配给我们的应用程序。有一个可选的 **CNAME**
    字段用于设置应用程序所在的域名，以及一个用于 `index.html` 文件路径的字段。如果您使用的是 `app.html` 文件而不是 `index.html`，或者如果您的应用程序托管在服务器的子目录中，则需要设置此字段。
- en: We can also set an application icon here. This is the icon that will be used
    if the user saves our web application to their home screen. Click on **Save**
    when you are finished.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在这里设置应用程序图标。这是当用户将我们的网络应用程序保存到主屏幕时将使用的图标。完成设置后，点击 **保存**。
- en: '![Registering your application and Auth group](img/8901OS_05_08.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![注册应用程序和认证组](img/8901OS_05_08.jpg)'
- en: On the page application page, you should now see a listing for your application's
    ID (mentioned in the **ID** field) and secret (mentioned in the **Secret** field).
    Make note of these, as we will need to add them into `app.js` once we are finished
    with registration.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面应用程序页面上，您现在应该看到您的应用程序 ID（在 **ID** 字段中提及）和密钥（在 **Secret** 字段中提及）的列表。请注意这些信息，因为我们完成注册后需要将它们添加到
    `app.js` 中。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Please note that the **ID** and **Secret** values in the preceding example screenshot
    are example data only. You will need to generate your own information on the Sencha.io
    site to make your application work. You will also need to generate your own ID
    and secret to make the example code from the chapter work.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面示例截图中的 **ID** 和 **Secret** 值仅是示例数据。您需要在 Sencha.io 网站上生成自己的信息以使您的应用程序工作。您还需要生成自己的
    ID 和密钥以使章节中的示例代码工作。
- en: 'Once you have completed this part of the registration, you will need to add
    the ID and secret values into your `app.js` file. Open the file and add the following
    code at the top of the `Ext.application({` section:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 完成注册的这一部分后，您需要将 ID 和密钥值添加到您的 `app.js` 文件中。打开文件，并在 `Ext.application({` 部分的顶部添加以下代码：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Substitute your information for the `appId` and `appSecret` placeholders shown.
    Once you have added the information into `app.js`, we can get back to updating
    our stores and creating our controller.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 用 `appId` 和 `appSecret` 占位符所示的信息替换您的信息。一旦您将信息添加到 `app.js` 中，我们就可以回到更新我们的存储和创建我们的控制器。
- en: Updating the application for Sencha.io
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新应用程序以使用 Sencha.io
- en: Now that our application is registered, we need to set up the stores to use
    Sencha.io. We will also set up our controller for the application and show you
    how to override the `Carousel` component to make it work with a data store.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经注册了应用程序，我们需要设置存储以使用 Sencha.io。我们还将设置应用程序的控制器，并展示如何覆盖 `Carousel` 组件以使其与数据存储一起工作。
- en: Updating the stores
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新存储
- en: 'Our original stores were simple local storage for testing. We are going to
    edit these now to use Sencha.io to store our data. Most of these changes will
    be in the `proxy` section. For example, the `DeckStore` code should be updated
    to look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原始的存储是简单的本地存储，用于测试。我们现在将编辑这些存储以使用 Sencha.io 存储我们的数据。这些更改的大部分将在 `proxy` 部分进行。例如，`DeckStore`
    代码应更新为如下所示：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we now use a new type of proxy called `syncstorage`. This is the
    special Sencha.io proxy that works much the same as a local store, but it stores
    the data remotely on the Sencha.io servers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在使用一种新的代理类型，称为 `syncstorage`。这是一个特殊的 Sencha.io 代理，它的工作方式与本地存储非常相似，但它将数据远程存储在
    Sencha.io 服务器上。
- en: We also have new configurations for `owner` and `access`. The `owner` and `access`
    field must both be set for `syncstorage` to work correctly. As of this writing,
    the only `owner` option is `user`. This is the currently authenticated user.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有新的 `owner` 和 `access` 配置。`owner` 和 `access` 字段都必须设置，`syncstorage` 才能正确工作。截至本文写作时，唯一的
    `owner` 选项是 `user`。这是当前认证的用户。
- en: The `access` configuration determines if the store is **private**, available
    only to the currently authenticated user, or **public**, available to all members
    of the group of users. This is the user group we set up in the Sencha.io dashboard.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`access` 配置确定存储是**私有**的，仅对当前认证用户可用，还是**公共**的，对所有用户组的成员可用。这是我们设置在 Sencha.io
    仪表板中的用户组。'
- en: 'Next, we added a configuration of `autoLoad: true`. This will load any local
    data if the connection is lost while the user is still logged in. We then set
    `autosync: false` to prevent the store from automatically syncing when the application
    starts. We should to wait until the user logs into the application before we load
    the store. We will do this manually as part of the application controller.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们添加了 `autoLoad: true` 的配置。当用户仍然登录时，如果连接丢失，这将加载任何本地数据。然后我们设置 `autosync:
    false` 以防止存储在应用程序启动时自动同步。我们应该在加载存储之前等待用户登录到应用程序。我们将手动作为应用程序控制器的一部分来完成这项工作。'
- en: 'You can make the exact same changes to the `CardStore.js` file to get it working
    with Sencha.io, but it requires one additional setting for `remoteFilter: false`.
    We will be loading all of the user''s cards when they log in, and filtering them
    by deck once a deck is selected.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以对 `CardStore.js` 文件进行完全相同的更改，使其与 Sencha.io 一起工作，但需要为 `remoteFilter: false`
    设置一个额外的设置。当用户登录时，我们将加载所有用户的卡片，并在选择一副牌后进行过滤。'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The `remoteFilter` configuration is part of the store, not the proxy.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`remoteFilter` 配置是存储的一部分，而不是代理。'
- en: Now that we have our stores configured we can move on to the controller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了存储，我们可以继续到控制器部分。
- en: Creating the controller
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'Our controller has a few things it needs to handle for us:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器需要为我们处理一些事情：
- en: Setting up for Sencha.io
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Sencha.io设置
- en: Handling anything that needs to happen at login and logout
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理登录和登出时需要发生的任何事情
- en: Adding cards and decks
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加卡片和牌组
- en: Selecting a deck for display
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择用于显示的牌组
- en: Syncing between the local application and Sencha.io
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地应用程序和Sencha.io之间同步
- en: 'We will start by setting up our basic controller with the models, views, stores,
    and references:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置基本控制器，包括模型、视图、存储和引用：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first section defines our controller and then lists the `models`, `stores`,
    and `views` values we previously created. We also add an empty configuration for
    `selectedDeck`. We will be using this as a placeholder for storing the record
    of the currently selected deck. This will allow us to easily get and set the value
    anywhere in our controller functions using `getSelectedDeck` and `setSelectedDeck`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分定义了我们的控制器，并列出了之前创建的`models`、`stores`和`views`值。我们还为`selectedDeck`添加了一个空配置。我们将使用这个作为存储当前所选牌组记录的占位符。这将允许我们在控制器的任何地方使用`getSelectedDeck`和`setSelectedDeck`轻松地获取和设置值。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Getters and setters**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取器和设置器**'
- en: Sencha Touch automatically creates `get` and `set` functions for configuration
    settings as well as references (see the following section). These functions take
    the form of `getWhateverYouCalledIt` and `setWhateverYouCalledIt`. It is important
    to remember that even if you lowercase the first letter of the `config` option
    or reference, the `get` and `set` functions will uppercase the first letter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch会自动为配置设置以及引用创建`get`和`set`函数（见下一节）。这些函数的形式为`getWhateverYouCalledIt`和`setWhateverYouCalledIt`。重要的是要记住，即使你将`config`选项或引用的第一个字母小写，`get`和`set`函数也会将第一个字母大写。
- en: The `refs` section allows us to create a reference to a component either by
    `id` (such as `#addCardSheet`) or a component query, such as (`#addCardSheet button[text="Save"]`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`refs`部分允许我们通过`id`（例如`#addCardSheet`）或组件查询（例如`#addCardSheet button[text="Save"]`）创建对组件的引用。'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding component query will look for a component with an `id` value of
    `addCardSheet` and then find the button within the component that has a `text`
    configuration of `"Save"`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个组件查询将寻找一个`id`值为`addCardSheet`的组件，然后在该组件中找到配置为`"Save"`的按钮。
- en: We can now reference anything in our `refs` list with `this.getReferenceName`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`this.getReferenceName`引用我们的`refs`列表中的任何内容。
- en: 'Immediately after the `refs` section we need to add a `control` section. This
    section uses our references and defines a set of listeners and functions for some
    of our components:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`refs`部分之后，我们需要添加一个`control`部分。此部分使用我们的引用，并为一些组件定义了一组监听器和函数：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each member of our `control` section has a reference, an event to listen for
    and a function to fire when the event occurs. We will create each of these functions
    later in the controller, but first we need to add our `init` function to set up
    Sencha.io and the other functions for authentication.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`control`部分的每个成员都有一个引用，一个要监听的事件，以及当事件发生时要触发的函数。我们将在控制器中稍后创建这些函数，但首先我们需要添加我们的`init`函数来设置Sencha.io和其他认证函数。
- en: 'When our application first starts, it needs to listen to the Sencha.io controller
    for authentication and messaging. We handle this in our `init` function (this
    goes right after the `config` section):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序首次启动时，它需要监听Sencha.io控制器进行认证和消息处理。我们在`init`函数中处理这个问题（紧接在`config`部分之后）：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code tells our controller three events from the Sencha.io controller:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉我们的控制器来自Sencha.io控制器的三个事件：
- en: '`authorized`: The user has successfully logged in'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorized`：用户已成功登录'
- en: '`logout`: The user has logged out of the system'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logout`：用户已从系统中登出'
- en: '`usermessage`: The user has received a message'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usermessage`：用户已收到消息'
- en: We have assigned a function to each one of these events and now we need to add
    them below our `init` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个这些事件分配了一个函数，现在我们需要在`init`函数下方添加它们。
- en: 'The first is our `onAuth` function, which syncs all of the user''s stores once
    they have logged in:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是我们的`onAuth`函数，它在用户登录后同步所有用户的存储：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `onLogout` function does the reverse and clears out any locally stored
    data:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`onLogout`函数执行相反的操作，并清除任何本地存储的数据：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our message function is a bit more interesting.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消息功能有点更有趣。
- en: Sencha.io allows an application to send messages to the user. These can be system
    messages (for example, the data in a store has updated) or even direct messages
    between users.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha.io允许应用程序向用户发送消息。这些可以是系统消息（例如，存储中的数据已更新）或甚至用户之间的直接消息。
- en: 'We have set up the following function to simply sync our stores when a message
    has been received (we will set up the function to send the message a bit later).
    This means if the user has the program open on one device and makes a change to
    the data, any other device that user has logged in will update and receive the
    change:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了一个函数，当收到消息时简单地同步我们的存储（我们将在稍后设置函数以发送消息）。这意味着如果用户在一个设备上打开了程序并更改了数据，任何其他登录了该用户的设备都将更新并接收更改：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have also added a number of console logs, which you can use to take a look
    at the messages being sent and the data that is potentially available to your
    application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一些控制台日志，你可以使用它们来查看发送的消息和可能可用于应用程序的数据。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to pull up your console when testing the application and examine the
    different message elements available to you. We will delve deeper into messaging
    in the final chapter, but you can also check out the *Overview Guide* available
    at [http://docs.sencha.io](http://docs.sencha.io) for more information about messaging.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试应用程序时，请确保打开控制台并检查可用的不同消息元素。我们将在最后一章深入探讨消息传递，但你也可以查看[http://docs.sencha.io](http://docs.sencha.io)上提供的*概述指南*以获取有关消息传递的更多信息。
- en: 'Next we need to add the functions that will save our new cards and decks. Both
    functions are tied to their respective save buttons. They need to grab the data
    from the sheet, add it to the store, and then sync the store:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加将保存我们新卡片和牌组的函数。这两个函数都与它们各自的保存按钮相关联。它们需要从表格中获取数据，将其添加到存储中，然后同步存储：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use our references here to grab the `addCardSheet` value using `this.getAddCardSheet()`
    and then we add the data as a new record to our card store.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用我们的引用来通过`this.getAddCardSheet()`获取`addCardSheet`值，然后将数据作为一条新记录添加到我们的卡片存储中。
- en: 'We then sync the store and *bind* a function called `syncCallback`. This is
    the function that will send out our message telling the application that data
    has been updated. The `syncCallback` function can go right below our `addCards`
    function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们同步存储并将一个名为`syncCallback`的函数绑定。这是将发送消息告知应用程序数据已更新的函数。`syncCallback`函数可以直接放在`addCards`函数下面：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The console logs have been left in to provide an inside view of the data being
    passed inside the function. The first part of the code, `this.getApplication().sio.getUser`,
    grabs the currently authenticated user and runs a function. The function checks
    to see if we got back a user and, if so, we send the user a message that simply
    says, `updated`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台日志被保留以提供函数内部传递数据的内部视角。代码的第一部分`this.getApplication().sio.getUser`获取当前认证的用户并运行一个函数。该函数检查是否收到了用户，如果是，我们向用户发送一条简单的消息，内容为`updated`。
- en: This message gets processed by our `onUserMessage` function, which causes our
    stores to update their data. You can change this message and use the console logs
    to see how the data is passed between the two functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息由我们的`onUserMessage`函数处理，这会导致我们的存储更新其数据。你可以更改这条消息并使用控制台日志来查看两个函数之间数据是如何传递的。
- en: 'Our `addDeck` function is a virtual duplicate of our `addCard` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`addDeck`函数是`addCard`函数的虚拟副本：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we only need to get one `textfield` value before we sync the store and
    do our `syncCallback` function. As before, we also clear the field values before
    hiding the sheet.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步存储并执行`syncCallback`函数之前，我们只需要获取一个`textfield`值。与之前一样，在隐藏表格之前，我们也会清除字段值。
- en: Next we will need to leave our controller for a bit and take a look at how our
    cards will be displayed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要暂时离开控制器，看看我们的卡片是如何显示的。
- en: Overriding the Carousel component
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖Carousel组件
- en: For a flash card application, `Carousel` seems like an ideal component to use
    because it allows the user to quickly flip from one card to the next. This would
    allow us to present a question and have the user swipe to get to the answer. The
    user can then swipe again to get to the next question and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个闪卡应用来说，`Carousel`组件似乎是一个理想的选择，因为它允许用户快速翻转到下一张卡片。这将使我们能够展示一个问题，并让用户滑动以获取答案。用户可以再次滑动以获取下一个问题，依此类推。
- en: This problem is that `Carousel` is actually a collection of panels and what
    we really need is something that will pull records from our data store the way
    a list view does. In order to do this we need to override the `Carousel` component
    and add some additional behavior.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于`Carousel`实际上是一个面板集合，而我们真正需要的是能够像列表视图那样从我们的数据存储中提取记录的东西。为了做到这一点，我们需要覆盖`Carousel`组件并添加一些额外的行为。
- en: 'We will start with our basic component that extends `Carousel`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从扩展`Carousel`的基本组件开始：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We start out setting our `store` configuration to `null` by default. We will
    set this when we declare the component in the `Main.js` file. In our `Main.js`
    file, locate the section that says:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初将`store`配置设置为默认的`null`。我们将在`Main.js`文件中声明组件时设置它。在我们的`Main.js`文件中，找到以下部分：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Replace that line with the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将该行替换为以下内容：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This sets the container to our new `flashcards` carousel and sets the `store`
    configuration to `CardStore`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将容器设置为我们的新`flashcards`轮播图，并将`store`配置设置为`CardStore`。
- en: If we had hardcoded the store for the component in our `CardView.js` file, it
    would be more difficult to re-use. When you override a component to extend functionality,
    it is always a good idea to write it with an eye towards re-using it somewhere
    else, later on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`CardView.js`文件中硬编码了组件的存储，那么它将更难重用。当你覆盖一个组件以扩展功能时，始终是一个好主意，编写时考虑到将来在其他地方重用的可能性。
- en: 'Back in `CardView.js`, we need to add a pair of strings to use as xTemplates
    for our question and answer cards. These go in the `config` section of our component:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`CardView.js`，我们需要添加一对字符串，用作问题和答案卡片的xTemplates。这些放在我们的组件的`config`部分：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These will control how to display the question and answer cards. Since we will
    be using these same templates multiple times, it''s a good idea to compile them
    in our `constructor` function. Otherwise, the xTemplate will be compiled and recompiled
    each time a new flashcard is created:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将控制如何显示问题和答案卡片。由于我们将多次使用这些相同的模板，所以在`constructor`函数中编译它们是个好主意。否则，xTemplate将在每次创建新的闪存卡时被编译和重新编译：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our `constructor` function also sets up the store we passed in `Main.js`. This
    one is a bit complex and requires a bit of explaining. Let''s start from the inside
    and work our way out:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`constructor`函数还设置了在`Main.js`中传递的存储。这个函数有点复杂，需要一些解释。让我们从内部开始，逐步向外解释：
- en: '`this.getStore()`: This grabs the string value we passed in `Main.js` (`store:
    ''CardStore''`)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.getStore()`: 这获取我们在`Main.js`中传递的字符串值（`store: ''CardStore''`）'
- en: '`Ext.getStore()`: This grabs the store with a `storeId` value of `''CardStore''`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ext.getStore()`: 这通过`storeId`值为`''CardStore''`获取存储'
- en: '`this.setStore()`: This applies the store to our `CardView` component, replacing
    the original string value'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.setStore()`: 这将存储应用于我们的`CardView`组件，替换原始字符串值'
- en: When we call `this.getStore()` on the next line to set `listeners`, it now returns
    an actual store instead of the string value from before.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行调用`this.getStore()`来设置`listeners`时，现在它返回一个实际的存储，而不是之前的字符串值。
- en: Then we assign a single function to the store events for `load`, `refresh`,
    and `addrecords`. We need to add that function next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为存储的`load`、`refresh`和`addrecords`事件分配一个单一的功能。我们需要在下一个步骤中添加该函数。
- en: 'We have broken this function into two parts. The first part is the `createCards`
    function, which gets our store and removes any existing panels from our custom
    carousel. It then checks to see if we have any cards in the store:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个函数分为两部分。第一部分是`createCards`函数，它获取我们的存储并从我们的自定义轮播图中删除任何现有的面板。然后它检查存储中是否有任何卡片：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If not, we give the user a message that there are no cards in the deck and they
    can click on **Add** to create new cards.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，我们给用户显示一条消息，说明牌组中没有卡片，并且他们可以点击**添加**来创建新的卡片。
- en: 'This is where the second part of our function comes into play. If we have records,
    we pass each one along to a second function called `createFlashCard`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的函数的第二部分发挥作用的地方。如果我们有记录，我们将每个记录传递给一个名为`createFlashCard`的第二个函数：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function is run on each record in `CardStore`. The first line creates our
    initial data array and sets values for the `total` (the number of cards in the
    deck), `number` (the sequential number of the current card), and `data` records
    from the store (which contains both our question and answer for the card).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在`CardStore`中的每一条记录上运行。第一行创建我们的初始数据数组，并设置`total`（牌组中的卡片数量）、`number`（当前卡片的顺序号）和从存储中获取的`data`记录（其中包含我们的问题和答案）的值。
- en: We then create a new `panel` component and set `html` to our compiled question
    template with the applied data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个新的`panel`组件，并将`html`设置为应用了数据的编译后问题模板。
- en: We do the same thing for our answer template, so we end up with two new panels
    for each record in the store; a question panel, followed by an answer panel.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对答案模板也做同样的事情，因此对于存储中的每条记录，我们最终会得到两个新的面板；一个问题面板，后面跟着一个答案面板。
- en: Since `CardStore` contains all of the records for every deck, we need to filter
    these down by deck before our `CardsView` carousel loads. We'll handle that back
    in the controller.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CardStore`包含每个牌组的所有记录，我们在`CardsView`轮播加载之前需要按牌组过滤这些记录。我们将在控制器中处理这个问题。
- en: Back in the controller
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到控制器
- en: 'Once the user selects a deck from our list, we need to filter `CardStore` so
    that only the cards for that deck are available. We do this in our `onDeckSelected`
    function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户从我们的列表中选择了一个牌组，我们需要过滤`CardStore`，以便只有该牌组的卡片可用。我们在`onDeckSelected`函数中这样做：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function is triggered by the select event in our `deckList` component and
    passes us the list and the record that was selected. Once we grab `CardStore`,
    we set the `selectedDeck` function to the record that was passed to us when the
    deck in the list was selected.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数由我们的`deckList`组件中的选择事件触发，并将列表和所选记录传递给我们。一旦我们获取到`CardStore`，我们将`selectedDeck`函数设置为在列表中的牌组被选中时传递给我们的记录。
- en: Next, we clear any existing filters on `CardStore` and sort it by its `id` value.
    We then filter the cards to only display the ones for the current deck. Finally,
    we enable `cardsPanel` and set it to be the active item.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们清除`CardStore`上的任何现有过滤器，并按其`id`值对其进行排序。然后我们过滤卡片，只显示当前牌组的卡片。最后，我们启用`cardsPanel`并将其设置为活动项。
- en: 'We also have a `control` function that fires when `cardPanel` is shown. This
    function sets the title bar of the card panel to the name of the deck:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`control`函数，当`cardPanel`显示时触发。此函数将卡片面板的标题栏设置为牌组的名称：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since our initial load of the card store presents them in order by `id`, it
    might be a good idea to let the user shuffle the cards. We do this with our final
    controller function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们最初加载的卡片存储按`id`顺序显示它们，可能让用户洗牌是个好主意。我们通过最终的控制器函数来实现这一点：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function grabs `CardStore` and sorts it using JavaScript's `Math.random`
    function to assign a random sort order to each card.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数获取`CardStore`并使用JavaScript的`Math.random`函数对其进行排序，为每张卡片分配一个随机的排序顺序。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a more complete understanding of how sorting works in JavaScript (and Sencha
    Touch), consult the excellent Mozilla Developer Network's JavaScript Reference
    for sorting at [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要更全面地了解JavaScript（以及Sencha Touch）中的排序工作原理，请参阅Mozilla开发者网络提供的出色的JavaScript排序参考，网址为[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort)。
- en: 'You should now be able to add decks and cards to the application. When you
    select a deck, the card stack will appear. You can advance from one card to the
    next by swiping from right to left as shown:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够向应用程序添加牌组和卡片。当你选择一个牌组时，卡片堆将出现。你可以通过从右向左滑动来从一张卡片切换到下一张，如下所示：
- en: '![Back in the controller](img/8901OS_05_09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![回到控制器](img/8901OS_05_09.jpg)'
- en: You can use the CSS files to style the answer and question to fit your own personal
    tastes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用CSS文件来设置答案和问题的样式，以适应你自己的个人品味。
- en: Remember, you will need to register with the application before you can start
    creating decks and cards. Once you are registered, you can log in from any Sencha
    Touch Compatible browser and access the same information across multiple devices.
    Fortunately, since we are using Sencha.io, all of this is taken care of automatically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在开始创建牌组和卡片之前，你需要注册应用程序。一旦你注册了，你就可以从任何Sencha Touch兼容的浏览器登录并跨多个设备访问相同的信息。幸运的是，由于我们使用Sencha.io，所有这些都会自动处理。
- en: '![Back in the controller](img/8901OS_05_10.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![回到控制器](img/8901OS_05_10.jpg)'
- en: Sencha.io automatically creates these login and registration forms for our application.
    If the user clicks the **register** button, they will be offered the opportunity
    to register and use your application. Sencha.io handles all of the forms, data
    storage, and interactions, which include password recovery without the need for
    any additional code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha.io自动为我们应用程序创建这些登录和注册表单。如果用户点击**注册**按钮，他们将被提供注册和使用您应用程序的机会。Sencha.io处理所有表单、数据存储和交互，包括密码恢复，无需任何额外的代码。
- en: Deploying the application
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的部署
- en: Sencha.io also offers you the option of deploying your application to the Sencha.io
    cloud service.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha.io 还提供了将您的应用程序部署到 Sencha.io 云服务的选项。
- en: From the Sencha.io dashboard, you can click on your application in the list
    on the right-hand side of the page. When the main page for the application appears,
    click on **New Version** and you will be able to upload a zipped file containing
    all of your code to the Sencha.io website.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Sencha.io 仪表板中，您可以在页面右侧的列表中点击您的应用程序。当应用程序的主页出现时，点击**新版本**，您将能够上传一个包含所有代码的压缩文件到
    Sencha.io 网站。
- en: When the upload completes, you will be presented with a public URL you can use
    to access the application. You can also specify if the release is for development
    or production.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上传完成后，您将看到一个可以用来访问应用程序的公共 URL。您还可以指定发布是针对开发还是生产。
- en: You can also choose to deploy your application to your own web server if you
    prefer.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以选择将应用程序部署到您自己的 Web 服务器。
- en: Homework
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: 'There are a few things that can be added to the application to make it more
    complete:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加一些内容到应用程序中使其更加完整：
- en: Add the ability to edit/delete cards and decks
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加编辑/删除卡片和牌组的功能
- en: Update the deck list template to show the number of cards in the deck
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新牌组列表模板以显示牌组中的卡片数量
- en: Provide a more detailed layout and CSS styling for the questions and answers
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为问题和答案提供更详细的布局和 CSS 样式
- en: Switch the login method in the Sencha dashboard to allow login with Facebook
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Sencha 仪表板中的登录方法切换为允许使用 Facebook 登录
- en: Use the messaging system to present an alert to the user when new cards or decks
    are available
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息系统在用户有新卡片或牌组可用时向用户显示警报
- en: The opportunities offered by Sencha.io are huge. With its integrated messaging
    system, you have the potential to communicate with a single user or every user
    of the application. This opens up possibilities such as publishing and sharing
    decks between users.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha.io 提供的机会是巨大的。凭借其集成的消息系统，您有可能与单个用户或应用程序的每个用户进行通信。这为用户之间发布和共享牌组等可能性打开了大门。
- en: For more information, take a look at the documentation available at [http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction](http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请查看[http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction](http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction)提供的文档。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter we used a simple Flash card application to explore some of
    the uses and possibilities of Sencha.io. We covered the following points:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了一个简单的闪卡应用程序来探索 Sencha.io 的一些用途和可能性。我们涵盖了以下内容：
- en: Building the basic application including the stores, models, and views
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基本应用程序，包括存储、模型和视图
- en: Getting started with Sencha.io, signing up, downloading, installing, and configuring
    the basic application to communicating with the Sencha.io service
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Sencha.io，注册、下载、安装和配置基本应用程序以与 Sencha.io 服务通信
- en: Creating a controller for the application and updating the stores to connect
    to the Sencha.io service
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序创建控制器并更新存储以连接到 Sencha.io 服务
- en: Overriding the carousel so that it can read from a data store
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖轮播图，使其能够从数据存储中读取
- en: Deploying the application to Sencha.io
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Sencha.io
- en: In the next chapter we will explore creating your own API for use with Sencha
    Touch.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨创建用于 Sencha Touch 的自定义 API。
