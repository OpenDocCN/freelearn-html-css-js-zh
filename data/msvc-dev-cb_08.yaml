- en: Scaling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Load testing microservices with Vegeta
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vegeta进行微服务负载测试
- en: Load testing microservices with Gatling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gatling进行微服务负载测试
- en: Building auto-scaling clusters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自动扩展集群
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A significant advantage of using microservices over a monolith architecture
    is that microservices can be separately scaled to meet the unique traffic demands
    they serve. A service that must do work for every single request will have very
    different scaling needs than a service that only needs to perform work for specific
    kinds of request.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务而不是单体架构的一个显著优势是，微服务可以单独扩展以满足它们所服务的独特流量需求。必须为每个请求执行工作的服务将具有与只需要为特定类型的请求执行工作的服务非常不同的扩展需求。
- en: Because microservices encapsulate ownership over a single-domain entity, they
    can be load tested independently. They can also be configured to scale automatically
    based on demand. In this chapter, we'll discuss load testing using two different
    load testing tools and set up auto-scaling groups in AWS that can scale on demand.
    Finally, we'll discuss strategies for capacity-planning.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务封装了对单个领域实体的所有权，它们可以独立进行负载测试。它们还可以根据需求自动配置扩展。在本章中，我们将讨论使用两种不同的负载测试工具进行负载测试，并在AWS中设置自动扩展组，以便按需扩展。最后，我们将讨论容量规划策略。
- en: Load testing microservices with Vegeta
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vegeta进行微服务负载测试
- en: Load testing is an important part of predicting how your service is going to
    behave over time. When we are performing load testing, we shouldn't just ask simple
    questions, such as "*How many requests per second is our system capable of serving?*"
    Instead, we should try to understand how our whole system performs under various
    load conditions. In order to answer this question, we need to understand the infrastructure
    that makes up our system and the dependencies that a particular service has.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试是预测您的服务随时间如何表现的重要部分。当我们进行负载测试时，我们不应该只问简单的问题，例如“*我们的系统每秒能处理多少请求？*”相反，我们应该试图了解我们的整个系统在各种负载条件下的表现。为了回答这个问题，我们需要了解构成我们系统的基础设施以及特定服务所依赖的依赖关系。
- en: For example, is the service behind a load-balancer? How about a CDN? What other
    caching mechanisms are used? All of these questions and more can be answered by
    our systems having good observability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，该服务是否位于负载均衡器后面？CDN呢？还使用了哪些其他缓存机制？所有这些问题以及更多都可以通过我们系统良好的可观察性得到解答。
- en: '**Vegeta** is an open source load testing utility designed to test HTTP services
    with a constant request rate. It''s a versatile tool that can be used as a command-line
    utility or a library. In this recipe, we''ll focus on using the command-line utility.
    Vegeta allows you to specify targets as URLs in a separate file—optionally with
    custom headers and request bodies—that can be used as an input to the command-line
    tool. The command-line tool can then attack the targets in the file, with various
    options to control the request rate and duration, as well as other variables.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vegeta**是一个开源的负载测试工具，旨在以恒定的请求速率测试HTTP服务。它是一个多功能的工具，可以用作命令行工具或库。在这个菜谱中，我们将专注于使用命令行工具。Vegeta允许你将目标指定为单独文件中的URL，可选地带有自定义头和请求体，这些可以作为命令行工具的输入。然后，命令行工具可以攻击文件中的目标，有各种选项来控制请求速率和持续时间，以及其他变量。'
- en: In this recipe, we'll be using Vegeta to test the message-service we've been
    working with in previous chapters. We'll test a simple request path that includes
    creating a new message and retrieving a list of messages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用Vegeta测试我们在前几章中一直在使用的消息服务。我们将测试一个简单的请求路径，包括创建新消息和检索消息列表。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s have a look at the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'We''ll modify our message-service and add a new endpoint that allows us to
    query all messages for a particular user. This introduces the notion of an inbox,
    so we''ll modify our `MessageRepository` class to add a new in-memory map of usernames
    to lists of messages, as shown in the following code. Note that in a production
    system, we''d choose a more durable and flexible store, but this will suffice
    for demonstration purposes:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改我们的消息服务并添加一个新的端点，允许我们查询特定用户的全部消息。这引入了收件箱的概念，因此我们将修改我们的`MessageRepository`类以添加一个新的内存映射，将用户名映射到消息列表，如下面的代码所示。请注意，在生产系统中，我们会选择一个更持久和灵活的存储方案，但这对演示目的已经足够了：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify `MessageController` to add the endpoint itself:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`MessageController`以添加端点本身：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''ll need a mock socialgraph service, so create the following Ruby script
    in a file called `socialgraph.rb` and run it:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个模拟的社交图服务，因此在一个名为`socialgraph.rb`的文件中创建以下Ruby脚本并运行它：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Install `vegeta`. If you''re on Mac OS X and have HomeBrew installed, you can
    just use the following:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`vegeta`。如果你在Mac OS X上并且已经安装了HomeBrew，你可以直接使用以下命令：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before we can launch an attach with `vegeta`, we''ll need to create a `targets`
    file. The first request we''ll make will create a message with the specified request
    body. The second request will get a list of messages by user ID. Create a file
    called `message-request-body.json`, as shown in the following code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够使用`vegeta`启动附件之前，我们需要创建一个`targets`文件。我们将发出的第一个请求将创建一个带有指定请求体的消息。第二个请求将通过用户ID获取消息列表。创建一个名为`message-request-body.json`的文件，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create another file called `targets.txt`, as shown in the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`targets.txt`的文件，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With both our message-service and our mock socialgraph service running, we''re
    ready to load test these two services using the following code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的消息服务和模拟社交图服务都已运行，我们现在可以使用以下代码来对这些两个服务进行负载测试：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Experiment with different duration values and request rates to see how the behavior
    of the system changes. If you increase the rate to 1,000, what happens? Depending
    on hardware and other factors, it's possible that the single-threaded Ruby mock
    service will be overwhelmed and trip the circuit breaker we added to the message-service.
    This should change certain details, such as the success rate, so it's an important
    observation to make. What would happen if you load tested the mock Ruby service
    separately?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的持续时间值和请求速率，看看系统行为如何变化。如果你将速率增加到1,000，会发生什么？根据硬件和其他因素，单线程的Ruby模拟服务可能会超负荷运行并触发我们添加到消息服务的熔断器。这可能会改变某些细节，例如成功率，因此这是一个重要的观察点。如果你单独对模拟Ruby服务进行负载测试，会发生什么？
- en: In this recipe, we load tested the message-service, which depends on the socialgraph
    service. Both services were running locally, which was necessary for demonstration
    purposes and gives us some insight into how the two systems behave. In a production
    system, it's vital to load test your services in production so that you include
    all of the infrastructure involved in serving requests (load balancers, caches,
    and so on). In a production system, you can also monitor dashboards and look for
    changes to how your system behaves under load conditions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们负载测试了依赖于社交图服务的消息服务。这两个服务都在本地运行，这对于演示目的来说是必要的，并让我们对这两个系统的行为有了一些了解。在生产系统中，在生产环境中对服务进行负载测试至关重要，以确保你包括了所有参与服务请求的基础设施（负载均衡器、缓存等）。在生产系统中，你还可以监控仪表板，寻找系统在负载条件下的行为变化。
- en: Load testing microservices with Gatling
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gatling对微服务进行负载测试
- en: Gatling is an open source load testing tool that allows users to script custom
    scenarios using a *Scala-based DSL*. Scenarios can go beyond simple straight path
    testing and involve multiple steps, even simulating user behavior, such as pauses
    and making decisions about how to proceed based on output in the test. Gatling
    can be used to automate the load testing of microservices or even browser-based
    web applications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Gatling是一个开源的负载测试工具，它允许用户使用基于*Scala的DSL*脚本来编写自定义场景。场景可以超越简单的直线路径测试，包括多个步骤，甚至可以模拟用户行为，如暂停并根据测试输出做出如何继续的决定。Gatling可以用来自动化微服务或基于浏览器的Web应用的负载测试。
- en: In the previous recipe, we used Vegeta to send a constant request rate to our
    message-service. Our request path created a new message and then retrieved all
    messages for a user. This method had the advantage of being able to test the response
    time of retrieving all messages for a user as the list of messages grew. Vegeta
    excels at this type of testing, but because it is fed attack targets from a static
    file, you cannot use Vegeta to build dynamic request paths based on the responses
    from previous requests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们使用Vegeta向我们的消息服务发送恒定的请求速率。我们的请求路径创建了一条新消息，然后检索了用户的全部消息。这种方法的优势在于能够测试随着消息列表的增长，检索用户所有消息的响应时间。Vegeta擅长此类测试，但由于它从静态文件中获取攻击目标，因此你不能使用Vegeta根据先前请求的响应构建动态请求路径。
- en: Because Gatling uses a DSL to script load testing scenarios, it's possible to
    make a request, capture some element of the response, and use that output to make
    decisions about future requests. In this recipe, we'll use Gatling to script a
    load testing scenario that involves creating a message and then retrieving that
    specific message by its ID. This is a very different kind of test than what we
    did in the previous recipe, so it's a good opportunity to demonstrate the differences
    between Vegeta and Gatling.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Gatling使用DSL来编写负载测试场景，因此可以发出请求，捕获响应的一些元素，并使用该输出来做出关于未来请求的决定。在本食谱中，我们将使用Gatling编写一个涉及创建消息然后通过其ID检索该特定消息的负载测试场景。这与之前食谱中做的测试非常不同，因此这是一个很好的机会来展示Vegeta和Gatling之间的差异。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s check the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下步骤：
- en: 'Download `gatling` for your platform. Gatling is distributed as a ZIP bundle
    and is available for download at [https://gatling.io/download/](https://gatling.io/download/).
    Unzip the bundle into the directory of your choice:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的平台下载`gatling`。Gatling以ZIP包的形式分发，可在[https://gatling.io/download/](https://gatling.io/download/)下载。将包解压到你的选择目录中：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Simulations for `gatling` are placed by default in the `user-files/simulations`
    directory. Create a new subdirectory called `messageservice` and a new file called
    `BasicSimulation.scala`. This is the file that contains the code that describes
    your scenario. In our scenario, we''ll use the Gatling DSL to script a POST request
    to the create message endpoint followed by a GET request to the message endpoint,
    as shown in the following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gatling`的模拟默认放置在`user-files/simulations`目录中。创建一个名为`messageservice`的新子目录和一个名为`BasicSimulation.scala`的新文件。这是包含描述你的场景的代码的文件。在我们的场景中，我们将使用Gatling
    DSL来编写一个POST请求到创建消息端点，然后是一个GET请求到消息端点，如下面的代码所示：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create the same mock Ruby service we used in the previous recipe and run it:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建与之前食谱中使用的相同的模拟Ruby服务并运行它：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the Ruby mock service as well as our message-service. From the Gatling
    directory, launch Gatling by running `bin/gatling.sh`. You''ll be prompted to
    select a simulation to run. Choose `messageservice.BasicSimulation`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时运行Ruby模拟服务和我们的消息服务。从Gatling目录中，通过运行`bin/gatling.sh`启动Gatling。你将被提示选择要运行的模拟。选择`messageservice.BasicSimulation`：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output will show some statistics about the results from the load test. Requests
    will be bucketed into under 800 ms, between 800 ms and 1,200 ms, and over 1,200
    ms. A link to an HTML file will be displayed. Open it in a browser to see charts
    and other useful visualizations about your load test.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将显示关于负载测试结果的某些统计数据。请求将被分类到小于800毫秒、800毫秒到1,200毫秒之间以及超过1,200毫秒的几个类别。将显示一个HTML文件的链接。在浏览器中打开它，以查看关于你的负载测试的图表和其他有用的可视化。
- en: As we've seen in this recipe, Gatling offers a lot of flexibility in running
    load tests. With some clever scripting using the DSL, it's possible to more closely
    simulate production traffic by parsing log files and generating requests, making
    dynamic decisions based on latency, responses, or other elements of requests.
    Both Gatling and Vegeta are great load testing tools that you can use to explore
    how your systems operate under various load conditions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本食谱中看到的，Gatling在运行负载测试方面提供了很多灵活性。通过使用DSL的一些巧妙脚本，可以更接近地模拟生产流量，通过解析日志文件和生成请求，根据延迟、响应或其他请求元素做出动态决策。Gatling和Vegeta都是优秀的负载测试工具，你可以使用它们来探索你的系统在各种负载条件下的运行情况。
- en: Building auto-scaling clusters
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自动扩展集群
- en: With the advent of virtualization and the move to cloud-based infrastructure,
    applications can exist on elastic infrastructure designed to grow and shrink based
    on anticipated or measured traffic patterns. If your application experiences peak
    periods, you shouldn't have to provision full capacity during non-peak periods,
    wasting compute resources and money. From virtualization to containers and container
    schedulers, it's more and more common to have dynamic infrastructure that changes
    to accommodate the needs of your system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随着虚拟化和向基于云的基础设施的迁移，应用程序可以存在于弹性基础设施上，该基础设施根据预期的或测量的流量模式进行扩展和收缩。如果你的应用程序经历高峰期，你不需要在非高峰期配置全部容量，从而浪费计算资源和金钱。从虚拟化到容器和容器调度器，动态基础设施越来越普遍，这种基础设施会根据系统的需求进行变化。
- en: Microservices are a natural fit for auto-scaling. Because we can scale separate
    parts of a system separately, it's easier to measure the scaling needs of a specific
    service and its dependencies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务非常适合自动扩展。因为我们可以分别扩展系统的不同部分，所以更容易衡量特定服务及其依赖项的扩展需求。
- en: There are many ways to create auto-scaling clusters. In the next chapter, we'll
    talk about container orchestration tools, but without skipping ahead, auto-scaling
    clusters can also be created in any cloud provider. In this recipe, we'll cover
    creating auto-scaling compute clusters using *Amazon Web Services*, particularly
    Amazon EC2 Auto Scaling. We'll create a cluster with multiple EC2 instances running
    our message-service behind an **Application Load Balancer** (**ALB**). We'll configure
    out cluster to automatically add instances based on CPU utilization.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自动扩展集群有许多方法。在下一章中，我们将讨论容器编排工具，但不会跳过，自动扩展集群也可以在任何云服务提供商中创建。在本菜谱中，我们将介绍使用 *Amazon
    Web Services* 创建自动扩展计算集群，特别是 Amazon EC2 自动扩展。我们将创建一个集群，其中包含多个运行在我们的消息服务背后的 EC2
    实例，并位于 **应用程序负载均衡器** (**ALB**) 后面。我们将配置我们的集群，以便根据 CPU 利用率自动添加实例。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s check the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下步骤：
- en: 'This recipe requires an AWS account. If you do not already have an AWS account,
    create one at [https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/) and
    create a set of access keys at [https://docs.aws.amazon.com/general/latest/gr/managing-aws-access-keys.html](https://docs.aws.amazon.com/general/latest/gr/managing-aws-access-keys.html).
    Install the `aws cli` utility. If you''re on OS X and have HomeBrew installed,
    this can be done with the following:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此菜谱需要 AWS 账户。如果您还没有 AWS 账户，请访问 [https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/) 创建一个账户，并在
    [https://docs.aws.amazon.com/general/latest/gr/managing-aws-access-keys.html](https://docs.aws.amazon.com/general/latest/gr/managing-aws-access-keys.html)
    创建一组访问密钥。安装 `aws cli` 工具。如果您在 OS X 上并且已安装 HomeBrew，可以使用以下命令完成此操作：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Configure the `aws` command-line utility, entering the access key you created:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `aws` 命令行工具，输入您创建的访问密钥：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a launch configuration. Launch configurations are templates used by
    auto-scaling groups when creating new instances. In this case, we''ve chosen an
    Amazon AMI and `t2.nano` as our EC2 instance type (see [https://aws.amazon.com/ec2/instance-types/](https://aws.amazon.com/ec2/instance-types/) for
    more details), as shown in the following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建启动配置。启动配置是自动扩展组在创建新实例时使用的模板。在这种情况下，我们选择了 Amazon AMI 和 `t2.nano` 作为我们的 EC2
    实例类型（有关更多详细信息，请参阅 [https://aws.amazon.com/ec2/instance-types/](https://aws.amazon.com/ec2/instance-types/)），如下面的代码所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the actual auto-scaling group. Auto-scaling groups have configurable
    maximum and minimum sizes that specify how much the auto-scaling group can shrink
    or grow based on demand. In this case, we''ll create an auto-scaling group with
    a minimum of `1` instance and a maximum of `5` instances, as shown in the following
    code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建实际的自动扩展组。自动扩展组具有可配置的最大和最小大小，这指定了自动扩展组可以根据需求缩小或扩大的程度。在这种情况下，我们将创建一个具有最小 `1`
    个实例和最大 `5` 个实例的自动扩展组，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We want the instances in our auto-scaling group to be accessible behind a load
    balancer, so we''ll create that now:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望我们的自动扩展组中的实例可以通过负载均衡器访问，因此我们现在将创建它：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order to automatically scale our auto-scaling group, we need to define a
    metric. Clusters can be scaled based on memory, CPU utilization, or request rate.
    In this case, we''re going to configure our scaling policy to use CPU utilization.
    If CPU utilization hits a 20% average, our auto-scaling group will create more
    instances. Create a file called `config.json`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了自动扩展我们的自动扩展组，我们需要定义一个指标。集群可以根据内存、CPU 利用率或请求速率进行扩展。在这种情况下，我们将配置我们的扩展策略以使用 CPU
    利用率。如果 CPU 利用率达到 20% 的平均值，我们的自动扩展组将创建更多实例。创建一个名为 `config.json` 的文件：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Attach the scaling policy to our auto-scaling group.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将扩展策略附加到我们的自动扩展组。
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our auto-scaling group is now configured to grow when CPU utilization exceeds
    a 20% average. Launch configurations can also include bootstrapping steps for
    installing and configuring your service—typically with some kind of configuration-management
    tool, such as **Chef** or **Puppet**—or it can be configured to pull a Docker
    image from a private Docker repository.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自扩展组现在配置为当CPU利用率超过20%的平均值时进行扩展。启动配置还可以包括安装和配置您的服务的引导步骤——通常使用某种配置管理工具，例如**Chef**或**Puppet**——或者它可以配置为从私有Docker仓库拉取Docker镜像。
