- en: Chapter 5. Modeling Data Structures for Your UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。为您的 UI 模型化数据结构
- en: Representing your system's data accurately is extremely important for every
    application. Being able to access and manipulate datasets in a logical and organized
    way is essential to creating a maintainable code base.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 准确表示您系统的数据对于每个应用程序都至关重要。能够以逻辑和组织的方式访问和操作数据集对于创建可维护的代码库是必不可少的。
- en: 'Ext JS has a comprehensive data package which makes this task very easy. It
    has a huge number of features, including:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 拥有一个全面的数据包，这使得这项任务变得非常简单。它具有大量功能，包括：
- en: Numerous data field types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数种数据字段类型
- en: Automatic value conversion
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动值转换
- en: Validation rules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证规则
- en: Associations, including one-to-many, one-to-one, and many-to-many
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联，包括一对一、一对多和多对多
- en: Abstracted reading and writing mechanisms, including AJAX, LocalStorage, and
    REST
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象的读写机制，包括 AJAX、LocalStorage 和 REST
- en: In this chapter, we will demonstrate how to create the data structures required
    for our business dashboard application, how to join these data models with associations,
    and how to read and write data from a backend.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示如何创建业务仪表板应用程序所需的数据结构，如何将这些数据模型通过关联连接起来，以及如何从后端读取和写入数据。
- en: 'The following diagram demonstrates the data entities and their relationships
    that we will be representing in our application:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了我们将代表的应用程序中的数据实体及其关系：
- en: '![Modeling Data Structures for Your UI](img/3717_05_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![为您的 UI 模型化数据结构](img/3717_05_01.jpg)'
- en: 'The main relationships are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 主要关系如下：
- en: A **Location** can contain one or more Products
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **位置** 可以包含一个或多个 **产品**
- en: A **Product** can be found in one or more Locations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **产品** 可以位于一个或多个 **位置**
- en: A **Product** can have multiple Sales
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **产品** 可以有多个 **销售**
- en: A **Sale** can involve one or more Products
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **销售** 可以涉及一个或多个 **产品**
- en: A **User** can have multiple Sales
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **用户** 可以有多个 **销售**
- en: A **User** can have multiple Messages
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **用户** 可以有多个 **消息**
- en: Defining models
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模型
- en: Data models are defined as regular Ext JS classes and should extend the `Ext.data.Model`
    class. Model classes are generally located in the app's model folder and can have
    any number of subnamespaces to allow for grouping of related models.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型定义为常规的 Ext JS 类，并应扩展 `Ext.data.Model` 类。模型类通常位于应用程序的模型文件夹中，并且可以有任意数量的子命名空间，以允许对相关模型进行分组。
- en: 'We will start by defining our Product model in a file named `Product.js` in
    the `model` folder:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在 `model` 文件夹中名为 `Product.js` 的文件中定义我们的产品模型：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To save on some key strokes, you can generate models in the command line using
    Sencha Cmd. Refer to [Chapter 4](ch04.html "Chapter 4. Architecting an Ext JS
    Application"), *Architecting an Ext JS Application*, for details on how to do
    this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省一些按键，您可以使用 Sencha Cmd 在命令行中生成模型。有关如何操作的详细信息，请参阅第 4 章，*构建 Ext JS 应用程序架构*，[第
    4 章](ch04.html "第 4 章。构建 Ext JS 应用程序架构")。
- en: Fields
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段
- en: The `fields` property in the product model defines the name and type of each
    piece of data attached to the model. Each object in the fields array is a configuration
    object for the `Ext.data.Field` class, which provides various options for how
    the field is interpreted and stored.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 产品模型中的 `fields` 属性定义了附加到模型每份数据的名称和类型。`fields` 数组中的每个对象都是 `Ext.data.Field` 类的配置对象，该类提供了各种选项，用于解释和存储字段的方式。
- en: 'The main configurations are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 主要配置如下：
- en: '`name`: This is the name of the field. It is used as the mapping key when reading
    data from a data source and retrieving it later.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是字段的名称。在从数据源读取数据并稍后检索时用作映射键。'
- en: '`type`: This is data type the assigned value should be parsed into. Possible
    values include `string`, `int`, `float`, `date`, `boolean`, and `auto`. If set
    to `auto`, no automatic conversion will take place.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这是分配的值应解析成的数据类型。可能的值包括 `string`、`int`、`float`、`date`、`boolean` 和 `auto`。如果设置为
    `auto`，则不会进行自动转换。'
- en: '`mapping`: This allows the field''s value to be pulled from a property that
    doesn''t match the field''s name.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapping`：这允许从与字段名称不匹配的属性中提取字段的值。'
- en: Field validation
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段验证
- en: Validation logic for data structures can be baked right into the definition,
    thus ensuring that the same logic isn't scattered all through your application.
    This can be added with the `validators` option which lets you define what validation
    rules should be applied to each field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构的验证逻辑可以直接嵌入到定义中，从而确保相同的逻辑不会散布在您的应用程序的各个部分。这可以通过 `validators` 选项来实现，该选项允许您定义应应用于每个字段的验证规则。
- en: We can add validation rules to our Product model to ensure each field's data
    is correct. We do this by defining an object with each key referring to a field's
    name. The value of this property can be a simple string referring to the name
    of a validation type, an object configuring the validation, or an array of objects
    so multiple rules can be applied.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向产品模型添加验证规则以确保每个字段的数据正确。我们通过定义一个对象来完成此操作，其中每个键都引用一个字段的名称。此属性的值可以是一个简单的字符串，指代验证类型的名称，一个配置验证的对象，或者一个对象数组，以便可以应用多个规则。
- en: 'The following snippet shows the configuration used to validate the fields in
    the following way:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了用于以这种方式验证字段的配置：
- en: The `Name` field is valid by being present (that is, not empty) and by being
    at least three characters long
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name` 字段通过存在（即不为空）并且至少有三个字符长是有效的'
- en: The `Quantity` field must be present
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Quantity` 字段必须存在'
- en: The `Price` field is greater than 0
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Price` 字段大于 0'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `type` config defines the rule we want to apply: out of the box the possibilities
    are `presence`, `length`, `format`, `inclusion`, `exclusion`, `range`, and `email`.
    Details of each can be found in the `Ext.data.validator.*` namespace.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 配置定义了我们想要应用的规则：默认情况下，可能的选项有 `presence`、`length`、`format`、`inclusion`、`exclusion`、`range`
    和 `email`。每个选项的详细信息可以在 `Ext.data.validator.*` 命名空间中找到。'
- en: Any other properties added are then used as options to customize that specific
    validator; for example, min defines the minimum length the `Name` must have.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的任何其他属性都用作选项来定制特定的验证器；例如，min 定义了 `Name` 必须具有的最小长度。
- en: We can apply the validation rules on a model instance (sometimes referred to
    as a *record*) using the `getValidation` method. This method will return an instance
    of the `Ext.data.Validation` class, which we can then query to determine which
    fields are invalid and retrieve error messages from.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `getValidation` 方法在模型实例（有时称为 *record*）上应用验证规则。此方法将返回 `Ext.data.Validation`
    类的实例，然后我们可以查询它以确定哪些字段无效并检索错误消息。
- en: Custom field types
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义字段类型
- en: Although Ext JS has five field types that cover the majority of scenarios required,
    the latest version introduces the ability to create your own custom field type
    that can have conversions, validations, and serializations built in. This feature
    can help reduce duplicated code across models that share the same field type.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Ext JS有五种字段类型可以覆盖大多数场景，但最新版本引入了创建自己的自定义字段类型的能力，该类型可以内置转换、验证和序列化。此功能可以帮助减少具有相同字段类型的模型之间的代码重复。
- en: In our Product model, we defined a validation rule for the `Price` field to
    ensure it has a positive value. We will have to apply this same rule to every
    model which has a field holding a monetary value. This would be a prime candidate
    for a custom field type that would allow this configuration to be shared.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的产品模型中，我们为 `Price` 字段定义了一个验证规则，以确保它具有正值。我们必须将此规则应用到每个包含货币值的字段的所有模型上。这将是一个理想的候选者，用于创建一个自定义字段类型，以便可以共享此配置。
- en: Custom field types are declared in the same way as other classes and should
    extend the `Ext.data.field.Field` class (or one of its subclasses if you want
    to build upon their existing functionality). We will extend the `Ext.data.field.Number`
    type, which provides us with the logic to ensure the value is numeric.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义字段类型声明的方式与其他类相同，应扩展 `Ext.data.field.Field` 类（或其子类之一，如果您想基于其现有功能进行构建）。我们将扩展
    `Ext.data.field.Number` 类型，它为我们提供了确保值是数字的逻辑。
- en: 'The validation we added to the Product model can then be added to this class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到产品模型的验证规则可以添加到此类中：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This custom field type can now be used by assigning any field a type of `money`.
    The Product model''s `Price` field will be rewritten as follows, and will automatically
    have the validation rules we specified applied to it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过将任何字段指定为类型 `money` 来使用此自定义字段类型。产品模型的 `Price` 字段将被重写如下，并且将自动应用我们指定的验证规则：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Custom data converters
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义数据转换器
- en: 'A field''s value can be automatically processed before being stored, in order
    to modify it in some way based on other field values, or to parse its value into
    a different type; for example, splitting a currency value received as "USD10.00"
    to its two component parts: currency and value.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 字段的值可以在存储之前自动处理，以便根据其他字段的值对其进行修改，或者将其值解析为不同的类型；例如，将接收到的货币值“USD10.00”拆分为其两个组成部分：货币和值。
- en: The first way to do this is to add a `convert` property to the field's configuration
    and assign it a function. This function will be passed the field's value and the
    record instance it is being stored in and should return the processed value which
    will then be stored.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的第一种方法是向字段的配置中添加一个`convert`属性，并为其分配一个函数。这个函数将接收字段的值以及它所存储的记录实例，并应该返回要存储的处理后的值。
- en: It should be noted that the record instance may be incomplete depending on the
    order in which the fields are populated, so it can't be guaranteed that other
    field values will be available.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，记录实例可能根据字段填充的顺序而不完整，因此不能保证其他字段值将可用。
- en: 'The following example shows how we might implement a `StockValue` field, which
    uses the current `Quantity` and `Price` values to calculate the total value of
    the stock:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何实现一个`StockValue`字段，该字段使用当前的`Quantity`和`Price`值来计算股票的总价值：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have also included the `depends` config, which creates a dependency between
    our `StockValue` field and the fields we use in its `convert` function. This means
    that when the `Price` or `Quantity` fields are updated, the `StockValue` field
    is recalculated ensuring everything is kept in sync.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了`depends`配置，它在我们使用的`StockValue`字段和其`convert`函数中的字段之间创建了一个依赖关系。这意味着当`Price`或`Quantity`字段更新时，`StockValue`字段会重新计算，确保一切保持同步。
- en: 'Another way of doing this, is to use the `calculate` option, which behaves
    in a very similar way, but is designed to be used for purely calculated fields
    rather than manipulating actual values. We could rewrite the `StockValue` field
    using `calculate`, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`calculate`选项，它的工作方式非常相似，但设计用于仅用于计算字段而不是操作实际值。我们可以使用`calculate`重写`StockValue`字段，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `calculate` function accepts one parameter containing the record's data
    object, which can be used to access the other fields. As with the `convert` function,
    it should return the value to be stored.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate`函数接受一个包含记录数据对象的参数，可以用来访问其他字段。与`convert`函数一样，它应该返回要存储的值。'
- en: By using `calculate`, the dependencies are automatically determined based on
    the function's contents. So, there is no need for an explicit `depends` configuration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`calculate`，会根据函数的内容自动确定依赖关系。因此，不需要显式的`depends`配置。
- en: Working with stores
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与存储一起工作
- en: Stores are a collection of model instances that allow these models to be manipulated
    (for example, sorted, filtered, searched, and so on). They also provide a platform
    for backend interaction. Many of Ext JS' components can be bound to data stores
    and take care of a lot of the plumbing required to react to changes in the data
    held within it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 存储是一组模型实例的集合，允许对这些模型进行操作（例如，排序、过滤、搜索等）。它们还提供了一个与后端交互的平台。许多Ext JS组件可以绑定到数据存储，并处理许多响应存储中数据变化的管道工作。
- en: In this section, we will discuss how to construct a simple store and how to
    perform simple manipulation of the data within it; how to create different views
    of a dataset using Chained stores; and finally, how hierarchical data can be stored
    using TreeStores.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何构建一个简单的存储以及如何对其进行简单的数据操作；如何使用链式存储创建数据集的不同视图；最后，如何使用TreeStores存储层次数据。
- en: Simple stores
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单存储
- en: 'To define a store, you must extend the `Ext.data.Store` class and configure
    it with a `model` class that it will hold a collection of. The following store
    definition shows a store containing a collection of user records:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个存储，你必须扩展`Ext.data.Store`类，并使用一个`model`类来配置它，该类将包含一个集合。以下存储定义显示了一个包含用户记录集合的存储：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now add our store to the `stores` config option in our `Application.js`
    file. This will result in the file being loaded and automatically instantiated,
    making it accessible using the `Ext.getStore` method. We can then populate it
    with some sample data using the `add` method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将我们的存储添加到`Application.js`文件中的`stores`配置选项。这将导致文件被加载并自动实例化，使其可以通过`Ext.getStore`方法访问。然后我们可以使用`add`方法添加一些示例数据：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have a store filled with data, we can start exploring the various
    methods to interrogate and manipulate the data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个填充了数据的存储，我们可以开始探索各种查询和操作数据的方法。
- en: Store stats
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储统计
- en: 'We often need to know how many records there are within a store, and this can
    be done easily with the `getCount` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要知道存储中记录的数量，这可以通过`getCount`方法轻松完成：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Retrieving a record
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索记录
- en: 'The simplest way to retrieve a record instance is to access it based on its
    (zero-based) index. To do this, we use the `getAt` method, which returns the `Ext.data.Model`
    subclass at that position (or null if none was found):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 获取记录实例的最简单方法是基于其（基于0的）索引访问它。为此，我们使用`getAt`方法，它返回该位置的`Ext.data.Model`子类（如果没有找到则返回null）：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finding specific records
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找特定记录
- en: 'In order to find a specific record based on a field''s value, we use the `findRecord`
    method which, in its simplest form, accepts a field name and value to match. This
    will return the first record that matches, or null if none was found:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据字段的值查找特定记录，我们使用`findRecord`方法，其最简单形式接受一个字段名称和要匹配的值。这将返回第一个匹配的记录，如果未找到则返回null：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By default, this will search all records and will look for the search value
    at the beginning of the record''s value. It will be case insensitive and will
    allow partial matches. These options can be changed by passing the following parameters
    to the `findRecord` method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将搜索所有记录，并将搜索值查找在记录值的开头。它将不区分大小写，并允许部分匹配。这些选项可以通过将以下参数传递给`findRecord`方法来更改：
- en: '**Field Name (String)**: The field to match against'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段名称（字符串）**：要匹配的字段'
- en: '**Search Value (String/Number/Date)**: The value to find'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索值（字符串/数字/日期）**：要查找的值'
- en: '**Start Index (Number)**: The index at which to start searching'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**起始索引（数字）**：开始搜索的索引'
- en: '**Any Match (Boolean)**: True to match the search value anywhere (not just
    at the beginning)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任意匹配（布尔值）**：如果匹配搜索值在任意位置（而不仅仅是开头）'
- en: '**Case Sensitive (Boolean)**: True to match the case'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区分大小写（布尔值）**：如果匹配大小写'
- en: '**Exact Match (Boolean)**: True to match the whole value'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确匹配（布尔值）**：如果匹配整个值'
- en: If you would prefer to retrieve the index of the record, rather than the actual
    record instance, you can use the `find` method, which will return the record's
    position, or -1 if not found.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望检索记录的索引而不是实际的记录实例，可以使用`find`方法，它将返回记录的位置，如果未找到则返回-1。
- en: Complex searches
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂搜索
- en: If your search criteria are more complex than a simple field match, you can
    use your own custom matching functions to introduce multiple criteria. For example,
    you may want to find a user by name and telephone number.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的搜索条件比简单的字段匹配更复杂，你可以使用自己的自定义匹配函数来引入多个标准。例如，你可能想通过名称和电话号码查找用户。
- en: 'You can do this using the `findBy` method, passing it a function that will
    have one parameter, a `record` instance, and it should return true if it is deemed
    a match or false if it isn''t. This function will be executed once for each record
    in the store or until it finds a match:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`findBy`方法做到这一点，传递一个函数，该函数将有一个参数，即`record`实例，如果被认为匹配则返回true，如果不匹配则返回false。此函数将为存储中的每个记录执行一次，直到找到匹配项：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Filtering a store
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 筛选商店
- en: Stores can be filtered at any time with similar basic or complex queries. Doing
    so, will result in the store exposing a subset of its original dataset. The filters
    can be removed at any time to restore the full dataset once again.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 商店可以在任何时候通过类似的基本或复杂查询进行筛选。这样做，将导致商店仅暴露其原始数据集的子集。可以在任何时候移除过滤器以再次恢复完整的数据集。
- en: 'We can filter a store by using the `addFilter` method, which accepts a single
    `Ext.util.Filter` instance or an array of `Ext.util.Filter` instances or configuration
    objects. These should specify the name of the field being filtered on and the
    value to compare against. The following example filters the store to only users
    named "Brian":'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`addFilter`方法通过配置筛选商店，它接受单个`Ext.util.Filter`实例或`Ext.util.Filter`实例数组或配置对象。这些应指定正在筛选的字段名称和要比较的值。以下示例筛选商店以仅包含名为“Brian”的用户：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In a way similar to the `findBy` method, we can also filter with a function
    that allows more complex queries to be constructed. The following example shows
    the store being filtered by name and e-mail:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`findBy`方法，我们还可以使用一个允许构建更复杂查询的函数进行筛选。以下示例显示了商店通过名称和电子邮件进行筛选：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'While a store is filtered, all query operations (`find`, `getAt`, and so on)
    are performed on the filtered dataset and won''t search any filtered items. To
    return the store to its unfiltered state, simply call the `clearFilter` method:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当商店被筛选时，所有查询操作（`find`、`getAt`等）都在筛选后的数据集上执行，而不会搜索任何筛选项。要使商店回到未筛选状态，只需调用`clearFilter`方法：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Configuration-based filtering
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于配置的筛选
- en: 'All the preceding examples show the store being filtered programmatically.
    It is also possible to define a default filter when the store is configured, and
    which will be applied to all new records being added to the store. This can be
    a full `Ext.util.Filter` configuration object with a simple property/value combination
    or a more complex `filterFn`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述示例都显示了存储程序化地进行过滤。当配置存储时，也可以定义一个默认过滤器，并将其应用于添加到存储中的所有新记录。这可以是一个完整的`Ext.util.Filter`配置对象，包含简单的属性/值组合或更复杂的`filterFn`：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Sorting a store
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对存储进行排序
- en: We can also change the sort order of a store's records by using the `sort` or
    `sortBy` methods. As with filtering and finding, these allow for simple sorting
    in one or more fields, or more complex sorting using a function. Note that if
    no sorting options are provided, the records will remain in the order they are
    added.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`sort`或`sortBy`方法来更改存储记录的排序顺序。与过滤和查找类似，这些方法允许在单个或多个字段中进行简单排序，或者使用函数进行更复杂的排序。请注意，如果没有提供排序选项，记录将保持添加时的顺序。
- en: 'A simple sort on `Name` can be seen as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对`名称`进行简单排序可以如下所示：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To perform more complex sorting, you can provide an object that will configure
    an instance of the `Ext.util.Sorter` class. This example sorts by the reverse
    of each user''s name (for example, nhoJ, haraS):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行更复杂的排序，你可以提供一个对象来配置`Ext.util.Sorter`类的实例。以下示例通过每个用户的姓名的逆序（例如，nhoJ，haraS）进行排序：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Configuration-based sorting
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于配置的排序
- en: 'Once again, we can define a default sorter on a store that will be reapplied
    after each new record is added. This should be an `Ext.util.Sorter` configuration
    object:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们可以在添加每条新记录后重新应用默认排序器。这应该是一个`Ext.util.Sorter`配置对象：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Grouping
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组
- en: 'A store''s records can also be grouped by specific fields or combination of
    fields, which can be very useful to display data in grouped grids. We use the
    `group` method as follows, passing in the `Role` field, as the field to group
    on and `ASC` to determine the sort direction of the groups:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的记录也可以通过特定的字段或字段的组合进行分组，这在以分组网格显示数据时非常有用。我们使用`group`方法如下，传入`Role`字段作为分组字段，以及`ASC`来确定组的排序方向：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By calling this method, the store remains unchanged. This means all its records
    can be accessed as before, but it now gives us access to an `Ext.util.GroupCollection`
    instance, which is a collection of `Ext.util.Group` instances that holds a set
    of grouped records in each instance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用此方法，存储保持不变。这意味着我们可以像以前一样访问所有记录，但现在它还提供了对`Ext.util.GroupCollection`实例的访问，这是一个包含每个实例中一组分组记录的`Ext.util.Group`实例集合。
- en: 'We can interrogate the grouped data using the `getGroups` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`getGroups`方法来查询分组数据：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition to accepting these parameters, we can also pass in an `Ext.util.Grouper`
    config object to define a more complex grouping setup. In the following example,
    we group by each user''s email address domain (notice that we use the `clearGrouping`
    method to reset any existing groupings already in place):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接受这些参数外，我们还可以传递一个`Ext.util.Grouper`配置对象来定义更复杂的分组设置。在以下示例中，我们根据每个用户的电子邮件地址域进行分组（注意，我们使用`clearGrouping`方法来重置任何现有的分组）：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Configuration-based grouping
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于配置的分组
- en: 'Grouping can also be done in the store''s definition by using the `groupField`
    and `groupDirection` options together, or the `grouper` option on its own. The
    following snippets show the store grouped in `Role` using each combination:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 分组也可以通过在存储定义中使用`groupField`和`groupDirection`选项一起，或者单独使用`grouper`选项来完成。以下代码片段显示了使用每种组合在`Role`上对存储进行分组：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And, here is the another one:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有另一个示例：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Chained stores
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连锁存储
- en: Chained stores are a new addition to Ext JS 5 and allow us to create different
    views of the same underlying data store without it affecting the base data or
    other chained stores.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 连锁存储是Ext JS 5的新增功能，允许我们创建对同一底层数据存储的不同视图，而不会影响基础数据或其他连锁存储。
- en: Imagine that we want to display the data within our `usersStore` in separate
    grids for each role. We would want one grid attached to the `usersStore` with
    a filter of *Role=Administrator*, the next grid with *Role=Supplier*, and so on.
    Unfortunately, before Ext JS 5, this was not possible to do with just one store
    and so, we would have to create multiple stores with multiple copies of the same
    data and manage them all separately. Chained stores take this problem away and
    allow us to attach to an underlying base data store and apply any filters and
    sorters to the view of the data, without them affecting the base store or any
    other linked chained stores.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在`usersStore`中为每个角色显示数据，我们希望一个网格连接到`usersStore`并带有过滤器*Role=Administrator*，下一个网格带有*Role=Supplier*，依此类推。不幸的是，在Ext
    JS 5之前，无法仅使用一个存储来完成此操作，因此，我们必须创建多个存储，包含相同数据的多个副本，并分别管理它们。链式存储解决了这个问题，并允许我们附加到基本数据存储，并应用任何过滤器或排序器到数据的视图中，而不会影响基本存储或任何其他相关联的链式存储。
- en: 'The following diagram explains this concept:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图解解释了这个概念：
- en: '![Chained stores](img/3717_05_02.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![链式存储](img/3717_05_02.jpg)'
- en: 'Key things to remember about chained stores are:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 关于链式存储的关键事项包括：
- en: The record instances are shared between all chained stores and the base store
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录实例在所有链式存储和基本存储之间共享
- en: Any updates made to any of the records will be propagated through to all linked
    stores
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对任何记录所做的任何更新都将传播到所有相关联的存储。
- en: Going back to our roles example, we can now solve the problem by defining three
    chained stores that can be bound to separate grids or data views.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的角色示例，我们现在可以通过定义三个链式存储来解决此问题，这些存储可以绑定到单独的网格或数据视图中。
- en: We link them to the base data store using the `source` configuration option,
    which can accept a store instance or a store ID. We can then add any sorters or
    filters to the chained store, as we would to a regular store.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`source`配置选项将它们链接到基本数据存储，该选项可以接受存储实例或存储ID。然后我们可以向链式存储添加任何排序器或过滤器，就像对常规存储所做的那样。
- en: 'We create these in the folder `store/users/` to keep things organized:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`store/users/`文件夹中创建这些存储，以保持事物有序：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then add the new stores to the `stores` config within `Application.js` and
    create an instance of each and see the record counts in each:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`Application.js`中的`stores`配置中添加新的存储，并为每个创建一个实例，查看每个实例的记录数：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: TreeStores
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TreeStores
- en: The `Ext.data.TreeStore` class is a specialist store, extending from the regular
    `Ext.data.Store` class, which manages hierarchical data. This type of store must
    be used to bind to Tree Panels and other components, where data is required to
    have a hierarchical structure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.data.TreeStore`类是一个专业存储，它扩展自常规的`Ext.data.Store`类，用于管理层次化数据。此类存储必须用于绑定到树面板和其他组件，其中数据需要具有层次结构。'
- en: TreeStores are created in the same way as regular stores except for one main
    difference. The collection of the model that a TreeStore manages must extend from
    the `Ext.data.TreeModel` class, rather than the usual `Ext.data.Model`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TreeStores的创建方式与常规存储相同，只有一个主要区别。TreeStore管理的模型集合必须扩展自`Ext.data.TreeModel`类，而不是通常的`Ext.data.Model`。
- en: Ext.data.TreeModels
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ext.data.TreeModels
- en: The reason that a TreeStore's model must extend the `Ext.data.TreeModel` class
    is that each model instance must be decorated with additional properties and methods
    to allow the models' hierarchy to be managed correctly, and to allow the tree
    components to display them correctly. These extra properties and methods come
    from the `Ext.data.NodeInterface` class, whose members are all applied to each
    model instance in the TreeStore.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: TreeStore的模型必须扩展`Ext.data.TreeModel`类的原因是每个模型实例都必须添加额外的属性和方法，以便正确管理模型的层次结构，并允许树组件正确显示它们。这些额外的属性和方法来自`Ext.data.NodeInterface`类，其成员都应用于TreeStore中的每个模型实例。
- en: 'We will create a simple tree example by first defining the model that will
    be stored. Our data will represent our application''s navigation structure and
    will form the basis of our menu:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过首先定义将要存储的模型来创建一个简单的树示例。我们的数据将代表我们应用程序的导航结构，并形成我们菜单的基础：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you require this class within your `Application.js` file, create an instance
    of this model and inspect its contents. You will see that the model now has over
    20 additional data fields. These fields are all used to describe each node for
    various purposes, for example, tracking its location, its state, and its appearance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在你的 `Application.js` 文件中使用这个类，创建这个模型的实例并检查其内容。你会发现模型现在有超过 20 个额外的数据字段。这些字段都用于描述每个节点以实现各种目的，例如跟踪其位置、状态和外观。
- en: By default, these fields have their `persist` configs set to `false`, so they
    won't be included in any save operations initiated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些字段的 `persist` 配置设置为 `false`，因此它们不会包含在任何由它们发起的保存操作中。
- en: '![Ext.data.TreeModels](img/3717_05_03.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Ext.data.TreeModels](img/3717_05_03.jpg)'
- en: 'If you look further, you will also see numerous extra methods added to the
    model. These methods can be used to manage the node and its children, traverse
    the tree structure, and interrogate its position in the hierarchy. Some of the
    more useful methods are detailed here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进一步查看，你还会看到添加到模型中的许多额外方法。这些方法可以用来管理节点及其子节点，遍历树结构，并查询其在层次结构中的位置。其中一些更有用的方法在此处详细说明：
- en: '`appendChild`: This adds the specified node(s) as the last child of the current
    node'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendChild`: 这会将指定的节点（或节点集合）添加为当前节点的最后一个子节点'
- en: '`insertChild`: This inserts the new node at the specified position'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertChild`: 这将在指定位置插入新的节点'
- en: '`removeChild`: This removes the specified node from the child collection'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeChild`: 这将从子节点集合中移除指定的节点'
- en: '`eachChild`: This executes a function on each of the child nodes'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eachChild`: 这将对每个子节点执行一个函数'
- en: '`findChild`: This finds the first child that matches the given property/value
    given'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findChild`: 这将找到第一个匹配给定属性/值的子节点'
- en: '`isLeaf`: This determines if the current node is a leaf without any further
    children'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLeaf`: 这将确定当前节点是否为没有子节点的叶子节点'
- en: Creating a TreeStore
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 TreeStore
- en: 'We will create a simple TreeStore called `BizDash.store.Navigation`, which
    will contain a collection of `BizDash.model.NavigationItem` model instances. This
    store extends the base `Ext.data.TreeStore` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的 TreeStore，名为 `BizDash.store.Navigation`，它将包含 `BizDash.model.NavigationItem`
    模型实例的集合。此存储库扩展了基类 `Ext.data.TreeStore`：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We include this store in the `Application.js` file's `stores` array, where it
    will be automatically loaded and instantiated, and will be accessible via a call
    to `Ext.getStore('Navigation')`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此存储库包含在 `Application.js` 文件中的 `stores` 数组中，它将自动加载和实例化，并且可以通过调用 `Ext.getStore('Navigation')`
    来访问。
- en: Populating a TreeStore
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充 TreeStore
- en: TreeStores must always have a *root node*, which is the root parent of all child
    nodes within the store. It is common for this node to always be hidden and never
    actually seen in tree views. To populate our TreeStore programmatically (that
    is, not from an external data source—we'll talk about that in the next section),
    we can either add the full hierarchy using the `setRoot` method, or add child
    nodes individually using the `appendChild` or `insertChild` methods.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: TreeStores 必须始终有一个 *根节点*，它是存储中所有子节点的根父节点。这个节点通常总是隐藏的，实际上在树视图中从未真正显示。为了以编程方式（即不是从外部数据源——我们将在下一节中讨论这一点）填充我们的
    TreeStore，我们可以使用 `setRoot` 方法添加完整的层次结构，或者使用 `appendChild` 或 `insertChild` 方法单独添加子节点。
- en: 'We will start by using the `setRoot` method, which builds a hierarchy of `NavigationItem`
    instances expanding outward from the root:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 `setRoot` 方法，该方法从根节点向外构建 `NavigationItem` 实例的层次结构：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will produce a structure, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结构：
- en: '![Populating a TreeStore](img/3717_05_04.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![填充 TreeStore](img/3717_05_04.jpg)'
- en: Note that our own fields (`Label` and `Route`) are combined with some of the
    `Ext.data.NodeInterface` fields (children and leaf); we do this to indicate the
    parent-child relationship between the nodes, and to indicate which nodes do not
    have any children, respectively.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们自己的字段（`Label` 和 `Route`）与一些 `Ext.data.NodeInterface` 字段（子节点和叶子节点）结合使用；我们这样做是为了表示节点之间的父子关系，以及表示哪些节点没有子节点。
- en: 'Once a root node exists, we can also start adding nodes using the `appendChild`
    method, as shown in the following code snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存在根节点，我们也可以开始使用 `appendChild` 方法添加节点，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Getting data into your application
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据放入你的应用程序中
- en: So far, we have only dealt with hard-coded data and not with real-world examples
    of loading and saving data from/to external sources, whether they are REST endpoints,
    local databases, or third party APIs. Ext JS supports a number of different ways
    of assisting with data loading and persistence, including AJAX and LocalStorage.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了硬编码的数据，而没有处理从外部源加载数据和保存数据的真实世界示例，无论是REST端点、本地数据库还是第三方API。Ext JS支持多种不同的方式来帮助加载数据和持久化，包括AJAX和LocalStorage。
- en: Ext.Ajax
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ext.Ajax
- en: Although only indirectly related to stores, we are first going to discuss AJAX
    requests in a more general sense and how we can perform them to make calls to
    a server backend.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这与存储间接相关，但我们首先将更一般地讨论AJAX请求以及我们如何执行它们以调用服务器后端。
- en: '`Ext.Ajax` is a singleton instance of the `Ext.data.Connection` class, which
    provides us with a very simple interface for making AJAX calls to a server and
    handling the response. We will primarily focus on the `request` method, which
    initiates this call and allows us to specify how it should be made.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.Ajax`是`Ext.data.Connection`类的单例实例，它为我们提供了一个非常简单的接口，用于向服务器发出AJAX调用并处理响应。我们将主要关注`request`方法，它启动此调用并允许我们指定如何进行调用。'
- en: Simple AJAX calls
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单AJAX调用
- en: 'We will start by demonstrating how to make a simple AJAX request to a static
    JSON file. We simply pass in a configuration object to the request method, telling
    the framework where to make the AJAX request to, in this case specifying the `url`
    property:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先演示如何向一个静态JSON文件发出简单的AJAX请求。我们只需向请求方法传递一个配置对象，告诉框架在哪里发出AJAX请求，在这种情况下指定`url`属性：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we run this in the console of the Ext JS app, we should see the request being
    made in the **Network** tab. At the moment, we are ignoring the response given
    to us, so now we will include a callback function to process the received data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Ext JS应用的控制台中运行此代码，我们应该在**网络**选项卡中看到请求正在发出。目前，我们正在忽略给我们提供的响应，所以现在我们将包括一个回调函数来处理接收到的数据。
- en: 'As we''re sure you know, AJAX calls are asynchronous, meaning the rest of the
    code will carry on while the request is made and will not wait for it to complete.
    This means we must handle the response in a callback function that will get executed
    when the response has been received. We do this by specifying the `success` property,
    whose function will be given two parameters: a response object and an options
    object.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，AJAX调用是异步的，这意味着在请求进行时，其余的代码将继续执行，而不会等待它完成。这意味着我们必须在回调函数中处理响应，该函数将在收到响应时执行。我们通过指定`success`属性来实现这一点，该属性的函数将接收两个参数：一个响应对象和一个选项对象。
- en: 'In our success handler, we will decode the JSON string received and log the
    output to the console:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的成功处理程序中，我们将解码收到的JSON字符串并将输出记录到控制台：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Handling errors
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'Obviously we can''t just rely on the fairytale case where all our AJAX requests
    complete successfully, so we must include some alternative should our request
    fail (that is, return a non-200 response code). We can do this by specifying a
    `failure` config and defining a function that will be executed should the request
    fail. The following example console logs the response status code when an error
    occurs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不能仅仅依赖于所有AJAX请求都成功完成的童话案例，所以我们必须包括一些替代方案，以防请求失败（即返回非200响应代码）。我们可以通过指定`failure`配置并定义一个在请求失败时将执行的函数来实现这一点。以下示例在发生错误时控制台记录响应状态代码：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can try this out by modifying the `url` property to a non-existent one to
    force a 404 error.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过修改`url`属性为一个不存在的地址来尝试此操作，以强制产生404错误。
- en: Other useful configurations
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他有用的配置
- en: 'You can pass a lot of configuration options to the `request` method. We run
    down a few of these as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向`request`方法传递很多配置选项。以下是一些这些选项的简要说明：
- en: '`params`: This is an object whose key/value pairs will be sent along with the
    request'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`: 这是一个对象，其键/值对将随请求一起发送'
- en: '`method`: This is the method by which the request is sent (defaults to `GET`
    when no `params` are present, or `POST` if they are)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`: 这是发送请求的方法（如果没有`params`，默认为`GET`，如果有则为`POST`）'
- en: '`callback`: The function defined here will be called following the request,
    regardless of the success or failure'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`: 在请求之后，无论成功与否，都会调用这里定义的函数'
- en: '`timeout`: This defines the timeout length, in seconds, for the request'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`: 这定义了请求的超时时间，以秒为单位'
- en: '`headers`: This defines the headers that are sent with the request'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`: 这定义了随请求一起发送的头部信息'
- en: Proxies
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: Now that we have discussed performing simple AJAX requests, which could quite
    happily be used to populate stores, we will move on to explain proxies, which
    provide us with a simple mechanism for our stores to communicate with data sources.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了执行简单的AJAX请求，这些请求可以愉快地用来填充存储，我们将继续解释代理，它为我们提供了简单机制，使我们的存储能够与数据源通信。
- en: A store or model can be configured with a proxy, which provides an abstracted
    layer above the specifics of each possible data source (be it an external server
    or LocalStorage). This abstraction allows us to provide a simple configuration
    and have the store take care of performing the intricacies of communicating with
    the source.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 存储或模型可以通过代理进行配置，该代理提供了一层抽象，覆盖了每个可能的数据源的具体细节（无论是外部服务器还是LocalStorage）。这种抽象允许我们提供简单的配置，并让存储负责处理与数据源通信的复杂性。
- en: 'Proxies are linked to two other class types: `Reader` and `Writer`. The `Reader`
    class is responsible for interpreting the received data and parsing it correctly,
    so it can be turned into Model instances. The `Writer` class on the other hand,
    looks after collecting the data to be saved.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 代理与两种其他类类型相关联：`Reader`和`Writer`。`Reader`类负责解释接收到的数据并正确解析它，以便它可以转换为模型实例。另一方面，`Writer`类负责收集要保存的数据。
- en: 'The following diagram shows how these classes are linked:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了这些类是如何相互关联的：
- en: '![Proxies](img/3717_05_05.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![代理](img/3717_05_05.jpg)'
- en: AJAX proxies
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AJAX代理
- en: 'The most common type of proxy is an AJAX proxy (`Ext.data.proxy.Ajax`), which
    allows us to load and save data to server endpoints via an AJAX call. We will
    add an AJAX proxy to our users store to load the data from a simple JSON file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的代理类型是AJAX代理（`Ext.data.proxy.Ajax`），它允许我们通过AJAX调用将数据加载和保存到服务器端点。我们将向用户存储添加一个AJAX代理来从简单的JSON文件加载数据：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's break down this code. We start by adding a `proxy` config option with
    a `config` object. We specify the type of `proxy` we want (we'll talk about other
    types shortly)—in this case an AJAX proxy which equates to the `Ext.data.proxy.Ajax`
    class. We next specify the `url` to load the data from. Finally, we tell the proxy
    how to interpret the results by giving it a `reader` configuration. The type tells
    it we're going to be receiving JSON data and so we want to use the `Ext.data.reader.Json`
    class. The `rootProperty` tells the reader which property of the received JSON
    object to look in for the data records.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码。我们首先添加一个`proxy`配置选项和一个`config`对象。我们指定我们想要的`proxy`类型（我们很快会讨论其他类型）——在这种情况下是一个AJAX代理，相当于`Ext.data.proxy.Ajax`类。接下来，我们指定从哪里加载数据的`url`。最后，我们通过给代理一个`reader`配置来告诉代理如何解释结果。类型告诉它我们将接收JSON数据，因此我们想使用`Ext.data.reader.Json`类。`rootProperty`告诉读取器在接收到的JSON对象中查找数据记录的哪个属性。
- en: 'This setup will load data from the `users.json` file, which contains the following
    data:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将从包含以下数据的`users.json`文件加载数据：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now call the load method of the users store and it will make an AJAX
    request to the `users.json` file and populate itself with four records. The following
    code will load the store and log the loaded records once it has completed:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将用户的加载方法称为存储，并且它将向`users.json`文件发起一个AJAX请求，并使用四个记录填充自身。以下代码将在完成加载后加载存储并记录加载的记录：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: LocalStorage proxies
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LocalStorage代理
- en: 'Another type of proxy is the `localstorage` proxy, which allows us to load
    and save data to the LocalStorage within the browser. It is extremely simple to
    configure a store to communicate with the LocalStorage, and it follows the same
    pattern as the AJAX proxy, as seen here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的代理是`localstorage`代理，它允许我们在浏览器中加载和保存LocalStorage中的数据。配置存储与LocalStorage通信非常简单，并且它遵循与AJAX代理相同的模式，如下所示：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Again, we specify the proxy type, which in this case, will use the `Ext.data.proxy.LocalStorage`
    class. We also specify an `id` which will be used to identify items that belong
    to this store within the LocalStorage. This `id` must be unique across all proxies.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们指定了代理类型，在这种情况下，将使用`Ext.data.proxy.LocalStorage`类。我们还指定了一个`id`，它将用于识别LocalStorage中属于此存储的项目。这个`id`必须在所有代理中是唯一的。
- en: 'We will first demonstrate saving records, so we have some data to load in LocalStorage.
    We can save the store''s records by calling the `sync` method after adding some
    records:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先演示保存记录，以便在LocalStorage中有一些数据可以加载。我们可以在添加一些记录后通过调用`sync`方法来保存存储的记录：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you open up the **Resources** tab of Developer Tools and inspect the LocalStorage
    area, you will see the records with keys based on the `id` we provided.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开开发者工具的**资源**选项卡并检查LocalStorage区域，你会看到基于我们提供的`id`的键的记录。
- en: 'There are three types of items stored:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的项有三种类型：
- en: '`<id>-counter`, which holds the number of records stored'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<id>-counter`，包含存储记录的数量'
- en: '`<id>`, which contains a comma-separated list of the stored records'' IDs'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<id>`，包含存储记录ID的逗号分隔列表'
- en: Each record's JSON encoded data stored with a key in the format of `<id>-<Record
    ID>`
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条记录的JSON编码数据都存储在一个键中，其格式为`<id>-<Record ID>`
- en: '![LocalStorage proxies](img/3717_05_14.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![LocalStorage代理](img/3717_05_14.jpg)'
- en: Now that we have records saved in LocalStorage, we can call the store's `load`
    method, in the same way as we did with the AJAX proxy, to retrieve these saved
    records and repopulate the store.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将记录保存在LocalStorage中，我们可以调用存储的`load`方法，就像我们使用AJAX代理做的那样，以检索这些已保存的记录并重新填充存储。
- en: REST proxies
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST代理
- en: 'Many APIs are RESTful and so Ext JS has a proxy to make integration with them
    extremely easy. By defining a REST proxy, our CRUD requests will be executed to
    the endpoint with the correct method type. We can update our users store to use
    a REST proxy (the `Ext.data.writer.Rest` class), by changing the type to `rest`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 许多API都是RESTful的，因此Ext JS提供了一个代理，使得与它们的集成变得极其简单。通过定义REST代理，我们的CRUD请求将执行到具有正确方法类型的端点。我们可以通过将类型更改为`rest`来更新我们的用户存储以使用REST代理（`Ext.data.writer.Rest`类）：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have our store, by using a REST proxy, we can update one of the
    records and sync the store and see a `GET` request made to retrieve the records
    and a `PUT` request being made to update the data:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的存储，通过使用REST代理，我们可以更新记录之一并同步存储，看到执行检索记录的`GET`请求和执行更新数据的`PUT`请求：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is the screenshot of it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的截图：
- en: '![REST proxies](img/3717_05_15.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![REST代理](img/3717_05_15.jpg)'
- en: Data associations
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据关联
- en: Our application's data models will always have associations between them, which
    must be represented in our client-side applications, so that they can be manipulated
    easily and consistently. Ext JS offers the ability to model one-to-one, one-to-many,
    and many-to-many relationships between Model types.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的数据模型之间始终存在关联，这些关联必须在我们的客户端应用程序中表示，以便它们可以轻松且一致地进行操作。Ext JS提供了在模型类型之间建模一对一、一对多和多对多关系的功能。
- en: One-to-many
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多
- en: One-to-many relationships exist when a single entity owns multiple entities
    of a different type. For example, an author *has many* books or a recipe *has
    many* ingredients. In our example project, we will model the association between
    users and sales—a user can have many sales and each sale only has one user.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个实体拥有多个不同类型的实体时，存在一对一关系。例如，一个作者*拥有许多*书籍或一个食谱*拥有许多*成分。在我们的示例项目中，我们将模拟用户和销售之间的关联——一个用户可以有多个销售，而每个销售只有一个用户。
- en: '![One-to-many](img/3717_05_11.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![一对一](img/3717_05_11.jpg)'
- en: Configuring a proxy and data source
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置代理和数据源
- en: 'We will start by defining a proxy and simple static data source to connect
    our models to so that they can be populated. We do this with the following code
    pointing to two simple JSON files:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个代理和简单的静态数据源，以便将我们的模型连接起来，这样它们就可以被填充。我们使用以下代码指向两个简单的JSON文件来完成此操作：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Defining the association
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义关联
- en: 'Now that we have our infrastructure in place to allow data to be loaded into
    each model, we can define the relationship between these two entities. There are
    two ways this can be done: `hasMany` and `reference`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了基础设施，允许数据加载到每个模型中，我们可以定义这两个实体之间的关系。这可以通过两种方式完成：`hasMany`和`reference`。
- en: hasMany config
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: hasMany配置
- en: 'The `hasMany` configuration option is the way these associations have always
    been created and allow us to define the models that would be related, and the
    names and data sources of each. This approach allows for more explicit control
    over the details of the association, making it more appropriate for more custom
    situations:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasMany`配置选项是这些关联一直以来的创建方式，并允许我们定义相关的模型，以及每个模型的名称和数据源。这种方法允许对关联的细节有更明确的控制，使其更适合更定制的情况：'
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `hasMany` config accepts an array of association definitions and should
    include a model option, defining the name of the model that the association data
    represents, and a name option which will be used to access the associated data.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasMany`配置接受一个关联定义数组，并应包括一个模型选项，定义关联数据表示的模型名称，以及一个名称选项，该选项将用于访问关联数据。'
- en: 'To access the associated data via the defined proxy, we use the user model''s
    static `load` method to load the user with an ID of `1` and specify a callback
    function to execute when it is successfully loaded:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过定义的代理访问关联数据，我们使用用户模型的静态`load`方法来加载ID为`1`的用户，并指定一个在成功加载时执行的回调函数：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can now load in the sale records that are associated with this user. We
    do this by calling the `sales` method (so called based on the `name` config we
    gave it in our `hasMany` configuration), which will return an `Ext.data.Store`
    instance that will contain our sale record instances. We then call that store''s
    `load` method, which will hit the `sale.json` file and return the related sale
    records. Within a callback function, we can then see the data items loaded:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以加载与该用户关联的销售记录。我们通过调用`sales`方法（根据我们在`hasMany`配置中给出的`name`配置命名）来完成此操作，这将返回一个包含我们的销售记录实例的`Ext.data.Store`实例。然后我们调用该存储的`load`方法，这将访问`sale.json`文件并返回相关的销售记录。在回调函数中，我们可以看到加载的数据项：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The reference config
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用配置
- en: The new way in Ext JS 5 to define associations is to use the `reference` config
    on a model's field, which will link the foreign key in a model to a related model
    type. This greatly simplifies the construction of associations and means both
    directions of the association can be accessed easily.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS 5中定义关联的新方法是在模型字段上使用`reference`配置，这将把模型中的外键链接到相关模型类型。这极大地简化了关联的构建，并且意味着关联的两个方向都可以轻松访问。
- en: 'The following code shows the `reference` config added to the `BizDash.model.Sale`
    model, linking it to the `BizDash.model.User` model:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了添加到`BizDash.model.Sale`模型的`reference`配置，将其链接到`BizDash.model.User`模型：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can now use the same code to load the user and then its associated sale
    records:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用相同的代码来加载用户及其关联的销售记录：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This technique also makes it easy to gain access to a sale record associated
    to a user. We make use of the generated `getUser` method, which is added to the
    sale record because of the reference we created. Calling this method will load
    the relevant user model based on the foreign key (`userId`) defined in the sale:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术还使得访问与用户关联的销售记录变得容易。我们利用生成的`getUser`方法，这是由于我们创建的引用而添加到销售记录中的。调用此方法将根据销售中定义的外键（`userId`）加载相关的用户模型：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Exploring requests
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索请求
- en: Each time we did a `load` or `getUser` call in our associations, an AJAX request
    was made to our server resources. In our case, we just had simple static JSON
    files, but in real life, we would have a proper server implementation which would
    return the correct data, based on the sale or user being requested. If we look
    at the **Network** tab of Developer Tools, we can see that the request to the
    `user.json` and `sale.json` files passed up parameters that we can then use to
    retrieve the correct data from our server database.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们在关联中进行`load`或`getUser`调用时，都会向我们的服务器资源发送一个AJAX请求。在我们的案例中，我们只有简单的静态JSON文件，但在现实生活中，我们会有一个适当的服务器实现，它会根据请求的销售或用户返回正确的数据。如果我们查看开发者工具的**网络**选项卡，我们可以看到对`user.json`和`sale.json`文件的请求传递了参数，然后我们可以使用这些参数从我们的服务器数据库检索正确数据。
- en: 'The following screenshot shows the user with ID of 1 loading. It passes the
    ID value as a query string parameter:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了ID为1的用户加载过程。它将ID值作为查询字符串参数传递：
- en: '![Exploring requests](img/3717_05_12.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![探索请求](img/3717_05_12.jpg)'
- en: When loading the sales relating to this user, the server is given a slightly
    more complex JSON string with details of the filter that should be applied to
    retrieve the correct data. In our server-side code, we would parse this and use
    it in our database queries.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载与该用户相关的销售时，服务器会收到一个稍微复杂一些的JSON字符串，其中包含应用于检索正确数据的筛选器细节。在我们的服务器端代码中，我们会解析这个字符串并在数据库查询中使用它。
- en: '![Exploring requests](img/3717_05_13.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![探索请求](img/3717_05_13.jpg)'
- en: Many-to-many
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多
- en: Another relationship type that can be modeled is many-to-many. In our application,
    we want to define a many-to-many relationship between Products and Locations,
    meaning that one Product can be stored in multiple Locations and one Location
    can have multiple Products. For example, Product 1 could be located in Warehouse
    1 and Warehouse 2, and Warehouse 1 could store Product 1 and Product 2.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以建模的关系类型是多对多。在我们的应用中，我们想要定义产品和位置之间的多对多关系，这意味着一个产品可以存储在多个位置，而一个位置也可以拥有多个产品。例如，产品1可以位于仓库1和仓库2，而仓库1可以存储产品1和产品2。
- en: Configuring a proxy and data source
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置代理和数据源
- en: 'As we did earlier, we will start by defining a proxy and simple static data
    source to connect our models to so that they can be populated. We do this with
    the following code pointing to two simple JSON files:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，我们将首先定义一个代理和简单的静态数据源，以便将我们的模型连接起来，从而使它们可以被填充。我们使用以下代码指向两个简单的JSON文件：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Defining the association
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义关联
- en: 'The simplest way to define this relationship is to add the `manyToMany` config
    option to the models on both sides of the association (Product and Location) and
    by providing the name of the model that should be on the other side:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 定义这种关系的最简单方法是在关联（产品与位置）两边的模型中添加`manyToMany`配置选项，并指定应该位于另一边的模型名称：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Loading the associated data
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载关联数据
- en: 'Like the one-to-many association, by defining this link, Ext JS will generate
    new methods called `locations` and `products` in the Product and Location models
    respectively. These methods will return an `Ext.data.Store` instance and will
    contain our associated data:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一对一关联一样，通过定义这个链接，Ext JS将在产品和位置模型中分别生成名为`locations`和`products`的新方法。这些方法将返回一个`Ext.data.Store`实例，并包含我们的关联数据：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: From a Location record, the related Products can be loaded in an identical way.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从位置记录中，可以以相同的方式加载相关的产品。
- en: Saving data
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存数据
- en: Now that we are able to load data successfully into our application, we can
    move on to persisting changes that we've made to this data within our client-side
    application. In most applications, when a change is made to a data store or record,
    we want to persist that change back to the data source, be it a server-side database
    or LocalStorage store. As mentioned previously, Ext JS provides us with the `Ext.data.writer.Writer`
    class (and its sub-classes) to manage the fields required to be written.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够成功地将数据加载到我们的应用程序中，我们可以继续将我们在客户端应用程序中对这些数据的更改持久化。在大多数应用程序中，当对数据存储或记录进行更改时，我们希望将此更改持久化回数据源，无论是服务器端数据库还是LocalStorage存储。如前所述，Ext
    JS为我们提供了`Ext.data.writer.Writer`类（及其子类）来管理需要写入的字段。
- en: In its most simple and standard form, a store will save any changes made when
    the `sync` method is called, without any further additions to our `proxy` configuration.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单和标准的形式中，存储将在调用`sync`方法时保存所做的任何更改，而无需进一步添加到我们的`proxy`配置中。
- en: 'If we continue with our users store example, we can update one of the `record`
    fields and then call the `sync` method:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续使用我们的用户存储示例，我们可以更新一个`record`字段，然后调用`sync`方法：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we inspect the **Network** tab of our Developer Tools, we will see a `POST`
    request being made to our `users.json` file passing along the changed field and
    the record''s ID:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查开发者工具的**网络**标签页，我们将看到向我们的`users.json`文件发送`POST`请求，传递更改的字段和记录的ID：
- en: '![Saving data](img/3717_05_06.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![保存数据](img/3717_05_06.jpg)'
- en: 'Similarly, we can add or remove records and call the `sync` method and an equivalent
    `POST` request will be made:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以添加或删除记录，并调用`sync`方法，这将触发一个等效的`POST`请求：
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is the screenshot of the request that is made:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是请求的截图：
- en: '![Saving data](img/3717_05_07.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![保存数据](img/3717_05_07.jpg)'
- en: 'The preceding request, after a record has been added, shows all fields being
    sent as `POST` parameters:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录添加后，前面的请求显示了所有字段作为`POST`参数被发送：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![Saving data](img/3717_05_08.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![保存数据](img/3717_05_08.jpg)'
- en: When a record is removed, the `id` field is POSTed to the server.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录被删除时，`id`字段将被发送到服务器。
- en: CRUD endpoints
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRUD端点
- en: 'Obviously the preceding example is a little flawed, in that we are POSTing
    changes to a static JSON file. By default, Ext JS will send all changes to the
    URL specified in the proxy, regardless of whether they are adds, updates, or deletes.
    This is often undesirable when separate endpoints exist for each of these actions.
    We can easily configure our proxy to contact a different endpoint for each action
    using the `api` configuration property. Our `proxy` configuration could be rewritten
    as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前面的例子有点不完善，因为我们正在将更改POST到静态JSON文件。默认情况下，Ext JS将发送所有更改到代理中指定的URL，无论它们是添加、更新还是删除。当存在针对这些操作的单独端点时，这通常是不希望的。我们可以轻松配置我们的代理以使用`api`配置属性联系不同的端点。我们的`proxy`配置可以重写如下：
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If we rerun the add, update, and delete actions, we will see calls being made
    to each of the PHP files specified in our `api` configuration.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行添加、更新和删除操作，我们将看到对我们在`api`配置中指定的每个PHP文件的调用。
- en: Data writers
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据写入者
- en: Data writers allow us to control how a store's data is constructed for sending
    out to be saved and give us a variety of options to customize this process. By
    default, a proxy will use a JSON writer (`Ext.data.writer.Json`), which will result
    in the to-be-saved data being encoded as a JSON string. Alternatively, the XML
    writer (`Ext.data.writer.Writer`) could be used, which would transfer data as
    XML.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 数据写入器使我们能够控制如何构建存储的数据以发送保存，并为我们提供了各种选项来自定义此过程。默认情况下，代理将使用 JSON 写入器（`Ext.data.writer.Json`），这将导致要保存的数据被编码为
    JSON 字符串。或者，可以使用 XML 写入器（`Ext.data.writer.Writer`），这将数据作为 XML 传输。
- en: To define a writer, we use the `writer` config of the proxy and give it its
    own configuration object. The `type` property determines which writer class is
    used—either JSON or XML.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个写入器，我们使用代理的 `writer` 配置，并给它一个自己的配置对象。`type` 属性确定使用哪个写入器类——要么是 JSON，要么是
    XML。
- en: 'We can configure our users store to use a JSON writer, as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置我们的用户存储使用 JSON 写入器，如下所示：
- en: '[PRE54]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We'll now take a look at a couple of the configuration options the writer class
    offers to allow us to customize how and what data is sent to the server.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看写入器类提供的几个配置选项，以允许我们自定义如何以及发送哪些数据到服务器。
- en: 'In our previous update example, we saw the edited field (in this case the `Email`
    field) being sent, along with the record''s ID, to the server. Sometimes, we will
    want to send all the fields to the server regardless of whether they have been
    edited or not. We can do this easily with the `writeAllFields` config as demonstrated
    here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的更新示例中，我们看到了编辑的字段（在这种情况下是 `Email` 字段）被发送，以及记录的 ID，到服务器。有时，我们可能希望无论是否已编辑，都发送所有字段到服务器。我们可以通过使用
    `writeAllFields` 配置轻松完成此操作，如下所示：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here is the screenshot of this update request:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此更新请求的截图：
- en: '![Data writers](img/3717_05_09.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![数据写入器](img/3717_05_09.jpg)'
- en: 'On occasion, you might want to do some additional processing on a dataset before
    it is sent up to the server. We can define this extra processing step by using
    the `transform` config, giving it a function to execute during the writing process.
    This function will accept the `data` object that will be sent and should return
    the processed `data` object. The following example shows how we can ensure that
    the given e-mail address is always in lowercase:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在数据被发送到服务器之前，你可能想要对数据集进行一些额外的处理。我们可以通过使用 `transform` 配置来定义这个额外的处理步骤，给它一个在写入过程中执行的功能。这个函数将接受将要发送的
    `data` 对象，并应返回处理后的 `data` 对象。以下示例显示了如何确保给定的电子邮件地址始终是小写：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Throughout this chapter, we have explored the details of how to model our application''s
    data structure with Ext JS. We have covered:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用 Ext JS 对应用程序的数据结构进行建模的细节。我们涵盖了：
- en: Defining models
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模型
- en: Loading and saving data to server and LocalStorage
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据加载和保存到服务器和 LocalStorage
- en: Defining relationships between models through associations
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过关联定义模型之间的关系
- en: How to work with data within data stores
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在数据存储中处理数据
- en: We will make use of all of these lessons throughout the rest of the book as
    our example application comes to life and we start to integrate data sources and
    data visualizations to it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的其余部分利用所有这些课程，随着我们的示例应用程序逐渐成形，并开始将其与数据源和数据可视化集成。
