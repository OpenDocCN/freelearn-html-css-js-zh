- en: Chapter 11\. OpenAPI (Swagger) Specification
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。OpenAPI（Swagger）规范
- en: The OpenAPI specification, most notably known by it’s former name Swagger, is
    a JSON schema that can be used to construct a JSON or YAML definition of a set
    of restful APIs. OpenAPI itself is language agnostic, meaning the underlying APIs
    can be constructed in any language with any tool or framework the developer would
    like. The sole concern of an OpenAPI document is to describe the inputs and outputs,
    among other things, of API endpoints. In this respect, an OpenAPI document acts
    as a documentation tool allowing developers to easily describe their public APIs
    in a format that is widely known, understood, and supported.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI规范，最著名的是其前身Swagger，是一个JSON模式，可用于构建一组RESTful API的JSON或YAML定义。OpenAPI本身是与语言无关的，这意味着底层API可以使用开发人员喜欢的任何语言、任何工具或框架来构建。OpenAPI文档的唯一关注点是描述API端点的输入和输出等内容。在这方面，OpenAPI文档充当了一个文档工具，使开发人员能够轻松地以广泛已知、理解和支持的格式描述其公共API。
- en: The OpenAPI document, however, is not just limited to being documentation. Many
    tools have been developed that are capable of using an OpenAPI document to auto-generate
    client projects, server stubs, an API explorer UI for visually inspecting the
    OpenAPI document, and even server generators. Developers can find such tools as
    the Swagger Editor, Codegen, and UI at [https://swagger.io](https://swagger.io).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，OpenAPI文档不仅仅局限于文档。已开发了许多工具，这些工具能够使用OpenAPI文档自动生成客户端项目、服务器存根、用于直观检查OpenAPI文档的API资源管理器UI，甚至服务器生成器。开发人员可以在[https://swagger.io](https://swagger.io)找到Swagger
    Editor、Codegen和UI等工具。
- en: While some tools exist to generate an OpenAPI document, a number of developers
    maintain such documents either as individual JSON or YAML files. They can break
    their document up into smaller pieces using OpenAPI reference mechanics. In Nest.js,
    a separate module is available for developers to use to generate an OpenAPI document
    for their application. Instead of writing your OpenAPI document by hand, Nest.js
    will use the decorators you provide in your controllers to generate as much information
    that it can about the APIs within your project. Of course, it won’t get everything
    out of the box. For that, the Nest.js swagger module provides additional decorators
    that you can use to fill in the gaps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在一些工具可以生成OpenAPI文档，但许多开发人员将这些文档保存为单独的JSON或YAML文件。他们可以使用OpenAPI引用机制将文档分解成更小的部分。在Nest.js中，开发人员可以使用单独的模块来为他们的应用程序生成OpenAPI文档。Nest.js将使用您在控制器中提供的装饰器来生成有关项目中API的尽可能多的信息，而不是手动编写OpenAPI文档。当然，它不会一步到位。为此，Nest.js
    swagger模块提供了额外的装饰器，您可以使用它们来填补空白。
- en: 'In this chapter, we will explore using the Nest.js Swagger module to generate
    a swagger version 2 document. We will begin with configuring the Nest.js Swagger
    module. We will setup our blog example application to expose the swagger document
    using the Swagger UI and begin exploring how the Nest.js decorators you are used
    to using already affect the swagger document. We will also explore the new decorators
    the swagger module provides. By the end of this chapter, you will have a complete
    understanding of how Nest.js produces a swagger document. Before getting started,
    be sure you run `npm install @nestjs/swagger` in your project. To see a working
    example, remember you can clone the accompanying Git repository for this book:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用Nest.js Swagger模块生成swagger版本2文档。我们将从配置Nest.js Swagger模块开始。我们将设置我们的博客示例应用程序以使用Swagger
    UI公开swagger文档，并开始探索Nest.js装饰器如何影响swagger文档。我们还将探索swagger模块提供的新装饰器。在本章结束时，您将完全了解Nest.js如何生成swagger文档。在开始之前，请确保在项目中运行`npm
    install @nestjs/swagger`以查看工作示例，记住您可以克隆本书的附带Git存储库：
- en: '`git clone https://github.com/backstopmedia/nest-book-example.git`'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/backstopmedia/nest-book-example.git`'
- en: Document Settings
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档设置
- en: Each swagger document can contain a basic set of properties such as the title
    of the application. This information can be configured using the various public
    methods found on the `DocumentBuilder` class. These methods all return the document
    instance allowing you to chain as many of the methods as you need. Be sure to
    finish your configuration before calling the `build` method. Once the `build`
    method has been called, the document settings are no longer modifiable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个swagger文档都可以包含一组基本属性，例如应用程序的标题。可以使用`DocumentBuilder`类上找到的各种公共方法来配置此信息。这些方法都返回文档实例，允许您链式调用尽可能多的方法。在调用`build`方法之前，请确保完成配置。一旦调用了`build`方法，文档设置将不再可修改。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These methods are used to configure the `info` section of the swagger document.
    The swagger specification requires the `title` and `version` fields to be provided,
    but Nest.js will default these values to an empty string and `"1.0.0"`, respectively.
    If your project has terms of service and a license, you can use `setTermsOfService`
    and `setLicense` to provide a URL to those resources within your application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法用于配置swagger文档的“info”部分。Swagger规范要求提供“title”和“version”字段，但Nest.js将这些值默认为一个空字符串和“1.0.0”，分别。如果您的项目有服务条款和许可证，您可以使用`setTermsOfService`和`setLicense`在应用程序中提供这些资源的URL。
- en: Swagger documents can also contain server information. Users, developers, and
    the UI can use this information to understand how to access the APIs described
    by the document.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger文档还可以包含服务器信息。用户、开发人员和UI可以使用此信息来了解如何访问文档中描述的API。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `setHost` should contain only the server and port to access the APIs. If,
    in your application, you use `setGlobalPrefix` to configure a base path for the
    Nest.js application, set the same value in the swagger document using `setBasePath`.
    The swagger specification uses a `schemes` array to describe the transfer protocol
    used by the APIs. While the swagger specification supports the `ws` and `wss`
    protocols as well as multiple values, Nest.js limits the value to either `http`
    or `https`. Metadata and external documentation can also be added to provide users
    of the swagger document additional details regarding how the APIs work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`setHost`应仅包含访问API的服务器和端口。如果在应用程序中使用`setGlobalPrefix`为Nest.js应用程序配置基本路径，则使用`setBasePath`在swagger文档中设置相同的值。swagger规范使用`schemes`数组来描述API使用的传输协议。虽然swagger规范支持`ws`和`wss`协议以及多个值，但Nest.js将该值限制为`http`或`https`。还可以添加元数据和外部文档，以向swagger文档的用户提供有关API工作方式的其他详细信息。'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Use the first parameter of `setExternalDoc` to describe the external documentation
    and a URL to the documentation as the second parameter. An endless number of tags
    can be added to the document using `addTag`. The only requirement is the first
    parameter to `addTag` be unique. The second parameter should describe the tag.
    The last document setting is how user’s authenticate with the APIs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setExternalDoc`的第一个参数描述外部文档，第二个参数是文档的URL。可以使用`addTag`向文档添加无数个标签。唯一的要求是`addTag`的第一个参数必须是唯一的。第二个参数应描述标签。最后一个文档设置是用户如何与API进行身份验证。
- en: Documenting authentication
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录身份验证
- en: 'The swagger specification supports three types of authentication: basic, API
    key, and Oauth2\. Nest.js provides two different methods that can be used to auto-configure
    the swagger document authentication information with the possibility for some
    settings to be overridden. Keep in mind, this is describing how users will authenticate
    with your application.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: swagger规范支持三种类型的身份验证：基本、API密钥和Oauth2。Nest.js提供了两种不同的方法，可以用于自动配置swagger文档的身份验证信息，并且可以覆盖一些设置。请记住，这描述了用户如何对您的应用程序进行身份验证。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If your application is using `basic` authentication, the username and password
    as a base64 encoded string, or JSON web tokens (JWT), you will make use of the
    `addBearerAuth` configuration method. The example above uses the defaults Nest.js
    will use if no parameters are passed and establishes that the APIs use an API
    key like a JWT in the authorization header. The first parameter should contain
    the key/header where the authentication key should be provided. This same configuration
    should be used if users will be using an application key to access the APIs. Application
    keys are typically used by public API provides like Google Maps to limit access
    to APIs and associate an API call to a specific billing account.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序使用`basic`身份验证，用户名和密码作为base64编码的字符串，或JSON web令牌（JWT），您将使用`addBearerAuth`配置方法。上面的示例使用Nest.js的默认值，如果没有传递参数，Nest.js将使用这些默认值，并确定API使用类似JWT的API密钥在授权标头中。第一个参数应包含应提供身份验证密钥的密钥/标头。如果用户将使用应用程序密钥访问API，则应使用相同的配置。应用程序密钥通常由公共API提供商（如Google
    Maps）使用，以限制对API的访问并将API调用与特定的计费账户关联起来。
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example describes two query parameters that must be included when calling
    APIs that require authentication. The second parameter describes where the authentication
    key should be provided, either as a header, query, or body parameter. The third
    parameter is the type of authentication. When using `addBearerAuth`, use `apiKey`
    or `basic`. In addition to basic and API key authentication, swagger also supports
    documenting an Oauth2 authentication flow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例描述了调用需要身份验证的API时必须包含的两个查询参数。第二个参数描述了身份验证密钥应该放在哪里，可以是标头、查询或正文参数。第三个参数是身份验证的类型。使用`addBearerAuth`时，使用`apiKey`或`basic`。除了基本和API密钥身份验证外，swagger还支持记录Oauth2身份验证流程。
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first parameter to the `addOAuth2` method is the OAuth2 flow the APIs use
    for authentication. In this example, we use the `password` flow to indicate the
    user should send a username and password to the API. You can also use `implicit`,
    `application`, and `accessCode` flow. The second and third parameters are the
    URLs where the user will authorize access to the APIs and request a refresh token,
    respectively. The last parameter is an object of all the scopes with descriptions
    that are available in the application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`addOAuth2`方法的第一个参数是API用于身份验证的OAuth2流。在此示例中，我们使用`password`流来指示用户应向API发送用户名和密码。您还可以使用`implicit`、`application`和`accessCode`流。第二个和第三个参数是用户将授权访问API和请求刷新令牌的URL。最后一个参数是应用程序中可用的所有范围及其描述的对象。'
- en: For the blog application, we will keep the configuration simple and store the
    configuration in a new file in the `shared/config` directory. Having a central
    location will let us write the configuration once and implement multiple times.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于博客应用程序，我们将保持配置简单，并将配置存储在`shared/config`目录中的新文件中。有一个中心位置将使我们只需编写一次配置并多次实现。
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our first implementation will use the configuration and the Nest.js swagger
    module to produce two new endpoints in our application: one to serve the swagger
    UI application and one to serve the swagger document as raw JSON.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个实现将使用配置和Nest.js swagger模块在我们的应用程序中生成两个新的端点：一个用于提供swagger UI应用程序，另一个用于提供原始JSON格式的swagger文档。
- en: Swagger UI
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger UI
- en: The swagger module is unlike most other Nest.js modules. Instead of being imported
    into your application’s primary app module, the swagger module is configured within
    the main bootstrap of your application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: swagger模块与大多数其他Nest.js模块不同。它不是被导入到应用程序的主要app模块中，而是在应用程序的主要引导中进行配置。
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After declaring the Nest application and before calling the `listen` method,
    we use the swagger document options configured in the last section and `SwaggerModule.createDocument`
    to create the swagger document. The swagger module will inspect all controllers
    within the application and use decorators to construct the swagger document in
    memory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明Nest应用程序并在调用`listen`方法之前，我们使用上一节配置的swagger文档选项和`SwaggerModule.createDocument`来创建swagger文档。Swagger模块将检查应用程序中的所有控制器，并使用装饰器在内存中构建swagger文档。
- en: Once we have created the swagger document, we setup and instruct the swagger
    module to serve the swagger UI at a specified path, `SwaggerModule.setup('/swagger',
    app, document)`. Under the hood, the swagger module makes use of the `swagger-ui-express`
    NodeJS module to turn the swagger document into a full web UI application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了swagger文档，我们设置并指示swagger模块在指定路径上提供swagger UI，`SwaggerModule.setup('/swagger',
    app, document)`。在幕后，swagger模块使用`swagger-ui-express` NodeJS模块将swagger文档转换为完整的Web
    UI应用程序。
- en: '![Example Swagger UI Application](img/basic-swagger-ui.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![示例Swagger UI应用程序](img/basic-swagger-ui.png)'
- en: The above figure shows a basic Swagger UI application using our example blog
    application. The JSON used to produce the UI is also available by appending `-json`
    to the path we configured for the UI. In our example, accessing `/swagger-json`
    will return the swagger document. This can be used with code generators like Swagger
    Codegen. For more information about Swagger UI and Swagger Codegen, refer to [https://swagger.io](https://swagger.io).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了一个使用我们示例博客应用程序的基本Swagger UI应用程序。用于生成UI的JSON也可以通过将我们为UI配置的路径添加`-json`来获得。在我们的示例中，访问`/swagger-json`将返回swagger文档。这可以与Swagger
    Codegen等代码生成器一起使用。有关Swagger UI和Swagger Codegen的更多信息，请参阅[https://swagger.io](https://swagger.io)。
- en: If you have followed along with the book and created the blog application, you
    may find that the Swagger UI produced does not contain a lot of information about
    the APIs in the application. Since the swagger document is built using Typescript
    decorator metadata, you may need to alter your types or make use of the additional
    decorators found in the Nest.js swagger module.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跟着本书创建了博客应用程序，您可能会发现Swagger UI生成的信息不包含应用程序中API的很多信息。由于swagger文档是使用Typescript装饰器元数据构建的，您可能需要修改您的类型或使用Nest.js
    swagger模块中找到的其他装饰器。
- en: API input decorators
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API输入装饰器
- en: The Nest.js swagger module can produce a swagger document using the `@Body`,
    `@Param`, `@Query`, and `@Headers` decorators. However, depending on how you write
    your API controllers, the swagger document can contain very little information.
    The swagger module will use the types associated with the decorated parameters
    to describe the parameters an API expects within the swagger document. To depict
    this, we will modify the comment PUT API to use all four decorators and show how
    that affects the swagger document by reviewing the swagger UI application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Nest.js swagger模块可以使用`@Body`、`@Param`、`@Query`和`@Headers`装饰器生成swagger文档。然而，根据您编写API控制器的方式，swagger文档可能包含的信息很少。swagger模块将使用与装饰参数相关联的类型来描述swagger文档中API期望的参数。为了描述这一点，我们将修改评论PUT
    API，使用所有四个装饰器，并通过查看swagger UI应用程序来展示这对swagger文档的影响。
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Comment Put Swagger Example](img/comment-put-swagger-example1.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![评论放置Swagger示例](img/comment-put-swagger-example1.png)'
- en: From the example, we can see the header of this API card uses a combination
    of the `@Controller` and `@Put` decorators to construct the path to the API. The
    parameters section is built using the `@Body`, `@Param`, `@Query`, and `@Headers`
    query params. The types we provide to the decorated parameters is used in the
    Swagger UI as a hint to the user regarding what is expected in the parameter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中，我们可以看到这个API卡的标题使用`@Controller`和`@Put`装饰器的组合来构建API的路径。参数部分使用`@Body`、`@Param`、`@Query`和`@Headers`查询参数构建。我们提供给装饰参数的类型在Swagger
    UI中被用作对用户的提示，说明参数中期望的内容。
- en: '![Comment Put Swagger Example](img/comment-put-swagger-example2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![评论放置Swagger示例](img/comment-put-swagger-example2.png)'
- en: Clicking the **Try it out** button in the header of the API card changes the
    card into a set of inputs. This allows the user to fill in the required and optional
    parameters of the API and execute the API call. We will cover the remaining sections
    of the API card later. For now, let’s review the basic parameter decorators in
    more detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 点击API卡标题中的**试一试**按钮会将卡片变成一组输入。这允许用户填写API的必需和可选参数，并执行API调用。我们将在稍后讨论API卡的其余部分。现在，让我们更详细地审查基本参数装饰器。
- en: '@Body'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@Body'
- en: You may have noticed in our example, the parameter we decorated with `@Body`
    had a type of `UpdateCommentRequest`. Your application may or may not have this
    class already. If not, let’s write it now.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在我们的示例中，我们用`@Body`装饰的参数的类型是`UpdateCommentRequest`。您的应用程序可能已经有这个类，也可能没有。如果没有，让我们现在编写它。
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The request class is very basic and makes use of the first decorator we will
    cover from the Nest.js swagger module, `@ApiModelPropertyOptional`. This decorator
    informs the swagger module that the `body` property of the request class is an
    optional property that can be included in the request body when calling the API.
    This decorator is actually a shortcut for the `@ApiModelProperty` decorator. We
    could write our request class as:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请求类非常基础，使用了Nest.js swagger模块中我们将要介绍的第一个装饰器`@ApiModelPropertyOptional`。这个装饰器通知swagger模块，请求类的`body`属性是一个可选属性，可以在调用API时包含在请求体中。这个装饰器实际上是`@ApiModelProperty`装饰器的快捷方式。我们可以将我们的请求类写成：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However, if a property is optional, use the `@ApiModelPropertyOptional` decorator
    to save yourself some typing. Both decorators can take several additional properties
    in an object passed to the decorator that will further define the data model for
    the request body.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果属性是可选的，请使用`@ApiModelPropertyOptional`装饰器来节省一些输入。这两个装饰器都可以接受传递给装饰器的对象中的几个附加属性，进一步定义请求体的数据模型。
- en: '**description**: A string that can be used to describe what the model property
    should contain or what it is used for.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**description**：一个字符串，可用于描述模型属性应包含的内容或其用途。'
- en: '**required**: A boolean indicating if the model property is required. This
    only applies to the `@ApiModelProperty` decorator.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**required**：一个布尔值，指示模型属性是否是必需的。这仅适用于`@ApiModelProperty`装饰器。'
- en: '**type**: The Nest.js swagger module will use the type associated with the
    model property or you can pass the **type** as any string or class value. If you
    use the **isArray** property, the **type** property should also be used. This
    property can also be used to pass any of the data types defined in the swagger
    specification.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**type**：Nest.js swagger模块将使用与模型属性关联的类型，或者您可以将**type**作为任何字符串或类值传递。如果使用**isArray**属性，则还应使用**type**属性。此属性还可用于传递swagger规范中定义的任何数据类型。'
- en: '**isArray**: A boolean indicating if the model property should take an array
    of values. If the model does take an array of values, be sure to include this
    value in the decorator or the Nest.js swagger module will not know to represent
    the model property as an array.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isArray**：一个布尔值，指示模型属性是否应该接受一组值。如果模型确实接受一组值，请确保在装饰器或Nest.js swagger模块中包含此值，以便知道将模型属性表示为数组。'
- en: '**collectionFormat**: Maps to the swagger specification **collectionFormat**
    setting. This is used to depict how a model properties array values should be
    formatted. For the request body, this property should probably not be used. Possible
    values are:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**collectionFormat**：映射到swagger规范的**collectionFormat**设置。这用于描述模型属性数组值的格式应该如何格式化。对于请求体，可能不应该使用此属性。可能的值包括：'
- en: '**csv**: comma separated values `foo,bar`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**csv**：逗号分隔的值`foo,bar`'
- en: '**ssv**: space separated values `foo bar`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ssv**：空格分隔的值`foo bar`'
- en: '**tsv**: tab separated values `foo\tbar`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tsv**：制表符分隔的值`foo\tbar`'
- en: '**pipes**: pipe separated values `foo|bar`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pipes**：管道分隔的值`foo|bar`'
- en: '**multi**: corresponds to multiple parameter instances instead of multiple
    values for a single instance foo=bar&foo=baz. This is valid only for parameters
    in “query” or “formData”.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**multi**：对应于多个参数实例，而不是单个实例的多个值foo=bar&foo=baz。这仅适用于“query”或“formData”中的参数。'
- en: '**default**: The default value to be used for the model property in the swagger
    document. This value will also be used in the example provided in the Swagger
    UI. The type of this value will depend on the type of the model property but could
    be a string, number, or even an object.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**default**：在swagger文档中用于模型属性的默认值。此值还将用于Swagger UI中提供的示例。此值的类型取决于模型属性的类型，但可以是字符串、数字，甚至是对象。'
- en: '**enum**: If your model properties type is an enum, pass the same enum to the
    decorator using this property so the Nest.js swagger module can inject those enum
    values into the swagger document.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**enum**：如果您的模型属性类型是枚举，使用此属性将相同的枚举传递给装饰器，以便Nest.js swagger模块可以将这些枚举值注入到swagger文档中。'
- en: '**format**: If you use the **type** property with a data type described in
    the swagger specification, you may also need to pass the format for that data
    type. For example, a field that takes a number with multiple precision points,
    values after the decimal, the **type** would be `integer` but the **format** may
    be either `float` or `double`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**format**：如果使用swagger规范中描述的数据类型的**type**属性，则可能还需要传递该数据类型的格式。例如，接受具有多个精度点、小数点后的值的字段，**type**将是`integer`，但**format**可能是`float`或`double`。'
- en: '**multipleOf**: A number indicating that the value passed in the model property
    should have a remainder of zero using the modulus operator. Setting this property
    in the decorator is only valid if the model properties type is `number` or the
    **type** provided to the decorator is `integer`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**multipleOf**：表示传递给模型属性的值应使用模运算符具有零余数的数字。仅当装饰器中的模型属性类型为`number`或装饰器提供的**type**为`integer`时，才可以设置此属性。'
- en: '**maximum**: A number indicating that the value passed in the model property
    should be less than or equal to the given value to be valid. Setting this property
    in the decorator is only valid if the model properties type is `number` or the
    **type** provided to the decorator is `integer`. This property should not be used
    with **exclusiveMaximum**.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maximum**：表示传递给模型属性的值应小于或等于给定值才有效的数字。仅当装饰器中的模型属性类型为`number`或装饰器提供的**type**为`integer`时，才可以设置此属性。此属性不应与**exclusiveMaximum**一起使用。'
- en: '**exclusiveMaximum**: A number indicating that the value passed in the model
    property should be less than the given value to be valid. Setting this property
    in the decorator is only valid if the model properties type is `number` or the
    **type** provided to the decorator is `integer`. This property should not be used
    with **maximum**.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exclusiveMaximum**：表示传递给模型属性的值应小于给定值才有效的数字。仅当装饰器中的模型属性类型为`number`或装饰器提供的**type**为`integer`时，才可以设置此属性。此属性不应与**maximum**一起使用。'
- en: '**minimum**: A number indicating that the value passed in the model property
    should be greater than or equal to the given value to be valid. Setting this property
    in the decorator is only valid if the model properties type is `number` or the
    **type** provided to the decorator is `integer`. This property should not be used
    with **exclusiveMinimum**.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minimum**：表示传递给模型属性的值应大于或等于给定值才有效的数字。仅当装饰器中的模型属性类型为`number`或装饰器提供的**type**为`integer`时，才可以设置此属性。此属性不应与**exclusiveMinimum**一起使用。'
- en: '**exclusiveMinimum**: A number indicating that the value passed in the model
    property should be less than the given value to be valid. Setting this property
    in the decorator is only valid if the model properties type is `number` or the
    **type** provided to the decorator is `integer`. This property should not be used
    with **minimum**.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exclusiveMinimum**：表示传递给模型属性的值应小于给定值才有效的数字。仅当装饰器中的模型属性类型为`number`或装饰器提供的**type**为`integer`时，才可以设置此属性。此属性不应与**minimum**一起使用。'
- en: '**maxLength**: A number indicating that the value passed in the model property
    should a character length less than or equal to the given value to be valid. Setting
    this property in the decorator is only valid if the model properties type is `string`
    or the **type** provided to the decorator is `string`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maxLength**：一个数字，表示模型属性中传递的值应该是字符长度少于或等于给定值才能有效。如果在装饰器中设置此属性，则必须是模型属性类型为`string`或装饰器提供的**type**为`string`。'
- en: '**minLength**: A number indicating that the value passed in the model property
    should a character length more than or equal to the given value to be valid. Setting
    this property in the decorator is only valid if the model properties type is `string`
    or the **type** provided to the decorator is `string`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minLength**：一个数字，表示模型属性中传递的值应该是字符长度大于或等于给定值才能有效。如果在装饰器中设置此属性，则必须是模型属性类型为`string`或装饰器提供的**type**为`string`。'
- en: '**pattern**: A string containing a JavaScript compatible regular expression.
    The value passed in the model property should match the regular expression to
    be valid. Setting this property in the decorator is only valid if the model properties
    type is `string` or the **type** provided to the decorator is `string`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pattern**：包含JavaScript兼容正则表达式的字符串。模型属性中传递的值应与正则表达式匹配才能有效。如果在装饰器中设置此属性，则必须是模型属性类型为`string`或装饰器提供的**type**为`string`。'
- en: '**maxItems**: A number indicating that the value passed in the model property
    should an array length less than or equal to the given value to be valid. Setting
    this property in the decorator is only valid if the the **isArray** is also provided
    with a value of `true`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maxItems**：一个数字，表示模型属性中传递的值应该是数组长度少于或等于给定值才能有效。如果在装饰器中设置此属性，则必须同时提供值为`true`的**isArray**。'
- en: '**minItems**: A number indicating that the value passed in the model property
    should an array length more than or equal to the given value to be valid. Setting
    this property in the decorator is only valid if the the **isArray** is also provided
    with a value of `true`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minItems**：一个数字，表示模型属性中传递的值应该是数组长度大于或等于给定值才能有效。如果在装饰器中设置此属性，则必须同时提供值为`true`的**isArray**。'
- en: '**uniqueItems**: A number indicating that the value passed in the model property
    should contain a set of unique array values. Setting this property in the decorator
    is only valid if the the **isArray** is also provided with a value of `true`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uniqueItems**：一个数字，表示模型属性中传递的值应包含一组唯一的数组值。如果在装饰器中设置此属性，则必须同时提供值为`true`的**isArray**。'
- en: '**maxProperties**: A number indicating that the value passed in the model property
    should contain a number of properties less than or equal to the given value to
    be valid. Setting this property in the decorator is only valid if the model property
    type is a class or object.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maxProperties**：一个数字，表示模型属性中传递的值应该包含少于或等于给定值的属性数量才能有效。如果模型属性类型是类或对象，则在装饰器中设置此属性才有效。'
- en: '**minProperties**: A number indicating that the value passed in the model property
    should contain a number of properties more than or equal to the given value to
    be valid. Setting this property in the decorator is only valid if the model property
    type is a class or object.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minProperties**：一个数字，表示模型属性中传递的值应该包含的属性数量大于或等于给定值才能有效。如果模型属性类型是类或对象，则在装饰器中设置此属性才有效。'
- en: '**readOnly**: A boolean indicating the model property **MAY** be sent in the
    API response body, but should not be provided in the request body. Use this if
    you will be using the same data model class to represent the request and response
    bodies of an API.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**readOnly**：一个布尔值，表示模型属性**可能**在API响应体中发送，但不应该在请求体中提供。如果您将使用相同的数据模型类来表示API的请求和响应体，请使用此选项。'
- en: '**xml**: A string containing XML that represent the format of the model property.
    Only use if the model property will contain XML.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**xml**：包含表示模型属性格式的XML的字符串。仅当模型属性将包含XML时使用。'
- en: '**example**: An example value to place in the swagger document. This value
    will also be used in the example provided in the Swagger UI and takes precedence
    over the **default** decorator property value.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**example**：在Swagger文档中放置的示例值。此值还将用于Swagger UI中提供的示例，并优先于**default**装饰器属性值。'
- en: The property that has been decorated with the `@Body` decorator should always
    have a type that is a class. Typescript interfaces cannot be decorated and do
    not provide the same metadata that a class with decorators can. If, in your application,
    any of your APIs have a property with the `@Body` decorator and an interface type,
    the Nest.js swagger module will not be able to correctly create the swagger document.
    In fact, the Swagger UI will most likely note display the body parameter at all.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 已使用`@Body`装饰器装饰的属性应始终具有类类型。Typescript接口无法被装饰，也不提供与带装饰器的类相同的元数据。如果在您的应用程序中，任何一个API具有带有`@Body`装饰器和接口类型的属性，则Nest.js
    swagger模块将无法正确创建Swagger文档。实际上，Swagger UI很可能根本不会显示请求体参数。
- en: '@Param'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@Param'
- en: The `@Param` decorator in our example contained a string value indicating which
    URL parameter to use for the `comment` parameter of our controller method. When
    the Nest.js swagger module encounters this decorator with the provided string,
    it is able to determine the name of the URL parameter and includes it in the swagger
    document along with the type provided for the method parameter. However, we could
    have also written the controller method without passing a string to the `@Param`
    decorator to get an object containing all of the URL parameters. If we do this,
    Nest.js will only be able to determine the names and types of the URL parameters
    if we use a class as the type for the `comment` parameter or use the `@ApiImplicitParam`
    decorator provided by the Nest.js swagger module on the controller method. Let’s
    create a new class to describe our URL params and see how it affects the swagger
    UI.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`@Param`装饰器包含一个字符串值，指示控制器方法的`comment`参数使用哪个URL参数。当Nest.js swagger模块遇到提供的字符串的装饰器时，它能够确定URL参数的名称，并将其与方法参数提供的类型一起包含在swagger文档中。但是，我们也可以在不向`@Param`装饰器传递字符串的情况下编写控制器方法，以获取包含所有URL参数的对象。如果这样做，Nest.js只能在我们将类用作`comment`参数的类型或在控制器方法上使用Nest.js
    swagger模块提供的`@ApiImplicitParam`装饰器时，才能确定URL参数的名称和类型。让我们创建一个新类来描述我们的URL参数，并看看它如何影响swagger
    UI。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `UpdateCommentParams` class, we have created a single property and used
    the `@ApiModelProperty` decorator so the Nest.js swagger module knows to include
    the properties with their types in the swagger document. Do not try to split the
    `entryId` out into it’s own class and extend it because the Nest.js swagger module
    will not be able to pickup the properties of the extended class. It is also important
    that the names of the properties used in the class matches the names used in the
    `@Controller` and `@Put` decorators. We can change our comment to use the new
    class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UpdateCommentParams`类中，我们创建了一个属性，并使用了`@ApiModelProperty`装饰器，这样Nest.js swagger模块就知道在swagger文档中包含属性及其类型。不要尝试将`entryId`拆分成自己的类并扩展它，因为Nest.js
    swagger模块将无法捕捉扩展类的属性。在类中使用的属性名称与`@Controller`和`@Put`装饰器中使用的名称匹配也很重要。我们可以修改我们的评论以使用新的类。
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have changed the controller so that all path parameters are provided to the
    controller method’s `params` parameter as an object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已更改控制器，以便所有路径参数作为对象提供给控制器方法的`params`参数。
- en: '![Comment Put Swagger Example](img/comment-put-swagger-example3.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Comment Put Swagger Example](img/comment-put-swagger-example3.png)'
- en: 'The swagger UI has been updated to show the comment put API takes two required
    URL parameters: `entryId` and `commentId`. If you will be writing APIs that use
    a single parameter in your method controller to hold all of the URL parameters,
    your preferred method of informing the Nest.js swagger module is what you should
    expect as URL parameters. Using a class as the type for your URL parameters not
    only informs the Nest.js swagger module of the URL parameters, it also helps in
    writing your application by providing type checking and code auto-completion.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: swagger UI已更新，显示评论put API需要两个必需的URL参数：`entryId`和`commentId`。如果您将编写使用单个参数在方法控制器中包含所有URL参数的API，您应该期望Nest.js
    swagger模块通知您URL参数的首选方法。将类用作URL参数的类型不仅通知Nest.js swagger模块URL参数，还通过提供类型检查和代码自动完成来帮助编写应用程序。
- en: If, however, you don’t want to make a new class to use as the type for your
    URL parameters, use an interface, or one or more of the URL parameters are in
    a Nest.js guard, or middleware, or in a custom decorator, but not in the controller
    method. You can still inform the Nest.js swagger module about the URL parameters
    using the `@ApiImplicitParam` decorator.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您不想创建一个新类来用作URL参数的类型，可以使用接口，或者一个或多个URL参数在Nest.js守卫、中间件或自定义装饰器中，而不在控制器方法中。您仍然可以使用`@ApiImplicitParam`装饰器通知Nest.js
    swagger模块有关URL参数。
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If a path param is required to reach the controller method, but the controller
    method does not use the param specifically, the Nest.js swagger module will not
    include it in the swagger document unless the controller method is decorated with
    the `@ApiImplicitParam` decorator. Use the decorator once for each path parameter
    that is necessary to reach the controller method, but it isn’t used in the controller
    itself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要路径参数才能到达控制器方法，但控制器方法并未专门使用该参数，Nest.js swagger模块将不会在swagger文档中包含它，除非控制器方法使用了`@ApiImplicitParam`装饰器进行装饰。对于每个必要到达控制器方法的路径参数，使用装饰器一次，但它在控制器本身中并未使用。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For example, the above controller, being a part of the comment controller,
    requires two path parameters: `entryId` and `commentId`. Since the controller
    does not contain any `@Param` decorators in the method parameters, `@ApiImplicitParam`
    is used to describe both path params.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上述控制器作为评论控制器的一部分，需要两个路径参数：`entryId`和`commentId`。由于控制器在方法参数中不包含任何`@Param`装饰器，因此使用`@ApiImplicitParam`来描述两个路径参数。
- en: The `@ApiImplicitParam` decorator can take several additional properties in
    an object passed to the decorator that will further define the URL parameter in
    the swagger document.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ApiImplicitParam`装饰器可以在传递给装饰器的对象中接受几个附加属性，进一步定义swagger文档中的URL参数。'
- en: '**name**: A string containing the name of the URL parameter. This decorator
    property is the only one required.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**：包含URL参数名称的字符串。这个装饰器属性是唯一必需的。'
- en: '**description**: A string that can be used to describe what the URL parameter
    should contain or what it is used for.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**description**：一个字符串，可用于描述URL参数应包含什么或用于什么。'
- en: '**required**: A boolean indicating if the URL parameter is required.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**required**：一个布尔值，指示URL参数是否是必需的。'
- en: '**type**: A string containing one of the types defined in the swagger specification.
    Classes and objects should not be used.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**type**：包含swagger规范中定义的类型之一的字符串。不应使用类和对象。'
- en: '@Query'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@Query'
- en: The `@Query` decorator in our example contained a string value indicating which
    query parameter to use for the `testQuery` parameter of our controller method.
    When the Nest.js swagger module encounters this decorator with the provided string,
    it is able to determine the name of the query parameter and includes it in the
    swagger document along with the type provided for the method parameter. However,
    we could have also wrote the controller method without passing a string to the
    `@Query` decorator to get an object containing all the query parameters. If we
    do this, Nest.js will only be able to determine the names and types of the query
    parameters if we use a class as the type for the `testQuery` parameter or use
    the `@ApiImplicitQuery` decorator provided by the Nest.js swagger module on the
    controller method. Let’s create a new class to describe our query params and see
    how it affects the Swagger UI.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`@Query`装饰器包含一个字符串值，指示控制器方法的`testQuery`参数使用哪个查询参数。当Nest.js swagger模块遇到提供的字符串的装饰器时，它能够确定查询参数的名称，并将其与方法参数提供的类型一起包含在swagger文档中。但是，我们也可以编写控制器方法，而不传递字符串给`@Query`装饰器，以获得包含所有查询参数的对象。如果这样做，Nest.js只能确定查询参数的名称和类型，如果我们使用类作为`testQuery`参数的类型或在控制器方法上使用Nest.js
    swagger模块提供的`@ApiImplicitQuery`装饰器。让我们创建一个新类来描述我们的查询参数，并看看它如何影响Swagger UI。
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `UpdateCommentQuery` class, we have created two properties and used the
    `@ApiModelPropertyOptional` decorator so the Nest.js swagger module knows to include
    these properties with their types in the swagger document. We can change our comment
    and put the controller method to use the new class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UpdateCommentQuery`类中，我们创建了两个属性，并使用`@ApiModelPropertyOptional`装饰器，以便Nest.js
    swagger模块知道在swagger文档中包含这些属性及其类型。我们可以更改我们的评论并将控制器方法更改为使用新类。
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have changed the controller so that all query parameters are provided to
    the controller method’s `queryParameters` parameter as an object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已更改控制器，以便所有查询参数作为对象提供给控制器方法的`queryParameters`参数。
- en: '![Comment Put Swagger Example](img/comment-put-swagger-example4.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Comment Put Swagger Example](img/comment-put-swagger-example4.png)'
- en: 'The swagger UI has been updated to show the comment, and the `put` API takes
    two optional query parameters: `testQueryA` and `testQueryB`. If you will be writing
    APIs that will use a single parameter in your method controller to hold all of
    the query parameters, this should be your preferred method of informing the Nest.js
    swagger module you are expecting as query parameters. Using a class as the type
    for your query parameters not only informs the Nest.js swagger module of the query
    parameters, it also helps in writing your application by providing type checking
    and code auto-completion.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI已更新以显示注释，并且`put` API接受两个可选的查询参数：`testQueryA`和`testQueryB`。如果您将编写将在方法控制器中使用单个参数来保存所有查询参数的API，那么这应该是您首选的方法，以通知Nest.js
    swagger模块您期望作为查询参数的内容。将类用作查询参数的类型不仅通知Nest.js swagger模块查询参数，还通过提供类型检查和代码自动完成来帮助编写应用程序。
- en: However, if you do not wish to make a new class to use as the type for your
    query parameters, you use an interface, or the query parameters are used in a
    Nest.js guard or middleware in a custom decorator, but not in the controller method.
    You can still inform the Nest.js swagger module about the query parameters using
    the `@ApiImplicitQuery` decorator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您不希望创建一个新类来用作查询参数的类型，可以使用接口，或者查询参数在Nest.js守卫或中间件中使用自定义装饰器，而不是在控制器方法中使用。您仍然可以使用`@ApiImplicitQuery`装饰器通知Nest.js
    swagger模块有关查询参数。
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If a query param is required to reach the controller method, but the controller
    method does not use the query param specifically, the Nest.js swagger module will
    not include it in the swagger document unless the controller method is decorated
    with the `@ApiImplicitQuery` decorator. Use the decorator once for each query
    parameter that is necessary to reach the controller method, but is not not used
    in the controller itself.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要查询参数才能到达控制器方法，但控制器方法没有专门使用查询参数，则Nest.js swagger模块将不会在swagger文档中包含它，除非控制器方法使用`@ApiImplicitQuery`装饰器进行装饰。对于每个必要到达控制器方法但在控制器本身中未使用的查询参数，使用装饰器一次。
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, the above controller requires two query parameters: `testQueryA`
    and `testQueryB`. Since the controller does not contain any `@Query` decorators
    in the method parameters, `@ApiImplicitQuery` is used to describe both query params.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上述控制器需要两个查询参数：`testQueryA`和`testQueryB`。由于控制器在方法参数中不包含任何`@Query`装饰器，因此使用`@ApiImplicitQuery`来描述两个查询参数。
- en: The `@ApiImplicitQuery` decorator can take several additional properties in
    an object passed to the decorator that will further define the query parameter
    in the swagger document.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ApiImplicitQuery`装饰器可以在传递给装饰器的对象中接受几个额外的属性，这些属性将进一步定义swagger文档中的查询参数。'
- en: '**name**: A string containing the name of the query parameter. This decorator
    property is the only one required.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**：包含查询参数名称的字符串。这个装饰器属性是唯一必需的。'
- en: '**description**: A string that can be used to describe what the query parameter
    should contain or what it is used for.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**description**：一个字符串，用于描述查询参数应包含什么或用于什么目的。'
- en: '**required**: A boolean indicating if the query parameter is required.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**required**：一个布尔值，指示查询参数是否是必需的。'
- en: '**type**: A string containing one of the types defined in the swagger specification.
    Classes and objects should not be used.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**type**：包含swagger规范中定义的类型之一的字符串。不应使用类和对象。'
- en: '**isArray**: A boolean indicating if the model property should take an array
    of values. If the model does take an array of values, be sure to include this
    value in the decorator or the Nest.js swagger module will not know to represent
    the model property as an array.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isArray**：一个布尔值，指示模型属性是否应该采用值数组。如果模型确实采用值数组，请确保在装饰器中包含此值，否则Nest.js swagger模块将不知道将模型属性表示为数组。'
- en: '**collectionFormat**: Maps to the swagger specification **collectionFormat**
    setting. This is used to depict how a model properties array values should be
    formatted. Possible values are:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**collectionFormat**：映射到swagger规范**collectionFormat**设置。这用于描述如何格式化模型属性数组值。可能的值有：'
- en: '**csv**: comma separated values `foo,bar`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**csv**：逗号分隔的值 `foo,bar`'
- en: '**ssv**: space separated values `foo bar`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ssv**：空格分隔的值 `foo bar`'
- en: '**tsv**: tab separated values `foo\tbar`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tsv**：制表符分隔的值 `foo\tbar`'
- en: '**pipes**: pipe separated values `foo|bar`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pipes**：管道分隔的值 `foo|bar`'
- en: '**multi**: corresponds to multiple parameter instances instead of multiple
    values for a single instance foo=bar&foo=baz. This is valid only for parameters
    in “query” or “formData”.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**multi**：对应于多个参数实例，而不是单个实例的多个值foo=bar&foo=baz。这仅对“query”或“formData”中的参数有效。'
- en: '@Headers'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@Headers'
- en: The `@Headers` decorator in our example contained a string value indicating
    which request header value to use for the `testHeader` parameter of our controller
    method. When the Nest.js swagger module encounters this decorator with the provided
    string, it is able to determine the name of the request header and includes it
    in the swagger document along with the type provided for the method parameter.
    However, we could have also written the controller method without passing a string
    to the `@Headers` decorator to get an object containing all the request headers.
    If we do this, Nest.js will only be able to determine the names and types of the
    request headers if we use a class as the type for the `testHeader` parameter or
    use the `@ApiImplicitHeader` decorator provided by the Nest.js swagger module
    on the controller method. Let’s create a new class to describe our query params
    and see how it affects the swagger UI.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`@Headers`装饰器包含一个字符串值，指示控制器方法的`testHeader`参数使用哪个请求头值。当Nest.js swagger模块遇到提供的字符串的装饰器时，它能够确定请求头的名称，并将其与方法参数提供的类型一起包含在swagger文档中。然而，我们也可以编写控制器方法，而不向`@Headers`装饰器传递字符串，以获得包含所有请求头的对象。如果我们这样做，Nest.js只能确定请求头的名称和类型，如果我们使用类作为`testHeader`参数的类型，或者在控制器方法上使用Nest.js
    swagger模块提供的`@ApiImplicitHeader`装饰器。让我们创建一个新类来描述我们的查询参数，并看看它如何影响swagger UI。
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `UpdateCommentHeaders` class, we have created two properties and used
    the `@ApiModelPropertyOptional` decorator so the Nest.js swagger module knows
    to include these properties with their types in the swagger document. We can change
    our comment `put` controller method to use the new class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UpdateCommentHeaders`类中，我们创建了两个属性，并使用`@ApiModelPropertyOptional`装饰器，以便Nest.js
    swagger模块知道在swagger文档中包含这些属性及其类型。我们可以更改我们的评论`put`控制器方法以使用新类。
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have changed the controller so that all request parameters the controller
    expects are provided to the controller method’s `queryParameters` parameter as
    an object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已更改控制器，以便将控制器方法期望的所有请求参数作为对象提供给控制器方法的`queryParameters`参数。
- en: '![Comment Put Swagger Example](img/comment-put-swagger-example5.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![评论放置Swagger示例](img/comment-put-swagger-example5.png)'
- en: 'The swagger UI has been updated to show the comment `put` API expects two headers:
    `testHeaderA` and `testHeaderB`. If you will be writing APIs that will use a single
    parameter in your method controller to hold all of the expected headers, and this
    should be your preferred method of informing the Nest.js swagger module that you
    are expecting as query parameters. Using a class as the type for your expected
    headers not only informs the Nest.js swagger module of the headers, it also helps
    in writing your application by providing type checking and code auto-completion.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: swagger UI已更新，显示评论`put` API需要两个头部：`testHeaderA`和`testHeaderB`。如果您将编写使用单个参数在方法控制器中保存所有预期头部的API，这应该是通知Nest.js
    swagger模块您期望的首选方法。使用类作为预期头部的类型不仅通知Nest.js swagger模块头部，还通过提供类型检查和代码自动完成来帮助编写应用程序。
- en: If, however, you do not wish to make a new class to use as the type for your
    expected headers, you use an interface, or the headers are used in a Nest.js guard
    or middleware or in a custom decorator, but not in the controller method. You
    can still inform the Nest.js swagger module about the query parameters using the
    `@ApiImplicitHeader` or the `@ApiImplicitHeaders` decorators.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您不希望创建一个新类作为预期头部的类型，您可以使用接口，或者头部用于Nest.js守卫、中间件或自定义装饰器，而不是在控制器方法中使用。您仍然可以使用`@ApiImplicitHeader`或`@ApiImplicitHeaders`装饰器通知Nest.js
    swagger模块有关查询参数。
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If a header is required to reach the controller method, but the controller method
    does not use the header specifically. The Nest.js swagger module will not include
    it in the swagger document unless the controller method is decorated with the
    `@ApiImplicitHeader` or `@ApiImplicitHeaders` decorators. Use the `@ApiImplicitHeader`
    decorator once for each header, or the `@ApiImplicitHeaders` decorator once to
    describe all the headers. This is necessary to reach the controller method but
    it isn’t used in the controller itself.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要一个头部才能到达控制器方法，但控制器方法没有专门使用头部。除非控制器方法使用`@ApiImplicitHeader`或`@ApiImplicitHeaders`装饰器进行装饰，否则Nest.js
    swagger模块不会将其包含在swagger文档中。对于每个头部使用一次`@ApiImplicitHeader`装饰器，或者一次使用`@ApiImplicitHeaders`装饰器来描述所有头部是必要的。这是为了到达控制器方法，但它在控制器本身中没有使用。
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For example, the above controllers requires two headers: `testHeaderA` and
    `testHeaderB`. Since the controller does not contain and `@Headers` decorators
    in the method parameters, `@ApiImplicitHeader`, and `@ApiImplicitHeaders` that
    is used to describe both headers.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上述控制器需要两个头部：`testHeaderA`和`testHeaderB`。由于控制器方法在方法参数中不包含`@Headers`装饰器，因此使用`@ApiImplicitHeader`和`@ApiImplicitHeaders`来描述两个头部。
- en: The `@ApiImplicitHeader` and `@ApiImplicitHeaders` decorators can take several
    additional properties in an object or array of objects, respectively, passed to
    the decorator that will further define the query parameter in the swagger document.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ApiImplicitHeader`和`@ApiImplicitHeaders`装饰器可以在对象或对象数组中接受几个额外的属性，分别传递给装饰器，以进一步定义swagger文档中的查询参数。'
- en: '**name**: A string containing the name of the header. This decorator property
    is the only one required.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**：包含标头名称的字符串。这个装饰器属性是唯一必需的。'
- en: '**description**: A string that can be used to describe what the header should
    contain or what it is used for.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**description**：一个字符串，可用于描述标头应包含什么或用于什么。'
- en: '**required**: A boolean indicating if the header is required.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**required**：一个布尔值，指示标头是否是必需的。'
- en: '**Note:** the `@ApiImplicitHeaders` decorator is just a shortcut for using
    the `@ApiImplicitHeader` decorator multiple times. If you need to describe multiple
    headers, use `@ApiImplicitHeaders`. Also, you should not use these headers to
    describe authentication mechanics. There are other decorators for that.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**`@ApiImplicitHeaders`装饰器只是使用`@ApiImplicitHeader`装饰器的快捷方式多次。如果需要描述多个标头，请使用`@ApiImplicitHeaders`。此外，您不应该使用这些标头来描述身份验证机制。有其他装饰器可以用于此目的。'
- en: Authentication
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证
- en: 'It is very likely that you will need to have some form of authentication in
    your application at some point. The blog example application uses a `username`
    and `password` combination to authenticate a user and provides a JSON web token
    to allow the user to access the APIs. However you decide to setup authentication,
    one thing is for sure: you will require either query parameters or headers to
    maintain an authentication state and you will most likely use Nest.js middleware
    or guards to check a user’s authentication state. You do this because writing
    that code in every controller method creates a lot of code duplication and would
    complicate every controller method.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能您在某个时候需要在应用程序中设置某种形式的身份验证。博客示例应用程序使用`用户名`和`密码`组合来验证用户，并提供JSON Web令牌以允许用户访问API。无论您决定如何设置身份验证，有一点是肯定的：您将需要查询参数或标头来维护身份验证状态，并且您很可能会使用Nest.js中间件或守卫来检查用户的身份验证状态。您这样做是因为在每个控制器方法中编写该代码会创建大量的代码重复，并且会使每个控制器方法变得复杂。
- en: If your application does require authentication, first, be sure your document
    settings are properly configured using the `addOAuth2` or the `addBearerAuth`
    method. Refer back to the **Document Settings** section if you are unsure of what
    those methods do.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序需要身份验证，请确保使用`addOAuth2`或`addBearerAuth`方法正确配置文档设置。如果您不确定这些方法的作用，请参考**文档设置**部分。
- en: In addition to setting the authentication scheme for the swagger document, you
    should also use the `ApiBearerAuth` and/or the `ApiOAuth2Auth` decorators on the
    controller class or controller methods. When used on an entire controller class,
    these decorators inform the Nest.js swagger module that all controller methods
    require authentication. If not all controller methods require authentication,
    you will need to decorate the individual controller methods that do.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为swagger文档设置身份验证方案之外，您还应该在控制器类或控制器方法上使用`ApiBearerAuth`和/或`ApiOAuth2Auth`装饰器。当用于整个控制器类时，这些装饰器会通知Nest.js
    swagger模块所有控制器方法都需要身份验证。如果不是所有控制器方法都需要身份验证，则需要装饰那些需要的单个控制器方法。
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example depicts a single controller method, API, that requires a bearer
    token to be able to use the API.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例描述了一个需要持有者令牌才能使用API的单个控制器方法API。
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This example depicts a single controller method, API, that requires a specific
    set of OAuth2 roles to be able to use the API. The `@ApiOAuth2Auth` decorator
    takes an array of all the roles the user should have in order to have access to
    the API.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例描述了一个需要特定OAuth2角色集才能使用API的单个控制器方法API。`@ApiOAuth2Auth`装饰器接受用户应具有的所有角色的数组，以便访问API。
- en: These decorators are used in conjunction with the `ApiBearerAuth` and `ApiOAuth2Auth`
    document settings to build a form the user can enter their credentials, either
    an API key or an Oauth key, and select their roles, if OAuth2 is being used, inside
    the swagger UI. These values are then passed in the appropriate places, either
    as query params or header values, when the user executes a specific API.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些装饰器与`ApiBearerAuth`和`ApiOAuth2Auth`文档设置一起使用，以构建用户可以输入其凭据（API密钥或Oauth密钥）并选择其角色（如果使用OAuth2）的表单，位于swagger
    UI内。然后，当用户执行特定API时，这些值将传递到适当的位置，即作为查询参数或标头值。
- en: '![Swagger UI Login Form](img/swagger-ui-login.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Swagger UI登录表单](img/swagger-ui-login.png)'
- en: Clicking the **Authorize** button at the top of the swagger UI page will open
    the authorizations form. For a bearer token, log into the application and copy
    the auth token returned into the space provided in the swagger UI authorization.
    The token should be in the form of `Bearer <TOKEN VALUE>`. For OAuth2 authentication,
    enter your credentials and select the roles you are requesting. Clicking the **Authorize**
    button will save the credentials for use when executing the APIs in the swagger
    UI.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 单击swagger UI页面顶部的**授权**按钮将打开授权表单。对于持有者令牌，请登录应用程序并将返回的授权令牌复制到swagger UI授权中提供的空间中。令牌应该是`Bearer
    <TOKEN VALUE>`的形式。对于OAuth2身份验证，请输入您的凭据并选择您要请求的角色。单击**授权**按钮将保存凭据，以便在swagger UI中执行API时使用。
- en: API request and response decorators
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API请求和响应装饰器
- en: So far we have been primarily focused on decorating controllers, so the Nest.js
    swagger module can build a swagger document containing all of the inputs our APIs
    expect or could use. The Nest.js swagger module also contains decorators that
    can be used to describe with what and how APIs respond and the format of the content
    it expects to receive and send. These decorators help form a complete picture
    of how a specific API works when looking at the swagger document or when using
    the swagger UI.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注装饰控制器，以便Nest.js swagger模块可以构建包含我们的API期望或可能使用的所有输入的swagger文档。Nest.js
    swagger模块还包含可以用于描述API如何响应以及它期望接收和发送的内容格式的装饰器。这些装饰器有助于在查看swagger文档或使用swagger UI时形成特定API如何工作的完整图像。
- en: All of the APIs we have covered in our example blog application follow a typical
    modal of accepting inputs in the form of JSON. However, it is possible that an
    application may need to take a different input type, often referred to as a MIME
    type. For example, we could allow users of our example blog application to upload
    an avatar image. An image cannot easily be represented as JSON so we would need
    to build an API that takes an input MIME type of `image/png`. We can ensure this
    information is present in our application’s swagger document by using the `@ApiConsumes`
    decorator.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例博客应用中涵盖的所有API都遵循接受JSON形式输入的典型模式。然而，应用程序可能需要接受不同的输入类型，通常称为MIME类型。例如，我们可以允许我们示例博客应用的用户上传头像图像。图像不能轻松地表示为JSON，因此我们需要构建一个接受`image/png`输入MIME类型的API。我们可以通过使用`@ApiConsumes`装饰器确保这些信息存在于我们应用程序的swagger文档中。
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we have used the `@ApiConsumes` decorator to inform the Nest.js
    swagger module that the comment `put` API expects to receive a png image.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`@ApiConsumes`装饰器来告知Nest.js swagger模块，评论`put` API预期接收一个png图像。
- en: '![Comment Put Swagger UI](img/comment-put-swagger-example6.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![评论Put Swagger UI](img/comment-put-swagger-example6.png)'
- en: The Swagger UI now shows the **Parameter content type** drop down as `image/png`.
    The `@ApiConsumes` decorator can take any number of MIME types as parameters.
    Multiple values in the decorator will result in the **Parameter content type**
    drop down containing multiple values with the first value always being the default.
    If a controller is dedicated to handling a specific MIME type, like `application/json`,
    the `@ApiConsumes` decorator can be placed on the controller class instead of
    on every single controller method. However, if your APIs will be consuming JSON,
    the decorator can be left off and the Nest.js swagger module will default the
    APIs to `application/json`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI现在显示**参数内容类型**下拉菜单为`image/png`。`@ApiConsumes`装饰器可以接受任意数量的MIME类型作为参数。装饰器中的多个值将导致**参数内容类型**下拉菜单包含多个值，第一个值始终是默认值。如果控制器专门用于处理特定的MIME类型，比如`application/json`，则可以将`@ApiConsumes`装饰器放在控制器类上，而不是每个单独的控制器方法上。然而，如果您的API将消耗JSON，可以不使用装饰器，Nest.js
    swagger模块将默认API为`application/json`。
- en: In addition to consuming various MIME data types, APIs can also respond with
    various MIME data types. For example, our fictitious avatar upload API may store
    the images in a database or cloud storage provider. Such storage locations may
    not be directly accessible to users so an API can be created to lookup and return
    the avatar image for any user. We can use the `@ApiProduces` decorator to let
    the Nest.js swagger module know the API returns data using the `image/png` MIME
    type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了消耗各种MIME数据类型外，API还可以响应各种MIME数据类型。例如，我们虚构的头像上传API可能会将图像存储在数据库或云存储提供商中。这样的存储位置可能不直接对用户可访问，因此可以创建一个API来查找并返回任何用户的头像图像。我们可以使用`@ApiProduces`装饰器来告知Nest.js
    swagger模块，API使用`image/png` MIME类型返回数据。
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we have used the `@ApiProduces` decorator to inform the Nest.js
    swagger module that the comment `put` API expects to return a png image.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`@ApiProduces`装饰器来告知Nest.js swagger模块，评论`put` API预期返回一个png图像。
- en: '![Comment Put Swagger UI](img/comment-put-swagger-example7.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![评论Put Swagger UI](img/comment-put-swagger-example7.png)'
- en: The Swagger UI now shows the **Response content type** drop down as `image/png`.
    The `@ApiProduces` decorator can take any number of MIME types as parameters.
    Multiple values in the decorator will result in the **Response content type**
    drop down containing multiple values with the first value always being the default.
    If a controller is dedicated to handling a specific MIME type, like `application/json`,
    the `@ApiConsumes` decorator can be placed on the controller class instead of
    on every single controller method. However, if your APIs will be consuming JSON,
    the decorator can be left off and the Nest.js swagger module will default the
    APIs to `application/json`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI现在显示**响应内容类型**下拉菜单为`image/png`。`@ApiProduces`装饰器可以接受任意数量的MIME类型作为参数。装饰器中的多个值将导致**响应内容类型**下拉菜单包含多个值，第一个值始终是默认值。如果控制器专门用于处理特定的MIME类型，比如`application/json`，则可以将`@ApiConsumes`装饰器放在控制器类上，而不是每个单独的控制器方法上。然而，如果您的API将消耗JSON，可以不使用装饰器，Nest.js
    swagger模块将默认API为`application/json`。
- en: Request and response MIME type information goes a long way to informing the
    end use of the swagger document, and how to use an API and how an API works. However,
    we have not fully documented everything an API can respond with. For example,
    what data values are contained in the APIs response body and what are the potential
    HTTP status codes it could return? Such information can be provided using the
    `@ApiResponse` decorator.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应的MIME类型信息在很大程度上可以告知Swagger文档的最终使用方式，以及如何使用API以及API的工作原理。然而，我们并没有完全记录API可能会响应的所有内容。例如，API响应体中包含哪些数据值，以及可能返回的HTTP状态码是什么？可以使用`@ApiResponse`装饰器提供这样的信息。
- en: The `@ApiResponse` decorator can be placed on individual controller methods
    or on the controller class. The Nest.js swagger module will collect the controller
    class level decorator data and pair it with the controller method decorator data
    to produce a list of possible responses each individual API could produce.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ApiResponse`装饰器可以放在单个控制器方法上，也可以放在控制器类上。Nest.js swagger模块将收集控制器类级别的装饰器数据，并将其与控制器方法的装饰器数据配对，以生成每个单独API可能产生的可能响应列表。'
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we decorated the comment controller so that all the APIs will
    contain a generic response for internal server errors. The update controller method
    has been decorated so that responses with a status code of `200` indicate the
    comment was successfully updated. The type is another data model created to provide
    the Nest.js swagger module with information regarding the individual properties
    in the response body.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们装饰了评论控制器，以便所有的API都包含一个用于内部服务器错误的通用响应。更新控制器方法已被装饰，以便状态码为`200`的响应表示评论已成功更新。类型是另一个数据模型，用于向Nest.js
    swagger模块提供有关响应体中各个属性的信息。
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `UpdateCommentResponse` data model contains one optional property, `success`,
    that could be used to further relay to the UI that the comment was updated successfully.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateCommentResponse`数据模型包含一个可选属性`success`，可以进一步向UI传达评论已成功更新的信息。'
- en: '![Comment Put swagger UI](img/comment-put-swagger-example8.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![评论放置swagger UI](img/comment-put-swagger-example8.png)'
- en: The swagger UI now lists both possible responses in the **Responses** section
    of the API card. Use the `@ApiResponse` decorator to inform user’s of your APIs
    about the different success and error scenarios they may need to deal with when
    using the APIs. The `@ApiResponse` decorator can take additional properties in
    the object passed to it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在swagger UI在API卡的**响应**部分列出了两种可能的响应。使用`@ApiResponse`装饰器来告知用户关于使用API时可能需要处理的不同成功和错误场景。`@ApiResponse`装饰器可以在传递给它的对象中接受其他属性。
- en: '**status**: A number containing the HTTP status code the API will respond with.
    This decorator property is the only one required.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**status**：包含API将响应的HTTP状态码的数字。这个装饰器属性是唯一必需的。'
- en: '**description**: A string that can be used to describe what the response indicates
    or how the user should react when the response is encountered.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**description**：一个字符串，可用于描述响应表示什么或者用户在遇到响应时应该如何反应。'
- en: '**type**: Use a data model class any of the data types defined in the swagger
    specification to inform users of the API what they can expect in the response
    body. If you use the **isArray** property, it indicated the response will be an
    array of values with the provided type.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**type**：使用数据模型类中swagger规范定义的任何数据类型，来告知用户可以在响应体中期望什么。如果使用了**isArray**属性，它表示响应将是一个包含提供类型的值的数组。'
- en: '**isArray**: A boolean indicating if the response body will contain an array
    of values. If the response body will contain an array of values, be sure to include
    this value in the decorator or the Nest.js swagger module will not know to represent
    the response body an array.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isArray**：一个布尔值，指示响应体是否包含一系列值。如果响应体将包含一系列值，请确保在装饰器中包含此值，否则Nest.js swagger模块将不知道如何表示响应体为一系列值。'
- en: API metadata decorators
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API元数据装饰器
- en: If you work through any Nest.js project and properly decorate all the controllers
    and controller methods with the decorators we have covered so far, the swagger
    document the Nest.js swagger module produces will have every technical detail
    a user of the APIs would need to understand and use the APIs. The last two decorators
    we will cover in this chapter simply provide more metadata for the swagger document.
    The swagger UI will use this metadata to produce a cleaner UI, but functionality
    will not change.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在任何Nest.js项目中工作，并且正确地使用我们到目前为止介绍的装饰器装饰所有的控制器和控制器方法，Nest.js swagger模块生成的swagger文档将包含用户理解和使用API所需的每一个技术细节。在本章中，我们将介绍的最后两个装饰器只是为swagger文档提供更多的元数据。swagger
    UI将使用这些元数据来生成更清晰的UI，但功能不会改变。
- en: The first decorator we will cover is `@ApiOperation`. Don’t confuse this decorator
    with the HTTP method decorators like `@Put`. This decorator is used to provide
    a **title**, **description**, and unique identifier called an **operationId**
    for individual controller methods.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的第一个装饰器是`@ApiOperation`。不要将这个装饰器与`@Put`之类的HTTP方法装饰器混淆。这个装饰器用于为单个控制器方法提供**标题**、**描述**和称为**operationId**的唯一标识符。
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we have provided a brief **title** and a much longer **description**
    of the comment put API. The **title** should be kept short, less than 240 character,
    and is used to populate the `summary` portion of the swagger specification. While
    the **description** in the example is short, use verbose descriptions in your
    own projects. This should convey why a user would use the API or what they accomplish
    through the use of the API. The **operationId** must be kept unique per the swagger
    documentation. The value could be used in various swagger codegen projects to
    reference the specific API.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供了一个简短的**标题**和一个更长的**评论放置API的描述**。**标题**应该保持简短，少于240个字符，并用于填充swagger规范的`summary`部分。虽然例子中的**描述**很短，但在你自己的项目中使用详细的描述。这应该传达用户为什么会使用API或者通过使用API可以实现什么。**operationId**必须根据swagger文档保持唯一。该值可以在各种swagger代码生成项目中用来引用特定的API。
- en: '![Comment Put swagger UI](img/comment-put-swagger-example9.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![评论放置swagger UI](img/comment-put-swagger-example9.png)'
- en: In the swagger UI, we can see the values we have passed to the `@ApiOperation`
    decorator, and how they are used to fill in additional details of the API card.
    The **title** is placed in the header next to the API path. The **description**
    is the first bit of information in the API card following the header. We can see
    how using a long **title** and **description** negatively impacts the API card
    header, but works very well in the API card body.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在swagger UI中，我们可以看到我们传递给`@ApiOperation`装饰器的值，以及它们如何用来填充API卡的附加细节。**标题**放在API路径旁的标题中。**描述**是标题后面API卡中的第一部分信息。我们可以看到，使用长**标题**和**描述**会对API卡标题产生负面影响，但在API卡正文中效果非常好。
- en: '![Comment Put Swagger UI](img/basic-swagger-ui1.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![评论放置Swagger UI](img/basic-swagger-ui1.png)'
- en: Looking at the overall swagger UI application, we can see that all of the APIs
    for the example blog application are grouped together. While this works, it would
    be nicer to group the APIs based on the operations they perform or the resources,
    comment, entry, or keyword that they act upon. This is what the `@ApiUseTags`
    decorator is used for.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从整体上看Swagger UI应用程序，我们可以看到示例博客应用程序的所有API都被分组在一起。虽然这样可以工作，但更好的是根据它们执行的操作或资源（评论、条目或关键字）对API进行分组。这就是`@ApiUseTags`装饰器的用途。
- en: The `@ApiUseTags` decorator can be placed on a controller class or individual
    controller methods and can take any number of string parameters. These values
    will be placed in the swagger document for each individual API.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ApiUseTags`装饰器可以放置在控制器类或单个控制器方法上，并且可以接受任意数量的字符串参数。这些值将被放置在swagger文档中的每个单独API中。'
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, we decorated the comment controller class so that all of the
    controller methods will be given the `comments` tag.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们装饰了评论控制器类，以便所有控制器方法都被赋予`comments`标签。
- en: '![Comment Put Swagger UI](img/basic-swagger-ui2.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![评论放置Swagger UI](img/basic-swagger-ui2.png)'
- en: The swagger UI now groups the APIs using the tags. This ensures like APIs are
    grouped and provides a little spacing between each group to produce a nicer UI.
    The groups are also expandable and collapsible giving users the option of hiding
    APIs they may not be interested in.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI现在使用标签对API进行分组。这确保了类似的API被分组，并在每个组之间提供一些间距，以产生更美观的UI。这些组也是可展开和可折叠的，让用户有隐藏他们可能不感兴趣的API的选项。
- en: Saving the swagger document
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存swagger文档
- en: We have covered all of the available decorators in the Nest.js swagger module
    and the decorators already available in Nest.js to produce a swagger document
    and expose the swagger UI. This works great when your APIs are primarily used
    by developers in their own projects or when testing the APIs on a local development
    server or in a staging environment. For APIs that are primarily used for a specific
    front-end application, you may not wish to expose the swagger UI for the general
    public to be able to use. In such a case, you can still produce a swagger document
    for storage and use it on your own or your teams other projects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了Nest.js swagger模块中所有可用的装饰器，以及Nest.js中已有的装饰器，以生成swagger文档并公开swagger UI。当您的API主要由开发人员在其自己的项目中使用，或者在本地开发服务器或分期环境中测试API时，这非常有效。对于主要用于特定前端应用程序的API，您可能不希望公开swagger
    UI供一般公众使用。在这种情况下，您仍然可以生成swagger文档以供存储，并在您自己或您团队的其他项目中使用。
- en: To accomplish this, we will write a new Typescript file that can be executed
    as part of a build chain. We will use the `fs-extras` NodeJS module to make writing
    our file to disk much simpler.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将编写一个新的Typescript文件，可以作为构建链的一部分执行。我们将使用`fs-extras` NodeJS模块，使文件写入磁盘变得更简单。
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can place this file in the root of your project or in the source directory
    and use an NPM script entry to execute it or run it using NodeJS. The example
    code will use the Nest.js swagger module to build a swagger document and `fs-extras`
    to write the document to the `dist` directory as a JSON file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此文件放在项目的根目录或源目录中，并使用NPM脚本条目来执行它，或者使用NodeJS运行它。示例代码将使用Nest.js swagger模块构建swagger文档，并使用`fs-extras`将文档写入`dist`目录作为JSON文件。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered how the Nest.js swagger module makes use of the
    existing decorators you use in your application to create a swagger v2 specification
    document. We also covered all the additional decorators the Nest.js swagger module
    provides to enhance the information in the swagger document. We also setup the
    example blog application to expose the swagger UI.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Nest.js swagger模块如何利用您在应用程序中使用的现有装饰器来创建swagger v2规范文档。我们还介绍了Nest.js
    swagger模块提供的所有额外装饰器，以增强swagger文档中的信息。我们还设置了示例博客应用程序以公开swagger UI。
- en: Use the Nest.js swagger module to not only document your application’s controllers,
    but to also provide UI for testing your application. If you fully document your
    application, the swagger UI can be an excellent replacement UI or provide an easy
    testing area that you or your users can use instead of having to watch for network
    calls in your applications real UI. The swagger UI can also be a great substitute
    for tools like Postman.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nest.js swagger模块不仅可以记录应用程序的控制器，还可以为测试应用程序提供UI。如果您完全记录了应用程序，Swagger UI可以是一个很好的替代UI，或者提供一个简单的测试区域，您或您的用户可以使用，而不必在应用程序的真实UI中观察网络调用。Swagger
    UI也可以是Postman等工具的很好替代品。
- en: If you don’t wish to use the Swagger UI or expose your swagger document with
    you application in a production environment, remember you can always write the
    file to disk as a separate build job of your application. This allows you to store
    and use the document in a number of ways, most notably with Swagger Codegen.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望使用Swagger UI或在生产环境中公开您的swagger文档，记住您可以始终将文件写入磁盘作为应用程序的单独构建作业。这允许您以多种方式存储和使用文档，尤其是使用Swagger
    Codegen。
- en: The next chapter will bring you up to speed on Command Query Responsibility
    Separation (CQRS).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将带您了解命令查询责任分离（CQRS）。
