- en: Chapter 13. Testing and Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 测试与性能
- en: We want the architecture of our application to be the best that it can possibly
    be. It may sound silly to have to state this, but it does bear repeating from
    time to time, as a reminder that the work we're doing with Flux has the potential
    to make or break the success of the application. The best tools we have in our
    arsenal are unit tests and performance tests. These two activities are equally
    important. Being functionally-correct but slow as hell is a failure. Being fast
    as hell and riddled with bugs is a failure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们应用程序的架构尽可能优秀。虽然这样说可能显得有些荒谬，但确实有必要时不时地重复这一点，以提醒我们使用 Flux 所做的工作有可能决定应用程序的成功与否。我们拥有的最佳工具是单元测试和性能测试。这两个活动同等重要。功能正确但速度极慢是失败。速度极快但充满错误也是失败。
- en: A huge contributing factor to implementing successful tests is to focus on what's
    relevant. We'll spend time in this chapter thinking about what the important tests
    are for Flux architectures—from both a functional and a performance perspective.
    This is especially important to think about given how new Flux is to the community.
    We'll focus on specific Flux components and design some unit tests for them. We'll
    then think about the difference between benchmarking low-level code versus performance
    testing end-to-end scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实施成功的测试的一个巨大贡献因素是关注相关的内容。在本章中，我们将花时间思考对于 Flux 架构来说，哪些是重要的测试——从功能和性能两个角度来看。鉴于
    Flux 对于社区来说相对较新，这一点尤为重要。我们将关注特定的 Flux 组件，并为它们设计一些单元测试。然后，我们将思考基准测试底层代码与性能测试端到端场景之间的区别。
- en: Hello Jest
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello Jest
- en: Jasmine is the widely accepted tool of choice when it comes to writing effective
    unit tests for JavaScript code. There's no shortage of add-on tools for Jasmine
    that make it possible to test just about anything and to use any tool to run your
    tests. For example, it's common practice to use a task runner such as Grunt or
    Gulp to run tests, along with the other various build tasks associated with the
    project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到为 JavaScript 代码编写有效的单元测试时，Jasmine 是广泛接受的选择工具。对于 Jasmine 的附加工具并不缺乏，这使得测试几乎任何东西和使用任何工具运行测试成为可能。例如，使用任务运行器（如
    Grunt 或 Gulp）来运行测试，以及与项目相关的其他各种构建任务是常见的做法。
- en: Jest is a unit testing tool, developed by Facebook, which leverages the best
    parts of Jasmine while adding new capabilities. It's also easy to run Jest in
    our projects. For example, projects that depend on Webpack generally rely on NPM
    scripts to perform various tasks, as opposed to a task runner. This is easy to
    do with Jest, as we'll see in a moment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 是由 Facebook 开发的一个单元测试工具，它借鉴了 Jasmine 的优点，并增加了新的功能。在项目中运行 Jest 也同样简单。例如，依赖于
    Webpack 的项目通常依赖于 NPM 脚本来执行各种任务，而不是使用任务运行器。使用 Jest 就可以轻松做到这一点，正如我们接下来将要看到的。
- en: 'There are three key aspects to Jest that will help us test our Flux architectures:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 有三个关键方面可以帮助我们测试 Flux 架构：
- en: Jest provides a virtualized JavaScript environment, including a DOM interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest 提供了一个虚拟化的 JavaScript 环境，包括 DOM 接口
- en: Jest spawns multiple worker processes to run our tests, leading to less time
    waiting for tests to complete and an overall faster development lifecycle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest 会启动多个工作进程来运行我们的测试，这导致等待测试完成的时间更少，并且整体上加快了开发周期
- en: Jest can mock JavaScript modules for us, making it easier to isolate units of
    code to test
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest 可以为我们模拟 JavaScript 模块，这使得隔离代码单元以进行测试变得更加容易
- en: 'Let''s take a look at a quick example to get things rolling. Suppose we have
    the following function that we''d like to test:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速示例来开始。假设我们有一个我们想要测试的以下函数：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should be easy enough, we just need to write a unit test that checks for
    expected output. Let''s see what this test looks like in Jest:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很容易，我们只需要编写一个单元测试来检查预期的输出。让我们看看这个测试在 Jest 中的样子：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If this looks a lot like Jasmine, that's because it is. Jasmine is actually
    used under the hood to perform all the test assertions. However, at the top of
    the test module, you can see that there's a Jest function call to `unmock()`.
    This tells Jest that we don't want a mocked version of the `sayHello()` function.
    We want to test the real thing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很像 Jasmine，那是因为它确实如此。实际上，Jasmine 被用于底层执行所有的测试断言。然而，在测试模块的顶部，你可以看到有一个 Jest
    函数调用 `unmock()`。这告诉 Jest 我们不想要 `sayHello()` 函数的模拟版本。我们想要测试真实的东西。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There's actually quite a bit of tinkering involved with getting Jest set up
    to work with ES2015 module imports. But rather than try to explain that here,
    I'd recommend looking at the source code that ships along with this book. And
    now, back to the important stuff.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Jest设置成与ES2015模块导入一起工作方面，实际上涉及了很多调整。但在这里尝试解释它可能不太合适，我建议查看这本书附带源代码。现在，回到重要的事情上。
- en: 'Let''s create a `main.js` module that imports the `sayHello()` function and
    calls it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`main.js`模块，它导入`sayHello()`函数并调用它：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Jest unit test that we created for the `sayHello()` function isolated the
    `sayHello()` function. That is, we didn''t have to test any other code in order
    to test this function. If we apply this same logic to the main module, we shouldn''t
    have to rely on the code that implements `sayHello()`. This is where the mocking
    capability of Jest comes in handy. Our last test turned off the mocking feature
    for the hello module, where `sayHello()` is defined. This time, we actually want
    to mock the function. Let''s see what the main test looks like:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`sayHello()`函数创建的Jest单元测试将`sayHello()`函数进行了隔离。也就是说，我们不需要测试任何其他代码来测试这个函数。如果我们将这种逻辑应用到主模块，我们就不必依赖于实现`sayHello()`的代码。这正是Jest的模拟功能派上用场的地方。我们上次的测试关闭了hello模块的模拟功能，其中定义了`sayHello()`。这次，我们实际上想要模拟这个函数。让我们看看主测试看起来像什么：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time around, we're making sure that the `main.js` module is not mocked
    by Jest. This means that the `sayHello()` function that we've imported is in fact
    the mocked version. To verify that the main module is working as expected, as
    simple as the module is, we just need to verify that the `sayHello()` function
    was called once.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们确保`main.js`模块不会被Jest模拟。这意味着我们导入的`sayHello()`函数实际上是模拟版本。为了验证主模块是否按预期工作，尽管模块很简单，我们只需要验证`sayHello()`函数被调用了一次。
- en: Testing action creators
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试动作创建者
- en: Now that we have a rough idea of how Jest works, it's time to start testing
    the various components of our Flux architecture. We'll start with action creator
    functions, since these determine the data that enters the system and are the starting
    point of the unidirectional data-flow. There are two types of action creators
    we'll want to test. First, we have the basic synchronous functions, followed by
    the asynchronous ones. Both types of actions lead to very different types of unit
    tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Jest的工作原理有了大致的了解，是时候开始测试我们Flux架构的各个组件了。我们将从动作创建者函数开始，因为它们决定了进入系统的数据，并且是单向数据流的起点。我们想要测试两种类型的动作创建者。首先，我们有基本的同步函数，然后是异步函数。这两种类型的动作会导致非常不同的单元测试。
- en: Synchronous functions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步函数
- en: 'The job of an action creator is to create the necessary payload data and to
    dispatch it to stores. So to test this functionality, we''ll want the real action
    creator function and a mocked dispatcher component. Remember, the idea is to isolate
    the component as the single unit that''s being tested—we don''t want any side-effects
    from the dispatcher code to influence the test outcome. With that said, lets take
    a look at the action creator:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 动作创建者的任务是创建必要的有效负载数据并将其分发给存储。因此，为了测试这个功能，我们需要真实的动作创建者函数和一个模拟的分发器组件。记住，我们的想法是将组件作为单独的测试单元进行隔离——我们不想任何来自分发器代码的副作用影响测试结果。有了这些话，让我们看看动作创建者：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This sort of function is probably looking familiar by now. We want our unit
    test for this function to verify whether or not the `dispatch()` method is called
    correctly. Let''s take a look at the test now:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的函数现在可能看起来很熟悉了。我们希望我们的单元测试验证这个函数是否正确地调用了`dispatch()`方法。现在让我们看看这个测试：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This works exactly as we expect it to. The first step is to tell Jest not to
    mock what's in the sync-func module, using the `unmock()` function. Jest will
    still mock everything else, including the dispatcher. So when this test calls
    `syncFunc()`, it's calling the mock dispatcher in-turn. When it does so, the mock
    records information about the call, which we then use in our test assertions to
    make sure that everything is working as expected.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全符合我们的预期。第一步是告诉Jest不要模拟sync-func模块中的内容，使用`unmock()`函数。Jest仍然会模拟其他所有内容，包括分发器。所以当这个测试调用`syncFunc()`时，它实际上是调用模拟的分发器。当它这样做时，模拟记录了关于调用的信息，然后我们使用这些信息在我们的测试断言中确保一切按预期工作。
- en: Nice and easy, right? Things get a little trickier when we need to mock asynchronous
    action creator functions, but we'll try to simplify everything in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？当我们需要模拟异步动作创建器函数时，事情会变得有点复杂，但我们在下一节会尝试简化一切。
- en: Asynchronous functions
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步函数
- en: 'Jest makes it easy for us to isolate the code that a given unit test should
    be testing by mocking all the irrelevant parts. Some things are easily handled
    by the Jest mock generator. Others need our intervention, as you''ll see in this
    example. So let''s start off and take a look at the asynchronous action creator
    function that we''re trying to test:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Jest使我们能够通过模拟所有无关部分来轻松隔离给定单元测试应该测试的代码。一些事情可以通过Jest模拟生成器轻松处理。其他事情则需要我们的干预，正如你将在下面的例子中看到的那样。所以，让我们开始，看看我们试图测试的异步动作创建器函数：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This action creator makes a request to a public JSON endpoint, and then dispatches
    the `ASYNC` action with the response as the action payload. If the `request()`
    function that we''re using to make the network request looks a lot like the global
    `fetch()` function, that''s because it is that function. The request module simply
    exports it, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动作创建器向一个公共JSON端点发送请求，然后将响应作为动作负载来分发`ASYNC`动作。如果我们使用的`request()`函数看起来很像全局的`fetch()`函数，那是因为它就是那个函数。请求模块只是简单地导出它，如下所示：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It seems pointless, but there''s really no overhead involved. This is how we''re
    able to mock all network requests in our code easily. If we mock this request
    module for our unit tests, it means that our code won''t be trying to reach a
    remote server. To mock this module, we just have to create a module by the same
    name in the `__mocks__` directory, alongside the `__tests__` directory. Jest will
    mock find this mock and substitute it for the real module when it''s imported.
    Let''s look at the source of the mock `request()` function now:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎没有意义，但实际上并没有涉及任何开销。这就是我们能够轻松模拟代码中所有网络请求的方式。如果我们为单元测试模拟这个请求模块，这意味着我们的代码不会尝试连接到远程服务器。为了模拟这个模块，我们只需要在`__mocks__`目录中创建一个同名的模块，与`__tests__`目录并列。Jest将找到这个模拟并替换导入时的真实模块。现在让我们看看模拟`request()`函数的源代码：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If this code looks a little gross, don't worry—it's confined to this one place.
    All it's doing is replicating the interface of the native `fetch()` function that
    this module replaces (because we don't actually want to fetch anything). The tricky
    part of this approach is that any `request()` calls in our code are going to get
    the same resolved values. But this should be fine, assuming that our code can
    just ignore properties that it doesn't care about and that we can keep the test
    data in here to a minimum.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码看起来有点糟糕，不要担心——它只限于这个位置。它所做的只是复制这个模块所替代的本地`fetch()`函数的接口（因为我们实际上不想获取任何东西）。这种方法棘手的地方在于，我们代码中的任何`request()`调用都将获得相同的解析值。但只要我们的代码可以忽略它不关心的属性，并且我们可以将测试数据保持到最小，这应该就没有问题。
- en: 'At this point, we have a mocked network layer, which means that we''re ready
    to implement the actual unit test now. Let''s go ahead and do that:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有一个模拟的网络层，这意味着我们现在可以实施实际的单元测试了。让我们继续进行：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are two important things to note about this test. One, it's using the
    `pit()` function as a drop-in replacement for `it()`. Two, the `asyncFunc()` function
    itself returns a promise. These two aspects of Jest are what make writing asynchronous
    unit tests so straightforward. The difficult part of this example isn't the test,
    it's the infrastructure we need in place in order to mock things like network
    requests. Thanks to everything Jest takes care of for us, our unit test code is
    actually a lot smaller than it would otherwise be.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个测试，有两点需要注意。一是它使用`pit()`函数作为`it()`函数的直接替代。二是`asyncFunc()`函数本身返回一个承诺。这两个方面是Jest使编写异步单元测试变得如此简单的原因。这个例子中困难的部分不是测试，而是我们需要建立的基础设施，以便模拟像网络请求这样的东西。多亏了Jest为我们处理的一切，我们的单元测试代码实际上比其他情况下要小得多。
- en: Testing stores
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试存储
- en: In the previous section, we used Jest to test action creator functions. This
    wasn't much different from testing any other JavaScript function, except that
    Flux action creators need to somehow dispatch the actions they create to stores.
    Jest helps us achieve this by automatically mocking certain components, and it
    will certainly help us test our store components.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了Jest来测试动作创建函数。这与测试任何其他JavaScript函数没有太大区别，只是Flux动作创建者需要以某种方式将它们创建的动作调度到存储上。Jest通过自动模拟某些组件来帮助我们实现这一点，这无疑将帮助我们测试存储组件。
- en: In this section, we'll look at testing the basic path of an action being dispatched
    to a store and the store emitting a change event. Then, we'll think about the
    initial store state and how this can lead to bugs that unit tests should be able
    to catch. Making all of this work is going to involve thinking about implementing
    testable store code, which is something we have yet to think about in this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看测试动作被调度到存储并存储发出更改事件的路径。然后，我们将思考初始存储状态以及这可能导致单元测试应该能够捕获的bug。使所有这些工作涉及考虑实现可测试的存储代码，这是我们在这本书中还没有考虑过的。
- en: Testing store listeners
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试存储监听器
- en: Store components can be tricky to isolate from other components. This in turn
    makes designing unit tests for stores difficult. For example, a store will typically
    register itself with the dispatcher by passing it a callback function. This is
    the function that will change the state of the store, depending on the action
    payload that's passed to it. The reason this is a challenge is that it's tightly-coupled
    with the dispatcher.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 存储组件可能很难与其他组件隔离。这反过来使得为存储编写单元测试变得困难。例如，一个存储通常会通过传递一个回调函数来向调度器注册自己。这个函数将根据传递给它的动作有效载荷改变存储的状态。这之所以是一个挑战，是因为它与调度器紧密耦合。
- en: Ideally, we want the dispatcher removed from the unit test completely. We're
    only testing our store code in the unit test, so we don't want anything that's
    happening in the dispatcher to interfere with the outcome. The odds of this happening
    are slim, since the dispatcher doesn't really have much to do. However, it's better
    to be consistent with all our Flux components and somehow isolate them completely.
    We've seen how Jest can help us out in the previous section. We just need to somehow
    apply this principle to stores—to decouple them from the dispatcher during unit
    tests.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望将调度器完全从单元测试中移除。我们只是在单元测试中测试我们的存储代码，所以不希望调度器中发生的任何事情干扰测试结果。这种情况发生的可能性很小，因为调度器实际上并没有太多事情要做。然而，与我们的所有Flux组件保持一致并尽可能完全隔离它们会更好。我们在上一节中看到了Jest如何帮助我们。我们只需要以某种方式将这个原则应用到存储上——在单元测试期间将它们与调度器解耦。
- en: 'This is a case where we might need to reconsider how we write our store code—sometimes
    for code to be good, it needs to be changed slightly so that it''s good and testable.
    For example, the anonymous function that we would normally register with the dispatcher
    becomes a store method. This allows the test to call the method directly, skipping
    the whole dispatching mechanism, which is exactly what we want. Let''s take a
    look at the store code now:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可能需要重新考虑我们编写存储代码的方式的情况——有时为了代码质量，需要稍作修改以便它既好又可测试。例如，我们通常注册到调度器的匿名函数变成了存储方法。这允许测试直接调用该方法，跳过整个调度机制，这正是我们想要的。现在让我们看看存储代码：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the `onAction()` method is registered with the dispatcher, and
    will be called any time an action is dispatched. The `doStuff()` method breaks
    the specific state transformation that takes place in response to the `DO_STUFF`
    action out of the `onAction()` method. This isn't strictly necessary, but it does
    provide us with another target for our unit tests. For example, we could have
    just left the anonymous callback function in place and have our tests target the
    `doStuff()` method directly. However, if our tests call `onAction()` with the
    same type of payload data that comes from the dispatcher, we get better test coverage
    of the store.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`onAction()`方法已注册到调度器，并且每当有动作被调度时都会被调用。`doStuff()`方法将响应`DO_STUFF`动作发生的特定状态转换从`onAction()`方法中分离出来。这并不是严格必要的，但它为我们提供了另一个单元测试的目标。例如，我们本可以保留匿名回调函数不变，并直接针对`doStuff()`方法进行测试。然而，如果我们的测试使用来自调度器的相同类型的有效载荷数据调用`onAction()`，我们将获得更好的存储测试覆盖率。
- en: 'The astute reader might have noticed that this store is importing `EventEmitter`
    from a different place than usual—`../events`. We have our own events module?
    We do now, and it''s the same idea as with the `fetch()` function in the preceding
    section. We''re providing a module of our own that Jest can mock. This is an easy
    way for Jest to mock the `EventEmitter` class. We were so busy thinking about
    the dispatcher, that we forgot to decouple our store from the event emitter for
    our test. Let''s take a look at the events module so that you can see we''re still
    exposing the good old `EventEmitter` we all know and love:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 精明的读者可能已经注意到，这个商店从不同于平常的地方导入`EventEmitter`——`../events`。我们有自己的事件模块吗？我们现在有了，并且它与上一节中`fetch()`函数的思路相同。我们提供了一个自己的模块，Jest可以对其进行模拟。这是Jest模拟`EventEmitter`类的一个简单方法。我们当时太忙于思考分发器，以至于忘记了在测试中将我们的商店与事件发射器解耦。让我们看看事件模块，这样你就可以看到我们仍然在暴露大家所熟知和喜爱的“老式”`EventEmitter`：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This means that the methods inherited by our store will be mocked by Jest,
    which is perfect because now our store is completely isolated from other component
    code and we can use data collected by the mock to perform some test assertions.
    Let''s implement the unit test for this store now:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的商店继承的方法将由Jest进行模拟，这是完美的，因为现在我们的商店完全与其他组件代码隔离，我们可以使用模拟收集的数据来进行一些测试断言。现在让我们为这个商店实现单元测试：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What's nice about this approach is that it closely resembles how the data flows
    through the store, but without actually depending on other components in order
    to run the test. The test data enters the store the same way it would with an
    actual dispatcher component. Likewise, we know that the correct event data is
    being emitted by the store by measuring the mock implementation. This is where
    the store's responsibilities end, and so too do the test's responsibilities.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于，它非常接近数据在商店中流动的方式，但实际上并不依赖于其他组件来运行测试。测试数据以与实际分发器组件相同的方式进入商店。同样，我们知道商店通过测量模拟实现正确地发出了事件数据。这就是商店的责任结束的地方，测试的责任也是如此。
- en: Testing initial conditions
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试初始条件
- en: 'One thing we''ll learn soon after our Flux stores grow large and complex is
    that they become increasingly difficult to test. For example, if the number of
    actions that a store responds to goes up, then the number of state configurations
    we''ll want to test with will also go up. To help accommodate the unit tests for
    our stores, it would be helpful to be able to set the initial state of the store.
    Let''s take a look at a store that allows us to set the initial state and responds
    to a couple of actions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的Flux商店变得庞大且复杂后，我们很快就会学到，它们变得越来越难以测试。例如，如果一个商店响应的动作数量增加，那么我们想要测试的状态配置数量也会增加。为了帮助适应我们商店的单元测试，能够设置商店的初始状态将非常有帮助。让我们看看一个允许我们设置初始状态并响应几个动作的商店：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This store responds to the `POWER_ON` and `POWER_OFF` actions. If you look
    at the methods that handle the state transformations of these two actions, you
    can see that the result depends on the current state. For example, powering on
    a store requires that the store already be off. Powering off a store is even more
    restrictive—the store has to be off and cannot be busy. These types of state transformations
    need to be tested using different initial store states, to make sure that the
    happy path works as expected, as well as the edge cases. Now let''s take a look
    at the test for this store:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个商店响应`POWER_ON`和`POWER_OFF`动作。如果你查看处理这两个动作状态转换的方法，你会发现结果取决于当前状态。例如，开启商店需要商店已经关闭。关闭商店的限制更加严格——商店必须关闭且不能忙碌。这类状态转换需要使用不同的初始商店状态进行测试，以确保预期中的正常路径以及边缘情况都能按预期工作。现在让我们看看这个商店的测试：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The second test is perhaps the most interesting because it makes sure that no
    events were emitted as a result of the action, due to the way the state transformation
    logic of the store works.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试可能是最有趣的，因为它确保由于商店的状态转换逻辑方式，没有事件被动作触发。
- en: Performance goals
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能目标
- en: It's time to switch gears and think about testing the performance of our Flux
    architecture. Testing the performance of a particular component can be difficult
    for the same reason that testing the functionality of a component is difficult—we
    have to isolate it from other code. On the other hand, our users don't necessarily
    care about the performance of individual components—just the overall user experience.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候转换思路，思考测试我们Flux架构性能的问题了。测试特定组件的性能可能会很困难，原因与测试组件功能一样——我们必须将其与其他代码隔离开来。另一方面，我们的用户并不一定关心单个组件的性能——他们只关心整体的用户体验。
- en: In this section, we'll discuss what we're trying to achieve with our Flux architecture
    in terms of performance. We'll start with the user perceived performance of the
    application, because this is the most consequential aspect of an under-performing
    architecture. Next, we'll think about measuring the raw performance of our Flux
    components. Finally, we'll consider the benefits of putting performance requirements
    in place for when we develop new components.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论我们在性能方面通过我们的Flux架构试图实现的目标。我们将从应用程序的用户感知性能开始，因为这是性能不佳架构中最重要的一面。接下来，我们将考虑测量我们Flux组件的原始性能。最后，我们将考虑为开发新组件时设定性能要求的好处。
- en: User perceived performance
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户感知性能
- en: From the point of view of our users, our application either feels responsive
    or laggy. This *feeling* is called user-perceived performance, because the user
    isn't actually measuring how long something takes to complete. Generally speaking,
    user-perceived performance is about frustration thresholds. Whenever we have to
    wait for something, frustration grows because we don't feel in control of the
    situation. We can't do anything to make it hurry up, in other words.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，我们的应用程序要么感觉响应迅速，要么运行缓慢。这种*感觉*被称为用户感知性能，因为用户实际上并没有测量完成某件事情所需的时间。一般来说，用户感知性能关乎挫败感阈值。每当我们需要等待某事时，挫败感就会增长，因为我们感觉无法掌控局势。我们无法做任何事情来让它加快速度，换句话说。
- en: One solution is to distract the user. There are times when our code has to process
    something and there's no way around the length of time it takes. While this is
    happening, we can keep the user updated on the task progress. We might even be
    able to show some of the output that's already been processed, depending on the
    type of task. The other answer is to write performant code, which is something
    we should always strive for anyway.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是分散用户的注意力。有时候，我们的代码必须处理某些事情，而没有办法缩短它所需的时间。在这个过程中，我们可以让用户了解任务进度。根据任务类型，我们甚至可能能够展示一些已经处理过的输出。另一个答案是编写高性能的代码，这是我们始终应该努力追求的。
- en: User-perceived performance is critically important for the software product
    that we're building because if it's perceived as being slow, it's also perceived
    as being of poor quality. At the end of the day, it's the user's opinion that
    matters—this is how we measure whether or not our Flux architecture scales to
    an acceptable level. The downside of user perceived performance is that it's impossible
    to quantify, at least at a granular level. This is where we need tooling in place
    to help us measure how our components perform.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 用户感知性能对我们正在构建的软件产品至关重要，因为如果它被认为运行缓慢，也会被认为质量低下。最终，用户的意见才是最重要的——这就是我们衡量我们的Flux架构是否扩展到可接受水平的方法。用户感知性能的缺点是它无法量化，至少在细粒度层面上是这样。这就是我们需要工具来帮助我们衡量组件性能的地方。
- en: Measured performance
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量性能
- en: Performance metrics tell us specifically where the performance bottlenecks in
    our code are. If we know where the performance issues are, then we're better equipped
    to address them. From the perspective of a Flux architecture, for example, we
    would want to know whether the action creators are taking a long time to respond,
    or whether the stores are taking a long time to transform their state.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 性能指标告诉我们代码中性能瓶颈的具体位置。如果我们知道性能问题的所在，那么我们就能更好地解决它们。从Flux架构的角度来看，例如，我们想知道动作创建者是否需要很长时间才能响应，或者存储是否需要很长时间来转换其状态。
- en: There are two types of performance testing that can help us stay on top of any
    performance issues during the development of our Flux architecture. The first
    type of testing is profiling, and we'll look at this in more detail in the next
    section. The second type of performance testing is benchmarking. This latter type
    of testing is done at a lower level and is good for comparing different implementations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的性能测试可以帮助我们在开发Flux架构的过程中保持对任何性能问题的控制。第一种测试类型是分析，我们将在下一节中更详细地探讨这一点。第二种性能测试类型是基准测试。这种测试类型在较低级别进行，适用于比较不同的实现。
- en: The only question is—how do we make performance measurement a fact of daily
    life, and what can we do with the results?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是——我们如何使性能测量成为日常生活的常态，我们可以用这些结果做什么？
- en: Performance requirements
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能要求
- en: Given that we have the tools necessary for performance testing at our disposal,
    it would seem that it's possible to define some requirements around performance.
    For example, if someone is implementing a store, could we introduce a performance
    requirement that says a store can take no longer than x milliseconds to emit a
    change event? The plus side is that we could be reasonably confident about the
    performance of our architecture, right down to the component level. The down side
    is the complexity involved.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们拥有必要的性能测试工具，似乎可以定义一些关于性能的要求。例如，如果有人正在实现一个存储库，我们能否引入一个性能要求，即存储库在发出更改事件时不能超过x毫秒？好处是我们可以对我们的架构的性能有合理的信心，甚至到组件级别。坏处是涉及的复杂性。
- en: For one thing, development of new code would noticeably slow down, because not
    only would we have to test for functional correctness, we would also have a strict
    performance bar to clear. This takes time, and the payoff is most likely nothing.
    Let's say that we end up spending a bunch of time improving the performance of
    some component because it's barely failing the requirement. This would mean that
    we're spinning our wheels on something that's intangible to the user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，新代码的开发会明显减慢，因为我们不仅要测试功能正确性，还要达到严格性能标准。这需要时间，而且回报可能微乎其微。假设我们花费大量时间提高某个组件的性能，因为它勉强满足要求。这意味着我们在做一些对用户来说无形的事情上白费力气。
- en: This isn't to say that performance testing cannot be automated or that it shouldn't
    be done at all. We simply have to be smart about where we invest our time testing
    the performance of our Flux code. The ultimate decider of performance is the user,
    so it's difficult to set concrete requirements that mean *good enough* performance,
    but it's really easy to waste time trying to achieve optimal performance that
    nobody will notice, least of all your customers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说性能测试不能自动化，或者根本不应该进行。我们只是需要明智地选择在哪里投入我们的时间来测试Flux代码的性能。性能的最终决定者是用户，因此很难设定具体的要求，这些要求意味着“足够好”的性能，但尝试达到无人能察觉的优化性能却很容易浪费时间。
- en: Profiling tools
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析工具
- en: The various profiling tools available to us through a web browser are often
    enough to address any performance issues in our interface. These include the components
    that make up our Flux architecture. In this section, we'll go over the three main
    tools found in browser developer tools that we'll want to use to profile our Flux
    architecture.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络浏览器提供的各种分析工具通常足以解决我们界面中出现的任何性能问题。这些工具包括构成我们Flux架构的组件。在本节中，我们将介绍浏览器开发者工具中发现的三个主要工具，我们将使用这些工具来分析我们的Flux架构。
- en: First are the action creator functions, specifically asynchronous functions.
    Then we'll think about the memory consumption of our Flux components. Finally,
    we'll discuss CPU utilization.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是动作创建函数，特别是异步函数。然后我们将考虑我们的Flux组件的内存消耗。最后，我们将讨论CPU利用率。
- en: Asynchronous actions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步操作
- en: The network is always going to be the slowest layer of the application. Even
    if the API call we're making is relatively fast, it's still slow compared to other
    JavaScript code. If our application didn't make any network requests, it would
    be blazing fast. It also wouldn't be of much use. Generally speaking, JavaScript
    applications rely on remote API endpoints as their data resources.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 网络总是应用中最慢的一层。即使我们进行的API调用相对较快，它与其他JavaScript代码相比仍然很慢。如果我们的应用程序没有进行任何网络请求，它将会非常快。但它也不会很有用。一般来说，JavaScript应用程序依赖于远程API端点作为它们的数据资源。
- en: To make sure that these network calls aren't causing performance issues, we
    can leverage the networking profiler of the browser developer tools. This shows
    us, in great detail, what any given request is doing, and how long it takes to
    do it. For example, if the server is taking a long time to respond to a request,
    this will be reflected in the timeline of the request.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这些网络调用不会导致性能问题，我们可以利用浏览器开发者工具的网络分析器。这以极大的细节显示了任何给定请求正在做什么，以及它需要多长时间来完成。例如，如果服务器响应请求需要很长时间，这将在请求的时间线上反映出来。
- en: Using this tool, we can also see the number of requests that are outstanding
    at any given point. For instance, maybe there's a page in our application that's
    hammering the server with requests and overwhelming it. In that case, we have
    to rethink the design. Each request that we look at in this tool allows us to
    drill down into the code that initiated the request. In Flux applications, this
    should always be an action creator function. With this tool, we always know which
    action creator functions are problematic from a network point of view and we can
    do something about them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个工具，我们还可以看到在任何给定时刻未完成的请求数量。例如，可能在我们应用程序中有一个页面正在用请求猛烈地敲击服务器并使其不堪重负。在这种情况下，我们必须重新思考设计。在这个工具中查看的每个请求都允许我们深入到发起请求的代码。在Flux应用程序中，这应该始终是一个动作创建函数。有了这个工具，我们总是知道哪些动作创建函数从网络角度来看是有问题的，并且我们可以对它们采取措施。
- en: Store memory
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储内存
- en: The next developer tool that can help us test the performance of our Flux architecture
    is the memory profiler. Memory is obviously something that we have to be careful
    with. On the one hand, we have to be considerate of other applications running
    on the system and avoid hogging memory. On the other hand, when we try to be careful
    with memory, we end up with frequent allocations/deallocations, triggering the
    garbage collector. It's hard to put a number on the maximum amount of memory a
    component should use. The application needs what it needs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个可以帮助我们测试Flux架构性能的开发者工具是内存分析器。内存显然是我们必须小心处理的东西。一方面，我们必须考虑系统上运行的其它应用程序，避免占用过多内存。另一方面，当我们试图小心处理内存时，我们最终会频繁地进行分配/释放，触发垃圾回收器。很难确定一个组件应该使用的最大内存量。应用程序需要它需要的。
- en: In terms of Flux, we're most interested in what the memory profiler can tell
    us about our stores. Remember, stores are where we're likely to face scalability
    issues as our application grows, because they'll have to handle more input data.
    Of course, we'll also want to keep an eye on the memory consumed by our view components
    as well, but ultimately it's the stores that control how much or how little memory
    views will consume.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flux方面，我们最感兴趣的是内存分析器能告诉我们关于我们存储的信息。记住，随着应用程序的增长，我们很可能会在存储上遇到可扩展性问题，因为它们将不得不处理更多的输入数据。当然，我们也会想关注我们的视图组件消耗的内存，但最终是存储控制视图将消耗多少或多少内存。
- en: There are two ways the memory profiler can help us better understand the memory
    consumption of our Flux stores. First, there's the memory timeline. This view
    shows how memory is allocated/deallocated over time. This is useful because it
    lets us see how memory is used as we interact with the application the same way
    a user would. Second, the memory profiler lets us take a snapshot of the current
    memory allocations. This is how we determine the type of data that's being allocated,
    and the code that's doing it. For example, with a snapshot, we can see which store
    is taking up the most memory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析器有两种方式可以帮助我们更好地理解Flux存储的内存消耗。首先，是内存时间线。这个视图显示了内存随时间分配/释放的情况。这很有用，因为它让我们看到内存是如何被使用的，就像用户与应用程序交互一样。其次，内存分析器允许我们拍摄当前内存分配的快照。这是我们确定正在分配的数据类型及其代码的方式。例如，通过快照，我们可以看到哪个存储占用了最多的内存。
- en: CPU utilization
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU利用率
- en: As you saw in the previous section on the memory profiler, the frequent garbage
    collections can cause issues with responsiveness. This is because the garbage
    collector will block any other JavaScript code from running. The CPU profiler
    can actually show us how much CPU time the garbage collector is taking away from
    other code. If it's a lot, then we can figure out a better memory strategy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个关于内存分析器的章节所示，频繁的垃圾回收可能会影响响应性。这是因为垃圾回收器会阻止其他JavaScript代码的运行。CPU分析器实际上可以显示垃圾回收器从其他代码中夺走了多少CPU时间。如果很多，那么我们可以找到更好的内存策略。
- en: Once again, however, we should turn our attention to the store components of
    our Flux architecture when profiling the CPU. The simple reason is that this will
    have the biggest return on investment. The scalability issues that we're likely
    to face are centered around the data transformation functions used to handle action
    payloads within stores. Unless these functions are efficient enough to handle
    the data that enters the system, the architecture won't scale because the CPU
    is being over-utilized by our code. And with that, we'll turn our attention to
    benchmarking the functions that are critical to the scalability of our systems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们分析CPU时，我们再次应该将注意力转向Flux架构的商店组件。简单的原因是这将带来最大的投资回报。我们可能面临的可扩展性问题集中在用于处理商店中动作负载的数据转换函数。除非这些函数足够高效以处理进入系统的数据，否则架构不会扩展，因为我们的代码过度利用了CPU。有了这个，我们将把注意力转向基准测试对我们系统可扩展性至关重要的函数。
- en: Benchmarking tools
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试工具
- en: On one end of the performance testing spectrum, there's user-perceived performance.
    This is where one of our customers is complaining about laggyness, and sure enough,
    it's easy for us to replicate the problem. This could be an issue with view components,
    network requests, or something in our store that's causing the suboptimal user
    experience. On the other end of the spectrum, we have raw benchmarking of code,
    where we want accurate timings to ensure that we're using the most efficient implementation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能测试的谱系一端，是用户感知的性能。这就是我们的客户在抱怨卡顿的地方，而且确实很容易复现这个问题。这可能是因为视图组件、网络请求，或者是我们商店中某些导致用户体验不佳的问题。在谱系的另一端，我们有代码的原始基准测试，我们希望获得准确的计时，以确保我们使用的是最高效的实现。
- en: In this section, we'll briefly introduce the concept of benchmarking, and then
    we'll show an example that uses `Benchmark.js` to compare two state transformation
    implementations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍基准测试的概念，然后我们将展示一个使用 `Benchmark.js` 比较两种状态转换实现的示例。
- en: Benchmarking code
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试代码
- en: When we benchmark our code, we're comparing one implementation to another, or
    we can compare three or more implementations. The key is to isolate the implementations
    from any other components and to make sure that they each have the same input
    and produce the same output. Benchmarks are like unit tests in a sense, because
    we have a unit of code that we isolate as a unit and use a tool to measure and
    test its performance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们基准测试我们的代码时，我们是在比较一种实现与另一种实现，或者我们可以比较三个或更多实现。关键是隔离实现与其他组件，并确保它们各自有相同的输入并产生相同的输出。在某种程度上，基准测试就像单元测试，因为我们有一个被隔离作为单元的代码块，并使用工具来测量和测试其性能。
- en: One challenge with performing these sorts of micro-benchmarks is accurate timing.
    Another challenge is creating an environment that isn't disrupted by other things.
    For example, trying to run a JavaScript benchmark in a web page is likely to face
    interference by other things, such as the DOM. `Benchmark.js` handles the nitty-gritty
    details of getting the most accurate measurement for our code. With that said,
    let's jump into an example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这类微基准测试时，一个挑战是准确的计时。另一个挑战是创建一个不受其他事物干扰的环境。例如，尝试在网页中运行JavaScript基准测试可能会面临来自DOM等事物的干扰。`Benchmark.js`处理获取我们代码最准确测量的繁琐细节。话虽如此，让我们跳入一个示例。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike unit tests, benchmarks aren't necessarily something we want to keep around
    and maintain forever. It's simply too much of a burden, and the value of benchmarks
    tends to diminish when there's hundreds of them. There are probably a few exceptions,
    where we want to keep benchmarks in the repository for illustrative purposes.
    But generally speaking, benchmarks can safely be discarded once the code has been
    implemented or once the performance of existing code has been improved.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试不同，基准测试不一定是我们希望保留和维护的东西。这会带来太多的负担，而且当有成百上千个基准测试时，基准测试的价值往往会降低。可能有一些例外，我们希望为了说明目的而在存储库中保留基准测试。但一般来说，一旦代码实现或现有代码的性能得到改善，基准测试可以安全地被丢弃。
- en: State transformations
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态转换
- en: 'The state transformations that happen inside of Flux stores have the potential
    to bring the system to a halt when we try to scale it up. As you know, the rest
    of the Flux components in our architecture scale well. It''s the added request
    volume and added data volume that cause problems. Low-level functions that transform
    this data need to perform well. We can use a tool like `Benchmark.js` to build
    benchmarks for the code that works with store data. Here''s an example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试扩展系统时，Flux 存储内部发生的状态转换有可能使系统停止运行。正如你所知，我们架构中的其他 Flux 组件扩展性良好。问题在于增加的请求量和数据量。需要高效执行转换这些数据的基本函数。我们可以使用
    `Benchmark.js` 这样的工具为与存储数据一起工作的代码构建基准测试。以下是一个示例：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we just need to add two or more benchmark functions to the suite,
    then run it. The output is specific performance data that compares the various
    implementations. In this case, we're filtering and mapping an array of 10,000
    items. The `"for..of"` approach stands out as the best bet performance-wise.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只需将两个或更多基准函数添加到测试套件中，然后运行它。输出是特定性能数据，比较了各种实现。在这种情况下，我们正在过滤和映射一个包含 10,000
    项的数组。从性能角度来看，“for..of”方法脱颖而出，是最佳选择。
- en: What's important about benchmarking is that it can rule out false assumptions
    fairly easily. For example, we might assume that because `"for..of"` outperforms
    the alternative implementations, that it's automatically the best choice. Well,
    the two alternatives aren't that far behind. So if we really would rather implement
    the functionality using `reduce()`, there's probably no scaling risk in doing
    so.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的重要之处在于它可以很容易地排除错误的假设。例如，我们可能会假设因为“for..of”比其他实现表现更好，所以它自动是最好的选择。然而，这两种替代方案并不落后太多。所以，如果我们真的想使用
    `reduce()` 实现功能，这样做可能没有扩展风险。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code that ships with this book implements a few tricks to make this example
    work with ES2015 syntax using Babel. This is an especially good idea if you're
    transpiling your production code using Babel, so your benchmarks reflect reality.
    It's also handy to add an `npm bench` script to your `package.json` for easy access.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书附带代码实现了一些技巧，以便使用 Babel 使此示例与 ES2015 语法兼容。如果你使用 Babel 对生产代码进行转换，这是一个特别好的主意，这样你的基准测试就能反映现实情况。同时，在
    `package.json` 中添加一个 `npm bench` 脚本也很方便，以便轻松访问。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The focus of this chapter has been testing our Flux architectures. There are
    two types of tests that we employ to do this: functional and performance. With
    functional units, we verify that the units of code that make up our Flux architecture
    are behaving as expected. With performance units, we''re validating that the code
    is performing at the expected levels.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是测试我们的 Flux 架构。我们采用两种类型的测试来完成这项工作：功能和性能。使用功能单元，我们验证构成我们的 Flux 架构的代码单元是否按预期运行。使用性能单元，我们验证代码是否达到预期的性能水平。
- en: We introduced the Jest testing framework to implement unit tests for our action
    creators and our stores. We then discussed the various tools in the browser that
    can help us troubleshoot performance issues at a high-level. These are the types
    of things that impact the user experience in a tangible way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了 Jest 测试框架，用于为我们的动作创建者和存储实现单元测试。然后，我们讨论了浏览器中可以帮助我们解决高级别性能问题的各种工具。这些都是以可感知的方式影响用户体验的类型。
- en: We closed the chapter with a look at benchmarking our code. This is something
    that takes place at a low-level and is most likely related to the state transformation
    functionality of our stores. Now it's time to consider the implications a Flux
    architecture has on the overall software development lifecycle.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以对代码进行基准测试来结束这一章。这是在低级别发生的事情，很可能与我们的存储的状态转换功能有关。现在，我们需要考虑 Flux 架构对整个软件开发生命周期的影响。
