- en: MongoDB, Mongoose, and REST APIs – Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB，Mongoose和REST API - 第2部分
- en: In this chapter, you're finally going to move out of the `playground` folder,
    and we're going to start playing with Mongoose. We'll be connecting to our MongoDB
    database, creating a model, talking about what exactly a model is, and finally,
    we'll be saving some data to the database using Mongoose.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您最终将离开`playground`文件夹，并且我们将开始使用Mongoose。我们将连接到我们的MongoDB数据库，创建一个模型，讨论模型的确切含义，最后，我们将使用Mongoose向数据库保存一些数据。
- en: Setting up Mongoose
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Mongoose
- en: We're not going to need any of the files we currently have open in the `playground`
    directory, so we can go ahead and close them. We're also going to wipe the `TodoApp`
    database using Robomongo. The data inside of Robomongo is going to be a little
    different than the data we'll be using going forward, and it's best to start with
    a clean slate. There is no need to create the database after you drop it because
    if you remember, MongoDB is going to automatically create the database once you
    start writing data to it. With this in place, we can now explore Mongoose, and
    the first thing I always like to do is check out the website.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在`playground`目录中打开的任何文件，所以我们可以关闭它们。我们还将使用Robomongo清除`TodoApp`数据库。Robomongo中的数据将与我们将来使用的数据有些不同，最好从头开始。在删除数据库后，无需创建数据库，因为如果您记得，一旦开始向数据库写入数据，MongoDB将自动创建数据库。有了这个准备，我们现在可以探索Mongoose，我总是喜欢做的第一件事是查看网站。
- en: 'You can check the website out by going to [mongoosejs.com](http://mongoosejs.com/):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问[mongoosejs.com](http://mongoosejs.com/)来查看网站：
- en: '![](img/882fe839-f4d9-4eee-8119-1169fcfc4185.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/882fe839-f4d9-4eee-8119-1169fcfc4185.png)'
- en: Here, you can find examples, guides, a full list of plugins, and a ton of great
    resources. The read the docs resource is the one I use the most. It includes tutorial-like
    guides that have examples, as well as documentation covering every single feature
    of the library. It really is a fantastic resource.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以找到示例，指南，插件的完整列表以及大量的优秀资源。我最常使用的是阅读文档资源。它包括类似教程的指南，具有示例，以及覆盖库的每个功能的文档。这真的是一个很棒的资源。
- en: If you ever want to learn about something or want to use a feature we don't
    cover in the book, I highly recommend coming to this page, taking the examples,
    copying and pasting some code, playing around with it, and figuring out how it
    works. We're going to be covering most of the essential Mongoose features right
    now.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解某些内容或者想使用书中未涵盖的功能，我强烈建议您来到这个页面，获取一些例子，复制和粘贴一些代码，玩弄一下，并弄清楚它是如何工作的。我们现在将介绍大部分基本的Mongoose功能。
- en: Setting up root of the project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目的根目录
- en: 'The first thing we need to do before we can actually use Mongoose in our project
    is install it. Over in the Terminal, I''m going to install it using `npm i`, which
    is short for `npm install`. The module name itself is called `mongoose`, and we''ll
    be installing the most recent version, which is going to be version `5.0.6`. We''re
    going to tack on the `--save` flag since we will need Mongoose for both production
    and testing purposes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际在项目中使用Mongoose之前，我们需要做的第一件事是安装它。在终端中，我将使用`npm i`来安装它，这是`npm install`的缩写。模块名称本身称为`mongoose`，我们将安装最新版本，即`5.0.6`版本。我们将添加`--save`标志，因为我们将需要Mongoose用于生产和测试目的。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we run this command, it's going to go off and do its thing. We can move
    into Atom and start creating the files we're going to need to run our application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行这个命令，它就会开始执行。我们可以进入Atom并开始创建我们运行应用程序所需的文件。
- en: First up, let's make a folder in the root of the project. This folder is going
    to be called `server`, and everything related to our server is going to get stored
    in the `server` folder. The first file we're going to create is going to be called
    `server.js`. This is going to be the root of our application. When you want to
    start up your Node app, you're going to run this file. This file will get everything
    ready to go.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在项目的根目录中创建一个文件夹。这个文件夹将被称为`server`，与我们的服务器相关的所有内容都将存储在`server`文件夹中。我们将创建的第一个文件将被称为`server.js`。这将是我们应用程序的根。当您想启动您的Node应用程序时，您将运行这个文件。这个文件将准备好一切。
- en: The first thing we need to do inside of `server.js` is load in Mongoose. We're
    going to make a variable called `mongoose`, and we're going to acquire it from
    the `mongoose` library.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`server.js`中需要做的第一件事是加载Mongoose。我们将创建一个名为`mongoose`的变量，并从`mongoose`库中获取它。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have the mongoose variable in place, we need to go ahead and connect
    to the database because we can't start writing data to the database until Mongoose
    knows how to connect.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`mongoose`变量，我们需要继续连接到数据库，因为在Mongoose知道如何连接之前，我们无法开始向数据库写入数据。
- en: Connecting mongoose to database
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接mongoose到数据库
- en: The process of connecting is going to be pretty similar to what we did inside
    of our MongoDB scripts; for example, the `mongodb-connect` script. Here, we called
    `MongoClient.connect`, passing in a URL. What we're going to do for Mongoose is
    call `mongoose.connect`, passing in the exact same URL; `mongodb` is the protocol,
    call in `//`. We're going to be connecting to our `localhost` database on port
    `27017`. Next up is going to be our `/`, followed by the database name, and we'll
    continue to use the `TodoApp` database, which we used over in the `mongodb-connect`
    script.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的过程将与我们在MongoDB脚本中所做的非常相似；例如，`mongodb-connect`脚本。在这里，我们调用了`MongoClient.connect`，传入了一个URL。对于Mongoose，我们要做的是调用`mongoose.connect`，传入完全相同的URL；`mongodb`是协议，调用`//`。我们将连接到我们的`localhost`数据库，端口为`27017`。接下来是我们的`/`，然后是数据库名称，我们将继续使用`TodoApp`数据库，这是我们在`mongodb-connect`脚本中使用的。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is where the two functions differ. The `MongoClient.connect` method takes
    a callback, and that is when we have access to the database. Mongoose is a lot
    more complex. This is good, because it means our code can be a lot simpler. Mongoose
    is maintaining the connection over time. Imagine I try to save something, `save
    new something`. Now obviously, by the time this save statement runs, `mongoose.connect`
    is not going to have had time to make a database request to connect. That's going
    to take a few milliseconds at least. This statement is going to run almost right
    away.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这两个函数的不同之处。`MongoClient.connect`方法接受一个回调函数，那时我们就可以访问数据库。Mongoose要复杂得多。这是好事，因为这意味着我们的代码可以简单得多。Mongoose会随着时间维护连接。想象一下，我尝试保存一些东西，`save
    new something`。现在显然，当这个保存语句运行时，`mongoose.connect`还没有时间去发出数据库请求来连接。那至少需要几毫秒。这个语句几乎会立即运行。
- en: Behind the scenes, Mongoose is going to be waiting for the connection before
    it ever actually tries to make the query, and this is one of the great advantages
    of Mongoose. We don't have to micromanage the order in which things happen; Mongoose
    takes care of that for us.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Mongoose将等待连接，然后才会尝试进行查询，这是Mongoose的一个巨大优势之一。我们不需要微观管理事情发生的顺序；Mongoose会为我们处理。
- en: There is one more thing I want to configure just above `mongoose.connect`. We've
    been using promises in this course, and we're going to continue using them. Mongoose
    supports callbacks by default, but callbacks really aren't how I like to program.
    I prefer promises as they're a lot simpler to chain, manage, and scale. Right
    above the `mongoose.connect` statement, we're going to tell Mongoose which promise
    library we want to use. If you're not familiar with the history of promises, it
    didn't have to always be something built into JavaScript. Promises originally
    came from libraries like Bluebird. It was an idea a developer had, and they created
    a library. People started using it, so much so that they added it to the language.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想在`mongoose.connect`的上面配置一件事。在这门课程中，我们一直在使用promises，并且我们将继续使用它们。Mongoose默认支持回调，但回调并不是我喜欢编程的方式。我更喜欢promises，因为它们更容易链式、管理和扩展。在`mongoose.connect`语句的上面，我们将告诉Mongoose我们想要使用哪个promise库。如果你不熟悉promise的历史，它并不一定总是内置在JavaScript中的。Promise最初来自像Bluebird这样的库。这是一个开发者的想法，他们创建了一个库。人们开始使用它，以至于他们将其添加到了语言中。
- en: 'In our case, we need to tell Mongoose that we want to use the built- in promise
    library as opposed to some third-party one. We''re going to set `mongoose.Promise`
    equal to `global.Promise`, and this is something we''re only going to have to
    do once:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要告诉Mongoose我们想要使用内置的promise库，而不是一些第三方的库。我们将把`mongoose.Promise`设置为`global.Promise`，这是我们只需要做一次的事情：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We're just going to put these two lines in `server.js`; we don't have to add
    them anywhere else. With this in place, Mongoose is now configured. We've connected
    to our database and we've set it up to use promises, which is exactly what we
    want. The next thing we're going to do is create a model.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要把这两行放在`server.js`中；我们不需要在其他地方添加它们。有了这个配置，Mongoose现在已经配置好了。我们已经连接到了我们的数据库，并设置它使用promises，这正是我们想要的。接下来我们要做的是创建一个模型。
- en: Creating the todo model
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建待办事项模型
- en: Now, as we have already talked about, inside of MongoDB, your collections can
    store anything. I could have a collection with a document that has an age property,
    and that's it. I could have a different document in the same collection with a
    property name; that's it. These two documents are different, but they're both
    in the same collection. Mongoose likes to keep things a little more organized
    than that. What we're going to do is create a model for everything we want to
    store. In this example, we'll be creating a Todo model.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们已经讨论过的，MongoDB中，你的集合可以存储任何东西。我可以有一个具有年龄属性的文档的集合，就是这样。我可以在同一个集合中有一个不同的文档，具有一个名字属性；就是这样。这两个文档是不同的，但它们都在同一个集合中。Mongoose喜欢保持事情比那更有组织性一些。我们要做的是为我们想要存储的每样东西创建一个模型。在这个例子中，我们将创建一个待办事项模型。
- en: Now, a Todo is going to have certain attributes. It's going to have a `text`
    attribute, which we know is a string; it's going to have a `completed` attribute,
    which we know is a Boolean. These are things we can define. What we're going to
    do is create a Mongoose model so Mongoose knows how to store our data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，待办事项将具有某些属性。它将有一个`text`属性，我们知道它是一个字符串；它将有一个`completed`属性，我们知道它是一个布尔值。这些是我们可以定义的。我们要做的是创建一个Mongoose模型，这样Mongoose就知道如何存储我们的数据。
- en: Right below the `mongoose.connect` statement, let's make a variable called `Todo`,
    and we're going to set that equal to `mongoose.model`. The `model` is the method
    we're going to use to create a new model. It takes two arguments. The first one
    is the string name. I'm going to match the variable name on the left, `Todo`,
    and the second argument is going to be an object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mongoose.connect`语句的下面，让我们创建一个名为`Todo`的变量，并将其设置为`mongoose.model`。`model`是我们将用来创建新模型的方法。它接受两个参数。第一个是字符串名称。我将匹配左边的变量名`Todo`，第二个参数将是一个对象。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This object is going to define the various properties for a model. For example,
    the Todo model is going to have a `text` property, so we can set that up. Then,
    we can set text equal to an object, and we can configure exactly what text is.
    We can do the same thing for `completed`. We''re going to have a completed property,
    and we''re going to want to specify certain things. Maybe it''s required; maybe
    we have custom validators; maybe we want to set the type. We''re also going to
    add one final one, `completedApp`, and this is going to let us know when a Todo
    was completed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象将定义模型的各种属性。例如，待办事项模型将有一个`text`属性，所以我们可以设置它。然后，我们可以将text设置为一个对象，并且可以配置text的具体内容。我们也可以为`completed`做同样的事情。我们将有一个completed属性，并且我们将要指定某些内容。也许它是必需的；也许我们有自定义验证器；也许我们想设置类型。我们还将添加一个最终的属性`completedApp`，这将让我们知道何时完成了一个待办事项：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A `createdApp` property might sound useful, but if you remember the MongoDB
    `ObjectId`, that already has the `createdAt` timestamp built in, so there's no
    reason to add a `createdApp` property here. `completedAt`, on the other hand,
    is going to add value. It lets you know exactly when you have completed a Todo.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`createdApp`属性可能听起来有用，但如果你记得MongoDB的`ObjectId`，它已经内置了`createdAt`时间戳，所以在这里没有理由添加`createdApp`属性。另一方面，`completedAt`将增加价值。它让你确切地知道你何时完成了一个Todo。'
- en: From here, we can start specifying the details about each attribute, and there's
    a ton of different options available inside of the Mongoose documentation. For
    now though, we're going to keep things really simple by specifying the type for
    each, for example, `text`. We can set `type` equal to `String`. It's always going
    to be a string; it wouldn't make sense if it was a Boolean or a number.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以开始指定每个属性的细节，Mongoose文档中有大量不同的选项可用。但现在，我们将通过为每个属性指定类型来保持简单，例如`text`。我们可以将`type`设置为`String`。它始终将是一个字符串；如果它是布尔值或数字就没有意义了。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we can set a type for `completed`. It needs to be a Boolean; there's no
    way around that. We're going to set `type` equal to `Boolean`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以为`completed`设置一个类型。它需要是一个布尔值；没有其他办法。我们将把`type`设置为`Boolean`。
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last one we have is `completedAt`. This is going to be a regular old Unix
    timestamp, which means it''s just a number, so we can set the `type` for `completedAt`
    equal to `Number`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个属性是`completedAt`。这将是一个普通的Unix时间戳，这意味着它只是一个数字，所以我们可以将`completedAt`的`type`设置为`Number`。
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this in place, we now have a working Mongoose model. It''s a model of
    a Todo that has a few properties: `text`, `completed`, and `completedAt`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有一个可用的Mongoose模型。这是一个具有几个属性的Todo模型：`text`，`completed`和`completedAt`。
- en: Now in order to illustrate exactly how we create instances of this, we're going
    to go ahead and just add one Todo. We're not going to worry about fetching data,
    updating data, or deleting data, although that is stuff that Mongoose supports.
    We'll be worrying about that in the following sections, as we start building out
    the individual routes for our API. For now, we're going to go over just a very
    quick example of creating a brand-new Todo.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准确说明我们如何创建这些实例，我们将继续添加一个Todo。我们不会担心获取数据、更新数据或删除数据，尽管这是Mongoose支持的功能。我们将在接下来的部分中担心这些问题，因为我们将开始为API的各个路由构建。现在，我们将简要介绍如何创建一个全新的Todo的示例。
- en: Creating a brand-new Todo
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个全新的Todo
- en: I'm going to make a variable called `newTodo`, although you could call it anything
    you like; the name here is not important. What is important though is that you
    run the Todo function. This is what comes back from `mongoose.model` as a constructor
    function. We want to add the `new` keyword in front of it because we're creating
    a new instance of `Todo`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建一个名为`newTodo`的变量，尽管你可以给它取任何你喜欢的名字；这里的名字并不重要。但重要的是你运行Todo函数。这是从`mongoose.model`返回的构造函数。我们要在它前面加上`new`关键字，因为我们正在创建`Todo`的一个新实例。
- en: 'Now, the `Todo` constructor function does take an argument. It''s going to
    be an object where we can specify some of these properties. Maybe we know that
    we want `text` to equal something like `Cook dinner`. Right in the function, we
    can specify that. `text` equals a string, `Cook dinner`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Todo`构造函数确实需要一个参数。它将是一个对象，我们可以在其中指定一些这些属性。也许我们知道我们希望`text`等于`Cook dinner`之类的东西。在函数中，我们可以指定。`text`等于一个字符串，`Cook
    dinner`：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We haven't required any of our attributes, so we could just stop here. We have
    a `text` property; that's good enough. Let's go ahead and explore how to save
    this to the database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有要求任何属性，所以我们可以到此为止。我们有一个`text`属性；这已经足够了。让我们继续探讨如何将其保存到数据库。
- en: Saving the instance to the database
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将实例保存到数据库
- en: Creating a new instance alone does not actually update the MongoDB database.
    What we need to do is call a method on `newTodo`. This is going to be `newTodo.save`.
    The `newTodo.save` method is going to be responsible for actually saving `text` to
    the MongoDB database. Now, `save` returning a promise, which means we can tack
    on a `then` call and add a few callbacks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅创建一个新实例并不会实际更新MongoDB数据库。我们需要在`newTodo`上调用一个方法。这将是`newTodo.save`。`newTodo.save`方法将负责将`text`实际保存到MongoDB数据库中。现在，`save`返回一个promise，这意味着我们可以添加一个`then`调用并添加一些回调。
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''ll add the callbacks for when the data either gets saved or when an error
    occurs because it can''t save for some reason. Maybe the connection failed, or
    maybe the model is not valid. Either way, for now we''ll just print a little string,
    `console.log(Unable to save todo)`. Up above, in the success callback, we''re
    actually going to get that Todo. I can call the argument `doc`, and I can print
    it to the screen, `console.log`. I''ll print a little message first: `Saved todo`,
    and the second argument will be the actual document:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为数据保存成功或出现错误时添加回调。也许连接失败了，或者模型无效。无论如何，现在我们只是打印一个小字符串，`console.log(Unable
    to save todo)`。在上面的成功回调中，我们实际上将得到那个Todo。我可以将参数称为`doc`，并将其打印到屏幕上，`console.log`。我将首先打印一条小消息：`Saved
    todo`，第二个参数将是实际的文档：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've configured Mongoose, connecting to the MongoDB database; we've created
    a model, specifying the attributes we want Todos to have; we created a new Todo;
    and finally, we saved it to the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了Mongoose，连接到了MongoDB数据库；我们创建了一个模型，指定了我们希望Todos具有的属性；我们创建了一个新的Todo；最后，我们将其保存到了数据库中。
- en: Running the Todos script
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Todos脚本
- en: 'We''re going to run the script from the Terminal. I''m going to kick things
    off by running `node`. The file we''re running is in the `server` directory, and
    it''s called `server.js`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从终端运行脚本。我将通过运行`node`来启动，我们要运行的文件位于`server`目录中，名为`server.js`：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/ed659d0a-1b42-4d15-a9ad-630e16843426.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed659d0a-1b42-4d15-a9ad-630e16843426.png)'
- en: When we run the file, we get `Saved todo`, meaning that things went well. We
    have an object right here with an `_id` property as expected; the `text` property,
    which we specified; and the `__v` property. The `__v` property means version,
    and it comes from Mongoose. We'll talk about it later, but essentially it keeps
    track of the various model changes over time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行文件时，我们得到`Saved todo`，这意味着事情进行得很顺利。我们在这里有一个对象，有一个预期的`_id`属性；我们指定的`text`属性；和`__v`属性。`__v`属性表示版本，它来自mongoose。我们稍后会谈论它，但基本上它会跟踪随时间的各种模型更改。
- en: 'If we open up Robomongo, we''re going to see the exact same data. I''m going
    to right-click the connection and refresh it. Here, we have our `TodoApp`. Inside
    of the `TodoApp` database, we have our `todos` collection:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开Robomongo，我们会看到完全相同的数据。我要右键单击连接并刷新它。在这里，我们有我们的`TodoApp`。在`TodoApp`数据库中，我们有我们的`todos`集合：
- en: '![](img/b21da561-c5a1-4a56-8a79-7b8f11564915.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b21da561-c5a1-4a56-8a79-7b8f11564915.png)'
- en: 'Notice that Mongoose automatically lowercased and pluralized Todo. I''m going
    to view the documents:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: mongoose自动将Todo转换为小写并复数形式。我要查看文档：
- en: '![](img/992de390-402a-4e3b-8587-0738a485e9d1.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/992de390-402a-4e3b-8587-0738a485e9d1.png)'
- en: We have our one document with the text equal to Cook dinner, exactly what we
    created over inside of Atom.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个文档，文本等于Cook dinner，就是我们在Atom中创建的。
- en: Creating a second Todo model
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建第二个Todo模型
- en: We have one Todo created using our Mongoose model. What I want you to do is
    make a second one, filling out all three values. This means you're going to make
    a new Todo with a `text` value, a `completed` Boolean; go ahead and set that to
    `true`; and a `completedAt` timestamp, which you can set to any number you like.
    Then, I want you to go ahead and save it; print it to the screen if it saves successfully;
    print an error if it saves poorly. Then, finally, run it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的mongoose模型创建了一个Todo。我希望你做的是创建第二个，填写所有三个值。这意味着你要创建一个新的Todo，有一个`text`值，一个`completed`布尔值；继续设置为`true`；和一个`completedAt`时间戳，你可以设置为任何你喜欢的数字。然后，我希望你继续保存它；如果保存成功，将其打印到屏幕上；如果保存不好，打印一个错误。最后，运行它。
- en: The first thing I would have done is made a new variable down below. I'm going
    to make a variable called `otherTodo`, setting it equal to a `new` instance of
    the `Todo` model.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先要做的是在下面创建一个新变量。我要创建一个名为`otherTodo`的变量，将其设置为`Todo`模型的一个`new`实例。
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From here, we can pass in our one argument, which is going to be the object,
    and we can specify all of these values. I can set `text` equal to whatever I like,
    for example, `Feed the cat`. I can set the `completed` value equal to `true`,
    and I can set `completedAt` equal to any number. Anything lower than 0, like -1,
    is going to go backwards from 1970, which is where 0 is. Anything positive is
    going to be where we're at, and we'll talk about time-stamps more later. For now,
    I'm going to go with something like `123`, which would basically be two minutes
    into the year 1970.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以传入我们的一个参数，这将是对象，并且我们可以指定所有这些值。我可以将`text`设置为任何我喜欢的值，例如`Feed the cat`。我可以将`completed`值设置为`true`，我可以将`completedAt`设置为任何数字。任何小于0的值，比如-1，都会从1970年开始倒数。任何正数都将是我们所在的位置，我们稍后会更多地讨论时间戳。现在，我要选择类似`123`的东西，基本上是1970年的两分钟。
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this in place, we now just need to call `save`. I'm going to call `otherTodo.save`.
    This is what's actually going to write to the MongoDB database. I am going to
    tack on a `then` callback, because I do want to do something once the save is
    complete. If the `save` method worked, we're going to get our `doc`, and I'm going
    to print it to the screen. I'm going to use that pretty-print system we talked
    about earlier, `JSON.stringify`, passing in the actual object, `undefined`, and
    `2`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在只需要调用`save`。我要调用`otherTodo.save`。这实际上是要写入到MongoDB数据库的。我要添加一个`then`回调，因为我确实想在保存完成后做一些事情。如果`save`方法成功，我们将得到我们的`doc`，我要将其打印到屏幕上。我要使用我们之前谈到的漂亮打印系统，`JSON.stringify`，传入实际对象，`undefined`和`2`。
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You don''t need to do this; you can print it in any way you like. Next up,
    I''m going to print a little message if things go poorly: `console.log(''Unable
    to save'', e)`. It''ll pass along that error object, so if someone''s reading
    the logs, they can see exactly why the call failed:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要这样做；你可以以任何你喜欢的方式打印它。接下来，如果事情进行得不好，我要打印一条小消息：`console.log('Unable to save',
    e)`。它会传递那个错误对象，所以如果有人在阅读日志，他们可以看到调用失败的原因。
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this in place, we can now comment out that first Todo. This is going to
    prevent another one from being created, and we can rerun the script, running our
    brand-new Todo creation calls. In the Terminal, I''m going to shut down the old
    connection and start up a new one. This is going to create a brand-new Todo, and
    we have it right here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以注释掉那个第一个Todo。这将阻止创建另一个，我们可以重新运行脚本，运行我们全新的Todo创建调用。在终端中，我要关闭旧连接并启动一个新连接。这将创建一个全新的Todo，我们就在这里：
- en: '![](img/b3fac07c-6fb7-4586-8126-aaf2bec1881b.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3fac07c-6fb7-4586-8126-aaf2bec1881b.png)'
- en: 'The `text` property equals `Feed the cat`. The `completed` property sets to
    the Boolean `true`; notice there''s no quotes around it. The `completedAt` equals
    the number `123`; once again, no quotes. I can also go into Robomongo to confirm
    this. I''m going to refetch the Todos collection, and now we have two Todos:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`text`属性等于`Feed the cat`。`completed`属性设置为布尔值`true`；注意它周围没有引号。`completedAt`等于数字`123`；再次，没有引号。我也可以进入Robomongo来确认这一点。我要重新获取Todos集合，现在我们有两个Todos：'
- en: '![](img/13ecf179-7f79-4fc2-b3ff-3f9d73ba92bc.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13ecf179-7f79-4fc2-b3ff-3f9d73ba92bc.png)'
- en: On the right-hand side of the Values column, you'll also notice the Type column.
    Here, we have int32 for completedAt and the __v property. The completed property
    is a Boolean, text is a String, and the _id is an ObjectId type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在值列的右侧，你还会注意到类型列。在这里，我们有int32用于completedAt和__v属性。completed属性是一个布尔值，text是一个字符串，_id是一个ObjectId类型。
- en: There's a lot of useful information hidden inside of Robomongo. If you want
    something, they most likely have it built in. That's it for this one. We now know
    how to use Mongoose to make a connection, create a model, and finally save that
    model to the database.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Robomongo中隐藏了很多有用的信息。如果你想要什么，他们很可能已经内置了。就是这样。我们现在知道如何使用Mongoose建立连接，创建模型，最终将该模型保存到数据库中。
- en: Validators, Types, and Defaults
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证器、类型和默认值
- en: In this section, you're going to learn how to improve your Mongoose models.
    This is going to let you add things like validation. You can make certain properties
    be a requirement, and you can set up smart defaults. So, if something like completed
    is not provided, you can have a default value that gets set. All of this functionality
    is built into Mongoose; we just have to learn how to use it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何改进你的Mongoose模型。这将让你添加诸如验证之类的东西。你可以使某些属性成为必需项，并设置智能默认值。因此，如果没有提供类似已完成的东西，你可以设置一个默认值。所有这些功能都内置在Mongoose中；我们只需要学会如何使用它。
- en: 'To illustrate why we''d want to set this stuff up, let''s scroll to the bottom
    of our `server` file and remove all of the properties on the `new Todo` we created.
    Then, we''re going to save the file and move into the Terminal, running the script.
    That''s going to be `node` in the `server` directory, and the file is going to
    be called `server.js`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明为什么我们要设置这些东西，让我们滚动到我们的“server”文件的底部，删除我们创建的“new Todo”上的所有属性。然后，我们将保存文件并进入终端，运行脚本。这将是在“server”目录中的“node”，文件将被称为“server.js”：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we run it, we get our new Todo, but it only has the version and ID properties:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，我们得到了我们的新Todo，但它只有版本和ID属性：
- en: '![](img/a2ac5284-4e03-4f07-a75f-b419eaad74f6.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2ac5284-4e03-4f07-a75f-b419eaad74f6.png)'
- en: All of the properties we specified in the model, `text`, `completed`, and `completedAt`,
    are nowhere to be found. That's a pretty big problem. We should not be adding
    Todos to the database if they don't have a `text` property, and things like `completed`
    should have smart defaults. No-one's going to create a Todo item if they already
    completed it, so completed should default to `false`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模型中指定的所有属性，“text”，“completed”和“completedAt”，都找不到。这是一个相当大的问题。如果它们没有“text”属性，我们不应该将Todo添加到数据库中，“completed”之类的东西应该有智能默认值。如果没有人会创建一个已经完成的Todo项目，那么“completed”应该默认为“false”。
- en: Mongoose validators
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoose验证器
- en: 'Now in order to get started, we''re going to pull up two pages in the Mongoose
    documentation, just so you know where this stuff lives if you ever want to dive
    deeper in the future. First up, we''re going to look up the validators. I''m going
    to google `mongoose validators`, and this is going to show us all of the default
    validation properties we have built in:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了开始，我们将在Mongoose文档中打开两个页面，这样你就知道这些东西的位置，如果将来想深入了解的话。首先，我们将查找验证器。我将搜索“mongoose验证器”，这将显示我们内置的所有默认验证属性：
- en: '![](img/7a3739ae-5156-4ac0-b21a-7a9f721ba7a7.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a3739ae-5156-4ac0-b21a-7a9f721ba7a7.png)'
- en: For example, we can set something as `required`, so if it's not provided it's
    going to throw an error when we try to save that model. We can also set up validators
    for things like numbers and strings, giving a `min` and `max` value or a `minlength`/`maxlength`
    value for a string.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将某些东西设置为“必需的”，所以如果没有提供，当我们尝试保存该模型时，它将抛出错误。我们还可以为数字和字符串设置验证器，为字符串设置“minlength”/“maxlength”值。
- en: 'The other page we''re going to look at is the Schemas page. To get to this,
    we''re going to google `mongoose schemas`. This is the first one, the `guide.html`
    file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查看的另一个页面是模式页面。要进入这个页面，我们将搜索“mongoose模式”。这是第一个页面，“guide.html”文件：
- en: '![](img/212abfaf-82d2-4a8f-bbaf-957f2b7b764b.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/212abfaf-82d2-4a8f-bbaf-957f2b7b764b.png)'
- en: On this page, you're going to see something slightly different from what we've
    been doing so far. They call `new Schema`, setting up all of their properties.
    This is not something we've done yet, but we will in the future. For now, you
    can consider this object, the `Schema` object, identical to the one we have over
    in Atom that we pass in as the second argument to our `mongoose.model` call.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，你将看到与我们迄今为止所做的略有不同的东西。他们称之为“新模式”，设置所有属性。这不是我们到目前为止所做的事情，但将来我们会做。现在，你可以将这个对象，即“模式”对象，视为我们在Atom中拥有的对象，作为我们的“mongoose.model”调用的第二个参数传递过去。
- en: Customizing the Todo text property
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Todo文本属性
- en: To kick things off, let's customize how Mongoose treats our `text` property.
    Currently, we tell Mongoose that we want it to be a string, but we don't have
    any validators. One of the first things we can do for the `text` property is set
    `required` equal to `true`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们自定义Mongoose如何处理我们的“text”属性。目前，我们告诉Mongoose我们希望它是一个字符串，但我们没有任何验证器。我们可以为“text”属性做的第一件事是将“required”设置为“true”。
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you set `required` equal to `true`, the value must exist, so if I were
    to try to save this Todo it would fail. And we can prove this. We can save the
    file, head over to the Terminal, shut things down, and restart it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将“required”设置为“true”时，值必须存在，所以如果我尝试保存这个Todo，它会失败。我们可以证明这一点。我们可以保存文件，转到终端，关闭一切，然后重新启动它：
- en: '![](img/c5664fc4-40e1-47a2-baff-0973a8305dc2.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5664fc4-40e1-47a2-baff-0973a8305dc2.png)'
- en: 'We get an unreadable error message. We''ll dive into this in a second, but
    for now all you need to know is that we''re getting a validation error: Todo validation
    failed, and that is fantastic.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个难以理解的错误消息。我们将在一会儿深入研究这个问题，但现在你只需要知道的是，我们得到了一个验证错误：Todo验证失败，这太棒了。
- en: 'Now, aside from just making sure the `text` property exists, we can also set
    up some custom validators. For strings, for example, we have a `minlength` validator,
    which is great. You shouldn''t be able to create a Todo whose text is an empty
    string. We can set `minlength` equal to the minimum length, which we''re is going
    to be `1` in this case:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除了确保“text”属性存在之外，我们还可以设置一些自定义验证器。例如，对于字符串，我们有一个“minlength”验证器，这很棒。你不应该能够创建一个文本为空字符串的Todo。我们可以将“minlength”设置为最小长度，在这种情况下将是“1”：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, even if we do provide a `text` property in the `otherTodo` function, let''s
    say we set `text` equal to an empty string:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使我们在`otherTodo`函数中提供了一个`text`属性，假设我们将`text`设置为空字符串：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It's still going to fail. It is indeed there but it does not pass the minlength
    validator, where the `minlength` validator must be `1`. I can save the `server`
    file, restart things over in the Terminal, and we still get a failure.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然会失败。它确实存在，但它没有通过`minlength`验证器，其中`minlength`验证器必须是`1`。我可以保存`server`文件，在终端重新启动，我们仍然会失败。
- en: 'Now aside from `required` and `minlength`, there are a couple other utilities
    that are around in the docs. One good example is something called `trim`. It''s
    fantastic for strings. Essentially, `trim` trims off any white space in the beginning
    or end of your value. If I set `trim` equal to `true`, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除了`required`和`minlength`之外，文档中还有一些其他实用程序。一个很好的例子是称为`trim`的东西。它对字符串非常有用。基本上，`trim`会修剪掉值的开头或结尾的任何空格。如果我将`trim`设置为`true`，就像这样：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It''s going to remove any leading or trailing white space. So if I try to create
    a Todo whose `text` property is just a bunch of spaces, it''s still going to fail:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它将删除任何前导或尾随空格。因此，如果我尝试创建一个`text`属性只是一堆空格的Todo，它仍然会失败：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `trim` property is going to remove all of the leading and trailing spaces,
    leaving an empty string, and if I rerun things, we still get a failure. The text
    field is invalid. If we do provide a valid value, things are going to work as
    expected. Right in the middle of all of the spaces in `otherTodo`, I''m going
    to provide a real Todo value, which is going to be `Edit this video`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim`属性将删除所有前导和尾随空格，留下一个空字符串，如果我重新运行，我们仍然会失败。文本字段无效。如果我们提供有效的值，事情将按预期工作。在`otherTodo`的所有空格中间，我将提供一个真正的Todo值，它将是`Edit
    this video`：'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we try to save this Todo, the first thing that''s going to happen is the
    spaces in the beginning and the end of the string are going to get trimmed. Then,
    it''s going to validate that this string has a minimum length of 1, which it does,
    and finally, it will save the Todo to the database. I''m going to go ahead and
    save `server.js`, restart our script, and this time around we get our Todo:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试保存这个Todo时，首先会发生的是字符串开头和结尾的空格会被修剪。然后，它会验证这个字符串的最小长度为1，它确实是，最后，它会将Todo保存到数据库。我将保存`server.js`，重新启动我们的脚本，这一次我们得到了我们的Todo：
- en: '![](img/85a25e58-55ab-40e6-b209-73bbca30dd1e.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85a25e58-55ab-40e6-b209-73bbca30dd1e.png)'
- en: The `Edit this video` text shows up as the `text` property. Those leading and
    trailing spaces have been removed, which is fantastic. Using just three properties,
    we were able to configure our `text` property, setting up some validation. Now,
    we can do similar stuff for `completed`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Edit this video`文本显示为`text`属性。那些前导和尾随空格已经被移除，这太棒了。只使用三个属性，我们就能够配置我们的`text`属性，设置一些验证。现在，我们可以为`completed`做类似的事情。'
- en: Mongoose defaults
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoose默认值
- en: For `completed`, we're not going to `require` it because the completed value
    is most likely going to default to `false`. What we can do instead is set the
    `default` property, giving this `completed` field a default value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`completed`，我们不会`require`它，因为完成值很可能默认为`false`。相反，我们可以设置`default`属性，为这个`completed`字段设置一个默认值。
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now `completed`, as we talked about earlier in the section, should default
    to `false`. There''s no reason to create a Todo if it''s already done. We can
    do the same thing for `completedAt`. If a Todo starts off not completed, then
    `completedAt` is not going to exist. It is only going to exist when the Todo has
    been completed; it''s going to be that timestamp. What I''m going to do is set
    `default` equal to `null`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`completed`，正如我们在本节中讨论的那样，应该默认为`false`。如果Todo已经完成，就没有理由创建一个Todo。我们也可以为`completedAt`做同样的事情。如果一个Todo开始时没有完成，那么`completedAt`就不会存在。只有当Todo完成时，它才会存在；它将是时间戳。我要做的是将`default`设置为`null`：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Awesome. Now, we have a pretty good schema for our Todo. We''re going to validate
    that the text is set up properly by the user, and we are going to set up the `completed`
    and `completedAt` values by our-self since we can just use defaults. With this
    in place, I can now rerun our `server` file, and here we get a better default
    Todo:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。现在，我们为我们的Todo有一个相当不错的模式。我们将验证用户是否正确设置了文本，并且我们将自己设置`completed`和`completedAt`的值，因为我们可以使用默认值。有了这个设置，我现在可以重新运行我们的`server`文件，这样我们就可以得到一个更好的默认Todo：
- en: '![](img/676dd86c-d8d0-4581-80c2-fbeac54bba33.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/676dd86c-d8d0-4581-80c2-fbeac54bba33.png)'
- en: We have the `text` property and the user provided, which has been validated
    and trimmed. Next, we have `completed` set to `false` and `completedAt` set to
    `null`; this is fantastic. We now have a foolproof schema that has good defaults
    and validation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有用户提供的`text`属性，已经经过验证和修剪。接下来，我们将`completed`设置为`false`，`completedAt`设置为`null`；这太棒了。我们现在有一个无懈可击的模式，具有良好的默认值和验证。
- en: Mongoose types
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoose类型
- en: 'If you''ve been playing around with the various types, you might have noticed
    that if you set a `type` equal to something other than the type you specified,
    in certain cases it does still work. For example, if I try to set `text` equal
    to an object, I''m going to get an error. It''s going to say hey, you tried to
    use a string, but an object showed up instead. However, if I try to set `text`
    equal to something like a number, I''m going to go with `23`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在玩各种类型，您可能已经注意到，如果您将`type`设置为除了您指定的类型之外的其他类型，在某些情况下它仍然可以工作。例如，如果我尝试将`text`设置为一个对象，我会得到一个错误。它会说，嘿，你试图使用一个字符串，但实际上出现了一个对象。但是，如果我尝试将`text`设置为一个数字，我会选择`23`：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is going to work. That''s because Mongoose is going to cast your number
    into a string, essentially wrapping it in quotes. The same thing is going to be
    true with the Boolean. If I pass in a Boolean like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将起作用。这是因为Mongoose会将您的数字转换为字符串，实质上是用引号包裹它。对于布尔值也是一样的。如果我传入一个布尔值，就像这样：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The resulting string is going to be `"true"`. I''m going to go ahead and save
    the file after setting `text` equal to `true`, and run the script:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的字符串将是`"true"`。我将在将`text`设置为`true`后保存文件，并运行脚本：
- en: '![](img/495fb8a4-dddd-40ae-b13a-667020db4ba5.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/495fb8a4-dddd-40ae-b13a-667020db4ba5.png)'
- en: 'When I do it, I get `text` equal to `true`, as shown in the preceding screenshot.
    Notice it is indeed wrapped in quotes. It''s important to be aware that typecasting
    does exist inside of Mongoose. It can easily trip you up and cause some unexpected
    errors. For now though, I am going to set `text` equal to a proper string:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我这样做时，我得到了`text`等于`true`，如前面的截图所示。请注意，它确实被引号包裹。重要的是要意识到，在Mongoose内部确实存在类型转换。它很容易让你犯错并导致一些意外的错误。但现在，我将把`text`设置为一个合适的字符串：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Creating a Mongoose user model for authentication
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为身份验证创建Mongoose用户模型
- en: Now, we're going to create a brand-new Mongoose model. First up, you're going
    to make a new `User` model. Eventually, we're going to use this for authentication.
    It's going to store stuff like an email and a password, and the Todos are going
    to be associated with that `User` so when I create one, only I can edit it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个全新的Mongoose模型。首先，你将创建一个新的`User`模型。最终，我们将用它进行身份验证。它将存储诸如电子邮件和密码之类的东西，而Todos将与该`User`关联，因此当我创建一个时，只有我可以编辑它。
- en: We'll look into all these, but for now, we're going to keep things really simple.
    On the `User` model, the only property that you need to set up is the `email`
    property. We'll set up others like `password` later, but it's going to be done
    a little differently since it needs to be secure. For now, we'll just stick with
    `email`. I want you to `require` it. I also want you to `trim` it, so if someone
    adds spaces before or after, those spaces go away. Last but not least, go ahead
    and set the `type` equal to a `String`, set type, and set `minlength` of `1`.
    Now, obviously, you'll be able to pass in a string that's not an email. We'll
    explore custom validation a little later. This is going to let us validate that
    the email is an email, but for now this is going to get us on the right track.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究所有这些，但现在，我们将保持事情非常简单。在`User`模型上，你需要设置的唯一属性是`email`属性。我们以后会设置其他属性，比如`password`，但它将以稍有不同的方式完成，因为它需要是安全的。现在，我们只需坚持`email`。我希望你对其进行`require`。我也希望你对其进行`trim`，所以如果有人在之前或之后添加了空格，那些空格就会消失。最后但并非最不重要的是，继续将`type`设置为`String`，设置类型，并将`minlength`设置为`1`。现在，显然，你可以传入一个不是电子邮件的字符串。我们以后会探索自定义验证。这将让我们验证电子邮件是否为电子邮件，但现在这将让我们走上正确的轨道。
- en: Once you have your Mongoose model created, I want you to go ahead and try to
    create a new `User`. Create one without the `email` property, and then make one
    with the email property, making sure that when you run the script, the data shows
    up as expected over in Robomongo. This data should show up in the new `Users`
    collection.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了你的Mongoose模型后，我希望你继续尝试创建一个新的`User`。创建一个没有`email`属性的`User`，然后创建一个具有`email`属性的`User`，确保当你运行脚本时，数据会如预期般显示在Robomongo中。这些数据应该显示在新的`Users`集合中。
- en: Setting up the email property
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置电子邮件属性
- en: The first thing I'm going to do is make a variable to store this new model,
    a variable called `User`, and I'm going to set that equal to `mongoose.model`,
    which is how we can make our new `User` model. The first argument, as you know,
    needs to be the string model name. I'm going to use the exact same name as I specified
    over in the variable, although it could be different. I just like to keep things
    using this pattern, where the variable equals the model name. Next up, as the
    second argument, we can specify the object where we configure all the properties
    a `User` should have.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我要做的是创建一个变量来存储这个新模型，一个名为`User`的变量，并将其设置为`mongoose.model`，这是我们可以创建新的`User`模型的方法。第一个参数，你知道，需要是字符串模型名称。我将使用与我在变量中指定的完全相同的名称，尽管它可能会有所不同。我只是喜欢保持使用这种模式，其中变量等于模型名称。接下来，作为第二个参数，我们可以指定一个对象，其中我们配置`User`应该具有的所有属性。
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now as I mentioned previously, we'll be adding others later, but for now, adding
    support for an `email` property will be good enough. There's a few things I want
    to do on this email. First up, I want to set the `type`. An email is always going
    to be a string, so we can set that `type` equal to `String`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我之前提到的，我们以后会添加其他属性，但是现在，添加对`email`属性的支持就足够了。有几件事我想在这封电子邮件上做。首先，我想设置`type`。电子邮件始终是一个字符串，因此我们可以将`type`设置为`String`。
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next up, we're going to `require` it. You can't make a user without an email,
    so I'll set `required` equal to `true`. After required, we're going to go ahead
    and `trim` that email. If someone adds spaces before or after it, it's clearly
    a mistake, so we'll go ahead and remove those for the `User` model, making our
    application just a little more user-friendly. Last but not least, what we want
    to do is set up a `minlength` validator. We'll be setting up custom validation
    later, but for now `minlength` of `1` is going to get the trick done.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对其进行`require`。你不能创建一个没有电子邮件的用户，所以我将把`required`设置为`true`。在`required`之后，我们将继续对该电子邮件进行`trim`。如果有人在它之前或之后添加了空格，显然是一个错误，所以我们将继续删除`User`模型中的那些空格，使我们的应用程序变得更加用户友好。最后但并非最不重要的是，我们要做的是设置一个`minlength`验证器。我们以后将设置自定义验证，但现在`minlength`为`1`就足够了。
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, I am going to go ahead and create a new instance of this `User` and save
    it. Before I run the script though, I will be commenting out our new Todo. Now,
    we can make a new instance of this `User` model. I'm going to make a variable
    called `user` and set it equal to `new User`, passing in any values we want to
    set on that user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将继续创建这个`User`的新实例并保存它。在运行脚本之前，我将注释掉我们的新Todo。现在，我们可以创建这个`User`模型的新实例。我将创建一个名为`user`的变量，并将其设置为`new
    User`，传入我们想要在该用户上设置的任何值。
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'I''m going to run it with nothing at first, just to make sure the validation
    is working. Next to the user variable, I can now call `user.save`. The `save`
    method returns a promise, so I can tack on a `then` callback. I''m going to add
    a success case for this one, and an error handler. The error handler will get
    that error argument, and the success case will get the doc. If things go well,
    I''ll print a message using `console.log(''User saved'', doc)`, followed by the
    `doc` argument. No need to format it for this example. I''ll do the same thing
    for the error handler, using `console.log(''Unable to save user'')` followed by
    the error object:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先不运行它，只是为了确保验证有效。现在，在用户变量旁边，我现在可以调用`user.save`。`save`方法返回一个promise，因此我可以附加一个`then`回调。我将为此添加一个成功案例和一个错误处理程序。错误处理程序将获得该错误参数，成功案例将获得doc。如果一切顺利，我将使用`console.log('User
    saved', doc)`打印一条消息，然后是`doc`参数。对于此示例，不需要为其进行格式化。对于错误处理程序，我将使用`console.log('无法保存用户')`，然后是错误对象。
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we''re creating a user with no properties, we would expect the error
    to print. I''m going to save `server.js` and restart the file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在创建一个没有属性的用户，我们希望错误会打印出来。我将保存`server.js`并重新启动文件：
- en: '![](img/16d912d6-c907-453e-8235-935e68105d61.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16d912d6-c907-453e-8235-935e68105d61.png)'
- en: 'We get our error. It''s a validation error called Path ''email'' is required.
    Mongoose is letting us know that we do indeed have an error. The email does need
    to exist, since we set `required` equal to `true`. I''m going to go ahead and
    put a value, setting `email` to my email, `andrew@example.com`, and I''ll put
    a few spaces afterwards:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了错误。这是一个名为“路径'email'是必需的”验证错误。 Mongoose让我们知道我们确实有一个错误。由于我们将`required`设置为`true`，因此电子邮件确实需要存在。我将继续放一个值，将`email`设置为我的电子邮件`andrew@example.com`，然后我会在后面放几个空格：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This time around, things should go as expected and `trim` should be trimming
    the end of that email, removing all of the spaces, and that''s exactly what we
    get:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，事情应该如预期那样进行，`trim`应该修剪该电子邮件的末尾，删除所有空格，这正是我们得到的结果：
- en: '![](img/dd0d3bfd-cd05-4808-b38d-b3fa153e95d7.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd0d3bfd-cd05-4808-b38d-b3fa153e95d7.png)'
- en: The `User` was indeed saved, which is great, and the `email` has been properly
    formatted. Now obviously, I could have put a string in like `123`, and it would
    have worked because we don't have custom validation set up just yet, but we have
    a pretty good starting point. We have the `User` model, and we have our `email`
    property set up and ready to go.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`确实已保存，这很好，`email`已经被正确格式化。显然，我也可以输入像`123`这样的字符串，它也可以工作，因为我们还没有设置自定义验证，但我们有一个相当不错的起点。我们有`User`模型，并且我们已经设置好并准备好使用`email`属性。'
- en: With this in place, we are now going to start creating the API. In the next
    section, you're going to install a tool called **Postman**, which is going to
    help us test our HTTP requests, and then we're going to create our very first
    route for our Todo REST API.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在要开始创建API。在下一节中，您将安装一个名为**Postman**的工具，它将帮助我们测试我们的HTTP请求，然后我们将为我们的Todo
    REST API创建我们的第一个路由。
- en: Installing Postman
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Postman
- en: In this section, you're going to learn how to use Postman. Postman is an essential
    tool if you're building a REST API. I have never worked with a team or on a project
    where Postman was not heavily used by every developer involved. Postman lets you
    create HTTP requests and fire them off. This makes it really easy to test that
    everything you're writing is working as expected. Now obviously, we will also
    be writing automated tests, but using Postman lets you play around with data and
    see how things work as you move through your API. It really is a fantastic tool.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用Postman。如果您正在构建REST API，Postman是一种必不可少的工具。我从未与团队合作或在项目中使用Postman不是每个开发人员都大量使用的情况。Postman允许您创建HTTP请求并将其发送。这使得测试您编写的所有内容是否按预期工作变得非常容易。显然，我们还将编写自动化测试，但使用Postman可以让您玩弄数据并在移动API时查看事物是如何工作的。这真的是一个很棒的工具。
- en: 'We''re going to head over to the browser and go to [getpostman.com](https://www.getpostman.com/),
    and here we can grab their application:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将转到浏览器并转到[getpostman.com](https://www.getpostman.com/)，在这里我们可以获取他们的应用程序：
- en: '![](img/835b7f36-2f52-4f8f-933e-ae187b98caf2.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/835b7f36-2f52-4f8f-933e-ae187b98caf2.png)'
- en: Now I'm going to be using the Chrome application. To install it, all you have
    to do is install the Chrome app from the Chrome store, click Add to Chrome, and
    it should bring you over to the page where you can open up the application. Now,
    to open up Chrome apps, you have to go to this kind of weird URL. It's `chrome://apps`.
    Here, you can view all of your apps, and we can just open up Postman by clicking
    it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将使用Chrome应用程序。要安装它，您只需从Chrome商店安装Chrome应用程序，单击“添加到Chrome”，它应该会将您带到可以打开应用程序的页面。现在，要打开Chrome应用程序，您必须转到这种奇怪的URL。它是`chrome://apps`。在这里，您可以查看所有应用程序，我们只需单击即可打开Postman。
- en: Now as I mentioned previously, Postman lets you make HTTP requests, so we're
    going to go ahead and make a few to play around with the user interface. You do
    not need to make an account, and you do not need to sign up for a paid plan. The
    paid plans are targeted towards teams of developers who need advanced features.
    We are just making basic requests on our machine; we don't need cloud storage
    or anything like that. I'm going to skip account creation, and we can go right
    to the application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正如我之前提到的，Postman允许您发出HTTP请求，因此我们将继续并进行一些操作以玩弄用户界面。您无需创建帐户，也无需注册付费计划。付费计划面向需要高级功能的开发团队。我们只是在我们的机器上进行基本请求；我们不需要云存储或类似的东西。我将跳过帐户创建，我们可以直接进入应用程序。
- en: 'Here, we can set up our request; this is what happens in the panel:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以设置我们的请求；这是面板中发生的事情：
- en: '![](img/d92b060a-975c-4a9b-a969-974129f1781e.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d92b060a-975c-4a9b-a969-974129f1781e.png)'
- en: And, in the white space, we'll be able to view the result. Let's go ahead and
    make a request to Google.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，在白色空间中，我们将能够查看结果。让我们继续向谷歌发出请求。
- en: Making an HTTP request to Google
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向谷歌发出HTTP请求
- en: 'In the URL bar, I''m going to type `http://google.com`. We can click Send to
    send off that request. Make sure you have GET chosen as your HTTP method. When
    I fire off the request, it comes back, and all of the data that comes back is
    shown in the white space:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL栏中，我将输入`http://google.com`。我们可以点击发送来发送该请求。确保你选择了GET作为你的HTTP方法。当我发送请求时，它会返回，所有的返回数据都显示在白色空间中：
- en: '![](img/30fd6a5f-765a-4304-b3fe-1d288de8d437.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30fd6a5f-765a-4304-b3fe-1d288de8d437.png)'
- en: We have things like the Status code; we have a 200, meaning things went great;
    we have the Time, which took about a quarter of a second; we have Headers, which
    are coming back from Google; we have Cookies, but there's none in this case; and
    we have our Body data. The body for `google.com` is an HTML website. For the most
    part, the bodies that we'll be sending and getting in Postman are going to be
    JSON since we're building out the REST API.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些状态码；我们有一个200，表示一切顺利；我们有时间，大约花了四分之一秒；我们有来自Google的头部；我们有Cookie，但在这种情况下没有；我们有我们的Body数据。`google.com`的body是一个HTML网站。在大多数情况下，我们在Postman中发送和接收的body将是JSON，因为我们正在构建REST
    API。
- en: Illustrating working of the JSON data
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明JSON数据的工作方式
- en: So to illustrate how JSON data works, we're going to make a request to the geocoding
    URL that we used earlier in the course. If you remember, we were able to pass
    in a location and we got some JSON back, describing things like the latitude and
    longitude, and the formatted address. Now this should still be in your Chrome
    history.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为了说明JSON数据是如何工作的，我们将向我们在课程中早些时候使用过的地理编码URL发出请求。如果你还记得，我们能够传入一个位置，然后得到一些JSON数据，描述了诸如纬度和经度以及格式化地址之类的东西。现在这些应该还在你的Chrome历史记录中。
- en: 'If you deleted your history, you can go ahead and put [https://maps.googleapis.com/maps/api/geocode/json?address=1301+lombard+st+philadelphia](https://maps.googleapis.com/maps/api/geocode/json?address=1301+lombard+st+philadelphia) in
    the address bar. This is the URL I''ll be using; you can simply copy it, or you
    can grab any JSON API URL. I''m going to copy it to the clipboard, head back into
    Postman, and swap out the URL with the URL I just copied:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你删除了你的历史记录，你可以在地址栏中输入[https://maps.googleapis.com/maps/api/geocode/json?address=1301+lombard+st+philadelphia](https://maps.googleapis.com/maps/api/geocode/json?address=1301+lombard+st+philadelphia)。这是我将要使用的URL；你可以简单地复制它，或者你可以获取任何JSON
    API的URL。我将它复制到剪贴板中，然后返回到Postman，用刚刚复制的URL替换掉原来的URL：
- en: '![](img/51563b05-4b16-4b54-b205-919769dc5aca.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51563b05-4b16-4b54-b205-919769dc5aca.png)'
- en: 'Now, I can go ahead and fire off the request. We get our JSON data, which is
    fantastic:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以继续发送请求。我们得到了我们的JSON数据，这太棒了：
- en: '![](img/071bf0f7-f6a7-435e-8579-509ed52a4808.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/071bf0f7-f6a7-435e-8579-509ed52a4808.png)'
- en: We're able to see exactly what comes back when we make this request, and this
    is how we're going to be using Postman.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发出这个请求时，我们能够看到确切的返回内容，这就是我们将要使用Postman的方式。
- en: We'll use Postman to make requests, add Todos, delete Todos, get all of our
    Todos, and log in; all of that stuff is going to happen right in here. Remember,
    APIs don't necessarily have a frontend. Maybe it's an Android app; maybe it's
    an iPhone app or a web app; maybe it's another server. Postman gives us a way
    to interact with our API, making sure it works as expected. We have all of the
    JSON data that comes back. In the Raw view, which is under Body, we have the raw
    data response. Essentially, it's just unprettified; there is no formatting, there
    is no colorization. We also have a Preview tab. The Preview tab is pretty useless
    for JSON. When it comes to JSON data., I always stick with the Pretty tab, which
    should be the default.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Postman来发送请求，添加Todos，删除Todos，获取所有的Todos，并登录；所有这些都将在这里发生。记住，API不一定有前端。也许它是一个Android应用程序；也许它是一个iPhone应用程序或Web应用程序；也许它是另一个服务器。Postman让我们能够与我们的API进行交互，确保它按预期工作。我们有所有的JSON数据返回。在Body下的Raw视图中，我们有原始数据响应。基本上，它只是未经美化的；没有格式化，没有着色。我们还有一个预览选项卡。预览选项卡对于JSON来说是相当无用的。当涉及到JSON数据时，我总是坚持使用漂亮的选项卡，这应该是默认的。
- en: Now that we have Postman installed and we know a little bit about how to use
    it, we're going to move on to the next section, where we will actually create
    our first request. We'll be firing off a Postman request to hit the URL we're
    going to create. This is going to let us make new Todos right from Postman or
    any other application, whether it's a web app, a mobile app, or another server.
    That's all coming up next, so just make sure you have Postman installed. If you
    were able to do everything in this section, you are ready to continue.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Postman并且知道了一些如何使用它的知识，我们将继续进行下一部分，我们将实际创建我们的第一个请求。我们将发送一个Postman请求来访问我们将要创建的URL。这将让我们可以直接从Postman或任何其他应用程序（无论是Web应用程序、移动应用程序还是另一个服务器）中创建新的Todos。接下来就是这些内容，所以请确保你已经安装了Postman。如果你能够完成本节的所有内容，那么你已经准备好继续了。
- en: Resource Creation Endpoint - POST /todos
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源创建端点 - POST /todos
- en: In this section, you're going to create your `HTTP POST` route for adding new
    Todos. Before we dive into that, we're first going to refactor everything we have
    in `server.js`. We have database configuration stuff which should live somewhere
    else and we have our models, which should also live in separate files. The only
    thing we want in `server.js` is our Express route handlers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将为添加新的Todos创建你的`HTTP POST`路由。在我们深入讨论之前，我们首先要重构`server.js`中的所有内容。我们有数据库配置的东西，应该放在其他地方，我们有我们的模型，也应该放在单独的文件中。我们在`server.js`中想要的唯一的东西就是我们的Express路由处理程序。
- en: Refactoring the server.js file to create POST todos route
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构server.js文件以创建POST todos路由
- en: 'To get started, inside of the `server` folder, we''re going to make a new folder
    called `db`, and inside of the `db` folder we''ll make a file where all of this
    Mongoose configuration will happen. I''m going to call that file `mongoose.js`,
    and all we need to do is take our Mongoose configuration code right here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`server`文件夹中，我们将创建一个名为`db`的新文件夹，在`db`文件夹中，我们将创建一个文件，所有的Mongoose配置都将在其中进行。我将把那个文件命名为`mongoose.js`，我们需要做的就是将我们的Mongoose配置代码放在这里：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Cut it out, and to move it over into `mongoose.js`. Now, we need to export
    something. What we''re going to export is the `mongoose` variable. So essentially,
    when someone requires the mongoose.js file, they''re going to have Mongoose configured
    and they''re going to get it —they''re going to get back the `mongoose` variable
    that comes from the library. I''m going to set `module.exports` equal to an object,
    and on that object we''ll set `mongoose` equal to `mongoose`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 删除它，并将其移动到`mongoose.js`中。现在，我们需要导出一些东西。我们要导出的是`mongoose`变量。因此，当有人需要mongoose.js文件时，他们将得到配置好的Mongoose，并且他们将得到它——他们将从库中得到的`mongoose`变量。我将设置`module.exports`等于一个对象，并且在该对象上，我们将`mongoose`设置为`mongoose`：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now as we know, in ES6, this can be simplified. If you have a property and
    a variable with the same name you can shorten it, and we can take things a step
    further and put it all on one line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，在ES6中，这可以简化。如果你有一个属性和一个同名的变量，你可以缩短它，我们可以进一步将其放在一行上：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we have the Mongoose configuration in a separate file, and that file can
    be required in the `server.js` file. I''m going to pull off the mongoose property
    using ES6 destructuring. Essentially, we''re creating a local variable called
    `mongoose` equal to the mongoose property on the object, and that object is going
    to be the return result from requiring the file we just created. It''s in the
    `db` directory and it''s called `mongoose.js`, and we can leave off that extension:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个单独的文件中的Mongoose配置，该文件可以在`server.js`文件中被引用。我将使用ES6解构来获取mongoose属性。基本上，我们正在创建一个名为`mongoose`的本地变量，该变量等于对象上的mongoose属性，并且该对象将是从我们刚刚创建的文件中获取的返回结果。它在`db`目录中，名为`mongoose.js`，我们可以省略扩展名：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now that Mongoose lives in its own place, let's do the same thing for `Todo`
    and `User`. This is going to happen in a new folder in a server called `models`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Mongoose已经有了自己的位置，让我们对`Todo`和`User`做同样的事情。这将发生在服务器中的一个名为`models`的新文件夹中。
- en: Configuring the Todo and Users file
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Todo和Users文件
- en: 'Inside of `models`, we''re going to create two files, one for each model. I''m
    going to make two new files called `todo.js`, and `user.js`. We can take the todos
    and Users models from the `server.js` file and simply copy and paste them into
    their appropriate files. Once the model''s copied, we can remove it from `server.js`.
    The Todos model is going to look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models`文件夹中，我们将创建两个文件，一个用于每个模型。我将创建两个新文件，名为`todo.js`和`user.js`。我们可以从`server.js`文件中获取todos和Users模型，然后将它们简单地复制粘贴到相应的文件中。一旦模型被复制，我们可以从`server.js`中删除它。Todos模型将如下所示：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `user.js` model is going to look like this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`user.js`模型将如下所示。'
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I'm also going to remove everything we have so far, since those examples in
    server.js aren't necessary anymore. We can simply leave our mongoose import statement
    up at the top.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将删除到目前为止我们所拥有的一切，因为`server.js`中的这些示例不再必要。我们可以简单地将我们的mongoose导入语句留在顶部。
- en: 'Inside of these model files, there are a few things we need to do. First up,
    we will call the `mongoose.model` in both Todos and Users files, so we still need
    to load in Mongoose. Now, we don''t have to load in the `mongoose.js` file we
    created; we can load in the plain old library. Let''s make a variable. We''ll
    call that variable `mongoose`, and we''re going to `require(''mongoose'')`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些模型文件中，有一些事情我们需要做。首先，我们将在Todos和Users文件中调用`mongoose.model`，因此我们仍然需要加载Mongoose。现在，我们不必加载我们创建的`mongoose.js`文件；我们可以加载普通的库。让我们创建一个变量。我们将称这个变量为`mongoose`，然后我们将`require('mongoose')`：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The last thing that we need to do is export the model, otherwise we can''t
    use it in files that require this one. I''m going to set `module.exports` equal
    to an object, and we''ll set the `Todo` property equal to the `Todo` variable;
    this is exactly what we did over in `mongoose.js`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是导出模型，否则我们无法在需要这个文件的文件中使用它。我将设置`module.exports`等于一个对象，并且我们将`Todo`属性设置为`Todo`变量；这正是我们在`mongoose.js`中所做的：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And we''re going to do the exact same thing in `user.js`. Inside of `user.js`,
    up at the top, we''ll create a variable called `mongoose` requiring `mongoose`,
    and at the bottom we''ll export the `User` model, `module.exports`, setting it
    equal to an object where `User` equals `User`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`user.js`中做完全相同的事情。在`user.js`中，我们将在顶部创建一个名为`mongoose`的变量，需要`mongoose`，然后在底部导出`User`模型，`module.exports`，将其设置为一个对象，其中`User`等于`User`：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, all three of our files have been formatted. We have our three new files
    and our one old one. The last thing left to do is load in `Todo` and `User`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的三个文件都已经格式化。我们有三个新文件和一个旧文件。剩下要做的就是加载`Todo`和`User`。
- en: Loading Todo and User file in server.js
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`server.js`文件中加载Todo和User文件
- en: 'In the `server.js` file, let''s make a variable using destructuring call `Todo`,
    setting it equal to `require(''./models/todo'')`, and we can do the exact same
    thing for `User`. Using ES6 destructuring, we''re going to pull off that `User`
    variable, and we''re going to get it from the object that comes back from a call
    to `require`, requiring `models/user`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`文件中，让我们使用解构创建一个变量`Todo`，将其设置为`require('./models/todo')`，我们可以对`User`做完全相同的事情。使用ES6解构，我们将获取`User`变量，并且我们将从调用`require`返回的对象中获取它，需要`models/user`：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With this in place, we are now ready to get going. We have the exact same setup,
    only it's been refactored, and this is going to make it a lot easier to test,
    update, and manage. The `server.js` file is just going to be responsible for our
    routes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在准备开始。我们有完全相同的设置，只是已经重构，这将使测试、更新和管理变得更加容易。`server.js`文件只负责我们的路由。
- en: Configuring the Express application
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Express应用程序
- en: Now, to get started, we're going to need to install Express. We've already done
    that in the past, so over in the Terminal all we need to do is run  `npm i` followed
    by the module name, which is `express`. We'll be using the most recent version,
    `4.16.2`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始，我们需要安装Express。我们已经在过去做过了，所以在终端中，我们只需要运行`npm i`，然后是模块名称，即`express`。我们将使用最新版本，`4.16.2`。
- en: 'We''re also going to be installing a second module, and we can actually type
    that right after the first one. There''s no need to run `npm install` twice. This
    one is called the `body-parser`. The `body-parser` is going to let us send JSON
    to the server. The server can then take that JSON and do something with it. `body-parser`
    essentially parses the body. It takes that string body and turns it into a JavaScript
    object. Now, with `body-parser`, we''re going to be installing version `1.18.2`,
    the most recent version. I''m also going to provide the `--save` flag, which is
    going to add both Express and `body-parser` to the dependencies section of `package.json`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将安装第二个模块，实际上我们可以在第一个模块之后立即输入。没有必要两次运行`npm install`。这个叫做`body-parser`。`body-parser`将允许我们向服务器发送JSON。服务器然后可以接收该JSON并对其进行处理。`body-parser`本质上解析主体。它获取该字符串主体并将其转换为JavaScript对象。现在，使用`body-parser`，我们将安装最新版本`1.18.2`。我还将提供`--save`标志，这将把Express和`body-parser`添加到`package.json`的依赖项部分：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, I can go ahead and fire off this request, installing both modules, and
    over inside of `server.js`, we can start configuring our app.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以继续发送这个请求，安装这两个模块，并在`server.js`中开始配置我们的应用程序。
- en: 'First up, we have to load in those two modules we just installed. As I mentioned
    previously, I like to keep a space between local imports and library imports.
    I''m going to use a variable called `express` to store the Express library, namely `require(''express'')`.
    We''re going to do the same thing for `body-parser` with a variable called `bodyParser`,
    setting it equal to the return result from requiring `body-parser`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须加载刚刚安装的这两个模块。正如我之前提到的，我喜欢在本地导入和库导入之间保留一个空格。我将使用一个名为`express`的变量来存储Express库，即`require('express')`。我们将对`body-parser`做同样的事情，使用一个名为`bodyParser`的变量，将其设置为从`body-parser`中获取的返回结果：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that we can set up a very basic application. We''re going to make a variable
    called `app`; this is going to store our Express application. I''m going to set
    this equal to a call to `express`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设置一个非常基本的应用程序。我们将创建一个名为`app`的变量；这将存储我们的Express应用程序。我将把它设置为调用`express`：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And we''re also going to call `app.listen`, listening on a port. We will be
    deploying this to Heroku eventually. For now though, we''re going to have a local
    port, port `3000`, and we''ll provide a callback function that''s going to fire
    once the app is up. All we''re going to do is use `console.log` to print `Started
    on port 3000`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将调用`app.listen`，监听一个端口。我们最终将部署到Heroku。不过，现在我们将有一个本地端口，端口`3000`，并且我们将提供一个回调函数，一旦应用程序启动，它就会触发。我们将使用`console.log`来打印`Started
    on port 3000`：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Configuring the POST route
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置POST路由
- en: Now, we have a very basic server. All we have to do is start configuring our
    routes, and as I promised, the one we're going to be focusing on in this section
    is the POST route. This is going to let us create new Todos. Now, inside of your
    REST APIs, there's the basic CRUD operations, CRUD being Create, Read, Update,
    and Delete.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个非常基本的服务器。我们只需要开始配置我们的路由，正如我承诺的那样，我们将在本节中专注于POST路由。这将让我们创建新的Todos。现在，在您的REST
    API中，有基本的CRUD操作，CRUD代表创建、读取、更新和删除。
- en: When you want to create a resource, you use the `POST HTTP` method, and you
    send that resource as the body. This means that when we want to make a new Todo,
    we're going to send a JSON object over to the server. It's going to have a `text`
    property, and the server is going to get that `text` property, create the new
    model, and send the complete model with the ID, the completed property, and `completedAt`
    back to the client.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要创建一个资源时，您使用`POST HTTP`方法，并将该资源作为主体发送。这意味着当我们想要创建一个新的Todo时，我们将向服务器发送一个JSON对象。它将具有一个`text`属性，服务器将获取该`text`属性，创建新模型，并将带有ID、completed属性和`completedAt`的完整模型发送回客户端。
- en: 'To set up a route, we need to call `app.post`, passing in the two arguments
    we''ve used for every single Express route, which are our URL and our callback
    function that get called with the `req` and `res` objects. Now, the URL for a
    REST API is really important, and there is a lot of talk about the proper structure.
    For resources, what I like to do is use `/todos`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置路由，我们需要调用`app.post`，传入我们用于每个Express路由的两个参数，即我们的URL和我们的回调函数，该函数将使用`req`和`res`对象进行调用。现在，REST
    API的URL非常重要，关于正确的结构有很多讨论。对于资源，我喜欢使用`/todos`：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is for resource creation, and this is a pretty standard setup. `/todos`
    is for creating a new Todo. Later on, when we want to read Todos, we'll use the
    `GET` method, and we will use `GET` from `/todos` to get all Todos or `/todos`,
    some crazy number, to get an individual Todo by its ID. This is a very common
    pattern, and it's the one we're going to be using. For now though, we can focus
    on getting the body data that was sent from the client.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于资源创建的，这是一个非常标准的设置。`/todos`用于创建新的Todo。稍后，当我们想要读取Todos时，我们将使用`GET`方法，并且我们将使用`GET`从`/todos`获取所有Todos或`/todos`，一些疯狂的数字，以根据其ID获取单个Todo。这是一个非常常见的模式，也是我们将要使用的模式。不过，现在我们可以专注于获取从客户端发送的主体数据。
- en: Getting body data from the client
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从客户端获取主体数据
- en: 'To do this, we have to use the `body-parser` module. As I mentioned previously,
    `body-parser` is going to take your JSON and convert it into an object, attaching
    it onto this `request` object. We''re going to configure the middleware using
    `app.use`. The `app.use` takes the middleware. If we''re writing custom middleware,
    it''ll be a function; if we''re using third-party middleware, we usually just
    access something off of the library. In this case, it''s going to be `bodyParser.json`
    getting called as a function. The return value from this JSON method is a function,
    and that is the middleware that we need to give to Express:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们必须使用`body-parser`模块。正如我之前提到的，`body-parser`将获取您的JSON并将其转换为一个对象，将其附加到此`request`对象上。我们将使用`app.use`配置中间件。`app.use`使用中间件。如果我们正在编写自定义中间件，它将是一个函数；如果我们正在使用第三方中间件，我们通常只是从库中访问某些内容。在这种情况下，它将作为函数调用`bodyParser.json`。这个JSON方法的返回值是一个函数，这就是我们需要给Express的中间件：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With this in place, we can now send JSON to our Express application. What I''d
    like to do inside of the `post` callback is simply `console.log` the value of
    `req.body`, where the body gets stored by `bodyParser`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在可以向我们的Express应用程序发送JSON。在`post`回调中，我想要做的就是简单地`console.log` `req.body`的值，其中`bodyParser`存储了body。
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can now start up the server and test things out inside of Postman.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动服务器并在Postman中测试一下。
- en: Testing the POST route inside Postman
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中测试POST路由
- en: 'In the Terminal, I''m going to use `clear` to clear the Terminal output, and
    then I''ll run the app:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我将使用`clear`清除终端输出，然后运行应用程序：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The server is up on port 3000, which means we can now head into Postman:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在端口3000上运行，这意味着我们现在可以进入Postman：
- en: '![](img/6a953c9e-1aaa-46b5-9fbe-b41a776ebcf2.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a953c9e-1aaa-46b5-9fbe-b41a776ebcf2.png)'
- en: 'Inside of Postman, we''re not going to be making a `GET` request like we did
    in the previous section. This time, what we''re going to be doing is making a
    POST request, which means we need to change the HTTP method to POST, and type
    the URL. That''s going to be `localhost:3000` for the port, `/todos`. This is
    the URL that we want to send our data to:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中，我们不会像在上一节中那样进行`GET`请求。这次，我们要做的是进行POST请求，这意味着我们需要将HTTP方法更改为POST，并输入URL。端口将是`localhost:3000`，路径将是`/todos`。这是我们要发送数据的URL：
- en: '![](img/4febabfd-5ae5-42f9-9a10-fc88a754d192.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4febabfd-5ae5-42f9-9a10-fc88a754d192.png)'
- en: 'Now in order to send some data to the application, we have to go to the Body
    tab. We''re trying to send JSON data, so we''re going to go to raw and select
    JSON (application/json) from the drop-down list on the right-hand side:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了向应用程序发送一些数据，我们必须转到Body选项卡。我们要发送JSON数据，所以我们将转到原始并从右侧的下拉列表中选择JSON（application/json）：
- en: '![](img/6a0475dd-eab4-40a1-add7-f4e0db4de205.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a0475dd-eab4-40a1-add7-f4e0db4de205.png)'
- en: 'Now we have our Header set. This is the Content-Type header, letting the server
    know that JSON is getting sent. All of this is done automatically with Postman.
    Inside of Body, the only piece of information I''m going to attach to my JSON
    is a `text` property:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了头部。这是Content-Type头部，让服务器知道正在发送JSON。所有这些都是由Postman自动完成的。在Body中，我要附加到我的JSON的唯一信息是一个“text”属性：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now we can click Send to fire off our request. We''re never going to get a
    response because we haven''t responded to it inside of `server.js`, but if I head
    over to the Terminal, you see we have our data:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以点击发送来发送我们的请求。我们永远不会收到响应，因为我们还没有在`server.js`中回应它，但是如果我转到终端，你会看到我们有我们的数据：
- en: '![](img/f9371b46-fd66-4a0d-939f-fe21b9551ad7.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9371b46-fd66-4a0d-939f-fe21b9551ad7.png)'
- en: This is the data we created inside of Postman. It's now showing up in our Node
    application, which is fantastic. We are one step closer to actually creating that
    Todo. The only thing left to do inside of the post handler is to actually create
    the Todo using the information that comes from the `User`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在Postman中创建的数据。现在它显示在我们的Node应用程序中，这太棒了。我们离实际创建Todo只差一步。在post处理程序中，唯一剩下的事情就是实际使用来自“用户”的信息创建Todo。
- en: Creating an instance of Mongoose model
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Mongoose模型的实例
- en: 'Inside `server.js`, let''s make a variable called `todo` to do what we''ve
    done previously, creating an instance of a Mongoose model. We''re going to set
    it equal to `new Todo`, passing in our object and passing in the values we want
    to set. In this case, we just want to set `text`. We''re going to set text to
    `req.body`, which is the object we have, and then we''re going to access the `text`
    property, like so:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中，让我们创建一个名为`todo`的变量，以执行之前所做的操作，创建Mongoose模型的实例。我们将其设置为`new Todo`，传入我们的对象和要设置的值。在这种情况下，我们只想设置`text`。我们将文本设置为`req.body`，这是我们拥有的对象，然后我们将访问`text`属性，就像这样：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Next up, we're going to call `todo.save`. This is going to actually save the
    model to the database, and we're going to be providing a callback for a success
    case and an error case.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调用`todo.save`。这将实际将模型保存到数据库，并且我们将为成功和错误情况提供回调。
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now if things go well, we''re going to be sending back the actual Todo which
    is going to show up in the then callback. I''m going to get the `doc`, and right
    inside of the callback function, I''m going to use `res.send` to send the doc
    back. This is going to give the `User` really important information, things like
    the ID and the `completed` and `completedAt` properties, which were not set by
    the `User`. If things go poorly and we get an error, that''s fine too. All we''re
    going to do is use `res.send` to send that error back:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一切顺利，我们将发送回实际的Todo，它将显示在then回调中。我将获取`doc`，并在回调函数中使用`res.send`发送`doc`回去。这将为`User`提供非常重要的信息，例如ID和`completed`和`completedAt`属性，这些属性不是由`User`设置的。如果事情进展不顺利并且我们遇到错误，那也没关系。我们要做的就是使用`res.send`发送错误回去：
- en: '[PRE56]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We'll be modifying how we send errors back a little later. For now, this code
    is going to work just great. We can also set an HTTP status.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将修改如何发送错误。目前，这段代码将运行得很好。我们还可以设置HTTP状态。
- en: Setting up HTTP status code
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置HTTP状态码
- en: 'If you remember, HTTP statuses let you give someone some information about
    how the request went. Did it go well? Did it go poorly? That kind of thing. You
    can get a list of all the HTTP statuses available to you by going to [httpstatuses.com](https://httpstatuses.com/).
    Here, you can view all of the statuses that you can set:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，HTTP状态可以让你给别人一些关于请求进展情况的信息。它进行得顺利吗？它进行得不好吗？这种情况。你可以通过访问[httpstatuses.com](https://httpstatuses.com/)来获取所有可用的HTTP状态列表。在这里，你可以查看所有你可以设置的状态：
- en: '![](img/6da92bd6-eedd-4b4d-b992-f2aae3128ab9.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6da92bd6-eedd-4b4d-b992-f2aae3128ab9.png)'
- en: 'The one that''s set by default by Express is `200`. This means that things
    went OK. What we''re going to be using for an error is code `400`. A `400` status
    means there was some bad input, which is going to be the case if the model can''t
    be saved. Maybe the `User` didn''t provide a `text` property, or maybe the text
    string was empty. Either way, we want to send a `400` back, and that''s going
    to happen. Right before we call `send`, all we''re going to do is call `status`,
    passing in the status of `400`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Express默认设置的一个是`200`。这意味着事情进行得很顺利。我们将用于错误的是`400`。`400`状态意味着有一些错误的输入，如果模型无法保存，就会出现这种情况。也许`User`没有提供`text`属性，或者文本字符串为空。无论哪种情况，我们都希望返回`400`，这将会发生。在我们调用`send`之前，我们要做的就是调用`status`，传入`400`的状态：
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: With this in place, we are now ready to test out our `POST /todos` request over
    inside of Postman.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在准备在Postman中测试我们的`POST /todos`请求。
- en: Testing POST /todos inside of Postman
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Postman中测试POST /todos
- en: 'I''m going to restart the server in the Terminal. You could start this up with
    `nodemon` if you like. For the moment, I''ll be manually restarting it:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在终端中重新启动服务器。如果你喜欢，你可以用`nodemon`启动它。目前，我将手动重新启动它：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We''re now up on localhost 3000, and inside of Postman, we can make the exact
    same request we made earlier. I''m going to click on Send:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在本地主机3000上，进入Postman，我们可以进行与之前完全相同的请求。我将点击发送：
- en: '![](img/776c1611-1339-44e4-b558-bc348e3afa13.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/776c1611-1339-44e4-b558-bc348e3afa13.png)'
- en: We get a Status of 200\. This is fantastic; it's the default status, which means
    things went great. The JSON response is exactly what we expected. We have our
    `text` that we set; we have the `_id` property which was generated; we have `completedAt`,
    which is set to `null`, the default; and we have `completed` set to `false`, the
    default.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个200的状态。这太棒了；这是默认状态，意味着事情进行得很顺利。JSON响应正是我们所期望的。我们有我们设置的`text`；我们有生成的`_id`属性；我们有`completedAt`，它被设置为`null`，默认值；以及我们有`completed`被设置为`false`，默认值。
- en: 'We could also test what happens when we try to create a Todo without the proper
    information. For example, maybe I set a `text` property equal to an empty string.
    If I send this over, we now get a 400 Bad Request:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试当我们尝试创建一个没有正确信息的Todo时会发生什么。例如，也许我将`text`属性设置为空字符串。如果我发送这个请求，我们现在会得到一个400
    Bad Request：
- en: '![](img/cb3f9133-cfef-4f45-932b-624493eef4f1.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb3f9133-cfef-4f45-932b-624493eef4f1.png)'
- en: Now, we have a bunch of validation code saying that the `Todo validation failed`.
    Then, we can go into the `errors` object to get the specific error. Here, we can
    see the `text` field failed, and the `message` is `Path 'text' is required`. All
    of this information can help someone fix their request and make a proper one.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一堆验证代码说`Todo验证失败`。然后，我们可以进入`errors`对象来获取具体的错误。在这里，我们可以看到`text`字段失败了，`message`是`Path
    'text' is required`。所有这些信息都可以帮助某人修复他们的请求并做出正确的请求。
- en: 'Now if I head over into Robomongo, I''m going to refresh the collection for
    `todos`. Look at the last one, and it is indeed the one we created in Postman:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我进入Robomongo，我将刷新`todos`集合。看看最后一个，它确实是我们在Postman中创建的：
- en: '![](img/bbc69aa2-e621-4fe9-8387-10ac561c4a4d.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbc69aa2-e621-4fe9-8387-10ac561c4a4d.png)'
- en: The text is equal to This is from postman. With this in place, we now have our
    very first HTTP endpoint set up for the Todo REST API.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 文本等于这是来自Postman的。有了这个，我们现在为Todo REST API设置了我们的第一个HTTP端点。
- en: Now I haven't talked exactly about what REST is. We're going to talk about that
    later. For now, we're going to focus on creating these endpoints. The REST version
    will come up a little later when we start adding authentication.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我还没有详细讨论REST是什么。我们稍后会谈论这个。现在，我们将专注于创建这些端点。当我们开始添加认证时，REST版本将稍后出现。
- en: Adding more Todos to the database
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向数据库添加更多的Todos
- en: 'Over inside of Postman, we can add a few more Todos, which is what I''m going
    to do. `Charge my phone`—I don''t think I''ve ever needed to be reminded of that
    one—and we''ll add `Take a break for lunch`. In the Pretty section, we see the
    `Charge my phone` Todo was created with a unique ID. I''m going to send off the
    second one, and we''ll see that the `Take a break for lunch` Todo was created:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中，我们可以添加更多的Todos，这就是我要做的。`Charge my phone`—我想我从来没有需要被提醒过这个—我们将添加`Take
    a break for lunch`。在Pretty部分，我们看到`Charge my phone` Todo已经创建了一个唯一的ID。我将发送第二个，我们会看到`Take
    a break for lunch` Todo已经创建：
- en: '![](img/a4b7b887-ce27-47db-9bc9-12faf509399a.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4b7b887-ce27-47db-9bc9-12faf509399a.png)'
- en: 'Over inside of Robomongo, we can give our `todos` collection a final refresh.
    I''m going to expand those last three items, and they are indeed the three items
    we created in Postman:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在Robomongo中，我们可以给`todos`集合进行最后一次刷新。我将展开最后三个项目，它们确实是我们在Postman中创建的三个项目：
- en: '![](img/e9e6b7a1-ffa1-4d96-83d3-f4cc1172b560.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9e6b7a1-ffa1-4d96-83d3-f4cc1172b560.png)'
- en: 'Now that we have some meaningful work done in our project, let''s go ahead
    and commit our changes. As you can see over in Atom, the `server` directory is
    green, meaning that it hasn''t been added to Git, and the `package.json` file
    is orange, which means that it''s been modified, even though Git is tracking it.
    Over in the Terminal we can shut down the server, and I always like to run `git
    status` to do a sanity check:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目中已经完成了一些有意义的工作，让我们继续提交我们的更改。你可以在Atom中看到，`server`目录是绿色的，意味着它还没有添加到Git中，`package.json`文件是橙色的，这意味着它已经被修改，尽管Git正在跟踪它。在终端中，我们可以关闭服务器，我总是喜欢运行`git
    status`来进行一次理智检查：
- en: '![](img/ccbaae0a-9862-411f-a8b5-5bd8aa2ac2b3.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccbaae0a-9862-411f-a8b5-5bd8aa2ac2b3.png)'
- en: 'Here, everything does look as expected. I can it using `git add .` to add everything,
    followed by one more sanity check:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一切看起来都如预期。我可以使用`git add .`添加所有内容，然后再进行一次检查：
- en: '![](img/b349702a-b07e-406a-a056-911068914b44.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b349702a-b07e-406a-a056-911068914b44.png)'
- en: Here, we have our four new files in the `server` folder, as well as our `package.json`
    file.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`server`文件夹中有四个新文件，以及我们的`package.json`文件。
- en: 'Now, it''s time to make that commit. I''m going to create a quick commit. I''m
    using the `-am` flag, which usually adds modified files. Since I already used
    add, I can simply use the `-m` flag, like we''ve been doing all the way through
    the course. A good message for this one would be something like `Add POST /todos
    route and refactor mongoose`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候提交了。我要创建一个快速提交。我使用`-am`标志，通常会添加修改后的文件。由于我已经使用了add，我可以简单地使用`-m`标志，就像我们在整个课程中一直在做的那样。对于这个，一个好的消息可能是`添加POST
    /todos路由和重构mongoose`：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: With the commit in place, we can now wrap things up by pushing it up to GitHub,
    making sure it's backed up, and making sure it's available for anyone else collaborating
    on the project. Remember, creating a commit alone does not get it up on GitHub;
    you've got to push that with another command, namely `git push`. With that in
    place, it's now time to move on to the next section, where you will be testing
    the route you just created.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有了提交，我们现在可以通过将其推送到GitHub来结束这些工作，确保它得到备份，并确保它对任何其他在项目上合作的人都可用。记住，仅仅创建一个提交并不能将其上传到GitHub；您必须使用另一个命令`git
    push`将其推送上去。有了这个，现在是时候进入下一部分了，您将在那里测试您刚刚创建的路由。
- en: Testing POST /todos
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试POST /todos
- en: In this section, you're going to learn how to set up the test suite for the
    Todo API, similar to what we did in the `test` section, and we'll be writing two
    test cases for `/todos`. We're going to verify that when we send the correct data
    as the body, we get a `200` back with the completed doc, including the ID; and,
    if we send bad data, we expect a `400` back with the error object.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将学习如何为Todo API设置测试套件，类似于我们在“测试”部分所做的，我们将为`/todos`编写两个测试用例。我们将验证当我们发送正确的数据作为主体时，我们会得到一个包括ID在内的`200`完成文档；如果我们发送错误的数据，我们期望得到一个包含错误对象的`400`。
- en: Installing npm modules for testing POST /todos route
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试POST /todos路由安装npm模块
- en: Now before we can do any of this, we have to install all of those modules we
    installed in the `test` section, `expect` for assertions, `mocha` for the entire
    test suite, `supertest` to test our Express routes, and `nodemon`. The `nodemon`
    module is going to let us create that `test-watch` script we had, so we can automatically
    restart the test suite. Now I know you have `nodemon` installed globally, but
    since we are using it inside of a `package.json` script, it's a great idea to
    install it locally as well.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们做任何这些之前，我们必须安装在“测试”部分中安装的所有模块，`expect`用于断言，`mocha`用于整个测试套件，`supertest`用于测试我们的Express路由，以及`nodemon`。`nodemon`模块将让我们创建`test-watch`脚本，这样我们就可以自动重新启动测试套件。现在我知道您已经全局安装了`nodemon`，但由于我们在`package.json`脚本中使用它，所以在本地安装它也是一个好主意。
- en: 'We''re going to run `npm i` with `expect` version `22.3.0`, the most recent.
    Next up is going to be `mocha`. The most recent version is `5.0.1`. After that
    is `nodemon` version `1.15.0`, and last but not least is `supertest` at version
    `3.0.0`. With this in place, all we have to do is tack on that `--save-dev` flag.
    We want to save these, but not as regular dependencies. They''re for testing purposes
    only, so we''re going to save them as `devDependencies`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`npm i`安装`expect`版本`22.3.0`，最新版本。接下来是`mocha`。最新版本是`5.0.1`。之后是`nodemon`版本`1.15.0`，最后但并非最不重要的是`supertest`版本`3.0.0`。有了这些，我们只需要加上`--save-dev`标志。我们想要保存这些，但不作为常规依赖项。它们仅用于测试，因此我们将它们保存为`devDependencies`：
- en: '[PRE60]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, we can go ahead and run this command, and once it's done we'll be able
    to start setting up the test files inside of Atom.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行这个命令，一旦完成，我们就可以开始在Atom中设置测试文件。
- en: Setting up the test files
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置测试文件
- en: 'In Atom, inside my `package.json` file, I now have my `devDependencies` listed
    out:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，我现在在我的`package.json`文件中列出了我的`devDependencies`：
- en: '![](img/17f9d742-f3d4-4e21-870d-edcfd2448fc6.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17f9d742-f3d4-4e21-870d-edcfd2448fc6.png)'
- en: Now, my output for this command might look a little different than yours. npm
    is caching some of my modules that I've installed recently, so as you can see
    in the preceding screenshot, it's just grabbing the local copy. They did indeed
    get installed though, and I can prove that by opening up the `node_modules` folder.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我的命令输出可能与您的有些不同。npm正在缓存我最近安装的一些模块，所以正如您在前面的截图中所看到的，它只是获取本地副本。它们确实被安装了，我可以通过打开`node_modules`文件夹来证明。
- en: We're now going to create a folder inside the `server` where we can store all
    of our test files, and this folder is going to be called `tests`. The only file
    we're going to worry about creating for this section is a test file for `server.js`.
    I'm going to make a new file in tests called `server.test.js`. This is the extension
    we'll be using for test files in the chapter. Inside of the `server.test` file,
    we can now kick things off by requiring a lot of those modules. We're going to
    require the `supertest` module and `expect`. The `mocha` and `nodemon` modules
    do not need to be required; that's not how they're used.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在`server`中创建一个文件夹，用于存储所有测试文件，这个文件夹将被称为`tests`。我们要担心创建的唯一文件是`server.js`的测试文件。我将在tests中创建一个名为`server.test.js`的新文件。这是我们将在本章中使用的测试文件的扩展名。在`server.test`文件中，我们现在可以通过要求很多这些模块来启动事情。我们将要求`supertest`模块和`expect`。`mocha`和`nodemon`模块不需要被要求；这不是它们的使用方式。
- en: 'The `const expect` variable we''ll get will be equal to `require(''expect'')`,
    and we''ll do the exact same thing for `supertest`, using `const`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到的`const expect`变量将等于`require('expect')`，我们将对`supertest`做同样的事情，使用`const`：
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now that we have these in place, we need to load in some of our local files.
    We need to load in `server.js` so we have access to the Express app since we need
    that for super-test, and we also want to load in our Todo model. As you'll see
    a little later, we're going to be querying the database, and having access to
    this model is going to be necessary. Now the model already exports something,
    but `server.js` currently exports nothing. We can fix this by adding `module.exports`
    to the very bottom of the `server.js` file, setting it equal to an object. On
    that object, all we're going to do is set the `app` property equal to the `app`
    variable, using the ES6 object syntax.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经准备好了，我们需要加载一些本地文件。我们需要加载`server.js`，这样我们就可以访问Express应用程序，因为我们需要它来进行超级测试，我们还想加载我们的Todo模型。正如您稍后将看到的，我们将查询数据库，并且访问此模型将是必要的。现在模型已经导出了一些东西，但`server.js`目前没有导出任何东西。我们可以通过在`server.js`文件的最底部添加`module.exports`并将其设置为一个对象来解决这个问题。在该对象上，我们要做的就是将`app`属性设置为`app`变量，使用ES6对象语法。
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With this in place, we are now ready to load those two files in.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好加载这两个文件了。
- en: Loading the test files
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载测试文件
- en: First up, let's go ahead and create a local variable called `app`, and we're
    going to be using ES6 destructuring to pull it off of the return result from requiring
    the server file. Here, we're going to start by getting the relative path. Then,
    we're going to go back one directory from `tests` into `server`. The filename
    is simply `server` without the extension. We can do the exact same thing for the
    Todo model as well.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`app`的本地变量，并且我们将使用ES6解构从服务器文件的返回结果中取出它。在这里，我们将从相对路径开始。然后，我们将从`tests`返回到`server`的上一级目录。文件名只是`server`，没有扩展名。我们也可以对Todo模型做同样的操作。
- en: 'We''re going to make a constant called `Todo`. We''re using ES6 destructuring
    to pull that off of the export, and the file is from the relative path, back a
    directory. Then we have to go into the `models` directory, and finally, the filename
    is called `todo`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`Todo`的常量。我们使用ES6解构从导出中取出它，文件来自相对路径，返回到上一级目录。然后我们必须进入`models`目录，最后，文件名为`todo`：
- en: '[PRE63]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: And now that we have all of this loaded in, we are ready to create our `describe`
    block and add our test cases.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经加载了所有这些，我们准备创建我们的`describe`块并添加我们的测试用例。
- en: Adding describe block for the test cases
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试用例添加描述块
- en: 'I''m going to use `describe` to group all of the routes. I''m going to have
    multiple test cases for some routes, and it''s nice to add a `describe` block
    so you can quickly glance at the test output in the Terminal. The `describe` block
    for POST Todos will simply be called `POST /todos`. Then, we can add our arrow
    function (`=>`), and inside of here we can start laying out our test cases. The
    first test is going to verify that when we send the appropriate data, everything
    goes as expected:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`describe`来对所有路由进行分组。对于一些路由，我将有多个测试用例，添加一个`describe`块是很好的，这样您可以在终端中快速查看测试输出。POST
    Todos的`describe`块将简单地称为`POST /todos`。然后，我们可以添加箭头函数(`=>`)，在其中我们可以开始列出我们的测试用例。第一个测试将验证当我们发送适当的数据时，一切都如预期般进行：
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, we can add our callback function, and this function is going to take the
    `done` argument because this is going to be an asynchronous test. You have to
    specify `done`, otherwise this test is not going to work as expected. In the callback
    function, what we're going to do is create a variable called `text`. This is the
    only setup data we really need. We just need a string, and we're going to use
    that string throughout. Go ahead and give this any value you like. I'm going to
    use `Test todo text`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加我们的回调函数，这个函数将接受`done`参数，因为这将是一个异步测试。您必须指定`done`，否则这个测试将无法按预期工作。在回调函数中，我们将创建一个名为`text`的变量。这是我们真正需要的唯一设置数据。我们只需要一个字符串，并且我们将在整个过程中使用该字符串。随意给它任何值。我将使用`Test
    todo text`。
- en: '[PRE65]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now it's time to start making that request via `supertest`. We only made `GET`
    requests previously, but `POST` requests are just as easy.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始通过`supertest`发出请求了。我们之前只发出了`GET`请求，但`POST`请求同样简单。
- en: Making the POST requests via supertest
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过supertest进行POST请求
- en: 'We''re going to call request, passing in the app we want to make the request
    on. Next up, we''re going to call `.post`, which sets up a `POST` request. We''re
    going to go to `/todos`, and the new thing we''re going to do is actually send
    data. In order to send data along with the request as the body we have to call
    `send`, and we''re going to pass in an object. This object is going to get converted
    to JSON by `supertest`, so there''s no need for us to worry about that—just another
    great reason to use the `supertest` library. We''re going to set `text` equal
    to the `text` variable shown previously, and we can use the ES6 syntax to get
    that done:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用请求，传入我们要发出请求的应用程序。接下来，我们将调用`.post`，这将设置一个`POST`请求。我们将前往`/todos`，新的事情是我们实际上要发送数据。为了随请求发送数据作为主体，我们必须调用`send`，并且我们将传入一个对象。这个对象将被`supertest`转换为JSON，所以我们不需要担心这一点——这只是使用`supertest`库的另一个很好的理由。我们将把`text`设置为之前显示的`text`变量，并且我们可以使用ES6语法来完成这个操作：
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now that we've sent the request, we can start making assertions about the request.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发送了请求，我们可以开始对请求进行断言。
- en: Making assertions about the POST request
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对POST请求进行断言
- en: We'll start with the status. I'm going to `expect` that the status equals `200`,
    which should be the case when we send across valid data. After this, we can go
    ahead and make an assertion about the body that comes back. We want to make sure
    the body is an object and that it has the `text` property equal to the one we
    specified previously. That's exactly what it should be doing when it sends the
    body back.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从状态开始。我将`expect`状态等于`200`，当我们发送有效数据时，这应该是情况。之后，我们可以对返回的主体进行断言。我们希望确保主体是一个对象，并且它的`text`属性等于我们之前指定的属性。这正是它在发送主体时应该做的事情。
- en: 'Over inside of `server.test.js`, we can get that done by creating a custom
    `expect` assertion. If you can recall, our custom `expect` calls do get passed
    in the response, and we can use that response inside of the function. We''re going
    to `expect` that the response body has a `text` property and that the `text` property
    equals using `toBe`, the `text` string we have defined:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.test.js`中，我们可以通过创建一个自定义的`expect`断言来完成这个操作。如果你还记得，我们的自定义`expect`调用确实传递了响应，并且我们可以在函数内部使用该响应。我们要`expect`响应体有一个`text`属性，并且`text`属性等于使用`toBe`定义的`text`字符串：
- en: '[PRE67]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If that''s the case, great; this will pass. If not, that''s fine too. We''re
    just going to throw an error and the test will fail. The next thing we need to
    do is call end to wrap things up, but we''re not quite done yet. What we want
    to do is actually check what got stored in the MongoDB collection, and this is
    why we loaded in the model. Instead of passing `done` into end like we did previously,
    we''re going to pass in a function. This function will get called with an error,
    if any, and the response:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，很好，测试通过了。如果不是，也没关系。我们只需要抛出一个错误，测试就会失败。接下来我们需要做的是调用`end`来结束一切，但我们还没有完成。我们要做的是实际检查MongoDB集合中存储了什么，这就是我们加载模型的原因。与之前一样，我们不再像之前那样将`done`传递给end，而是传递一个函数。这个函数将在有错误时被调用，并传递一个错误和响应：
- en: '[PRE68]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This callback function is going to allow us to do a few things. First up, let's
    handle any errors that might have occurred. This will be if the status wasn't
    `200`, or if the `body` doesn't have a `text` property equal to the `text` property
    we sent in. All we have to do is check if an error exists. If an error does exist,
    all we're going to do is pass it into `done`. This is going to wrap up the test,
    printing the error to the screen, so the test will indeed fail. I'm also going
    to `return` this result.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调函数将允许我们做一些事情。首先，让我们处理可能发生的任何错误。如果状态不是`200`，或者`body`没有一个等于我们发送的`text`属性的`text`属性，那么就会出现错误。我们只需要检查错误是否存在。如果存在错误，我们将把它传递给`done`。这将结束测试，将错误打印到屏幕上，因此测试确实会失败。我也会`return`这个结果。
- en: '[PRE69]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, returning it doesn't do anything special. All it does is stop the function
    execution. Now, we're going to make a request to the database fetching all the
    Todos, verifying that our one `Todo` was indeed added.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，返回它并没有做任何特别的事情。它只是停止函数的执行。现在，我们将向数据库发出请求，获取所有的Todos，并验证我们添加的一个`Todo`是否确实被添加了。
- en: Making a request to fetch the Todos from the database
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出请求从数据库中获取Todos
- en: To do that, we have to call `Todo.find`. Now, `Todo.find` is really similar
    to the MongoDB native `find` method we used. We can call it with no arguments
    to fetch everything in that collection. In this case, we'll be fetching all of
    the Todos. Next up, we can attach a `then` callback. We're going to get this function
    called with all `todos`, and we can make some assertions about that.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们必须调用`Todo.find`。现在，`Todo.find`与我们使用的MongoDB原生`find`方法非常相似。我们可以不带参数地调用它来获取集合中的所有内容。在这种情况下，我们将获取所有的Todos。接下来，我们可以附加一个`then`回调。我们将使用这个函数调用所有的`todos`，并对其进行一些断言。
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this case, we're going to assert that the Todo we created does exist. We'll
    get started by expecting `todos.length` to `toBe` equal to the number `1`, because
    we've added one Todo item. We're going to make one more assertion. We're going
    to `expect` that that one and only item has a `text` property equal to using `toBe`,
    the `text` variable we have in server.test.js.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们要断言我们创建的Todo确实存在。我们将从期望`todos.length`等于数字`1`开始，因为我们添加了一个Todo项目。我们还要做一个断言。我们要`expect`这一个唯一的项目有一个`text`属性等于使用`toBe`在server.test.js中定义的`text`变量。
- en: '[PRE71]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If both of these pass, then we can be pretty sure that everything worked as
    expected. The status code is correct, the response is correct, and the database
    looks correct as well. Now it''s time to call `done`, wrapping up the test case:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个都通过了，那么我们可以相当肯定一切都按预期工作了。状态码是正确的，响应也是正确的，数据库看起来也是正确的。现在是时候调用`done`，结束测试用例了：
- en: '[PRE72]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We're not done quite yet. If either of these fail, the test is still going to
    pass. What we have to do is tack on a `catch` call.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。如果其中任何一个失败，测试仍然会通过。我们必须添加一个`catch`调用。
- en: Adding the catch call for the error handling
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为错误处理添加catch调用
- en: 'The `catch` is going to get any errors that might occur inside of our callback.
    Then, we''re going to be able to take that error argument, and using an arrow
    function, we''re going to be able to pass it into `done`, just like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`将获取我们回调中可能发生的任何错误。然后，我们将能够获取到错误参数，并使用箭头函数将其传递给`done`，就像这样：'
- en: '[PRE73]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice here I'm using the statement syntax as opposed to the arrow function
    expression syntax. With this in place, our test case is now good to go. We have
    a great test case, and all we need to do is set up the `scripts` in `package.json`
    to actually run it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我使用的是语句语法，而不是箭头函数表达式语法。有了这个，我们的测试用例现在可以运行了。我们有一个很好的测试用例，我们需要做的就是在`package.json`中设置`scripts`来实际运行它。
- en: Setting up test scripts in package.json
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`package.json`中设置测试脚本
- en: 'Before we run the test, we''re going to set up the `scripts`, just like we
    did in the test section. We''re going to have two: `test`, which just runs the
    tests; and `test-watch`, which runs the test script through `nodemon`. This means
    that any time we change our app, the tests will rerun.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，我们要设置`scripts`，就像我们在测试部分做的那样。我们将有两个：`test`，只运行测试；和`test-watch`，通过`nodemon`运行测试脚本。这意味着每当我们更改应用程序时，测试都会重新运行。
- en: Right in `test`, we'll be running `mocha`, and the only other argument we need
    to provide is the globbing pattern for the test files. We're going to fetch everything
    in the `server` directory, which could be in a subdirectory (which it will be
    later), so we'll use two stars (`**`). It can have any file name, as long as it
    ends with the `.test.js` extension.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 就在`test`中，我们将运行`mocha`，我们需要提供的唯一其他参数是测试文件的globbing模式。我们将获取`server`目录中的所有内容，这可能在一个子目录中（稍后会有），所以我们将使用两个星号（`**`）。它可以有任何文件名，只要以`.test.js`扩展名结尾。
- en: '[PRE74]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now for `test-watch`, all we''re going to do is run `nodemon`. We''re going
    to be using the `--exec` flag to specify a custom command to run inside of single
    quotes. The command we''re going to run is `npm test`. The `test` script on its
    own is useful, and `test-watch` simply reruns the `test` script every time something
    changes:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于`test-watch`，我们要做的就是运行`nodemon`。我们将使用`--exec`标志来指定一个在单引号内运行的自定义命令。我们要运行的命令是`npm
    test`。单独的`test`脚本是有用的，`test-watch`只是在每次更改时重新运行`test`脚本：
- en: '[PRE75]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: There is still a major flaw we need to fix before we can move on. As you may
    have noticed, inside of the `server.test` file, we make a really big assumption.
    We assume that there's nothing already in the database. We assume this because
    we expect the Todos to be a length of 1 after adding 1, which means that we assumed
    it started at 0\. Now this assumption is not going to be correct. If I were to
    run the test suite right now, it would fail. I already have Todos in the database.
    What we're going to do is add a testing life cycle method in the `server.test`
    file. This one is called `beforeEach`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要修复一个重大缺陷。正如你可能已经注意到的，在`server.test`文件中，我们做出了一个非常大的假设。我们假设数据库中没有任何内容。我们之所以这样假设，是因为我们期望在添加1个待办事项后，待办事项的长度为1，这意味着我们假设它从0开始。现在这个假设是不正确的。如果我现在运行测试套件，它会失败。我已经在数据库中有了待办事项。我们要做的是在`server.test`文件中添加一个测试生命周期方法。这个方法叫做`beforeEach`。
- en: Adding testing life cycle method in server.test.js file
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在server.test.js文件中添加测试生命周期方法
- en: The `beforeEach` method is going to let us run some code before every single
    test case. We're going to use `beforeEach` to set up the database in a way that's
    useful. For now, all we're going to do is make sure the database is empty. We're
    going to pass in a function, that function is going to get called with a `done`
    argument, just like our individual test cases are.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`方法将允许我们在每个测试用例之前运行一些代码。我们将使用`beforeEach`来设置数据库的有用方式。现在，我们要做的只是确保数据库是空的。我们将传入一个函数，该函数将使用`done`参数调用，就像我们的单独测试用例一样。'
- en: '[PRE76]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This function is going to run before every test case and it''s only going to
    move on to the test case once we call `done`, which means we can do something
    asynchronous inside of this function. What I''m going to do is call `Todo.remove`,
    which is similar to the MongoDB native method. All we need to do is pass in an
    empty object; this is going to wipe all of our Todos. Then, we can tack on a `then`
    callback, and inside of the `then` callback we''re going to call `done`, just
    like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将在每个测试用例之前运行，只有在我们调用`done`后才会继续进行测试用例，这意味着我们可以在这个函数中做一些异步的事情。我要做的是调用`Todo.remove`，这类似于MongoDB的原生方法。我们只需要传入一个空对象；这将清除所有的待办事项。然后，我们可以添加一个`then`回调，在`then`回调中，我们将调用`done`，就像这样：
- en: '[PRE77]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, we can also shorten this using the expression syntax:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也可以使用表达式语法来缩短这个：
- en: '[PRE78]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: With this in place, our database is going to be empty before every request,
    and now our assumption is correct. We're assuming we start with 0 Todos, and we
    will indeed start with 0 Todos since we just deleted everything.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的数据库在每次请求之前都将是空的，现在我们的假设是正确的。我们假设我们从0个待办事项开始，并且确实从0个待办事项开始，因为我们刚刚删除了所有内容。
- en: Running the test suite
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试套件
- en: 'I''m going to go ahead and move into the Terminal, clear the Terminal output,
    and now we can start running the test suite by using the following command:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续进入终端，清除终端输出，现在我们可以通过以下命令开始运行测试套件：
- en: '[PRE79]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This is going to start up `nodemon` which will start up the test suite, and
    right here we get one test passing, should create a new todo:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动`nodemon`，它将启动测试套件，然后我们得到一个通过的测试，应该创建一个新的待办事项：
- en: '![](img/f0070bec-b83e-418e-9b90-edf39bd6f374.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0070bec-b83e-418e-9b90-edf39bd6f374.png)'
- en: 'We can verify that everything is working as expected by tweaking some values.
    I can add on `1` as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调整一些值来验证一切是否按预期工作。我可以添加`1`如下：
- en: '[PRE80]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Just to prove that it is actually doing what it says it's doing. You can see
    that we're getting an error because the two are not equal.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了证明它实际上正在做它所说的。你可以看到我们得到了一个错误，因为这两个不相等。
- en: 'The same thing holds true with our status. If I change the status to something
    else, like `201`, the test suite is going to rerun and it is going to fail. Last
    but not least, down below, if I change `toBe` to `3` as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的状态也是一样的。如果我将状态更改为其他值，比如`201`，测试套件将重新运行并失败。最后但并非最不重要的是，如果我将`toBe`更改为`3`，如下所示：
- en: '[PRE81]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It's going to fail because we're always wiping the database, and therefore the
    only correct value here would be `1`. Now that we have this in place, we can add
    our second test case. This is going to be the test case that verifies that a Todo
    does not get created when we send bad data.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这将失败，因为我们总是在清除数据库，因此这里唯一正确的值将是`1`。现在我们已经有了这个，我们可以添加我们的第二个测试用例。这将是验证当我们发送错误数据时，待办事项不会被创建的测试用例。
- en: Test case: should not create todo with invalid body data
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例：不应该使用无效的主体数据创建待办事项
- en: To get started with this one, we will be using `it` to create a brand-new test
    case. The text for this one could be something like `should not create todo with
    invalid body data`. We can pass in our callback with the `done` argument, and
    start making our super-test request.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用这个，我们将使用`it`来创建一个全新的测试用例。这个测试用例的文本可能是`should not create todo with invalid
    body data`。我们可以传入带有`done`参数的回调函数，并开始进行超级测试请求。
- en: 'This time around, there is no need to make a `text` variable since we''re not
    going to be passing text into it. What we''re going to be doing is passing in
    nothing at all:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，不需要创建一个`text`变量，因为我们不会将文本传递进去。我们要做的是什么都不传递：
- en: '[PRE82]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now, what I'd like you to do is make a request just like we did previously.
    You're going to make a `POST` request to the same URL, but instead you're going
    to send `send` as an empty object. This empty object is going to cause the test
    to fail because we won't be able to save the model. Then, you're going to expect
    we get a `400`, which would be the case, we send a 400 in the server.js file.
    You don't need to make any assumptions about the body that comes back.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想让你做的是，像之前一样发出一个请求。你将向相同的URL发出一个`POST`请求，但是你将发送一个空对象作为`send`。这个空对象会导致测试失败，因为我们无法保存模型。然后，你会期望我们得到一个`400`，这将是情况，我们在`server.js`文件中发送了一个400。你不需要对返回的主体做出任何假设。
- en: 'Last but not least, you are going to use the following format; we pass a callback
    to end, check for any errors, and then make some assumptions about the database.
    The assumption you''re going to make is that the length of `todos` is `0`. Since
    the preceding code block does not create a Todo, no Todos should be there. The
    `beforeEach` function is going to run before every test case, so the Todo that
    gets created in `should create a new todo` is going to get deleted before our
    case runs. Go ahead and set that up. Make the request and verify that the length
    is 0\. You don''t need to have the assertion in the previous test case, since
    this assertion asserts something about the array, and the array is going to be
    empty. You can also leave the following assertion off:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将使用以下格式；我们将传递一个回调给`end`，检查是否有任何错误，然后对数据库做出一些假设。你要做的假设是`todos`的长度是`0`。由于前面的代码块没有创建`Todo`，所以不应该有`Todo`存在。`beforeEach`函数将在每个测试用例运行之前运行，所以在我们的用例运行之前，`should
    create a new todo`中创建的`Todo`将被删除。继续设置。发出请求并验证长度是否为0。你不需要在前一个测试用例中进行断言，因为这个断言是关于数组的某些内容，而数组将是空的。你也可以不使用以下断言：
- en: '[PRE83]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Since we're not going to make any assertions about the body. When you're done,
    save the test file. Make sure both of your tests pass.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不会对主体做出任何断言。完成后，保存测试文件。确保你的两个测试都通过了。
- en: 'The first thing I''m going to do is call `request`, passing in our `app`. We
    want to make another post request, so I''ll call `.post` again, and the URL is
    also going to be the same. Now at this point, we are going to be calling `.send`,
    but we''re not going to be passing invalid data. The whole point of this test
    case is to see what happens when we pass in invalid data. What should happen is
    we should get a `400`, so I''m going to `expect` that a `400` response is what
    comes back from the server. Now we don''t need to make any assertions about the
    body, so we can go ahead and move on to `.end`, where we''re going to pass in
    our function that gets called with the `err` argument, if any, and `res`, just
    like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我要做的第一件事是调用`request`，传入我们的`app`。我们想再次发出一个`post`请求，所以我会再次调用`.post`，URL也将是相同的。现在，在这一点上，我们将调用`.send`，但我们不会传递无效的数据。这个测试用例的整个重点是看当我们传入无效数据时会发生什么。应该发生的是我们应该得到一个`400`，所以我期望从服务器得到一个`400`的响应。现在我们不需要对主体做出任何断言，所以我们可以继续进行`.end`，在那里我们将传递我们的函数，该函数将被调用并传入`err`参数，如果有的话，以及`res`，就像这样：
- en: '[PRE84]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we want to do is handle any potential errors. If there is an error we''re
    going to `return`, which stops the function from executing, and we''re going to
    call `done`, passing in that error so the test properly fails:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要做的是处理任何潜在的错误。如果有错误，我们将`return`，这将停止函数的执行，然后我们将调用`done`，传入错误，以便测试正确地失败：
- en: '[PRE85]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Making assertions about the length of the Todos collection
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对`Todos`集合的长度做出断言
- en: Now, we can fetch from the database and make some assertions about the length
    of the Todos collection. I'm going to use `Todo.find` to fetch every single Todo
    inside of the collection. Then, I'll tack on a `then` callback, so I can do something
    with that data. In this case, I'll get the `todos`, and I'm going to assert something
    about its length. We're going to `expect` that `todos.length` equals `toBe` the
    number `0`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从数据库中获取数据，并对`Todos`集合的长度做出一些断言。我将使用`Todo.find`来获取集合中的每一个`Todo`。然后，我将添加一个`then`回调，这样我就可以对数据做一些操作。在这种情况下，我将得到`todos`，并对其长度做出断言。我们将期望`todos.length`等于数字`0`。
- en: '[PRE86]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'There should be no Todos in the database before this test case runs, and since
    we''re sending in bad data, this test case should not create any Todos. We can
    now call `done` and we can also tack on our `catch` callback, which we''re going
    to need to do just like we did previously. We are going to call `catch`, taking
    that error argument and passing it into `done`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试用例运行之前，数据库中不应该有`Todo`，因为我们发送了错误的数据，所以这个测试用例不应该创建任何`Todo`。现在我们可以调用`done`，并且我们也可以添加我们的`catch`回调，就像之前一样。我们将调用`catch`，获取错误参数并将其传递给`done`：
- en: '[PRE87]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And now, we are done. I can save the file. This is going to restart `nodemon`,
    which is going to restart our test suite. What we should see is our two test cases,
    both of them passing. Over in the Terminal, we get just that. We have two test
    cases for `POST /todos`, and both are indeed passing:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们完成了。我可以保存文件了。这将重新启动`nodemon`，这将重新启动我们的测试套件。我们应该看到的是我们的两个测试用例，它们都通过了。在终端中，我们确实看到了这一点。我们有两个`POST
    /todos`的测试用例，两者都确实通过了：
- en: '![](img/9b7eb6b6-3f5b-4b0d-a3a5-3dec02aac70a.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b7eb6b6-3f5b-4b0d-a3a5-3dec02aac70a.png)'
- en: It took a little while to set up the basic test suite in this section, but in
    the future as we add more routes, testing is going to be much easier. We're not
    going to have to set up the infrastructure; we're not going to need to create
    the test scripts or install new modules.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，设置基本的测试套件花了一些时间，但是在将来，随着我们添加更多的路由，测试将会更容易。我们不需要设置基础设施；我们也不需要创建测试脚本或安装新的模块。
- en: Making commit for POST /todos route
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`POST /todos`路由做出提交
- en: 'The last thing to do is make a commit. We added some meaningful code, so we''re
    going to want to save that work. If I run `git status`, you can see we have a
    few changed files as well as some untracked ones, so I will use `git add .` to
    add all of those to the next commit. Now, I can use `git commit` with the `-m`
    flag to actually make the commit. A good commit message for this one would be
    `Test POST /todos route`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的就是提交。我们添加了一些有意义的代码，所以我们要保存这项工作。如果我运行`git status`，您可以看到我们有一些更改的文件以及一些未跟踪的文件，所以我将使用`git
    add .`将所有这些添加到下一个提交中。现在，我可以使用`git commit`和`-m`标志来实际进行提交。对于这个提交，一个好的提交消息将是`测试POST
    /todos路由`。
- en: '[PRE88]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: I'm going to make the commit, and lastly, I'll be pushing this up to GitHub
    using `git push`. You can use `git push` for this particular case. I need to go
    ahead and use `git push --force`, which is going to overwrite everything on GitHub.
    This is only something I need to do in this specific situation. You should just
    be running `git push`. Once you run that, your code should get pushed up to GitHub,
    and you are done. We have two test cases for our route, and it's time to move
    on and add a new route. The next route is going to be a `GET` request to fetch
    all Todos.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我将进行提交，最后，我将使用`git push`将其推送到GitHub。您可以在这种特殊情况下使用`git push`。我需要使用`git push --force`，这将覆盖GitHub上的所有内容。这只是我在这种特定情况下需要做的事情。您应该只运行`git
    push`。运行后，您的代码应该被推送到GitHub，然后就完成了。我们的路由有两个测试案例，现在是时候继续添加新的路由了。下一个路由将是一个`GET`请求，用于获取所有Todos。
- en: List Resources - GET /todos
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出资源 - GET /todos
- en: With our test suite in place, it's now time to create our second route, the
    `GET /todos` route, which will be responsible for returning all of your Todos.
    This is useful for any Todo application.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试套件已经就位，是时候创建我们的第二个路由了，即`GET /todos`路由，它将负责返回所有的Todos。这对于任何Todo应用程序都是有用的。
- en: Creating the GET /todos route
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建GET /todos路由
- en: 'The first screen you''re probably going to show a user is a list of all of
    their Todos. This is the route you would use to get that information. It''s going
    to be a `GET` request so I''m going to use `app.get` to register the route handler,
    and the URL itself is going to match the URL we have, `/todos`, because we want
    to get all of the Todos. Later on when we get an individual Todo, the URL will
    look something like `/todos/123`, but for now we''re going to match it with the
    POST URL. Next up, we can add our callback right above `app.listen` in `server.js`;
    this is going to give us our request and response objects:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能要向用户显示的第一个屏幕是他们所有的Todos列表。这是您用来获取信息的路由。这将是一个`GET`请求，所以我将使用`app.get`来注册路由处理程序，URL本身将与我们的URL匹配，`/todos`，因为我们想要获取所有的Todos。稍后当我们获取单个Todo时，URL将看起来像`/todos/123`，但现在我们将其与POST
    URL匹配。接下来，我们可以在`server.js`中的`app.listen`上面添加我们的回调；这将给我们我们的请求和响应对象：
- en: '[PRE89]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: All we need to do is get all of the Todos in the collection, which we've already
    done in the test file. Inside of `server.test.js`, we used `Todo.find` to fetch
    all of the Todos. We're going to use that same technique right here, but we're
    not passing in a query; we want to return everything.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是获取集合中的所有Todos，这一步我们已经在测试文件中完成了。在`server.test.js`中，我们使用`Todo.find`来获取所有的Todos。我们将在这里使用相同的技术，但是我们不会传入查询；我们想要返回所有内容。
- en: '[PRE90]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Later on when we add authentication you'll get back just the `Todos` you created,
    but for now, without authentication you're going to get everything in the `Todos`
    collection back.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后当我们添加身份验证时，您将只获取您创建的`Todos`，但是现在，没有身份验证，您将获取`Todos`集合中的所有内容。
- en: Next up, we're going to attach a `then` call. This `then` call is going to take
    two functions, the success case function when the promise gets resolved, and a
    function that gets fired when the promise gets rejected. The success case will
    get called with all of the `todos` and all we're going to do is send that information
    back using `res.send`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个`then`调用。这个`then`调用将使用两个函数，一个是成功案例函数，当承诺被解决时调用，另一个是当承诺被拒绝时调用的函数。成功案例将使用所有的`todos`调用，并且我们要做的就是使用`res.send`将这些信息发送回去。
- en: '[PRE91]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We could pass in the `todos` array, but this is not the best way to get the
    job done. When you pass back an array you''re kind of locking yourself down. If
    you want to add on another property, whether it''s a custom status code or some
    other data, you can''t because you have an array. The better solution would be
    to create an object, and on that object specify `todos`, setting it equal to the
    `todos` array using ES6:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传入`todos`数组，但这不是完成任务的最佳方式。当您返回一个数组时，您有点束缚自己。如果您想添加另一个属性，无论是自定义状态代码还是其他数据，您都不能，因为您有一个数组。更好的解决方案是创建一个对象，并在该对象上指定`todos`，使用ES6将其设置为`todos`数组：
- en: '[PRE92]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This would let you add other properties later on. For example, I could add
    some sort of custom status code setting it equal to whatever I like. By using
    an object as opposed to sending an array back, we''re opening ourselves up to
    a more flexible future. With this in place, our success case is good to go. The
    only thing we need to do to wrap this one up is handle errors, and the error handler
    is going to look exactly like the one we used previously, `res.status`. We''re
    going to be sending back a `400` and we''ll be sending back the error object that
    got passed into the function:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让您以后添加其他属性。例如，我可以添加某种自定义状态代码，将其设置为我喜欢的任何值。通过使用对象而不是发送一个数组回来，我们为更灵活的未来打开了可能性。有了这个，我们的成功案例就可以运行了。我们唯一需要做的就是处理错误，错误处理程序将与我们之前使用的一样，`res.status`。我们将发送一个`400`，并将发送回传入函数的错误对象：
- en: '[PRE93]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now that we have this in place, we can go ahead and start up our server and
    test things out over inside of Postman.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了这一步，我们可以启动服务器并在Postman中测试一下。
- en: Testing the GET /todos route
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试GET /todos路由
- en: 'I''m going to fire up the server using the following command:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用以下命令启动服务器：
- en: '[PRE94]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Inside of Postman, we can get started by creating some Todos. Currently, our
    application and the tests for the application use the same database. The `beforeEach`
    method call we ran in the last section unfortunately wiped everything, which means
    we have no data to fetch. The first thing I''m going to do in Postman is try to
    fetch the data we should get back an empty array, which should still work. The
    URL is going to be `localhost:3000/todos` and it is indeed going to be a GET request.
    I can click Send, which is going to fire off the request, and we get our data
    back:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中，我们可以开始创建一些待办事项。目前，我们的应用程序和应用程序的测试使用相同的数据库。在上一节中我们运行的`beforeEach`方法调用不幸地擦除了一切，这意味着我们没有数据可获取。我在Postman中要做的第一件事是尝试获取我们应该得到的数据，我们应该得到一个空数组，这仍然可以工作。URL将是`localhost:3000/todos`，确实将是一个GET请求。我可以点击发送，这将触发请求，然后我们得到我们的数据：
- en: '![](img/34dbc53f-5ac8-4bcd-87f9-143839ddf738.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34dbc53f-5ac8-4bcd-87f9-143839ddf738.png)'
- en: We have an object, we have our `todos` property, and we have our empty array,
    which is expected.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个对象，我们有我们的`todos`属性，我们有我们的空数组，这是预期的。
- en: 'Now, as you may have noticed, manually configuring a route every single time
    you want to use it gets pretty tedious, and we''re going to be using a lot of
    the same routes over and over again. With Postman, we can actually create a collection
    of routes so we can re-fire requests without having to manually enter all of the
    information. Over on the right-hand side, I can click the drop-down arrow next
    to Save and click Save As. Here, I can give my request a little bit of detail:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能已经注意到，每次想要使用它时手动配置路由变得非常乏味，我们将一遍又一遍地使用相同的路由。通过Postman，我们实际上可以创建一个路由集合，这样我们就可以重新发送请求，而不必手动输入所有信息。在右侧，我可以单击保存旁边的下拉箭头，然后单击另存为。在这里，我可以给我的请求一些详细信息：
- en: '![](img/ac4b8cb6-153b-417c-96cd-269e9679134e.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac4b8cb6-153b-417c-96cd-269e9679134e.png)'
- en: I'm going to change the Request Name to `GET /todos`; this is the naming convention
    I like to use, the HTTP method followed by the URL. We can leave the description
    blank for now, and we can create a new collection since we don't have any. The
    Postman Echo collection is an example collection Postman gives you to explore
    this feature. We're going to make one called `Todo App`. Now, anytime we want
    to run that command, all we do is we go to Collections, click GET /todos, click
    Send, and the request fires.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我将请求名称更改为`GET /todos`；这是我喜欢使用的命名约定，HTTP方法后跟URL。我们现在可以暂时将描述留空，并且我们可以创建一个新的集合，因为我们没有任何集合。Postman
    Echo集合是Postman提供给您探索此功能的示例集合。我们将创建一个名为`Todo App`的集合。现在，每当我们想要运行该命令时，我们只需转到集合，点击GET
    /todos，点击发送，请求就会触发。
- en: Let's go ahead and set up a `POST` request to create a Todo, and then we'll
    run that, save it, and rerun `GET` to make sure it returns the newly created Todo.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续设置一个`POST`请求来创建一个待办事项，然后我们将运行它，保存它，并重新运行`GET`以确保返回新创建的待办事项。
- en: Setting up Post request to create a todo
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Post请求以创建待办事项
- en: 'To create the `POST` request, if you recall, we have to change the method to
    POST and the URL will be the same, `localhost:3000/todos`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`POST`请求，如果您还记得，我们必须将方法更改为POST，URL将保持不变，`localhost:3000/todos`：
- en: '![](img/49eb0feb-7dd5-4958-9e2c-01e98e4a4b11.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49eb0feb-7dd5-4958-9e2c-01e98e4a4b11.png)'
- en: 'Now, in order for this request to succeed, we also have to pass along a Body
    tab. This one is going to be a raw JSON body. Here, we can specify the data we''d
    like to send. In this case, the only data property we''re going to send is `text`,
    and I''ll set this to `Something to do from postman`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使这个请求成功，我们还必须传递一个Body标签。这个标签将是一个原始的JSON主体。在这里，我们可以指定我们想要发送的数据。在这种情况下，我们要发送的唯一数据属性是`text`，我将其设置为`从Postman做的一些事情`：
- en: '[PRE95]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, we can go ahead and fire this off, and down below we get our newly created
    Todo with a 200 status code:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续执行此操作，然后在下面，我们得到了我们新创建的带有200状态代码的Todo：
- en: '![](img/e5588bc3-06ee-437a-8df9-f71995efcf4a.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5588bc3-06ee-437a-8df9-f71995efcf4a.png)'
- en: 'Which means everything went well. We can save this to our collections so we
    can easily rerun this one later. I''m going to change the Request Name to `POST
    /todos`, following that same syntax. Then, I can then select an existing collection,
    the Todo App collection, and save it:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一切都进行得很顺利。我们可以将其保存到我们的集合中，以便稍后可以轻松地重新运行此操作。我将请求名称更改为`POST /todos`，遵循相同的语法。然后，我可以选择现有的集合，Todo
    App集合，并保存它：
- en: '![](img/8c148816-7449-49fd-9c48-d2b819286d1c.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c148816-7449-49fd-9c48-d2b819286d1c.png)'
- en: Now I can simply click the request, using *command* + *enter*, or clicking the
    Send button, to fire off the request, and I get my `todos` array—everything looks
    great.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我只需点击请求，使用*command* + *enter*，或单击发送按钮，即可发送请求，然后我得到了我的`todos`数组，一切看起来都很好。
- en: 'I can always click POST, add a second one, tweak it if I like, adding the number
    `2`, and then I can use *command* + *enter* to fire that one off. I can rerun
    the `GET` request and I have my two `todos` in the database:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是可以点击POST，添加第二个，如果我喜欢，可以进行微调，添加数字`2`，然后我可以使用*command* + *enter*来发送它。我可以重新运行`GET`请求，然后在数据库中有两个`todos`：
- en: '![](img/e15ee861-0822-44b8-8e3a-9006edc40d0e.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e15ee861-0822-44b8-8e3a-9006edc40d0e.png)'
- en: With this in place, our `GET /todos` request is now complete. We also set up
    our collection in Postman, making it really easy to fire off any of these HTTP
    requests much faster.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的`GET /todos`请求现在已经完成。我们还在Postman中设置了我们的集合，这样就可以更快地触发任何这些HTTP请求。
- en: 'I''m going to go ahead and wrap this section up by making a commit over in
    the Terminal. I''m going to shut the server down and run `git status`. This time
    around, you''ll see that we just have one file and it is modified, which means
    instead of using `git add`, we can simply use `git commit` with the `-a` flag.
    The `-a` flag adds all modified files to the next commit. It does not work for
    new, untracked files, but modified files are perfectly fine. Then, I can tack
    on the `-m` flag to specify my commit message. A good one for this will be `Add
    GET /todos route`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过在终端中进行提交来结束本节。我将关闭服务器并运行`git status`。这一次，你会看到我们只有一个文件被修改，这意味着我们可以简单地使用`git
    commit`和`-a`标志，而不是使用`git add`。`-a`标志将所有修改的文件添加到下一个提交中。它不适用于新的、未跟踪的文件，但修改的文件是完全可以的。然后，我可以添加`-m`标志来指定我的提交消息。对于这个来说，一个好的提交消息将是`Add
    GET /todos route`：
- en: '[PRE96]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Last up, we're going to push it up to GitHub using `git push`, and now we are
    done. In the next section, we'll write test cases for `GET /todos`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`git push`将其推送到GitHub，现在我们完成了。在下一节中，我们将为`GET /todos`编写测试用例。
- en: Testing GET /todos
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试GET /todos
- en: With our `GET /todos` route now in place, it is time to add a test case for
    it. Now, before we can actually write the test case, we have to deal with a different
    problem. The first thing we do inside of our `server.test` file is delete all
    the Todos, and this happens before every single test. The `GET /todos` route pretty
    much lives off the fact that there are Todos it can return. It will handle Node
    Todos, but for our test case, we want some data in that database.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`GET /todos`路由已经就位，是时候为它添加一个测试用例了。现在，我们实际上可以编写测试用例之前，我们必须处理一个不同的问题。我们在`server.test`文件中的第一件事是删除所有的Todos，这发生在每个测试之前。`GET
    /todos`路由基本上依赖于数据库中有它可以返回的Todos。它将处理Node Todos，但对于我们的测试用例，我们希望数据库中有一些数据。
- en: In order to add this data, what we're going to do is modify `beforeEach`, adding
    some seed data. This means that our database is still going to be predictable;
    it's always going to look exactly the same when it starts, but it will have some
    items in it.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加这些数据，我们要做的是修改`beforeEach`，添加一些种子数据。这意味着我们的数据库仍然是可预测的；当它启动时，它总是看起来完全一样，但它会有一些项目。
- en: Adding seed data for the GET /todos test case
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为GET /todos测试用例添加种子数据
- en: 'Now, in order to do that, the first thing that we''re going to do is make up
    an array of dummy Todos. These Todos only need the `text` property since everything
    else is going to get populated by Mongoose. I can create a constant called `todos`,
    setting it equal to an array, and we''re going to have an array of objects where
    each object has a `text` property. For example, this one could have a text of `First
    test todo`, and then I can add on a second object as the second item in the array,
    with a `text` property equal to `Second test todo`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了做到这一点，我们要做的第一件事是制作一个虚拟Todos数组。这些Todos只需要`text`属性，因为其他所有内容都将由Mongoose填充。我可以创建一个名为`todos`的常量，将其设置为一个数组，我们将有一个对象数组，其中每个对象都有一个`text`属性。例如，这个可以有一个文本为`First
    test todo`，然后我可以在数组的第二个项目中添加第二个对象，其`text`属性等于`Second test todo`：
- en: '[PRE97]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Now before we can actually write the test case, we have to modify `beforeEach`
    using a brand new Mongoose method called `insertMany`, which takes an array, as
    shown in the preceding code block, and inserts all of those documents into the
    collection. This means that we are going to need to tweak the code real quick.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实际上可以编写测试用例之前，我们必须使用一个全新的Mongoose方法`insertMany`修改`beforeEach`，它接受一个数组，如前面的代码块所示，并将所有这些文档插入集合中。这意味着我们需要快速调整代码。
- en: 'Instead of having a simple arrow function that calls `done`, I''m going to
    tack on some curly braces and inside of the callback function, we''re going to
    call `Todo.insertMany` and we''re going to call `insertMany` with the array we
    defined in the preceding code block. This is going to insert all of the Todos
    in this array, our two Todos, and then we can do something like call `done`. I''m
    going to return the response, which is going to let us chain callbacks, and then
    I can tack on a `then` method, where I can use a really simple expression-based
    arrow function. All I''m going to do is call `done` using the expression syntax:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 不是使用一个简单的箭头函数调用`done`，我要加上一些花括号，在回调函数内部，我们将调用`Todo.insertMany`，并且我们将使用在前面的代码块中定义的数组调用`insertMany`。这将插入数组中的所有Todos，我们的两个Todos，然后我们可以做一些像调用`done`的事情。我将返回响应，这将让我们链接回调，然后我可以添加一个`then`方法，在那里我可以使用一个非常简单的基于表达式的箭头函数。我要做的就是使用表达式语法调用`done`：
- en: '[PRE98]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, let''s go ahead and run the test suite. I''ll warn you now, the other
    tests are going to have problems because the numbers that they assert are now
    going to be incorrect. Over in the Terminal, I''m going to start up the test suite
    by using the following command:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续运行测试套件。我现在警告你，其他测试会出问题，因为它们断言的数字现在将不正确。在终端中，我将使用以下命令启动测试套件：
- en: '[PRE99]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Once that test suite gets started, I'm going to move back into Atom and as you
    can see, as promised, both of the test cases failed. We expected `3` to be `1`
    and we expected `2` to be `0`. Everything is now off by `2`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试套件启动，我将回到Atom，正如承诺的那样，两个测试用例都失败了。我们期望`3`是`1`，我们期望`2`是`0`。现在所有的都错了`2`。
- en: 'To fix this, we''re going to use two different techniques. Inside the server.test.js
    file, in the Post todos test, for the first test, we''re going to do is only going
    to find Todos where the `text` property equals to the `Test todo text`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将使用两种不同的技术。在server.test.js文件中，在Post todos测试中，对于第一个测试，我们要做的是只查找`text`属性等于`Test
    todo text`的Todos：
- en: '[PRE100]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This means that the resulting length is still going to be `1` and the first
    item should still have a `text` property equal to the text above. For the second
    test, we''re going to leave the `find` call the way it is; instead, we''re going
    to make sure that the length of the database is `2`:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着结果的长度仍然是`1`，第一项仍然应该有一个`text`属性等于上面的文本。对于第二个测试，我们将保持`find`调用不变；相反，我们将确保数据库的长度为`2`：
- en: '[PRE101]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'There should only be two documents in the Todos collection because that''s
    all we added, and this was testing a failure so a third one should not have been
    added. With this in place, you can see our two test cases are now passing:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: Todos集合中应该只有两个文档，因为这是我们添加的所有内容，这是一个失败的测试，所以不应该添加第三个。有了这个设置，你可以看到我们的两个测试用例现在通过了：
- en: '![](img/5938a07e-7023-4bbc-8d15-0354b7666740.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5938a07e-7023-4bbc-8d15-0354b7666740.png)'
- en: We're now ready to move on and add a new `describe` block in the test case.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续并在测试用例中添加一个新的`describe`块。
- en: Adding a describe block to the test case
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试用例中添加一个描述块
- en: 'I''m going to add a `describe` block, which is going to describe the `GET /todos`
    route, passing in our arrow function, and then we can add our single test case,
    `it(''should get all todos'', )`. Now, in this case, all `todos` refer to the
    two Todos we just added previously. I''m going to pass in an arrow function with
    the `done` argument and we are good to go. All we have to do is start the super
    test request—I''m going to `request` something on the express application—this
    is going to be a GET request so we''ll call `.get`, passing in the URL `/todos`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加一个`describe`块，描述`GET /todos`路由，传入我们的箭头函数，然后我们可以添加我们的单个测试用例，`it('should get
    all todos', )`。现在，在这种情况下，所有的`todos`都指的是我们之前添加的两个Todos。我将传入一个带有`done`参数的箭头函数，我们准备好了。我们所要做的就是开始super
    test请求——我将在express应用程序上`request`一些东西——这将是一个GET请求，所以我们将调用`.get`，传入URL`/todos`：
- en: '[PRE102]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: With this in place, we're now ready to make our assertions; we're not sending
    any data in the request body, but we are going to make some assertions about what
    comes back.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在准备做出我们的断言；我们没有在请求体中发送任何数据，但我们将对返回的内容做出一些断言。
- en: Adding assertions to the test case
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试用例中添加断言
- en: We're going to `expect` that a `200` comes back and we're also going to create
    a custom assertion, expecting something about the body. We'll provide our callback
    function with the response and we're going to `expect` that `res.body.todos` has
    a length of `2`, `.toBe(2)`. Now that we have this in place, all we have to do
    is tack on an `end` call, and pass in `done` as the argument.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望返回`200`，并且我们还将创建一个自定义断言，期望关于body的一些内容。我们将使用响应提供我们的回调函数，并期望`res.body.todos`的长度为`2`，`.toBe(2)`。现在我们有了这个设置，我们所要做的就是添加一个`end`调用，并将`done`作为参数传递。
- en: '[PRE103]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: There is no need to provide a function to end, because we're not doing anything
    asynchronously.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要提供一个结束函数，因为我们不是异步地做任何事情。
- en: 'With this in place, we are now good to go. We can save the `server.test` file.
    This is going to rerun the test suite using `nodemon`; we should see our new test
    and it should be passing. In the Terminal, we get just that:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在可以继续了。我们可以保存`server.test`文件。这将使用`nodemon`重新运行测试套件；我们应该看到我们的新测试，并且它应该通过。在终端中，我们就是这样得到的：
- en: '![](img/d04de850-8dd9-43c5-8f4b-f04d8d8571ea.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d04de850-8dd9-43c5-8f4b-f04d8d8571ea.png)'
- en: We have our section for `POST /todos`; both of these tests are passing and we
    have our section for `GET /todos`, and the one test is indeed passing. Now if
    I change the status to `201`, the test is going to fail because that's not the
    status that came back. If I change the length to `3`, it's going to fail because
    we only added 2 Todos in as the seed data.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`POST /todos`部分；这两个测试都通过了，我们有`GET /todos`部分，一个测试确实通过了。现在，如果我将状态更改为`201`，测试将失败，因为这不是返回的状态。如果我将长度更改为`3`，它将失败，因为我们只添加了2个Todos作为种子数据。
- en: 'Now that we''re done, let''s go ahead and make a commit, saving this code.
    I''m going to shut down the `test-watch` script, run a `git status` command, and
    we have two modified files, which means I can use `git commit` with the `-a` flag
    and the `-m` flag. Remember, the `-a` flag adds modified files to the next commit.
    A good message for this commit is going to be `Add tests for GET /todos`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了，让我们继续提交，保存这段代码。我将关闭`test-watch`脚本，运行`git status`命令，我们有两个修改过的文件，这意味着我可以使用`git
    commit`与`-a`标志和`-m`标志。记住，`-a`标志将修改的文件添加到下一个提交。这次提交的好消息是`Add tests for GET /todos`：
- en: '[PRE104]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: I'm going to make the commit, push it up to GitHub, and then we are done.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我要提交，将其推送到GitHub，然后我们就完成了。
- en: Summary
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we worked on setting up mongoose, connecting mongoose to the
    database. We created few Todos model and run the test script. Next, we looked
    into mongoose validators, Defaults and types, and customize todo model properties
    such as test, completed and completedAt. Then, we looked in the basics of Postman
    and made HTTP request to Google. We also looked into configuring some todo routes,
    mainly POST /todos and GET /todos. We also looked into creating test cases and
    testing these routes.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们致力于设置mongoose，将mongoose连接到数据库。我们创建了一些Todos模型并运行了测试脚本。接下来，我们研究了mongoose验证器、默认值和类型，并自定义了todo模型的属性，如测试、完成和完成时间。然后，我们了解了Postman的基础知识，并向Google发出了HTTP请求。我们还研究了配置一些todo路由，主要是POST
    /todos和GET /todos。我们还研究了创建测试用例和测试这些路由。
- en: With this in place, we are ready to move on to adding a brand new route, which
    is coming up in the next chapter.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在准备继续添加一个全新的路由，这将在下一章中进行。
