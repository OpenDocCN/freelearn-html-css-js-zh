- en: '*Chapter 6*: Setting Up Our Project Using create-react-app and Testing with
    Jest'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：使用create-react-app设置我们的项目，并使用Jest进行测试'
- en: In this chapter, we'll learn about the tools that help us build React applications.
    High-level, professional application development, regardless of the language or
    framework, always involves using tooling to help build applications faster and
    with higher code quality. The React development ecosystem is no different. A community
    has gathered around certain tooling and coding methodologies and we will go over
    those in this chapter. These sophisticated tools and methods will help us code
    better applications and help us refactor our code to adapt it to new requirements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习帮助我们构建React应用程序的工具。无论语言或框架如何，高级的专业应用程序开发总是涉及使用工具来帮助更快地构建应用程序并提高代码质量。React开发生态系统也不例外。一个社区已经围绕着某些工具和编码方法形成，并且我们将在本章中介绍这些。这些复杂的工具和方法将帮助我们编写更好的应用程序，并帮助我们重构我们的代码以使其适应新的需求。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Learning React development methods and about the build system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习React开发方法和构建系统
- en: Understanding client-side testing for React
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解React的客户端测试
- en: Learning common tools and practices for React development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习React开发的常见工具和实践
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You should have a basic understanding of web development and the SPA style of
    coding that we've been learning in the previous chapters. We will once again be
    using Node (npm) and VS Code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对Web开发和我们在之前章节中学习的SPA编码风格有基本的了解。我们将再次使用Node（npm）和VS Code。
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in folder `Chap6`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库位于[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node)。使用`Chap6`文件夹中的代码。
- en: To set up the [*Chapter 6*](B15508_06_Final_JC_ePub.xhtml#_idTextAnchor091)
    code folder on your own machine, go to your `HandsOnTypescript` folder and create
    a new folder called `Chap6`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您自己的机器上设置[*第6章*](B15508_06_Final_JC_ePub.xhtml#_idTextAnchor091)代码文件夹，请转到您的`HandsOnTypescript`文件夹并创建一个名为`Chap6`的新文件夹。
- en: Learning React development methods and about the build system
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习React开发方法和构建系统
- en: In this section, we will learn about the tools and practices used for coding
    and building React applications. Many of these methods are used in general for
    modern JavaScript development, even in competing frameworks such as Angular and
    Vue.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习用于编码和构建React应用程序的工具和实践。这些方法中的许多方法通常用于现代JavaScript开发，甚至在竞争框架如Angular和Vue中也是如此。
- en: In order to build large, complex applications, we need tools – lots and lots
    of tools. Some of these tools will help us write better quality code, some will
    help us share and manage our code, and still others will exist only to enhance
    developer productivity and make it easier to debug and test our code. Therefore,
    by learning the tooling used to build modern React apps, we will ensure our application
    works as it should with minimal issues.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建大型、复杂的应用程序，我们需要工具 - 大量的工具。其中一些工具将帮助我们编写更高质量的代码，一些将帮助我们共享和管理我们的代码，还有一些将存在只是为了增强开发人员的生产力，并使调试和测试我们的代码变得更容易。因此，通过学习用于构建现代React应用程序的工具，我们将确保我们的应用程序能够以最少的问题正常工作。
- en: Project tools
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目工具
- en: As we've seen from the prior chapters, modern React development uses many components
    to build a final application. For project structure and base dependencies, most
    developers will use `create-react-app`, which is based on the development tools
    first created for Node development (npm). We've already seen what `create-react-app`
    can do, but in this section, we'll take a deeper look.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从之前的章节中看到的，现代React开发使用许多组件来构建最终的应用程序。对于项目结构和基本依赖项，大多数开发人员将使用`create-react-app`，这是基于最初为Node开发（npm）创建的开发工具。我们已经看到了`create-react-app`可以做什么，但在本节中，我们将深入了解一下。
- en: But first, we need to understand how we arrived at using the current state of
    the art in tools and coding. This knowledge will help us better understand why
    a shift to this current style was made and what the benefits are.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要了解我们是如何使用当前的工具和编码方式的。这些知识将帮助我们更好地理解为什么要转向当前的风格以及好处是什么。
- en: How it was done before tooling
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以前是如何完成的
- en: 'The web is actually a hodgepodge of different technologies. HTML came first,
    to create text sharing capabilities. Then CSS, for better styling and document
    structure. And then finally, JavaScript, to add some event-driven capabilities
    and programmatic control. So, it''s no wonder that sometimes integrating these
    technologies into a single coherent application can feel awkward and even difficult.
    Let''s look at some examples of bringing these pieces together without using much
    tooling:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 网络实际上是由不同的技术拼凑而成的。HTML首先出现，用于创建文本共享功能。然后是CSS，用于更好的样式和文档结构。最后是JavaScript，用于添加一些事件驱动的功能和编程控制。因此，难怪有时将这些技术整合到一个统一的应用程序中会感到尴尬甚至困难。让我们看一些例子，将这些部分整合在一起而不使用太多的工具：
- en: Open your terminal or command line to the `Chap6` folder. Create a new folder
    called `OldStyleWebApp`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端或命令行到`Chap6`文件夹。创建一个名为`OldStyleWebApp`的新文件夹。
- en: 'Using VS Code create an HTML file called `index.html` and add this code into
    it. We''ll create a simple input and display:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用VS Code创建一个名为`index.html`的HTML文件，并将以下代码添加到其中。我们将创建一个简单的输入和显示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create a `.css` file called `core.css` in the same folder.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中创建一个名为`core.css`的`.css`文件。
- en: Create a `.js` file called `script.js` in the same folder.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中创建一个名为`script.js`的`.js`文件。
- en: 'Now, we''ll fill in the CSS and JS files later, but immediately we have an
    issue. How do I run this app? In other words, how do I see it run so I can check
    whether it''s working? Let''s see what we can do:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们稍后会填写CSS和JS文件，但是立即我们遇到了一个问题。我怎么运行这个应用程序？换句话说，我怎么看到它运行，以便我可以检查它是否工作？让我们看看我们能做什么：
- en: In your VS Code, right-click on the `index.html` file and copy its path like
    this:![Figure 6.1 – Copy index.html
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的VS Code中，右键单击`index.html`文件并复制其路径，如下所示：![图6.1 – 复制index.html
- en: '](img/Figure_6.01_B15508.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01_B15508.jpg)'
- en: Figure 6.1 – Copy index.html
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 复制index.html
- en: Now, open your browser and paste this file path into the URL. You should see
    the following:![Figure 6.2 – index.html in the browser
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开您的浏览器，并将此文件路径粘贴到URL中。您应该会看到以下内容：![图6.2 – 浏览器中的index.html
- en: '](img/Figure_6.02_B15508.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.02_B15508.jpg)'
- en: Figure 6.2 – index.html in the browser
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 浏览器中的index.html
- en: You may not have already known this, but you do not need an HTTP server in order
    to view HTML files in your browser. However, you can see this process isn't the
    most efficient and it would be better if it could be automated, including auto-refreshing
    when I make changes to any related files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还不知道，但您不需要HTTP服务器才能在浏览器中查看HTML文件。但是，您可以看到这个过程并不是最有效的，如果能自动化，包括在我对任何相关文件进行更改时自动刷新，那将更好。
- en: 'Now, let''s fill in our CSS file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们填写我们的CSS文件：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You'll notice that even if I save this file, the `label` element on the web
    browser does not automatically update. I have to refresh my browser and then it
    will update. What if I have dozens of files that get updated during my development
    session? Having to manually refresh each time would not be a good experience.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，即使我保存了这个文件，Web浏览器上的`label`元素也不会自动更新。我必须刷新浏览器，然后它才会更新。如果我在开发会话期间更新了数十个文件怎么办？每次都手动刷新将不是一个好的体验。
- en: 'Next, let''s add some code to `script.js`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`script.js`中添加一些代码：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We want to read this code carefully as there are multiple issues with it. Let's
    see what those issues are. If we save this file, open the browser debugger tools,
    and then refresh the browser, you can see that it fails immediately with this
    error in the `create-react-app` project tooling. `create-react-app` projects have
    what's called a linter. A linter is a code checker tool that runs in the background
    as you're writing your code. It will check for common errors, such as the one
    we just saw, so that it they do not end up in your production code. There's a
    lot more functionality to linters, but we will explore them more deeply later.
    The point here is we want to avoid these types of errors before running the app.
    And `create-react-app`, or in this case some of the built-in tooling, can help
    us do that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要仔细阅读这段代码，因为它存在多个问题。让我们看看这些问题是什么。如果我们保存这个文件，打开浏览器调试工具，然后刷新浏览器，您会看到在`create-react-app`项目工具中立即出现了这个错误。`create-react-app`项目具有所谓的linter。linter是一个代码检查工具，它在您编写代码时在后台运行。它将检查常见错误，比如我们刚刚看到的错误，以便它们不会出现在您的生产代码中。linter还有更多功能，但我们将在以后更深入地探讨它们。关键在于我们希望在运行应用程序之前避免这些类型的错误。而`create-react-app`，或者在这种情况下一些内置的工具，可以帮助我们做到这一点。
- en: 'Let''s try adding the correct variable name and try reloading the browser again.
    Update the `script.js` file like this, save it, and then reload the browser:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试添加正确的变量名，并再次重新加载浏览器。像这样更新`script.js`文件，保存它，然后重新加载浏览器：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see in the debugger console, the log statement does not find the
    `inputEl`, as it returns `null`. This is happening because we mistyped the `id`
    of the `input` element as `"userNam"` instead of `"userName"`. Now, again, with
    the `create-react-app` project running, this sort of error is simply not possible,
    because the vast majority of React code does not attempt to query or look for
    elements in our HTML page. Instead, we use React components directly and therefore
    we can avoid this class of error altogether. Admittedly it is possible to opt
    out of this behavior and use a reference to HTML elements via `useRef`. However,
    this is something that should be done sparingly, as you are deliberately exiting
    out of the normal React ecosystem behavior by using this Hook and therefore losing
    its benefits.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在调试器控制台中所看到的，日志语句找不到`inputEl`，因为它返回`null`。这是因为我们将`input`元素的`id`误写为`"userNam"`而不是`"userName"`。现在，再次运行`create-react-app`项目时，这种错误根本不可能发生，因为绝大多数React代码不会尝试查询或查找我们HTML页面中的元素。相反，我们直接使用React组件，因此我们可以完全避免这类错误。诚然，可以选择退出此行为并通过`useRef`使用对HTML元素的引用。然而，这应该是一种谨慎的做法，因为通过使用此Hook故意退出正常的React生态系统行为，从而失去其好处。
- en: 'Let''s fix our `script.js` file and complete it. Update it like so:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修复我们的`script.js`文件并完成它。像这样更新它：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run this code by refreshing the browser, you will see that if you type
    your name into the input box and then click out of the input element, a message
    will display like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过刷新浏览器来运行此代码，您会看到如果您在输入框中输入您的姓名，然后点击输入元素外部，将显示如下消息：
- en: '![Figure 6.4 – Welcome display'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 欢迎显示'
- en: '](img/Figure_6.04_B15508.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.04_B15508.jpg)'
- en: Figure 6.4 – Welcome display
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 欢迎显示
- en: So, this code does work to display a welcome message. However, it's easy to
    make mistakes, and not have any help indicating why. In addition to this, notice
    that we have no TypeScript since browsers don't run TypeScript; they can only
    run JavaScript. This means we are also missing the type indicators that are also
    helpful in avoiding bugs related to incorrect types.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这段代码确实可以显示欢迎消息。然而，很容易出错，而且没有任何帮助指示原因。除此之外，请注意，由于浏览器不运行TypeScript，我们没有TypeScript。这意味着我们也缺少了类型指示器，这些指示器在避免与不正确类型相关的错误方面也很有帮助。
- en: So, we've seen some of the issues around doing things in the original web way.
    But the reality is we haven't even scratched the surface of issues with doing
    development in this manner. For example, having script tags embedded in our HTML
    is a reasonable thing to do when we have only a few scripts to deal with. But
    what about when our dependencies grow? For larger apps, it is quite possible to
    have hundreds of dependencies. Managing that many script tags would be very difficult.
    And not only that – a lot of JavaScript dependencies no longer provide a URL from
    which they can be called.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经看到了在原始的web方式下做事情的一些问题。但事实上，我们甚至还没有触及以这种方式进行开发的问题的表面。例如，在我们的HTML中嵌入脚本标签是一个合理的做法，当我们只有少量脚本要处理时。但是当我们的依赖增长时呢？对于更大的应用程序，很可能会有数百个依赖项。管理那么多脚本标签将会非常困难。而且不仅如此
    - 很多JavaScript依赖项不再提供可以调用的URL。
- en: Having said all this, perhaps one of the biggest issues is the highly free-form
    nature of the code. If you look at the `script.js` file again, you can see there
    is no pattern or structure to the code. Sure, it is likely your team could come
    up with a pattern on its own, but what about new programmers joining the team?
    They would have to learn a unique way of structuring the code that is specific
    to your team.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，也许最大的问题之一是代码的高度自由形式。如果你再看一下`script.js`文件，你会发现代码没有模式或结构。当然，你的团队可能会自己想出一种模式，但是新加入团队的程序员呢？他们将不得不学习一种特定于你的团队的代码结构方式。
- en: So, the point is tooling, frameworks, and structure provide consistent, repeatable
    ways of writing and maintaining code. You can consider it a sort of culture of
    programming, where everyone has accepted the norms and practices of the culture
    and therefore knows what to do and how to behave. This makes code easier to write,
    share, and refactor. Now that we've taken a look at free-form coding, let's start
    looking at `create-react-app` more deeply.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，工具、框架和结构提供了一致、可重复的编写和维护代码的方式。你可以把它看作是一种编程文化，每个人都接受了文化的规范和实践，因此知道该做什么和如何行事。这使得代码更容易编写、共享和重构。现在我们已经看过了自由形式的编码，让我们开始更深入地了解`create-react-app`。
- en: create-react-app
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: create-react-app
- en: In prior chapters, such as [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072),
    *Learning Single-Page Application Concepts and How React Enables Them*, and [*Chapter
    5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081), *React Development with Hooks*,
    we used `create-react-app` to set up our base application project. Let's look
    more closely at what is inside a `create-react-app` project. To better understand
    the parts that make up a `create-react-app` project, we need to `eject` it first.
    Here, eject simply means that we will reveal all of the internal dependencies
    and scripts that make `create-react-app` work, as normally these are hidden.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，比如[*第4章*]（B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072），*学习单页应用程序概念以及React如何实现它们*，以及[*第5章*]（B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081），*使用Hooks进行React开发*，我们使用`create-react-app`来设置我们的基础应用程序项目。让我们更仔细地看一下`create-react-app`项目的内部。为了更好地理解组成`create-react-app`项目的部分，我们首先需要`弹出`它。在这里，弹出只是意味着我们将揭示所有使`create-react-app`工作的内部依赖项和脚本，因为通常这些是隐藏的。
- en: 'Warning: Ejection is a non-reversable action'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：弹出是一个不可逆转的操作
- en: In the vast majority of cases, you will not eject a `create-react-app` project,
    as there is little value in doing so. We are doing it here only to gain more insights
    into how this project works.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝大多数情况下，你不会弹出`create-react-app`项目，因为这样做没有多大价值。我们在这里这样做只是为了更深入地了解这个项目是如何工作的。
- en: 'Let''s look at the steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下步骤：
- en: 'Create a new project inside of the `Chap6` folder by executing the following
    command from inside that folder:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`Chap6`文件夹内执行以下命令来在其中创建一个新项目：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s eject the project. Change directories in your command line to the
    new `ejected-app` folder and run this command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们弹出项目。在命令行中切换到新的`ejected-app`文件夹，并运行以下命令：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then enter `y` at the prompt to continue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在提示符处输入`y`继续。
- en: 'Let''s take a look at this project from the top of the VS Code explorer menu:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从VS Code资源管理器菜单的顶部看一下这个项目：
- en: '`config`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`'
- en: This folder contains most of the configuration files and scripts that the project
    uses to set itself up. The main thing to note is that the React team by default
    uses **Jest** for testing and **Webpack** for the bundling and minification of
    JavaScript files. We'll discuss Jest in the *Understanding client-side testing
    for React* section, and Webpack is discussed later in this section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹包含了大部分配置文件和脚本，项目用来设置自身。需要注意的主要是，React团队默认使用**Jest**进行测试和**Webpack**进行JavaScript文件的捆绑和最小化。我们将在*了解React的客户端测试*部分讨论Jest，而Webpack将在本节后面讨论。
- en: '`node_modules`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules`'
- en: As you know, this folder contains our project's dependencies. As you can see,
    even before we add our own dependencies, the default set of dependencies is vast.
    It would be quite difficult to try and use HTML script tags to list out these
    dependencies. And in most cases, these dependencies don't support script tag references.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，这个文件夹包含了我们项目的依赖项。正如你所看到的，即使在我们添加自己的依赖项之前，默认的依赖项集合就已经非常庞大了。试图使用HTML脚本标签列出这些依赖项将会非常困难。而且在大多数情况下，这些依赖项不支持脚本标签引用。
- en: '`public`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`'
- en: This folder contains static assets that are used in generating our single-page
    application. This includes our one HTML file called `index.html`, the `manifest.json`
    file that is needed if we are building a PWA application. It is also possible
    to add additional files such as image files for deployment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹包含用于生成我们的单页应用程序的静态资产。这包括我们的一个名为`index.html`的HTML文件，如果我们正在构建PWA应用程序，则需要的`manifest.json`文件。还可以添加其他文件，比如用于部署的图像文件。
- en: '`scripts`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`'
- en: The `scripts` folder contains scripts that are used to manage the project, for
    example, scripts that build, start, or kick off tests of the application. Actual
    test files should not be added here. We'll cover testing later, in the *Understanding
    client-side testing for React section*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts` 文件夹包含用于管理项目的脚本，例如，构建、启动或启动应用程序测试的脚本。实际的测试文件不应该添加在这里。我们将在稍后的 *理解 React
    客户端测试* 部分介绍测试。'
- en: '`src`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src` '
- en: This is, of course, the folder that contains the source files of our project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是包含我们项目源文件的文件夹。
- en: '`.gitignore`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.gitignore`'
- en: '`.gitignore` is a file that tells the Git source code repository system which
    files and folders not to track. We will dive deeper into Git later in this section.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`.gitignore` 是一个文件，告诉 Git 源代码仓库系统不要跟踪哪些文件和文件夹。我们将在本节后面更深入地了解 Git。'
- en: '`package.json`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json` '
- en: As mentioned in prior chapters, npm is the dependency management system originally
    created for use with the Node server framework. The capabilities and popularity
    of this dependency manager eventually made it a standard for client-side development
    as well. So, the React team uses npm as its base system for project creation and
    dependency management.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，npm 是最初为 Node 服务器框架创建的依赖管理系统。这个依赖管理器的功能和流行度最终使它成为客户端开发的标准。因此，React 团队使用
    npm 作为项目创建和依赖管理的基础系统。
- en: On top of listing dependencies for projects, it can also list scripts that can
    be run to manage a project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列出项目的依赖关系，它还可以列出可以运行以管理项目的脚本。
- en: It also has configuration capabilities for things such as Jest, ESLint, and
    Babel.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它还具有配置 Jest、ESLint 和 Babel 等功能。
- en: '`Package-lock.json`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Package-lock.json`'
- en: This is a related file that helps maintain a proper set of dependencies and
    sub-dependencies regardless of their order of installation. We don't need to work
    with this file directly, but knowing that this helps prevent issues when different
    developers update their `npm_modules` folder at different times with a different
    set of existing dependencies is good knowledge to have.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相关文件，它有助于维护一组正确的依赖关系和子依赖关系，而不管它们安装的顺序如何。我们不需要直接处理这个文件，但知道这有助于防止不同开发人员在不同时间使用不同的现有依赖关系更新他们的
    `npm_modules` 文件夹时出现问题是很有用的知识。
- en: '`tsconfig.json`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsconfig.json`'
- en: We already reviewed this file in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025),
    *Exploring TypeScript*, and as mentioned in that chapter, it contains the settings
    for the TypeScript compiler to use. Note that, in general, the React team prefers
    stricter compilation settings. Also notice that the target JavaScript version
    is ES5\. This is because some browsers are not compatible with ES6 yet.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第 2 章*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025) 中回顾过这个文件，*探索
    TypeScript*，并且如该章节中提到的，它包含了 TypeScript 编译器的设置。请注意，一般来说，React 团队更喜欢更严格的编译设置。还要注意目标
    JavaScript 版本是 ES5。这是因为一些浏览器尚不兼容 ES6。
- en: '`create-react-app` also contains two very important tools that enable some
    of its functionality: Webpack and ESLint. Webpack is a bundling and minification
    tool that automates the task of gathering all of the files that make up a project,
    removing any extraneous, unused pieces, and consolidating them into a few files.
    By removing extraneous pieces, such as white spaces and unused files or scripts,
    it can drastically lower the file sizes that must be downloaded by user browsers.
    This, of course, enhances the user experience. In addition to this core functionality,
    it provides a "hot reloading" development server, which can allow certain script
    changes to automatically show in the browser without needing a page refresh (although
    most changes do seem to trigger browser refreshes, but at least those are automated).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app` 还包含两个非常重要的工具，它们使一些功能得以实现：Webpack 和 ESLint。Webpack 是一个捆绑和最小化工具，它自动完成了收集项目中所有文件的任务，移除任何多余的、未使用的部分，并将它们合并成几个文件。通过移除多余的部分，比如空格和未使用的文件或脚本，它可以大大减小用户浏览器需要下载的文件大小。当然，这会增强用户体验。除了这个核心功能，它还提供了一个“热重载”开发服务器，可以让某些脚本更改自动显示在浏览器中，而无需刷新页面（尽管大多数更改似乎会触发浏览器刷新，但至少这些是自动的）。'
- en: ESLint is also an important tool. Since JavaScript is a scripting language and
    not a compiled language, it does not have a compiler that will check syntax and
    code validity (obviously, TypeScript does but the TypeScript compiler focuses
    primarily on typing issues). So, ESLint provides development-time code checking
    to make sure it is valid JavaScript syntax. And in addition, it allows for the
    creation of custom code-formatting rules. These rules are generally used to ensure
    that everyone on the team is coding using the same style; for example, variable
    naming conventions and bracket indentation. Once rules are set up, the ESLint
    service will enforce these rules with warning messages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 也是一个重要的工具。由于 JavaScript 是一种脚本语言而不是编译语言，它没有编译器来检查语法和代码的有效性（显然，TypeScript
    有，但 TypeScript 编译器主要关注类型问题）。因此，ESLint 提供了开发时代码检查，以确保它是有效的 JavaScript 语法。此外，它还允许创建自定义代码格式规则。这些规则通常用于确保团队中的每个人都使用相同的编码风格；例如，变量命名约定和括号缩进。一旦规则设置好，ESLint
    服务将通过警告消息强制执行这些规则。
- en: The rules are not just specific to JavaScript, but they can also be rules around
    how to write code for frameworks such as React. So, for example, in a `create-react-app`
    project, the ESLint setting is `react-app`, as shown in `package.json`, which
    is a set of coding rules specific to React development. So, many of the messages
    we will see are not necessarily JavaScript errors but rules around best practices
    for coding React apps.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则不仅适用于 JavaScript，还可以是关于如何为 React 等框架编写代码的规则。例如，在 `create-react-app` 项目中，ESLint
    设置为 `react-app`，如 `package.json` 中所示，这是一组特定于 React 开发的编码规则。因此，我们将看到的许多消息并不一定是
    JavaScript 错误，而是关于编写 React 应用程序的最佳实践的规则。
- en: Webpack, although extremely powerful, is also enormously difficult to set up.
    And creating custom rules for ESLint can take a very long time to do. So, fortunately,
    another benefit of using `create-react-app` is that it provides us with good default
    configurations for both of these tools.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack虽然功能强大，但设置起来也非常困难。为ESLint创建自定义规则可能需要很长时间。所幸使用`create-react-app`的另一个好处是它为这两个工具提供了良好的默认配置。
- en: Transpilation
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转译
- en: 'We introduced transpilation in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017),
    *Understanding TypeScript*. However, we should cover it a little more deeply in
    this chapter since `create-react-app` depends on transpilation for much of its
    code generation. `create-react-app` allows us to use TypeScript or Babel so that
    we can develop code in one language or language version and emit code as a different
    language or language version. Here''s a simple diagram showing the flow of code
    during the transpilation of TypeScript:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第1章*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017)中介绍了转译，*理解TypeScript*。然而，在这一章中，我们应该更深入地介绍它，因为`create-react-app`在很大程度上依赖于转译来生成其代码。`create-react-app`允许我们使用TypeScript或Babel，以便我们可以用一种语言或语言版本开发代码，并将代码作为不同的语言或语言版本发出。下面是一个简单的图表，显示了在TypeScript转译过程中代码的流动。
- en: '![Figure 6.5 – Transpilation from TypeScript to JavaScript'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5-从TypeScript到JavaScript的转译'
- en: '](img/Figure_6.05_B15508.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.05_B15508.jpg)'
- en: Figure 6.5 – Transpilation from TypeScript to JavaScript
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5-从TypeScript到JavaScript的转译
- en: The TypeScript compiler will search your project and find all the `ts` or `tsx`
    files inside of the root code folder, usually `src`. If there are errors, it will
    stop and let us know, otherwise, it will parse and convert the TypeScript into
    pure JavaScript as `js` files and that is what is run on systems. Notice in the
    diagram we are also changing the JavaScript version as well. So, transpilation
    is a lot like compilation. Code is checked for validity and some classes of bugs,
    but instead of being converted into byte code that can be run directly, it is
    converted into a different language or language version. Babel is also capable
    of emitting JavaScript and working with TypeScript developer code. However, I
    prefer to use the original TypeScript compiler, as it is made by the same team
    that designs TypeScript and is usually more up to date.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器将搜索您的项目，并找到根代码文件夹（通常为`src`）中的所有`ts`或`tsx`文件。如果有错误，它会停止并通知我们，否则，它将解析并将TypeScript转换为纯JavaScript作为`js`文件，并在系统上运行。请注意，在图表中，我们还更改了JavaScript版本。因此，转译很像编译。代码被检查有效性和某些类别的错误，但不是转换为可以直接运行的字节码，而是转换为不同的语言或语言版本。Babel也能够发出JavaScript并处理TypeScript开发人员的代码。但是，我更喜欢使用原始的TypeScript编译器，因为它是由设计TypeScript的同一个团队制作的，通常更加更新。
- en: Choosing transpilation as the method of compilation has multiple important benefits.
    For one, developers do not need to worry whether their code will run on a browser,
    or whether the user would need to either upgrade or install a bunch of dependencies
    on that machine first. The TypeScript compiler emits web standard ECMAScript (ES3,
    ES5, ES6, and so on) and therefore the code can be set to run on any modern browser.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 选择转译作为编译方法有多个重要的好处。首先，开发人员不需要担心他们的代码是否能在浏览器上运行，或者用户是否需要在机器上升级或安装一堆依赖。TypeScript编译器发出Web标准ECMAScript（ES3、ES5、ES6等），因此代码可以在任何现代浏览器上运行。
- en: Transpilation also allows developers to take advantage of newer versions of
    JavaScript before their final release. Since JavaScript is on an almost annual
    update cycle, this feature can be extremely useful in terms of taking advantage
    of new language features or performance capabilities; for example, when a new
    feature of JavaScript is being considered. The ECMA foundation, the standards
    body that maintains the JavaScript language, goes through several stages before
    accepting changes into an official version of JavaScript. But the TypeScript and
    Babel teams will sometimes accept new JavaScript features when they are still
    in one of these earlier stages. This is how many JavaScript developers were able
    to use async-await in their code before it became an official standard.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 转译还允许开发人员在最终发布之前利用JavaScript的新版本。由于JavaScript几乎每年都会更新一次，这个功能在利用新的语言特性或性能能力方面非常有用；例如，当考虑JavaScript的新功能时。ECMA基金会，维护JavaScript语言的标准机构，在将更改纳入JavaScript的官方版本之前会经历几个阶段。但是TypeScript和Babel团队有时会在这些较早阶段之一接受新的JavaScript功能。这就是许多JavaScript开发人员在它成为官方标准之前就能在他们的代码中使用async-await的方式。
- en: Code repositories
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码存储库
- en: A code repository is a system that allows the sharing of source code among multiple
    developers. Code can be updated, copied, and merged. For large teams, this tool
    is absolutely necessary for building complex applications. The most popular modern
    source code control and repository is Git. And the most popular online repository
    host is GitHub.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码存储库是一个允许多个开发人员共享源代码的系统。代码可以被更新、复制和合并。对于大型团队来说，这个工具对于构建复杂的应用程序是绝对必要的。最流行的现代源代码控制和存储库是Git。而最流行的在线存储库主机是GitHub。
- en: Although thoroughly learning Git is beyond the scope of this book, it is important
    to understand some of the basic concepts and commands, as you will need them when
    interacting with other developers and maintaining your own projects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管彻底学习Git超出了本书的范围，但了解一些基本概念和命令是很重要的，因为在与其他开发人员互动和维护自己的项目时，您将需要它们。
- en: 'One of the more important concepts of any code repository is that of branching.
    This means the ability to indicate multiple versions of a project. For example,
    these branches could be for the version numbers of a project, such as 1.0.0, 1.0.1,
    and so on. It could also be for creating separate versions of an app where perhaps
    some experimental or high-risk code is being tried out. It would not be a good
    idea to place such code into the main branch. Here''s an example of the React
    GitHub page and its many versions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 任何代码存储库的更重要的概念之一是分支。这意味着能够指示项目的多个版本。例如，这些分支可以用于项目的版本号，如1.0.0、1.0.1等。也可以用于创建应用程序的不同版本，其中可能正在尝试一些实验性或高风险的代码。将这样的代码放入主分支不是一个好主意。这是React
    GitHub页面及其许多版本的一个例子：
- en: '![Figure 6.6 – React GitHub'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6 – React GitHub'
- en: '](img/Figure_6.06_B15508.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.06_B15508.jpg)'
- en: Figure 6.6 – React GitHub
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – React GitHub
- en: As you can see, there are many branches. The current stable branch, although
    not visible in this screenshot, is usually called the master.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有许多分支。当前稳定的分支，虽然在此截图中看不到，通常称为主分支。
- en: 'Again, learning Git well would require a book of its own, so here I''ll just
    go over some of the main commands that you would use daily:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，要全面了解Git需要一本专门的书，所以在这里我只会介绍一些您每天会使用的主要命令：
- en: '`git`: This command is the Git `git` command, you are working on a local copy
    of the repository; you are not directly working on the online repository or affecting
    your teammates'' repositories until you push your changes onto the server.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git`：此命令是Git `git`命令，您正在使用存储库的本地副本；直到将更改推送到服务器之前，您不会直接在在线存储库上工作或影响您的队友的存储库。'
- en: '`clone`: This command allows you to copy a repository onto your local machine.
    Note that when you clone, generally, you will default to the master branch. Here''s
    an example:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`克隆`：此命令允许您将存储库复制到本地计算机上。请注意，当您克隆时，通常会默认为主分支。这是一个例子：'
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`checkout`: This subcommand allows you to change your working branch to a different
    desired branch. So, if you wanted to work in another branch other than the master,
    you would use this command. Here''s an example:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`检出`：此子命令允许您将工作分支更改为不同的所需分支。因此，如果您想要在主分支之外的另一个分支中工作，您将使用此命令。这是一个例子：'
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`add`: This subcommand adds the files you recently changed as needing to be
    tracked, which indicates you will later commit them into the repository. You can
    do all your changed files in one shot by using `.` after `add` or indicate the
    files explicitly:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`添加`：此子命令将您最近更改的文件添加为需要跟踪的文件，这表示您稍后将它们提交到存储库中。您可以使用`add`后的`.`一次性处理所有更改的文件，或者明确指定文件：'
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`commit`: This subcommand indicates that you will eventually update your working
    branch with the files that you just added locally. If you add the `-m` parameter,
    you can add a label inline to describe your commit. This command helps team members
    track which changes were done in each commit:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`提交`：此子命令表示您最终将使用您刚刚在本地添加的文件更新您的工作分支。如果添加`-m`参数，您可以内联添加标签来描述您的提交。此命令有助于团队成员跟踪每个提交中所做的更改：'
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`push`: This subcommand does the actual moving of local committed files into
    the remote repository:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`推送`：此子命令将本地提交的文件实际移动到远程存储库中：'
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this section, we covered some of the core project tools available for React
    developers. `create-react-app`, ESLint, Webpack, and npm provide invaluable features
    that make development more efficient and less error-prone. We also covered transpilation,
    to understand how we can take advantage of newer language versions, without compromising
    compatibility, on end user devices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一些适用于React开发人员的核心项目工具。`create-react-app`、ESLint、Webpack和npm提供了宝贵的功能，使开发更高效，减少错误。我们还介绍了转译，以了解如何利用新的语言版本，而不影响最终用户设备的兼容性。
- en: Additionally, we took a quick look at Git. Currently, it is the most popular
    code-sharing repository. As a professional developer, you will most certainly
    end up using it for projects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们快速看了一下Git。目前，它是最受欢迎的代码共享存储库。作为专业开发人员，您肯定会在项目中使用它。
- en: Now that we have some important core tools knowledge, we'll continue in the
    next section by discussing testing. Modern development practices make heavy use
    of testing and test frameworks. Fortunately, JavaScript has great testing frameworks
    to help us write good-quality tests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了一些重要的核心工具知识，我们将在下一节中继续讨论测试。现代开发实践大量使用测试和测试框架。幸运的是，JavaScript有很好的测试框架，可以帮助我们编写高质量的测试。
- en: Understanding client-side testing for React
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解React的客户端测试
- en: Unit testing is a very important part of development. These days, no large projects
    will be written without some level of unit testing. The purpose of tests is to
    ensure that your code is always working correctly and doing the expected things.
    This is especially true when code is modified, that is, refactored. In fact, it
    is probably more difficult to change existing complex code than it is to create
    brand-new code. Unit testing can prevent breaking existing code during refactoring.
    But if code does break, it can also help pinpoint the exact place where code no
    longer works so it can be fixed quickly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是开发的一个非常重要的部分。如今，没有任何大型项目会在没有一定级别的单元测试的情况下编写。测试的目的是确保您的代码始终正常工作并执行预期的操作。当代码被修改时，即重构时，这一点尤为重要。事实上，更改现有复杂代码可能比创建全新代码更困难。单元测试可以防止在重构过程中破坏现有代码。但是，如果代码出现故障，它也可以帮助准确定位代码不再起作用的确切位置，以便快速修复。
- en: 'In React, previously, there were two main testing libraries that were commonly
    used: `create-react-app`. So, for this book, we will be learning about Jest and
    testing-library.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，以前有两个常用的主要测试库：`create-react-app`。因此，在本书中，我们将学习Jest和testing-library。
- en: All unit tests work in the same way. This is true not only for React and JavaScript
    tests, but tests in any language will work in the same manner. So then, what is
    a unit test? A unit test attempts to test one specific portion of code and it
    attempts to assert that something about it is true. That's basically it. To put
    it another way, it means that the test is checking to see whether something expected
    is indeed the case. If it is not, then the test should fail. Although this goal
    is simple, creating high-quality tests is not. So, we'll go over some examples
    here, but please keep in mind that large-application testing can be as complicated
    if not more so than the actual code for creating the app. So, it will take some
    time for you to become proficient in writing tests.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有单元测试都以相同的方式工作。这不仅适用于React和JavaScript测试，而且适用于任何语言的测试都以相同的方式工作。那么，什么是单元测试？单元测试尝试测试代码的一个特定部分，并试图断言关于它的某些内容是真实的。基本上就是这样。换句话说，这意味着测试是在检查某些预期的东西是否确实如此。如果不是，那么测试应该失败。尽管这个目标很简单，但创建高质量的测试并不简单。因此，我们将在这里介绍一些例子，但请记住，大型应用程序的测试可能会比实际创建应用程序的代码更复杂。因此，您需要一些时间才能熟练地编写测试。
- en: 'To make things clearer, let''s take a look at a simple test. Do the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰，让我们看一个简单的测试。请执行以下操作：
- en: Go to VS Code and open the file at path `ejected-app/src/App.test.tsx`. This
    is a test for the `App` component. We'll go over the contents of the test in just
    a moment.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code并在路径`ejected-app/src/App.test.tsx`中打开文件。这是对`App`组件的测试。我们将在接下来的内容中讨论测试的内容。
- en: 'Open your terminal to `ejected-app` and run this command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端到`ejected-app`并运行以下命令：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Figure 6.7 – Test run options'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7 – 测试运行选项'
- en: '](img/Figure_6.07_B15508.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.07_B15508.jpg)'
- en: Figure 6.7 – Test run options
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 测试运行选项
- en: 'If your tests did run or you selected `a`, you should see the following result:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的测试已经运行或者您选择了`a`，您应该会看到以下结果：
- en: '![Figure 6.8 – Tests completed successfully'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 – 测试成功完成'
- en: '](img/Figure_6.08_B15508.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.08_B15508.jpg)'
- en: Figure 6.8 – Tests completed successfully
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 测试成功完成
- en: As you can see, our tests have automatically been found and run (although, currently,
    we only have one). And in this run, the one test is successful, meaning what was
    expected did occur. If any failed, the same UI would indicate how many tests failed
    and how many succeeded.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的测试已经被自动发现并运行（尽管目前我们只有一个）。在这次运行中，一个测试成功，这意味着预期的事情发生了。如果有任何失败，同样的UI将指示有多少测试失败和多少成功。
- en: 'Now, let''s take a look at the test in `App.test.tsx`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`App.test.tsx`中的测试：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, you will notice the filename has the text `test` in it. This is what
    tells Jest that this is a test file. Some teams like to place all their tests
    into a single folder. Some teams prefer to have the test right next to the actual
    file being tested, as in this case. There is no right answer. Do what works best
    for you and your team. In this book, we will put our tests right next to the file
    being tested. Let''s take a look at the contents of our `test` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您会注意到文件名中包含文本`test`。这告诉Jest这是一个测试文件。一些团队喜欢将所有测试放在一个文件夹中。一些团队更喜欢将测试放在被测试的实际文件旁边，就像这种情况。没有标准答案。做最适合您和您的团队的事情。在本书中，我们将把我们的测试放在被测试的文件旁边。让我们来看看我们`test`文件的内容：
- en: Notice among the imports that we have a reference to `@testing-library/react`.
    As mentioned, this library will give us some extra tooling to make the testing
    of the component output easier.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在导入中，我们引用了`@testing-library/react`。如前所述，这个库将为我们提供一些额外的工具，以使组件输出的测试更容易。
- en: Now, notice the `test` function. This function acts as an encapsulated wrapper
    for our single test. This means that all the things relative to this one test
    live inside this function and cannot be accessed from outside of it. This ensures
    that our test is not impacted by other tests.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，注意`test`函数。这个函数充当我们单个测试的封装包装器。这意味着与这个测试相关的所有内容都存在于这个函数内部，不能从外部访问。这确保了我们的测试不会受到其他测试的影响。
- en: The first parameter of this function is a description. Descriptions are totally
    arbitrary, and your team will have its own standard for how these descriptions
    should be written. The only thing we need to focus on is making the description
    brief but clear about what is being tested.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数的第一个参数是一个描述。描述是完全任意的，您的团队将有自己的标准，描述应该如何编写。我们唯一需要关注的是让描述简洁明了，清楚地说明正在测试的内容。
- en: The second parameter is a function that runs the actual test. In this case,
    the test is checking whether a certain specific text appears within the emitted
    HTML of our `App` component. Let's go over the code line by line.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数是运行实际测试的函数。在这种情况下，测试检查特定文本是否出现在我们的`App`组件的生成的HTML中。让我们逐行查看代码。
- en: On *line 6*, we run `render`, passing it the `App` component. This `render`
    function executes our component and gets back certain properties and functions
    that allow us to test the emitted HTML. In this case, we decide only to receive
    the function `getByText`, which simply means to return an element that has certain
    text in it.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第6行*，我们运行`render`，将`App`组件传递给它。这个`render`函数执行我们的组件，并返回一些属性和函数，允许我们测试生成的HTML。在这种情况下，我们决定只接收`getByText`函数，这意味着返回一个包含特定文本的元素。
- en: In *l**ine 7*, we get our HTML DOM element by calling `getByText` with the parameter
    `/learn react/i`, which is syntax for running a regular expression, but in this
    case, it's hardcoded for text.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第7行*，我们通过使用参数`/learn react/i`调用`getByText`来获取我们的HTML DOM元素，这是用于运行正则表达式的语法，但在这种情况下，它是针对文本的硬编码。
- en: Finally, on *line 8*, an assertion is made called `expect`, which expects the
    element object called `linkElement` to be in the DOM using the `toBeInTheDocument`
    function. So, an easy way of understanding tests in general is to read their assertions
    like a sentence. For example, we can read this assertion like this, "I expect
    the linkElement to be in the document" (the document is, of course, the browser
    DOM). By reading it this way, it's pretty clear what is intended.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在*第8行*，进行了一个称为`expect`的断言，它期望名为`linkElement`的元素对象使用`toBeInTheDocument`函数在DOM中。因此，理解测试的一种简单方法是将它们的断言读作一个句子。例如，我们可以这样读取这个断言，"我期望linkElement在文档中"（当然，文档是浏览器DOM）。通过这种方式阅读，很清楚意图是什么。
- en: 'Now, let''s see what happens if we change the code a bit. Update `App.tsx`
    with the following (I''m only showing the `App` function for brevity):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们稍微改变代码会发生什么。使用以下内容更新`App.tsx`（出于简洁起见，我只显示`App`函数）：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you save this file, you should immediately see an error like this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此文件后，您应该立即看到如下错误：
- en: '![Figure 6.9 – Error after changing App.tsx'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9-更改App.tsx后的错误'
- en: '](img/Figure_6.09_B15508.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.09_B15508.jpg)'
- en: Figure 6.9 – Error after changing App.tsx
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9-更改App.tsx后的错误
- en: Again, the test runner is running in watch mode so you should see the test results
    as soon as you save your change. As you can see, our test fails because the text
    `learn react` was not found and therefore the assertion `expect(linkElement).toBeInTheDocument()`
    is not true.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，测试运行程序正在观察模式下运行，因此只要保存更改，您就应该看到测试结果。正如您所看到的，我们的测试失败，因为未找到文本`learn react`，因此断言`expect(linkElement).toBeInTheDocument()`不成立。
- en: 'OK, so we''ve taken a look at a built-in test that `create-react-app` provided.
    Let''s now create a new component so we can write our own tests from scratch.
    Do the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们已经看了一下`create-react-app`提供的内置测试。现在让我们创建一个新组件，这样我们就可以从头开始编写我们自己的测试。请按照以下步骤操作：
- en: 'Let''s leave our test running in watch mode, even though it''s showing an error,
    and create a new terminal window by clicking the plus button at the upper-right
    side of the terminal window in VS Code. The button is the plus sign shown here:![Figure
    6.10: Plus sign for a new terminal'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们保持测试处于观察模式运行，即使它显示错误，并通过单击VS Code终端窗口右上角的加号按钮创建一个新的终端窗口。该按钮如下所示：![图6.10：新终端的加号标志
- en: '](img/Figure_6.10_B15508.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.10_B15508.jpg)'
- en: 'Figure 6.10: Plus sign for a new terminal'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：新终端的加号标志
- en: 'Now, create a new file called `DisplayText.tsx` in the `src` folder and add
    this code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`src`文件夹中创建一个名为`DisplayText.tsx`的新文件，并添加以下代码：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This component will simply display a new message after someone enters their
    name into the input and clicks the `DisplayText`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件将在有人输入他们的名字并点击`DisplayText`后简单地显示一个新消息。
- en: 'We then create some state necessary for the workings of our component and event
    handlers to deal with new text and the display of our message (we''ve already
    covered how to create a React component in [*Chapter 5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081),
    *React Development with Hooks*):'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一些组件工作所必需的状态和事件处理程序，以处理新文本和消息的显示（我们已经介绍了如何在[*第5章*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081)中使用Hooks创建React组件）：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we return our UI, which includes an input and a submit button. Note
    the `data-testid` attributes to allow elements to be easily found by our tests
    later. If you run this code and enter your name and click the button, you should
    see something like this:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回我们的UI，其中包括一个输入和一个提交按钮。请注意`data-testid`属性，以便稍后可以轻松地通过我们的测试找到元素。如果您运行此代码并输入您的姓名并单击按钮，您应该会看到类似于这样的东西：
- en: '![Figure 6.11 – New component for testing'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11-用于测试的新组件'
- en: '](img/Figure_6.11_B15508.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.11_B15508.jpg)'
- en: Figure 6.11 – New component for testing
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11-用于测试的新组件
- en: As you can see, our display simply returns the entered text with a welcome message.
    However, even this simple example has several different things to test. For one,
    we would like to make sure that there is text entered into the input and that
    it is words and not numbers or symbols. We also want to make sure that when we
    click the button, the message is displayed and that it starts with the string
    `"Welcome to React testing"` and ends with the user's input text.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的显示只是返回输入的文本和欢迎消息。然而，即使这个简单的例子也有几个不同的测试内容。首先，我们希望确保输入框中输入了文本，并且是单词而不是数字或符号。我们还希望确保当我们单击按钮时，消息被显示，并且以字符串`"Welcome
    to React testing"`开头，并以用户输入的文本结尾。
- en: 'Now that we have our component, let''s build our test for it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的组件，让我们为它构建我们的测试：
- en: 'We need to be aware of a small issue in our `tsconfig.json` file. As I stated
    earlier, you can place your tests inside of a separate folder, usually called
    `__test__`, or you can place it side by side with your component file. We will
    be placing it side by side for convenience. If we do so, we will need to update
    our `tsconfig.json` file to include this `compilerOption`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要注意一下我们的`tsconfig.json`文件中的一个小问题。正如我之前所述，您可以将测试放在一个单独的文件夹中，通常称为`__test__`，或者您可以将其与组件文件放在一起。为了方便起见，我们将它放在一起。如果我们这样做，我们将需要更新我们的`tsconfig.json`文件以包括这个`compilerOption`：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create the test file for this component by creating a new file called `DisplayText.test.tsx`
    and add this initial code into it:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`DisplayText.test.tsx`的新文件为这个组件创建测试文件，并将初始代码添加到其中：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: From the top, you'll notice we have imported `render` from `@testing-library/react`
    and we've also imported the `@testing-library/jest-dom/extend-expect` extension,
    which allow us to do assertions. The extensions of the `expect` keyword give us
    additional functions that allow us to test in more ways. For example, we are using
    `toHaveValue` to get the value of `input`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，您会注意到我们从`@testing-library/react`导入了`render`，我们还从`@testing-library/jest-dom/extend-expect`导入了扩展，这使我们能够进行断言。`expect`关键字的扩展给了我们额外的函数，让我们能够以更多的方式进行测试。例如，我们使用`toHaveValue`来获取`input`的值。
- en: After the imports, you'll notice some new syntax. `describe` is, as the name
    implies, simply a way to create a grouping container with a helpful label. This
    container can have more than one test, but these tests should all be related to
    testing a specific component or feature. In this case, we are trying to test the
    `DisplayText` component so all the tests within `describe` will be testing only
    that.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入之后，您会注意到一些新的语法。`describe`就像其名称所示的那样，只是一种创建带有有用标签的分组容器的方法。此容器可以有多个测试，但这些测试应该都与测试特定组件或功能相关。在这种情况下，我们试图测试`DisplayText`组件，因此`describe`中的所有测试都将仅测试该组件。
- en: 'So, our first test is started using the function called `it`. This function
    checks that our component, `DisplayText`, can be rendered out as HTML without
    crashing or erroring out. The `render` function attempts to do the rendering and
    the `expect` and `toBeInTheDocument` functions determine whether the rendering
    was a success by checking whether it is in the DOM. As an experiment, add this
    code, `console.log(baseElement.innerHTML)`, within the first test `it` function
    below the line starting with `const { baseElement }`. You should see this HTML
    string in the terminal:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的第一个测试是使用名为`it`的函数开始的。此函数检查我们的组件`DisplayText`是否可以呈现为HTML而不崩溃或出错。`render`函数尝试进行呈现，`expect`和`toBeInTheDocument`函数通过检查它是否在DOM中来确定呈现是否成功。作为一个实验，在第一个测试`it`函数中的以`const
    { baseElement }`开头的行下面添加此代码`console.log(baseElement.innerHTML)`。您应该在终端中看到这个HTML字符串：
- en: '![Figure 6.12 – Log: resultant test HTML'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12-日志：结果测试HTML'
- en: '](img/Figure_6.12_B15508.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.12_B15508.jpg)'
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s create one more test to show an end-to-end test of our component.
    Add the following code after our second `it` function:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个测试，以显示我们组件的端到端测试。在第二个`it`函数之后添加以下代码：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This test is similar to our second test in that it adds a value within our `input`,
    but then it goes on and gets our `button`, and then our `label`. It then creates
    a `click` event to simulate a button press that in regular code would cause our
    `label` to be populated with our welcome message. It then tests the contents of
    our `label`. Again, once you save this file, our tests should rerun and all of
    them should pass.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试类似于我们的第二个测试，它在我们的`input`中添加了一个值，然后继续获取我们的`button`，然后获取我们的`label`。然后创建一个`click`事件来模拟按下按钮，在常规代码中，这会导致我们的`label`被我们的欢迎消息填充。然后测试我们`label`的内容。同样，一旦保存了这个文件，我们的测试应该重新运行，所有测试都应该通过。
- en: 'Now, let''s also look at something called snapshots. Obviously, a big part
    of React development is not just the behavior or actions available within our
    app, but the actual UI presented to our users. So, by doing snapshot testing,
    we are able to check that the desired UI, HTML elements, are indeed created by
    our components. Let''s add this code to our tests after our "renders without crashing"
    test:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们也看看快照。显然，React开发的一个重要部分不仅是我们应用程序中可用的行为或操作，还有我们向用户呈现的实际UI。因此，通过快照测试，我们能够检查组件确实创建了所需的UI，HTML元素。让我们在“呈现无崩溃”测试之后的测试中添加此代码：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, our `render` function is set to return the root most element
    of the `DisplayText` component by using the `baseElement` property. In addition,
    we can see that we have a new `expect` function called `toMatchSnapshot`. This
    function does a couple of things:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的`render`函数设置为通过使用`baseElement`属性返回`DisplayText`组件的最根元素。此外，我们可以看到我们有一个名为`toMatchSnapshot`的新`expect`函数。此函数执行了一些操作：
- en: The first time it runs, it creates a folder called `__snapshot__` at the root
    of our `src` folder.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次运行时，它会在我们的`src`文件夹的根目录下创建一个名为`__snapshot__`的文件夹。
- en: It then adds or updates a file that has the same name as our test file and ends
    with the extension .`snap`. So, in this case, our test file snapshot file would
    be `DisplayText.test.tsx.snap`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它添加或更新一个与我们的测试文件同名且以扩展名`.snap`结尾的文件。因此，在这种情况下，我们的测试文件快照文件将是`DisplayText.test.tsx.snap`。
- en: 'The contents of this snapshot file are the emitted HTML elements of our component.
    So the snapshot you have should look something like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此快照文件的内容是我们组件的发出HTML元素。因此，您拥有的快照应该看起来像这样：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, this is an exact duplicate of our desired HTML as emitted by
    our `DisplayText` component. Notice also the description given and the indication
    that it is `snapshot 1`. As you add more, the number will increment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这是我们期望的HTML的精确副本，由我们的`DisplayText`组件发出。还要注意给出的描述以及指示它是“快照1”。随着您的添加，编号将递增。
- en: 'OK, so now we have a snapshot and our first test run has succeeded. Let''s
    see what happens if we change our `DisplayText` JSX. Update the `DisplayText.tsx`
    file, not your test file, like this (I''ll just show the component definition
    for brevity''s sake):'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们有了一个快照，我们的第一次测试运行成功了。让我们看看如果我们改变我们的`DisplayText` JSX会发生什么。更新`DisplayText.tsx`文件，而不是您的测试文件，就像这样（为了简洁起见，我只会显示组件定义）：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code remains entirely the same, however, in the `return`, we
    add a dummy `div` tag as shown:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码保持完全相同，但是在`return`中，我们添加了一个虚拟的`div`标签，如下所示：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And after selecting `u`, our snapshot file should update successfully and our
    snapshot test should complete. If you open your local snapshot file, you should
    see the same new `div` tag we added to our component earlier.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`u`之后，我们的快照文件应该成功更新，我们的快照测试应该完成。如果您打开本地快照文件，您应该看到我们之前添加到组件中的相同的新`div`标签。
- en: So now we've seen some simple tests to help us get started. Next, we'll get
    introduced to the topic of mocking.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们已经看到了一些简单的测试，帮助我们入门。接下来，我们将介绍模拟的主题。
- en: Mocking
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: Mocking is simply replacing specific functionality in our test with default
    values. An example of mocking could be to only pretend to make a network call
    but instead return a hardcoded value. The reason we want to do this is we want
    to only test a single unit or a small piece of our code. By mocking some portions
    of our code that are not specific to what we are testing, we are avoiding confusion
    and making certain our test works consistently. For example, if we were trying
    to test input in our code, we wouldn't want a network call failure to affect the
    result of that test, because a network call has nothing to do with the input element
    specifically. When we want to do end-to-end testing or integration testing, we
    can worry about the network call as well. But that is a different animal from
    unit testing (in some teams, integration testing is handled by the QA team separately)
    and we won't cover it here. Now, when it comes to React components, testing-library
    actually recommends against mocking, because this effectively makes our test less
    like actual code. Having said that, sometimes mocking can still be helpful to
    do, so I will show how to mock components as well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟就是用默认值替换测试中的特定功能。模拟的一个例子可能是假装进行网络调用，而实际上返回一个硬编码的值。我们这样做的原因是我们只想测试单个单元或代码的一小部分。通过模拟一些与我们正在测试的内容无关的代码部分，我们避免了混淆，并确保我们的测试始终有效。例如，如果我们试图测试代码中的输入，我们不希望网络调用失败影响该测试的结果，因为网络调用与输入元素无关。当我们想进行端到端测试或集成测试时，我们可以担心网络调用。但这与单元测试是不同的（在一些团队中，集成测试由QA团队单独处理），我们在这里不涉及它。现在，当涉及到React组件时，testing-library实际上建议不要模拟，因为这实际上使我们的测试不太像实际代码。话虽如此，有时模拟仍然是有帮助的，所以我将展示如何模拟组件。
- en: Mocking with jest.fn
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jest.fn进行模拟
- en: 'Let''s learn about mocking with Jest as it is also used with Node development.
    The first way to do mocking in Jest is to mock a specific function using `fn`.
    This function takes another function as a parameter that will do whatever you
    need to be done to set up your desired mock. But also, in addition to this ability
    to replace arbitrary existing code and values, creating a mock will give you access
    to a member called `mock`. This member provides metrics about your mock call.
    This is difficult to conceptualize so let''s create an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习使用Jest进行模拟，因为它也与Node开发一起使用。在Jest中进行模拟的第一种方法是使用`fn`模拟特定函数。这个函数接受另一个函数作为参数，这个函数将执行您需要执行的任何操作来设置您想要的模拟。但除了替换任意现有代码和值的能力之外，创建模拟还将使您可以访问一个名为`mock`的成员。这个成员提供了有关您的模拟调用的指标。这很难概念化，所以让我们创建一个例子：
- en: 'Let''s update our `DisplayText` component to make a network call to a web API.
    We will use the `DisplayText` that is a function that returns a user''s full name
    based upon their username. We need to first update the `App` function file like
    this:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新我们的`DisplayText`组件，以便向Web API发出网络调用。我们将使用`DisplayText`，它是一个根据用户名返回用户全名的函数。我们需要首先更新`App`函数文件如下：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s see the updated `DisplayText` component code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看更新的`DisplayText`组件代码：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: return (
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 返回（
- en: <form>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <form>
- en: <div>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <div>
- en: <label>Enter your name</label>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <label>输入您的姓名</label>
- en: </div>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <div>
- en: <input data-testid="user-input"                   value={txt}
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <input data-testid="user-input"                   value={txt}
- en: onChange={onChangeTxt} />
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: onChange={onChangeTxt} />
- en: </div>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <div>
- en: <button data-testid="input-submit"
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <button data-testid="input-submit"
- en: onClick={onClickShowMsg}>Show Message</                  button>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: onClick={onClickShowMsg}>显示消息</                  按钮>
- en: </div>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <div>
- en: <label data-testid="final-msg" >{msg}</                 label>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <label data-testid="final-msg" >{msg}</label>
- en: </div>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </form>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: </form>
- en: )
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '}'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: export default DisplayText;
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: export default DisplayText;
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Figure 6.15 – User''s full name'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15 - 用户的全名'
- en: '](img/Figure_6.15_B15508.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.15_B15508.jpg)'
- en: Figure 6.15 – User's full name
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 - 用户的全名
- en: As you can see, the full name of the user with the username **bret** is **Leanne
    Graham**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，具有用户名**bret**的用户的全名为**Leanne Graham**。
- en: 'Now let''s write our test and mock out our network call using Jest:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写我们的测试，并使用Jest模拟我们的网络调用：
- en: 'Open `DisplayText.test.tsx` and notice that all our tests are failing since
    none of them will have the new property `getUserFullname`. So, let''s update our
    test and mock this function. Here are the new tests:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DisplayText.test.tsx`，注意到我们所有的测试都失败了，因为它们都没有新属性`getUserFullname`。所以，让我们更新我们的测试并模拟这个函数。以下是新的测试：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: afterEach(cleanup);
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: afterEach(cleanup);
- en: 'userFullName and getUserFullnameMock. Since we will be running our mock function
    in several tests, we are creating the getUserFullnameMock function so that we
    can reuse it to give us our mock function getUserFullname and a few other needed
    items.But then the question may be why do they look so complicated? Let''s go
    through the code and figure out what it''s doing: *   After we set the `userFullName`,
    variable we create the `getUserFullnameMock`. function As you can see, the `getUserFullnameMock`
    function takes a `username` as a parameter, just like the real `getUserFullname`
    function, and returns a `promise` and a `Mock` object. *   Inside of `getUserFullnameMock`,
    the definition instantiates a `promise` object and it mocks our `getUserFullname`
    function by using `jest.fn`. We need a promise to simulate a network call and
    also to `await` on it later with the `wait` call from testing-library.*   As mentioned,
    `jest.fn` is used to instantiate a mock and have the mock do whatever it is that
    we may need. In this case, since the `getUserFullname` function we are mocking
    is making a network call, we need to have our `jest.fn` mock return a promise.
    And it does so by returning the `promise` we created on the line immediately above
    it.*   And then, finally, both the `promise` and the new mock function, `getUserFullname`,
    are returned. *   We are going to quite a bit of trouble here, but in this case,
    it is a good idea to eliminate the use of a slow and error-prone network call.
    Otherwise, if the network call fails, we may incorrectly believe our test and
    code have failed.*   Next, let''s see how our mock is used within our tests:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: userFullName和getUserFullnameMock。由于我们将在几个测试中运行我们的模拟函数，我们创建了getUserFullnameMock函数，以便我们可以重复使用它来给我们提供getUserFullname模拟函数和其他一些需要的项目。但问题可能是为什么它们看起来这么复杂？让我们浏览一下代码，弄清楚它在做什么：*在设置`userFullName`变量之后，我们创建了`getUserFullnameMock`函数。正如你所看到的，`getUserFullnameMock`函数接受一个`username`作为参数，就像真正的`getUserFullname`函数一样，并返回一个`promise`和一个`Mock`对象。*在`getUserFullnameMock`内部，定义实例化了一个`promise`对象，并使用`jest.fn`来模拟我们的`getUserFullname`函数。我们需要一个promise来模拟网络调用，并且稍后使用testing-library的`wait`调用来等待它。*如前所述，`jest.fn`用于实例化一个模拟，并让模拟执行我们可能需要的任何操作。在这种情况下，由于我们正在模拟的`getUserFullname`函数正在进行网络调用，我们需要让我们的`jest.fn`模拟返回一个promise。它通过返回我们在上一行创建的`promise`来实现这一点。*最后，`promise`和新的模拟函数`getUserFullname`都被返回。*我们在这里做了很多工作，但在这种情况下，消除慢速和容易出错的网络调用是一个好主意。否则，如果网络调用失败，我们可能会错误地认为我们的测试和代码失败了。*接下来，让我们看看我们的模拟在测试中是如何使用的：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last test is updated since it tests the welcome message. Update your last
    test like this:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个测试已更新，因为它测试了欢迎消息。像这样更新你的最后一个测试：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So by using `jest.fn`, we can mock out a piece of code so that it can give us
    a consistent value. Again, this helps us create consistent, reproducible tests
    where we are testing only a specific unit of code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用`jest.fn`，我们可以模拟出一段代码，以便它可以给我们一个一致的值。同样，这有助于我们创建一致、可重现的测试，我们只测试特定的代码单元。
- en: Component mocking
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件模拟
- en: 'The second form of mocking is to replace whole components entirely and use
    them in place of real components when we want to test other code. In order to
    test this, follow the steps given here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种模拟的形式是完全替换整个组件，并在我们想要测试其他代码时使用它们代替真实组件。为了测试这个，按照这里给出的步骤进行：
- en: 'Let''s make our `DisplayText` component show a list of user todos based on
    the inserted username. Update the component like this:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们的`DisplayText`组件根据插入的用户名显示用户待办事项列表。更新组件如下：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, we''ve created some state to use later:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一些稍后使用的状态：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we update our input with the value of the username given by the user:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用用户提供的用户名的值更新我们的输入：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once the **Show Message** button is clicked, we update the message to be displayed
    as well as the list of todos to be shown.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦单击**显示消息**按钮，我们就会更新要显示的消息以及要显示的待办事项列表。
- en: 'We are going to accept a prop to use as our message prefix:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将接受一个属性作为我们的消息前缀使用：
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Similarly to how we got the user''s `fullname` by using their `username`, we
    get the user''s list of todos by calling the JSONPlaceholder API. First, we find
    the user by calling into the users collection:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们通过使用他们的`username`获取用户的`fullname`，我们通过调用JSONPlaceholder API来获取用户的待办事项列表。首先，我们通过调用用户集合来找到用户：
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then we call into the todos collection and match the todos to the previously
    found user.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用待办事项集合，并将待办事项与先前找到的用户进行匹配。
- en: 'Finally, we return an unordered list of todos via the UI:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过UI返回一个未排序的待办事项列表：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Figure 6.16 – List user todos'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16 - 用户待办事项列表'
- en: '](img/Figure_6.16_B15508.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.16_B15508.jpg)'
- en: Figure 6.16 – List user todos
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 - 用户待办事项列表
- en: Here, we are displaying the user bret's list of todos.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们显示用户bret的待办事项列表。
- en: 'Now, let''s pretend we wanted to test our `DisplayText` component without testing
    this list of todos. How could we refactor this code so that our test wouldn''t
    be so monolithic? Let''s refactor our `DisplayText` component and pull out the
    todos capability as its own component:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要测试我们的`DisplayText`组件，而不测试这个待办事项列表。我们如何重构这段代码，使得我们的测试不会那么庞大？让我们重构我们的`DisplayText`组件，并将待办事项功能提取为自己的组件：
- en: 'Update the `DisplayText` file like this:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像这样更新`DisplayText`文件：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'const onClickShowMsg = async (e:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: const onClickShowMsg = async (e：
- en: React.MouseEvent<HTMLButtonElement, MouseEvent>) =>         {
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: React.MouseEvent<HTMLButtonElement, MouseEvent>) =>         {
- en: e.preventDefault();
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: e.preventDefault();
- en: setTodoControl(null);
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: setTodoControl(null);
- en: setMsg(`Welcome to React testing, ${await
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: setMsg(`欢迎来到React测试，${await
- en: getUserFullname(txt)}`);
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: getUserFullname(txt)}`);
- en: 'onClickShowMsg event handler will call setTodoControl and pass our UserTodos
    component the username:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: onClickShowMsg事件处理程序将调用setTodoControl并将我们的UserTodos组件传递给用户名：
- en: '[PRE39]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let''s create our new `UserTodos` component. Create a file called `UserTodos.tsx`
    and add this code:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的新`UserTodos`组件。创建一个名为`UserTodos.tsx`的文件，并添加以下代码：
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are now taking the username as a prop from our parent:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在从父级获取用户名作为一个属性：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'First, we grab our users again from the users collection and filter to find
    our one user by matching the `username`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们再次从用户集合中获取我们的用户，并过滤以找到我们的一个用户，通过匹配`username`：
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then we grab the matching todos of the found user. We then run the JavaScript
    `map` function to create a collection of `li` elements for each todo:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们获取找到用户的匹配待办事项。然后我们运行JavaScript的`map`函数为每个待办事项创建一个`li`元素的集合：
- en: '[PRE44]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By using `useEffect`, we are indicating that any time our `username` prop changes,
    we want to update our list of todos:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`useEffect`，我们表明每当我们的`username`属性发生变化时，我们都希望更新我们的待办事项列表：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And finally, we output our todos as unordered list elements. If you run this
    code, you should see this once you click **Show Message**:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的待办事项输出为无序列表元素。如果你运行这段代码，当你点击**显示消息**时，你应该会看到这个：
- en: '![Figure 6.17 – Refactored todos'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17 – 重构后的待办事项'
- en: '](img/Figure_6.17_B15508.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.17_B15508.jpg)'
- en: Figure 6.17 – Refactored todos
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 重构后的待办事项
- en: 'OK, so now we can add a new test that mocks out our `UserTodos` component and
    therefore allows `DisplayText` to be tested independently. Note also that there
    are two main ways of doing mocks with Jest. We can do an inline call to mock or
    we can use a mock file. For this example, we will use a mock file. Let''s look
    at the steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以添加一个新的测试，模拟我们的`UserTodos`组件，从而允许独立测试`DisplayText`。还要注意，使用Jest有两种主要的模拟方式。我们可以进行内联调用来模拟，也可以使用一个模拟文件。在这个例子中，我们将使用一个模拟文件。让我们看看步骤：
- en: 'In the `src` folder, create a new folder, `__mocks__`. Inside that folder,
    create a file called `UserTodos.tsx` and add this code into it:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，创建一个新文件夹`__mocks__`。在该文件夹中，创建一个名为`UserTodos.tsx`的文件，并将以下代码添加到其中：
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This file will be the mocked version of the function component. As you can see,
    it returns nothing and has no real members. This means that unlike the real component,
    it will not make any network call or emit any HTML, which for testing is what
    we want.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件将是函数组件的模拟版本。正如你所看到的，它什么也不返回，也没有真正的成员。这意味着与真实组件不同，它不会进行任何网络调用或发出任何HTML，这对于测试来说是我们想要的。
- en: 'Let''s now update `DisplayText.test.tsx` with the following code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们用以下代码更新`DisplayText.test.tsx`：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we can see that we import our mock `UserTodos` component outside of any
    test. This is necessary as doing it inside a test will not work.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以看到我们在任何测试之外导入了我们的模拟`UserTodos`组件。这是必要的，因为在测试内部这样做是行不通的。
- en: The rest of the tests are the same but they now internally use the mock of `UserTodos`.
    Therefore, the test runs faster as there's no network call. As a trial of your
    newfound testing skills, try creating your own test for the `UserTodos` component
    separately.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的测试都是一样的，但现在它们内部使用`UserTodos`的模拟。因此，由于没有网络调用，测试运行得更快。作为对你新学到的测试技能的试验，尝试单独为`UserTodos`组件创建你自己的测试。
- en: In this section, we learned about testing React applications using Jest and
    testing-library. Unit testing is a very important part of application development
    and you will be coding tests almost daily as a professional programmer. It can
    help both to write and refactor code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了使用Jest和testing-library测试React应用程序。单元测试是应用程序开发的一个非常重要的部分，作为专业程序员，你几乎每天都会编写测试。它可以帮助编写和重构代码。
- en: In the next section, we'll continue adding to our developer skillset by discussing
    common tools used in the development of React applications.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将继续通过讨论在React应用程序开发中常用的工具来增加我们的开发者技能。
- en: Learning common tools and practices for React development
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习React开发的常用工具和实践
- en: There are many tools that can help in writing React applications. There are
    too many to list them exhaustively but we will review some of the most common
    here. These tools are vital for writing and debugging your code, so you should
    spend some time familiarizing yourself with them.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以帮助编写React应用程序。它们太多了，无法详尽列举，但我们将在这里回顾一些最常见的。这些工具对于编写和调试你的代码至关重要，所以你应该花一些时间熟悉它们。
- en: VS Code
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VS Code
- en: 'We''ve been using VS Code as our code editor for the entirety of this book.
    And for JavaScript development, VS Code is clearly the most popular editor currently
    in use. Here are a few facts you should know in order to make optimal use of VS
    Code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直使用VS Code作为我们的代码编辑器。对于JavaScript开发，VS Code显然是目前使用最广泛的编辑器。以下是一些你应该知道的事实，以便最大限度地利用VS
    Code：
- en: 'VS Code has a large ecosystem of extensions to help in coding. Many of them
    are dependent upon developer preferences, so you should do a quick search and
    take a look. However, here are some common extensions you should consider using:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code有一个庞大的扩展生态系统，可以帮助编码。其中许多依赖于开发者的偏好，所以你应该快速搜索并查看一下。然而，以下是一些你应该考虑使用的常见扩展：
- en: '**Visual Studio IntelliCode**: Provides a language service for AI-driven code
    completion and syntax highlighting.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio IntelliCode**：提供了一个基于人工智能驱动的代码完成和语法高亮的语言服务。'
- en: '**Apollo GraphQL**: Code completion and formatting helpers for GraphQL.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 阿波罗GraphQL：GraphQL的代码完成和格式化助手。
- en: '**React-related plugins**: There are many React-related plugins that can help
    by providing code snippets or Hooks into services like NPM. Here are just a few:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**与React相关的插件**：有许多与React相关的插件，可以通过提供代码片段或将Hooks集成到NPM等服务来帮助。以下只是其中一些：'
- en: '![Figure 6.18 – React VS Code plugins'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.18 – React VS Code插件'
- en: '](img/Figure_6.18_B15508.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.18_B15508.jpg)'
- en: Figure 6.18 – React VS Code plugins
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – React VS Code插件
- en: VS Code has a built-in debugger that allows you to break (stop) on code and
    review variable values. I won't demonstrate it here as the standard for frontend
    development is to use the Chrome debugger, which also allows breaking on code,
    but I will demonstrate it once we start using Node.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code有一个内置的调试器，允许你在代码上中断（停止）并查看变量值。我不会在这里演示它，因为前端开发的标准是使用Chrome调试器，它也允许在代码上中断，但一旦我们开始使用Node，我会演示它。
- en: 'Configuration files: In VS Code, there are two ways of setting preferences
    for your project, a workspace and the `settings.json` file. There is an enormous
    number of ways VS Code can be configured with regard to fonts, extensions, windows,
    and so on. These configurations can be done globally, or they can be done per
    project. I''ve included a `.vscode/settings.json` file in the `ejected-app` project
    for demonstration purposes. Workspace files are basically the same as settings
    files, except they''re intended for use with multiple projects in a single folder.
    Workspace files are named `<name>.code-workspace`.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件：在VS Code中，有两种设置项目偏好的方式，一个是工作区，另一个是`settings.json`文件。关于字体、扩展、窗口等方面，VS Code有大量的配置方式。这些配置可以在全局范围内进行，也可以在每个项目中进行。我在`ejected-app`项目中包含了一个`.vscode/settings.json`文件，用于演示目的。工作区文件基本上与设置文件相同，只是它们用于在单个文件夹中使用多个项目。工作区文件的命名为`<name>.code-workspace`。
- en: Prettier
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prettier
- en: When writing code, it is very important to use a consistent style to improve
    readability. For example, if you imagine a large team with many developers, if
    they each write code in their own style with various ways of doing indentation,
    variable naming, and so on, it would be chaos. Additionally, there are industry-standard
    ways of formatting JavaScript that can make it more readable and therefore more
    understandable. This is what tools like Prettier provide.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，使用一致的风格非常重要，以提高可读性。例如，如果想象一个有许多开发人员的大团队，如果他们每个人都以自己的风格编写代码，采用不同的缩进方式、变量命名等，那将是一团混乱。此外，有行业标准的JavaScript格式化方式可以使其更易读，因此更易理解。这就是Prettier等工具提供的功能。
- en: Prettier will automatically format your code into a consistent and readable
    format upon every save, no matter who is writing the code. Just remember, after
    installing Prettier, you need to set up `settings.json` or your workspace file
    to use it. Again, I have a sample `settings.json` file in our `ejected-app` project.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier将在每次保存时自动将您的代码格式化为一致且可读的格式，无论是谁在编写代码。只需记住，在安装Prettier后，您需要设置`settings.json`或您的工作区文件来使用它。同样，我在我们的`ejected-app`项目中包含了一个示例`settings.json`文件。
- en: Chrome Debugger
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chrome调试器
- en: The Chrome browser provides built-in tools for web development. These include
    the ability to see all the HTML of a page, view console messages, break on JavaScript
    code, and view network calls made by the browser. Even without any plugins, it
    is quite extensive. For many frontend developers, Chrome is the main tool for
    debugging code.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome浏览器提供了用于Web开发的内置工具。这些工具包括查看页面的所有HTML、查看控制台消息、在JavaScript代码上中断以及查看浏览器所做的网络调用。即使没有任何插件，它也非常广泛。对于许多前端开发人员来说，Chrome是调试代码的主要工具。
- en: 'Let''s take a look at the debugger for `ejected-app` and learn some of the
    basics:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`ejected-app`的调试器，并学习一些基础知识：
- en: If your local instance of `ejected-app` is not running, start it again and open
    your Chrome browser to the default `localhost:3000` URL. Once there, open your
    Chrome debugger by either pressing the *F12* key or going to `root div` tag where
    the rest of our app resides. And in this screenshot, we can see the state where
    we've made our call to the web API to get todos for the user `Bret`. So, then
    we can use the Chrome Debugger to find our HTML elements and check their attributes
    and play with CSS values to get our UI precisely how we would want it.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的本地`ejected-app`实例没有运行，请重新启动它，并打开您的Chrome浏览器到默认的`localhost:3000` URL。一旦到达那里，通过按下*F12*键或转到`root
    div`标签打开您的Chrome调试器，那里是我们应用程序的其余部分。在这个截图中，我们可以看到我们已经调用Web API来获取用户`Bret`的待办事项。因此，我们可以使用Chrome调试器来找到我们的HTML元素，检查它们的属性，并调整CSS值，使我们的UI精确地符合我们的要求。
- en: 'Next, go to the **Console** tab and you should see something like this:![Figure
    6.20: Chrome Debugger Console tab'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到**控制台**选项卡，您应该会看到类似于这样的内容：![图6.20：Chrome调试器控制台选项卡
- en: '](img/Figure_6.20_B15508.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.20_B15508.jpg)'
- en: 'Figure 6.20: Chrome Debugger Console tab'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：Chrome调试器控制台选项卡
- en: So, here, we can check the values for variables and function return data, making
    sure they are what we want and are expecting.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这里，我们可以检查变量和函数返回数据的值，确保它们是我们想要的并且符合预期。
- en: Using the Chrome Debugger, it is possible to break on running code. Open the
    `UserTodos.tsx` file, then add the breakpoint as shown:![Figure 6.21 – Chrome
    Debugger Sources tab
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Chrome调试器，可以在运行代码时中断。打开`UserTodos.tsx`文件，然后添加如下所示的断点：![图6.21 - Chrome调试器源选项卡
- en: '](img/Figure_6.21_B15508.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.21_B15508.jpg)'
- en: Figure 6.21 – Chrome Debugger Sources tab
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 - Chrome调试器源选项卡
- en: As you can see, we are able to stop on our breakpoint, as indicated by the dot
    next to *line 30*. If you hover over certain variables, you will be able to see
    their current values, even when they contain objects such as other components.
    This is a really useful feature for debugging issues in code. This feature is
    enabled by something called source maps. Source maps are files that map or tie
    source code to minified runtime code. They get created and sent to the browser
    during development time and allow the ability to break on and view variable values
    during runtime.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们能够在我们的断点上停下来，这是由*行30*旁边的点所指示的。如果你悬停在某些变量上，你将能够看到它们当前的值，即使它们包含其他组件等对象。这是一个在代码调试中非常有用的功能。这个功能是由一种叫做源映射的东西所启用的。源映射是将源代码映射或绑定到缩小后的运行时代码的文件。它们在开发时被创建并发送到浏览器，允许在运行时断点和查看变量值。
- en: 'Now let''s remove our breakpoint and move to the **Network** tab. This tab
    shows all the network connections made by our browser. This includes not only
    calls for network resources such as data but can include calls to get images or
    static files such as HTML files. If we open this tab and then make our call to
    get todos for the user Bret, we should see this:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们移除断点，转到**网络**选项卡。这个选项卡显示了浏览器所做的所有网络连接。这不仅包括对网络资源（如数据）的调用，还可以包括获取图像或静态文件（如HTML文件）的调用。如果我们打开这个选项卡，然后进行调用以获取用户Bret的待办事项，我们应该会看到这个：
- en: '![Figure 6.22 – Chrome Debugger Network tab'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.22 - Chrome调试器网络选项卡'
- en: '](img/Figure_6.22_B15508.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.22_B15508.jpg)'
- en: Figure 6.22 – Chrome Debugger Network tab
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 – Chrome调试器网络选项卡
- en: As you can see, we can view all the data that comes back from our call to the
    web API. This is a handy tool that allows us to compare the data coming from our
    network resource and compare it to what our code seems to be using. We will also
    use this tool later when we do GraphQL calls as well.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以查看从Web API调用返回的所有数据。这是一个方便的工具，可以让我们比较来自我们网络资源的数据，并将其与我们的代码似乎正在使用的数据进行比较。当我们进行GraphQL调用时，我们也将在以后使用这个工具。
- en: 'OK, so that was a quick overview of the Chrome Debugger, but Chrome also provides
    extensions that enable React-specific help. React Developer Tools provides information
    about our component hierarchy and attribute information about each component;
    for example, here''s a sample in our app:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是对Chrome调试器的快速概述，但Chrome还提供了能够提供React特定帮助的扩展。React开发者工具提供有关我们组件层次结构和每个组件的属性信息；例如，这是我们应用程序中的一个示例：
- en: '![Figure 6.23 – React Developer Tools'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.23 – React开发者工具'
- en: '](img/Figure_6.23_B15508.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.23_B15508.jpg)'
- en: Figure 6.23 – React Developer Tools
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23 – React开发者工具
- en: As you can see, this tool reveals our component hierarchy and it shows the currently
    selected component's attributes. It also shows a highlight on the screen of the
    elements that make up our component, when we select the specific component within
    the hierarchy. It's a handy tool for viewing our elements from the standpoint
    of React component structure, as opposed to HTML structure. The Chrome ecosystem
    of extensions is vast and there are also extensions for Redux and Apollo GraphQL.
    We'll explore those in [*Chapter 8*](B15508_08_Final_JC_ePub.xhtml#_idTextAnchor122),
    *Learning Server-Side Development with Node.js and Express*,and [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, respectively.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个工具显示了我们的组件层次结构，并显示了当前选定组件的属性。当我们在层次结构中选择特定组件时，它还会在屏幕上显示组成我们组件的元素的高亮显示。这是一个方便的工具，可以从React组件结构的角度查看我们的元素，而不是HTML结构。Chrome生态系统的扩展非常广泛，还有针对Redux和Apollo
    GraphQL的扩展。我们将在[*第8章*](B15508_08_Final_JC_ePub.xhtml#_idTextAnchor122)中探索这些，*使用Node.js和Express学习服务器端开发*，以及[*第9章*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139)中，*什么是GraphQL？*。
- en: Alternative IDEs
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代IDE
- en: 'In this book, we use VS Code as our code editor. It works great and has become
    the most popular JavaScript and TypeScript editor. However, there is no reason
    why you have to use it. And there are alternatives you should be aware of. I will
    only list out a few of them here, just so you are aware of some options:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用VS Code作为我们的代码编辑器。它运行良好，并已成为最受欢迎的JavaScript和TypeScript编辑器。但是，你没有理由非要使用它。你应该知道还有其他选择。我只会在这里列出其中一些，这样你就知道一些选项：
- en: '**Atom**: Probably the most popular free editor after VS Code.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Atom**：除了VS Code之后可能是最受欢迎的免费编辑器。'
- en: '**Sublime Text**: One of the faster and more responsive editors. Also has a
    free version.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sublime Text**：更快速、更响应的编辑器之一。也有免费版本。'
- en: '**Vim**: A Unix text editor, often used for editing code.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vim**：Unix文本编辑器，通常用于编辑代码。'
- en: '**Webstorm**: A commercial editor from JetBrains.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Webstorm**：来自JetBrains的商业编辑器。'
- en: Try some of these editors for yourself, as having a good code editor can definitely
    enhance your productivity.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一些这些编辑器，因为拥有一个好的代码编辑器肯定可以提高你的生产力。
- en: This section reviewed some of the more commonly used tools in React development.
    Although these tools don't do the main work of writing code for our application,
    they are nevertheless enormously important for helping us to write code faster
    and of higher quality. They will also reduce our pain points while writing code,
    because finding bugs can often be as challenging as resolving them.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本节回顾了React开发中一些常用的工具。虽然这些工具并不是我们应用程序编写代码的主要工具，但它们对于帮助我们更快速、更高质量地编写代码至关重要。它们还将减少我们编写代码时的痛点，因为找到错误通常与解决错误一样具有挑战性。
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the many tools professional frontend developers
    use to help write high-quality code. Whether it's the VS Code editor used to write
    the code, or the source code repository Git used to share it, all of the tools
    mentioned here are vitally important in doing the work of a frontend engineer.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了许多专业前端开发人员用来帮助编写高质量代码的工具。无论是用于编写代码的VS Code编辑器，还是用于共享代码的源代码存储库Git，这里提到的所有工具在前端工程师的工作中都至关重要。
- en: By learning about these tools, you will become a much better programmer and
    your code quality will increase substantially. Additionally, your quality of life
    as a developer will improve because many of these tools can help track down issues
    more quickly and help you resolve them more easily than trying to tackle it entirely
    on your own.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解这些工具，你将成为一个更好的程序员，你的代码质量将大大提高。此外，作为开发人员，你的生活质量也会提高，因为这些工具中的许多工具可以帮助你更快速地跟踪问题，并帮助你比完全靠自己解决问题更容易地解决问题。
- en: In the next chapter, we will extend our knowledge of React by learning about
    Redux and React Router. Redux will help us manage global state and React Router
    will help us create client-side URLs. Both frameworks are very popular in the
    React community and provide many features that will help us create a more sophisticated,
    capable application.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过学习Redux和React Router来扩展我们对React的了解。Redux将帮助我们管理全局状态，而React Router将帮助我们创建客户端URL。这两个框架在React社区中非常受欢迎，并提供许多功能，将帮助我们创建一个更复杂、更有能力的应用程序。
