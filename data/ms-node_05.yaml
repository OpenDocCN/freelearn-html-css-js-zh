- en: Managing Many Simultaneous Client Connections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理许多同时客户连接
- en: '"If everyone helps to hold up the sky, then one person does not become tired."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “如果每个人都帮助撑起天空，那么一个人就不会感到疲倦。”
- en: – Tshi Proverb
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Tshi谚语'
- en: 'Maintaining a high level of throughput while managing thousands of simultaneous
    client transactions in the unpredictable and *bursty* environment of networked
    software is one expectation developers have for their Node implementations. Given
    a history of failed and unpopular solutions, the problem of concurrency has even
    been assigned its own numeronym: "*The C10K problem*". How should network software
    confidently serving 10,000 simultaneous clients be designed?'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络软件的不可预测和*突发*环境中管理成千上万个同时客户事务的同时保持高吞吐量是开发人员对他们的Node实现的一个期望。鉴于历史上失败和不受欢迎的解决方案，处理并发问题甚至被赋予了自己的数字缩写：“*C10K问题*”。应该如何设计能够自信地为10,000个同时客户提供服务的网络软件？
- en: 'The question of how to best build high concurrency systems has provoked much
    theory over the last several decades, with the debate mostly between two alternatives,
    threads and events:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如何构建高并发系统的最佳方法的问题在过去几十年引发了许多理论争论，主要是在线程和事件之间。
- en: '"Threading allows programmers to write straight-line code and rely on the operating
    system to overlap computation and I/O by transparently switching across threads.
    The alternative, events, allows programmers to manage concurrency explicitly by
    structuring code as a single-threaded handler that reacts to events (such as non-blocking
    I/O completions, application-specific messages, or timer events)."'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: “线程允许程序员编写直线代码，并依赖操作系统通过透明地在线程之间切换来重叠计算和I/O。另一种选择，事件，允许程序员通过将代码结构化为一个单线程处理程序来显式地管理并发，以响应事件（如非阻塞I/O完成、特定于应用程序的消息或定时器事件）。”
- en: – "A Design Framework for Highly Concurrent Systems"  (Welsh, Gribble, Brewer
    & Culler, 2000), p. 2.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: - “高并发系统的设计框架”  （韦尔什，格里布尔，布鲁尔和卡勒，2000），第2页。
- en: 'Two important points are made in the preceding quote:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述引用中提出了两个重要观点：
- en: Developers prefer to write structured code (straight line; single threaded)
    that hides the complexity of multiple simultaneous operations where possible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员更喜欢编写结构化代码（直线；单线程），以尽可能隐藏多个同时操作的复杂性
- en: I/O efficiency is a primary consideration of high-concurrency applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O效率是高并发应用的主要考虑因素
- en: Until very recently, programming languages and related frameworks were not (necessarily)
    optimized for software executing across nodes in a distributed network, or even
    across processors. Algorithms are expected to be deterministic; data written to
    a database is expected to be immediately available for reading. In this age of
    eventually consistent databases and asynchronous control flow, developers can
    no longer expect to know the precise state of an application at any given point
    of time; a sometimes mind-bending challenge for the architects of highly concurrent
    systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，编程语言和相关框架并不是（必然）针对在分布式网络或甚至跨处理器上执行的软件进行优化。算法应该是确定性的；写入数据库的数据应该立即可供阅读。在这个时代的最终一致性数据库和异步控制流中，开发人员不能再期望在任何给定时间点知道应用程序的精确状态；这对高并发系统的架构师来说是一种有时令人费解的挑战。
- en: As we learned in [Chapter 2](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml), *Understanding
    Asynchronous Event-Driven Programming,* Node's design attempts to combine the
    advantages of both threads and events, serving all clients on a single thread
    (an event loop wrapping a JavaScript runtime) while delegating the blocking work
    (I/O) to an optimized thread pool that informs the main thread of state changes
    via an event notification system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml)中所学到的，*理解异步事件驱动编程*，Node的设计试图结合线程和事件的优势，通过在单个线程上为所有客户提供服务（一个包装JavaScript运行时的事件循环），同时将阻塞工作（I/O）委托给一个优化的线程池，通过事件通知系统通知主线程状态变化。
- en: 'Think clearly about how the following HTTP server implementation, running on
    a single CPU, is responding to each client request by wrapping a callback function
    in the context of the request and pushing that execution context onto a stack
    that is constantly emptied and rebuilt within a single thread bound to an event
    loop:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 清楚地思考以下HTTP服务器实现，运行在单个CPU上，通过将回调函数包装在请求的上下文中，并将执行上下文推送到一个不断被清空和重建的堆栈中，该堆栈绑定到事件循环的单个线程中，以响应每个客户请求：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Schematically, it is this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从图上看，情况是这样的：
- en: '![](img/7dcb3dae-75b2-4ef1-ba34-433e6e556c37.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dcb3dae-75b2-4ef1-ba34-433e6e556c37.png)'
- en: 'On the other hand, a server like Apache spins up a thread for each client request:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，像Apache这样的服务器为每个客户请求启动一个线程：
- en: '![](img/9db30472-79fb-46ca-a25c-65579afd9641.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9db30472-79fb-46ca-a25c-65579afd9641.png)'
- en: 'These two approaches are very different. The claim implicit in Node''s design
    is this: it is easier to reason about highly concurrent software when program
    flow is organized along a single thread, and that decreasing I/O latency increases
    the number of simultaneous clients that can be supported even in a single-threaded
    execution model. The second claim will be tested later, but for now, let''s see
    how easy it can be to build basic processes that naturally scale.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法非常不同。Node设计中隐含的声明是：当程序流沿着单个线程组织时，更容易推理高并发软件，并且即使在单线程执行模型中，减少I/O延迟也会增加可以支持的同时客户数量。第二个声明将在以后进行测试，但现在，让我们看看构建自然扩展的基本流程有多容易。
- en: We will demonstrate how to track and manage the relationships between concurrent
    processes using Node, in particular, those servicing multiple clients simultaneously.
    Our goal is to set up a basic understanding of how state should be modeled within
    a Node server or other processes. How is it that a large online social network
    serves you customized information tailored by your friendships or interests? How
    is your shopping cart maintained over several shopping sessions, without disappearing,
    even containing suggestions based on your history of purchases? How can a single
    client interact with other clients?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何使用Node跟踪和管理并发进程之间的关系，特别是那些同时为多个客户提供服务的进程。我们的目标是建立对在Node服务器或其他进程中如何对状态进行建模的基本理解。一个大型在线社交网络如何为您提供根据您的友谊或兴趣定制的信息？您的购物车如何在多次购物会话中保持不变，甚至包含基于您的购买历史的建议？一个客户端如何与其他客户端进行交互？
- en: Understanding concurrency
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并发性
- en: We would all agree that there are unexpected events in the world, and that many
    of them occur at exactly the same time. It is also clear that the state of any
    given system may be composed of any number of substates, where the full consequence
    of even minor state changes are difficult to predict—the power of a butterfly's
    wings being enough to tip a much larger system into an alternate state. Also,
    we also know that the volume and shape of a system, over time, changes in ways
    difficult to predict.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都会同意世界上有意想不到的事件，其中许多事件恰好发生在同一时间。很明显，任何给定系统的状态可能由任意数量的子状态组成，即使是微小的状态变化的全部后果也很难预测——蝴蝶煽动翅膀的力量足以将一个更大的系统推入另一个状态。此外，我们也知道，系统的体积和形状随着时间的推移以难以预测的方式发生变化。
- en: 'In his PHD thesis "*Foundations of Actor Semantics*", written in 1981, William
    Clinger proposed that his work was:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在他1981年撰写的博士论文《*Actor语义的基础》中，William Clinger提出他的工作是：
- en: '"...motivated by the prospect of highly parallel computing machines consisting
    of dozens, hundreds or even thousands of independent microprocessors, each with
    its own local memory and communications processor, communicating via a high-performance
    communications network."'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “……受到高度并行计算机的前景的激励，这些计算机由数十、数百甚至数千个独立的微处理器组成，每个微处理器都有自己的本地存储器和通信处理器，通过高性能通信网络进行通信。”
- en: As it turns out, Clinger was on to something. Concurrency is a property of systems
    composed of many simultaneously executing operations, and the network software
    we are now building resembles the one he envisioned, only much larger, where *hundreds
    or even thousands* is the lower bound, not the higher.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，Clinger有所发现。并发是由许多同时执行的操作组成的系统的属性，我们现在正在构建的网络软件类似于他所设想的，只是规模更大，*数百甚至数千*是下限，而不是上限。
- en: Node makes concurrency accessible, while simultaneously scaling across multiple
    cores, multiple processes, and multiple machines. It is important to note that
    Node places as much importance on the simplicity and consistency of programs as
    it does on being the fastest solution, embracing and enforcing non-blocking I/O
    in an effort to deliver high concurrency through well-designed and predictable
    interfaces. This is what Dahl meant when he said, "Node's goal is to provide an
    easy way to build scalable network programs".
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Node使并发变得容易访问，同时可以跨多个核心、多个进程和多台机器进行扩展。重要的是要注意，Node对程序的简单性和一致性的重视程度与成为最快解决方案的重视程度一样高，通过采用和强制非阻塞I/O来提供高并发性，以及通过设计良好和可预测的接口。这就是Dahl说的“Node的目标是提供一种构建可扩展网络程序的简单方法”的意思。
- en: Happily, it also turns out that Node is very fast.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 令人高兴的是，Node非常快。
- en: Concurrency is not parallelism
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发不等于并行。
- en: A problem can be solved by dividing it into smaller problems, spreading those
    smaller problems across a pool of available people or workers to work on in parallel,
    and delivering the parallel results concurrently.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题分解为较小的问题，将这些较小的问题分散到一个可用的人员或工人池中并行处理，并同时交付并行的结果，可以解决问题。
- en: Multiple processes each solving one part of a single mathematical problem simultaneously
    is an example of parallelism.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 多个进程同时解决单个数学问题的一部分是并行性的一个例子。
- en: 'Rob Pike, general wizard hacker and co-inventor of Google''s Go programming
    language, defines concurrency in this way:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Rob Pike，一位通用的巫师黑客和Google Go编程语言的共同发明者，以这种方式定义并发：
- en: '"Concurrency is a way to structure a thing so that you can, maybe, use parallelism
    to do a better job. But parallelism is not the goal of concurrency; concurrency''s
    goal is a good structure."'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: “并发是一种构造事物的方式，使您可以可能使用并行性来做得更好。但并行性不是并发的目标；并发的目标是一个良好的结构。”
- en: Successful high-concurrency application development frameworks provide a simple
    and expressive vocabulary for describing such systems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的高并发应用程序开发框架提供了一种简单而富有表现力的词汇，用于描述这样的系统。
- en: Node's design suggests that achieving its primary goal—to provide an easy way
    to build scalable network programs—includes simplifying how the execution order
    of coexisting processes is structured and composed. Node helps a developer struggling
    with a program within which many things are happening at once (such as serving
    many concurrent clients) to better organize his or her code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Node的设计表明，实现其主要目标——提供一种构建可扩展网络程序的简单方法——包括简化共存进程的执行顺序的结构和组合。Node帮助开发人员更好地组织他们的代码，解决了在一个程序中同时发生许多事情（比如为许多并发客户提供服务）的问题。
- en: This is not to say that Node is designed to concede efficiency in order to maintain
    simple interfaces—far from it. Instead, the idea is to move responsibility for
    implementing efficient parallel processing away from the developer and into the
    core design of the system, leaving the developer free to structure concurrency
    through a simple and predictable callback system, safe from deadlocks and other
    traps.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说Node是为了保持简单的接口而设计的，而牺牲效率——恰恰相反。相反，这个想法是将实现高效并行处理的责任从开发人员转移到系统的核心设计中，使开发人员可以通过简单和可预测的回调系统来构建并发，远离死锁和其他陷阱。
- en: Node's bracing simplicity comes at a good time, as social and community networks
    grow alongside the world's data. Systems are being scaled to sizes that few would
    have predicted. It is a good time for new thinking, such as how to describe and
    design these systems, and the way they make requests of, and respond to, each
    other.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Node的简洁来得正是时候，因为社交和社区网络与世界数据一起增长。系统正在被扩展到很少有人预测的规模。现在是进行新思考的好时机，比如如何描述和设计这些系统，以及它们如何相互请求和响应。
- en: Routing requests
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求路由
- en: HTTP is a data transfer protocol built upon a request/response model. Using
    this protocol, many of us communicate our current status to friends, buy presents
    for family, or discuss a project over email with colleagues. A staggering number
    of people have come to depend on this foundational internet protocol.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是建立在请求/响应模型之上的数据传输协议。使用这个协议，我们中的许多人向朋友传达我们的当前状态，为家人买礼物，或者与同事通过电子邮件讨论项目。令人震惊的是，许多人已经开始依赖这个基础性的互联网协议。
- en: Typically, a browser client will issue an HTTP GET request to a server. This
    server then returns the requested resource, often represented as an HTML document.
    HTTP is stateless, which simply means that each request or response maintains
    no information on previous requests or responses—with each back and forward movement
    through web pages, the entire browser state is destroyed and rebuilt from scratch.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，浏览器客户端会向服务器发出HTTP GET请求。然后服务器返回所请求的资源，通常表示为HTML文档。HTTP是无状态的，这意味着每个请求或响应都不保留先前请求或响应的信息——通过网页的前后移动，整个浏览器状态都会被销毁并从头开始重建。
- en: Servers route state change requests from clients, ultimately causing new state
    representations to be returned, which clients (often browsers) redraw or report.
    When the WWW was first conceived, this model made sense. For the most part, this
    new network was understood as a distributed filesystem, accessible by anyone with
    a web browser, where a specific resource (such as a newspaper article) could be
    requested from a file-serving computer (a server) located somewhere on the network
    (at an Internet Protocol or IP address) via an HTTP request (such as GET) by simply
    typing in an URL (for example, [http://www.example.org/articles/april/showers.html](http://www.example.org/articles/april/showers.html)).
    A user requests a page and that page appears, perhaps containing (hyper) links
    to related pages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器从客户端路由状态更改请求，最终导致返回新的状态表示，客户端（通常是浏览器）重新绘制或报告。当WWW首次构想时，这个模型是有意义的。在很大程度上，这个新网络被理解为一个分布式文件系统，任何人都可以通过网络浏览器访问，可以通过HTTP请求（例如GET）从网络上的某个位置（Internet
    Protocol或IP地址）的文件服务器计算机（服务器）请求特定资源（例如报纸文章），只需输入URL（例如[http://www.example.org/articles/april/showers.html](http://www.example.org/articles/april/showers.html)）。用户请求一个页面，页面出现，可能包含到相关页面的（超）链接。
- en: However, since a stateless protocol does not maintain context information, it
    was nearly impossible for the operator of a server to develop a more interesting
    relationship with a visitor across a series of requests, or for a visitor to dynamically
    aggregate multiple responses into a single view.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于无状态协议不保留上下文信息，服务器操作员几乎不可能在一系列请求中与访问者建立更有趣的关系，或者访问者动态地将多个响应聚合成一个视图。
- en: 'Additionally, the expressiveness of requests was limited both by the protocol
    itself and by the lack of server content rich enough to usefully support a more
    descriptive vocabulary. For the most part, requests were as blunt as pointing
    a finger at an object of desire—*get that for me*. Consider the parts of a typical
    URL:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请求的表达能力受到协议本身的限制，也受到服务器内容不足以有用地支持更具描述性词汇的限制。在很大程度上，请求就像指着一个对象说“给我那个”。考虑典型URL的部分：
- en: '![](img/8e5bfd4c-8f16-4b85-8909-315c391656bd.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e5bfd4c-8f16-4b85-8909-315c391656bd.png)'
- en: We can see how much client work is involved in describing a simple resource
    location, with query parameters and resource targets an awkward afterthought,
    becoming nearly unusable once more than a few resource descriptors are used. While
    this was workable in a time of simple documents in well-understood and invariant
    hierarchies, the demands and complexities of modern networked software have rendered
    the original concept unworkable and in need of improvement.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在描述简单资源位置时，客户端工作量很大，查询参数和资源目标成为一个笨拙的事后想法，一旦使用了多个资源描述符，几乎变得无法使用。虽然在简单文档和不变的层次结构的时代，这是可行的，但现代网络软件的需求和复杂性使原始概念变得不可行并需要改进。
- en: The clumsiness of passing around increasingly complex key/value pairs to maintain
    user state began to frustrate the ambitions of this new medium. Very quickly,
    it became obvious to developers that a growing reliance on the internet as the
    utility communication layer of the world's information, software, and commerce
    required a more refined approach.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 传递越来越复杂的键/值对以维护用户状态的笨拙性开始让这个新媒介的抱负受挫。很快，开发人员意识到，对互联网作为世界信息、软件和商业的实用通信层的日益依赖需要更精细的方法。
- en: Over time, these limitations have been overcome through a combination of improvements
    to the HTTP protocol, the introduction of JavaScript to the browser, technologies
    such as browser cookies and the attendant innovation from developers building
    products and services exploiting these advances.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，这些限制已经通过对HTTP协议的改进、引入JavaScript到浏览器、诸如浏览器cookie等技术以及开发人员构建产品和服务来利用这些进步的创新的结合而被克服。
- en: Nevertheless, the HTTP protocol itself continues to be dominated by the same
    motifs of individual file-like resources existing at a distinct and permanent
    path and identified by an often non-descriptive name.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，HTTP协议本身仍然被个体文件样式资源存在于一个独特和永久路径，并由一个通常不具描述性的名称标识的相同主题所支配。
- en: What actually exists on many servers now is a complex software specifying network
    interfaces to data models. Communicating with these types of networked applications
    involves getting and setting the state of that data model, both in general and
    as it applies in particular to the client making a request.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在许多服务器上实际存在的是一个复杂的软件，指定了数据模型的网络接口。与这些类型的网络应用程序通信涉及到获取和设置该数据模型的状态，无论是一般的还是特定于向发出请求的客户端的状态。
- en: Clients deploying a real-time solution both set and get resource state representations
    on a server. Application servers must report a client's state in relation to multiple
    processes (databases, files, rules engines, calculation engines, and so on) on
    each request, and often unilaterally on application state changes (for example,
    a user losing access permission). Clients are often not browsers, but other servers.
    How should they communicate?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 部署实时解决方案的客户端在服务器上设置和获取资源状态表示。应用服务器必须在每个请求中报告客户端的状态与多个进程（数据库、文件、规则引擎、计算引擎等）的关系，并且通常在应用状态发生变化时单方面报告（例如，用户失去访问权限）。客户端通常不是浏览器，而是其他服务器。它们应该如何通信？
- en: Understanding routes
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解路线
- en: 'Routes map URLs to actions. Rather than constructing an application interface
    in terms of URL paths to specific files that contain some logic, designing with
    routes involves assigning a specific function to a distinct combination of a URL
    path and request method. For example, a web service that accepts requests for
    lists of cities might be called in this manner:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 路由将URL映射到操作。与构建应用程序界面以URL路径到包含一些逻辑的特定文件的方式不同，使用路由进行设计涉及将特定功能分配给URL路径和请求方法的不同组合。例如，一个接受城市列表请求的Web服务可能以这种方式被调用：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When your server receives this request, it would pass the URL information to
    a PHP process that will execute the application logic in `cities.php`, such as
    reading the query, parsing out the country and state, calling a database, building
    a response, and returning it. Node has the great benefit of being able to function
    both as the server and the application environment. The server can field requests
    directly. Then, it makes more sense to use URLs as simple statements of intent:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的服务器收到此请求时，它将把URL信息传递给一个PHP进程，该进程将执行`cities.php`中的应用逻辑，比如读取查询、解析国家和州、调用数据库、构建响应并返回。Node具有作为服务器和应用环境的双重优势。服务器可以直接处理请求。因此，使用URL作为简单的意图陈述更有意义：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In a Node server, we might use something like the following code to handle
    these requests for cities:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node服务器中，我们可能会使用以下代码来处理这些城市的请求：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One good thing and one bad jump out:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个好的和一个坏的跳出来：
- en: URL handling is clearly organized in one place
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL处理清晰地组织在一个地方
- en: The code is impossibly repetitive
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是不可思议的重复
- en: 'Writing out every possible route won''t work. We''ll keep the organization,
    but need to create variables in routes, preferring to define a general route expression
    like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 写出每种可能的路线是行不通的。我们将保持组织，但需要在路线中创建变量，更倾向于定义一个通用的路线表达式，如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The method `listCities` can accept `country` and `state` *variable* arguments,
    identified with a colon (`:`) prefix. Within our server, we would need to convert
    this symbolic expression into a regular expression. In this case, the `RegExp
    /^\/listCities\/([^\/\.]+)\/([^\/\.]+)\/?$/` could be used to extract ordered
    values from our example URL into a value map similar to:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`listCities`可以接受`country`和`state` *变量*参数，用冒号(`:`)前缀标识。在我们的服务器中，我们需要将这个符号表达式转换成正则表达式。在这种情况下，`RegExp
    /^\/listCities\/([^\/\.]+)\/([^\/\.]+)\/?$/`可以用来从我们的示例URL中提取有序值，形成一个类似于值映射的值映射：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By treating requests as expressions, our server design has become a little
    saner, nicely routing any country/state combination to a common handler function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将请求视为表达式，我们的服务器设计变得更加理智，将任何国家/州的组合都很好地路由到一个公共处理程序函数：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This form of request routing has *won the argument* in the Node community, being
    the default behavior of various frameworks and tools. In fact, this way of thinking
    about routing requests has gained acceptance in many other development environments,
    such as Ruby on Rails. As a result, most web application frameworks for Node have
    been developed around routing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的请求路由在Node社区中*赢得了争论*，成为各种框架和工具的默认行为。事实上，这种关于路由请求的思考方式已经在许多其他开发环境中得到了接受，比如Ruby
    on Rails。因此，大多数Node的Web应用程序框架都是围绕路由开发的。
- en: The most popular web application framework for Node is T.J. Holowaychuk's Express
    framework, and we'll be using this framework frequently in this book when designing
    routing servers. You can install it via `npm` by running `npm install express`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Node最流行的Web应用程序框架是T.J. Holowaychuk的Express框架，我们将在本书中经常使用这个框架来设计路由服务器。您可以通过运行`npm
    install express`来安装它。
- en: Using Express to route requests
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express路由请求
- en: 'Express simplifies the complexity of defining route-matching routines. Our
    example might be written in the following way using Express:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Express简化了定义路由匹配例程的复杂性。我们的示例可能以以下方式使用Express编写：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Instantiating Express delivers a fully-formed web server wrapped in an easy-to-use
    application development API. Our cities service is clearly defined and its variables
    stated, expecting to be called via GET (one might also use `app.post(...)` or
    `app.put(...)`, or any other standard `HTTP` method).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化Express提供了一个完全成型的Web服务器，包装在一个易于使用的应用程序开发API中。我们的城市服务已经清晰定义，并声明了其变量，期望通过GET调用（也可以使用`app.post(...)`或`app.put(...)`，或任何其他标准的`HTTP`方法）。
- en: 'Express also introduces the idea of chaining request-handling routines, which
    in Express are understood as middleware. In our example, we are calling a single
    function in order to handle a cities request. What if, prior to calling our database,
    we want to check that the user is authenticated? We might add an `authenticate()`
    method prior to our main service method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Express还引入了请求处理程序链的概念，在Express中被理解为中间件。在我们的示例中，我们调用一个单个函数来处理城市请求。如果在调用数据库之前，我们想要检查用户是否经过身份验证呢？我们可以在主要服务方法之前添加一个`authenticate()`方法：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Middleware can be chained, in other words, simplifying the creation of complex
    execution chains, nicely following the Rule of Modularity. Many types of middleware
    for handling favicons, logging, uploads, static file requests, and so on have
    already been developed. To learn more, visit: [https://expressjs.com/](https://expressjs.com/).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以链接，换句话说，简化了复杂执行链的创建，很好地遵循了模块化规则。已经开发了许多类型的中间件，用于处理网站图标、日志记录、上传、静态文件请求等。要了解更多，请访问：[https://expressjs.com/](https://expressjs.com/)。
- en: Having established the proper way for Node servers to be configured for routing
    requests, we can now begin a discussion on how to identify the client making the
    request, assigning that client a unique session ID, and managing that session
    through time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Node服务器配置路由请求的正确方式已经建立之后，我们现在可以开始讨论如何识别发出请求的客户端，为该客户端分配一个唯一的会话ID，并通过时间管理该会话。
- en: Using Redis for tracking client state
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis跟踪客户端状态
- en: 'For some of the applications and examples in this chapter, we will be using
    **Redis**, an in-memory Key/Value (KV) database developed by *Salvatore Sanfilippo*.
    More information on Redis can be found at: [http://redis.io](http://redis.io).
    A well-known competitor to Redis is **Memcached** ([http://memcached.org](http://memcached.org)).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的一些应用程序和示例中，我们将使用**Redis**，这是由*Salvatore Sanfilippo*开发的内存键/值（KV）数据库。有关Redis的更多信息，请访问：[http://redis.io](http://redis.io)。Redis的一个知名竞争对手是**Memcached**（[http://memcached.org](http://memcached.org)）。
- en: In general, any server that must maintain the session state of many clients
    will need a high-speed data layer with near-instantaneous read/write performance,
    as request validation and user state transformations can occur multiple times
    on each request. Traditional file-backed relational databases tend to be slower
    at this task than in-memory KV databases. We're going to use Redis for tracking
    the client state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，任何必须维护许多客户端会话状态的服务器都需要一个高速数据层，具有几乎即时的读/写性能，因为请求验证和用户状态转换可能在每个请求上发生多次。传统的基于文件的关系数据库在这个任务上往往比内存KV数据库慢。我们将使用Redis来跟踪客户端状态。
- en: Redis is a single-threaded data store that runs in memory. It is very fast,
    and focused on implementing several data structures, such as hashes and lists
    and sets, and performing operations on those (such as set intersections and list
    pushing and popping). Instructions for installing Redis can be found here: [https://redis.io/topics/quickstart](https://redis.io/topics/quickstart).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个在内存中运行的单线程数据存储。它非常快，专注于实现多个数据结构，如哈希、列表和集合，并对这些数据执行操作（如集合交集和列表推送和弹出）。有关安装Redis的说明，请访问：[https://redis.io/topics/quickstart](https://redis.io/topics/quickstart)。
- en: 'To interact with Redis:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与Redis交互：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notably, Amazon''s ElastiCache service enables Redis "in the cloud" as an in-memory
    cache, with automatic scaling and redundancy at: [https://aws.amazon.com/elasticache/](https://aws.amazon.com/elasticache/).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，亚马逊的ElastiCache服务可以将Redis作为内存缓存“云”化，具有自动扩展和冗余功能，网址为：[https://aws.amazon.com/elasticache/](https://aws.amazon.com/elasticache/)。
- en: 'Redis supports a standard interface for expected actions, such as getting or
    setting key/value pairs. To `get` the value stored at a key, first start the Redis
    CLI:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Redis支持预期操作的标准接口，例如获取或设置键/值对。要`get`存储在键上的值，请首先启动Redis CLI：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Redis will return (`nil`) when a key does not exist. Let''s `set` a key:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当键不存在时，Redis会返回（`nil`）。让我们`set`一个键：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To use Redis within a Node environment, we will need some sort of binding.
    We will be using Matt Ranney''s `node_redis` module. Install it with npm using
    the following command line:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Node环境中使用Redis，我们需要某种绑定。我们将使用Matt Ranney的`node_redis`模块。使用以下命令行通过npm安装它：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To set a value in Redis and get it back again, we can now do this in Node:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Redis中设置一个值并再次获取它，我们现在可以在Node中这样做：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Storing user data
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储用户数据
- en: Managing many users means at least tracking their user information, some stored
    long term (for example, address, purchase history, and contact list) and some
    session data stored for a short time (time since login, last game score, and most
    recent answer).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 管理许多用户意味着至少跟踪他们的用户信息，一些长期存储（例如地址、购买历史和联系人列表），一些会话数据短期存储（自登录以来的时间、最后一次游戏得分和最近的答案）。
- en: 'Normally, we would create a secure interface or similar, allowing administrators
    to create user accounts. It will be clear to the reader how to create such an
    interface by the end of this chapter. For the examples that follow, we''ll only
    need to create one user, to act as a volunteer. Let''s create `Jack`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会创建一个安全的接口或类似的东西，允许管理员创建用户帐户。读者在本章结束时将清楚如何创建这样的接口。在接下来的示例中，我们只需要创建一个用户，作为志愿者。让我们创建`Jack`：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will create a key in Redis—Jack—containing a hash resembling:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Redis中创建一个键—Jack—包含一个类似的哈希：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we wanted to create a hash and add several KV pairs all at once, we could
    achieve the preceding with the `hmset` command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个哈希并一次添加多个KV对，我们可以使用`hmset`命令来实现前面的操作：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, `Jack` exists:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Jack`存在了：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can use the following command to fetch the value stored for a specific field
    in Jack''s account:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令来获取存储在Jack账户中特定字段的值：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Handling sessions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理会话
- en: How does a server know if the current client request is part of a chain of previous
    requests? Web applications engage with clients through long transactional chains—the
    shopping cart containing items to buy will still be there even if a shopper navigates
    away to do some comparison-shopping. We will call this a session, which may contain
    any number of KV pairs, such as a username, product list, or the user's login
    history.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器如何知道当前客户端请求是否是先前请求链的一部分？Web应用程序通过长事务链与客户端进行交互——包含要购买的商品的购物车即使购物者离开进行一些比较购物也会保留。我们将称之为会话，其中可能包含任意数量的KV对，例如用户名、产品列表或用户的登录历史。
- en: How are sessions started, ended, and tracked? There are many ways to attack
    this problem, depending on many factors existing in different ways on different
    architectures. In particular, if more than one server is being used to handle
    clients, how is session data shared between them?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是如何开始、结束和跟踪的？有许多方法可以解决这个问题，这取决于不同体系结构上存在的许多因素。特别是，如果有多个服务器用于处理客户端，那么会话数据是如何在它们之间共享的？
- en: We will use cookies to store session IDs for clients, while building a simple
    long-polling server. Keep in mind that as applications grow in complexity, this
    simple system will need to be extended. As well, long-polling as a technology
    is giving ground to the more powerful socket techniques we will explore in our
    discussions around building real-time systems. However, the key issues faced when
    holding many connected clients simultaneously on a server, and tracking their
    sessions, should be demonstrated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用cookie来存储客户端的会话ID，同时构建一个简单的长轮询服务器。请记住，随着应用程序的复杂性增加，这个简单的系统将需要扩展。此外，长轮询作为一种技术正在为我们在讨论实时系统构建时将要探索的更强大的套接字技术所取代。然而，在服务器上同时保持许多连接的客户端，并跟踪它们的会话时所面临的关键问题应该得到证明。
- en: Cookies and client state
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cookie和客户端状态
- en: 'Netscape provided the preliminary specification for cookies in 1997:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Netscape在1997年提供了有关cookie的初步规范：
- en: According to [https://web.archive.org/web/20070805052634/http://wp.netscape.com/newsref/std/cookie_spec.html](https://web.archive.org/web/20070805052634/http://wp.netscape.com/newsref/std/cookie_spec.html), "Cookies
    are a general mechanism which server side connections (such as CGI scripts) can
    use to both store and retrieve information on the client side of the connection.
    The addition of a simple, persistent, client-side state significantly extends
    the capabilities of Web-based client/server applications. A server, when returning
    an HTTP object to a client, may also send a piece of state information which the
    client will store. Included in that state object is a description of the range
    of URLs for which that state is valid. Any future HTTP requests made by the client
    which fall in that range will include a transmittal of the current value of the
    state object from the client back to the server. The state object is called a
    cookie, for no compelling reason."
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[https://web.archive.org/web/20070805052634/http://wp.netscape.com/newsref/std/cookie_spec.html](https://web.archive.org/web/20070805052634/http://wp.netscape.com/newsref/std/cookie_spec.html)，“Cookie是一种通用机制，服务器端连接（如CGI脚本）可以使用它来存储和检索与连接的客户端一侧有关的信息。简单、持久的客户端状态的添加显著扩展了基于Web的客户端/服务器应用程序的功能。服务器在向客户端返回HTTP对象时，还可以发送一个状态信息片段，客户端将存储该状态。该状态对象包括一个描述该状态有效的URL范围。客户端以后在该范围内发出的任何HTTP请求都将包括将当前状态对象的值从客户端传输回服务器。状态对象称为cookie，没有强制的原因。”
- en: Here, we have one of the first attempts to *fix* the stateless nature of HTTP,
    specifically, the maintenance of session state. It was such a good attempt, which
    still remains a fundamental part of the web.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首次尝试*修复*HTTP的无状态性，特别是会话状态的维护。这是一个很好的尝试，它仍然是Web的一个基本部分。
- en: 'We''ve already seen how to read and set the cookie header with Node. Express
    makes the process a little easier:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用Node读取和设置cookie头。Express使这个过程变得更容易：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the `use` method, which allows us to turn on the cookie handling middleware
    for Express. Here, we see that whenever a client hits our server, this client
    is assigned a random number as a cookie. By navigating to `/mycookie`, this client
    can see the cookie.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`use`方法，它允许我们为Express打开cookie处理中间件。在这里，我们看到每当客户端访问我们的服务器时，该客户端都会被分配一个随机数作为cookie。通过导航到`/mycookie`，该客户端可以看到cookie。
- en: A simple poll
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的轮询
- en: Next, let's create a concurrent environment, one with many simultaneously connected
    clients. We'll use a long-polling server to do this, broadcasting to all connected
    clients via `stdin`. Additionally, each client will be assigned a unique session
    ID, used to identify the client's `http.serverResponse` object, which we will
    push data to.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个并发环境，一个有许多同时连接的客户端。我们将使用一个长轮询服务器来做到这一点，通过`stdin`向所有连接的客户端进行广播。此外，每个客户端将被分配一个唯一的会话ID，用于标识客户端的`http.serverResponse`对象，我们将向其推送数据。
- en: Long polling is a technique whereby a server holds on to a client connection
    until there is data available to send. When data is ultimately sent to the client,
    the client reconnects to the server and the process continues. It was designed
    as an improvement on short polling, which is the inefficient technique of blindly
    checking with a server for new information every few seconds or so, hoping for
    new data. Long polling only requires a reconnection following a tangible delivery
    of data to the client.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 长轮询是一种技术，其中服务器保持与客户端的连接，直到有数据可发送。当数据最终发送到客户端时，客户端重新连接到服务器，进程继续进行。它被设计为对短轮询的改进，短轮询是盲目地每隔几秒钟检查一次服务器是否有新信息的低效技术，希望有新数据。长轮询只需要在向客户端传递实际数据后重新连接。
- en: We'll use two routes. The first route is described using a forward slash (`/`),
    a root domain request. Calls to this path will return some HTML forming the client
    UI. The second route is `/poll`, which the client will use to reconnect with the
    server following the receipt of some data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个路由。第一个路由使用斜杠(`/`)描述，即根域请求。对该路径的调用将返回一些形成客户端UI的HTML。第二个路由是`/poll`，客户端将使用它在接收到一些数据后重新连接服务器。
- en: 'The client UI is extremely simple: its sole purpose is to make an XML HTTP
    request (XHR) to a server (which will hold that request until some data arrives),
    repeating this step immediately following the receipt of some data. Our UI will
    display a list of messages received within an unordered list. For the XHR bit
    we will use the jQuery library. Any similar library can be used, and building
    a pure JavaScript implementation is not difficult.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端UI非常简单：它的唯一目的是向服务器发出XML HTTP请求（XHR）（服务器将保持该请求直到接收到一些数据），在接收到一些数据后立即重复此步骤。我们的UI将在无序列表中显示接收到的消息列表。对于XHR部分，我们将使用jQuery库。可以使用任何类似的库，并且构建纯JavaScript实现并不困难。
- en: 'HTML:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: HTML：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'JavaScript:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the client code above you should see how this will work. A client makes a
    GET call to /poll, and will wait until data is received. Once data is received
    it is added to the client display and another /poll call is made. In this way
    the client holds a long connection to the server, and reconnects only after receiving
    data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的客户端代码中，您应该看到这将如何工作。客户端对/poll进行GET调用，并将等待直到接收到数据。一旦接收到数据，它将被添加到客户端显示，并进行另一个/poll调用。通过这种方式，客户端保持与服务器的长连接，并且仅在接收到数据后重新连接。
- en: 'The server is also simple, mainly responsible for setting session IDs and holding
    on to concurrent client connections until such time as data is available, which
    is broadcast to all connected clients. Data is made available through a redis
    pub/sub mechanism. These connections are indexed via session IDs, maintained using
    cookies:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器也很简单，主要负责设置会话ID并保持并发客户端连接，直到数据可用，然后将数据广播到所有连接的客户端。数据通过redis pub/sub机制可用。这些连接通过会话ID进行索引，使用cookie进行维护：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run this server on the command line, and connect to the server via a browser
    (http://localhost:2112). A page with the text "Results:" will be displayed. Return
    to the command line and enter some text—this message should immediately appear
    in your browser. As you keep typing on the command line, your message will be
    routed to connected clients. You can try this as well with multiple clients --
    note that you should use different browsers, incognito mode, or other ways to
    distinguish each client.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上运行此服务器，并通过浏览器连接到服务器（http://localhost:2112）。将显示一个带有文本“Results:”的页面。返回到命令行并输入一些文本-此消息应立即显示在您的浏览器中。当您在命令行上继续输入时，您的消息将被路由到连接的客户端。您也可以尝试使用多个客户端进行此操作--请注意，您应该使用不同的浏览器，隐身模式或其他方法来区分每个客户端。
- en: While this is a toy server used for demonstration (you probably shouldn't use
    long polling -- better options are presented in [Chapter 6](7c71fdd2-8060-4363-9ab3-1c5cdc24c8cf.xhtml),
    *Creating Real-Time Applications*), ultimately it should be seen how one might
    use some business logic to update state, and then have those state change events
    caught and then broadcast to listening clients using a mechanism like Redis pub/sub.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是用于演示的玩具服务器（您可能不应该使用长轮询--更好的选项在[第6章](7c71fdd2-8060-4363-9ab3-1c5cdc24c8cf.xhtml)中提出，*创建实时应用程序*），但最终应该看到如何使用一些业务逻辑来更新状态，然后捕获这些状态更改事件，然后使用类似Redis
    pub/sub的机制广播到监听客户端。
- en: Authenticating connections
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证连接
- en: In conjunction with establishing client session objects, a Node server often
    demands authentication credentials. The theory and practice of web security is
    extensive.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与建立客户端会话对象相结合，Node服务器通常需要身份验证凭据。Web安全的理论和实践是广泛的。
- en: 'We want to simplify our understanding into two main authentication scenarios:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将我们的理解简化为两种主要的身份验证场景：
- en: When the wire protocol is HTTPS
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传输协议是HTTPS时
- en: When it is HTTP
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它是HTTP时
- en: The first is naturally secure, and the second is not. For the first, we will
    learn how to implement Basic authentication in Node, and for the second, a challenge-response
    system will be described.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个自然是安全的，第二个不是。对于第一个，我们将学习如何在Node中实现基本身份验证，对于第二个，将描述一种挑战-响应系统。
- en: Basic authentication
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: 'As mentioned, Basic authentication sends plain text over the wire containing
    a username/password combination, using standard HTTP headers. It is a simple and
    well-known protocol. Any server sending the correct headers will cause any browser
    to display a login dialog, like the following one:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，基本身份验证在传输中发送包含用户名/密码组合的明文，使用标准HTTP头。这是一个简单而广为人知的协议。发送正确头的任何服务器都将导致任何浏览器显示登录对话框，如下所示：
- en: '![](img/8b8f4ff2-1e85-46b4-8ef2-59f273085118.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b8f4ff2-1e85-46b4-8ef2-59f273085118.png)'
- en: Nonetheless, this method remains insecure, sending non-encrypted data in plain
    text over the wire. For the sake of simplicity, we will demonstrate this authentication
    method on an HTTP server, but it must be stressed that in real-world usage the
    server must be communicating via a secure protocol, such as HTTPS.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这种方法仍然不安全，在传输中发送非加密的明文数据。为了简单起见，我们将在HTTP服务器上演示此身份验证方法，但必须强调的是，在实际使用中，服务器必须通过安全协议进行通信，例如HTTPS。
- en: 'Let''s implement this authentication protocol with Node. Employing the user
    database developed earlier in Redis, we validate submitted credentials by checking
    user objects for matching passwords, handling failures and successes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Node实现此身份验证协议。利用之前在Redis中开发的用户数据库，我们通过检查用户对象以验证提交的凭据，处理失败和成功来验证提交的凭据：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By sending a `401` status and the `''authorization''` header on a new client
    connection, a dialog like the one previous screenshot will be created via this
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在新的客户端连接上发送`401`状态和`'authorization'`头，将创建一个类似于上一个屏幕截图的对话框，通过这段代码：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this way, a straightforward login system can be designed. As browsers will
    naturally prompt users requesting access to a protected domain, even the login
    dialog is taken care of.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，可以设计一个简单的登录系统。由于浏览器会自然地提示用户请求访问受保护的域，甚至登录对话框也会被处理。
- en: Handshaking
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 握手
- en: 'Another authentication method to consider in situations where an HTTPS connection
    cannot be established is a challenge-response system:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法建立HTTPS连接的情况下考虑的另一种身份验证方法是挑战/响应系统：
- en: '![](img/53a64cb6-d275-4202-8fd3-f0fb575ba817.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53a64cb6-d275-4202-8fd3-f0fb575ba817.png)'
- en: In this scenario, a client asks a server for access for a specific user, username,
    ID, or similar. Typically, this data would be sent via a login form. Let's mock
    up a challenge/response scenario, using for our example the user we created earlier—Jack.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，客户端请求服务器访问特定用户、用户名、ID或类似的内容。通常，这些数据将通过登录表单发送。让我们模拟一个挑战/响应场景，使用我们之前创建的用户Jack作为示例。
- en: 'The general design and purpose of a challenge/response system aims to avoid
    sending any password data in plain text over the wire. So, we will need to decide
    on an encryption strategy that both the client and the server share. For our example,
    let''s use the SHA256 algorithm. Node''s crypto library contains all of the tools
    necessary for creating this type of hash. The client likely does not, so we must
    provide one. We''ll use the one developed by Chris Veness, which can be downloaded
    from the following link: [https://github.com/chrisveness/crypto/blob/master/sha256.js.](https://github.com/chrisveness/crypto/blob/master/sha256.js)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战/响应系统的一般设计和目的是避免在网络上传输任何明文密码数据。因此，我们需要决定一个加密策略，客户端和服务器都共享。在我们的示例中，让我们使用SHA256算法。Node的crypto库包含了创建这种类型哈希所需的所有工具。客户端可能没有，所以我们必须提供一个。我们将使用由Chris
    Veness开发的一个，可以从以下链接下载：[https://github.com/chrisveness/crypto/blob/master/sha256.js.](https://github.com/chrisveness/crypto/blob/master/sha256.js)
- en: 'To initiate this login, the client will need to send an authentication request
    for the user Jack:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动此登录，客户端需要为用户Jack发送身份验证请求：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In response, the client should receive a server-generated public key—the challenge.
    The client must now form a string of Jack''s password prefixed by this key. Create
    a SHA256 hash from it, and pass the resulting hash to `/login/`. The server will
    have also created the same SHA256 hash—if the two match, the client is authenticated:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 作为响应，客户端应该收到服务器生成的公钥——挑战。现在，客户端必须形成一个以此键为前缀的Jack的密码字符串。从中创建一个SHA256哈希，并将生成的哈希传递给`/login/`。服务器也将创建相同的SHA256哈希——如果两者匹配，则客户端已经通过身份验证：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The server itself is very simple, composed of the two mentioned authentication
    routes. We can see in the following code how, upon receipt of a username (`jack`),
    the server will first check for an existing user hash in Redis, breaking the handshake
    if no such data is found. If a record exists we create a new, random public key,
    compose the relevant SHA256 hash, and return this challenge value to the client.
    Additionally, we set this hash as a key in Redis, with its value being the sent
    username:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器本身非常简单，由两个提到的身份验证路由组成。我们可以在以下代码中看到，当收到用户名（`jack`）时，服务器将首先检查Redis中是否存在用户哈希，如果找不到这样的数据，则中断握手。如果记录存在，我们创建一个新的随机公钥，组成相关的SHA256哈希，并将此挑战值返回给客户端。此外，我们将此哈希设置为Redis中的一个键，其值为发送的用户名：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `/login/` route handler, we can see how a check is made if the response
    exists as a key in Redis and, if found, we immediately delete the key. This is
    necessary for several reasons, not least of which is preventing others to send
    the same response and gain access. We also generally don''t want these now useless
    we want keys to pile up. This presents a problem: what if a client never responds
    to the challenge? As the key cleanup only happens when a `/login/` attempt is
    made, this key will never be removed.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/login/`路由处理程序中，我们可以看到如果响应存在于Redis中，则会进行检查，并且如果找到，则立即删除该键。这是有几个原因的，其中之一是防止其他人发送相同的响应并获得访问权限。我们也通常不希望这些现在无用的键堆积起来。这带来了一个问题：如果客户端从不响应挑战会怎么样？由于键清理仅在进行`/login/`尝试时发生，因此此键将永远不会被删除。
- en: 'Unlike most KV data stores, Redis introduces the idea of **key expiry**, where
    a set operation can specify a **Time To Live** (**TTL**) for a key. For example,
    here, we use the `setex` command to set a key `userId` to value `183` and specify
    that this key should expire in one second:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数KV数据存储不同，Redis引入了**键过期**的概念，其中设置操作可以为键指定**生存时间**（**TTL**）。例如，在这里，我们使用`setex`命令将键`userId`设置为值`183`，并指定该键应在一秒后过期：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This feature offers an excellent solution to our problem. By replacing the
    `client.set(challenge, username);` line with the following line:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能为我们的问题提供了一个很好的解决方案。通过用以下行替换`client.set(challenge, username);`行：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We ensure that, no matter what, this key will disappear in `5` seconds. Doing
    things this way also functions as a light security measure, leaving a very short
    window for a response to remain valid, and being naturally suspicious of delayed
    responses.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保无论如何，这个键都会在`5`秒内消失。以这种方式做事也可以作为一种轻量级的安全措施，留下一个非常短的时间窗口使响应保持有效，并自然地怀疑延迟的响应。
- en: Using JSON Web Tokens for authentication
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON Web令牌进行身份验证
- en: A basic authentication system might require a client to send a username and
    password on each request. To initiate a token-based authenticated session a client
    sends credentials just once, receives a token in exchange, and then sends only
    that token on subsequent requests, gaining any access that token provides. Incessantly
    passing around sensitive credentials is no longer required.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的身份验证系统可能需要客户端在每个请求上发送用户名和密码。要启动基于令牌的身份验证会话，客户端只需发送一次凭据，然后收到一个令牌作为交换，并在随后的请求中只发送该令牌，获取该令牌提供的任何访问权限。不再需要不断传递敏感凭据。
- en: '![](img/0b5ae151-9f87-4a30-8abd-b3f01561c0aa.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b5ae151-9f87-4a30-8abd-b3f01561c0aa.png)'
- en: One particular advantage of JWTs is that servers are no longer responsible for
    maintaining access to a common database of credentials, as only the issuing authority
    need validate an initial sign-in. There is no need to maintain a session store
    when using JWTs. The issued token (think of it as an access card) can therefore
    be used within any domain (or server) that recognizes and accepts it. In terms
    of performance, the cost of a request is now the cost of decrypting a hash versus
    the cost of making a database call to validate credentials. We also avoid the
    problems one can face using cookies on mobile devices, cross-domain issues (cookies
    are domain-bound), certain types of request forgery attacks, and so on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的一个特别优势是，服务器不再需要维护一个共同的凭据数据库，因为只有发行机构需要验证初始登录。在使用JWT时，无需维护会话存储。因此，发行的令牌（可以将其视为访问卡）可以在任何识别和接受它的域（或服务器）内使用。在性能方面，现在请求的成本是解密哈希的成本，而不是进行数据库调用来验证凭据的成本。我们还避免了在移动设备上使用cookie时可能遇到的问题，跨域问题（cookie是与域名绑定的），某些类型的请求伪造攻击等。
- en: The `express-jwt` module can be useful if you want to integrate with Express: [https://github.com/auth0/express-jwt](https://github.com/auth0/express-jwt).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要与Express集成，`express-jwt`模块可能会很有用：[https://github.com/auth0/express-jwt](https://github.com/auth0/express-jwt)。
- en: Let's look at the structure of a JWT, then build a simple example demonstrating
    how to issue, validate, and otherwise use JWTs to manage sessions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下JWT的结构，然后构建一个简单的示例，演示如何发出，验证和使用JWT来管理会话。
- en: 'A JWT token has the following format:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: JWT令牌具有以下格式：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Each segment is described in JSON format. A **header** simply describes the
    token -- its type and encryption algorithm. Consider this example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都以JSON格式描述。**header**只是描述令牌的类型和加密算法。考虑以下示例：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we declare that this is a JWT token, encrypted using HMAC SHA-256\. See [https://nodejs.org/api/crypto.html](https://nodejs.org/api/crypto.html)
    for more information about encryption, and how to perform encryption with Node.
    The JWT specification itself can be found at: [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明这是一个JWT令牌，使用HMAC SHA-256进行加密。有关加密的更多信息，请参阅[https://nodejs.org/api/crypto.html](https://nodejs.org/api/crypto.html)，以及如何在Node中执行加密。JWT规范本身可以在以下网址找到：[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)。
- en: 'The **claims** segment outlines security and other constraints that are should
    be checked by any service receiving the JWT. Check the specification for a full
    accounting. Typically, a JWT claims manifest will want to indicate when the JWT
    was issued, who issued it, when it expires, who the subject of the JWT is, and
    who should accept the JWT:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**claims**部分概述了安全性和其他约束条件，任何接收JWT的服务都应该检查这些条件。查看完整的规范。通常，JWT声明清单会想要指示JWT的发行时间，发行者，过期时间，JWT的主题以及谁应该接受JWT：'
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `iat` (issued-at) and `exp` (expires) claims are both set to numeric values
    indicating the number of seconds since the Unix epoch. The `iss` (issuer) should
    be a URL describing the issuer of the JWT. Any service that receives a JWT must
    inspect the `aud` (audience), and that service must reject the JWT if it does
    not appear in the audience list. The `sub` (subject) of the JWT identifies the
    subject of the JWT, such as the user of an application—a unique value that is
    never reassigned, such as the name of the issuing service and a unique user ID.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`iat`（发行时间）和`exp`（过期时间）声明都设置为数字值，表示自Unix纪元以来的秒数。`iss`（发行者）应该是描述JWT发行者的URL。任何接收JWT的服务都必须检查`aud`（受众），如果它不出现在受众列表中，该服务必须拒绝JWT。JWT的`sub`（主题）标识JWT的主题，例如应用程序的用户——一个永远不会重新分配的唯一值，例如发行服务的名称和唯一用户ID。'
- en: Finally, some sort of useful data is attached, using any key/value pairing you'd
    like. Here let's call the token data sessionData. Note that we need to encrypt
    this data—the signature segment of a JWT prevents tampering with session data,
    but JWTs are not themselves encrypted (though you can always encrypt the entire
    token itself).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用任何您喜欢的键/值对附加一些有用的数据。在这里，让我们称之为令牌数据sessionData。请注意，我们需要加密这些数据——JWT的签名部分防止篡改会话数据，但JWT本身并不加密（尽管您始终可以加密整个令牌本身）。
- en: The last step is to create a signature, which, as mentioned, prevents tampering—a
    JWT validator is specifically checking for mismatches between the signature and
    the packet received.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建一个签名，如前所述，防止篡改——JWT验证器专门检查签名和接收到的数据包之间的不匹配。
- en: What follows is a scaffold server and client example demonstrating how to implement
    a JWT-driven authentication system. Rather than implementing the various signing
    and validation steps "by hand", we'll use the `jwt-simple` package. Feel free
    to browse the `/jwt` folder in your code bundle, which contains the full code
    we'll be unpacking as we move ahead.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个示例服务器和客户端的框架，演示如何实现基于JWT的身份验证系统。我们将使用`jwt-simple`包来实现各种签名和验证步骤，而不是手动实现。随时浏览您的代码包中的`/jwt`文件夹，其中包含我们将在接下来解压缩的完整代码。
- en: 'To ask for a token, we will use the following client code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求令牌，我们将使用以下客户端代码：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And when we have received a `username` and `password` in some way:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以某种方式收到`username`和`password`时：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We'll implement the server code next. For now, note that we have a send method
    that expects at some point to have a global token set for it to pass along when
    making requests. The initial `/login` is where we ask for that token.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将实现服务器代码。现在，请注意我们有一个发送方法，该方法在某个时候期望有一个全局令牌设置，以便在进行请求时传递。最初的`/login`是我们请求该令牌的地方。
- en: 'Using Express, we create the following server and `/login` route:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Express，我们创建以下服务器和`/login`路由：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that we store our `jwtsecret` on the app server. This is the key that
    is used when signing tokens. When a login attempt is made the server will return
    the result of `jwt.encode`, which encodes the JWT claims discussed earlier. That''s
    it. From now on, any client that mentions this token to the correct audience will
    be allowed to interact with any services those audience members provide for a
    period expiring 7 days from the date of issue. These services will implement something
    like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`jwtsecret`存储在应用服务器上。这是在签署令牌时使用的密钥。当尝试登录时，服务器将返回`jwt.encode`的结果，该结果编码了前面讨论过的JWT声明。就是这样。从现在开始，任何客户端只要向正确的受众提到这个令牌，就可以与这些受众成员提供的任何服务进行交互，有效期为自发行日期起的7天。这些服务将实现类似以下内容的内容：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we are simply fetching the **Authorization** header (stripping out **Bearer**)
    and decoding via `jwt.decode`. A service must at least check for token expiry,
    which we do here by comparing the current number of seconds since the Epoch to
    the token's expiry time. Using this simple framework you can create an easily
    scalable authentication/session system using a secure standard. No longer required
    to maintain a connection to a common credentials database, individual services
    (deployed perhaps as microservices) can use JWTs to validate requests, incurring
    little CPU, latency, or memory cost.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是获取**Authorization**头（去掉**Bearer**）并通过`jwt.decode`进行解码。服务至少必须检查令牌是否过期，我们通过比较自纪元以来的当前秒数和令牌的过期时间来实现这一点。使用这个简单的框架，您可以创建一个易于扩展的身份验证/会话系统，使用安全标准。不再需要维护与公共凭据数据库的连接，个别服务（可能部署为微服务）可以使用JWT验证请求，而几乎不会产生CPU、延迟或内存成本。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Node provides a set of tools that help in the design and maintenance of large-scale
    network applications facing the C10K problem. In this chapter, we've taken our
    first steps into creating network applications with many simultaneous clients,
    tracking their session information and their credentials. This exploration into
    concurrency has demonstrated some techniques for routing, tracking, and responding
    to clients. We've touched on some simple techniques to use when scaling, such
    as the implementation of intra-process messaging via a publish/subscribe system
    built using a Redis database. We also touched on various authentication mechanisms,
    from basic authentication to token-based authentication with JSON Web Tokens.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Node提供了一组工具，可帮助设计和维护面对C10K问题的大规模网络应用程序。在本章中，我们已经迈出了第一步，创建了具有许多同时客户端的网络应用程序，跟踪它们的会话信息和凭据。这种并发性的探索展示了一些路由、跟踪和响应客户端的技术。我们提到了一些简单的扩展技术，例如使用Redis数据库构建的发布/订阅系统来实现进程内消息传递。我们还提到了各种认证机制，从基本认证到基于JSON
    Web Tokens的基于令牌的认证。
- en: We are now ready to go deeper into the design of real-time software—the logical
    next step after achieving high concurrency and low latency using Node. We will
    extend the ideas outlined during our discussion of long polling and place them
    in the context of more robust problems and solutions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备深入探讨实时软件的设计——在使用Node实现高并发和低延迟之后的逻辑下一步。我们将扩展我们在长轮询讨论中概述的想法，并将它们放在更健壮的问题和解决方案的背景下。
- en: Further reading
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Concurrency and parallelism are rich concepts that have enjoyed rigorous study
    and debate. When an application architecture is designed to favor threads, events,
    or some hybrid, it is likely that the architects are opinionated about both concepts.
    You are encouraged to dip a toe into the theory and read the following articles.
    A clear understanding of precisely what the debate is about will provide an objective
    framework that can be used to qualify a decision to choose (or not choose) Node:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 并发性和并行性是丰富的概念，经过了严格的研究和辩论。当应用架构设计支持线程、事件或某种混合时，架构师很可能对这两个概念持有看法。鼓励您深入理论，阅读以下文章。对辩论的准确理解将提供一个客观的框架，可用于评估选择（或不选择）Node的决定：
- en: Some numbers: [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.154.7354&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.154.7354&rep=rep1&type=pdf)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些数字：[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.154.7354&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.154.7354&rep=rep1&type=pdf)
- en: Threads are a bad idea: [https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf](https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程是一个坏主意：[https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf](https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf)
- en: 'Events are a bad idea: [https://people.eecs.berkeley.edu/~brewer/papers/threads-hotos-2003.pdf](https://people.eecs.berkeley.edu/~brewer/papers/threads-hotos-2003.pdf)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件是一个坏主意：[https://people.eecs.berkeley.edu/~brewer/papers/threads-hotos-2003.pdf](https://people.eecs.berkeley.edu/~brewer/papers/threads-hotos-2003.pdf)
- en: 'How about together? : [https://www.cis.upenn.edu/~stevez/papers/LZ06b.pdf](https://www.cis.upenn.edu/~stevez/papers/LZ06b.pdf)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一起怎么样？：[https://www.cis.upenn.edu/~stevez/papers/LZ06b.pdf](https://www.cis.upenn.edu/~stevez/papers/LZ06b.pdf)
- en: The science: [http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf](http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 科学：[http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf](http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf)
