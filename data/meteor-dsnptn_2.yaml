- en: Chapter 2. Publish and Subscribe Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。发布和订阅模式
- en: 'This is by far the most important chapter in this book. The way we control
    our publishers and subscribers is going to define how quickly our application
    responds in production. Publishers and subscribers are the link between our database
    and the client. The server uses publishers to publish information to the client,
    while the client requests information from the publishers by subscribing to them.
    This is all managed via the `Meteor.publish` and `Meteor.subscribe` functions.
    We should be able to produce the data that the client wants to see with two objectives
    in mind:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书到目前为止最重要的章节。我们控制发布者和订阅者的方式将决定我们的应用程序在生产中的响应速度有多快。发布者和订阅者是我们数据库和客户端之间的链接。服务器使用发布者向客户端发布信息，而客户端通过订阅发布者来从发布者请求信息。这一切都通过`Meteor.publish`和`Meteor.subscribe`函数来管理。我们应该能够根据两个目标产生客户端想要看到的数据：
- en: Reduce stress from the server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少服务器的压力
- en: Send only the information that the client needs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只发送客户端需要的信息
- en: 'This chapter will teach you the different patterns that you can use to attain
    these objectives for every template that you build. Here is an overview of the
    topics we will cover to understand these patterns:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教会你你可以用来实现每个构建的模板的这些目标的不同模式。以下是我们将涵盖的主题概述，以了解这些模式：
- en: Template-level subscriptions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板级别的订阅
- en: Database relationships
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库关系
- en: Publishing with relations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带关系的发布
- en: Aggregation publishers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合发布者
- en: External API publishers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部API发布者
- en: Template-level subscriptions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板级别的订阅
- en: This pattern attaches the `Meteor.subscribe` functions to templates. The key
    advantage of subscribing from the template is the ability to isolate the template
    and know that it still works when it is rendered.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式将`Meteor.subscribe`函数附加到模板上。从模板订阅的关键优势是能够隔离模板，并知道它在渲染时仍然有效。
- en: Many Meteor developers attach their subscription methods to their routes. This
    means that the template will only render with the correct data at that particular
    route.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Meteor开发者将他们的订阅方法附加到他们的路由上。这意味着模板只有在特定路由上才会渲染正确的数据。
- en: With this pattern, we will be able to reuse templates anywhere without worrying
    about data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，我们将能够在任何地方重用模板，而不用担心数据问题。
- en: Setting up products for the online shop
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为在线商店设置产品
- en: 'Let''s start by setting up a `Products` collection in MongoDB for our `online_shop`
    project. In [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started
    with Meteor"), *Getting Started with Meteor* we learned that we need to place
    this definition under the `/globals/lib/collections` directory:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的`online_shop`项目在MongoDB中设置一个`Products`集合。在[第1章](part0014_split_000.html#page
    "第1章。开始使用Meteor")，*开始使用Meteor*中，我们了解到我们需要将这个定义放在`/globals/lib/collections`目录下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's important to note that we are adding `@` at the beginning of the `Products`
    variable. This compiles into `this.Products`. In CoffeeScript for Meteor, we do
    this to define a globally scoped variable. This means that the `Products` variable
    now exists in every CoffeeScript file that we will create.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们在`Products`变量开头添加了`@`符号。这编译成`this.Products`。在Meteor的CoffeeScript中，我们这样做是为了定义一个全局作用域的变量。这意味着`Products`变量现在存在于我们将要创建的每个CoffeeScript文件中。
- en: We need to add a permission file as well so that we can modify the collection
    from the console. The `allow`/`deny` functions are rules that add a layer of security
    to the collections. If an `allow` rule returns `true` for a given action, it will
    allow the change to pass. For now, we are going to set all the rules to allow
    everything. We will address permissions when we look at roles in [Chapter 4](part0035_split_000.html#page
    "Chapter 4. Application Patterns"), *Application Patterns*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个权限文件，这样我们才能从控制台修改集合。`allow`/`deny`函数是给集合添加安全层的规则。如果一个`allow`规则对某个操作返回`true`，它将允许更改通过。目前，我们将设置所有规则以允许一切。当我们查看[第4章](part0035_split_000.html#page
    "第4章。应用模式")，*应用模式*时，我们将处理权限问题。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We use the `Meteor.startup` function to make sure that we have set up `Products`
    as a collection before we set the `allow`/`deny` rules. Now that we have a collection,
    let''s make the landing page to show us a list of products. Let''s build the **view**
    first in the `/products/client` directory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Meteor.startup`函数确保在设置`allow`/`deny`规则之前，我们已经将`Products`设置为集合。现在我们有了集合，让我们创建一个着陆页面来显示产品列表。让我们首先在`/products/client`目录中构建**视图**：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This view is just a placeholder. We always need to create the template object
    before we can actually begin working with the publishers and subscribers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图只是一个占位符。我们总是在实际开始使用出版商和订阅者之前创建模板对象。
- en: Building the publisher
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建出版商
- en: Let's construct a simple publisher for our view using the `Meteor.publish` function.
    This publisher will send only 10 documents to the subscribed clients. We'll discuss
    pagination in [Chapter 4](part0035_split_000.html#page "Chapter 4. Application
    Patterns"), *Application Patterns*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Meteor.publish`函数构建一个简单的出版商用于我们的视图。这个出版商将只向订阅客户端发送10个文档。我们将在[第4章](part0035_split_000.html#page
    "第4章。应用模式")中讨论分页，*应用模式*。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Subscribing to the publisher
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅出版商
- en: 'This is where the magic begins. We are going to use the `Template.<template>.onCreated`
    function to subscribe to our publisher. The `onCreated` function runs whenever
    an instance of the template is created in the DOM. So, if we place a `Meteor.subscribe`
    function within this function, this will automatically resubscribe whenever the
    template is used. Let''s give it a shot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里魔法开始了。我们将使用`Template.<template>.onCreated`函数来订阅我们的出版商。每当在DOM中创建模板实例时，`onCreated`函数就会运行。因此，如果我们在这个函数中放置一个`Meteor.subscribe`函数，这将自动在模板被使用时重新订阅。让我们试一试：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We only need to change the first line of the code. This is done so that we can
    attach multiple functions to the `onCreated` template hook without overwriting
    any other functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要更改代码的第一行。这样做是为了我们可以将多个函数附加到`onCreated`模板钩子而不会覆盖任何其他函数。
- en: Database relationships
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库关系
- en: Our collections will always be related in one way or another to other collections
    in our database. This topic is going to examine the three different types of relationships
    you should be thinking about when you are designing your database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有集合都将以某种方式与数据库中的其他集合相关联。这个主题将探讨你在设计数据库时应考虑的三种不同类型的关系。
- en: The shape that our database will take ultimately defines what our publishers
    are going to look like. If your data is all mashed up in just one or two different
    collections, you will very quickly find yourself struggling to filter data. If
    your data is spread too far between collections, the code will become difficult
    to maintain in the long run. So what is the solution to this problem?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据库的最终形状定义了我们的出版商将是什么样子。如果你的数据都混合在只有一个或两个不同的集合中，你很快就会发现自己难以筛选数据。如果你的数据在多个集合之间分布得太广，代码在长期内将难以维护。那么这个问题的解决方案是什么？
- en: The solution to database relationships is to understand how the data is going
    to be used in the client, how often it is going to be modified, and how large
    the set can be.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解决数据库关系的方案是理解数据将在客户端如何使用、将修改多频繁以及集合可以有多大。
- en: Let's build out the rest of our collections to get a notion of what good relationships
    look like.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们其余的集合，以了解良好的关系看起来像什么。
- en: One to one
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一
- en: A one to one database relationship describes how one MongoDB document in a collection
    will be linked to only one other MongoDB document in another collection. You can
    think of this as a JavaScript object inside another object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一数据库关系描述了集合中的一个MongoDB文档将如何仅与另一个集合中的MongoDB文档相关联。你可以将其想象为另一个对象内部的JavaScript对象。
- en: In Meteor, you should create a one to one relationship for a subset of fields
    that you will use sparingly, that will have unique interfaces, or that you will
    use without necessarily requiring access to the product. With this relationship,
    it is going to be very easy to build an image uploader and a collage of images
    showing only `master_image`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Meteor中，你应该为那些你将很少使用、具有独特接口或你将使用而不一定需要访问产品的字段子集创建一对一关系。有了这种关系，构建一个仅发送`master_image`的图片上传器和图片拼贴将变得非常容易。
- en: 'Start by adding a collection that will handle our products'' images: `ProductImages`.
    We are going to assume that our frontend is going to have multiple types of images,
    each one being presented in a different part of the interface that we are building:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个将处理我们产品图片的集合：`ProductImages`。我们将假设我们的前端将具有多种类型的图片，每种图片都将展示在我们构建的界面中的不同部分：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `ProductImages` collection is going to contain a field named `product`.
    This field establishes our relationship by saving the unique `_id` field from
    the `Products` collection. This means that every time we want to publish a product
    with `ProductImages`, we need to query the database as well by searching for `Product_id`
    within `ProductImages`. So a helper would look like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductImages` 集合将包含一个名为 `product` 的字段。该字段通过保存来自 `Products` 集合的唯一 `_id` 字段来建立我们的关系。这意味着每次我们想要发布带有
    `ProductImages` 的产品时，我们还需要通过在 `ProductImages` 中搜索 `Product_id` 来查询数据库。所以一个辅助器可能看起来像这样：'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One to many
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多
- en: A one to many database relationship describes how one MongoDB document in one
    collection will be linked to many MongoDB documents in another collection. You
    can think of this as an array of JavaScript objects that exists under a particular
    field but the data is so complex that you need to separate it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一对多数据库关系描述了在一个集合中的一个MongoDB文档将如何与另一个集合中的多个MongoDB文档相连接。你可以将其想象为一个存在于特定字段下的JavaScript对象数组，但数据如此复杂，以至于你需要将其分离。
- en: 'Now let''s create an `Orders` collection. This collection is going to function
    as a cart. While your first instinct may be to create a `Carts` collection, you
    will quickly find that you are duplicating the order information (one for the
    cart and one for the order, once it is placed). We can easily identify whether
    an order is new or not by adding a `status` field:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个 `Orders` 集合。这个集合将作为一个购物车。虽然你的第一反应可能是创建一个 `Carts` 集合，但你很快会发现你正在重复订单信息（一个用于购物车，一个用于订单，一旦下单）。我们可以通过添加一个
    `status` 字段来轻松识别订单是否为新的：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's not forget to add permissions for the collection as well. We need to do
    this every time we create a new collection to secure the collection from hackers
    and ensure that the client can modify the collection accordingly. We will cover
    more on this in the *Security* section of [Chapter 4](part0035_split_000.html#page
    "Chapter 4. Application Patterns"), *Application Patterns*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要忘记为集合添加权限。每次我们创建一个新的集合时，我们都需要这样做，以确保集合免受黑客攻击并确保客户端可以相应地修改集合。我们将在第4章的 *安全*
    部分中对此进行更多介绍，*应用模式*。
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Something is wrong with this, the products are not defined in the collection!
    We intentionally created an order summary collection that is going to have a one
    to many relationship with order details. We do not know how extensive the order
    actually might be. If we include a field that holds an array of products, this
    list will not only be difficult to manage, but also could potentially become large
    enough that it will crash the database.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有问题，产品没有在集合中定义！我们故意创建了一个将具有与订单详情一对多关系的订单摘要集合。我们不知道订单实际上可能有多广泛。如果我们包含一个包含产品数组的字段，这个列表不仅难以管理，而且可能变得足够大，以至于会崩溃数据库。
- en: 'Let''s put the details of our order in a separate collection called `OrderDetails`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把订单详情放在一个名为 `OrderDetails` 的单独集合中：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Perfect! Now we can say one `Order` has many `OrderDetails`. In this scenario,
    each document in the `OrderDetails` collection represents a single product and
    the details about that product within the order. We have added the `order` field
    to identify to which specific order the details (or in this case, the products)
    belong to.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在我们可以这样说，一个 `Order` 有多个 `OrderDetails`。在这种情况下，`OrderDetails` 集合中的每个文档代表一个单独的产品以及该产品在订单中的详细信息。我们已经添加了
    `order` 字段来识别这些详情（或在这种情况下，产品）属于哪个特定的订单。
- en: This is excellent design. By separating the details from the order, we are capable
    of controlling exactly which data the server sends down to the client. Remember,
    the goal here is to send the least amount of data possible to the client so that
    the site loads quickly and stress on the server is reduced. Managing inserts and
    updates as well becomes easier. As we do not need to deal with indexing a details
    array, we can simply use IDs to find and manipulate data. Now when the shop admin
    subscribes to the `Orders` collection, we can do this in such a way that the server
    only sends the data the admin needs to see the orders. Clicking on an order would
    then lead to subscribing to only that orders' details.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个优秀的设计。通过将细节与顺序分开，我们能够精确控制服务器发送给客户端的数据。记住，这里的目的是尽可能发送最少的可能数据给客户端，以便网站快速加载并减少服务器压力。管理插入和更新也变得更容易。由于我们不需要处理细节数组的索引，我们可以简单地使用ID来查找和操作数据。现在当商店管理员订阅`Orders`集合时，我们可以这样操作，即服务器只发送管理员需要查看订单的数据。点击订单后，就会订阅仅该订单的详细信息。
- en: Many to many
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多
- en: A many to many database relationship describes how many MongoDB documents in
    one collection will be linked to many MongoDB documents in another collection.
    You can think of this as a table where you repeat information and only change
    the information of one field for every row so that you can filter the information
    by that row.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多数据库关系描述了一个集合中的MongoDB文档如何链接到另一个集合中的多个MongoDB文档。你可以将其想象为一个表，其中你重复信息，并且对于每一行只更改一个字段的值，这样你就可以通过该行过滤信息。
- en: These types of relationships require a **mapping table**. In the case of MongoDB,
    a mapping table is a separate collection. A mapping table is the part that repeats
    information in every row without actually duplicating entries; it simply makes
    pairs between each collection ID.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这类关系需要**映射表**。在MongoDB的情况下，映射表是一个单独的集合。映射表是每行重复信息但不实际重复条目的部分；它只是将每个集合ID配对。
- en: In the example that we are going to program, we want to create a many to many
    relationship between products and tags because a product can have many tags and
    a tag can have many products. The mapping table in this case is going to save
    each ID pair. So if a product has two tags, there will be two entries in the mapping
    table with the same product ID but each with a different tag ID. If a tag is a
    part of two products, then the mapping table will have two entries with the same
    tag ID but each one with a different product ID.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们即将编写的示例中，我们想要在产品和标签之间创建一个多对多关系，因为一个产品可以有多个标签，而一个标签也可以有多个产品。在这种情况下，映射表将保存每个ID对。所以如果一个产品有两个标签，映射表中将有两个条目，具有相同的产品ID，但每个条目都有一个不同的标签ID。如果一个标签是两个产品的组成部分，那么映射表将有两个条目，具有相同的标签ID，但每个条目都有一个不同的产品ID。
- en: It's important to note that these types of relationships are often overlooked
    because of their complexity. If for some reason you find yourself trying to match
    two collections with arrays from each collection, you are definitely attempting
    a "many to many" relationship.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，由于它们的复杂性，这类关系往往被忽视。如果你发现自己试图通过每个集合的数组来匹配两个集合，那么你肯定是在尝试一个“多对多”关系。
- en: 'To explain this relationship, we are going to create a `Tags` collection for
    our products:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这种关系，我们将为我们的产品创建一个`Tags`集合：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will notice that in this type of relationship the `Tags` collection has
    nothing to associate to a product, but if it did, it would have to be an array
    of products to which the tag belongs to. To establish the relationship, we will
    create the mapping table, that is, the `ProductsTags` collection:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在这种关系中，`Tags`集合没有与产品关联的内容，但如果它有，它将是一个包含标签所属产品的数组。为了建立这种关系，我们将创建映射表，即`ProductsTags`集合：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This collection allows us to have any combination of relations between `Products`
    and `Tags`. Suppose we want to see all the products related to one tag. In this
    case, we will first query the mapping table for that tag and then query the tags
    using the result.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合允许我们在`Products`和`Tags`之间有任意的组合关系。假设我们想查看与一个标签相关的所有产品。在这种情况下，我们首先查询该标签的映射表，然后使用结果查询标签。
- en: Beware! Many to many relationships can be difficult to spot. If you are stuck
    at any point during your database design process, do not forget to consider this
    possibility.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！多对多关系可能难以发现。如果在数据库设计过程中遇到任何困难，不要忘记考虑这种可能性。
- en: Publishing with relations
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带关系的发布
- en: We understand how our collections are related, but how can we make it easy to
    publish data with these relationships?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解了我们的集合是如何相关的，但我们如何能够轻松地发布带有这些关系的数据？
- en: In Meteor, it can be problematic to publish relationships because of reactivity
    and the way publishers work. You would expect that by simply making two queries
    to two related collections and returning an array will publish a perfectly reactive
    collection. This is not the case. A `Meteor.publish` function does not rerun when
    dependencies change. This means that if a relationship is broken, the related
    document will remain published, or worse if a new relationship is made by another
    client, the related data will not publish.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Meteor中，由于反应性和发布者的工作方式，发布关系可能会出现问题。你可能会期望通过简单地向两个相关集合查询并返回一个数组就能发布一个完美的反应性集合。但这并不是事实。`Meteor.publish`函数在依赖项改变时不会重新运行。这意味着如果关系断开，相关的文档将保持发布状态，或者更糟糕的是，如果另一个客户端创建了新的关系，相关的数据将不会发布。
- en: To take care of database relationships and reactivity in Meteor, we use the
    `lepozepo:publish-with-relations` package. This package automatically takes care
    of subscribing to new data in the most efficient way possible when relationships
    are broken. If you are familiar with MySQL, this package makes JOINs a breeze.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理Meteor中的数据库关系和反应性，我们使用`lepozepo:publish-with-relations`包。当关系断开时，此包会自动以最有效的方式订阅新数据。如果你熟悉MySQL，这个包使得JOIN操作变得简单。
- en: Publishing products with images (one to one)
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布带有图片的产品（一对一）
- en: 'We will be working with the `/products` directory, this module will be our
    landing page. First, let''s set up a route for our view:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`/products`目录，这个模块将是我们的首页。首先，让我们为我们的视图设置一个路由：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are using the `FlowRouter.route` function to define the path of our landing
    page and the `FlowLayout.render` function to define which layout template to use.
    You will notice that the `FlowLayout.render` function is taking in two parameters:
    the first one defines which layout template to render, and the second one defines
    where to render within that layout template.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`FlowRouter.route`函数来定义我们首页的路径，以及`FlowLayout.render`函数来定义要使用哪个布局模板。你会注意到`FlowLayout.render`函数接收两个参数：第一个参数定义要渲染哪个布局模板，第二个参数定义在布局模板中渲染的位置。
- en: 'Now we can work on the publisher. The goal is to publish 10 products paired
    with only their `master_image`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始处理发布者了。目标是发布10个产品，只配对它们的`master_image`：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice the `mappings` key of the object that we are passing through the `@relations`
    function. All the objects inside the array must have at least a `collection` key.
    Optionally, they can take `key` and `foreign_key`. In this case, we use `key`
    to express that the `_id` field in the `Products` collection is equal to the string
    of the `product` field in the `ProductImages` collection. This is the most efficient
    way to publish data. The package will automatically make sure that all changes
    to the collections are reflected in real time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们通过`@relations`函数传递的对象中的`mappings`键。数组内的所有对象都必须至少有一个`collection`键。可选的，它们可以包含`key`和`foreign_key`。在这种情况下，我们使用`key`来表示`Products`集合中的`_id`字段等于`ProductImages`集合中`product`字段的字符串。这是发布数据最有效的方式。该包将自动确保所有集合的变化都能实时反映。
- en: 'The `Meteor.publish` function has one peculiarity: when data changes, the cursor
    will react accordingly, but the function holding the cursor will not. The impact
    of this is obvious when it comes to creating relationships. Let''s look at what
    our code would look like without using a package to handle our relationships:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meteor.publish`函数有一个特性：当数据发生变化时，光标会相应地反应，但持有光标的函数不会。当涉及到创建关系时，这种影响是明显的。让我们看看不使用包来处理我们的关系时，我们的代码会是什么样子：'
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, suppose that for some reason the order of the `Products` collection
    changes. This will make `products_cursor` change reactively as you would expect
    on the client, but because there were no changes to the `ProductImages` collection
    and `Meteor.publish` does not rerun when there is a change in one of its dependencies,
    the images of the newly published products will not be published reactively!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设由于某种原因`Products`集合的顺序发生了变化。这将使`products_cursor`按预期在客户端反应性地改变，但由于`ProductImages`集合没有变化，并且`Meteor.publish`在依赖项发生变化时不会重新运行，因此新发布产品的图片将不会反应性地发布！
- en: Publishing orders with details (one to many)
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布带有详细信息的订单（一对多）
- en: 'Now we will work on our `Orders` and `OrderDetails` collections. Let''s set
    up our template, route, and subscriber for the function that creates orders. We
    can name this module as `cart` and store it under the `orders` directory:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将处理我们的`Orders`和`OrderDetails`集合。让我们为创建订单的功能设置模板、路由和订阅者。我们可以将此模块命名为`cart`并将其存储在`orders`目录下：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the `order` variable is going to get our order `_id` by using the
    `Session` variables. We do this because the `Session` variables are reactive;
    if for some reason the value changes, this makes sure that the subscriber reruns.
    The subscriber reruns because the variable is defined within the `@autorun` function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`order`变量将通过使用`Session`变量来获取我们的订单`_id`。我们这样做是因为`Session`变量是响应式的；如果由于某种原因值发生变化，这将确保订阅者重新运行。订阅者重新运行是因为变量是在`@autorun`函数内定义的。
- en: 'Also, we are passing an object as an argument to the `@subscribe` function
    so that the publisher knows what order we are talking about:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们正在将一个对象作为参数传递给`@subscribe`函数，以便发布者知道我们正在谈论哪个订单：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to publish three different collections to have all the information
    that our cart needs: `Orders`, `OrderDetails`, and `Products`. This publisher
    can follow the same logic that we found in the first publisher:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要发布三个不同的集合以获取购物车所需的所有信息：`Orders`、`OrderDetails`和`Products`。此发布者可以遵循我们在第一个发布者中找到的相同逻辑：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This publisher is predefining defaults for the function by passing `ops={}`
    within the parameters (another useful shortcut that CoffeeScript provides). After
    making sure that `ops.order` exists and is not a blank string, we establish our
    relationships. We need to make sure that the status of `Order` has the `"new"`
    value for security, so we hardcode it in the `filter` key.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此发布者通过在参数中传递`ops={}`来预定义函数的默认值。在确保`ops.order`存在且不是空字符串后，我们建立关系。我们需要确保`Order`的状态具有`"new"`值以进行安全起见，所以我们将其硬编码在`filter`键中。
- en: Notice that in this case, we are making use of `foreign_key`. This indicates
    that the `OrderDetails` collection has a `product` field that contains a string
    equal to the `_id` field of the `Products` collection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们正在使用`foreign_key`。这表明`OrderDetails`集合有一个包含与`Products`集合的`_id`字段相等的字符串的`product`字段。
- en: For now, we are going to limit `OrderDetails` to `25`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将`OrderDetails`限制为`25`。
- en: Publishing a tag with products (many to many)
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布带有产品的标签（多对多）
- en: We definitely want to be able to filter our products via tags. We can follow
    the same pattern from the previous topic. Let's modify our `products` module.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对希望能够通过标签过滤我们的产品。我们可以遵循前一个主题中的相同模式。让我们修改我们的`products`模块。
- en: 'First, our subscriber needs to reactively change to an array of tags _ids.
    We can use a `Session` variable for now to set an array of tag _ids so that we
    can easily modify this directly from the console:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的订阅者需要反应性地将一个标签_id数组转换为数组。我们可以现在使用一个`Session`变量来设置一个标签_id数组，这样我们就可以轻松地从控制台直接修改它：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We use underscore''s `_.extend` function to make sure that the `filter` variable
    has a `tags` key, if `tags` exist. Now our publisher is going to get a bit more
    complex:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用下划线的`_.extend`函数确保如果存在`tags`，则`filter`变量有一个`tags`键。现在我们的发布者将变得更加复杂：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While the code may seem long, the logic is easy to understand. First, we filtered
    our `Tags` collection by using the `tags` array that we had defined in our subscriber.
    Then we chained the relations using a combination of `key` and `foreign_key`.
    The function that the mapping table (`ProductsTags`) serves is clear in this scenario.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码可能看起来很长，但逻辑很容易理解。首先，我们使用我们在订阅者中定义的`tags`数组过滤了`Tags`集合。然后，我们使用`key`和`foreign_key`的组合链式关系。在这种情况下，映射表（`ProductsTags`）所服务的函数是清晰的。
- en: Key, foreign key, options, and filter
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键，外键，选项和过滤器
- en: The core concepts to understand from the `lepozepo:publish-with-relations` package
    are simply the options provided within the `@relations` function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从`lepozepo:publish-with-relations`包中理解的核心概念是`@relations`函数中提供的选项。
- en: Both `key` and `foreign_key` default to the `_id` field. The `key` always makes
    reference to a field within the collection while the `foreign_key` always makes
    reference to a field of the parent collection.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`和`foreign_key`默认为`_id`字段。`key`始终引用集合内的字段，而`foreign_key`始终引用父集合的字段。'
- en: 'The `options` and `filter` options are equivalent to the second and first arguments
    (respectively) of a Meteor - MongoDB query: `Products.find(filter,options)`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`options` 和 `filter` 选项等价于 Meteor - MongoDB 查询的第二个和第一个参数（分别）：`Products.find(filter,options)`。'
- en: 'There are many packages that work similar to `lepozepo:publish-with-relations`,
    and we are not exploring them in this book, but they are certainly worth keeping
    an eye on: `reywood:publish-composite`, `lepozepo:reactive-publish`, and `cottz:publish-relations`.
    I have found the last package to be the best of the bunch because it is simple
    to use and forces the developer to create smarter database relationships.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多包的工作方式类似于 `lepozepo:publish-with-relations`，我们在这本书中没有探讨它们，但它们确实值得留意：`reywood:publish-composite`、`lepozepo:reactive-publish`
    和 `cottz:publish-relations`。我发现最后一个包是其中最好的，因为它使用简单，并迫使开发者创建更智能的数据库关系。
- en: Aggregation publishers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合发布者
- en: Sometimes our database has a considerable amount of information that we want
    to synthesize. Some developers choose to publish all the information to the client
    and have the client synthesize it. This, as we have learned so far, can have a
    negative impact on performance. Other developers might use `Meteor.method` to
    return the synthesized data. This is definitely better for the client, but it
    will take a toll on our server if the computation is large.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们的数据库有大量的信息，我们希望综合起来。一些开发者选择将所有信息发布到客户端，并让客户端进行综合。正如我们迄今为止所学的，这可能会对性能产生负面影响。其他开发者可能会使用
    `Meteor.method` 来返回综合数据。这当然对客户端更好，但如果计算量很大，这将对我们的服务器造成负担。
- en: 'The best way to handle a problem like this is to use MongoDB''s aggregation
    framework to take the hard work of the calculation to our database, and then we
    can pair the results with the `Meteor.publish` special functions: `@added`, `@changed`,
    and `@removed`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这类问题的最佳方式是使用 MongoDB 的聚合框架将计算的繁重工作转移到我们的数据库上，然后我们可以将结果与 `Meteor.publish` 特殊函数配对：`@added`、`@changed`
    和 `@removed`。
- en: The aggregation framework
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合框架
- en: MongoDB's aggregation framework uses the concept of a pipeline to process data.
    A pipeline is, basically, a series of steps that Mongo is going to follow to produce
    the data you need.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的聚合框架使用管道的概念来处理数据。基本上，管道是一系列Mongo将要遵循的步骤，以生成您所需的数据。
- en: We have installed support for the aggregation framework by adding `meteorhacks:aggregate`.
    This gives us access to all of the framework's server-side commands. The most
    common commands that you will end up using are `$match`, `$group`, and `$project`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加 `meteorhacks:aggregate` 来安装了对聚合框架的支持。这使我们能够访问框架的所有服务器端命令。您最终会使用最常用的命令是
    `$match`、`$group` 和 `$project`。
- en: 'Let''s build a publisher for our `dashboard` module and start by building the
    template:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的 `dashboard` 模块构建一个发布者，并首先构建模板：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we need to build a collection that exists only on the client. Our server
    will communicate with this collection manually. We specifically place this collection
    on the client side because we do not want the server to record data onto the database.
    We can append the collection to the (`/dashboard/client/dashboard.coffee`) client
    controller file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要构建一个只存在于客户端的集合。我们的服务器将手动与这个集合通信。我们特别将这个集合放在客户端，因为我们不希望服务器将数据记录到数据库中。我们可以将集合附加到
    (`/dashboard/client/dashboard.coffee`) 客户端控制器文件中：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As this collection is client-side, we have differentiated it with an underscore
    at the beginning of the name. This, of course, is not required, but it helps prevent
    duplicate collection names.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个集合是客户端的，我们在名称开头加了一个下划线来区分它。当然，这并不是必需的，但它有助于防止重复的集合名称。
- en: 'Our goal is to publish the sum of the total and subtotal for the `"pending"`
    orders. The steps for our pipeline are simple:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是发布 `"pending"` 订单的总计和子总计。我们的管道步骤很简单：
- en: Filter the collection to show orders with status equal to `"pending"`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤集合以显示状态等于 `"pending"` 的订单。
- en: 'Sum the totals of every filtered order:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个过滤订单的总计求和：
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To use the aggregation framework, you use the `.aggregate` function that is
    attached to the collection object; `Orders`, in this case. This function only
    takes an array as a parameter—this is because the array is the ordered set of
    steps that the framework is going to follow. Each step is represented by an object
    within the array and always begins with an operator.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用聚合框架，你使用附加到集合对象的 `.aggregate` 函数；在这种情况下是 `Orders`。此函数仅接受一个数组作为参数——这是因为数组是框架将要遵循的步骤的有序集合。数组中的每个步骤都由一个对象表示，并且总是以一个运算符开始。
- en: Here we have decided to use `$match` to filter the orders to find the pending
    orders, and then we have used `$group` to accumulate the values of `total` and
    `subtotal`. Notice that the `$group` expression has a mandatory `_id` key. This
    key defines how we want to group the collection. By setting the `_id` key to `null`,
    we are stating that we want all the documents in the collection grouped into one
    single object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们决定使用 `$match` 来过滤订单以找到待处理的订单，然后我们使用了 `$group` 来累计 `total` 和 `subtotal`
    的值。请注意，`$group` 表达式有一个强制性的 `_id` 键。此键定义了我们想要如何分组集合。通过将 `_id` 键设置为 `null`，我们表示我们希望将集合中的所有文档分组到一个单一的对象中。
- en: '`$sum` is an accumulator operator. When you use an operator like this, you
    can access a document property by using the money sign (`$`) followed by the name
    of the field within a string. Also, you can access objects within objects using
    the dot notation (`"$discount.amount"`).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`$sum` 是一个累加运算符。当你使用这样的运算符时，你可以通过使用货币符号（`$`）后跟字段名称的字符串来访问文档属性。此外，你可以使用点表示法（`"$discount.amount"`）访问对象中的对象。'
- en: 'The result of `totals` is an array containing a single object with the keys:
    `total`, `subtotal`, and `discount`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`totals` 的结果是包含单个对象的数组，具有 `total`、`subtotal` 和 `discount` 键。'
- en: Publishing the results
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布结果
- en: 'Publishing the results is much easier than it seems. We only need to use the
    `@added` function that is bound to `Meteor.publish`. The `@added` function, basically,
    informs the subscriber that data has been added to the published set:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 发布结果比看起来要容易得多。我们只需要使用绑定到 `Meteor.publish` 的 `@added` 函数。基本上，`@added` 函数会通知订阅者已向发布集合中添加了数据：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The last two lines make sure that the `totals` array exists, and if it does
    not, then we publish the first object within the array to our `_dashboard` collection.
    The `@added` function has three required parameters. The first parameter is the
    name of the collection, the second is the `_id` of the document, and the third
    is the document.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行确保 `totals` 数组存在，如果不存在，则将数组中的第一个对象发布到我们的 `_dashboard` 集合。`@added` 函数有三个必需的参数。第一个参数是集合的名称，第二个是文档的
    `_id`，第三个是文档。
- en: Notice that these kinds of publishers are not reactive, which means that we
    do not need to add a `@changed` or `@removed` function. We can take this a step
    further though. Instead of creating a collection for every module that needs an
    aggregation publisher, we can create one master collection that manages all our
    aggregation publishers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这类发布者不是响应式的，这意味着我们不需要添加 `@changed` 或 `@removed` 函数。然而，我们可以更进一步。我们不需要为每个需要聚合发布者的模块创建一个集合，我们可以创建一个主集合来管理我们所有的聚合发布者。
- en: 'First, we remove our `_dashboard` collection and create a new `Aggregate` collection:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们删除我们的 `_dashboard` 集合并创建一个新的 `Aggregate` 集合：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we need to modify our publisher:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改我们的发布者：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this, we can now access our values by calling the following function on
    our client-side console:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在可以通过在客户端控制台调用以下函数来访问我们的值：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It's important to understand that as soon as we leave the route, the subscriber
    will be stopped and the `aggregate` collection will be cleared. This default behavior
    gives this collection a lot of flexibility.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，一旦我们离开路由，订阅者将被停止，`aggregate` 集合将被清除。这种默认行为给了这个集合很大的灵活性。
- en: Why is using the aggregation framework with a publisher more effective than
    with `Meteor.method`? The Meteor methods are designed to trigger critical functions
    within our server and respond with a simple message. On the other hand, publishers
    are designed to control data sets. You will very quickly find that publishers
    are easier to control and optimize than methods.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用发布者与聚合框架比使用 `Meteor.method` 更有效？`Meteor.method` 是设计用来触发服务器中的关键函数并返回简单消息的。另一方面，发布者是设计用来控制数据集的。你很快会发现，发布者比方法更容易控制和优化。
- en: External API publishers
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部API发布者
- en: These types of publishers should be avoided. They are great to get raw data
    from external services such as **Stripe** or **Square**, but they tend to be little
    bit slower because this involves actively communicating with another server. When
    we are integrating with other servers, we should always build a separate synchronization
    server. We will talk about APIs in another chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 应该避免这类发布者。它们从外部服务（如 **Stripe** 或 **Square**）获取原始数据很棒，但它们通常稍微慢一些，因为这意味着需要与另一个服务器进行主动通信。当我们与其他服务器集成时，我们应该始终构建一个单独的同步服务器。我们将在另一章中讨论
    API。
- en: Still, this publishing pattern can be useful in edge cases, so it is important
    to know that this option exists.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这种发布模式在边缘情况下可能很有用，因此了解这个选项的存在很重要。
- en: The HTTP package
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 包
- en: HTTP is a protocol for collaborative systems; it is the protocol that allows
    users to connect to web pages. The HTTP protocol can be used to access data from
    other servers from our own server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是一个协作系统的协议；它是允许用户连接到网页的协议。HTTP 协议可以用来从我们的服务器访问其他服务器上的数据。
- en: 'We are going to use Meteor''s integrated HTTP `Request` module to communicate
    with Stripe''s servers. We chose to integrate with Stripe because it is a payment
    processor that is easy to integrate and more reliable than most other payment
    processors in the market. We have added this package when we ran `meteor add http`.
    This module has all the functions that you would expect: `.get`, `.post`, `.put`,
    and `.del`. For this topic, we are only going to cover the `.get` function.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Meteor 的集成 HTTP `Request` 模块与 Stripe 的服务器进行通信。我们选择与 Stripe 集成，因为它是一个易于集成且比市场上大多数其他支付处理器更可靠的支付处理器。我们在运行
    `meteor add http` 时添加了这个包。此模块具有你期望的所有功能：`.get`、`.post`、`.put` 和 `.del`。对于这个主题，我们只将涵盖
    `.get` 函数。
- en: Our goal is to get data from Stripe. Start by creating a free account in Stripe.
    After you have created your account, go to your dashboard and set it to `"test"`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是从 Stripe 获取数据。首先在 Stripe 中创建一个免费账户。创建账户后，转到你的仪表板并将其设置为 `"test"`。
- en: 'Now create a payment by clicking on **+ Create Payment**. Use the following
    data for the payment:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过点击 **+ 创建支付** 来创建一个支付。使用以下数据来进行支付：
- en: '**Amount**: `10`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金额**：`10`'
- en: '**Card Number**: `4242 4242 4242 4242`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卡号**：`4242 4242 4242 4242`'
- en: In our test environment, we do not need to add CVC, and Stripe automatically
    sets the expiration date to a year from today.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试环境中，我们不需要添加 CVC，Stripe 会自动将到期日期设置为今天起一年。
- en: Click on **Account Settings** and copy your test secret key. We are going to
    use this to authorize our request.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **账户设置** 并复制你的测试密钥。我们将使用它来授权我们的请求。
- en: 'We can start by creating a new publisher under `/dashboard_pub.coffee`; we
    are only going to get the last three charges—we will modify this later:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先在 `/dashboard_pub.coffee` 下创建一个新的发布者；我们目前只获取最后三个费用——我们稍后会修改这个设置：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `@unblock` function that we are using here has been made available via the
    `meteorhacks:unblock` package. It works the same way as the `@unblock` function
    does in `Meteor.methods`; this makes sure that the publisher does not block the
    server while it is waiting for information from Stripe to arrive. Unblocking the
    aggregation publishers is crucial! If we do not unblock the publisher, then we
    risk the client becoming unresponsive when the user navigates away from the page.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的 `@unblock` 函数是通过 `meteorhacks:unblock` 包提供的。它的工作方式与 `Meteor.methods`
    中的 `@unblock` 函数相同；这确保了发布者在等待从 Stripe 收到信息时不会阻塞服务器。解除聚合发布者的阻塞至关重要！如果我们不解除发布者的阻塞，那么当用户离开页面时，客户端可能会变得无响应。
- en: 'You might be asking yourself: can''t we just make the HTTP request on the client
    and not worry about blocking the server? No, we cannot. If you were to run this
    function on the client, you would have to expose your secret key, and this is
    a major security flaw.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能自己在想：我们能不能直接在客户端发起 HTTP 请求而不必担心阻塞服务器？不，我们不能。如果你在客户端运行这个函数，你就必须暴露你的密钥，这是一个重大的安全漏洞。
- en: 'The `HTTP.get` function has three important fields: the URL, the `options`
    object, and the callback function. The URL is the address that Stripe provides
    in their API documentation—in this case, we have used the `/charges` URL and passed
    a parameter `limit` to get the last three sales. The options object is used to
    pass all the information that the request needs. In this case, we will use the
    `headers` key to set our `Authorization` header. There are several keys that the
    options object can take; you can find these at [docs.meteor.com](http://docs.meteor.com).
    Our callback function receives the result from the request. As with most functions
    in Meteor, it returns two arguments; the first one is an error object that is
    undefined if there is no error, while the second one is the actual result.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTP.get`函数有三个重要的字段：URL、`options`对象和回调函数。URL是Stripe在其API文档中提供的地址——在这种情况下，我们使用了`/charges`
    URL并传递了一个参数`limit`来获取最后三笔销售。`options`对象用于传递请求所需的所有信息。在这种情况下，我们将使用`headers`键来设置我们的`Authorization`头。`options`对象可以接受几个键；你可以在[docs.meteor.com](http://docs.meteor.com)找到这些信息。我们的回调函数接收请求的结果。与Meteor中的大多数函数一样，它返回两个参数；第一个是一个错误对象，如果没有错误则为未定义，而第二个是实际的结果。'
- en: In this case, the data that we are looking for is contained within `result.data.data`
    as an array. We can then easily publish the data with our `@added` function. Notice
    that we are binding both the callback and the `_.each` function, so we can have
    access to `@added`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在寻找的数据包含在`result.data.data`数组中。然后我们可以轻松地使用我们的`@added`函数发布数据。请注意，我们同时绑定了回调函数和`_.each`函数，这样我们就可以访问到`@added`。
- en: 'Let''s subscribe to our new publisher to see our data:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们订阅我们的新发布者来查看我们的数据：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Try running `Aggregate.find().fetch()` in your console to see the results.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在你的控制台中运行`Aggregate.find().fetch()`来查看结果。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to isolate subscribers from templates using
    template hooks. Also, we learned how to optimize the structure of our database
    depending on how we are going to use it. When it comes to publishers, we learned
    how to return every possible data structure without breaking reactivity. We covered
    aggregation publishers and learned how to synthesize data before we publish it,
    without hurting the performance of the server.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用模板钩子将订阅者从模板中隔离出来。我们还学习了如何根据我们将如何使用它来优化我们数据库的结构。当涉及到发布者时，我们学习了如何返回每个可能的数据结构而不破坏响应性。我们介绍了聚合发布者，并学习了在发布之前如何合成数据，而不会损害服务器的性能。
- en: In the next chapter, we will cover a handful of frontend techniques that will
    help us to keep our code flexible and our frontend looking great.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些前端技术，这些技术将帮助我们保持代码的灵活性并使前端看起来很棒。
