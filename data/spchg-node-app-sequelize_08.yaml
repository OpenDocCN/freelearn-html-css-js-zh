- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Logging and Monitoring Your Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录和监控您的应用程序
- en: Maintaining records and metrics provides us with many advantages during our
    development cycle. They can help us increase our application’s performance, observe
    issues before they become problems, and give us insights into the application’s
    state. Logging and monitoring your application can reduce the time your development
    (and debugging) takes, as well as the number of headaches you acquire throughout
    the project. Logging is something that is often overlooked or treated with minimal
    afterthought, but it could make the difference between losing an hour’s worth
    of uptime or an entire day’s worth.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 维护记录和指标在我们的开发周期中提供了许多优势。它们可以帮助我们提高应用程序的性能，在问题成为问题之前观察问题，并让我们深入了解应用程序的状态。日志记录和监控您的应用程序可以减少您开发（和调试）所需的时间，以及在整个项目过程中您所获得的头痛次数。日志记录是经常被忽视或最少考虑的事情，但它可能是在丢失一小时的正常运行时间或整个一天的正常运行时间之间做出差别的关键。
- en: Suppose we had an application that simply inserted the details of a registration
    form into a database table. One day, the team accidentally renamed the `first_name`
    column to `firstname` and now no new records were being inserted. With logging,
    we would see something along the lines of a “`first_name` column does not exist”
    type of error. This would help guide us into looking at the database’s schema
    and figuring out where the disconnection is occurring (in this case, our typo
    from removing the underscore).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用程序，它只是将注册表单的详细信息插入到数据库表中。有一天，团队不小心将 `first_name` 列重命名为 `firstname`，现在没有新的记录被插入。使用日志记录，我们会看到类似“`first_name`
    列不存在”类型的错误。这将帮助我们查看数据库的模式，并找出断开连接发生的地方（在这种情况下，我们删除下划线的错误）。
- en: What if the error was more complex than that though? Our application is now
    running in a cluster and each node within the cluster receives a unique message
    exclusively from the other nodes. Occasionally, we would notice our table was
    missing some records without a clear pattern from the data itself. Using a logging
    mechanism, we would occasionally see a `Could not establish connection` error.
    We can double-check our connection pooling management (if applicable) or test
    each node if we can successfully connect to the database. On a small cluster,
    this would not be a problem, but on a large system, this could become tedious
    and time-consuming.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误比这更复杂怎么办？我们的应用程序现在正在集群中运行，集群中的每个节点都只从其他节点接收独特的消息。偶尔，我们会注意到我们的表中缺少一些记录，而数据本身并没有明显的模式。使用日志机制，我们偶尔会看到“无法建立连接”的错误。我们可以双重检查我们的连接池管理（如果适用）或测试每个节点，看我们是否可以成功连接到数据库。在一个小型集群中，这不会是问题，但在一个大型系统中，这可能会变得繁琐且耗时。
- en: A solution for helping manage applications in a larger cluster would be to customize
    (or add) additional context to your application’s logging records. Meta-information
    such as the machine’s identifier could have helped us in the previous example.
    Sequelize offers a way to customize our logging, using an `options.logging` parameter,
    with the ability to change the logging behavior with different method invocations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为帮助管理更大集群中的应用程序提供一个解决方案，就是为您的应用程序的日志记录记录自定义（或添加）额外的上下文。元信息，如机器的标识符，可能有助于我们之前的例子。Sequelize
    提供了一种使用 `options.logging` 参数自定义我们的日志记录的方法，并能够通过不同的方法调用更改日志记录行为。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Configuring logging with all of the available interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用所有可用接口配置日志记录
- en: Integrating third-party logging applications such as Pino or Bunyan
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成第三方日志记录应用程序，如 Pino 或 Bunyan
- en: Collecting metrics and statistics for Sequelize with OpenTelemetry
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry 收集 Sequelize 的指标和统计数据
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter at [https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch8](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch8)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此章节的代码文件[https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch8](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch8)中找到
- en: Configuring logging with all of the available interfaces
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用所有可用接口配置日志记录
- en: 'Sequelize offers a few overload signatures for incorporating logs into an application.
    The default behavior is to call `console.log` for each query. The following is
    a list of signatures that Sequelize will abide by:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 为将日志集成到应用程序中提供了几个重载签名。默认行为是针对每个查询调用 `console.log`。以下是 Sequelize 将遵守的签名列表：
- en: '`function (msg) {}`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function (msg) {}`'
- en: '`function (...msg) {}`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function (...msg) {}`'
- en: '`true`/`false`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`/`false`'
- en: '`msg => someLogger.debug(msg)`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msg => someLogger.debug(msg)`'
- en: '`someLogger.debug.bind(someLogger)`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`someLogger.debug.bind(someLogger)`'
- en: 'If we wanted to customize Sequelize’s logging behavior, the following example
    would be a quick introduction to how to do so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想自定义 Sequelize 的日志记录行为，以下示例将快速介绍如何实现：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In addition to Sequelize sending the SQL queries into our `customLog` function,
    we are also given a helper method for when we need to log additional info beyond
    our queries. The Sequelize instance provides a `log` method and can be called
    as shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Sequelize 将 SQL 查询发送到我们的 `customLog` 函数外，我们还提供了一个辅助方法，用于在需要记录查询之外的其他信息时。Sequelize
    实例提供了一个 `log` 方法，可以像下面这样调用：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If your Sequelize instance’s `benchmark` parameter is set to `true`, then Sequelize
    will add the total elapsed time for the query to complete at the end of the message.
    Using our previous example, a log entry might look something similar to this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Sequelize 实例的 `benchmark` 参数设置为 `true`，那么 Sequelize 将在消息末尾添加查询完成的总耗时。使用我们之前的示例，日志条目可能看起来类似如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes, we will want to log the log query, query objects, applicable parameters,
    or any other form of metadata. Sequelize will recognize the spread pattern for
    this type of support:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要记录日志查询、查询对象、适用参数或其他任何形式的元数据。Sequelize 将识别这种支持的扩展模式：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now call the Sequelize instance’s `log` method, which will send the
    parameters to our `multiLog` function as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以调用 Sequelize 实例的 `log` 方法，该方法将参数发送到我们的 `multiLog` 函数，如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would print each parameter onto its own newline due to the behavior of
    the `multiLog` function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `multiLog` 函数的行为，这将每个参数打印到其自己的换行符上。
- en: 'The logging parameter can also accept a Boolean value. The `true` value will
    coalesce into Sequelize’s default behavior (`console.log`). Setting the value
    to `false` would disable logging completely and nullify any log invocations. The
    following example would prevent Sequelize from logging queries:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 日志参数还可以接受布尔值。`true` 值将合并为 Sequelize 的默认行为（`console.log`）。将值设置为 `false` 将完全禁用日志记录并取消任何日志调用。以下示例将阻止
    Sequelize 记录查询：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `true` value for logging is considered deprecated and is not preferable
    to omitting the logging value for the default behavior or using `console.log`
    as the parameter’s value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录的 `true` 值被认为是过时的，并且不推荐省略日志记录值以实现默认行为或使用 `console.log` 作为参数的值。
- en: 'Sequelize can also limit logging to specific queries with the logging parameter
    on each queryable method (for example, `findAll`, `update`, and `create`). For
    instance, if we wanted to disable logging on a specific query, we can do so by
    setting the following query’s `logging` parameter to `false`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 还可以通过每个可查询方法的日志参数（例如，`findAll`、`update` 和 `create`）限制日志记录到特定的查询。例如，如果我们想禁用特定查询的日志记录，我们可以通过将以下查询的
    `logging` 参数设置为 `false` 来实现：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also see a log output of queries by taking advantage of Sequelize’s
    use of the debug NPM package. By setting the environment variable to `DEBUG=sequelize:sql*`,
    your terminal should show queries executed by Sequelize.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以利用 Sequelize 对 debug NPM 包的使用来查看查询的日志输出。通过设置环境变量为 `DEBUG=sequelize:sql*`，您的终端应显示
    Sequelize 执行的查询。
- en: Integrating third-party logging applications such as Pino or Bunyan
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成第三方日志应用，如 Pino 或 Bunyan
- en: If our application already utilizes a third-party application for logging, Sequelize
    can offer support for integrating with such systems. This section references two
    logging applications, Pino and Bunyan, but any logging library or framework should
    also be compatible with Sequelize.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序已经使用第三方日志应用，Sequelize 可以提供对这些系统进行集成的支持。本节引用了两个日志应用，Pino 和 Bunyan，但任何日志库或框架都应与
    Sequelize 兼容。
- en: Integrating with Pino
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Pino 集成
- en: 'Pino is a low overhead Node.js logger that also offers redaction, transport,
    and asynchronous support. Presuming our project has Pino installed within our
    `node_modules` folder, we can simply integrate it with our Sequelize instance
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Pino 是一个低开销的 Node.js 日志记录器，它还提供编辑、传输和异步支持。假设我们的项目在 `node_modules` 文件夹中安装了 Pino，我们可以简单地将其与
    Sequelize 实例集成，如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, when we call `sequelize.log` manually or execute queries, the logs will
    be sent to the Pino logging library. The output would look similar to this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们手动调用 `sequelize.log` 或执行查询时，日志将被发送到 Pino 日志库。输出将类似于以下内容：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For more information on Pino, you can refer to the project’s repository at [https://github.com/pinojs/pino](https://github.com/pinojs/pino).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Pino 的更多信息，您可以参考项目的仓库[https://github.com/pinojs/pino](https://github.com/pinojs/pino)。
- en: Integrating with Bunyan
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Bunyan 集成
- en: 'Sometimes a logging framework requires an intermediary step before being able
    to bind the framework to Sequelize. An example of this would be the Bunyan framework.
    Bunyan is a logging framework that focuses on offering serialization and streaming
    methods. Integrating this framework would look similar to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，日志框架需要在将其绑定到 Sequelize 之前进行中间步骤。Bunyan 框架就是这样一个例子。Bunyan 是一个专注于提供序列化和流方法的日志框架。集成此框架看起来类似于以下内容：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding example shows the output of Bunyan’s logging with Sequelize:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例显示了 Bunyan 日志与 Sequelize 的输出：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For more information on Bunyan, you can refer to the project’s repository at
    [https://github.com/trentm/node-bunyan](https://github.com/trentm/node-bunyan).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Bunyan 的更多信息，您可以参考项目的仓库[https://github.com/trentm/node-bunyan](https://github.com/trentm/node-bunyan)。
- en: From the Pino and Bunyan examples, we can see that adding a logging framework
    already resolves our unique machine identifier, the time of the error, and urgency
    research. By looking at the logs, it should now be easier to sift through wherever
    an error is occurring within clusters or applications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Pino 和 Bunyan 的示例中，我们可以看到添加日志框架已经解决了我们独特的机器标识符、错误发生的时间和紧急研究。通过查看日志，现在应该更容易筛选出在集群或应用程序中发生错误的任何地方。
- en: 'We can now finish integrating a logging framework within the Avalon Airlines
    project. From the project’s root directory, we will need to install the necessary
    package:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以完成在 Avalon Airlines 项目中集成日志框架的工作。从项目的根目录开始，我们需要安装必要的包：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Within `models/index.js`, see the following line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `models/index.js` 中，查看以下行：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Export the Pino framework underneath with a constant:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量导出下面的 Pino 框架：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After exporting the constant, see this line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 导出常量后，请查看此行：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Underneath, we can add the logging parameter to the `config` object as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，我们可以将日志参数添加到 `config` 对象中，如下所示：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, our application supports custom logs using the Pino logging framework.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序支持使用 Pino 日志框架进行自定义日志。
- en: Collecting metrics and statistics for Sequelize with OpenTelemetry
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry 收集 Sequelize 的指标和统计数据
- en: OpenTelemetry is a standardized specification for collecting, aggregating, and
    instrumenting various statistics, metrics, traces, and logs. OpenTelemetry can
    help us identify where bottlenecks may occur, categorize and apply topological
    filters on logs, and plug into third-party applications (for example, for alert
    monitoring).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 是一个用于收集、聚合和度量各种统计、指标、跟踪和日志的标准规范。OpenTelemetry 可以帮助我们识别瓶颈可能发生的位置，对日志进行分类和应用拓扑过滤器，并连接到第三方应用程序（例如，用于警报监控）。
- en: 'To integrate OpenTelemetry with Sequelize, we would need to install the following
    packages within our Avalon Airlines project:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 OpenTelemetry 与 Sequelize 集成，我们将在 Avalon Airlines 项目中安装以下包：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Within `models/index.js`, under the `''use strict'';` line, we can now add
    our new packages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `models/index.js` 中，在 `'use strict';` 行下方，我们现在可以添加我们的新包：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Just above the `let sequelize;` line, we can add the trace provider, which
    will register the correct Sequelize OpenTelemetry plugin:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `let sequelize;` 行的上方，我们可以添加跟踪提供者，这将注册正确的 Sequelize OpenTelemetry 插件：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Below the `traceProvider` declaration block, we can associate the provider
    with the Sequelize instrument specifications:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `traceProvider` 声明块下方，我们可以将提供者与 Sequelize 仪器规范关联：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find additional references and option parameters for Sequelize instrumentation
    at [https://github.com/aspecto-io/opentelemetry-ext-js/tree/master/packages/instrumentation-sequelize](https://github.com/aspecto-io/opentelemetry-ext-js/tree/master/packages/instrumentation-sequelize).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/aspecto-io/opentelemetry-ext-js/tree/master/packages/instrumentation-sequelize](https://github.com/aspecto-io/opentelemetry-ext-js/tree/master/packages/instrumentation-sequelize)找到关于
    Sequelize 仪表化的额外参考和选项参数。
- en: 'At the root directory of the Avalon Airlines project, create a file called
    `tracing.js` with the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Avalon Airlines 项目的根目录下，创建一个名为 `tracing.js` 的文件，并包含以下代码：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we can call our application with the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令调用我们的应用程序：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After that, open a browser to the project’s URL (by default, `http://localhost:3000/`)
    and refresh the page a few times. After a few seconds, you should see some events
    within your terminal that look similar to this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，打开浏览器访问项目的 URL（默认为 `http://localhost:3000/`）并刷新页面几次。几秒钟后，你应该能在你的终端看到一些类似以下的事件：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Traditionally, the application would export this data to a collector such as
    Zipkin ([https://zipkin.io/](https://zipkin.io/)), Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)),
    or Prometheus ([https://prometheus.io/](https://prometheus.io/)). For instructions
    on how to associate the application’s telemetry data, you can refer to this tutorial
    here: https://opentelemetry.io/docs/instrumentation/js/exporters/.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序会将这些数据导出到收集器，如 Zipkin ([https://zipkin.io/](https://zipkin.io/))、Jaeger
    ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)) 或 Prometheus
    ([https://prometheus.io/](https://prometheus.io/))。有关如何关联应用程序的遥测数据的说明，请参阅此教程：https://opentelemetry.io/docs/instrumentation/js/exporters/。
- en: 'If you were to use Zipkin as your collector, then under the `const tracerProvider
    = new NodeTracerProvider({` block within `models/index.js`, we would replace this
    line:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用 Zipkin 作为你的收集器，那么在 `models/index.js` 文件中的 `const tracerProvider = new
    NodeTracerProvider({)` 块下，我们将替换这一行：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to replace it with the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其替换为以下内容：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will tell our trace provider to export the traces and logs to the Zipkin
    Exporter (multiple exporters can be used at the same time).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示我们的跟踪提供程序将跟踪和日志导出到 Zipkin 导出器（可以同时使用多个导出器）。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the different overload signatures for configuring
    logging with Sequelize. We also learned how to integrate third-party frameworks,
    such as OpenTelemetry, within our Node.js application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了配置 Sequelize 日志的不同重载签名。我们还学习了如何在我们的 Node.js 应用程序中集成第三方框架，例如 OpenTelemetry。
- en: In the next chapter, we will be covering how to integrate plugins, or adapters,
    into our Sequelize instance. The following chapter will also demonstrate how to
    create our own adapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何将插件或适配器集成到我们的 Sequelize 实例中。下一章也将演示如何创建我们自己的适配器。
