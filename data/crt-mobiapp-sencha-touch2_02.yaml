- en: Chapter 2. A Feed Reader
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。源阅读器
- en: In our first project, Task Manager, we explored some of the basics of Sencha
    Architect. We also covered some of the ways to store, edit, and display data in
    Sencha Touch.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个项目，任务管理器中，我们探讨了 Sencha Architect 的一些基础知识。我们还介绍了在 Sencha Touch 中存储、编辑和显示数据的一些方法。
- en: 'This chapter will explore three new areas:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨三个新的领域：
- en: The NavigationView
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航视图
- en: Loading remote data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载远程数据
- en: Creating complex layouts with Sencha XTemplate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sencha XTemplate 创建复杂布局
- en: 'In this chapter we will build an RSS reader to grab news feeds from a list
    of sites and display the contents of those feeds in a complex pattern of columns
    and rows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个 RSS 阅读器，从一系列网站抓取新闻源，并以复杂的行列模式显示这些源的内容：
- en: '![A Feed Reader](img/8901OS_02_1.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![源阅读器](img/8901OS_02_1.jpg)'
- en: The newsreader will also build on the Sencha Touch `NavigationView` component
    to automate a number of helpful navigation elements for touch devices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 新闻阅读器也将基于 Sencha Touch 的 `NavigationView` 组件，为触摸设备自动化许多有用的导航元素。
- en: The basic application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本应用程序
- en: 'Our basic application will start off much the same way as our previous application:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本应用程序将与我们之前的应用程序以几乎相同的方式开始：
- en: A `NavigationView` component to hold all our view components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于包含所有视图组件的 `NavigationView` 组件
- en: A list to display feeds
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于显示源列表
- en: A store to hold the list data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于存储列表数据的存储
- en: A model to describe the data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于描述数据的模型
- en: A form to add items to the list
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于向列表添加项目的表单
- en: We will spend most of our time setting up `NavigationView` and a much briefer
    time covering the additional components, since these are very similar to what
    we did in [Chapter 1](ch01.html "Chapter 1. A Simple Task List"), *A Simple Task
    List*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将花费大部分时间设置 `NavigationView`，以及更简短的时间介绍其他组件，因为这些组件与我们在 [第一章](ch01.html "第一章。简单任务列表")，*简单任务列表*
    中所做的是非常相似的。
- en: An overview of NavigationView
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航视图概述
- en: In [Chapter 1](ch01.html "Chapter 1. A Simple Task List"), *A Simple Task List*,
    we manually coded a Back button into our Details view. The Back button was hidden
    by default and only displayed when an item in the list was clicked on and the
    Details view appeared. The Back button returned our user to the main list of tasks
    and then hid itself until it was needed again.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第一章](ch01.html "第一章。简单任务列表")，*简单任务列表* 中，我们手动将返回按钮编码到我们的详细信息视图中。默认情况下，返回按钮是隐藏的，并且仅在点击列表中的项目并出现详细信息视图时显示。返回按钮将用户返回到主要任务列表，然后再次隐藏，直到再次需要。
- en: In our new Feed Reader application, we will use `NavigationView`, which handles
    all of this functionality automatically. `NavigationView` functions similar to
    a card layout where a number of panels can be hidden or displayed based on the
    active item for the view.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新源阅读器应用程序中，我们将使用 `NavigationView`，它自动处理所有这些功能。`NavigationView` 的功能类似于卡片布局，其中可以根据视图的活动项目隐藏或显示多个面板。
- en: 'However, unlike a card layout, where the items are typically declared when
    the layout is created, `NavigationView` typically adds items dynamically using
    the `push()` function to add panels and other items for display. For example,
    let''s assume we have a `NavigationView` component called `MainView` that contains
    a list view with a list of items. We also have a details panel called `Details`.
    When the user clicks on an item in the list, we can call:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与卡片布局不同，其中项目通常在布局创建时声明，`NavigationView` 通常使用 `push()` 函数动态添加项目，用于显示面板和其他项目。例如，假设我们有一个名为
    `MainView` 的 `NavigationView` 组件，它包含一个带有项目列表的列表视图。我们还有一个名为 `Details` 的详细信息面板。当用户点击列表中的项目时，我们可以调用：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code will push a copy of our Details view onto `NavigationView` (`MainView`).
    `NavigationView` will use an animation transition to slide the new Details panel
    into place, automatically create the Back button for us, and then set the title
    of our Navigation bar to `Something Cool`. It also handles all of the behind-the-scenes
    code for taking us back to our main list when the Back button is clicked.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将我们的详细信息视图的副本推送到 `NavigationView` (`MainView`)。`NavigationView` 将使用动画过渡将新的详细信息面板滑入位置，为我们自动创建返回按钮，并将我们的导航栏标题设置为
    `Something Cool`。它还处理所有幕后代码，在点击返回按钮时带我们返回到主要列表。
- en: This makes `NavigationView` a very handy component to serve as the foundation
    for our application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 `NavigationView` 成为一个非常适合作为我们应用程序基础的组件。
- en: Let's begin by creating a new Sencha Touch application in Sencha Architect.
    For this application we are going to target the iPad tablet sized screen. This
    will give us more room to create an interesting display. We will also show you
    how to adjust the screen for iPhone and mobile phone users on the fly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在Sencha Architect中创建一个新的Sencha Touch应用程序开始。对于这个应用程序，我们将针对iPad平板电脑大小的屏幕。这将给我们更多的空间来创建有趣的显示。我们还将向您展示如何动态调整iPhone和手机用户的屏幕。
- en: Use the **Size** menu at the bottom of the design area to select iPad as our
    screen size and drag a **NavigationView** object from the toolbox onto the iPad
    image in our display area. In the **Config** section, set **userAlias** to **MainView**
    so that we can reference it later.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计区域底部的**大小**菜单选择iPad作为我们的屏幕大小，并将一个**NavigationView**对象从工具箱拖动到显示区域中的iPad图像上。在**配置**部分，将**userAlias**设置为**MainView**，以便我们稍后可以引用它。
- en: 'Next, we need to add a **List** view to **MainView** and give it a **Store**
    (with a **LocalStorage** proxy) and **Model**, just as we did in [Chapter 1](ch01.html
    "Chapter 1. A Simple Task List"), *A Simple Task List*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向**MainView**添加一个**列表**视图，并给它一个**存储**（带有**LocalStorage**代理）和**模型**，就像我们在[第1章](ch01.html
    "第1章。一个简单的任务列表")中做的那样，*一个简单的任务列表*：
- en: 'Start by adding a model and configure it as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加一个模型并按以下方式配置它：
- en: Set `userClassName` to `Feed`
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`userClassName`设置为`Feed`
- en: 'Add three fields:'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加三个字段：
- en: '`id` as `int`'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`作为`int`'
- en: '`name` as `string`'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`作为`string`'
- en: '`url` as `string`'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`作为`string`'
- en: 'Next, add the store and configure it as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加存储并按以下方式配置它：
- en: A `LocalStorage` proxy
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`LocalStorage`代理
- en: Set `userClassName` to `FeedStore`
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`userClassName`设置为`FeedStore`
- en: Set `storeId` to `FeedStore`
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`storeId`设置为`FeedStore`
- en: Set `model` to `Feed`
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`model`设置为`Feed`
- en: 'Finally configure the list:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后配置列表：
- en: Set `title` to `Feed Bag`
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`title`设置为`Feed Bag`
- en: Set `itemTpl` to `<div>{name}</div>`
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`itemTpl`设置为`<div>{name}</div>`
- en: Set `id` to `FeedList`
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`id`设置为`FeedList`
- en: Set `store` to `FeedStore`
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`store`设置为`FeedStore`
- en: '![An overview of NavigationView](img/8901OS_02_2.jpg)'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![NavigationView概述](img/8901OS_02_2.jpg)'
- en: Adding the form
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加表单
- en: Since our form is pretty simple this time (and to add a bit of variety) we are
    going to use a sheet to display our form. The sheet can be set to slide in from
    the top, bottom, or sides of the screen. It can also be set to pop in from the
    center.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的表单这次相当简单（并且为了增加一些多样性），我们将使用一个工作表来显示我们的表单。工作表可以设置为从屏幕的顶部、底部或侧面滑入。它也可以设置为从中心弹出。
- en: In this case, we do not want the sheet to be a child of our **MainView** container;
    we only want to create it when we need it, not when the application launches.
    To do this, we drag the **Sheet** object over to **Project Inspector** and drop
    it on the **Views** icon. This will create **Sheet** as a separate view from our
    **MainView** container.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们不希望工作表成为我们的**MainView**容器的子项；我们只想在我们需要时创建它，而不是在应用程序启动时。为此，我们将**Sheet**对象拖动到**项目检查器**上，并将其放置在**视图**图标上。这将创建一个与我们的**MainView**容器分开的**Sheet**视图。
- en: 'Configure the sheet as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式配置工作表：
- en: Set `userClassName` to `AddSheet`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`userClassName`设置为`AddSheet`
- en: Set `enter` to `top`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`enter`设置为`top`
- en: Set `exit` to `bottom`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`exit`设置为`bottom`
- en: Set `stretch` to `true`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`stretch`设置为`true`
- en: Set `stretchY` to `true`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`stretchY`设置为`true`
- en: 'Next we will add a **Form Panel** object to our sheet with the following items:
    a **Container**, two **Text Field,** and two **Button** objects.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的工作表中添加一个**表单面板**对象，包含以下项目：一个**容器**，两个**文本字段**和两个**按钮**对象。
- en: 'The container is simply a place to give the user some instructions. Set the
    **html** attribute to:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 容器只是一个为用户提供一些说明的地方。将**html**属性设置为：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Configure the two text fields as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式配置两个文本字段：
- en: 'For **Field 1**:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**字段1**：
- en: Set `id` to `name`
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`id`设置为`name`
- en: Set `name` to `name`
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`name`设置为`name`
- en: Set `label` to `Name`
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`label`设置为`名称`
- en: Set `margin` to `3 0 3 0`
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`margin`设置为`3 0 3 0`
- en: 'For **Field 2**:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**字段2**：
- en: Set `id` to `url`
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`id`设置为`url`
- en: Set `name` to `url`
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`name`设置为`url`
- en: Set `label` to `URL`
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`label`设置为`URL`
- en: Set `margin` to `3 0 3 0`
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`margin`设置为`3 0 3 0`
- en: 'Configure the two buttons like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式配置两个按钮：
- en: 'For **Button 1**:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**按钮1**：
- en: Set `id` to `SaveButton`
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`id`设置为`SaveButton`
- en: Set `text` to `Save`
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`text`设置为`保存`
- en: Set `margin` to `10`
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`margin`设置为`10`
- en: 'For **Button 2**:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**按钮2**：
- en: Set `id` to `CancelButton`
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`id`设置为`CancelButton`
- en: Set `text` to `Cancel`
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`text`设置为`取消`
- en: Set `margin` to `10`
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`margin`设置为`10`
- en: 'Next, we need to add tap listeners for our two buttons. In the **Event** section
    of **Config** for each button, click on the **+** button and select **Basic Event
    Binding**. When the menu appears, choose **tap**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的两个按钮添加触摸监听器。在每个按钮的**配置**中的**事件**部分，点击**+**按钮并选择**基本事件绑定**。当菜单出现时，选择**触摸**：
- en: '![Adding the form](img/8901OS_02_3.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![添加表单](img/8901OS_02_3.jpg)'
- en: 'For the Cancel button, our tap function is pretty simple:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于取消按钮，我们的点击功能相当简单：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Inside the function, `this` refers to our Sheet view. The code travels down
    into the sheet to find the form and then clears out all the field values. The
    sheet then hides itself.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，`this` 指的是我们的表单视图。代码向下传递到表单中，找到表单并清除所有字段值。然后表单会隐藏自己。
- en: 'The Save button works much the same way as the one from our previous chapter:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 保存按钮的工作方式与上一章中的按钮类似：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We move down from the Sheet view (`this`) to get our form panel. We then get
    the values from our form and find our store. Next, a new Feed record is created
    using the model manager and populated with the values from our form. Finally,
    we add the record to the store, sync the store to save it, and then hide the sheet.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从表单视图（`this`）向下移动以获取表单面板。然后我们从表单中获取值并找到我们的存储库。接下来，使用模型管理器创建一个新的内容记录，并用表单中的值填充它。最后，我们将记录添加到存储库中，同步存储库以保存它，然后隐藏表单。
- en: Next, we need a way to show the sheet for adding Feed items.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法来显示添加内容项的表单。
- en: Back to the navigation view
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回导航视图
- en: In our **MainView** component, we need to add a **Navigation Bar** object to
    the **Config** section using the **+** button next to **Navigation Bar**. This
    navigation bar will display our Back button and our titles. It will also give
    us a place to put the Add button that will show our sheet for adding feed items.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的**主视图**组件中，我们需要使用**导航栏**旁边的**+**按钮，将一个**导航栏**对象添加到**配置**部分。这个导航栏将显示我们的后退按钮和标题。它还将提供一个放置添加按钮的位置，该按钮将显示用于添加内容项的表单。
- en: 'We don''t need to change any configuration options for the navigation bar,
    so just drag a new **Button** object onto it for our Add button. Set the button''s
    configuration like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要更改导航栏的任何配置选项，所以只需将一个新的**按钮**对象拖放到它上面作为添加按钮。设置按钮的配置如下：
- en: Set `align` to `right`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `align` 设置为 `right`
- en: Set `text` to `Add`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `text` 设置为 `Add`
- en: Set `id` to `addButton`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `id` 设置为 `addButton`
- en: Then we need to add a tap event listener like we did with our other buttons.
    The code for our tap event needs to create a new instance of `AddSheet` and display
    it. It also has to do a bit of thinking before it creates the sheet to make sure
    that there is no sheet that is existing already.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要添加一个点击事件监听器，就像我们为其他按钮所做的那样。我们的点击事件代码需要创建一个新的 `AddSheet` 实例并显示它。它还必须在创建表单之前进行一些思考，以确保没有已经存在的表单。
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first thing we do is call `Ext.getCmp` to see if there is already an existing
    sheet. This is because we set up our Save and Cancel buttons to hide the sheet,
    which does not destroy it. It's still a part of the application (still in memory),
    but it is not being displayed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用 `Ext.getCmp` 来查看是否已经存在一个表单。这是因为我们设置了保存和取消按钮来隐藏表单，但不会销毁它。它仍然是应用程序的一部分（仍在内存中），但不会被显示。
- en: If we have used the Add button previously, then `Ext.getCmp` will return a valid
    component. This is what we are checking on line two with `!Ext.isDefined(sheet)`.
    If the sheet is not defined yet (not created), we use `Ext.create('MyApp.view.AddSheet');`
    to make our sheet and then add it to the viewport.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们之前已经使用了添加按钮，那么 `Ext.getCmp` 将返回一个有效的组件。这就是我们在第二行检查 `!Ext.isDefined(sheet)`
    的内容。如果表单尚未定义（尚未创建），我们使用 `Ext.create('MyApp.view.AddSheet');` 来创建我们的表单，然后将其添加到视图中。
- en: At this point, we should have a valid component for our sheet and then we can
    just call `sheet.show();`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该有一个有效的表单组件，然后我们可以直接调用 `sheet.show();`。
- en: 'Our application should now be able to add and display new Feed items to the
    list. Test the application to make sure everything is in working order by using
    Safari to open the `app.html` file in the folder where your project is saved:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在应该能够添加并显示新的内容项到列表中。通过使用Safari打开保存项目文件夹中的 `app.html` 文件来测试应用程序，以确保一切正常工作：
- en: '![Back to the navigation view](img/8901OS_02_4.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![返回导航视图](img/8901OS_02_4.jpg)'
- en: Next we need to add the logic for our MainView navigation view that will allow
    us to display a nice layout page for each of our feeds.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为主视图导航视图添加逻辑，以便我们可以为每个内容源显示一个漂亮的布局页面。
- en: Adding the controller
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加控制器
- en: Add a controller to the project by dragging it onto the **Controllers** section
    of **Project Inspector**. You can find it in **Toolbox** under **Behaviors**.
    Set the **userClassName** property of the controller to `FeedController`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其拖放到**项目检查器**的**控制器**部分来向项目中添加一个控制器。您可以在**工具箱**下的**行为**中找到它。将控制器的 **userClassName**
    属性设置为 `FeedController`。
- en: We also want to add a **Reference** property in the controller for **mainView**.
    Click on the **Add** button next to **Reference** and set the **ref** property
    to **mainView** and **Selector** to **MainView** (the selector needs to match
    our **userAlias** instance for the main navigation view).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望在控制器中为**mainView**添加一个**Reference**属性。点击**Reference**旁边的**Add**按钮，将**ref**属性设置为**mainView**，并将**Selector**设置为**MainView**（选择器需要与主要导航视图的**userAlias**实例匹配）。
- en: Adding this reference will allow us to easily grab our MainView navigation by
    calling `this.getMainView()` anywhere inside the controller.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个引用将允许我们通过调用`this.getMainView()`在控制器内部任何地方轻松获取MainView导航。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Wait, shouldn''t it be getmainView instead of getMainView?**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**等等，它不应该写成getmainView而不是getMainView吗？**'
- en: One of the things that should be pointed out in this example is that when the
    reference is created, Sencha automatically creates a "getter" function for the
    referenced component. Even though our reference has a lowercase `m`, the `getMainView`
    function changes this to uppercase, `M`. Given the case sensitive nature of JavaScript,
    this automatic case switch can lead to quite a bit of hair pulling and colorful
    language.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中应该指出的一点是，当创建引用时，Sencha会自动为引用组件创建一个“getter”函数。尽管我们的引用有一个小写的`m`，但`getMainView`函数将其改为大写，`M`。鉴于JavaScript的大小写敏感性，这种自动的大小写转换可能会导致大量的烦恼和彩色语言。
- en: 'Now that we have our reference, we need to add an action to perform when the
    user taps on the list of feeds. Click on the **+** button next to **Actions**
    and set the following information:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了参考，我们需要添加一个在用户点击订阅列表时执行的操作。点击**Actions**旁边的**+**按钮，并设置以下信息：
- en: Set `controlQuery` to `#FeedList`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`controlQuery`设置为`#FeedList`
- en: Set `targetType` to `Ext.dataview.List`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`targetType`设置为`Ext.dataview.List`
- en: Set `fn` to `onListItemTap`
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`fn`设置为`onListItemTap`
- en: Set `name` to `itemtap`
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`name`设置为`itemtap`
- en: 'Next, we need to double-click on the **itemtap** action to bring up our code
    editor. This is the code that will be fired when the list is tapped. Notice that
    the function is already set up to pass us a number of useful items including the
    dataview itself and the record for the item the user tapped on. We will set this
    action to call another function like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要双击**itemtap**操作来打开我们的代码编辑器。这是当列表被点击时将触发的代码。注意，函数已经设置好，可以传递给我们一些有用的项目，包括数据视图本身和用户点击的项目记录。我们将设置此操作调用另一个函数，如下所示：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will pass along the record `name` and `url` to our new `createFeedDetailsView`
    function using `record.get()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用`record.get()`将记录`name`和`url`传递给新的`createFeedDetailsView`函数。
- en: 'If we take a look at our **Code** view for the controller, it should look something
    like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看控制器的**Code**视图，它应该看起来像这样：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we see that Sencha has set up our `FeedController` function to extend the
    main `Ext.app.Contoller` component. This means it inherits all of the basic functions
    for the `Ext.app.Contoller` component.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到Sencha已经设置了我们的`FeedController`函数，使其扩展主要的`Ext.app.Controller`组件。这意味着它继承了`Ext.app.Controller`组件的所有基本功能。
- en: In the `config` section, we see our reference set up in the `refs` section.
    The `controls` section tells the controller which component to listen to (`#FeedList`),
    which event to listen for (`itemtap`), and which function to call when the event
    happens (`onListItemTap`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config`部分，我们在`refs`部分看到了我们的引用设置。`controls`部分告诉控制器监听哪个组件（`#FeedList`），监听哪个事件（`itemtap`），以及当事件发生时调用哪个函数（`onListItemTap`）。
- en: The last thing we need to do here is create the code for our `createFeedDetailsView`
    function. This code needs to use the URL to grab the RSS feed, create a new view,
    and push it onto the main navigation view.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要做的最后一件事是为我们的`createFeedDetailsView`函数创建代码。这段代码需要使用URL获取RSS源，创建一个新的视图，并将其推送到主要导航视图。
- en: 'Before we do that, there are a few things that we need to consider: how do
    we get the data from the remote source and how can we format it in an easy-to-use
    structure (JSON)?'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行之前，有一些事情需要考虑：我们如何从远程源获取数据，以及我们如何将其格式化为易于使用的结构（JSON）？
- en: To answer these questions, we need to have a better understanding of how Sencha
    Touch communicates with external servers, and some of the limitations involved
    in these types of transactions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们需要更好地理解Sencha Touch如何与外部服务器通信，以及这些交易类型中涉及的一些限制。
- en: Getting the data from a remote source
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从远程源获取数据
- en: For security reasons, JavaScript (and thus Sencha Touch) is not allowed to make
    AJAX requests to other domains. This means that if your application resides on
    `myCoolApp.com` and you make an AJAX request to the RSS feed at [boingboing.net](http://boingboing.net),
    it will be denied.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因，JavaScript（以及因此Sencha Touch）不允许向其他域发起AJAX请求。这意味着如果您的应用程序位于`myCoolApp.com`，并且您向[boingboing.net](http://boingboing.net)的RSS源发起AJAX请求，它将被拒绝。
- en: The reason for this is the **Same Origin Policy**, which states that certain
    browser functions like cookies and AJAX requests can't be shared between different
    servers. The reasoning being that JavaScript executes within the browser on the
    end user's computer. This gives JavaScript some unique abilities to interact with
    the user without having to constantly be in contact with a web server. Once the
    web browser loads the initial JavaScript files, they are stored on the user's
    machine until the cache is cleared. This means the application can continue to
    function when offline.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为**同源策略**，它指出某些浏览器功能（如cookies和AJAX请求）不能在不同服务器之间共享。理由是JavaScript在用户计算机上的浏览器中执行。这赋予了JavaScript一些独特的与用户交互的能力，而无需始终与Web服务器保持联系。一旦Web浏览器加载了初始JavaScript文件，它们就会存储在用户的机器上，直到缓存被清除。这意味着应用程序可以在离线状态下继续运行。
- en: However, as we all know, with great power comes great responsibility. The ability
    to run remote code on a user's computer can lead to people doing very bad things.
    AJAX requests in particular are problematic because they can happen without any
    direct request from the user.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们所知，权力越大，责任越大。在用户的计算机上运行远程代码的能力可能导致人们做非常糟糕的事情。特别是AJAX请求，因为它们可以在没有任何直接用户请求的情况下发生。
- en: For this reason, cross-domain AJAX requests in JavaScript are a very bad idea.
    While it may be easy enough to determine that your own code has honorable intentions,
    unchecked code from another domain can be potentially hostile.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JavaScript中的跨域AJAX请求是一个非常糟糕的想法。虽然可能很容易确定自己的代码有正当意图，但来自另一个域的未经检查的代码可能具有潜在的恶意。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you would like to learn more about same origin policy, this Wikipedia article
    is a good place to start:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于同源策略的信息，这篇维基百科文章是一个很好的起点：
- en: '[http://en.wikipedia.org/wiki/Same_origin_policy](http://en.wikipedia.org/wiki/Same_origin_policy)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Same_origin_policy](http://en.wikipedia.org/wiki/Same_origin_policy)'
- en: Enter the JSONP proxy
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入JSONP代理
- en: 'We can get around the same origin policy by using Sencha''s JSONP proxy component
    to send the request. This component injects `<script>` tags containing the proxy
    URL directly into the DOM to get around the cross-domain limitation. The script
    tag looks like a regular JavaScript embed tag, something like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用Sencha的JSONP代理组件来绕过同源策略发送请求。该组件直接将包含代理URL的`<script>`标签注入DOM中，以绕过跨域限制。脚本标签看起来像常规的JavaScript嵌入标签，类似于这样：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The response gets included as if it were any other JavaScript include. The JSONP
    proxy uses the `callback` function (which is generated automatically) to process
    this data and send it back to the proxy. The one caveat here is that the response
    has to be in JSON in order for the `callback` function to correctly process it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 响应被包含，就像任何其他JavaScript包含一样。JSONP代理使用自动生成的`callback`函数来处理这些数据并将其发送回代理。这里的一个注意事项是，响应必须是JSON格式，以便`callback`函数能够正确处理它。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A full explanation of cross-site scripting issues can be found here: [http://en.wikipedia.org/wiki/Cross-site_scripting](http://en.wikipedia.org/wiki/Cross-site_scripting)
    and an overview of the JSONP proxy component can be found here: [http://docs.sencha.com/touch/2-0/#!/api/Ext.data.proxy.JsonP](http://docs.sencha.com/touch/2-0/#!/api/Ext.data.proxy.JsonP).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于跨站脚本问题的完整解释可以在这里找到：[http://en.wikipedia.org/wiki/Cross-site_scripting](http://en.wikipedia.org/wiki/Cross-site_scripting)，以及JSONP代理组件的概述可以在这里找到：[http://docs.sencha.com/touch/2-0/#!/api/Ext.data.proxy.JsonP](http://docs.sencha.com/touch/2-0/#!/api/Ext.data.proxy.JsonP)。
- en: 'This brings us to another issue that we will run into with RSS feeds: they
    are formatted in XML instead of JSON. Since we need the JSONP store for cross-site
    requests and a JSON-encoded response for our `callback` function to process, XML
    won''t work for us without a bit more fiddling.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了我们将在RSS源中遇到的其他问题：它们是以XML格式而不是JSON格式编写的。由于我们需要JSONP存储进行跨站请求，以及JSON编码的响应供`callback`函数处理，因此没有更多的调整，XML对我们来说将不起作用。
- en: This basically gives us two options. The first option would be to use another
    programming language to write something that would make the proxy request for
    us. This would include languages such as PHP, Ruby, ASP, and Perl, which run on
    the local server along with our application and are not under the same security
    restrictions as JavaScript.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上给我们提供了两个选项。第一个选项是使用另一种编程语言编写一些代码，以便为我们发出代理请求。这包括 PHP、Ruby、ASP 和 Perl 等语言，这些语言在本地服务器上与我们的应用程序一起运行，并且不受
    JavaScript 相同的安全限制。
- en: A local proxy would receive the request from our store along with the variables
    and make a request to the remote server with our variables. The remote server
    would then send the request back to our local proxy that would then pass it back
    to the store in whatever format we need. This is a fine enough way to accomplish
    the task, but it is also overkill for our simple application. Don't worry, we
    will get to the overkill later on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本地代理将从我们的存储中接收请求以及变量，然后使用我们的变量向远程服务器发出请求。然后远程服务器将请求发送回我们的本地代理，本地代理再将它以我们需要的任何格式传递回存储。这是一种足够好的完成任务的方式，但对于我们的简单应用程序来说可能有些过度。不用担心，我们稍后会讨论这个问题。
- en: We also have a second option called **YQL**, the **Yahoo** **Query** **Language**,
    which we will be using in our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为 **YQL** 的第二个选项，即 **Yahoo 查询语言**，我们将在应用程序中使用它。
- en: Yahoo Query Language (YQL)
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Yahoo 查询语言 (YQL)
- en: The **Yahoo Query Language** (**YQL**) was developed as a way to search open
    data sources in a language similar to **Structured Query Language** (**SQL**),
    a standard language for dealing with database information.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**Yahoo 查询语言**（**YQL**）是为了以类似于 **结构化查询语言**（**SQL**）的语言搜索公开数据源而开发的，SQL 是处理数据库信息的一种标准语言。'
- en: 'A typical SQL request might look something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 SQL 请求可能看起来像这样：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This would grab all the records in the `users` table where the last name was
    `Scalzi`. The `*` character tells our query to grab all the data for the record.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取 `users` 表中姓氏为 `Scalzi` 的所有记录。`*` 字符告诉我们的查询获取该记录的所有数据。
- en: 'A YQL request is similar in structure and might look something like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 YQL 请求的结构类似，可能看起来像这样：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This request would return the RSS feed data from [boingboing.net](http://boingboing.net).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求将返回来自 [boingboing.net](http://boingboing.net) 的 RSS 源数据。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'YQL has access to a tremendous number of open data sources. To read up on the
    sources and get a better idea of what is possible in YQL, go to: [http://developer.yahoo.com/yql/](http://developer.yahoo.com/yql/).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: YQL 可以访问大量的公开数据源。要了解这些数据源并更好地了解 YQL 的可能性，请访问：[http://developer.yahoo.com/yql/](http://developer.yahoo.com/yql/)。
- en: Now that we can get information from our data source, we need to figure out
    how to have it sent in a format our Sencha Touch application can understand.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以从数据源获取信息，我们需要弄清楚如何以我们的 Sencha Touch 应用程序能够理解的方式发送它。
- en: One of the bonuses we get with YQL is that our results can be set up to return
    in a number of different formats, including the JSON format we want for our application.
    Before we set up the YQL query for our application we should take a look at the
    actual JSON that gets returned from the query. We can do this using the YQL console.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: YQL 带来的一个额外好处是，我们的结果可以设置为以多种不同的格式返回，包括我们应用程序需要的 JSON 格式。在我们为应用程序设置 YQL 查询之前，我们应该查看查询返回的实际
    JSON。我们可以使用 YQL 控制台来完成这个操作。
- en: The YQL console
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: YQL 控制台
- en: 'The YQL console (located at: [http://developer.yahoo.com/yql/console/](http://developer.yahoo.com/yql/console/))
    offers an easy way to test the various YQL commands and immediately see the results:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: YQL 控制台（位于：[http://developer.yahoo.com/yql/console/](http://developer.yahoo.com/yql/console/））提供了一个简单的方式来测试各种
    YQL 命令，并立即看到结果：
- en: '![The YQL console](img/8901OS_02_5.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![YQL 控制台](img/8901OS_02_5.jpg)'
- en: Enter the the query shown in the previous screenshot into the console, select
    JSON, and click on the **TEST** button.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前截图中的查询输入到控制台，选择 JSON，然后点击 **TEST** 按钮。
- en: 'You will get back the results as a large bundle of JSON starting with:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个以以下内容开始的 JSON 大包作为回应：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `cbfunc` header is the callback function our JSONP store is going to use
    to process the response. We don't need to worry about this since the store deals
    with it automatically. The first piece of information we need is the `count` parameter
    listed inside the `query` array. We can reference this in our code as `query.count`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`cbfunc` 头是 JSONP 存储将要使用的回调函数来处理响应。我们不需要担心这个问题，因为存储会自动处理它。我们需要的第一条信息是 `query`
    数组中列出的 `count` 参数。我们可以在代码中引用它为 `query.count`。'
- en: 'Further down in the results you will see the actual items we need to use for
    our dataview:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果下方，您将看到我们需要用于dataview的实际项目：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since these results are nested down in the `query` array, we will need to tell
    the store to set our `rootProperty` property as `query.results.item`. This `item`
    array holds the 30 listings returned by our query.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些结果嵌套在`query`数组中，我们需要告诉存储将我们的`rootProperty`属性设置为`query.results.item`。这个`item`数组包含了我们的查询返回的30个列表。
- en: When these items are part of the store we will have access to each of the individual
    pieces by name. For example, `title` from the previous code will give us `Minecraft
    heads to consoles` and `creator.content` will give us `Rob Beschizza`. All of
    this data will be accessible in the item template of our dataview.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些项目成为存储的一部分时，我们将可以通过名称访问每个单独的项目。例如，从之前的代码中的`title`将给我们`Minecraft heads to
    consoles`，而`creator.content`将给我们`Rob Beschizza`。所有这些数据都将可在我们的dataview项目模板中访问。
- en: 'You will need to set up a data model to grab the pieces of information you
    are interested in. For our purposes, we will be using the following data model:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要设置一个数据模型来获取您感兴趣的信息片段。对于我们的目的，我们将使用以下数据模型：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that we need to map some of the more deeply nested items such as `encoded.content`
    and `creator.content`. This model will give us all of the data items we need for
    our view.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要映射一些更深层次的项，例如`encoded.content`和`creator.content`。这个模型将为我们提供我们视图所需的所有数据项。
- en: Let's see how it all fits together.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这一切是如何结合在一起的。
- en: Meanwhile, back at the controller
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时，回到控制器
- en: 'If you remember, back in our `FeedController` function we had a tap handler
    that looked like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，在我们的`FeedController`函数中，我们有一个看起来像这样的触摸处理程序：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We now need to set up the `createFeedDetailsView` function and get it to create
    our data store for connecting to the YQL server.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要设置`createFeedDetailsView`函数，并使其创建我们的数据存储以连接到YQL服务器。
- en: 'Add the new function by clicking on the **+** button next to **functions**
    and setting the **Config** value for **fn** to `createFeedDetailsView`. Then add
    two **params**: `name` and `url`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**functions**旁边的**+**按钮，并设置**fn**的**Config**值为`createFeedDetailsView`来添加新函数。然后添加两个**params**：`name`和`url`。
- en: In the code editor, we want our function to grab the name and URL that we passed
    from our tap function and create a new data store. We will then load the store
    and use it to feed data into a new dataview. Lastly, we will push this new dataview
    onto our main navigation view for display.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码编辑器中，我们希望我们的函数能够抓取从我们的触摸函数传递过来的名称和URL，并创建一个新的数据存储。然后我们将加载存储，并使用它向新的dataview提供数据。最后，我们将这个新的dataview推送到我们的主导航视图中进行显示。
- en: 'The code looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像这样：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our first line sets up our URL to the main connection point for the YQL server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一行设置我们的URL为主连接点：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then set up our variables using the format required by YQL. This includes
    a query string (`q`) and a format type for the return value, which will be JSON:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用YQL所需的格式设置我们的变量。这包括一个查询字符串（`q`）和返回值的格式类型，它将是JSON：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we convert our variables into a Query String and add them to our URL
    like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的变量转换为查询字符串，并将其添加到我们的URL中，如下所示：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need to add a new dataview to our main navigation view. We will create
    the actual view in the next section, but for now we can in put the code to display
    it here like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的主导航视图中添加一个新的dataview。我们将在下一节创建实际视图，但在此期间，我们可以像这样输入代码来显示它：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This creates the `details` view using `MyApp.view.FeedDetails` (a view we will
    add a bit later) and set up the store for it with our `newURL` string that we
    created at the beginning of the function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`MyApp.view.FeedDetails`（我们稍后会添加的视图）创建`details`视图，并使用我们在函数开头创建的`newURL`字符串设置其存储。
- en: Our `reader` configuration is set for `json` and the `rootProperty` and `totalProperty`
    configurations are set to the default values that get returned from the YQL server
    for each of those attributes. `rootProperty` tells the reader where to start looking
    for results and `totalProperty` tells the reader how many results we have gotten.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`reader`配置设置为`json`，而`rootProperty`和`totalProperty`配置设置为YQL服务器为每个属性返回的默认值。`rootProperty`告诉读取器在哪里开始查找结果，而`totalProperty`告诉读取器我们获得了多少结果。
- en: 'Finally, we load our store and add the new dataview to our main navigation
    panel:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们加载我们的存储并将新的dataview添加到我们的主导航面板中：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have the store code in place, it's time to create the dataview for
    `MyApp.view.FeedDetails`, which is needed to display the feed data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了存储代码，是时候为 `MyApp.view.FeedDetails` 创建数据视图了，这是显示源数据所需的。
- en: The details dataview
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详情数据视图
- en: When using Sencha Touch, it's very easy to think of a dataview as just a fancy
    list. However, that tends to lock people into the list aspects of the dataview
    while ignoring the possibility of more complex layouts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Sencha Touch 时，很容易将数据视图视为一个花哨的列表。然而，这往往会让人们陷入数据视图的列表方面，而忽略了更复杂布局的可能性。
- en: 'For example, a newspaper-style layout is a great use of a dataview. The layout
    is a collection of articles with titles, dates, authors, and content. However
    it sidesteps the standard concept of a list and replaces it with a more visually
    interesting layout:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，报纸风格的布局非常适合使用数据视图。布局是一系列包含标题、日期、作者和内容的文章集合。然而，它避开了列表的标准概念，并使用更直观的布局来代替：
- en: '![The details dataview](img/8901OS_02_6.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![详情数据视图](img/8901OS_02_6.jpg)'
- en: A newspaper-style layout works well on a larger tablet-sized screen, but it
    would be difficult to read on a smaller phone screen. We need a way to change
    the layout of our application based on the user's device.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 报纸风格的布局在大尺寸平板屏幕上效果很好，但在小尺寸手机屏幕上阅读起来会很困难。我们需要一种根据用户设备更改应用程序布局的方法。
- en: Fortunately for us, not only does Sencha Touch understand the difference between
    devices, it also leverages the power of the HTML5 standard, which also understands
    different platforms and devices.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Sencha Touch 不仅理解设备之间的差异，还利用了 HTML5 标准的强大功能，该标准也理解不同的平台和设备。
- en: We will cover how Sencha Touch manages the different devices in a later chapter.
    For now, we are going to use CSS media queries to load different style sheets
    based on the device. Before we get too deeply into that, we need to create the
    dataview and the XTemplate.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中介绍 Sencha Touch 如何管理不同的设备。现在，我们将使用 CSS 媒体查询根据设备加载不同的样式表。在我们深入探讨这个话题之前，我们需要创建数据视图和
    XTemplate。
- en: An **XTemplate** is basically an HTML template with a few extra bells and whistles.
    The XTemplate takes the data you supply and uses it to fill out the template by
    substituting any value in curly braces, with the corresponding value from your
    data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**XTemplate** 实际上是一个带有一些额外功能的 HTML 模板。XTemplate 接收你提供的数据，并使用它通过替换花括号中的任何值来填充模板，以匹配数据中的相应值。'
- en: 'For example, suppose that you have an XTemplate that looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个看起来像这样的 XTemplate：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, the XTemplate will search your data for a variable called `name`
    and insert it into the template where we have `{name}`. You can use these curly
    braces to reference any of the fields in a data record.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，XTemplate 将在数据中搜索一个名为 `name` 的变量，并将其插入到 `{name}` 的模板位置。你可以使用这些花括号来引用数据记录中的任何字段。
- en: The XTemplate also offers us the opportunity to add logic (the "if...then" statements,
    simple math, and more) to the HTML template.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: XTemplate 还为我们提供了在 HTML 模板中添加逻辑（如 "if...then" 语句、简单数学等）的机会。
- en: Let's create one for our dataview to see how it all fits together.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的数据视图创建一个，看看它是如何组合在一起的。
- en: Create a new dataview in Sencha Architect and set `userAlias` to `feeddetails`
    and `userClassName` to `FeedDetails`. Set the store configuration to use our `FeedItemStore`
    we created earlier.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sencha Architect 中创建一个新的数据视图，并将 `userAlias` 设置为 `feeddetails`，将 `userClassName`
    设置为 `FeedDetails`。将存储配置设置为使用我们之前创建的 `FeedItemStore`。
- en: Next we need to create an `itemTpl` XTemplate. You should see a listing for
    **itemTpl** underneath the new **FeedDetails** dataview in the **Project Inspector**
    and if you select it, the **Code** editor will show the default **itemTpl** for
    editing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个 `itemTpl` XTemplate。你应该在 **Project Inspector** 下的新 **FeedDetails**
    数据视图下看到 **itemTpl** 的列表，如果你选择它，**Code** 编辑器将显示默认的 **itemTpl** 以供编辑。
- en: Our `itemTpl` will need to account for any missing data in the RSS feed (RSS
    feeds are often missing things such as descriptions, icons, and other elements).
    We also need to translate the dates into something Sencha Touch understands, and
    we need to loop through some of the nested array elements returned by our YQL
    request.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `itemTpl` 需要考虑 RSS 源中可能缺失的数据（RSS 源通常缺少描述、图标和其他元素）。我们还需要将日期转换为 Sencha Touch
    能够理解的形式，并且需要遍历 YQL 请求返回的一些嵌套数组元素。
- en: 'Let''s look at the full template first, and then we will go through the different
    sections to cover what we are doing:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看完整的模板，然后我们将逐一介绍不同的部分，以了解我们在做什么：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our first section looks to see if we have a thumbnail for the article using
    `<tpl if="thumbnail">`. If we do, then we style the article container with a class
    of `hasThumbnail`, if not, we just use the basic `<article>` tag. This will let
    us do different things with CSS depending on if we have the thumbnail or not.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一部分是检查是否有文章的缩略图，使用`<tpl if="thumbnail">`。如果有，我们就用`hasThumbnail`类来样式化文章容器，如果没有，我们就只用基本的`<article>`标签。这样我们就可以根据是否有缩略图使用CSS做不同的处理。
- en: Next we begin constructing our header section, creating a `<div>` tag with a
    class of `headline` that contains our `thumbnail` and `title` variables for the
    article. We also check to see if we have a `thumbnail` and then loop through the
    data for thumbnails (using `<tpl for="thumbnail">`) to gain access to the individual
    elements (`height`, `width`, `url`) in the `thumbnail` array.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始构建我们的页眉部分，创建一个包含文章的`thumbnail`和`title`变量的`<div>`标签，并具有`headline`类。我们还检查是否有`thumbnail`，然后通过`<tpl
    for="thumbnail">`遍历缩略图数据，以访问`thumbnail`数组中的单个元素（`height`、`width`、`url`）。
- en: Next, we close out the headline `div` tag and add our author/creator and the
    date to our template. RSS feeds can use either author or creator to refer to the
    person who wrote the article. We use `<tpl if="creator">` and `<tpl elseif="author">`
    to make sure we get one or the other if they are available.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们关闭标题`div`标签，并将作者/创建者和日期添加到模板中。RSS源可以使用作者或创建者来指代撰写文章的人。我们使用`<tpl if="creator">`和`<tpl
    elseif="author">`来确保如果它们可用，我们得到其中一个。
- en: 'We then check to see if we have a date and convert it to a format we like using:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查是否有日期，并将其转换为我们喜欢的格式：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that we have also wrapped the date inside an HTML5 `<time>` element,
    which provides contextual data to the browser, allowing features such as localization,
    visual timelines, and adding events to calendars. We set `datetime` to a format
    the browser understands, and then we set the displayed date and time to something
    a bit more user friendly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在HTML5 `<time>` 元素内部包装了日期，这为浏览器提供了上下文数据，允许使用本地化、视觉时间线以及将事件添加到日历等特性。我们将`datetime`设置为浏览器能理解的格式，然后我们将显示的日期和时间设置为更符合用户习惯的形式。
- en: Next we format our description and content. The description is pretty straight
    forward, but the content is a slightly different matter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们格式化描述和内容。描述相当直接，但内容则稍微复杂一些。
- en: Depending on the size of the device, we may not want to show the full content
    div, just the shorter description div. We can set our CSS to only show the `<div
    class="description">` or the `<div class="content">` block, depending on the device.
    However, the content element is also optional, so if we have no content we need
    to show the description in the `<div class="content">` block instead.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设备的尺寸，我们可能不想显示完整的内容div，而只想显示较短的描述div。我们可以设置CSS只显示`<div class="description">`或`<div
    class="content">`块，具体取决于设备。然而，内容元素是可选的，所以如果没有内容，我们需要在`<div class="content">`块中显示描述。
- en: 'To make things more complicated, the content returned by our YQL query is a
    nested array with two elements: a content definition link, which we can ignore,
    and the actual content that we want. To do this, we loop through the content and
    count the loops using the built-in `xindex` variable to add the second data element
    to our XTemplate (`{.}` is the current data element in the loop).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更复杂，我们YQL查询返回的内容是一个包含两个元素的嵌套数组：一个内容定义链接，我们可以忽略它，以及我们想要的实际内容。为此，我们遍历内容并使用内置的`xindex`变量来计数循环，将第二个数据元素添加到我们的XTemplate中（`{.}`是循环中的当前数据元素）。
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally we close out our XTemplate with a footer and a link to the original
    article.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用页脚和指向原始文章的链接来关闭我们的XTemplate。
- en: 'We will take a look at some other XTemplate options in later chapters, or you
    can see a full list of the options in the online documentation at:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中查看一些其他的XTemplate选项，或者您可以在在线文档中查看完整的选项列表：
- en: '[http://docs.sencha.com/touch/2-0/#!/api/Ext.XTemplate](http://docs.sencha.com/touch/2-0/#!/api/Ext.XTemplate)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.sencha.com/touch/2-0/#!/api/Ext.XTemplate](http://docs.sencha.com/touch/2-0/#!/api/Ext.XTemplate)'
- en: And now, the CSS
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在，是CSS的时间了
- en: As our container currently exists, the display would not be very interesting.
    It's just simple blocks of data one after another. While this is fine for small
    devices such as phones, it's a bit dull for larger tablet displays.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的容器目前存在，显示不会很有趣。它只是简单的数据块一个接一个。虽然这对小设备如手机来说是可以的，但对于更大的平板显示器来说则有点单调。
- en: 'We are going to address this by creating these three separate CSS files:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建这三个单独的CSS文件来解决这个问题：
- en: '`feedbag.css`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feedbag.css`'
- en: '`feedbag-tablet-portrait.css`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feedbag-tablet-portrait.css`'
- en: '`feedback-tablet-landscape.css`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feedback-tablet-landscape.css`'
- en: 'We will link these files in our `app.html` file like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`app.html`文件中这样链接这些文件：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first file, `feedbag.css`, contains all of our default styles for colors,
    font sizes, and so on. It also contains the small phone screen styles, which only
    show our image and header in the list view.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件，`feedbag.css`，包含我们所有的默认样式，如颜色、字体大小等。它还包含小手机屏幕样式，在列表视图中只显示我们的图片和标题。
- en: 'This set of styles gets overridden by the next file, which contains our portrait
    styles for tablet computers (minimum device width: 700 px). This file uses the
    same styles from the previous file, but organizes our content into two columns
    of blocks. It also displays the description block in the list view.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这组样式被下一个文件覆盖，该文件包含平板电脑的肖像样式（最小设备宽度：700像素）。此文件使用与上一个文件相同的样式，但将我们的内容组织成两列的块。它还在列表视图中显示描述块。
- en: The last file is used for tablet devices in landscape orientation. As before,
    it will override some of the styles in the previous files to further enhance the
    layout. In this case, we will float all of the blocks and set them to different
    widths to give the layout a more organic feel.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个文件用于横向排列的平板设备。与之前一样，它将覆盖前几个文件中的某些样式以进一步增强布局。在这种情况下，我们将所有块浮动并设置不同的宽度，以给布局带来更自然的感受。
- en: Rather than dig through the entire CSS file, we want to focus on the last file,
    as it is the most complex of the files—`feedback-tablet-landscape.css`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想翻遍整个CSS文件，而是想专注于最后一个文件，因为它是文件中最复杂的——`feedback-tablet-landscape.css`。
- en: 'In this CSS file, we will take a series of steps to get to this layout, starting
    from a grid of 12 items and modifying the widths and heights to give us a more
    fluid layout. Take a look at the following figure to see what we mean:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个CSS文件中，我们将采取一系列步骤来实现这个布局，从12项的网格开始，修改宽度和高度以给我们一个更流畅的布局。看看下面的图，以了解我们的意思：
- en: '![And now, the CSS](img/8901OS_02_7.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![现在，这是CSS](img/8901OS_02_7.jpg)'
- en: 'In `feedback-tablet-landscape.css` our first block of CSS looks like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`feedback-tablet-landscape.css`中，我们的第一个CSS块看起来像这样：
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can fit three blocks of content across the screen in landscape mode, so we
    set each item to a default width of 33 percent.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在横向模式下，我们可以在屏幕上放置三个内容块，因此我们将每个项目设置为默认宽度33%。
- en: 'The next block of CSS uses the nth-of-type selector to change the sizes of
    some of our item blocks:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个CSS块使用nth-of-type选择器来改变一些项目块的大小：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This rather complicated looking CSS says the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来相当复杂的CSS实际上是这样说的：
- en: We are only looking at items tagged with `div.x-dataview-item` (which are our
    item blocks).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只查看带有`div.x-dataview-item`标签的项（这些是我们的项目块）。
- en: We want `nth-of-type(12n+2)`, which in this case means that we are looking at
    everything in blocks of 12 items (`12n`). Of those 12 items, we want to apply
    this style to the second (`+2`) of those items.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要`nth-of-type(12n+2)`，在这种情况下意味着我们在查看12项的块（`12n`）。在这12项中，我们想要将此样式应用于第二项（`+2`）。
- en: We also want to do the same thing for the 8th member of our set of twelve (`nth-of-type(12n+8)`).
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还想要对十二个成员中的第八个成员（`nth-of-type(12n+8)`）做同样的事情。
- en: For our two items, we want to set the width to 66 percent (twice our normal
    article width).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的两个项目，我们想要将宽度设置为66%（是我们正常文章宽度的两倍）。
- en: By dealing with these items in blocks of 12 we end up with a more random and
    natural feel to our layout, rather than if we had simply set every third item
    to a wider size.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以12项的块处理这些项目，我们使我们的布局看起来更加随机和自然，而不是如果我们简单地将每个第三个项目设置为更宽的尺寸。
- en: 'The next two styles ensure that we don''t end up with one or two items dangling
    off the end of our layout. First we give our last item in the list a width of
    99 percent:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个样式确保我们不会在布局的末尾留下一个或两个项目。首先，我们给列表中的最后一个项目一个99%的宽度：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, if our last item is the last in a row of three, we don''t want it
    to have a 99 percent width as this would push it down a row and make things look
    weird. It should just be the regular size (33 percent):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们的最后一个项目是三行中的最后一个，我们不希望它有99%的宽度，因为这会将它推到下一行，使事物看起来很奇怪。它应该只是常规大小（33%）：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `12n+7` (the seventh item and the twelfth) items are the only two items
    in our set of twelve that may end up as the last item in a row of three.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`12n+7`（第七项和第十二项）是我们12项集中可能成为三行最后一项的唯一两个项目。'
- en: Tip
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We use `!important` in our CSS to make sure that our `width` definition overrides
    any other `width` values that might be applied by other (parent) classes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在CSS中使用 `!important` 来确保我们的 `width` 定义覆盖了其他（父）类可能应用的任何其他 `width` 值。
- en: 'We also don''t want it to be 99 percent if it''s the last item in a row with
    only two items. In this case, the last item just needs to have a width of 66 percent:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不希望它是99%，如果它是只有两个项目的行中的最后一个项目。在这种情况下，最后一个项目只需要66%的宽度：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, just to give us a break in the vertical rhythm of the layout, we make
    the first item in the set of 12 be twice as tall as the rest:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在布局的垂直节奏中给我们一个休息，我们将12个项目集中的第一个项目的高度设置为其他项目的两倍：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: While these types of CSS selectors can seem a bit daunting at first, they offer
    a wide range of layout options beyond the standard Sencha Touch options.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些类型的CSS选择器一开始可能看起来有些令人畏惧，但它们提供了比标准Sencha Touch选项更广泛的布局选项。
- en: If you look at the other two style sheets, you'll see that the styles get much
    simpler. The `feedbag-tablet-portrait.css` file is a simple two-column layout,
    while the plain `feedbag.css` file is a one-column layout with description content
    blocks hidden, for small devices such as iPhones. It would be possible to further
    customize the layouts based on device, or screen pixel density, but we'll leave
    that as an exercise for you.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看其他两个样式表，你会发现样式变得更加简单。`feedbag-tablet-portrait.css` 文件是一个简单的两列布局，而普通的 `feedbag.css`
    文件是一个单列布局，描述内容块被隐藏，适用于像iPhone这样的小设备。根据设备或屏幕像素密度进一步自定义布局是可能的，但我们将其留作你的练习。
- en: Homework
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: In the support files for this chapter, we have also added a details view called
    `FeedItem.js`, which is a simple panel that is called from the controller when
    an item in our dataview is clicked on. The panel is pushed onto the navigation
    view in the same way as our feed details view. The panel contains a simple XTemplate
    loaded from the record passed in the tap function. If you explore this code, you
    will also see that we added a bit of animation to make the transition slicker.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的支持文件中，我们还添加了一个名为 `FeedItem.js` 的详情视图，这是一个简单的面板，当我们的dataview中的项目被点击时由控制器调用。面板以与我们的feed详情视图相同的方式推送到导航视图中。面板包含一个从传递给tap函数的记录加载的简单XTemplate。如果你探索这段代码，你也会看到我们添加了一些动画来使过渡更加流畅。
- en: This type of application can easily be modified to serve as a mobile version
    for any website with an RSS feed. You can also use the additional data in the
    RSS feed to add more information to the display, or modify the look and feel through
    CSS.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的应用程序可以很容易地修改为任何具有RSS源网站的移动版本。你还可以使用RSS源中的附加数据来添加更多显示信息，或通过CSS修改外观和感觉。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter we discussed:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了：
- en: The basic application setup for the Feed Reader application
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Feed Reader应用程序的基本应用设置
- en: Creating data to use a remote data source
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据以使用远程数据源
- en: Potential issues with making Ajax requests to a remote server
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向远程服务器发送Ajax请求可能存在的问题
- en: Using the YQL system to query data from the web and return it as JSON
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用YQL系统从网络查询数据并将其作为JSON返回
- en: Setting up a complex XTemplate for our dataview
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的dataview设置一个复杂的XTemplate
- en: Using CSS styles and selectors to create a visually interesting and adaptable
    dataview display
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS样式和选择器创建一个视觉上有趣且可适应的dataview显示
- en: In the next chapter we will take a look at using a compiled Sencha Touch application
    to take advantage of features that are beyond a standard web based application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用编译后的Sencha Touch应用程序来利用超出标准基于Web应用程序的功能。
