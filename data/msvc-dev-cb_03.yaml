- en: Inter-service Communication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式服务通信
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Service-to-service communication
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务间通信
- en: Making concurrent asynchronous requests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作并发异步请求
- en: Finding services using service discovery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务发现查找服务
- en: Server-side load balancing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端负载均衡
- en: Client-side load balancing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端负载均衡
- en: Building event-driven microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建事件驱动的微服务
- en: Evolving APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API演进
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapters, we've covered how to begin breaking a monolithic codebase
    into microservices, as well as best practices for exposing your microservices
    to the public internet. So far, we've assumed that all of our microservices are
    standalone applications that have no dependencies. These simple microservices
    receive requests, retrieve data or write to a database, and return a response
    to clients. This kind of linear workflow is rare in real-world systems. In a real-world
    microservice architecture, services will frequently need to invoke other services
    in order to fulfill a user's request. A typical user request will commonly create
    dozens of requests to services in your system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经介绍了如何开始将单体代码库拆分成微服务，以及将你的微服务公开到公共互联网的最佳实践。到目前为止，我们假设所有的微服务都是没有依赖的独立应用程序。这些简单的微服务接收请求，检索数据或写入数据库，并向客户端返回响应。这种线性工作流程在现实世界的系统中很少见。在现实世界的微服务架构中，服务将经常需要调用其他服务以满足用户请求。典型的用户请求通常会在你的系统中创建数十个对服务的请求。
- en: Managing the communication between services presents a number of challenges.
    Before a service can speak to another service, it will need to locate it through
    some kind of service-discovery mechanism. When generating requests to a downstream
    service, we also need a way to distribute traffic across the various instances
    of the service that minimizes latency and distributes the load evenly without
    compromising data integrity. We’ll need to consider how to handle service failures
    and prevent them from cascading throughout our system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 管理服务间的通信带来了一系列挑战。在服务能够与其他服务通信之前，它需要通过某种服务发现机制来定位它。在生成对下游服务的请求时，我们还需要一种方法来在服务的各个实例之间分配流量，以最小化延迟并均匀分配负载，同时不损害数据完整性。我们需要考虑如何处理服务故障并防止它们在我们的系统中级联。
- en: Sometimes a service will need to communicate with other services asynchronously,
    in these cases, we can use event-driven architectural patterns to create reactive
    workflows. Breaking our system up into multiple services also means that different
    services will evolve their APIs independently, so we'll need ways to handle changes
    that won't break upstream services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有时一个服务需要异步地与其他服务通信，在这些情况下，我们可以使用事件驱动的架构模式来创建反应式工作流程。将我们的系统拆分成多个服务也意味着不同的服务将独立地演进它们的API，因此我们需要处理变化的方法，以确保不会破坏上游服务。
- en: In this chapter, we'll discuss recipes designed to address each of these challenges.
    By the end of this chapter, you'll be able to confidently handle the various kinds
    of interactions we're bound to require in a microservice architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论旨在解决这些挑战的食谱。到本章结束时，你将能够自信地处理在微服务架构中我们必然会需要的各种交互。
- en: Service-to-service communication
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务间通信
- en: 'In large-scale systems, problems arise less often in services themselves and
    more often in the communication between services. For this reason, we need to
    carefully consider all of the various challenges in service-to-service communication.
    When discussing service-to-service communication, it''s useful to visualize the
    flow of information in our system. Data flows in both directions–from the client
    (upstream) to the database, or event bus (downstream) in the form of requests,
    and back again in the form of responses. When we refer to upstream services, we
    are describing components of the system that are closer to the user in the flow
    of information. When we refer to downstream services, we are describing components
    of the system that are further away from the user–in other words, the user makes
    a request that is routed to a service that then makes requests to other, downstream
    services, as shown in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模系统中，问题很少出现在服务本身，而更多出现在服务之间的通信中。因此，我们需要仔细考虑服务之间通信的所有各种挑战。在讨论服务之间通信时，可视化我们系统中信息流是有用的。数据在两个方向上流动——从客户端（上游）到数据库或事件总线（下游），以请求的形式，并以响应的形式返回。当我们提到上游服务时，我们是在描述系统中信息流中更靠近用户的部分。当我们提到下游服务时，我们是在描述系统中离用户更远的部分——换句话说，用户发起一个请求，该请求被路由到服务，然后该服务向其他下游服务发送请求，如以下图所示：
- en: '![](img/e9d1a309-4a6c-40b9-b1f9-fb29a57213ea.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9d1a309-4a6c-40b9-b1f9-fb29a57213ea.png)'
- en: In the preceding diagram, the originating **User** is upstream from the **edge-proxy-service**,
    which is upstream from the **auth-service**, **attachment-service**, and **user-service**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，原始的 **User** 位于 **edge-proxy-service** 的上游，**edge-proxy-service** 位于
    **auth-service**、**attachment-service** 和 **user-service** 的上游。
- en: 'In order to demonstrate the service-to-service communication, we’ll create
    a simple service that calls another service synchronously using the Spring Boot
    Java framework. Keeping with the example of our fictional messaging application,
    we’ll create a message service that is responsible for sending messages. The message
    service has to invoke the social graph service in order to determine whether the
    sender and recipient of a message are friends before allowing a message to be
    sent. The following simplified diagram illustrates the relationship between services:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示服务之间的通信，我们将创建一个简单的服务，该服务使用 Spring Boot Java 框架同步调用另一个服务。遵循我们虚构的消息应用示例，我们将创建一个负责发送消息的消息服务。消息服务必须调用社交图服务，以确定消息的发送者和接收者是否是朋友，然后才允许发送消息。以下简化图展示了服务之间的关系：
- en: '![](img/f59246e5-43de-47fb-a0ec-04597a6befe0.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f59246e5-43de-47fb-a0ec-04597a6befe0.png)'
- en: As you can see, a **POST** request comes in from the user to the **/message**
    endpoint, which is routed to **message-service**. The **message-service** service
    then makes an HTTP **GET** request to the **social-service** service using the
    **/friendships/:id** endpoint. The **social-service** service returns a JSON representation
    of friendships for a user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，用户从 **/message** 端点发送一个 **POST** 请求到 **message-service**。然后，**message-service**
    服务使用 **/friendships/:id** 端点向 **social-service** 服务发送一个 HTTP **GET** 请求。**social-service**
    服务返回一个表示用户友谊的 JSON。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a new Java/Gradle project called `message-service` and add the following
    content to the `build.gradle` file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `message-service` 的新 Java/Gradle 项目，并将以下内容添加到 `build.gradle` 文件中：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new package called `com.packtpub.microservices.ch03.message` and a
    new class called `Application`. This will be our service''s entry point:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `com.packtpub.microservices.ch03.message` 的新包和一个名为 `Application` 的新类。这将是我们的服务入口点：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the model. Create a package called `com.packtpub.microservices.ch03.message.models`
    and a class called `Message`. This is the internal representation of the message.
    There''s a lot missing here. We''re not actually persisting the message in this
    code, as it''s best to keep this example simple:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模型。创建一个名为 `com.packtpub.microservices.ch03.message.models` 的包和一个名为 `Message`
    的类。这是消息的内部表示。这里缺少很多内容。我们实际上没有在这个代码中持久化消息，因为最好保持这个示例简单：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a new package called `com.packtpub.microservices.ch03.message.controllers`
    and a new class called `MessageController`. At the moment, our controller doesn''t
    do much except accept the request, parse the JSON, and return the message instance,
    as you can see from this code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `com.packtpub.microservices.ch03.message.controllers` 的新包和一个名为 `MessageController`
    的新类。目前，我们的控制器除了接受请求、解析 JSON 并返回消息实例之外，没有做太多事情，正如您可以从以下代码中看到的那样：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Test this basic service by running it and trying to send a simple request:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行它并尝试发送一个简单的请求来测试这个基本服务：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Take a look at the following command line:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下命令行：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have a basic service working, but it''s pretty dumb and not doing much.
    We won''t go into persistence in this chapter, but let''s add some intelligence
    by checking with the social service to verify that our two users have a friendship
    before allowing the message to be sent. For the purposes of our example, imagine
    we have a working social service that allows us to check for relationships between
    users with requests, like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基本的服务正在运行，但它相当愚蠢，没有做太多。我们不会在本章中讨论持久性，但让我们通过检查社交服务来验证我们的两个用户之间是否有友谊，从而增加一些智能，在允许发送消息之前。为了我们的示例，假设我们有一个可以让我们通过请求检查用户之间关系的有效社交服务，如下所示：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before we can consume this service, let''s create a model to store its response.
    In the `com.packtpub.microservices.ch03.message.models` package, create a class
    called `UserFriendships`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够消费此服务之前，让我们创建一个模型来存储其响应。在 `com.packtpub.microservices.ch03.message.models`
    包中，创建一个名为 `UserFriendships` 的类：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Modify `MessageController`, adding a method to get a list of friendships for
    a user, optionally filtering by a username. Note that we''re hardcoding the URL
    in this example, which is a bad practice. We''ll discuss alternatives to this
    in the next recipe. Take a look at the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `MessageController`，添加一个方法来获取一个用户的友谊列表，可选地按用户名过滤。请注意，在这个例子中，我们硬编码了 URL，这是一个坏习惯。我们将在下一个配方中讨论这个问题的替代方案。查看以下代码：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Modify the `create` method we wrote earlier. If the users are friends, we''ll
    continue and return the message as before; if the users are not friends, the service
    will respond with a `403` indicating that the request is forbidden:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改我们之前编写的 `create` 方法。如果用户是朋友，我们将继续并像以前一样返回消息；如果用户不是朋友，服务将响应 `403`，表示请求被禁止：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Asynchronous requests
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步请求
- en: In the previous recipe, we were making a single service invocation per request,
    from the message service to the social service. This has the benefit of being
    incredibly simple to implement and, when using single-threaded languages, such
    as Python, Ruby, or JavaScript, is often the only choice. Performing a network
    call synchronously in this manner is acceptable when you're only doing it once
    per request–it doesn't matter that the call blocks the thread since you can't
    respond to the user until the invocation is complete anyway. When you're making
    multiple requests, however, blocking network calls will severely impact the performance
    and scalability of your application. What we need is an easy way to make use of
    Java's concurrency features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们为每个请求从消息服务到社交服务进行单个服务调用。这有一个好处，就是实现起来非常简单，当使用单线程语言，如 Python、Ruby 或
    JavaScript 时，这通常是唯一的选择。以这种方式同步执行网络调用在每次请求只进行一次时是可以接受的——因为无论如何你都无法在调用完成之前响应用户，所以调用阻塞线程并不重要。然而，当你进行多个请求时，阻塞网络调用将严重影响应用程序的性能和可伸缩性。我们需要的是一个简单的方法来利用
    Java 的并发特性。
- en: If you're writing your microservices in Scala, you can take advantage of the
    `Future` type, which is used to represent an asynchronous computation. The **Finagle**
    RPC framework even uses futures as one of its base abstractions for modeling dependent
    RPCs. Java also has futures and the Spring Boot framework has some useful utilities
    that make it easy to wrap network calls, making them asynchronous and therefore
    non-blocking.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Scala 编写你的微服务，你可以利用 `Future` 类型，它用于表示异步计算。**Finagle** RPC 框架甚至将 futures
    作为其建模依赖 RPC 的基本抽象之一。Java 也有 futures，Spring Boot 框架提供了一些有用的工具，使得包装网络调用变得简单，从而使它们异步，因此是非阻塞的。
- en: 'In this recipe, we''ll retool the message service we introduced in the previous
    recipe. Instead of checking to see whether the sender and recipient of a message
    are friends, we''ll now imagine that our app uses an asymmetric following model.
    For a user to message another user, the two users will have to follow each other.
    This requires the message service to make two network calls to the social service,
    checking that the sender follows the recipient and simultaneously checking that
    the recipient follows the sender. The following simplified diagram represents
    the relationship between services:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重新配置我们在上一个菜谱中引入的消息服务。而不是检查消息的发送者和接收者是否是朋友，我们现在假设我们的应用程序使用非对称关注模型。为了一个用户向另一个用户发送消息，这两个用户必须相互关注。这要求消息服务向社交服务进行两次网络调用，检查发送者是否关注接收者，同时检查接收者是否关注发送者。以下简化图表示了服务之间的关系：
- en: '![](img/06522d1b-7cc6-456f-a624-cfcaef00e7c4.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06522d1b-7cc6-456f-a624-cfcaef00e7c4.png)'
- en: Spring Boot has useful tools that we can use to make methods asynchronous using
    Java's `CompletableFuture` type. We'll modify our previous message service to
    make two concurrent calls to the search service.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot有一些有用的工具，我们可以使用Java的`CompletableFuture`类型来使方法异步。我们将修改我们之前的消息服务，使其对搜索服务进行两次并发调用。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open the `MessageController` file and insert the following content:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MessageController`文件，插入以下内容：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Replace the `getFriendsForUser` method with a new method, called `isFollowing`.
    We give the new method an `@Async` annotation, which tells Spring Boot that this
    method will be run in a different thread:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`getFriendsForUser`方法替换为一个新的方法，称为`isFollowing`。我们给这个新方法添加了`@Async`注解，这告诉Spring
    Boot这个方法将在不同的线程中运行：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Modify the `create` method to make the two service invocations. We''ll need
    to wait until they are both done before deciding how to proceed, but the two service
    calls will be made concurrently:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`create`方法以进行两个服务调用。我们需要等待这两个调用都完成后才能决定如何进行，但这两个服务调用将并发进行：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the `@Async` annotation to schedule methods on separate threads, we need
    to configure an `Executor`. This is done in our `Application` class, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`@Async`注解在单独的线程上调度方法，我们需要配置一个`Executor`。这在我们`Application`类中完成，如下所示：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our service now makes concurrent asynchronous calls to the social service in
    order to ensure that the sender and recipient of a message follow each other.
    We customize our `Async` scheduler with `Executor` defined as part of our application's
    configuration. We've configured our `ThreadPoolTaskExecutor` class to limit the
    number of threads to `2` and the queue size to `500`. There are many factors to
    consider when configuring `Executor`, such as the amount of traffic you expect
    your service to receive and the average amount of time it takes for your service
    to serve a request. In this example, we'll leave it with these values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务现在并发异步地调用社交服务，以确保消息的发送者和接收者相互关注。我们使用定义在我们应用程序配置部分中的`Executor`来自定义我们的`Async`调度器。我们已经配置了`ThreadPoolTaskExecutor`类，将线程数限制为`2`，队列大小为`500`。在配置`Executor`时需要考虑许多因素，例如预期服务接收的流量量和服务处理请求的平均时间。在这个例子中，我们将保持这些值不变。
- en: Service discovery
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: Before services can invoke each other, they need to be able to find each other
    using some kind of service discovery mechanism. This means being able to translate
    a service name into a network location (IP address and port). Traditional applications
    maintained the network locations of services to send requests to, probably in
    a configuration file (or worse, hardcoded in the application code). This approach
    assumes that network locations are relatively static, which isn't going to be
    the case in modern, cloud-native applications. The topologies of microservice
    architectures are constantly changing. Nodes are being added and removed through
    auto-scaling, and we have to assume that some nodes will fail either completely
    or by serving requests with unacceptably high latency. As a microservice architecture
    grows, you'll need to consider a more feature-rich service-discovery mechanism.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务能够相互调用之前，它们需要能够使用某种服务发现机制找到彼此。这意味着能够将服务名称转换为网络位置（IP 地址和端口）。传统的应用程序维护了要发送请求的服务网络位置，可能在一个配置文件中（或者更糟糕的是，硬编码在应用程序代码中）。这种方法假设网络位置相对静态，这在现代云原生应用程序中不会是情况。微服务架构的拓扑结构不断变化。节点通过自动扩展被添加和删除，我们必须假设某些节点可能会完全失败或通过具有不可接受的高延迟来处理请求。随着微服务架构的发展，你需要考虑一个功能更丰富的服务发现机制。
- en: When choosing a service-discovery mechanism, the datastore used to back your
    service registry is extremely important. You want a well-tested, battle-worn system.
    Apache **ZooKeeper** is an open source hierarchical key-value store commonly used
    for distributed locking, service discovery, maintaining configuration information,
    and other distributed coordination tasks. The development of ZooKeeper was in
    part motivated by a paper published by Google in 2006 that described **Chubby**,
    an internally-developed system for distributed lock storage. In this recipe, we'll
    use ZooKeeper to build a service-discovery mechanism.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择服务发现机制时，用于支持你的服务注册表的数据存储极为重要。你需要一个经过良好测试、经验丰富的系统。Apache **ZooKeeper** 是一个开源的分层键值存储，通常用于分布式锁定、服务发现、维护配置信息和其他分布式协调任务。ZooKeeper
    的发展部分受到 2006 年谷歌发表的一篇论文的启发，该论文描述了 **Chubby**，这是一个用于分布式锁存储的内部开发系统。在这个配方中，我们将使用
    ZooKeeper 来构建服务发现机制。
- en: Spring Cloud ZooKeeper is a project that provides easy ZooKeeper integration
    in Spring Boot applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud ZooKeeper 是一个项目，它为 Spring Boot 应用程序提供简单的 ZooKeeper 集成。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For this recipe, there are two sets of steps, as shown in the next sections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，有两个步骤集合，如下一节所示。
- en: Registering with the service registry
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务注册表中注册
- en: 'This recipe requires a running ZooKeeper cluster. At a minimum, you will need
    a single ZooKeeper node running locally on your development machine. For instructions
    on installing and running ZooKeeper, please visit the excellent ZooKeeper documentation.
    Take a look at the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要一个正在运行的 ZooKeeper 集群。至少，你需要在你的开发机器上本地运行一个 ZooKeeper 节点。有关安装和运行 ZooKeeper
    的说明，请访问优秀的 ZooKeeper 文档。查看以下步骤：
- en: 'For this example, we''ll create a service to handle the creation and retrieval
    of user accounts. Create a new Gradle Java application called `users-service`
    with the following `build.gradle` file:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个服务来处理用户账户的创建和检索。创建一个名为 `users-service` 的新 Gradle Java 应用程序，并使用以下
    `build.gradle` 文件：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Because we''ve declared `spring-boot-starter-zookeeper-discovery` as a dependency,
    we have access to the necessary annotations to tell our application to register
    itself with a ZooKeeper service registry on startup. Create a new class called
    `Application`, which will serve as our service''s entry point:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经将 `spring-boot-starter-zookeeper-discovery` 声明为依赖项，我们可以访问必要的注解来告诉我们的应用程序在启动时将自己注册到
    ZooKeeper 服务注册表中。创建一个名为 `Application` 的新类，它将作为我们服务的入口点：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The application now attempts to connect to a ZooKeeper node, by default running
    on port 2181 on localhost. This default will work for local development, but will
    need to be changed in a production environment anyway. Add a file `src/resources/application.yml`
    with the following contents:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序现在尝试连接到 ZooKeeper 节点，默认情况下在本地主机的 2181 端口上运行。这个默认设置适用于本地开发，但在生产环境中仍然需要更改。添加一个名为
    `src/resources/application.yml` 的文件，并包含以下内容：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To give your service a meaningful name in the service registry, modify the
    `application.yml` file and add the following content:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在服务注册表中给你的服务一个有意义的名称，修改 `application.yml` 文件并添加以下内容：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finding services
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找服务
- en: 'Now that we have a service being registered with the service registry, we''ll
    create another service to demonstrate using the Spring ZooKeeper `DiscoveryClient`
    to find a running instance of that service:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将服务注册到服务注册表中，我们将创建另一个服务来演示使用Spring ZooKeeper `DiscoveryClient`查找该服务的运行实例：
- en: 'Open our previously created message-service client. Add the following lines
    to `build.gradle`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们之前创建的消息服务客户端。将以下行添加到`build.gradle`文件中：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''re using an HTTP client developed by Netflix, called **Feign**. Feign allows
    you to declaratively build HTTP clients and supports service discovery by default.
    Create a new file called `UsersClient.java` with the following content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用由Netflix开发的HTTP客户端，称为**Feign**。Feign允许你声明性地构建HTTP客户端，并默认支持服务发现。创建一个名为`UsersClient.java`的新文件，并包含以下内容：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Open the `MessageController.java` file, and add an instance of `UsersClient`
    as a field:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MessageController.java`文件，并将`UsersClient`的一个实例作为字段添加：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Instead of manually building the URL in the `isFollowing` method, we can use
    the Feign client to automatically get a list of friendships for a user, as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`isFollowing`方法中手动构建URL而不是，我们可以使用Feign客户端自动获取用户的友谊列表，如下所示：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Because we're using a service registry, we no longer have to worry about clunky
    configs holding onto hostname values that can change. Furthermore, we're in a
    position to start deciding how we want to distribute the load among available
    instances of a service.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用服务注册表，我们不再需要担心那些持有可能更改的主机名值的笨拙配置。此外，我们现在可以开始决定我们想要如何将负载分配给服务的可用实例。
- en: Server-side load balancing
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端负载均衡
- en: When thinking about distributing load across a cluster of servers running instances
    of an application, it's interesting to consider a brief (and incomplete) history
    of web application architectures. Some of the earliest web applications were static
    HTML pages hosted by a web server, such as Apache or similar web server daemon
    software. Gradually, applications became more dynamic, using technologies such
    as server-side scripts executed through CGI. Even dynamic applications were still
    files hosted and served directly by a web server daemon. This simple architecture
    worked for a long time. Eventually, however, as the amount of traffic an application
    received grew, a way to distribute load among identical stateless instances of
    an application was needed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑在运行应用程序实例的服务器集群中分配负载时，思考一下网络应用程序架构的简要（且不完整）历史很有趣。一些最早的Web应用程序是由Apache或类似Web服务器守护程序软件托管的静态HTML页面。逐渐地，应用程序变得更加动态，使用诸如通过CGI执行的服务器端脚本等技术。即使是动态应用程序，也仍然是托管并由Web服务器守护程序直接提供服务的文件。这种简单的架构长期有效。然而，随着应用程序接收到的流量增加，需要一种方法来在应用程序的相同无状态实例之间分配负载。
- en: There are a number of techniques for load balancing, including round-robin DNS
    or DNS geolocation. The simplest and most common form of load balancing for microservices
    is to use a software program that forwards requests to one of a cluster of backend
    servers. There are a number of different ways load can be distributed, based on
    the specific load-balancing algorithm used by the load balancer we choose. Simple
    load-balancing algorithms include round-robin and random choice. More often, in
    real-world production applications, we'll opt for a load-balancing algorithm that
    takes reported metrics, such as load or the number of active connections, into
    account when choosing a node in a cluster to forward a request to.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多负载均衡技术，包括轮询DNS或DNS地理位置。对于微服务而言，最简单且最常见的形式的负载均衡是使用一个软件程序，该程序将请求转发到后端服务器集群中的一个。根据我们选择的负载均衡器的特定负载均衡算法，可以以多种不同的方式分配负载。简单的负载均衡算法包括轮询和随机选择。在现实世界的生产应用程序中，我们通常会选择一种负载均衡算法，该算法在选择将请求转发到集群中的节点时，会考虑报告的指标，例如负载或活动连接数。
- en: There are a number of popular open source applications that can perform effective
    load balancing for microservices. **HAProxy** is a popular open source load balancer
    that can do TCP and HTTP load balancing. NGINX is a popular open source web server
    that can be effectively used as a reverse proxy, application server, load balancer,
    or even HTTP cache. Nowadays, more organizations are in positions to develop microservices
    that are deployed on cloud platforms, such as Amazon Web Services or Google Cloud
    Platform, which each have solutions for server-side load balancing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多流行的开源应用程序可以有效地为微服务执行负载均衡。**HAProxy**是一个流行的开源负载均衡器，可以进行TCP和HTTP负载均衡。NGINX是一个流行的开源Web服务器，可以有效地用作反向代理、应用程序服务器、负载均衡器，甚至是HTTP缓存。如今，更多的组织处于开发部署在云平台上的微服务的位置，例如亚马逊网络服务或谷歌云平台，它们各自都有服务器端负载均衡的解决方案。
- en: AWS provides a load-balancing solution called **Elastic Load Balancing** (**ELB**).
    ELB can be configured to forward traffic to a member of an **Auto Scaling Groups**.
    Auto Scaling Groups are collections of EC2 instances that are treated as a logical
    group. ELB use health checks (TCP or HTTP) that help the load balancer determine
    whether to forward traffic to a particular EC2 instance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: AWS提供了一个名为**弹性负载均衡**（**ELB**）的负载均衡解决方案。ELB可以被配置为将流量转发到**自动扩展组**的成员。自动扩展组是一组被视为逻辑组的EC2实例。ELB使用健康检查（TCP或HTTP），这有助于负载均衡器确定是否将流量转发到特定的EC2实例。
- en: In this recipe, we'll use the AWS CLI tool to create an Auto Scaling Groups
    and attach an ELB to it. We won't cover configuration management or deployment
    in this recipe, so imagine that you have a microservice running on each of the
    EC2 instances in the Auto Scaling Groups.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用AWS CLI工具创建一个自动扩展组并将其附加到它。在这个菜谱中，我们不会涵盖配置管理或部署，所以想象一下，你有一个微服务在每个自动扩展组的EC2实例上运行。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We'll be using the AWS CLI in this recipe, a command-line utility written in
    Python, that makes interacting with the AWS API easy. We'll assume you have an
    AWS account and have installed and configured the AWS CLI application. Consult
    the AWS documentation ([https://docs.aws.amazon.com/cli/latest/index.html#](https://docs.aws.amazon.com/cli/latest/index.html#))
    for installation instructions.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用AWS CLI，这是一个用Python编写的命令行实用程序，它使得与AWS API交互变得简单。我们假设你有一个AWS账户，并且已经安装并配置了AWS
    CLI应用程序。有关安装说明，请参阅AWS文档（[https://docs.aws.amazon.com/cli/latest/index.html#](https://docs.aws.amazon.com/cli/latest/index.html#)）。
- en: 'Create a launch configuration. Launch configurations are templates that our
    Auto Scaling Groups will use for creating new EC2 instances. They contain information
    such as the instance type and size that we want to use when creating new instances.
    Give your launch configuration a unique name–in our case, we''ll simply call it
    `users-service-launch-configuration`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个启动配置。启动配置是自动扩展组在创建新的EC2实例时使用的模板。它们包含我们创建新实例时想要使用的信息，例如实例类型和大小。给你的启动配置起一个独特的名字——在我们的例子中，我们将简单地称它为`users-service-launch-configuration`：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create an Auto Scaling Groups that uses our new launch configuration:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用我们新启动配置的自动扩展组：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create an ELB, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个ELB：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Attach the ASG to our load balancer by running the following command line:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令行将ASG附加到我们的负载均衡器：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Client-side load balancing
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端负载均衡
- en: Server-side load balancing is a well-established and battle-tested way to distribute
    load to an application. It has drawbacks, however, in that there is an upper limit
    to the amount of incoming connections that a single load balancer can handle.
    This can be at least partially solved with round-robin DNS, which would distribute
    load to a number of load balancers, but this configuration can quickly become
    cumbersome and costly. Load balancer applications can also become points of failure
    in an already-complex microservices architecture.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端负载均衡是一种经过验证和实战考验的将负载分配给应用程序的方法。然而，它也有一些缺点，例如，单个负载均衡器可以处理的传入连接数量有一个上限。这至少可以通过轮询DNS来解决，这将负载分配到多个负载均衡器，但这种配置可能会很快变得繁琐且成本高昂。负载均衡器应用程序也可能成为复杂微服务架构中的故障点。
- en: An increasingly popular alternative to server-side load balancing is client-side
    load balancing. In this convention, clients are responsible for distributing requests
    evenly to running instances of a service. Clients can keep track of latency and
    failure rates from nodes and opt to reduce the amount of traffic to nodes that
    are experiencing high latency or high failure rates. This method of load balancing
    can be extremely effective and simple, especially in large-scale applications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端负载均衡的一个越来越受欢迎的替代方案是客户端负载均衡。在这个约定中，客户端负责将请求均匀地分布到服务的运行实例。客户端可以跟踪节点的延迟和失败率，并选择减少经历高延迟或高失败率的节点的流量。这种负载均衡方法可以非常有效且简单，尤其是在大规模应用程序中。
- en: Ribbon is an open source library developed by Netflix that, among other features,
    provides support for client-side load balancing. In this recipe, we'll modify
    our message service to use `ribbon` for client-side load balancing. Instead of
    sending our requests for a user's friendships to a single instance of the users
    service, we'll distribute load to a number of available instances.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Ribbon 是 Netflix 开发的一个开源库，它提供了许多功能，其中包括对客户端负载均衡的支持。在这个配方中，我们将修改我们的消息服务以使用 `ribbon`
    进行客户端负载均衡。我们将不再将用户友情的请求发送到用户服务的单个实例，而是将负载分配给多个可用的实例。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open the `message-service` project and add the following lines to `build.gradle`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `message-service` 项目，并在 `build.gradle` 中添加以下行：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Navigate to `src/main/resources/application.yml` and add the following configuration
    for `users-service`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `src/main/resources/application.yml` 并为 `users-service` 添加以下配置：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a new Java class called `UsersServiceConfiguration`. This class will
    configure the specific rules we want `ribbon` to follow when deciding how to distribute
    load:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `UsersServiceConfiguration` 的新 Java 类。这个类将配置我们希望 `ribbon` 在决定如何分配负载时遵循的特定规则：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Open `MessageController` and add the following annotation to the `MessageController`
    class:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MessageController` 并在 `MessageController` 类中添加以下注释：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Annotate the `RestTemplate` class to indicate that we want it to use `ribbon`
    load-balancing support, and modify our URL to use the service name, not the hostname
    we had hardcoded previously:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释 `RestTemplate` 类以指示我们希望它使用 `ribbon` 负载均衡支持，并修改我们的 URL 以使用服务名称，而不是之前硬编码的主机名：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Building event-driven microservices
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建事件驱动微服务
- en: So far, all of our service-to-service communication recipes have involved having
    one service call one or more other services directly. This is necessary when the
    response from the downstream service is required to fulfill the user's request.
    This isn't always required however. In cases when you want to react to an event
    in the system, for example, when you want to send an email or notification or
    when you want to update an analytics store, using an event-driven architecture
    is preferable. In this design, one service produces a message to a broker and
    another application consumes that message and performs an action. This has the
    benefit of decoupling the publisher from the consumer (so your message service
    doesn't have to worry about sending email notifications, for instance) and also
    removing potentially expensive operations off the critical path of the user's
    request. The event-driven architecture also provide some level of fault tolerance
    as consumers can fail, and messages can be replayed to retry any failed operations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的服务间通信配方都涉及一个服务直接调用一个或多个其他服务。当需要下游服务的响应来满足用户请求时，这是必要的。然而，这并不总是必需的。在您想对系统中的事件做出反应的情况下，例如，当您想发送电子邮件或通知，或者当您想更新分析存储时，使用事件驱动架构是更可取的。在这个设计中，一个服务向代理发送消息，另一个应用程序消费该消息并执行操作。这有利于解耦发布者和消费者（因此您的消息服务不必担心发送电子邮件通知等）并且也从用户请求的关键路径上移除了可能昂贵的操作。事件驱动架构还提供了一定程度的容错性，因为消费者可能会失败，并且可以重新播放消息以重试任何失败的操作。
- en: '**Apache Kafka** is an open source stream-processing platform. At its core,
    it is an event broker architected as a distributed transaction log. A full description
    of Apache Kafka is worthy of an entire book in itself—for a great introduction,
    I highly recommend reading the LinkedIn blog post that introduces Kafka ([https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)).
    The minimum you need to know to follow this recipe is that Kafka is a distributed
    event store that lets you publish messages to categories called **topics**. Another
    process can then consume messages from a topic and react to them.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apache Kafka** 是一个开源的流处理平台。在其核心，它是一个分布式事务日志架构的事件代理。Apache Kafka 的完整描述足以写成一整本书——为了一个很好的介绍，我强烈推荐阅读
    LinkedIn 的博客文章，该文章介绍了 Kafka ([https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)))。为了遵循这个菜谱，你需要知道的最少信息是
    Kafka 是一个分布式事件存储，允许你向称为 **topics** 的类别发布消息。然后另一个进程可以从一个主题中消费消息并对它们做出反应。'
- en: Going back to our fictional messaging application, when a user sends a message
    to another user, we want to be able to notify the recipient in a number of ways.
    Depending on the recipient's preferences, we'll probably send an email or a push
    notification or both. In this recipe, we'll modify our message service from previous
    recipes to publish an event to a Kafka topic called **messages**. We'll then build
    a consumer application that listens for events in the message's topic and can
    react by sending the recipient notifications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们虚构的消息应用程序，当用户向另一个用户发送消息时，我们希望能够以多种方式通知接收者。根据接收者的偏好，我们可能会发送电子邮件或推送通知，或者两者都发送。在这个菜谱中，我们将修改之前菜谱中的消息服务，将事件发布到名为
    **messages** 的 Kafka 主题。然后我们将构建一个消费者应用程序，它监听消息主题中的事件，并可以通过发送接收者通知来做出反应。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Spring for Apache Kafka (`spring-kafka`) is a project that makes it easy to
    integrate Spring applications with Apache Kafka. It provides useful abstractions
    for sending and receiving messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Spring for Apache Kafka (`spring-kafka`) 是一个项目，它使得将 Spring 应用程序与 Apache Kafka
    集成变得容易。它为发送和接收消息提供了有用的抽象。
- en: Note that to follow the steps in this recipe, you will need to have a version
    of Kafka and ZooKeeper running and accessible. Installing and configuring these
    two pieces of software is beyond the scope of this recipe, so please visit the
    respective project websites and follow their wonderfully written guides on getting
    started. In this recipe, we'll assume that you have Kafka running a single broker
    on port `9092` and a single instance of ZooKeeper running on port `2181`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要遵循这个菜谱中的步骤，你需要有一个 Kafka 和 ZooKeeper 的版本正在运行并且可访问。安装和配置这两件软件超出了这个菜谱的范围，所以请访问相应的项目网站，并遵循他们精心编写的入门指南。在这个菜谱中，我们假设你有一个
    Kafka 在 `9092` 端口上运行的单个代理，以及一个在 `2181` 端口上运行的单个 ZooKeeper 实例。
- en: Message producer
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息生产者
- en: 'Open the `message-service` project from previous recipes. Modify the `build.gradle`
    file and add the `spring-kafka` project to the list of dependencies:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前菜谱中的 `message-service` 项目。修改 `build.gradle` 文件并将 `spring-kafka` 项目添加到依赖列表中：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `spring-kafka` project provides a template for sending messages to a Kafka
    broker. To use the template in our project, we'll need to create a `ProducerFactory`
    interface and provide it to the constructor of the template.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spring-kafka` 项目提供了一个向 Kafka 代理发送消息的模板。为了在我们的项目中使用这个模板，我们需要创建一个 `ProducerFactory`
    接口并将其提供给模板的构造函数。'
- en: 'Open the `Application.java` file and add the following content. Note that we''re
    hardcoding the network location of the Kafka broker here—in a real application,
    you''d at least place this value in some kind of configuration (preferably respecting
    12 factor conventions):'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Application.java` 文件并添加以下内容。请注意，我们在这里硬编码了 Kafka 代理的网络位置——在实际应用程序中，你至少应该将此值放置在某种配置中（最好是遵循
    12 因素约定）：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that we can use `KafkaTemplate` in our application, add one to the `MessageController`
    class. Also, use the Jackson `ObjectMapper` class to convert our `Message` instance
    into a JSON string that we''ll publish to the Kafka topic. Open the `MessageController`
    class and add following fields:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的应用程序中使用 `KafkaTemplate`，将其添加到 `MessageController` 类中。同时，使用 Jackson
    的 `ObjectMapper` 类将我们的 `Message` 实例转换为 JSON 字符串，然后将其发布到 Kafka 主题。打开 `MessageController`
    类并添加以下字段：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we have access to the Jackson `ObjectMapper` and the `KafkaTemplate`
    classes, create a method for publishing events. In this example, we''re printing
    out to standard error and standard output. In a real application, you''d configure
    a logger, such as log4j, and use the appropriate log levels:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经可以访问Jackson的`ObjectMapper`和`KafkaTemplate`类，创建一个用于发布事件的函数。在这个例子中，我们正在将输出打印到标准错误和标准输出。在实际应用程序中，您会配置一个记录器，例如log4j，并使用适当的日志级别：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following line to the `create` method, calling the previously created
    the `publishMessageEvent` method:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`create`方法中添加以下行，调用之前创建的`publishMessageEvent`方法：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To test this example, create a message topic using the `kafka-topics.sh` Kafka
    utility (packaged with the Kafka binary distribution), as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试此示例，请使用`kafka-topics.sh` Kafka实用工具（包含在Kafka二进制发行版中）创建一个消息主题，如下所示：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Message consumer
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息消费者
- en: 'Now that we''re publishing message-send events, the next step is to build a
    small consumer application that can react to these events in our system. We''ll
    discuss the scaffolding as it relates to Kafka in this recipe; implementing email
    and push notification functionality is left as an exercise for the reader:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在发布消息发送事件，下一步是构建一个小的消费者应用程序，它可以对我们的系统中的这些事件做出反应。我们将在这个菜谱中讨论与Kafka相关的框架；实现电子邮件和推送通知功能留作读者的练习：
- en: 'Create a new Gradle Java project called `message-notifier` with the following
    `build.gradle` file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`message-notifier`的新Gradle Java项目，并使用以下`build.gradle`文件：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a new Java class called `Application` with the Spring Boot application
    boilerplate:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Application`的新Java类，包含Spring Boot应用程序样板代码：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Evolving APIs
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API的演变
- en: APIs are contracts between clients and servers. Backward-incompatible changes
    to APIs can cause unexpected errors for clients of the service. In a microservices
    architecture, precautions have to be taken to ensure that changes to a service's
    API do not unintentionally cause cascading problems throughout the system.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: API是客户端和服务器之间的合同。API的向后不兼容更改可能会对服务的客户端造成意外的错误。在微服务架构中，必须采取预防措施以确保服务API的更改不会无意中在整个系统中引起级联问题。
- en: A popular approach is to version your API, either through the URL or via content
    negotiation in request headers. Because they're generally easier to work with,
    and often easier to cache, URL prefixes or query strings tend to be more common—in
    this case, the API endpoint is either prefixed with a version string (that is,
    `/v1/users`) or called with a query string parameter specifying a version or even
    a date (that is, `/v1/users?version=1.0 or /v1/users?version=20180122`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一种流行的方法是通过URL或通过请求头中的内容协商来对API进行版本控制。由于它们通常更容易处理，并且通常更容易缓存，因此URL前缀或查询字符串更常见——在这种情况下，API端点要么带有版本字符串前缀（即`/v1/users`），要么通过查询字符串参数指定版本或日期（即`/v1/users?version=1.0`或`/v1/users?version=20180122`）。
- en: With edge proxies or service mesh configurations, it's even possible to run
    multiple versions of software in an environment and route requests based on the
    URL to older or newer versions of a service. This changes the traditional life
    cycle of a service–you can safely decommission a version when it is no longer
    receiving any traffic. This can be useful, especially in the case of a public
    API where you have little control over clients.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用边缘代理或服务网格配置，甚至可以在环境中运行多个版本的软件，并根据URL路由请求到服务的新或旧版本。这改变了服务的传统生命周期——您可以在不再接收任何流量时安全地退役一个版本。这在公共API的情况下非常有用，您对客户端几乎没有控制权。
- en: Microservices are different than public APIs. The contract between clients and
    the server in a public API is much more long-lived. In a microservices architecture,
    it's easier to track down clients who are using your service and convince them
    to upgrade their code! Nevertheless, API versioning is sometimes necessary. Because
    being able to respond successfully to multiple versions of an API is a maintenance
    burden, we'd like to avoid it for as long as possible. To do this, there are a
    few practices that can be used to avoid making backward-incompatible changes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务与公共API不同。在公共API中，客户端和服务器之间的合同通常更持久。在微服务架构中，更容易追踪使用您服务的客户端并说服他们升级他们的代码！尽管如此，有时API版本化是必要的。因为能够成功响应多个版本的API是一种维护负担，我们希望尽可能避免它。为此，有一些实践可以用来避免做出向后不兼容的更改。
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Using our example application, `pichat`, let''s imagine that we want to change
    the name of the message body from `body` to `message_text`. This presents a problem
    because our message service is designed to accept the following requests:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的示例应用程序`pichat`，让我们假设我们想要将消息体的名称从`body`更改为`message_text`。这会带来一个问题，因为我们的消息服务被设计为接受以下请求：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the case of the `GET` requests, the client will expect a JSON object with
    a field called `body` in the response. In the case of the `POST` request, clients
    will be sending payloads as the JSON objects with a field called `body`. We can''t
    simply remove body because that would break existing clients, thus necessitating
    a change to the API version. Instead, we''ll simply add the new field in addition
    to the old one, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GET`请求的情况下，客户端会期望在响应中有一个名为`body`的字段所组成的JSON对象。在`POST`请求的情况下，客户端会将包含名为`body`的字段作为JSON对象发送负载。我们不能简单地移除`body`字段，因为这会破坏现有的客户端，因此需要修改API版本。相反，我们将在旧字段的基础上简单地添加新字段，如下所示：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now you can gradually track down clients using these responses; once they've
    all been upgraded, you can safely remove the deprecated field from the JSON response.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以逐步跟踪使用这些响应的客户端；一旦它们都升级了，你就可以安全地从JSON响应中移除已弃用的字段。
