- en: '*Chapter 4*: Learning Single-Page Application Concepts and How React Enables
    Them'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：学习单页应用程序的概念以及React如何实现它们'
- en: In this chapter, we'll learn about **Single-Page Applications** (**SPAs**).
    This style of programming web applications is relatively new in the history of
    web development but has caught on strongly in recent years. Its use is now common
    practice for building large complex web applications that need to feel like native
    desktop or mobile apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习**单页应用程序**（**SPA**）。这种编程Web应用程序的风格在Web开发的历史上相对较新，但近年来已经得到了广泛的应用。它的使用现在是构建需要感觉像原生桌面或移动应用程序的大型复杂Web应用程序的常见做法。
- en: We will review the former methods of building web apps and why SPA-style apps
    were created. We'll then learn how React can help us build this style of application
    in a performant and efficient way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾构建Web应用程序的以前方法以及为什么创建了SPA风格的应用程序。然后，我们将学习React如何帮助我们以高效和有效的方式构建这种应用程序风格。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding how websites were built in the past
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解过去网站是如何构建的
- en: Understanding SPA benefits and attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SPA的好处和属性
- en: Understanding how React helps build SPA applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解React如何帮助构建SPA应用程序
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The requirements for this chapter are similar to the ones for [*Chapter 3*](B15508_03_Final_JC_ePub.xhtml#_idTextAnchor052),
    *Building Better Apps with ES6+ Features*. You should have a basic understanding
    of JavaScript as well as HTML and CSS. We will once again be using Node.js and
    **Visual Studio Code** (**VSCode**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求与[*第3章*](B15508_03_Final_JC_ePub.xhtml#_idTextAnchor052)的要求相似，*使用ES6+功能构建更好的应用程序*。您应该对JavaScript以及HTML和CSS有基本的了解。我们将再次使用Node.js和**Visual
    Studio Code**（**VSCode**）。
- en: The GitHub repository is again at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap4` folder.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库再次位于[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node)。使用`Chap4`文件夹中的代码。
- en: To set up this chapter's code folder, go to your `HandsOnTypescript` folder
    and create a new folder called `Chap4`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设置本章的代码文件夹，转到您的`HandsOnTypescript`文件夹并创建一个名为`Chap4`的新文件夹。
- en: Understanding how websites were built in the past
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解过去网站是如何构建的
- en: In this section, we will investigate the reasons for the creation of SPA-style
    programming by reviewing the original methods for designing and writing web pages.
    Having this knowledge will help us understand the reason for the shift to SPAs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过回顾设计和编写网页的原始方法来调查SPA风格编程的创建原因。了解这些知识将帮助我们理解转向SPA的原因。
- en: Originally, when the web was getting started, there was no JavaScript language.
    Initially, it was all just static HTML pages created to share documents among
    scientists. Once this document format and the internet became more popular, people
    realized that these documents needed improved styling methods to enhance communication.
    So, CSS was created and it became a standard for styling and the layout of HTML
    documents. Then, finally, the Netscape browser company decided the web needed
    a scripting language to make page content more dynamic, and they created JavaScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，当Web开始时，没有JavaScript语言。最初，这只是为了在科学家之间共享文档而创建的静态HTML页面。一旦这种文档格式和互联网变得更受欢迎，人们意识到这些文档需要改进的样式方法来增强沟通。因此，创建了CSS，并且它成为了HTML文档的样式和布局的标准。最后，网景浏览器公司决定Web需要一种脚本语言来使页面内容更加动态，于是他们创建了JavaScript。
- en: Despite these features, the original web was still very static in nature. When
    you entered a URL into your browser, you got back a single document—that is, an
    actual file on the server—and this would be the case for every URL you entered.
    CSS and JavaScript did help to make the web look better and be more dynamic, but
    it did not change the page-focused model of the web.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些功能，原始的Web仍然非常静态。当您在浏览器中输入URL时，您会收到一个文档，即服务器上的实际文件，对于您输入的每个URL都是如此。CSS和JavaScript确实有助于使Web看起来更好，更具动态性，但它并没有改变Web的面向页面的模型。
- en: As websites became more and more sophisticated, many web developers wanted to
    have better control over their web documents. They wanted to dynamically control
    the layout and content of web pages. This resulted in **Common Gateway Interface**
    (**CGI**) being created. CGI was an early attempt at doing **Server-Side Rendering**
    (**SSR**). This basically means that requests from browsers were received by web
    servers, but instead of returning static HTML pages, the server would run a processor
    that would dynamically generate a page on the fly based on parameters and logic
    and then send that back.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网站变得越来越复杂，许多网页开发人员希望更好地控制他们的网页文档。他们希望动态控制网页的布局和内容。这导致了**通用网关接口**（**CGI**）的创建。CGI是对**服务器端渲染**（**SSR**）的早期尝试。这基本上意味着浏览器的请求被Web服务器接收，但服务器不会返回静态HTML页面，而是运行一个处理器，根据参数和逻辑动态生成页面，然后发送回去。
- en: Whether the website used a static HTML page that did not change or rendered
    its pages on a server using server-side logic, in the past, the emphasis was on
    sending to browsers complete HTML pages as files. This was how websites worked
    in general.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论网站使用静态HTML页面还是在服务器上使用服务器端逻辑呈现其页面，在过去，重点是向浏览器发送完整的HTML页面作为文件。这通常是网站的工作方式。
- en: This single-file or page-based model is not at all like how native apps work,
    either on desktops or mobile devices. The native app model is different in that
    the entire app is downloaded and installed onto the user's device. When the user
    opens the app, it is ready to use in its entirety at that moment. Any controls
    that need to be drawn on the screen are done so from the code that is already
    there, and no additional calls to a backend server are necessary (other than calls
    to send or get data). This makes apps feel noticeably more responsive and faster
    than classic web applications, which constantly required a page refresh to show
    new content in the old model.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种单文件或基于页面的模型与本机应用程序的工作方式完全不同，无论是在桌面还是移动设备上。本机应用程序模型不同之处在于整个应用程序被下载并安装到用户的设备上。用户打开应用程序时，它已经准备好在那一刻全部使用。需要在屏幕上绘制的任何控件都是从已经存在的代码中完成的，除了发送或获取数据的调用之外，不需要额外调用后端服务器（其他调用）。这使应用程序的响应速度和速度比旧模型中不断需要刷新页面以显示新内容的经典Web应用程序明显更快。
- en: The impetus of SPA applications was to make web apps feel much more like native
    device applications, in order to give them the same sense of speed and responsiveness.
    Therefore, the SPA style uses various techniques and libraries to make web applications
    function and feel more like native applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SPA应用程序的动机是使Web应用程序感觉更像本机设备应用程序，以便给它们相同的速度和响应性感觉。因此，SPA风格使用各种技术和库使Web应用程序的功能和感觉更像本机应用程序。
- en: In this section, we reviewed how websites were built in the early days of the
    web. Back then, the focus was on generating and serving individual HTML document
    files. We saw how there are limitations with this style of programming, especially
    when compared with native applications, and that SPA-style applications are an
    attempt to address those limitations and make web apps seem like native apps.
    In the next section, you will see what SPA apps are and how they may improve upon
    the page-focused model of the original web.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了早期Web构建网站的方式。当时，重点是生成和提供单独的HTML文档文件。我们看到了这种编程风格的局限性，特别是与本机应用程序相比，以及SPA风格应用程序是试图解决这些限制并使Web应用程序看起来像本机应用程序的尝试。在下一节中，您将看到SPA应用程序是什么，以及它们如何改进原始Web的页面集中模型。
- en: Understanding SPA benefits and attributes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SPA的好处和特性
- en: In this section, we will learn about what the benefits and attributes of SPA
    applications are. By learning about these attributes, they will help us understand
    some of the architectural decisions that were made during React's creation, as
    well as some of the related libraries and components used in creating React apps.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解SPA应用程序的好处和特性。通过了解这些特性，它们将帮助我们理解在创建React时所做的一些架构决策，以及在创建React应用程序时使用的一些相关库和组件。
- en: As mentioned earlier, the impetus for using SPA-style application building is
    to make our web app look and feel more like a native application. By using SPA
    application methods, we will make our program respond and look like it was installed
    on the device. Classic-style web apps can seem sluggish since any changes to the
    page require a call back to the server to get a new screen. However, SPA-style
    apps redraw portions of the screen immediately without waiting for a new file
    to come back from the server. Therefore, as far as the user can tell, a SPA application
    is a native device application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，使用SPA风格的应用程序构建的动机是使我们的Web应用程序看起来和感觉上更像本机应用程序。通过使用SPA应用程序方法，我们将使我们的程序响应和外观看起来像是安装在设备上的。经典风格的Web应用程序可能会显得迟钝，因为对页面的任何更改都需要回调服务器以获取新屏幕。然而，SPA风格的应用程序可以立即重绘屏幕的部分，而无需等待服务器返回新文件。因此，就用户而言，SPA应用程序就像本机设备应用程序一样。
- en: Building SPA applications is quite complex, with many components and libraries
    that need to be used. However, whether we're using Angular, Vue, React, or some
    other framework, there are certain features and requirements that will always
    be common across SPA applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 构建SPA应用程序非常复杂，需要使用许多组件和库。然而，无论我们使用Angular、Vue、React还是其他框架，SPA应用程序始终具有某些特性和要求。
- en: 'Let''s understand some of the requirements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一些要求：
- en: As the name suggests, the entire app lives on one HTML page only. Unlike standard
    HTML apps, which use separate pages to show different screens, the first page
    is the only page that ever loads on a SPA application.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顾名思义，整个应用程序只存在于一个HTML页面上。与使用单独页面显示不同屏幕的标准HTML应用程序不同，第一个页面是SPA应用程序上唯一加载的页面。
- en: Instead of static HTML files, JavaScript renders the screen dynamically. Therefore,
    the HTML page that is first downloaded is actually almost entirely empty of content.
    But what it will have is a root element inside of the body tag that becomes the
    container for the entire application, which again is rendered live as the user
    interacts with the application.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与静态HTML文件不同，JavaScript动态渲染屏幕。因此，首先下载的HTML页面实际上几乎完全没有内容。但它将有一个根元素，位于body标记内，成为整个应用程序的容器，再次随着用户与应用程序的交互而实时渲染。
- en: All scripts and files needed to run the application are generally downloaded
    in the beginning, when retrieving the main HTML file. However, this method is
    changing and more applications are downloading only a base-level script file and
    then downloading other scripts on-demand as needed. We'll review how to use these
    techniques later, as they can enhance the user experience by reducing screen wait
    times.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常在检索主HTML文件时，需要运行应用程序的所有脚本和文件都会被下载。然而，这种方法正在改变，越来越多的应用程序只下载一个基本级别的脚本文件，然后根据需要按需下载其他脚本。我们将在后面讨论如何使用这些技术，因为它们可以通过减少屏幕等待时间来增强用户体验。
- en: URL routing is handled differently for SPAs. In SPA applications, there is some
    mechanism used, depending on the framework you choose, in order to create **virtual
    routing**. Virtual routing simply means that although it appears to the user that
    different calls to different server-side URLs are being made, in reality, all
    the "routing" is only happening on the client browser in order to make logical
    transitions to different screens. In other words, no calls to servers are made
    and URL routing becomes a means to logically separate an app into different screens.
    For example, when a user types a URL into their browser, they must then press
    *Enter* for the submission to be posted back to the server that is the destination
    of the URL. However, in the case of routing happening in a SPA app, there is no
    actual server path indicated by the URL. It does not exist. Therefore, the postback
    is never triggered. Instead, the application uses the URL as a sort of container
    for sections of the application and also to trigger certain behaviors when certain
    URLs are given. Having said this, URL routing is still a useful feature to have,
    as routing is an expected capability by most users and it allows them to bookmark
    screens.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于单页应用程序，URL路由的处理方式有所不同。在SPA应用程序中，根据您选择的框架，会使用一些机制来创建**虚拟路由**。虚拟路由简单地意味着，尽管对用户来说，不同的调用会导致对不同的服务器端URL的访问，但实际上，“路由”只是在客户端浏览器上进行，以便对不同的屏幕进行逻辑转换。换句话说，不会发出对服务器的调用，URL路由成为将应用程序逻辑上分隔成不同屏幕的手段。例如，当用户在浏览器中输入URL时，他们必须按下*Enter*才能将提交发送回URL的目的地服务器。然而，在SPA应用程序中发生路由时，URL中并没有实际的服务器路径。它不存在。因此，提交不会被触发。相反，应用程序使用URL作为应用程序各部分的容器，并在给定某些URL时触发某些行为。话虽如此，URL路由仍然是一个有用的功能，因为大多数用户都希望具有路由功能，并且它允许他们将屏幕加为书签。
- en: In this section, we have learned about the attributes that make up a SPA. We
    covered the different methods to deal with having only a single file for our entire
    application and the methodologies used for building these kinds of applications.
    In the next section, we will drill into details about how React enables SPAs and
    the decisions that were made by the React team for creating this style of application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经了解了构成SPA的属性。我们涵盖了处理整个应用程序只有一个文件的不同方法以及用于构建这些应用程序的方法。在下一节中，我们将深入了解React如何实现SPA以及React团队为创建这种应用程序风格所做的决定。
- en: Understanding how React helps build SPAs
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解React如何帮助构建单页应用
- en: In this section, we'll learn about React at a high level. This understanding
    will help us build better React-based applications as we'll understand how React
    operates internally.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将以高层次了解React。这种理解将有助于我们构建更好的基于React的应用程序，因为我们将了解React在内部是如何运作的。
- en: As mentioned previously, a website is primarily just an HTML file, which is
    a text-based document. This file contains code that the browser uses to create
    a logical tree called the **Document Object Model** (**DOM**). This tree represents
    all of the HTML elements within the file according to their order and relative
    to other elements in the structure. All websites have a DOM structure on their
    pages, whether they use the SPA style or not. However, React takes advantage of
    the DOM in unique ways in order to help build apps.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，网站主要只是一个HTML文件，这是一个基于文本的文档。这个文件包含浏览器用来创建一个称为**文档对象模型**（**DOM**）的逻辑树的代码。这个树根据它们的顺序和相对于结构中其他元素的位置来表示文件中的所有HTML元素。所有网站都在其页面上有一个DOM结构，无论它们是否使用SPA风格。然而，React以独特的方式利用DOM来帮助构建应用程序。
- en: 'React has two main constructs:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: React有两个主要构造：
- en: React maintains its own virtual DOM at runtime. This virtual DOM is distinct
    from the browser's DOM. It is React's own unique copy of the DOM that it creates
    and maintains based on the instructions from our code. This virtual DOM is created
    and edited as needed based on a reconciliation process that the React service
    does internally. The reconciliation process is a comparison process where React
    looks at the browser DOM and contrasts that with its own virtual DOM. This reconciliation
    process is generally known as the **render phase**. When differences are found—for
    example, the virtual DOM contains an element not contained in the browser DOM—React
    will send instructions to the browser DOM to create that element so that the browser
    DOM and the virtual DOM match. This process of adding, editing, or removing elements
    is known as the **commit phase**.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React在运行时维护自己的虚拟DOM。这个虚拟DOM与浏览器的DOM是不同的。它是React根据我们的代码指令创建和维护的DOM的独特副本。这个虚拟DOM是根据React服务内部执行的协调过程创建和编辑的。协调过程是一个比较过程，React会查看浏览器DOM并将其与自己的虚拟DOM进行对比。这个协调过程通常被称为**渲染阶段**。当发现差异时，例如虚拟DOM包含一个浏览器DOM中没有的元素时，React将向浏览器DOM发送指令，以创建该元素，以使浏览器DOM和虚拟DOM匹配。这个添加、编辑或删除元素的过程被称为**提交阶段**。
- en: The other main attribute of React development is that it is state-driven. In
    React, an application is made up of many components, and in each component, there
    may be some local state (that is, data). If this data changes for any reason,
    React will trigger its reconciliation process and make changes in the DOM if needed.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React开发的另一个主要特点是它是状态驱动的。在React中，一个应用程序由许多组件组成，在每个组件中可能有一些本地状态（即数据）。如果由于任何原因这些数据发生变化，React将触发其协调过程，并在需要时更改DOM。
- en: To make these concepts more concrete, we should take a look at an example of
    a simple React application. But before we do that, let's review what a React application
    is "made of."
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些概念更具体，我们应该看一个简单的React应用程序的例子。但在这之前，让我们回顾一下React应用程序是由什么组成的。
- en: Attributes of a React application
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React应用程序的属性
- en: At its core, a modern React application will need a few base features to function.
    We'll need `npm` to help us manage the application's dependencies. As you've seen
    from our previous exercises, `npm` is a repository that allows us to download
    open source dependencies from a central store and use them in our application.
    We'll also need a tool for doing what's called bundling. A bundling system is
    a service that aggregates all of our script files and assets, such as CSS files,
    and minifies them into a single set of files. The minification process removes
    whitespace and other unneeded text from our scripts so that the files that ultimately
    get downloaded onto user browsers are as small as possible. This smaller payload
    size improves app startup time and improves user experience. The bundling system
    we'll use is called webpack, and we've selected it because it's the industry standard
    for bundling React applications. In addition, we can use `npm`'s built-in script
    system and create scripts to automate some of our work. For example, we can create
    scripts that will start up our test server, run our tests, and build the final
    production version of our app.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，现代React应用程序需要一些基本功能才能运行。我们需要`npm`来帮助我们管理应用程序的依赖关系。正如您从我们之前的练习中看到的，`npm`是一个允许我们从中央存储库下载开源依赖项并在我们的应用程序中使用它们的存储库。我们还需要一个称为捆绑的工具。捆绑系统是一种服务，它聚合我们所有的脚本文件和资产，例如CSS文件，并将它们最小化为一组文件。最小化过程会从我们的脚本中删除空格和其他不需要的文本，以便最终下载到用户浏览器上的文件尽可能小。这种较小的有效载荷大小可以提高应用程序的启动时间并改善用户体验。我们将使用的捆绑系统称为webpack，我们选择它是因为它是捆绑React应用程序的行业标准。此外，我们可以使用`npm`的内置脚本系统并创建脚本来自动化我们的一些工作。例如，我们可以创建脚本来启动我们的测试服务器，运行我们的测试，并构建应用程序的最终生产版本。
- en: 'If we use the `create-react-app` `npm` package, we can get all of the previously
    mentioned dependencies, as well as common dependencies for doing React development
    and some built-in scripts to manage our app. Let''s use this package and create
    our first app:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`create-react-app` `npm`包，我们可以获得所有先前提到的依赖项，以及进行React开发的常见依赖项和一些内置脚本来管理我们的应用程序。让我们使用这个包并创建我们的第一个应用程序：
- en: 'On your terminal or command line, go to the `HandsOnTypescript/Chap4` folder
    and run the following command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端或命令行中，转到`HandsOnTypescript/Chap4`文件夹并运行以下命令：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once this command completes, open VSCode and open the newly created folder,
    `try-react`, which we created at the start of this chapter.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦这个命令完成，打开VSCode并打开新创建的`try-react`文件夹，这是我们在本章开始时创建的。
- en: 'Open the terminal in VSCode and run the following command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VSCode中打开终端并运行以下命令：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Figure 4.1 – try-react'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 - try-react'
- en: '](img/Figure_4.1_B15508.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B15508.jpg)'
- en: Figure 4.1 – try-react
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - try-react
- en: 'Let''s take a look at what `create-react-app` gives us, starting from the top:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从顶部开始看看`create-react-app`给我们提供了什么：
- en: The `build` folder is the destination of all of our bundled and minified final
    production files. They have been shrunken down to be as small as possible and
    debug information has also been removed in order to enhance performance.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`文件夹是所有捆绑和最小化的最终生产文件的目的地。它们已经被缩小到尽可能小，并且调试信息也已被删除以提高性能。'
- en: Next, we have the `node_modules` folder, which contains all of our dependencies
    that we download from the `npm` repository.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有`node_modules`文件夹，其中包含我们从`npm`存储库下载的所有依赖项。
- en: Then, we have the `public` folder, which is a folder for static assets, such
    as the `index.html` file, which will be used to build out our final app.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有`public`文件夹，这是一个用于静态资产的文件夹，例如`index.html`文件，它将用于构建我们的最终应用程序。
- en: Next, we have what is perhaps the most important folder, called `src`. As the
    shortened name implies, this is the folder that contains all of our source scripts.
    Any files with a `.tsx` extension indicate a React component. `.ts` files are
    just plain TypeScript files. Finally, `.css` files have our styling attributes
    (and there can be more than one). `d.ts` files are files that contain TypeScript
    typing information that the compiler uses to determine static type checks it needs
    to do.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，也许最重要的文件夹是`src`。正如缩写的名称所示，这是包含所有源脚本的文件夹。任何扩展名为`.tsx`的文件都表示一个React组件。`.ts`文件只是普通的TypeScript文件。最后，`.css`文件包含我们的样式属性（可能不止一个）。`d.ts`文件包含TypeScript类型信息，编译器用它来确定需要进行的静态类型检查。
- en: Next is the `.gitignore` file. This file is for use with the GitHub code repository
    we are using to save this book's source code. As the name implies, with this file,
    we are telling our `git` system to not upload certain files and folders, but to
    ignore them.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是`.gitignore`文件。这个文件用于GitHub代码存储库，我们正在用它来保存本书的源代码。正如其名称所示，通过这个文件，我们告诉我们的`git`系统不要上传某些文件和文件夹，而是忽略它们。
- en: The `package.json` and `package-lock.json` files are for configuring and setting
    our dependencies. Additionally, they can store configurations for our build, test,
    and run scripts, as well as configurations for the Jest testing framework.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`和`package-lock.json`文件用于配置和设置我们的依赖关系。此外，它们还可以存储我们构建、测试和运行脚本的配置，以及Jest测试框架的配置。'
- en: Finally, we have our `tsconfig.json` file, which we discussed in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025),
    *Exploring TypeScript*. It will configure the TypeScript compiler. Please notice
    that by default, strict mode is turned on, and therefore we cannot use implicit
    `any` or `undefined`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有我们的`tsconfig.json`文件，我们在[*第2章*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025)中讨论过，*探索TypeScript*。它将配置TypeScript编译器。请注意，默认情况下，严格模式已打开，因此我们不能使用隐式的`any`或`undefined`。
- en: 'Now that we''ve done this quick inventory of our project, let''s take a look
    at the contents of some of our files. First, we''ll start with the `package.json`
    file. There are many sections to the `package.json` file, but let''s look at some
    of the most important ones:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速盘点了我们的项目，让我们来看看一些文件的内容。首先，我们将从`package.json`文件开始。`package.json`文件有许多部分，但让我们看一些最重要的部分：
- en: The `dependencies` section contains the libraries that our app will be using
    for certain pieces of functionality. These dependencies include React, as well
    as TypeScript and Jest libraries for doing testing. The `@types` dependencies
    contain the TypeScript definition files. TypeScript definition files store static
    typing information for frameworks that are written in JavaScript. In other words,
    this file tells the TypeScript compiler the shape of the types being used by a
    framework so that type declarations and checking can be done.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`部分包含我们的应用程序将用于某些功能的库。这些依赖包括React，以及用于测试的TypeScript和Jest库。`@types`依赖项包含TypeScript定义文件。TypeScript定义文件存储了JavaScript编写的框架的静态类型信息。换句话说，这个文件告诉TypeScript编译器框架使用的类型的形状，以便进行类型声明和检查。'
- en: There is another dependencies section, called `devDependencies`—although it's
    not used here—which normally stores development time dependencies (as opposed
    to the `dependencies` section, which normally only stores the runtime dependencies).
    For whatever reason, the React team decided to merge the two into `dependencies`.
    Having said that, you should be aware of it as you'll see this section in many
    projects.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有另一个依赖项部分，称为`devDependencies`——虽然这里没有使用——通常存储开发时依赖项（与`dependencies`部分相对，后者通常只存储运行时依赖项）。出于某种原因，React团队决定将两者合并为`dependencies`。话虽如此，你应该意识到这一点，因为你会在许多项目中看到这个部分。
- en: The scripts section is for storing scripts that manage the application. For
    example, the `start` script is used by calling `npm run start`, or `npm start`
    for short. This script is used to start our application using a development server.
    We can also add our own scripts, as we'll do later, for doing things such as deploying
    production files to a server.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本部分用于存储管理应用程序的脚本。例如，`start`脚本通过调用`npm run start`或`npm start`来使用。此脚本用于使用开发服务器启动我们的应用程序。我们还可以添加自己的脚本，稍后将会这样做，用于将生产文件部署到服务器等操作。
- en: Be aware that the projects created by `create-react-app` have been highly modified
    by the React team. They have been optimized by the team and have hidden scripts
    and configurations that are not readily visible—for example, base webpack configurations
    and scripts. If you're curious, you can run `npm run eject` to see what all these
    configurations and scripts are. However, please note that this is not reversible.
    So, you will not be able to undo it. We will not be using an ejected project,
    as there's little benefit in doing so.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由`create-react-app`创建的项目已经被React团队进行了大量修改。它们已经被团队优化，并且隐藏了不容易看到的脚本和配置，例如基本的webpack配置和脚本。如果你感兴趣，你可以运行`npm
    run eject`来查看所有这些配置和脚本。然而，请注意这是不可逆转的。因此，你将无法撤消它。我们不会使用已弹出的项目，因为这样做没有太多好处。
- en: 'Now, let''s look at some of the scripts. Open the `index.tsx` file from the
    `src` folder and you''ll see the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些脚本。从`src`文件夹中打开`index.tsx`文件，你会看到以下内容：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Service workers
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Service workers
- en: Service workers are a way of doing simple threading in JavaScript. We will not
    be using this feature, but it comes as part of the `create-react-app` project,
    so I have left it for completeness.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Service workers是JavaScript中进行简单线程处理的一种方式。我们不会使用这个功能，但它作为`create-react-app`项目的一部分存在，所以我留下它是为了完整性。
- en: 'Again, any file containing a React component that returns JSX will have a `.tsx`
    file extension. We are starting with this file because this is React''s entry
    point for the application. It''s where React starts its runtime build process.
    Now, if we start from the top, we can see that ES6 syntax for importing dependencies
    is being used. React and related modules are being imported, including the core
    `App` module, which we''ll explore shortly. After the imports, we can see that
    `ReactDOM.render` is called, which ultimately "writes out" the HTML of all our
    components combined. It takes two arguments. One is the lowest - level React component
    from which rendering will start and the other is the HTML element used to contain
    the rendered content. As you can see, the `App` component is wrapped with a component
    called `React.StrictMode`. This component is simply an aid to development. When
    compiling in production mode, it has no effect and does not impact performance.
    However, in development mode, it provides extra information about potential issues
    in our code. This may change over time, but here is a list of the current help
    it provides:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，任何包含返回JSX的React组件的文件都将具有`.tsx`文件扩展名。我们从这个文件开始，因为这是React应用程序的入口点。这是React开始其运行时构建过程的地方。现在，如果我们从顶部开始，我们可以看到正在使用ES6语法导入依赖项。导入了React和相关模块，包括核心的`App`模块，我们很快会探索。在导入之后，我们可以看到调用了`ReactDOM.render`，它最终“写出”了所有组件组合的HTML。它接受两个参数。一个是从哪个最低级的React组件开始渲染，另一个是用于包含渲染内容的HTML元素。正如你所看到的，`App`组件被包裹在一个名为`React.StrictMode`的组件中。这个组件只是开发的辅助。在生产模式下编译时，它没有影响，也不会影响性能。然而，在开发模式下，它提供了关于代码潜在问题的额外信息。这可能会随时间而改变，但这里是它目前提供的帮助列表：
- en: 'Identifying components with unsafe life cycles: It will show you if you are
    using unsafe life cycle calls, such as `componentWillMount`, `componentWillReceiveProps`,
    and `componentWillUpdate`. When coding with Hooks, these issues don''t apply,
    but it is good to be aware of them for legacy class-based components.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别具有不安全生命周期的组件：它将向您显示是否正在使用不安全的生命周期调用，例如`componentWillMount`，`componentWillReceiveProps`和`componentWillUpdate`。在使用Hooks编码时，这些问题不适用，但了解传统基于类的组件对它们很有好处。
- en: 'Warning about legacy string ref APIs: The older way of creating a reference
    to an HTML element, as opposed to a React component, was to use a string—for example,
    `<div ref="myDiv">{content}</div>`. Because this method uses a string, it has
    issues and now the preferred method is to use `React.createRef` instead. We''ll
    discuss why you might use a ref in later chapters.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于传统字符串引用API的警告：创建对HTML元素的引用的旧方法，而不是React组件，是使用字符串，例如`<div ref="myDiv">{content}</div>`。因为这种方法使用字符串，它存在问题，现在更倾向于使用`React.createRef`。我们将在后面的章节讨论为什么可能使用引用。
- en: 'Warning about deprecated `findDOMNode` usage: `findDOMNode` is now deprecated
    because it broke abstraction principles. Specifically, it allowed parent components,
    in a component tree, to code for specific child components. This tie-in to code
    implementation means that it becomes difficult to change code later because the
    parent now depends on something existing in its component tree. We discussed object-oriented
    programming principles, including abstraction, in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025),
    *Exploring TypeScript*.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于废弃的`findDOMNode`用法的警告：`findDOMNode`现在已经被废弃，因为它违反了抽象原则。具体来说，它允许父组件在组件树中为特定子组件编写代码。这种与代码实现的关联意味着以后更改代码变得困难，因为父组件现在依赖于其组件树中存在的某些内容。我们在[*第2章*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025)中讨论了面向对象编程原则，包括抽象。
- en: 'Detecting unexpected side effects: Side-effects are unintended consequences
    of our code. For example, if my class component initializes its state in the constructor
    from some other function or property, it would not be acceptable if that state
    sometimes received different values for every initialization. In order to help
    catch these kinds of issues, `React.StrictMode` will run certain life cycle calls,
    such as, for example, the constructor or `getDerivedStateFromProps`, twice to
    try and show whether this type of thing is happening. Note that this only happens
    during development.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测意外副作用：副作用是我们代码的意外后果。例如，如果我的类组件在构造函数中从其他函数或属性初始化其状态，那么如果该状态有时接收不同的值进行初始化，这是不可接受的。为了帮助捕捉这类问题，`React.StrictMode`将运行某些生命周期调用，例如构造函数或`getDerivedStateFromProps`，两次尝试并显示是否发生了这种情况。请注意，这仅在开发过程中发生。
- en: 'Detecting the legacy context API: The context API is a React feature that provides
    a global state across all components of an application. There is a newer version
    of the API and the older one is now deprecated. This checks that you are not using
    the older one.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测旧版上下文API：上下文API是React的一个功能，它提供了应用程序所有组件的全局状态。有一个更新版本的API，旧版本现在已经不推荐使用。这检查您是否在使用旧版本。
- en: Most of the checks being done revolve around the older class-based component
    style. However, since the vast majority of existing code that you will probably
    have to maintain is still written in the older style with classes, it's still
    important to know.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分检查都围绕旧的基于类的组件样式进行。然而，由于您可能需要维护的现有代码绝大部分仍然是用旧样式和类编写的，因此了解这一点仍然很重要。
- en: 'Next, let''s take a look at the `App.tsx` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下`App.tsx`文件：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please note that the JSX syntax, as shown here, is not actually HTML. It is
    custom JavaScript. Therefore, any time there is a potential conflict with JavaScript
    keywords, React uses another name. For example, `class` is a reserved keyword
    in JavaScript. So, React uses `className` instead to represent CSS classes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里显示的JSX语法实际上不是HTML。它是自定义的JavaScript。因此，每当可能与JavaScript关键字发生冲突时，React都会使用另一个名称。例如，`class`是JavaScript中的保留关键字。因此，React使用`className`来表示CSS类。
- en: Although the `index.tsx` file is the main starting point for React, the actual
    components that we will build for our app start in the `App.tsx` file. So, this
    is a very important file for us.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`index.tsx`文件是React的主要起点，但我们将为应用程序构建的实际组件始于`App.tsx`文件。因此，这对我们来说是非常重要的文件。
- en: 'Let''s discuss some items in this code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下这段代码中的一些项目：
- en: First, we are importing React from the React `npm` dependency. If you look inside
    of the `npm_modules` folder, you will find a subfolder called `react`, and that
    folder is what this `import` statement is referring to. Any code imports we did
    not create ourselves will be in the `node_modules` folder.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们从React的`npm`依赖中导入React。如果你查看`npm_modules`文件夹，你会发现一个名为`react`的子文件夹，这个文件夹就是这个`import`语句所指的。我们自己没有创建的任何代码导入都将在`node_modules`文件夹中。
- en: Next is the `logo` import. Image assets are imported into a JavaScript variable—in
    this case, the `logo` variable. Also, as you can see, since this is not an `npm`
    module, it requires a dot reference. `npm` modules do not require a relative path
    because the system is aware of which folder to start looking in, `npm_modules`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是`logo`的导入。图像资源被导入到一个JavaScript变量中，这种情况下是`logo`变量。另外，正如你所看到的，由于这不是一个`npm`模块，它需要一个点引用。`npm`模块不需要相对路径，因为系统知道从哪个文件夹开始查找，`npm_modules`。
- en: Next, we import `App.css`. This file is the styles file and therefore does not
    have an associated JavaScript variable to it. Since it is not an `npm` package,
    it also requires a relative path.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们导入`App.css`。这个文件是样式文件，因此没有与之关联的JavaScript变量。由于它不是一个`npm`包，所以它还需要一个相对路径。
- en: The `App` component is a functional component, as shown by its syntax. The `App`
    component is the root parent component for the entire application. This component
    has no state of its own and just renders out content. So, the `return` statement
    is the rendered content and it is using **JSX**.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App`组件是一个函数组件，如其语法所示。`App`组件是整个应用程序的根父组件。该组件本身没有状态，只是渲染内容。因此，`return`语句是渲染的内容，它使用**JSX**。'
- en: We'll go into much more detail about what JSX is in later chapters; however,
    for now, JSX is HTML-like syntax written in JavaScript. It was created by the
    React team to make it easier and clearer to create HTML content with React components.
    The main thing to note is that although it looks almost identical to HTML, it
    is not really HTML and therefore there are some differences in the way it works.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中详细讨论JSX是什么；但是，现在，JSX是用JavaScript编写的类似HTML的语法。它是由React团队创建的，旨在使使用React组件创建HTML内容更容易和更清晰。需要注意的主要事项是，尽管它看起来几乎与HTML相同，但它实际上并不是HTML，因此在工作方式上存在一些差异。
- en: The style reference to CSS classes, which is normally set as `class`, is set
    as `className`, as shown in the code. This is because `class` is a JavaScript
    keyword and so cannot be used here.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对CSS类的样式引用，通常设置为`class`，现在设置为`className`，如代码所示。这是因为`class`是JavaScript关键字，因此不能在这里使用。
- en: Squiggly brackets indicate code is being passed, not strings. For example, the
    `img` tag's `src` attribute takes a JavaScript variable, `logo`, as its value,
    and also that value is inside of squiggly brackets. To pass strings, use quotes.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号表示正在传递代码，而不是字符串。例如，`img`标签的`src`属性接受JavaScript变量`logo`作为其值，并且该值也在花括号内。要传递字符串，请使用引号。
- en: 'Let''s start our app in development mode to see what this basic screen looks
    like. Run the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以开发模式启动我们的应用程序，看看这个基本屏幕是什么样子。运行以下命令：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you run the previous command, you should see the following screen in your
    browser:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令后，你应该在浏览器中看到以下屏幕：
- en: '![Figure 4.2 – App start'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 应用程序启动'
- en: '](img/Figure_4.2_B15508.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2_B15508.jpg)'
- en: Figure 4.2 – App start
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 应用程序启动
- en: As you can see, the text and logo from our `App.tsx` file is showing up, since
    this is the main starting component of our application. Once we start coding,
    we will leave this server running, and when we save any script files, the page
    will automatically update, allowing us to see our changes in real time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，来自我们的`App.tsx`文件的文本和标志正在显示，因为这是我们应用程序的主要起始组件。一旦我们开始编码，我们将让这个服务器保持运行状态，当我们保存任何脚本文件时，页面将自动更新，让我们实时看到我们的更改。
- en: 'To get a better feel for building components in React, as well as how React
    routing works, let''s create our first simple component:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解在React中构建组件以及React路由是如何工作的，让我们创建我们的第一个简单组件：
- en: 'Create a new file in the `src` folder called `Home.tsx` and add the following
    code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个名为`Home.tsx`的新文件，并添加以下代码：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, as you can see, we are creating a component called `Home` that returns
    a `div` tag with the words `Hello World!`. You should also notice that we are
    using the `FC`, functional component, declaration to type our component. Functional
    components are the only way of creating components when using React Hooks, as
    opposed to the older class style. This is because the React team believes composition
    works better as a means of doing code reuse than inheritance. But do notice that
    the importance of having code reuse, whatever the method, is still there.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如你所见，我们正在创建一个名为`Home`的组件，它返回一个带有`Hello World!`字样的`div`标签。你还应该注意到，我们使用了`FC`，函数组件，声明来为我们的组件进行类型定义。在使用React
    Hooks时，函数组件是创建组件的唯一方式，而不是旧的类样式。这是因为React团队认为组合作为代码重用的手段比继承更有效。但请注意，无论采用何种方法，代码重用的重要性仍然存在。
- en: 'Now, in order to get our component to show on the screen, we need to add it
    to our `App.tsx` file. But let''s also add routing to our app and explore that
    as well. First, update the `index.tsx` file like this:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了让我们的组件显示在屏幕上，我们需要将它添加到我们的`App.tsx`文件中。但让我们也为我们的应用程序添加路由并探索一下。首先，像这样更新`index.tsx`文件：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `index.tsx` file now has a component called `BrowserRouter`. This component
    is part of React Router and is the base component that allows routing to happen
    across the application. Since it wraps our `App` component, and the rest of the
    application lives inside of this `App` component, it means routing services are
    being provided for the entire application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.tsx`文件现在有一个名为`BrowserRouter`的组件。这个组件是React Router的一部分，是一个基础组件，允许整个应用程序进行路由。由于它包裹了我们的`App`组件，而应用程序的其余部分都存在于这个`App`组件内部，这意味着整个应用程序都提供了路由服务。'
- en: 'Since we will be using React Router, let''s also create a component for a second
    route, called `AnotherScreen`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用React Router，让我们也为第二个路由创建一个名为`AnotherScreen`的组件：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, update the `App.tsx` file like this:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，像这样更新`App.tsx`文件：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you left `npm start` running, you should see **Hello World!** Home, as follows:![Figure
    4.3 – Home
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你让`npm start`保持运行状态，你应该会看到**Hello World!** Home，如下所示：![图4.3 – 主页
- en: '](img/Figure_4.3_B15508.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B15508.jpg)'
- en: Figure 4.3 – Home
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 主页
- en: 'If you look at the URL, you can see that it is on the root of the site. Let''s
    try switching the URL to `http://localhost:3000/another`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看一下URL，你会发现它在站点的根目录上。让我们尝试将URL切换到`http://localhost:3000/another`：
- en: '![Figure 4.4 – Another screen'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – 另一个屏幕'
- en: '](img/Figure_4.4_B15508.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B15508.jpg)'
- en: Figure 4.4 – Another screen
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 另一个屏幕
- en: As you can see, it loaded the `AnotherScreen` component, as per our instructions
    to load that component for this specific URL.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它加载了`AnotherScreen`组件，根据我们的指示加载了该组件用于特定URL。
- en: 'Additionally, if you open your Chrome browser debugger, you will see that no
    network calls to that specific path were actually made. Again, this confirms that
    React Router is not doing any postbacks for these paths and they only exist on
    the browser locally:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你打开Chrome浏览器的调试器，你会发现实际上没有网络调用到该特定路径。再次确认了React Router对这些路径没有进行任何后台处理，它们只存在于浏览器本地：
- en: '![Figure 4.5 – Chrome debugger'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – Chrome调试器'
- en: '](img/Figure_4.5_B15508.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5_B15508.jpg)'
- en: Figure 4.5 – Chrome debugger
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – Chrome调试器
- en: This was just a quick example of building a React app and components just to
    get us started.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个快速的例子，用于构建React应用程序和组件，让我们开始。
- en: In this section, we learned how React works internally and how to set up a React
    project. This knowledge will be valuable in the coming chapters as we begin to
    build out our application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了React的内部工作原理以及如何设置React项目。随着我们开始构建我们的应用程序，这些知识将在接下来的章节中变得有价值。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about how websites were built in the early days
    of the web. We also learned about some of the limitations of the older style of
    web development and how SPA applications attempt to overcome them. We saw how
    a SPA application's main driver is to make web apps behave more like native applications.
    Finally, we got an introduction to React development and building components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了早期网站是如何构建的。我们还了解了旧式网页开发的一些局限性，以及SPA应用程序是如何试图克服它们的。我们看到了SPA应用程序的主要驱动力是使Web应用程序更像本机应用程序。最后，我们对React开发和构建组件有了一个简介。
- en: In the next chapter, we'll build upon this knowledge and go into React component
    building in more depth. We'll look at class-based components and compare and contrast
    them to the newer Hook-style components. The things we've learned so far about
    web development and React-based web development will help us to better understand
    this next chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在这些知识的基础上深入探讨React组件的构建。我们将研究基于类的组件，并将它们与更新的Hook-style组件进行比较和对比。到目前为止，我们所学到的关于Web开发和基于React的Web开发的知识将帮助我们更好地理解下一章。
