- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Deploying Node.js Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Node.js微服务
- en: The term **microservices** is used to describe applications that have been built
    based on the microservice architecture paradigm. This architecture encourages
    larger applications to be built as a set of smaller modular applications, where
    each application focuses on one key concern. Microservice architectures are a
    contrast to the monolithic architectures of the past. **Monolith** is a term given
    to an application that handles many disparate concerns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**这一术语用于描述基于微服务架构范式构建的应用程序。这种架构鼓励将大型应用程序构建为一系列较小的模块化应用程序，每个应用程序专注于一个关键关注点。微服务架构与过去的单体架构形成对比。**单体**是指处理许多不同关注点的应用程序的术语。'
- en: There are numerous benefits to adopting a microservice architecture. Ensuring
    that an application only serves one purpose means that the application can be
    optimized to best serve that purpose. Microservices help to decouple various parts
    of a system, which can result in easier debuggability if something goes wrong.
    Adopting a microservice architecture also enables you to scale different parts
    of the system independently.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 采用微服务架构有许多好处。确保应用程序只服务于一个目的意味着应用程序可以被优化以最好地服务于该目的。微服务有助于解耦系统的各个部分，如果出现问题，这可以导致更容易的调试。采用微服务架构还使您能够独立扩展系统的不同部分。
- en: There are not only technical benefits to adopting a microservice architecture.
    Separating microservices into separate code bases can enable smaller teams to
    have autonomy over the microservices they’re responsible for. Many microservice-based
    systems are written in a variety of frameworks and languages. Development teams
    can choose the language and framework they feel is best suited for their microservice.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 采用微服务架构不仅具有技术上的好处。将微服务分离到单独的代码库可以使较小的团队能够对其负责的微服务拥有自主权。许多基于微服务的系统是用各种框架和语言编写的。开发团队可以选择他们认为最适合其微服务的语言和框架。
- en: Microservices can, however, increase complexity due to the management of multiple
    services, which requires mature DevOps practices and comprehensive monitoring.
    For this reason, microservices are often not suitable for simple applications
    where the management overhead outweighs the benefits.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于需要管理多个服务，微服务可能会增加复杂性，这需要成熟的DevOps实践和全面的监控。因此，微服务通常不适用于管理开销大于其益处的简单应用程序。
- en: Node.js microservices commonly expose **RESTful** APIs. **Representational State
    Transfer** ( **REST** ) is very popular. A RESTful API exposes its API via HTTP,
    making appropriate use of the HTTP verbs. For example, if a blogging service exposed
    a RESTful API, you’d expect it to expose an endpoint to which you could send an
    HTTP GET request to retrieve a blog post. Similarly, it would likely expose an
    endpoint to which you could send an HTTP POST request, with data, to publish new
    blogs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js微服务通常公开**RESTful** API。**表示状态转移**（**REST**）非常流行。RESTful API通过HTTP公开其API，并适当使用HTTP动词。例如，如果博客服务公开了RESTful
    API，您会期望它公开一个端点，您可以通过发送HTTP GET请求来检索博客文章。同样，它可能还会公开一个端点，您可以通过发送带有数据的HTTP POST请求来发布新的博客。
- en: Microservices and container technologies go hand in hand. Cloud and container
    technologies are growing in adoption, with Docker and Kubernetes, which are the
    leading choices for deploying microservice-based applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和容器技术相辅相成。云和容器技术的采用率正在增长，其中Docker和Kubernetes是部署基于微服务的应用程序的首选。
- en: 'This chapter contains the following recipes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下食谱：
- en: Generating a microservice with LoopBack
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LoopBack生成微服务
- en: Consuming a microservice
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费微服务
- en: Building a Docker container
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Docker容器
- en: Publishing a Docker image
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布Docker镜像
- en: Deploying to Kubernetes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到Kubernetes
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have Node.js installed, preferably the latest version – Node.js
    22. You’ll also need access to an editor and browser of your choice.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装Node.js，最好是最新版本——Node.js 22。您还需要访问您选择的编辑器和浏览器。
- en: Before completing this chapter, it is recommended that you have some understanding
    of HTTP protocols – you can refer to [*Chapter 4*](B19212_04.xhtml#_idTextAnchor100)
    .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，建议您对HTTP协议有所了解——您可以参考[*第4章*](B19212_04.xhtml#_idTextAnchor100)。
- en: The latter three recipes of this chapter will require you to have **Docker for
    Desktop** installed. It is recommended to install Docker for Desktop from [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    .
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的后三个食谱需要您已安装 **Docker for Desktop**。建议您从 [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    安装 Docker for Desktop。
- en: The recipe code for this chapter can be found at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    in the **Chapter11** folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的食谱代码可以在 [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    的 **Chapter11** 文件夹中找到。
- en: Generating a microservice with LoopBack
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LoopBack 生成微服务
- en: '**LoopBack** ( [https://loopback.io/](https://loopback.io/) ) is an extensible
    open source Node.js framework that is purpose-built for creating REST APIs and
    microservices. Early versions of LoopBack were both inspired by and based directly
    on the Express.js web framework. The most recent version, LoopBack 4, went through
    a significant refactor and was rewritten in TypeScript. This refactor allowed
    the maintainers to expand the features of LoopBack without being restricted by
    the technical implementation decisions made in prior versions.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**LoopBack** ( [https://loopback.io/](https://loopback.io/) ) 是一个可扩展的开源 Node.js
    框架，专为创建 REST API 和微服务而构建。LoopBack 的早期版本既受到了 Express.js 网络框架的启发，又直接基于该框架。最新版本 LoopBack
    4 经历了重大重构，并使用 TypeScript 重新编写。这次重构使得维护者能够在不受先前版本中做出的技术实现决策限制的情况下扩展 LoopBack 的功能。'
- en: In this recipe, we’re going to use the LoopBack 4 **Command-Line Interface**
    ( **CLI** ) to generate a Node.js microservice.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用 LoopBack 4 **命令行界面** ( **CLI** ) 来生成一个 Node.js 微服务。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To prepare for the recipe, we need to globally install the LoopBack CLI. Enter
    the following command in your terminal:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备食谱，我们需要全局安装 LoopBack CLI。在您的终端中输入以下命令：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have globally installed the LoopBack CLI, let’s move on to the recipe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经全局安装了 LoopBack CLI，让我们继续到食谱。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we’re going to generate a RESTful API, which will form our
    Node.js microservice. The RESTful API that we will create will mimic a bookstore
    inventory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将生成一个 RESTful API，这将形成我们的 Node.js 微服务。我们将创建的 RESTful API 将模仿书店库存：
- en: 'The LoopBack CLI should be available in your path as **lb4** . To start generating
    the project, we call the LoopBack CLI, providing a project name. Let’s give our
    project the name **loopback-bookstore** . Enter the following command in your
    terminal:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LoopBack CLI 应该作为 **lb4** 可用在你的路径中。要开始生成项目，我们调用 LoopBack CLI，提供一个项目名称。让我们将我们的项目命名为
    **loopback-bookstore**。在您的终端中输入以下命令：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Entering the command will start an interactive interface where the LoopBack
    CLI will request information for your new project. For the project description,
    project root directory, and application class name, just hit *Enter* to accept
    the default names.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入命令将启动一个交互式界面，其中 LoopBack CLI 将请求您新项目的信息。对于项目描述、项目根目录和应用程序类名，只需按 *Enter* 键接受默认名称。
- en: The fourth CLI question asks the user which features should be enabled in the
    project. Hit *Enter* to enable all features. If you are shown a subsequent command
    detailing that Yarn is available, enter **N** to indicate we do not wish to enable
    it by default.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个 CLI 问题会询问用户在项目中应启用哪些功能。按 *Enter* 键启用所有功能。如果您看到一个后续命令详细说明 Yarn 可用，请输入 **N**
    以表示我们不希望默认启用它。
- en: 'You should now see the LoopBack CLI scaffolding your application. Expect to
    see output starting with the following in your terminal window, detailing files
    and directories that have been created:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在应该看到 LoopBack CLI 在构建您的应用程序。在终端窗口中，您应该期望看到以下输出开始，详细说明已创建的文件和目录：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The LoopBack CLI has now generated our application. It should have also automatically
    installed our **npm** dependencies. Navigate to the application directory and
    start the application with the following commands:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LoopBack CLI 已经生成了我们的应用程序。它也应该已经自动安装了我们的 **npm** 依赖项。导航到应用程序目录，并使用以下命令启动应用程序：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you navigate to **http://localhost:3000** in your browser, you should expect
    to see the application running:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在浏览器中导航到 **http://localhost:3000**，您应该期望看到应用程序正在运行：
- en: '![Figure 11.1 – The generated LoopBack home page for the LoopBack bookstore
    application](img/Figure_11.1_B19212.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – LoopBack 书店应用程序生成的 LoopBack 主页](img/Figure_11.1_B19212.jpg)'
- en: Figure 11.1 – The generated LoopBack home page for the LoopBack bookstore application
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – LoopBack书店应用程序生成的LoopBack主页
- en: 'Go back to your terminal and press *Ctrl* + *C* to stop the application. So
    far, the LoopBack CLI has just generated a barebones project structure. Now we
    can build our bookstore API. We can do this using LoopBack’s model generator.
    Enter the following command to start creating a model:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回您的终端并按*Ctrl* + *C*停止应用程序。到目前为止，LoopBack CLI刚刚生成了一个基本的工程结构。现在我们可以构建我们的书店API。我们可以使用LoopBack的模型生成器来完成此操作。输入以下命令以开始创建模型：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'LoopBack’s model generator will open an interactive CLI where we can define
    the model and its properties. The model we want to create is a book of the **Entity**
    type. First, add the **id** property, which will be a number. You’ll also need
    to add **author** and **title** properties to the model, which should both be
    mandatory and of the string type. Enter these via the interactive session. The
    transcript of the session should look like the following:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LoopBack的模型生成器将打开一个交互式CLI，我们可以定义模型及其属性。我们想要创建的是一个**实体**类型的书籍。首先，添加**id**属性，它将是一个数字。您还需要向模型中添加**author**和**title**属性，这两个属性都应该是必填的，并且是字符串类型。通过交互会话输入这些属性。会话的转储应该看起来如下所示：
- en: '![Figure 11.2 – An overview of the expected transcript of the LoopBack model
    generator](img/Figure_11.2_B19212.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – LoopBack模型生成器预期转储的概述](img/Figure_11.2_B19212.jpg)'
- en: Figure 11.2 – An overview of the expected transcript of the LoopBack model generator
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – LoopBack模型生成器预期转储的概述
- en: 'Now that we’ve created our model, we need to create our data source using LoopBack’s
    data source CLI. Enter the following command in your terminal window:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的模型，我们需要使用LoopBack的数据源CLI创建我们的数据源。在您的终端窗口中输入以下命令：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The interactive CLI will request information about the data source. We’re going
    to use an in-memory data store. The values you should supply should be **Data
    source name: local** and **In-memory DB** . For the last two questions, hit *Enter*
    to accept the defaults. Expect the transcript of your session to match the following:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交互式CLI将请求有关数据源的信息。我们将使用内存数据存储。您应该提供的值应该是**数据源名称：local**和**内存数据库**。对于最后两个问题，按*Enter*键接受默认设置。期望您的会话转储与以下内容匹配：
- en: '![Figure 11.3 – An overview of the transcript of the LoopBack data source generator](img/Figure_11.3_B19212.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – LoopBack数据源生成器转储的概述](img/Figure_11.3_B19212.jpg)'
- en: Figure 11.3 – An overview of the transcript of the LoopBack data source generator
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – LoopBack数据源生成器转储的概述
- en: 'Next, we need to create a LoopBack repository. This is a LoopBack class that
    binds the data source and the model. Enter the following command to start the
    repository generator interface:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个LoopBack存储库。这是一个将数据源和模型绑定的LoopBack类。输入以下命令以启动存储库生成器界面：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the repository, we want to use **LocalDatasource** for the **Book** model
    with a **DefaultCrudRepository** base class. The terminal should match the following
    output:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于存储库，我们希望为**Book**模型使用**LocalDatasource**，并基于**DefaultCrudRepository**基类。终端应该匹配以下输出：
- en: '![Figure 11.4 – Expected transcript of the LoopBack repository generator](img/Figure_11.4_B19212.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – LoopBack存储库生成器预期的转储](img/Figure_11.4_B19212.jpg)'
- en: Figure 11.4 – Expected transcript of the LoopBack repository generator
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – LoopBack存储库生成器预期的转储
- en: 'Now, we need to create a LoopBack controller. A LoopBack controller handles
    the API requests and responses. Enter the following command to start the controller
    generator interface:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个LoopBack控制器。LoopBack控制器处理API请求和响应。输入以下命令以启动控制器生成器界面：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our controller should be a **REST Controller with Create, Read, Update, and
    Delete** ( **CRUD** ) **functions** named **Books** . For the remainder of the
    questions, you can accept the defaults by hitting *Enter* . The terminal should
    look as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的控制器应该是一个名为**Books**的**REST控制器**，具有创建、读取、更新和删除（**CRUD**）**功能**。对于剩余的问题，您可以通过按*Enter*键接受默认设置。终端应该看起来如下所示：
- en: '![Figure 11.5 – An overview of the transcript of the LoopBack controller generator](img/Figure_11.5_B19212.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – LoopBack控制器生成器转储的概述](img/Figure_11.5_B19212.jpg)'
- en: Figure 11.5 – An overview of the transcript of the LoopBack controller generator
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – LoopBack控制器生成器转储的概述
- en: 'Start the application with **$ npm start** and navigate to **http://localhost:3000/explorer/**
    . This will open up the LoopBack API explorer that we can use to test our API.
    Observe that the routes for various HTTP verbs have been automatically generated
    for us:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **$ npm start** 启动应用程序，并导航到 **http://localhost:3000/explorer/**。这将打开 LoopBack
    API 探索器，我们可以使用它来测试我们的 API。观察到的各种 HTTP 动词的路由已自动为我们生成：
- en: '![Figure 11.6 – LoopBack API Explorer for the loopback-bookstore application](img/Figure_11.6_B19212.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – loopback-bookstore 应用程序的 LoopBack API 探索器](img/Figure_11.6_B19212.jpg)'
- en: Figure 11.6 – LoopBack API Explorer for the loopback-bookstore application
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – loopback-bookstore 应用程序的 LoopBack API 探索器
- en: 'Navigate to the HTTP POST route in the explorer. Clicking the **Try it out**
    button will open an interface where you will be able to add a book to the inventory.
    Change the sample **title** and **author** values and then click **Execute** :'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在探索器中导航到 HTTP POST 路由。点击 **尝试一下** 按钮将打开一个界面，您可以在其中将书籍添加到库存中。更改示例 **标题** 和 **作者**
    值，然后点击 **执行**：
- en: '![Figure 11.7 – LoopBack API Explorer request interface](img/Figure_11.7_B19212.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – LoopBack API 探索器请求界面](img/Figure_11.7_B19212.jpg)'
- en: Figure 11.7 – LoopBack API Explorer request interface
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – LoopBack API 探索器请求界面
- en: 'Navigate to **http://localhost:3000/books** . This route will return a JSON
    array of all of the books stored. Expect to see the book that we added in the
    previous step:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **http://localhost:3000/books**。此路由将返回存储的所有书籍的 JSON 数组。预期将看到我们在上一步添加的书籍：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve generated a RESTful API that represents a bookstore inventory using the
    LoopBack CLI.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 LoopBack CLI 生成了一个表示书店库存的 RESTful API。
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The recipe demonstrated how to build a RESTful API for a sample bookstore inventory.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例演示了如何为示例书店库存构建 RESTful API。
- en: 'The first command we supplied to the generator was **$ lb4 loopback-bookstore**
    . This command scaffolds a LoopBack project structure for our application. In
    the recipe, we enabled all the following optional features:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供给生成器的第一个命令是 **$ lb4 loopback-bookstore**。此命令为我们的应用程序构建 LoopBack 项目结构。在示例中，我们启用了以下所有可选功能：
- en: '**ESLint** : A popular linter with some pre-defined linter rules'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ESLint**：一个流行的代码检查器，具有一些预定义的代码检查规则'
- en: '**Prettier** : A popular code formatter that is used throughout the examples
    in this book'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prettier**：一个流行的代码格式化工具，本书中的示例都使用了它'
- en: '**Mocha** : A Node.js test framework'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mocha**：一个 Node.js 测试框架'
- en: '**Loopback Build** : A set of LoopBack build helpers, exposed via the **@**
    **loopback/build** module'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Loopback Build**：一组 LoopBack 构建助手，通过 **@loopback/build** 模块公开'
- en: '**VSCode** : Configuration files for the VSCode editor'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode**：VSCode 编辑器的配置文件'
- en: '**Docker** : Generates **Dockerfile** and **.dockerignore** for the application'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：为应用程序生成 **Dockerfile** 和 **.dockerignore**'
- en: '**Repositories** : Enables convenience methods that can automatically bind
    repository classes'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储库**：启用方便的方法，可以自动绑定存储库类'
- en: '**Services** : Includes service-proxy imports (refer to [https://loopback.io/doc/en/lb4/Service.html](https://loopback.io/doc/en/lb4/Service.html)
    for more information on services)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：包括服务代理导入（有关服务的更多信息，请参阅 [https://loopback.io/doc/en/lb4/Service.html](https://loopback.io/doc/en/lb4/Service.html)）'
- en: Once the optional features were selected, the LoopBack CLI generated a base
    application structure. This structure includes directories and files related to
    the optional features that were selected. For example, the **eslintrc.js** and
    **mocharc.js** files were generated to configure ESLint and Mocha.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了可选功能，LoopBack CLI 将生成基础应用程序结构。此结构包括与所选可选功能相关的目录和文件。例如，生成了 **eslintrc.js**
    和 **mocharc.js** 文件来配置 ESLint 和 Mocha。
- en: We used the LoopBack model generator to create representations of the data we
    needed to store. In our case, we created one model named **Book** that contained
    the data we wished to store for each book. The LoopBack generator assisted us
    in adding these properties, including specifying which type the properties should
    be and whether they are required or optional properties. In larger and more complex
    APIs, it’s common to have multiple models, where some models may reference others,
    in a comparable manner to how relational databases are structured.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 LoopBack 模型生成器创建了我们需要存储的数据表示。在我们的例子中，我们创建了一个名为 **Book** 的模型，其中包含我们希望为每本书存储的数据。LoopBack
    生成器帮助我们添加了这些属性，包括指定属性的类型以及它们是否为必需或可选属性。在更大和更复杂的 API 中，通常会有多个模型，其中一些模型可能引用其他模型，类似于关系数据库的结构。
- en: The model generator created our **Book** model in **src/models/book.model.ts**
    . The model file contains a representation of a book in the form of a TypeScript
    class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 模型生成器在**src/models/book.model.ts**中创建了我们的**Book**模型。模型文件包含了一个以TypeScript类形式表示的书籍。
- en: After creating the model, we used the LoopBack data source generator to create
    a data source. We opted to use an in-memory data source to avoid the need to provision
    an instance of a database. Using an in-memory data source means that by default,
    when we stop our API from running, the data is lost. LoopBack handles data source
    integrations, removing the need for the developer to create and set up the data
    store connection. For the most part, this means the developer will not need to
    write code that is specific to the data store, making it easier to change between
    data stores.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模型后，我们使用LoopBack数据源生成器创建了一个数据源。我们选择使用内存数据源以避免需要配置数据库实例。使用内存数据源意味着默认情况下，当我们停止API运行时，数据将丢失。LoopBack处理数据源集成，消除了开发者创建和设置数据存储连接的需要。在大多数情况下，这意味着开发者不需要编写特定于数据存储的代码，这使得在数据存储之间切换变得更加容易。
- en: With LoopBack 4, it is necessary to create a repository for our **Book** model.
    A repository acts as an interface to a model, providing strong-typed data operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LoopBack 4，为我们的**Book**模型创建一个存储库是必要的。存储库充当模型的一个接口，提供强类型的数据操作。
- en: The final step of the recipe involved generating a controller to handle API
    requests and responses. We instructed the generator to create a REST Controller
    with CRUD functions for the **Book** model. **CRUD** covers the four basic functions
    that enable persistent storage.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱的最后一步涉及生成一个控制器来处理API请求和响应。我们指示生成器为**Book**模型创建一个具有CRUD功能的REST控制器。**CRUD**涵盖了四个基本功能，这些功能使持久化存储成为可能。
- en: 'The **Book** controller was created at **src/controllers/books.controller.ts**
    and contains generated functions to handle each REST API operation for our **Book**
    model. For example, the following code was generated in the controller to handle
    an HTTP GET request on the **/books** route. This route returns all books in the
    data store:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**Book**控制器在**src/controllers/books.controller.ts**中创建，并包含用于处理我们的**Book**模型的每个REST
    API操作的生成函数。例如，以下代码在控制器中生成以处理对**/books**路由的HTTP GET请求。此路由返回数据存储中的所有书籍：'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The controller, repositories, and data sources that were created are all loaded
    and bound to the application at boot time. This is handled by the **@** **loopback/boot**
    module.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的控制器、存储库和数据源在启动时都会被加载并绑定到应用程序上。这由**@loopback/boot**模块处理。
- en: In the final part of the recipe, we used the API explorer ( **http://localhost:3000/explorer/**
    ) to send requests to our API. The route explorer displays the available routes
    and provides sample requests for each route, allowing for an intuitive way to
    test your API. This explorer is implemented using Swagger UI ( [https://swagger.io/](https://swagger.io/)
    ).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱的最后部分，我们使用了API探索器（**http://localhost:3000/explorer/**）向我们的API发送请求。路由探索器显示了可用的路由并为每个路由提供了示例请求，允许以直观的方式测试您的API。此探索器使用Swagger
    UI（[https://swagger.io/](https://swagger.io/)）实现。
- en: LoopBack also allows for the generation of an OpenAPI specification document
    for the API, providing a standard interface for the RESTful API that includes
    human- and machine-readable definitions of the API routes. This can be achieved
    by running the **npm run openapi-spec ./open-api.json** command, which will create
    an **open-api.json** file containing the OpenAPI specification.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: LoopBack还允许为API生成OpenAPI规范文档，为RESTful API提供了一个标准接口，包括API路由的人机和机器可读定义。这可以通过运行**npm
    run openapi-spec ./open-api.json**命令实现，该命令将创建一个包含OpenAPI规范的**open-api.json**文件。
- en: This recipe highlighted that it is possible to generate a RESTful Node.js API
    without writing any code. Once your base API has been generated, it would then
    be possible to extend the application with any necessary business logic. LoopBack
    abstracts and handles some of the common technical tasks related to creating APIs,
    such as implementing CRUD operations. This enables developers to focus on the
    business logic of their microservice, rather than underlying and repetitive technical
    implementations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱强调了生成RESTful Node.js API而无需编写任何代码是可能的。一旦您的基API生成，就可以扩展应用程序以包含任何必要的业务逻辑。LoopBack抽象并处理与创建API相关的某些常见技术任务，例如实现CRUD操作。这使得开发者能够专注于其微服务的业务逻辑，而不是底层和重复的技术实现。
- en: See also
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19212_06.xhtml#_idTextAnchor178)'
- en: The *Consuming a microservice* recipe in this chapter
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *消费微服务* 菜单
- en: Consuming a microservice
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费微服务
- en: In this recipe, we will create an Express.js web application that will consume
    the **loopback-bookstore** microservice created in the previous recipe, *Generating
    a microservice with LoopBack* . This will demonstrate how modern web architectures
    are implemented based on the microservice pattern.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个 Express.js 网络应用程序，该应用程序将消费在之前的菜谱 *使用 LoopBack 生成微服务* 中创建的 **loopback-bookstore**
    微服务。这将展示现代网络架构是如何基于微服务模式实现的。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will be consuming the microservice created in the *Generating
    a microservice with LoopBack* recipe. If you have not completed that recipe, you
    can obtain the code from the Packt GitHub repository at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    in the **Chapter11/loopback-bookstore** directory.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将消费在 *使用 LoopBack 生成微服务* 菜谱中创建的微服务。如果您尚未完成该菜谱，您可以从 Packt GitHub 仓库的
    [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    中的 **Chapter11/loopback-bookstore** 目录中获取代码。
- en: We will also be creating a frontend web application, using the Express.js generator
    to create a base for our web application. For more information on the Express.js
    generator, visit [https://expressjs.com/en/starter/generator.html](https://expressjs.com/en/starter/generator.html)
    .
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个前端网络应用程序，使用 Express.js 生成器为我们的网络应用程序创建基础。有关 Express.js 生成器的更多信息，请访问
    [https://expressjs.com/en/starter/generator.html](https://expressjs.com/en/starter/generator.html)
    。
- en: 'Enter the following commands in your terminal to create the base application
    using the Express.js generator:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中输入以下命令以使用 Express.js 生成器创建基本应用程序：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will be creating a route and HTML form to add a book to the bookstore inventory.
    Let’s create the files for those in advance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个路由和 HTML 表单来添加书籍到书店库存。让我们提前创建这些文件：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have a base Express.js web application, we’re ready to move on to
    the recipe steps, where we’ll extend the application to interact with the bookstore
    inventory microservice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个基本的 Express.js 网络应用程序，我们可以继续到菜谱步骤，我们将扩展应用程序以与书店库存微服务交互。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We’re going to build a web application with Express.js that consumes our **loopback-bookstore**
    microservice. The web application should enable us to view the inventory and add
    a book to the inventory:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Express.js 构建一个网络应用程序，该应用程序将消费我们的 **loopback-bookstore** 微服务。该网络应用程序应使我们能够查看库存并添加书籍到库存：
- en: 'Start by adding two routes to the application. The first route we will add
    is a **/inventory** route that will accept an HTTP GET request. This route will
    respond with a list of books in the inventory and an HTML form that can be used
    to add a book to the inventory. The second route will accept an HTTP POST request
    on the **/inventory/add** endpoint. The **/inventory/add** route will interact
    with the bookstore inventory microservice to persist a new book. Add the following
    to **routes/inventory.j s** to create these two routes:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向应用程序添加两个路由。我们将添加的第一个路由是 **/inventory** 路由，它将接受 HTTP GET 请求。此路由将返回库存中的书籍列表以及一个可以用来添加书籍到库存的
    HTML 表单。第二个路由将接受在 **/inventory/add** 端点的 HTTP POST 请求。**/inventory/add** 路由将与书店库存微服务交互以持久化新书。将以下内容添加到
    **routes/inventory.js** 中以创建这两个路由：
- en: '[PRE12]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, in **app.js** , we need to register our new **inventory** router. Add
    the following line to **app.js** to first import the router using **var** to be
    consistent with the rest of the generated file. Add the following just below the
    other router imports:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 **app.js** 中，我们需要注册我们的新 **inventory** 路由器。将以下行添加到 **app.js** 中，首先使用 **var**
    导入路由器，以保持与生成的其他文件的兼容性。在以下其他路由导入下方添加以下内容：
- en: '[PRE13]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to instruct our Express.js application to use the **inventory**
    router. Add the following line below **app.use(''/users'', usersRouter);** :'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要指导我们的 Express.js 应用程序使用 **inventory** 路由器。在 **app.use('/users', usersRouter);**
    下方添加以下行：
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our inventory routes reference an **Embedded JavaScript** ( **EJS** ) template
    file named **inventory.ejs** . This template file will output a list of all books
    stored in the inventory and expose a form we can use to add books to the inventory.
    Add the following to the **views/inventory.ejs** file we created in the *Getting
    started* section of this recipe:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的库存路由引用了一个名为**嵌入式JavaScript**（**EJS**）的模板文件，名为**inventory.ejs**。此模板文件将输出库存中存储的所有书籍列表，并暴露一个我们可以用来向库存添加书籍的表单。将以下内容添加到我们在本菜谱*入门*部分创建的**views/inventory.ejs**文件中：
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Start your **loopback-bookstore** microservice from the previous recipe. Do
    this from within the **loopback-bookstore** directory:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个菜谱中启动您的**loopback-bookstore**微服务。请在**loopback-bookstore**目录内执行此操作：
- en: '[PRE16]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, in a separate terminal window, start the **bookstore-web-app** application
    with the following command. We’ll also pass a **PORT** environment variable to
    the start command to set a custom port. Express.js web applications default to
    port **3000** , but this will already be in use by our **loopback-bookstore**
    microservice, so we need to supply an alternative port. Run the following command
    from the **bookstore-web-app** directory:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在另一个终端窗口中，使用以下命令启动**bookstore-web-app**应用程序。我们还将传递一个**PORT**环境变量到启动命令，以设置自定义端口。Express.js网络应用程序默认端口为**3000**，但这个端口已经被我们的**loopback-bookstore**微服务占用，因此我们需要提供一个替代端口。从**bookstore-web-app**目录运行以下命令：
- en: '[PRE17]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Navigate to **http://localhost:8080/inventory** in your browser and expect
    to see the following output:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到**http://localhost:8080/inventory**，并期望看到以下输出：
- en: '![Figure 11.8 – HTML page showing an empty bookstore inventory and an HTML
    form to add a new book](img/Figure_11.8_B19212.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 显示空的书店库存和添加新书的HTML页面的HTML页面](img/Figure_11.8_B19212.jpg)'
- en: Figure 11.8 – HTML page showing an empty bookstore inventory and an HTML form
    to add a new book
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 显示空的书店库存和添加新书的HTML表单的HTML页面
- en: 'Now we can try adding a book to the inventory. Populate the **title** and **author**
    input fields and then click the **Submit** button. After submitting, you should
    expect to see the book you submitted added to the inventory:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试向库存中添加一本书。填写**标题**和**作者**输入字段，然后点击**提交**按钮。提交后，你应该期望看到你提交的书籍被添加到库存中：
- en: '![Figure 11.9 – Web page showing a populated bookstore inventory](img/Figure_11.9_B19212.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 显示已填充书店库存的网页](img/Figure_11.9_B19212.jpg)'
- en: Figure 11.9 – Web page showing a populated bookstore inventory
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 显示已填充书店库存的网页
- en: We’ve successfully built a frontend web application that communicates with our
    **loopback-bookstore** microservice.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功构建了一个与我们的**loopback-bookstore**微服务通信的前端网络应用程序。
- en: How it works…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In the recipe, we implemented a frontend web application layer that was backed
    by our **loopback-bookstore** microservice.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱中，我们实现了一个由我们的**loopback-bookstore**微服务支持的前端网络应用程序层。
- en: When our **/inventory** web page loads, under the covers, the Express.js web
    frontend queries the data from the loopback microservice.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的**/inventory**网页加载时，在幕后，Express.js网络前端从loopback微服务查询数据。
- en: Our Express.js server sends an HTTP POST request to the **http://localhost:3000/books**
    endpoint. The request is supplied with the HTML form data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Express.js服务器向**http://localhost:3000/books**端点发送HTTP POST请求。请求提供了HTML表单数据。
- en: Once the request to the LoopBack microservice is complete, the Express.js web
    application redirects to the **/inventory** route. This refreshes the template,
    which will then list the newly added book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成对LoopBack微服务的请求，Express.js网络应用程序将重定向到**/inventory**路由。这将刷新模板，然后列出新添加的书籍。
- en: This architecture demonstrates how you can modularize an application by building
    the backend API, in this case, **loopback-microservice** , separately from the
    frontend web application. This enables both applications to be scaled independently
    and keeps the code loosely coupled.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构展示了您如何通过分别构建后端API（在本例中为**loopback-microservice**）来模块化应用程序，从而与前端网络应用程序分离。这使得两个应用程序可以独立扩展，并保持代码松散耦合。
- en: For larger systems, it’s common to have many microservices communicating together.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的系统，通常会有许多微服务相互通信。
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Receiving HTTP POST requests* recipe in [*Chapter 4*](B19212_04.xhtml#_idTextAnchor100)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第4章*](B19212_04.xhtml#_idTextAnchor100)的*接收HTTP POST请求*菜谱中
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19212_06.xhtml#_idTextAnchor178)'
- en: The *Generating a microservice w ith LoopBack* recipe in this chapter
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中*使用LoopBack生成微服务*的菜谱
- en: Building a Docker container
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Docker容器
- en: Once we have a Node.js microservice, we need to package it ready for deployment
    to the cloud. Cloud and container technologies go hand in hand, and one of the
    most prevalent container technologies is Docker.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 Node.js 微服务，我们需要将其打包以便部署到云端。云和容器技术相辅相成，其中最普遍的容器技术之一是 Docker。
- en: Docker is a tool used for creating, deploying, and running applications with
    containers. A container enables you to package up your application with all its
    dependencies. A container is often said to be like a virtual machine, the key
    difference being that Docker allows applications to reuse the same Linux kernel,
    whereas a virtual machine virtualizes the whole operating system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个用于使用容器创建、部署和运行应用程序的工具。容器使您能够将应用程序及其所有依赖项打包在一起。容器通常被说成类似于虚拟机，关键区别在于
    Docker 允许应用程序重用相同的 Linux 内核，而虚拟机则是虚拟化整个操作系统。
- en: The key benefit to containerizing a microservice is that it is encapsulated,
    which means that the container holds everything that the microservice requires
    in order to run. This helps make the application portable and consistent across
    machines.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将微服务容器化的关键好处是它被封装起来，这意味着容器包含了微服务运行所需的一切。这有助于使应用程序在机器之间具有可移植性和一致性。
- en: Container technologies such as Docker are seen as the de facto tools for deploying
    to modern cloud environments, often combined with a container orchestrator such
    as Kubernetes, which we’ll cover in the *Deploying to Kubernetes* recipe of this
    chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Docker 这样的容器技术被视为部署到现代云环境的事实上工具，通常与 Kubernetes 这样的容器编排器结合使用，我们将在本章的 *Deploying
    to Kubernetes* 配方中介绍。
- en: 'Docker and Kubernetes are large and complex technologies. This chapter will
    focus on demonstrating how to leverage Docker and Kubernetes to deploy Node.js
    microservices. An in-depth overview of Docker and Kubernetes is beyond the scope
    of this book. Refer to the following links for more detailed information about
    Docker and Kubernetes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和 Kubernetes 是大型且复杂的科技。本章将重点展示如何利用 Docker 和 Kubernetes 来部署 Node.js 微服务。关于
    Docker 和 Kubernetes 的深入概述超出了本书的范围。有关 Docker 和 Kubernetes 的更详细信息，请参阅以下链接：
- en: 'Kubernetes overview: [https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 概述：[https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)
- en: 'Kubernetes setup guide: [https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 安装指南：[https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)
- en: In this recipe, we’ll be packaging a sample Node.js microservice into a Docker
    container.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将把一个示例 Node.js 微服务打包到 Docker 容器中。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need to have Docker installed. It is recommended to
    install Docker for Desktop from [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    .
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您需要安装 Docker。建议从 [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    安装 Docker for Desktop。
- en: 'Ensure Docker is running. You can test this by entering the following command
    in your terminal window:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 Docker 正在运行。您可以在终端窗口中输入以下命令进行测试：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This command pulls the **hello-world** image from Docker Hub and creates a container
    to run it. Docker Hub is a central repository of Docker images, almost like an
    **npm** registry for Docker images.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令从 Docker Hub 拉取 **hello-world** 镜像并创建一个容器来运行它。Docker Hub 是 Docker 镜像的中央存储库，几乎类似于
    Docker 镜像的 **npm** 注册表。
- en: The **hello-world** image is a sample image that you can use to test that Docker
    is installed and operating correctly. When you run the image, expect to see **Hello
    from Docker!** returned along with additional help text.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**hello-world** 镜像是您可以使用来测试 Docker 是否已安装并正确运行的示例镜像。当您运行此镜像时，您应该会看到 **Hello
    from Docker!** 以及其他帮助文本返回。'
- en: We will also need an API, or microservice, to build into a Docker container.
    We’ll use the Fastify CLI to generate an API. For more information on Fastify,
    refer to [*Chapter 6*](B19212_06.xhtml#_idTextAnchor178) .
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个 API 或微服务，将其构建到 Docker 容器中。我们将使用 Fastify CLI 生成 API。有关 Fastify 的更多信息，请参阅
    [*第 6 章*](B19212_06.xhtml#_idTextAnchor178)。
- en: 'Generate a sample API in a new directory named **fastify-microservice** by
    entering the following commands in your terminal window:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端窗口中输入以下命令，在名为 **fastify-microservice** 的新目录中生成一个示例 API：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have confirmed that Docker is installed and we have a sample microservice,
    we can move on to the recipe steps, where we’ll build a container.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确认 Docker 已安装并且我们有一个示例微服务，我们可以继续到配方步骤，我们将构建一个容器。
- en: How to do it…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we will be building a container for our **fastify-microservice**
    :'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一个用于我们的 **fastify-microservice** 的容器：
- en: 'Start by creating a **Dockerfile** file and a **.dockerignore** file in the
    **fastify-microservice** directory:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 **fastify-microservice** 目录中创建一个 **Dockerfile** 文件和一个 **.dockerignore**
    文件：
- en: '[PRE20]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A **Dockerfile** file is a set of instructions on how to build the container
    for our application or microservice. Open the **Dockerfile** file and add the
    following lines:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Dockerfile** 文件是一组指令，用于构建我们的应用程序或微服务的容器。打开 **Dockerfile** 文件并添加以下行：'
- en: '[PRE21]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we’ll create the **.dockerignore** file. Similar to a **.gitignore**
    file, the **.dockerignore** file is used to exclude files from being built into
    a container. Add the following to the **.** **dockerignore** file:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 **.dockerignore** 文件。类似于 **.gitignore** 文件，**.dockerignore** 文件用于排除文件被构建到容器中。将以下内容添加到
    **.** **dockerignore** 文件中：
- en: '[PRE22]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’re now ready to build the microservice. We do this by using the **docker
    build** command, along with **fastify-microservice** as a tag for our image:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已准备好构建微服务。我们通过使用 **docker build** 命令，并使用 **fastify-microservice** 作为我们镜像的标签来完成此操作：
- en: '[PRE23]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Expect to see the following output as Docker builds the image:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Docker构建镜像时，你预计会看到以下输出：
- en: '![Figure 11.10 – Web page showing a populated bookstore inventory](img/Figure_11.10_B19212.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 显示已填充的书店库存的网页](img/Figure_11.10_B19212.jpg)'
- en: Figure 11.10 – Web page showing a populated bookstore inventory
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 显示已填充的书店库存的网页
- en: 'Enter the following command in your terminal window to list all of your Docker
    images. You should expect to see the **fastify-microservice** Docker image in
    the list:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中输入以下命令以列出所有Docker镜像。你应该期望在列表中看到 **fastify-microservice** Docker镜像：
- en: '[PRE24]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we can run the Docker image as a Docker container, passing the **--publish**
    flag to instruct Docker to map port **3000** from within the container to port
    **3000** on our local machine. Enter the following command:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以运行Docker镜像作为Docker容器，通过传递 **--publish** 标志来指示Docker将容器内的端口 **3000** 映射到本地机器上的端口
    **3000**。输入以下命令：
- en: '[PRE25]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should be able to navigate to **http://localhost:3000/example** and see
    the **this is an** **example** output.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能够导航到 **http://localhost:3000/example** 并看到 **这是一个** **示例** 输出。
- en: Press *Ctrl* + *C* in your terminal window to stop your container.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中按 *Ctrl* + *C* 停止你的容器。
- en: We’ve now successfully built our first containerized microservice.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功构建了我们第一个容器化的微服务。
- en: How it works…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Containers enable you to package your application into an isolated environment.
    **Dockerfile** is used to define the environment. The environment should include
    the libraries and dependencies that are required to run the application code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使你能够将你的应用程序打包到一个隔离的环境中。**Dockerfile** 用于定义环境。环境应包括运行应用程序代码所需的库和依赖项。
- en: 'Let’s examine the contents of the **Dockerfile** file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 **Dockerfile** 文件的内容：
- en: '**FROM node:22** : The **node** instruction is used to initialize a new build
    stage. A **Dockerfile** file must start with a **FROM** instruction pointing to
    a valid Docker image that can be used as a base for our image. In this example,
    the image is based on the Docker Official Node.js image.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FROM node:22** : **node** 指令用于初始化一个新的构建阶段。一个 **Dockerfile** 文件必须以一个 **FROM**
    指令开始，该指令指向一个有效的Docker镜像，该镜像可以用作我们镜像的基础。在这个例子中，镜像基于Docker官方Node.js镜像。'
- en: '**RUN apt-get update...** : This line instructs Docker to update the containers’
    OS dependencies using the **Advanced Package Tool** ( **APT** ), which is Debian’s
    default package manager. It’s important that OS dependencies are up to date to
    ensure that your dependencies contain the latest available fixes and patches.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RUN apt-get update...** : 这行指令指示Docker使用 **Advanced Package Tool** ( **APT**
    ) 更新容器的操作系统依赖项，APT是Debian的默认包管理器。确保操作系统依赖项是最新的，这对于确保你的依赖项包含最新的修复和补丁非常重要。'
- en: '**COPY package*.json ./** : This copies the **package.json** and **package-lock.json**
    files, should they exist, into the container.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COPY package*.json ./** : 如果存在，此命令会将 **package.json** 和 **package-lock.json**
    文件复制到容器中。'
- en: '**RUN npm install --production** : This executes the **npm install** command
    within the container based on the **package*.json** files copied earlier into
    the container. **npm install** must be run within the container as some dependencies
    may have native components that need to be built based on the container’s OS.
    For example, if you’re developing locally on macOS and have native dependencies,
    you will not be able to just copy the contents of **node_modules** into the container,
    as the native macOS dependencies will not work in the Debian-based container.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RUN npm install --production**：这根据之前复制到容器中的**package*.json**文件在容器内执行**npm
    install**命令。必须在容器内运行**npm install**，因为某些依赖项可能具有需要根据容器OS构建的本机组件。例如，如果您在本地使用macOS开发并且有本机依赖项，您不能简单地复制**node_modules**的内容到容器中，因为本机macOS依赖项在基于Debian的容器中无法工作。'
- en: '**COPY . /app.** : This copies our application code into the container. Note
    that the **COPY** command will ignore all patterns listed in the **.dockerignore**
    file. This means that the **COPY** command will not copy **node_modules** and
    other information to the container.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COPY . /app.**：这把我们的应用程序代码复制到容器中。请注意，**COPY**命令将忽略**.dockerignore**文件中列出的所有模式。这意味着**COPY**命令不会将**node_modules**和其他信息复制到容器中。'
- en: '**ENV PORT 3000** : This sets the **PORT** environment variable in the container
    to **3000** .'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ENV PORT 3000**：这将在容器中设置**PORT**环境变量为**3000**。'
- en: '**EXPOSE 3000** : The **EXPOSE** instruction is used as a form of documentation
    as to which port is intended to be published for the containerized application.
    It does not publish the port.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXPOSE 3000**：**EXPOSE**指令用作文档形式，说明哪个端口打算公开给容器化应用程序。它不会公开端口。'
- en: '**USER node** : This instructs Docker to run the image as the **node** user.
    The **node** user is created by the Docker Official Node.js image. When omitted,
    the image will default to being run as the root user. You should run your containers
    as an unprivileged (non-root) user where possible as security mitigation.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USER node**：这指示Docker以**node**用户运行镜像。**node**用户是由Docker官方Node.js镜像创建的。如果省略，镜像将默认以root用户运行。在可能的情况下，您应该以无特权的（非root）用户运行容器，以作为安全缓解措施。'
- en: '**CMD ["npm", "start"]** : This executes the command to start the application.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMD ["npm", "start"]**：这执行启动应用程序的命令。'
- en: The ordering of the commands in **Dockerfile** is important. For each command
    in the **Dockerfile** file, Docker creates a new layer in the image. Docker will
    only rebuild the layers that have changed, so the ordering of the commands in
    the **Dockerfile** file can impact rebuild times. It is for this reason that we
    copy the application code into the container after running **npm install** , as
    we’re more commonly going to be changing the application code as opposed to changing
    our dependencies.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dockerfile**中命令的顺序很重要。对于**Dockerfile**文件中的每个命令，Docker都会在镜像中创建一个新的层。Docker只会重建已更改的层，因此**Dockerfile**文件中命令的顺序可能会影响重建时间。这就是为什么我们在运行**npm
    install**之后将应用程序代码复制到容器中，因为我们更经常改变应用程序代码，而不是改变我们的依赖项。'
- en: 'It’s possible to view the Docker layers for an image using the **docker history**
    command. For example, **$ docker history fastify-microservice** will output the
    layers of our **fastify-microservice** image:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**docker history**命令可以查看一个镜像的Docker层。例如，**$ docker history fastify-microservice**将输出我们的**fastify-microservice**镜像的层：
- en: '![Figure 11.11 – An overview of Docker history output for the fastify-microservice
    image](img/Figure_11.11_B19212.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – fastify-microservice镜像的Docker历史输出概述](img/Figure_11.11_B19212.jpg)'
- en: Figure 11.11 – An overview of Docker history output for the fastify-microservice
    image
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – fastify-microservice镜像的Docker历史输出概述
- en: The **$ docker build --tag fastify-microservice .** command builds the Docker
    image, based on the instructions in the **Dockerfile** file in the current directory.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ docker build --tag fastify-microservice .**命令基于当前目录中**Dockerfile**文件中的指令构建Docker镜像。'
- en: To run the image, we call **docker run --publish 3000:3000 fastify-microservice**
    . We pass this command the name of the image we’d like to run, and also the port
    we wish to expose. The **--publish 3000:3000** option maps port **3000** on your
    host machine to port **3000** on the container, ensuring that any traffic sent
    to port **3000** on the host is forwarded to port **3000** in the container.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行镜像，我们调用**docker run --publish 3000:3000 fastify-microservice**。我们传递这个命令我们想要运行的镜像名称，以及我们希望公开的端口。**--publish
    3000:3000**选项将主机上的端口**3000**映射到容器上的端口**3000**，确保任何发送到主机端口**3000**的流量都会转发到容器上的端口**3000**。
- en: There’s more…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: When creating a Docker image, it’s important to make it as small as possible.
    It’s considered good practice for your production image to only contain the dependencies
    and libraries required to run the application in production. To create a smaller
    image, we can leverage Docker’s multistage builds capability ( [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)
    ).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Docker 镜像时，使其尽可能小是很重要的。将生产镜像仅包含运行应用程序所需的生产依赖库和库被认为是良好的实践。为了创建更小的镜像，我们可以利用
    Docker 的多阶段构建功能（[https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)）。
- en: Docker multistage builds allow us to define multiple Docker images in the same
    **Dockerfile** file. For Node.js applications, we can split the *build* and *run*
    steps into separate containers. The result is that the final production container,
    the **run** container, will be a smaller and lighter-weight container.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 多阶段构建允许我们在同一个 **Dockerfile** 文件中定义多个 Docker 镜像。对于 Node.js 应用程序，我们可以将
    *构建* 和 *运行* 步骤拆分到单独的容器中。结果是最终的生成容器，即 **运行** 容器，将是一个更小、更轻量级的容器。
- en: 'We could use the following multistage **Dockerfile** file to containerize our
    **fastify-microservice** :'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下多阶段 **Dockerfile** 文件来容器化我们的 **fastify-microservice**：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Observe that there are two **FROM** instructions in the **Dockerfile** file,
    indicating that there are two build stages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在 **Dockerfile** 文件中有两个 **FROM** 指令，这表明有两个构建阶段。
- en: The first build stage creates a container that handles the installation of dependencies
    and any build tasks. In our example, the first container executes the **npm install**
    command. **node_modules** may contain native add-ons, which means the first container
    needs the relevant compilers and dependencies.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个构建阶段创建了一个容器，用于处理依赖项的安装和任何构建任务。在我们的例子中，第一个容器执行了 **npm install** 命令。**node_modules**
    可能包含原生插件，这意味着第一个容器需要相关的编译器和依赖项。
- en: The second container uses a base of the **node:22-slim** image. The **node:22-slim**
    image is a variant of the official Node.js Docker image that contains the minimum
    libraries required to run Node.js. This image is a much smaller and lighter-weight
    image. The regular **node** Docker image is around 1 GB in size, whereas the multi-stage
    **slim** image is around 200 MB. When deploying to the cloud, in many cases, you’ll
    be charged per MB. Minimizing your image size can result in cost savings.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个容器使用的是基于 **node:22-slim** 的镜像。**node:22-slim** 镜像是官方 Node.js Docker 镜像的一个变体，其中包含了运行
    Node.js 所需的最小库。这个镜像是一个更小、更轻量级的镜像。常规的 **node** Docker 镜像大小约为 1 GB，而多阶段的 **slim**
    镜像大小约为 200 MB。当部署到云端时，在许多情况下，你将按每 MB 收费。最小化镜像大小可以节省成本。
- en: Important note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Once you’ve completed the recipes in this chapter, you should stop and remove
    the Docker containers and images. Otherwise, the containers and images may linger
    on your system and consume system resources. Use **$ docker ps** to list your
    containers. Locate the container identifier and pass this to **$ docker stop <containerID>**
    to stop a container. Follow this up with **$ docker rm -f <containerID>** to remove
    a container. Similarly, to remove a Docker image, use the **$ docker image rm
    <image>** command. You can also use (with caution) the **$ docker system prune
    --all** command to remove all images and containers on your system.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了本章中的菜谱，你应该停止并删除 Docker 容器和镜像。否则，容器和镜像可能会留在你的系统中并消耗系统资源。使用 **$ docker ps**
    列出你的容器。定位容器标识符，并将其传递给 **$ docker stop <containerID>** 来停止容器。然后，使用 **$ docker rm
    -f <containerID>** 来删除容器。同样，要删除 Docker 镜像，请使用 **$ docker image rm <image>** 命令。你也可以（谨慎使用）使用
    **$ docker system prune --all** 命令来删除系统上的所有镜像和容器。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B19212_06.xhtml#_idTextAnchor178)'
- en: The *Publishing a Docker image* recipe in this chapter
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *发布 Docker 镜像* 菜谱
- en: The *Deploying to Kubernetes* recipe in this chapter
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *部署到 Kubernetes* 菜谱
- en: Publishing a Docker image
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布 Docker 镜像
- en: Docker Hub provides a global repository of images. Throughout this chapter and
    [*Chapter 7*](B19212_07.xhtml#_idTextAnchor212) , we’ve pulled Docker images that
    were stored in the Docker Hub repository. This includes the Docker Official Node.js
    image, which we used as a basis for our image in the *Building a Docker container*
    recipe in this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub提供了一个全球镜像存储库。在本章和[*第7章*](B19212_07.xhtml#_idTextAnchor212)中，我们已经从Docker
    Hub存储库中拉取了Docker镜像。这包括我们用作本章*构建一个Docker容器*菜谱基础的Docker官方Node.js镜像。
- en: In this recipe, we’re going to publish our **fastify-microservice** image to
    Docker Hub.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将发布我们的**fastify-microservice**镜像到Docker Hub。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will use the image created in the previous recipe, *Building a*
    *Docker container* .
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将使用前一个菜谱中创建的镜像，*构建一个* *Docker容器*。
- en: If you haven’t completed that recipe, the code is available in the Packt GitHub
    repository ( [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    ) in the **Chapter11/fastify-microservice** directory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有完成那个菜谱，代码可在Packt GitHub存储库（[https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)）的**Chapter11/fastify-microservice**目录中找到。
- en: How to do it…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we’re going to sign up for a Docker Hub account and publish
    our **fastify-microservice** image to Docker Hub:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将注册一个Docker Hub账户并将我们的**fastify-microservice**镜像发布到Docker Hub：
- en: First, we need to create a Docker Hub account. Visit [https://hub.docker.com/signup](https://hub.docker.com/signup)
    to create an account. You will need to enter your details and click **Sign up**
    .
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个Docker Hub账户。访问[https://hub.docker.com/signup](https://hub.docker.com/signup)以创建账户。您需要输入您的详细信息并点击**注册**。
- en: 'Once you’ve created your Docker Hub account, you need to authenticate your
    Docker client. Do this by entering the following command in your terminal:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您创建了您的Docker Hub账户，您需要认证您的Docker客户端。通过在终端中输入以下命令来完成此操作：
- en: '[PRE27]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once we have authenticated our Docker client, we then need to retag our image
    for it to be pushed to Docker Hub. Tag the image with the following command, substituting
    **<namespace>** with your Docker Hub ID:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们认证了Docker客户端，我们就需要重新标记我们的镜像以便将其推送到Docker Hub。使用以下命令标记镜像，将**<namespace>**替换为您的Docker
    Hub ID：
- en: '[PRE28]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we need to push the newly tagged image using the **docker** **push** command:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要使用**docker push**命令推送新标记的镜像：
- en: '[PRE29]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can now navigate to **https://hub.docker.com/repository/docker/<namespace>/fastify-microservice**
    to verify that your image has been published to Docker Hub. Again, you’ll need
    to substitute **<namespace>** with your Docker Hub ID. Expect to see output similar
    to the following:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以导航到**https://hub.docker.com/repository/docker/<namespace>/fastify-microservice**以验证您的镜像是否已发布到Docker
    Hub。同样，您需要将**<namespace>**替换为您的Docker Hub ID。您可能会看到以下类似的输出：
- en: '![Figure 11.12 – Docker Hub view of the published fastify-microservice image](img/Figure_11.12_B19212.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图11.12 – 已发布的fastify-microservice镜像的Docker Hub视图](img/Figure_11.12_B19212.jpg)'
- en: Figure 11.12 – Docker Hub view of the published fastify-microservice image
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – 已发布的fastify-microservice镜像的Docker Hub视图
- en: If you click on **Tags** , you should see that our Docker image has one tag
    named **latest** .
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您点击**标签**，您应该会看到我们的Docker镜像有一个名为**latest**的标签。
- en: 'It is also now possible to pull the image with the following command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在也可以使用以下命令拉取镜像：
- en: '[PRE30]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’ve pushed a Docker image containing our **fastify-microservice** image to
    Docker Hub.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将包含我们的**fastify-microservice**镜像的Docker镜像推送到Docker Hub。
- en: How it works…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We first tagged the **fastify-microservice** image with the **<namespace>/fastify-microservice**
    tag. This tag format instructs Docker that this image is associated with a repository
    on Docker Hub. Once we’ve appropriately tagged our image, we use the **docker
    push** command to publish the image to Docker Hub.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用**<namespace>/fastify-microservice**标记标记了**fastify-microservice**镜像。此标记格式指示Docker，此镜像与Docker
    Hub上的存储库相关联。一旦我们适当地标记了我们的镜像，我们就使用**docker push**命令将镜像发布到Docker Hub。
- en: By default, our Docker Hub image will be publicly accessible. Production microservices
    are not typically expected to be published publicly to Docker Hub to avoid exposing
    any proprietary code or secrets. Docker Hub does provide private image functionality,
    but users are limited to one private registry on Docker Hub’s free account plan.
    It is possible to sign up for a paid account plan with Docker Hub, which provides
    unlimited private repositories.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的Docker Hub镜像将是公开可访问的。通常不期望生产级微服务公开发布到Docker Hub，以避免泄露任何专有代码或机密。Docker
    Hub确实提供了私有镜像功能，但免费账户计划下的用户限制在一个私有注册库。可以通过Docker Hub注册付费账户计划，该计划提供无限私有仓库。
- en: When deploying images for use in production-grade systems, it is common to create
    a private Docker registry. Docker exposes a registry image ( [https://hub.docker.com/_/registry](https://hub.docker.com/_/registry)
    ) that can be used to provision a private registry. For more information on setting
    up a private registry, refer to [https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/)
    .
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署用于生产级系统的镜像时，通常创建一个私有Docker注册库。Docker提供了一个注册库镜像（[https://hub.docker.com/_/registry](https://hub.docker.com/_/registry)），可用于配置私有注册库。有关设置私有注册库的更多信息，请参阅[https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/)。
- en: The **<IP>:<PORT>/<IMAGE>** format is used when referring to images stored in
    private registries, where the IP is the address of the private registry. Many
    of the leading cloud providers also provide commercial container registry solutions,
    which can be used to avoid the overhead of managing a container registry.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用存储在私有注册库中的镜像时，使用**<IP>:<PORT>/<IMAGE>**格式，其中IP是私有注册库的地址。许多领先的云服务提供商也提供商业容器注册库解决方案，可用于避免管理容器注册库的开销。
- en: There’s more…
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In this recipe, we did not specify a version tag for our Docker image. Therefore,
    Docker defaulted to creating the **latest** version tag for our image. The **latest**
    tag is automatically updated each time we rebuild our image without explicitly
    specifying a version tag.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们没有为我们的Docker镜像指定版本标签。因此，Docker默认为我们的镜像创建**latest**版本标签。每次我们重建镜像而不明确指定版本标签时，**latest**标签都会自动更新。
- en: It is generally considered good practice to version Docker Hub images similar
    to how you’d version an application. Versioning Docker Hub images provides a history
    of images, which makes it possible to roll back to earlier image versions should
    something go wrong.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为，将Docker Hub镜像版本化与版本化应用程序的方式相似是一种良好的实践。对Docker Hub镜像进行版本化提供了镜像的历史记录，这使得在出现问题时可以回滚到早期镜像版本。
- en: 'We can tag our **fastify-microservice** image with the following command, substituting
    the namespace for our Docker Hub username:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令为我们的**fastify-microservice**镜像打标签，用我们的Docker Hub用户名替换命名空间：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The **1.0.0** version is specified in the preceding command to match the version
    declared in our **package.json** file. This is just one of many approaches we
    can take to versioning as there is no formal standard for how Docker images should
    be versioned. Other options include an incremental versioning scheme or even using
    the Git commit SHA of the application code as the version tag.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令中指定了**1.0.0**版本，以匹配我们在**package.json**文件中声明的版本。这只是我们可以在版本化方面采取的许多方法之一，因为目前没有关于如何版本化Docker镜像的正式标准。其他选项包括增量版本化方案，甚至可以使用应用程序代码的Git提交SHA作为版本标签。
- en: 'We push the image to Docker Hub with the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令将镜像推送到Docker Hub：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we navigate to the **Tags** panel for our **fastify-microservice** image
    on Docker Hub, we should be able to see that our newly pushed image version is
    available.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到Docker Hub上**fastify-microservice**镜像的**标签**面板，我们应该能够看到我们新推送的镜像版本可用。
- en: See also
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19212_06.xhtml#_idTextAnchor178)'
- en: The *Building a Docker container* recipe in this chapter
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*构建Docker容器*配方
- en: The *Deploying to Kubernetes* recipe in this chapter
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*部署到Kubernetes*配方
- en: Deploying to Kubernetes
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到Kubernetes
- en: Kubernetes is an open source container orchestration and management system originally
    developed by Google. Today, the Kubernetes project is maintained by the Cloud
    Native Computing Foundation ( [https://www.cncf.io/](https://www.cncf.io/) ).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个由Google最初开发的开源容器编排和管理系统。如今，Kubernetes项目由云原生计算基金会（[https://www.cncf.io/](https://www.cncf.io/)）维护。
- en: 'Kubernetes is a comprehensive and complex tool that provides the following
    features, among others:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个全面且复杂的工具，提供了以下功能，以及其他功能：
- en: Service discovery and load balancing
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现和负载均衡
- en: Storage orchestration
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储编排
- en: Automated rollouts and rollbacks
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动部署和回滚
- en: Automatic bin packing, specifying how much CPU and memory each container needs
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动装箱，指定每个容器需要的 CPU 和内存量
- en: Self-healing
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自我修复
- en: Secret and configuration management
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机密和配置管理
- en: An oversimplified description of Kubernetes is that it is a tool used to manage
    containers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的一个过于简化的描述是，它是一个用于管理容器的工具。
- en: This recipe will serve as an introduction to Kubernetes, demonstrating how we
    can deploy a microservice, packaged into a Docker container, to Kubernetes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将作为 Kubernetes 的介绍，展示我们如何将打包在 Docker 容器中的微服务部署到 Kubernetes。
- en: Getting ready
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have Node.js 22 installed, and access to both an editor and browser
    of your choice. This recipe also relies on the **fastify-microservice** image
    that we created in the *Building a Docker container* recipe in this chapter. If
    you haven’t completed that recipe, you can download the code from the Packt GitHub
    repository ( [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    ) in the **Chapter11/fastify-microservice** directory.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了 Node.js 22，并且可以访问你选择的编辑器和浏览器。这个配方还依赖于我们在本章的 *构建 Docker 容器* 配方中创建的 **fastify-microservice**
    镜像。如果你还没有完成那个配方，你可以从 Packt GitHub 仓库（[https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)）的
    **Chapter11/fastify-microservice** 目录中下载代码。
- en: For this recipe, you will additionally need to have both Docker and Kubernetes
    installed. It’s possible to install and enable Kubernetes via Docker for Desktop.
    It is recommended to install Docker for Desktop from [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    .
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你还需要安装 Docker 和 Kubernetes。可以通过 Docker for Desktop 安装和启用 Kubernetes。建议从
    [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    安装 Docker for Desktop。
- en: Important note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This recipe has been written based on using Docker for Desktop, which handles
    the setup of Kubernetes and installation of the **kubectl** CLI. However, Docker
    for Desktop is only available on macOS and Windows OSs. On Linux, an alternative
    is to use **minikube** , which is a tool that runs a Kubernetes cluster in a virtual
    machine on your local device. Minikube has a more complicated setup compared to
    Docker for Desktop. First, you’ll need to manually install the **kubectl** CLI
    ( [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
    ), and then follow the installation instructions for Minikube at [https://kubernetes.io/docs/tasks/tools/install-minikube](https://kubernetes.io/docs/tasks/tools/install-minikube)
    .
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是基于使用 Docker for Desktop 编写的，它处理 Kubernetes 的设置和 **kubectl** CLI 的安装。然而，Docker
    for Desktop 仅适用于 macOS 和 Windows 操作系统。在 Linux 上，可以使用 **minikube** 作为替代方案，这是一个在你的本地设备上运行
    Kubernetes 集群的工具。与 Docker for Desktop 相比，Minikube 的设置更为复杂。首先，你需要手动安装 **kubectl**
    CLI（[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)），然后按照
    [https://kubernetes.io/docs/tasks/tools/install-minikube](https://kubernetes.io/docs/tasks/tools/install-minikube)
    中的 Minikube 安装说明进行操作。
- en: 'To enable Kubernetes in Docker for Desktop, perform the following steps:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Docker for Desktop 中启用 Kubernetes，请执行以下步骤：
- en: Click the **Docker** icon in your menu bar.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击菜单栏中的 **Docker** 图标。
- en: 'Navigate to the **Preferences/Settings** | **Kubernetes** tab (as shown in
    the following screenshot):'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **首选项/设置** | **Kubernetes** 选项卡（如图下截图所示）：
- en: '![Figure 11.13 – The Docker for Desktop Kubernetes tab](img/Figure_11.13_B19212.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – Docker for Desktop Kubernetes 选项卡](img/Figure_11.13_B19212.jpg)'
- en: Figure 11.13 – The Docker for Desktop Kubernetes tab
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – Docker for Desktop Kubernetes 选项卡
- en: Check the **Enable** **Kubernetes** checkbox.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打勾 **启用** **Kubernetes** 复选框。
- en: Click **Apply &** **restart** .
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **应用** 和 **重启**。
- en: It will take a short while for Kubernetes to install. The installation process
    will instantiate all of the images that are required to run a Kubernetes cluster
    on your laptop. The **kubectl** CLI will also be installed at **/usr/local/bin/kubectl**
    . We will be using the **kubectl** CLI to interact with our Kubernetes cluster.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的安装将花费一些时间。安装过程将在你的笔记本电脑上实例化运行 Kubernetes 集群所需的所有镜像。**kubectl** CLI
    也将安装在 **/usr/local/bin/kubectl** 下。我们将使用 **kubectl** CLI 与我们的 Kubernetes 集群进行交互。
- en: 'If you already use Kubernetes, ensure that you are configured to use the **docker-desktop**
    context. To do so, perform the following steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用 Kubernetes，请确保你已配置为使用 **docker-desktop** 上下文。为此，请执行以下步骤：
- en: Click the Docker icon in your menu bar.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击菜单栏中的 Docker 图标。
- en: Click **Kubernetes** and select the **docker-desktop** context.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Kubernetes** 并选择 **docker-desktop** 上下文。
- en: 'Open a new terminal window and verify that both Docker and the **kubectl**
    CLI are present by entering the following commands. Expect to see output similar
    to the following:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口，通过输入以下命令来验证 Docker 和 **kubectl** CLI 是否存在。预期将看到类似以下内容的输出：
- en: '[PRE33]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Should any issues arise, refer to the official Docker for Desktop installation
    and the *Getting Started* guides at [https://docs.docker.com/desktop/#get-started](https://docs.docker.com/desktop/#get-started)
    .
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现任何问题，请参考官方 Docker for Desktop 安装和 [https://docs.docker.com/desktop/#get-started](https://docs.docker.com/desktop/#get-started)
    的 *入门* 指南。
- en: Now that we have Docker and Kubernetes installed and started, we can move to
    our recipe steps.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经安装并启动了 Docker 和 Kubernetes，我们可以进入我们的步骤。
- en: How to do it…
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we’re going to deploy our **fastify-microservice** image to
    Kubernetes. We’ll be using the **kubectl** CLI to interact with our Kubernetes
    cluster:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将部署我们的 **fastify-microservice** 镜像到 Kubernetes。我们将使用 **kubectl** CLI
    与我们的 Kubernetes 集群进行交互：
- en: 'First, let’s test out some **kubectl** commands. Enter the following commands
    to list the Kubernetes nodes and services present on our cluster:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们测试一些 **kubectl** 命令。输入以下命令以列出我们集群中现有的 Kubernetes 节点和服务：
- en: '[PRE34]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can proceed to deploy our **fastify-microservice** image. Let’s start
    by ensuring we have our Docker image built. To do so, run the following command
    within the **fastify-microservice** directory:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续部署我们的 **fastify-microservice** 镜像。让我们首先确保我们已经构建了 Docker 镜像。为此，请在 **fastify-microservice**
    目录下运行以下命令：
- en: '[PRE35]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we’ll create our deployment files. The deployment files will be a set
    of YAML files that are used to configure Kubernetes. We’ll create a subdirectory
    named **deployment** to hold the deployment files:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的部署文件。部署文件将是一组用于配置 Kubernetes 的 YAML 文件。我们将在名为 **deployment** 的子目录中创建一个子目录来保存部署文件：
- en: '[PRE36]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We’re going to create a Kubernetes deployment. We can configure a Kubernetes
    deployment with a YAML file. To create a deployment YAML file, add the following
    to **deployment/fastify-app.yml** :'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个 Kubernetes 部署。我们可以使用 YAML 文件来配置 Kubernetes 部署。要创建部署 YAML 文件，请将以下内容添加到
    **deployment/fastify-app.yml**：
- en: '[PRE37]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To create the Kubernetes deployment, we need to apply our YAML file that describes
    the deployment. We can confirm that the deployment has been created by asking
    our Kubernetes cluster to list its deployments. Do this by entering the following
    two commands:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建 Kubernetes 部署，我们需要应用描述部署的 YAML 文件。我们可以通过要求我们的 Kubernetes 集群列出其部署来确认部署已被创建。通过输入以下两个命令来完成此操作：
- en: '[PRE38]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In our YAML file, we instructed Kubernetes to create three replicas. This means
    three Kubernetes pods will be created. A Kubernetes pod is a group of one or more
    containers that are deployed together on the same host and share the same network
    namespace and storage volumes.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 YAML 文件中，我们指示 Kubernetes 创建三个副本。这意味着将创建三个 Kubernetes 容器组。Kubernetes 容器组是一组部署在同一主机上的一个或多个容器，它们共享相同的网络命名空间和存储卷。
- en: 'We can confirm that these have been created by listing all of the pods in our
    Kubernetes cluster by means of the following command:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令列出我们 Kubernetes 集群中的所有容器组来确认这些容器组已被创建：
- en: '[PRE39]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let’s move on to how we can expose the instances of our **fastify-microservice**
    image running in the pods. We do this by creating a Kubernetes Service. Add the
    following to **fastify-app-svc.yml** to create the Kubernetes Service:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续了解如何公开运行在容器组中的 **fastify-microservice** 镜像的实例。我们通过创建一个 Kubernetes 服务来实现这一点。将以下内容添加到
    **fastify-app-svc.yml** 以创建 Kubernetes 服务：
- en: '[PRE40]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To create the Kubernetes Service defined in the previous step, we need to apply
    the Service YAML file with the following commands. We can confirm that the Kubernetes
    Service was created by supplying the **kubectl get service** command. Enter the
    following in your terminal:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建在上一步骤中定义的 Kubernetes 服务，我们需要使用以下命令应用服务 YAML 文件。我们可以通过提供 **kubectl get service**
    命令来确认 Kubernetes 服务已被创建。请在您的终端中输入以下内容：
- en: '[PRE41]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that we have created a Kubernetes Service, we should be able to access
    the application in our browser. You will need to access the application via the
    external port, which is the port number detailed in the output of the previous
    step. In the preceding example, the application is located at **https://localhost:31815/example**
    , but you will need to substitute the port, as it is randomly assigned by Kubernetes.
    The external port, by default, will be in the range of **30000** to **32767**
    as this is the default range assigned to **NodePort services** by Kubernetes.
    Expect to see the following output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个 Kubernetes 服务，我们应该能够通过浏览器访问应用程序。您需要通过外部端口访问应用程序，该端口号在上一步骤的输出中详细说明。在先前的示例中，应用程序位于
    **https://localhost:31815/example** ，但您需要替换端口号，因为 Kubernetes 会随机分配它。默认情况下，外部端口号将在
    **30000** 到 **32767** 的范围内，因为这是 Kubernetes 分配给 **NodePort 服务** 的默认范围。您可能会看到以下输出：
- en: '![Figure 11.14 – Browser showing the this is an example string](img/Figure_11.14_B19212.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 浏览器显示这是示例字符串](img/Figure_11.14_B19212.jpg)'
- en: Figure 11.14 – Browser showing the this is an example string
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 浏览器显示这是示例字符串
- en: We’ve now pushed our containerized **fastify-microservice** image to our local
    Kubernetes cluster.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将我们的容器化 **fastify-microservice** 镜像推送到我们的本地 Kubernetes 集群。
- en: How it works…
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the recipe, we deployed our **fastify-microservice** image to the local Kubernetes
    cluster running under Docker for Desktop. Many of the leading cloud providers
    have commercial Kubernetes offerings that can be used should you not wish to manage
    a Kubernetes cluster. These commercial offerings extend the Kubernetes open source
    project, meaning the underlying Kubernetes technology remains consistent across
    cloud providers. Most of the providers offer CLIs to interact with their Kubernetes
    offering; however, the APIs provided by these CLIs tend to just be wrappers or
    shortcuts for **kubectl** commands.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们将我们的 **fastify-microservice** 镜像部署到了在 Docker for Desktop 下运行的本地 Kubernetes
    集群。许多领先的云服务提供商都提供商业 Kubernetes 服务，如果您不想管理 Kubernetes 集群，可以使用这些服务。这些商业服务扩展了 Kubernetes
    开源项目，这意味着底层 Kubernetes 技术在云服务提供商之间保持一致。大多数提供商都提供 CLI 来与其 Kubernetes 服务交互；然而，这些
    CLI 提供的 API 往往只是 **kubectl** 命令的包装器或快捷方式。
- en: 'The following is a selection of the commercial Kubernetes Services available
    from leading cloud providers:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从主要云服务提供商处可用的商业 Kubernetes 服务的选择：
- en: 'Amazon Elastic Kubernetes Service: [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '亚马逊弹性 Kubernetes 服务: [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)'
- en: 'Azure Kubernetes Service: [https://azure.microsoft.com/en-gb/services/kubernetes-service/](https://azure.microsoft.com/en-gb/services/kubernetes-service/)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '微软 Azure Kubernetes 服务: [https://azure.microsoft.com/en-gb/services/kubernetes-service/](https://azure.microsoft.com/en-gb/services/kubernetes-service/)'
- en: 'Google Kubernetes Engine: [https://cloud.google.com/kubernetes-engine](https://cloud.google.com/kubernetes-engine)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '谷歌 Kubernetes 引擎: [https://cloud.google.com/kubernetes-engine](https://cloud.google.com/kubernetes-engine)'
- en: 'IBM Cloud Kubernetes Service: [https://www.ibm.com/products/kubernetes-service](https://www.ibm.com/products/kubernetes-service)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IBM 云 Kubernetes 服务: [https://www.ibm.com/products/kubernetes-service](https://www.ibm.com/products/kubernetes-service)'
- en: The recipe relied on our **fastify-microservice** image being built and available
    on the local machine.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 配方依赖于我们的 **fastify-microservice** 镜像在本地机器上构建和可用。
- en: 'We declared a Kubernetes deployment in the **deployment/fastify-app.yml** file.
    A Kubernetes deployment is a resource object in Kubernetes. A Kubernetes deployment
    allows you to define the life cycle of your application. The life cycle definition
    includes the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 **deployment/fastify-app.yml** 文件中声明了一个 Kubernetes 部署。Kubernetes 部署是 Kubernetes
    中的一个资源对象。Kubernetes 部署允许您定义应用程序的生命周期。生命周期定义包括以下内容：
- en: The image to use for the deployment is included. In the recipe, the deployment
    YAML referenced the local **fastify-microservice** image that we created in the
    *Building a Docker container* recipe of this chapter. Note that we could have
    supplied an external image, such as one from Docker Hub, or referenced an image
    in a private registry.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署要使用的镜像已包含。在配方中，部署 YAML 引用了本章“构建 Docker 容器”配方中创建的本地 **fastify-microservice**
    镜像。请注意，我们可以提供外部镜像，例如来自 Docker Hub 的镜像，或者引用私有注册表中的镜像。
- en: The number of replicas or pods that should be available are included.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该可用的副本或 Pod 的数量已包含。
- en: How the replicas or pods should be updated is detailed.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何更新副本或 Pod 已详细说明。
- en: In **deployment/fastify-app.yml** , we declared that there should be three replicas,
    and therefore three pods were created by Kubernetes. We set three replicas so
    that if one pod crashes, then the other two pods can handle the load. The number
    of replicas required will depend on the typical load of a given application. Having
    multiple instances available is part of what provides Kubernetes’ “high-availability”
    behaviors; having other pods available that can handle the load in the case where
    one pod crashes can reduce downtime. If we were to manually kill a pod with **docker
    delete pod <podname>** , Kubernetes would automatically try to restart and spin
    up a new pod in its place. This demonstrates Kubernetes’ “ auto-restart” behavior.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在**deployment/fastify-app.yml**中，我们声明应该有三个副本，因此Kubernetes创建了三个Pod。我们设置三个副本，以便如果一个Pod崩溃，其他两个Pod可以处理负载。所需的副本数量将取决于特定应用程序的典型负载。拥有多个实例是Kubernetes提供“高可用性”行为的一部分；在某个Pod崩溃的情况下，有其他Pod可以处理负载可以减少停机时间。如果我们手动使用**docker
    delete pod <podname>**杀死一个Pod，Kubernetes会自动尝试重启并启动一个新的Pod来替代它。这展示了Kubernetes的“自动重启”行为。
- en: To access our application, we needed to define a Kubernetes Service. This Service
    is used to expose an application running on a set of pods. In the case of the
    recipe, we created a Kubernetes Service to expose **fastify-microservice** , which
    was running in three pods. Kubernetes creates a single DNS name for a group of
    Kubernetes pods, enabling load balancing between them.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问我们的应用程序，我们需要定义一个Kubernetes服务。此服务用于暴露在多个Pod上运行的应用程序。在食谱的情况下，我们创建了一个Kubernetes服务来暴露**fastify-microservice**，该服务在三个Pod上运行。Kubernetes为Kubernetes
    Pod组创建一个单一的DNS名称，使它们之间能够进行负载均衡。
- en: 'This recipe has only touched upon Kubernetes in the context of deploying a
    simple Node.js microservice. A full introduction to Kubernetes is beyond the scope
    of this book. For more detailed information on Kubernetes, you can refer to the
    following guides:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱只是在部署简单的Node.js微服务的背景下触及了Kubernetes。对Kubernetes的全面介绍超出了本书的范围。有关Kubernetes的更详细信息，您可以参考以下指南：
- en: 'Kubernetes overview: [https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes概述：[https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)
- en: 'Kubernetes setup guide: [https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes设置指南：[https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)
- en: There’s more…
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Kubernetes is focused on enabling the high availability of applications to minimize
    downtime. When deploying an updated version of your microservice, Kubernetes will
    conduct a rolling update. Rolling updates aim for zero downtime by incrementally
    updating individual pod instances with the new version of the microservice.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes致力于实现应用程序的高可用性，以最小化停机时间。当部署您的微服务更新版本时，Kubernetes将执行滚动更新。滚动更新的目标是实现零停机时间，通过逐步更新单个Pod实例的新版本微服务。
- en: 'We can demonstrate Kubernetes rolling updates by updating our microservice
    and instructing Kubernetes to deploy the updated version of the microservice:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更新我们的微服务并指示Kubernetes部署微服务的更新版本来演示Kubernetes滚动更新：
- en: 'We can start by making a small change to **fastify-microservice** . Open **routes/example/index.js**
    and change the response that is returned on line 5 to the following:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从对**fastify-microservice**进行小改动开始。打开**routes/example/index.js**，将第5行返回的响应更改为以下内容：
- en: '[PRE42]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we need to rebuild our container for our microservice. We’ll tag this image
    with version **2.0.0** . Enter the following command to rebuild and tag the image:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要重建我们的微服务容器。我们将为此镜像添加版本**2.0.0**的标签。输入以下命令以重建和标记镜像：
- en: '[PRE43]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we need to update our Kubernetes deployment. Open **deployment/fastify-app.yml**
    and change the image to reference our new image tag:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要更新我们的Kubernetes部署。打开**deployment/fastify-app.yml**，将镜像更改为引用我们的新标签：
- en: '[PRE44]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we need to reapply our Kubernetes deployment configuration with the following
    command:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要使用以下命令重新应用我们的Kubernetes部署配置：
- en: '[PRE45]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Enter the following to obtain the **NodePort** for our Kubernetes Service.
    We need this port to access the application from our browser:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以获取我们的Kubernetes服务的**NodePort**。我们需要这个端口从浏览器访问应用程序：
- en: '[PRE46]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Navigate to **http://localhost:<NodePort>/example** , where **NodePort** is
    the port output from the previous command.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**http://localhost:<NodePort>/example**，其中**NodePort**是上一条命令输出的端口。
- en: The **this is an updated example** string should be returned in your browser,
    indicating that the rolling update has taken place.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器应返回 **this is an updated example** 字符串，表示已进行滚动更新。
- en: Important note
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Once you’ve completed this recipe, including the *There’s more…* section, you
    should delete the Kubernetes resources you have created to avoid an unnecessary
    load on your system. To delete the deployment, use the **$ kubectl delete deployment
    fastify-app** command. Similarly, to delete the Kubernetes Service, use the **$
    kubectl delete service** **fastify-app-svc** command.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此菜谱，包括 *更多内容…* 部分，您应该删除您创建的 Kubernetes 资源，以避免对系统造成不必要的负载。要删除部署，请使用 **$ kubectl
    delete deployment fastify-app** 命令。同样，要删除 Kubernetes 服务，请使用 **$ kubectl delete
    service** **fastify-app-svc** 命令。
- en: See also
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B19212_06.xhtml#_idTextAnchor178)'
- en: The *Building a Docker container* recipe in this chapter
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *构建 Docker 容器* 菜谱
- en: The *Publishing a Docker image* recipe in this chapter
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *发布 Docker 镜像* 菜谱
