- en: Chapter 1. Let's Get Local!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。让我们开始本地化！
- en: There are a lot of languages in the world, and chances are good that you want
    your app to have the widest possible use and distribution, which means that you
    will need to provide your app with the ability to be multilingual. This can be
    a thorny task; a lot goes in to localization, translations, currency formats,
    date formats, and so on. But thankfully, there are some very smart people out
    there who have already worked through a lot of the pain involved. Now it's up
    to us to put that work to good use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上有各种各样的语言，很可能你希望你的应用能够被尽可能广泛地使用和分发，这意味着你需要给你的应用提供多语言的能力。这可能是一项棘手的任务；本地化、翻译、货币格式、日期格式等等都需要很多工作。但幸运的是，有一些非常聪明的人已经解决了许多痛苦的问题。现在，轮到我们把这些工作用到好的用途上了。
- en: What do we build?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要构建什么？
- en: The project that we will create is a simple game entitled *Quiz Time!* The game
    will essentially ask the player ten random questions in their native language
    and then tally and present their score when the game is finished. At the end,
    the app will ask the user if they want to try again as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的项目是一个简单的游戏，名为 *Quiz Time!* 游戏将基本上以玩家的母语随机提出十个问题，并在游戏结束时总计并展示他们的分数。最后，应用将询问用户是否想要再次尝试。
- en: The app itself will serve to introduce you to creating mobile apps using a simple
    framework named **YASMF** (**Yet Another Simple Mobile Framework**). There are
    a multitude of fantastic frameworks out there (jQuery Mobile, jQuery Touch, iUI,
    Sencha Touch, and so on.), but the point of this book isn't to show you how to
    use a particular framework; rather, the point is to show you how to use PhoneGap
    to do some amazing things. The framework you choose to use ultimately doesn't
    really matter that much—they all do what they advertise—and our using a custom
    framework isn't intended to throw you off-kilter in any fashion. The main reason
    for using this particular custom framework is that it's very lightweight and simple,
    which means the concepts it uses will be easy to transfer to any framework. For
    more information regarding the framework, please visit [https://github.com/photokandyStudios/YASMF/wiki](https://github.com/photokandyStudios/YASMF/wiki).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 应用本身将帮助你了解如何使用一个名为 **YASMF** （**Yet Another Simple Mobile Framework**）的简单框架来创建移动应用。市面上有无数的出色框架（jQuery
    Mobile、jQuery Touch、iUI、Sencha Touch等等），但本书的目的并不是教你如何使用特定的框架；相反，目的是展示你如何使用PhoneGap做一些令人惊叹的事情。你选择使用的框架最终并不那么重要——它们都做了它们所宣传的事情——我们使用自定义框架并不是为了让你感到困惑。使用这个特定自定义框架的主要原因是因为它非常轻量级和简单，这意味着它所使用的概念将很容易转移到任何框架上。有关框架的更多信息，请访问
    [https://github.com/photokandyStudios/YASMF/wiki](https://github.com/photokandyStudios/YASMF/wiki)。
- en: The app itself will also serve as a foundation to creating localized apps in
    the future. Localization is absolutely critical to get right, even in the beginning
    stages of development, which is why we start with it here, and why we assign it
    such importance. In essence, this first project is intended to make the rest of
    your app development career easier.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 应用本身也将成为创建未来本地化应用的基础。本地化在开发初期就至关重要，这就是为什么我们从这里开始，为什么我们给予它如此重要的地位。本质上，这个第一个项目旨在使你未来的应用开发生涯更加容易。
- en: What does it do?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它能做什么？
- en: As an app, Quiz Time! is pretty simple. There are only three screens, and only
    one of them is remotely complex. The game has ten built-in questions that it will
    randomly ask of the player. If the question is correct, the player is notified,
    and their score is increased by an arbitrarily large number. This is to show that
    we correctly handle the display of numbers in the player's locale. If the question
    is incorrect, we also notify the user, and then decrement their score. If they
    get enough questions wrong, they'll end up in negative territory, which is another
    great test for our localization skills.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一款应用，Quiz Time! 非常简单。只有三个屏幕，其中只有一个稍微复杂。游戏内置了十个问题，会随机向玩家提问。如果问题回答正确，玩家会收到通知，并且他们的分数会增加一个任意大的数字。这是为了展示我们正确处理了玩家所在地区的数字显示。如果问题回答错误，我们也会通知用户，然后减少他们的分数。如果他们回答了足够多的问题错误，他们最终会进入负分区域，这对我们的本地化技能也是一个很好的测试。
- en: Once the game is over, we'll display the score and the date to the player, along
    with the opportunity to try again. If the player does elect to try again, we'll
    reset everything and start the game over.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦游戏结束，我们将向玩家显示分数和日期，并给他们再次尝试的机会。如果玩家选择再次尝试，我们将重置一切并重新开始游戏。
- en: Why is it great?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它很棒？
- en: 'You''ll be primarily learning two things: building a simple game in PhoneGap,
    and localizing that app from the very beginning. A lot of projects forget about
    localization until near the end of the project, and then the poor developers find
    out that it is very difficult to shoehorn localization in after most of the project
    has already been developed. For example, the space assigned to some text might
    turn out to be too small for certain languages, or the images used as buttons
    or other widgets might not be large enough to hold the localized text. The app
    itself might crash in a certain language because it didn''t expect to receive
    any non-English characters. By implementing localization at the start of your
    app development, you''ll be saving yourself a lot of effort down the road, even
    if the first release of your app is only localized to one locale.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将主要学习两件事：在PhoneGap中构建一个简单的游戏，并从一开始就本地化该应用。许多项目直到项目接近尾声才考虑本地化，这时可怜的开发者会发现，在项目的大部分开发完成后强行加入本地化非常困难。例如，分配给某些文本的空间可能太小，无法容纳某些语言，或者用作按钮或其他小部件的图像可能不足以容纳本地化文本。应用本身可能在某些语言中崩溃，因为它没有预料到会接收到任何非英语字符。通过在应用开发的早期实现本地化，你将节省自己很多精力，即使你的应用的第一版只本地化到一个地区。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll often see the word `Cordova` in our code examples in this book. PhoneGap
    was recently acquired by Adobe and the underlying code was given to the Apache
    Incubator project. This project is named `Cordova`, and PhoneGap utilizes it to
    provide its various services. So if you see `Cordova`, it really means the same
    thing for now.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在本书的代码示例中经常看到“Cordova”这个词。PhoneGap最近被Adobe收购，其底层代码被提交给了Apache孵化器项目。这个项目被命名为“Cordova”，PhoneGap利用它来提供其各种服务。所以如果你看到“Cordova”，现在它实际上意味着同一件事。
- en: How are we going to do it?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何做到这一点？
- en: 'We''re going to follow the typical development cycle: design, implement, and
    test the app. Our design phase won''t just include the user interface, but also
    the data model, that is, how our questions are stored and retrieved. The implementation
    will focus on our three stages of the app: the *start* view, the *game* view,
    and the *end* view. After implementation, we''ll test the app not only to make
    sure it properly handles localization but also to make sure that the game works
    correctly.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循典型的开发周期：设计、实现和测试应用。我们的设计阶段不仅包括用户界面，还包括数据模型，即我们的问题是如何存储和检索的。实现将专注于我们应用的三阶段：*起始*视图、*游戏*视图和*结束*视图。实现后，我们将测试应用，不仅是为了确保它正确处理本地化，还要确保游戏能正确运行。
- en: 'Here''s the general outline:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是总体概述：
- en: Designing the app, UI/interactions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计应用，UI/交互
- en: Designing the data model
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计数据模型
- en: Implementing the data model
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据模型
- en: Implementing the start view
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现起始视图
- en: Implementing the game view
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现游戏视图
- en: Implementing the end view
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现结束视图
- en: Putting it all together
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: What do I need to get started?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我需要准备些什么才能开始？
- en: First, be sure to download the latest version of PhoneGap from [http://phonegap.com/download](http://phonegap.com/download),
    currently 2.2.0 (as this was being written), and extract it to the appropriate
    directory. (For example, I use `/Applications/phonegap/phonegap220`.) Make sure
    that you have also installed the appropriate IDEs (Xcode for iOS development and
    Eclipse for Android development).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保从[http://phonegap.com/download](http://phonegap.com/download)下载最新版本的PhoneGap，目前是2.2.0（在撰写本文时），并将其提取到适当的目录中。（例如，我使用`/Applications/phonegap/phonegap220`。）确保你已经安装了适当的IDE（iOS开发的Xcode和Android开发的Eclipse）。
- en: Next, download the latest version of the YASMF framework from [https://github.com/photokandyStudios/YASMF/downloads](https://github.com/photokandyStudios/YASMF/downloads),
    and extract it anywhere. (For example, I used my `Downloads` folder.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从[https://github.com/photokandyStudios/YASMF/downloads](https://github.com/photokandyStudios/YASMF/downloads)下载最新版本的YASMF框架，并将其提取到任何位置。（例如，我使用了我的`下载`文件夹。）
- en: If you want a copy of the projects for this book in order to look at, or to
    avoid the following project-creation steps, you can download them at [https://github.com/photokandyStudios/phonegap-hotshot](https://github.com/photokandyStudios/phonegap-hotshot).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要这本书的项目副本以便查看，或者为了避免以下项目创建步骤，你可以从[https://github.com/photokandyStudios/phonegap-hotshot](https://github.com/photokandyStudios/phonegap-hotshot)下载。
- en: Next, you need to create a project for the various platforms you intend to support.
    Here's how we create both projects at once on Mac OS X. The commands should translate
    to Linux and Android-only projects with a little modification, and the same should
    apply to creating Android projects on Windows with some additional modification.
    For the following steps, consider `$PROJECT_HOME` to be the location of your project,
    `$PHONEGAP_HOME` to be the location where you installed PhoneGap, and `$YASMF_DOWNLOAD`
    to be the location where you extracted the YASMF framework.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要为您打算支持的各个平台创建一个项目。以下是我们在 Mac OS X 上同时创建两个项目的步骤。这些命令经过一点修改后应该适用于 Linux
    和仅 Android 的项目，同样，在 Windows 上创建 Android 项目时也需要进行一些额外的修改。对于以下步骤，请将 `$PROJECT_HOME`
    理解为您项目的位置，`$PHONEGAP_HOME` 理解为您安装 PhoneGap 的位置，`$YASMF_DOWNLOAD` 理解为您解压 YASMF
    框架的位置。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following steps are just the steps that I use when setting up a project.
    You can, of course, structure it however you would like, but you'll need to make
    any modifications with regards to the file references and the likes on your own.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤只是我在设置项目时使用的步骤。当然，您可以根据自己的喜好来结构化它，但您需要自己进行任何有关文件引用等方面的修改。
- en: 'The following steps assume that you have downloaded PhoneGap (Cordova) 2.2.0\.
    If you download a more recent version, the following steps *should* work with
    minimal modification:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤假设您已经下载了 PhoneGap (Cordova) 2.2.0。如果您下载了更晚的版本，以下步骤*应该*经过最小修改后可以工作：
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 购买的所有 Packt 书籍的账户中下载示例代码文件。如果您在其他地方购买了这本书，您可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以将文件直接通过电子邮件发送给您。
- en: 'Use the following code snippet:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Edit `Cordova.plist`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `Cordova.plist`。
- en: Search for `UIWebViewBounce`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `UIWebViewBounce`。
- en: Change the `<true/>` tag just below it to `<false/>`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其下面的 `<true/>` 标签更改为 `<false/>`。
- en: Search for `ShowSplashScreenSpinner`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `ShowSplashScreenSpinner`。
- en: Change the `<true/>` tag just below it to `<false/>`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其下面的 `<true/>` 标签更改为 `<false/>`。
- en: Search for `ExternalHosts`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `ExternalHosts`。
- en: Remove the `<array/>` line and replace it with "`<array>`", "`<string>*</string>`"
    and "`</array>`". This isn't always something you'd want to do for a production
    app, but as it allows for our apps to access the Internet with no restrictions,
    it's good for testing purposes.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `<array/>` 行，并用 "`<array>`", "`<string>*</string>`" 和 "`</array>`" 替换它。这并不是您在发布应用程序时总是想要做的事情，但因为它允许我们的应用程序无限制地访问互联网，所以这对于测试目的来说很好。
- en: Save the file.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Start Eclipse.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse。
- en: '**Navigate to File** | **New** | **Project…**.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导航到文件** | **新建** | **项目…**。'
- en: Select **Android Project**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Android 项目**。
- en: Click on **Next** **>**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步** **>**.
- en: Select the **Create project from existing source** option.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**从现有源创建项目**选项。
- en: Click on **Browse**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**浏览**。
- en: Navigate to `$PROJECT_HOME/Android/QuizTime/`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `$PROJECT_HOME/Android/QuizTime/`。
- en: Click on **Open**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开**。
- en: Click on **Next** **>**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步** **>**。
- en: Uncheck and re-check the highest **Google APIs** entry. (For some reason, Eclipse
    doesn't always keep the correct SDK version when doing this, so you may have to
    go back after the project is created and reset it. Just right-click any directory,
    **Configure Build Paths…** and go to the **Android** section. Then you can re-select
    the highest SDK.)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消勾选并重新勾选最高的**Google APIs**条目。（由于某种原因，Eclipse 在执行此操作时并不总是保留正确的 SDK 版本，因此您可能需要在项目创建后返回并重置它。只需右键单击任何目录，**配置构建路径…**并转到**Android**部分。然后您可以重新选择最高的
    SDK。）
- en: Click on **Next** **>**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步** **>**。
- en: Change the **Minimum SDK** value to 8.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**最小 SDK**值更改为 8。
- en: Click on **Finish**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**。
- en: Start Xcode.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Xcode。
- en: Navigate to **File** | **Open…**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**文件** | **打开…**。
- en: Navigate to the project in `$PROJECT_HOME/iOS`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `$PROJECT_HOME/iOS` 中的项目。
- en: Click on **Open**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开**。
- en: At this point you should have Xcode and Eclipse open with the project. Close
    both; we'll be using our favorite editor for now.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经打开了 Xcode 和 Eclipse 并加载了项目。请关闭它们；我们现在将使用我们最喜欢的编辑器。
- en: 'When the project is created, the following directory structure results:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目创建时，以下目录结构会出现：
- en: '`/Android: The Android project`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Android: Android 项目`'
- en: '`/iOS: The iOS project`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/iOS: iOS 项目`'
- en: '`/www`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/www`'
- en: '`/cordova`: We''ll place the PhoneGap support libraries here.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cordova`：我们将在这里放置PhoneGap支持库。'
- en: '`/framework`: Our framework will be in this directory.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/framework`：我们的框架将放在这个目录中。'
- en: '`/cultures`: Any localization configuration will be placed here. The framework
    comes with `en-US`.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cultures`：任何本地化配置都将放在这里。框架自带`en-US`。'
- en: '`/images`: All of our images will be in this directory.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/images`：我们所有的图像都将放在这个目录中。'
- en: '`/views`: All of our views will be here.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/views`：所有我们的视图都将放在这里。'
- en: '`/models`: All of our data models will be here.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/models`：所有我们的数据模型都将放在这里。'
- en: '`/style`: Any custom CSS we need to use will live here.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/style`：我们需要的任何自定义CSS都将放在这里。'
- en: Once you've created the project, you also need to download the jQuery/Globalize
    repository from [https://github.com/jquery/globalize](https://github.com/jquery/globalize).
    There's a lot of content there, but we're most interested in the `lib` directory.
    Copy the `globalize.culture.en-US.js` and `globalize.culture.es-ES.js` files to
    the `www/framework/cultures` directory. (If you want, feel free to copy other
    culture files as well, if you want to try your hand at localizing in a language
    you know.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了项目，你还需要从[https://github.com/jquery/globalize](https://github.com/jquery/globalize)下载jQuery/Globalize仓库。那里有很多内容，但我们最感兴趣的是`lib`目录。将`globalize.culture.en-US.js`和`globalize.culture.es-ES.js`文件复制到`www/framework/cultures`目录。（如果你想，也可以复制其他文化文件，如果你想尝试在你所了解的语言中进行本地化。）
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using Eclipse, you must make absolutely certain that all the files
    you use in the `www` directory are set to the proper encoding. The easiest way
    to do this is to right-click on the `assets` directory, click on `Properties`,
    and then click on `Other`. Select the `UTF-8` option from the drop-down list and
    click on `Apply`. If you don't do this, it is entirely possible that some of your
    localized content will not be displayed correctly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Eclipse，你必须确保你在`www`目录中使用的所有文件都设置为正确的编码。最简单的方法是在`assets`目录上右键单击，点击`属性`，然后点击`其他`。从下拉列表中选择`UTF-8`选项，然后点击`应用`。如果你不这样做，完全有可能你的一些本地化内容将无法正确显示。
- en: Designing the app – UI/interactions
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计应用程序 – UI/交互
- en: In this first task we'll be designing the look and feel of the application as
    well as specifying the interactions between the various elements in the user interface
    and the player. For most of this task you can use pencil and paper or a graphics
    editor, though at some point you'll need a graphics editor such as Adobe Photoshop
    or GIMP in order to create some of the resources you'll need for the app.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个任务中，我们将设计应用程序的外观和感觉，以及指定用户界面中各种元素与播放器之间的交互。对于这个任务的大部分，你可以使用铅笔和纸或者图形编辑器，但在某个时候，你需要一个图形编辑器，如Adobe
    Photoshop或GIMP，以便创建应用程序所需的某些资源。
- en: Getting on with it
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动
- en: 'The difficulty when it comes to designing an app that can run on more than
    one platform is that each platform has many different ideas when it comes to how
    things should look on the screen. There are several ways to approach this; they
    are discussed as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个可以在多个平台上运行的应用程序时遇到的困难是，每个平台在屏幕上如何显示事物方面都有自己的许多不同想法。有几种方法可以解决这个问题；以下将进行讨论：
- en: You can build the user interface for the majority of your market, and use the
    exact interface on all the other devices (but be careful; this will often lead
    to poor reviews).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为你的主要市场构建用户界面，并在所有其他设备上使用完全相同的界面（但要注意；这通常会导致差评）。
- en: You could decide to customize the app's user interface for each device. This
    often requires a significant amount of work to accomplish and get it *just right*,
    but it can be very rewarding, especially when the end user has no idea the app
    wasn't written just for their own platform.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以决定为每个设备定制应用程序的用户界面。这通常需要大量的工作来完成，并且要确保做得“恰到好处”，但这可以是非常有回报的，尤其是当最终用户不知道应用程序不是只为他们的平台编写的。
- en: Or you could create a platform-agnostic look and feel. This is the direction
    we'll take in this app. The interface would be reasonably at home on iOS and Android
    devices. That's not to say that the appearance will be identical on both devices;
    it won't, but it will be similar while incorporating some of the platform-specific
    notions as well.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以创建一个平台无关的外观和感觉。这是我们在这个应用中将要采取的方向。界面在iOS和Android设备上都会感觉相当舒适。这并不是说这两个设备上的外观将完全相同；它们不会，但它们将相似，同时也会融入一些特定平台的观念。
- en: 'Before we go too much further, we need to get out our pencil and paper and
    sketch out an idea of how we want our app to look. It should be similar to the
    following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们走得更远之前，我们需要拿出我们的铅笔和纸，并勾勒出我们想要的应用程序外观的想法。它应该类似于以下截图：
- en: '![Getting on with it](img/9403OS_01_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403OS_01_01.jpg)'
- en: Our start view is a fairly simple view. At the top of the view we will have
    a navigation bar containing our app's title. In other views, this bar would often
    have other buttons in it, including one to go back to the previous view. At the
    bottom of the view, we will have a toolbar which will contain buttons relevant
    to the current view.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开场视图是一个相当简单的视图。在视图的顶部，我们将有一个包含我们应用程序标题的导航栏。在其他视图中，这个栏通常会包含其他按钮，包括一个返回上一个视图的按钮。在视图的底部，我们将有一个包含与当前视图相关的按钮的工具栏。
- en: The app's title will be an image containing the title of the application. This
    image should be made using a font that's fun and stylistic. The image will be
    appropriately localized.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的标题将是一个包含应用程序标题的图像。这个图像应该使用有趣和风格的字体制作。图像将适当本地化。
- en: 'We''ll have one button in the toolbar: a **Start** button. The text needs to
    be localized.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具栏中我们将有一个按钮：一个**开始**按钮。文本需要本地化。
- en: Below the navigation bar is the content area. Here we describe what the app
    will do. We won't have anything terribly fancy here; our space is limited, especially
    since we are restricted to the phone's screen size. In the future, we'll talk
    about how to allow content to scroll, but for now we'll keep it short and simple.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航栏下方是内容区域。在这里我们描述应用将要做什么。我们这里不会有非常花哨的东西；我们的空间有限，尤其是因为我们被限制在手机屏幕大小内。在未来，我们将讨论如何允许内容滚动，但现在我们将保持简洁。
- en: We do want to add a little bit of pizazz to the view, so we'll add a color splash
    to the background. You could make this anything you want, we'll go with rays of
    color shooting up from the bottom.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实想要在视图中添加一点魅力，所以我们将添加背景的彩色泼溅。你可以把它做成任何你想要的样子，我们将选择从底部向上射出的彩色光线。
- en: 'Our game view looks like the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏视图看起来如下截图所示：
- en: '![Getting on with it](img/9403OS_01_02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403OS_01_02.jpg)'
- en: Our game view is the most complex view we have in this app. Let's start outward
    and work in.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏视图是我们在这个应用程序中最复杂的视图。让我们从外部开始，逐步深入。
- en: At the top, our navigation bar will indicate the current question number. This
    lets the player know how many questions they've answered. To the left of the text
    is a **Back** button. If clicked, it should take the player back to the start
    view.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们的导航栏将指示当前问题编号。这会让玩家知道他们已经回答了多少问题。在文本的左侧是一个**返回**按钮。如果点击，它应该将玩家带回到开场视图。
- en: 'At the bottom, our toolbar contains a single button: **Skip**. This button
    will allow the player to skip any question they don''t want to answer. For now,
    we won''t assign any penalty to skipping a question, but you could always add
    a score deduction or something worse if you wanted to do so. If you removed the
    button entirely, it would be wise to remove the toolbar as well.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，我们的工具栏中只有一个按钮：**跳过**。这个按钮将允许玩家跳过他们不想回答的任何问题。目前，我们不会对跳过问题进行任何惩罚，但如果你愿意，可以添加分数扣除或其他更糟糕的惩罚。如果你完全移除了这个按钮，那么也明智地移除工具栏。
- en: In the middle is our content area, the most complex portion of the view; at
    the top we have the player's score, which needs to be localized. Below it is the
    question being asked, again, properly localized.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间是我们的内容区域，这是视图中最复杂的部分；在顶部我们显示玩家的得分，这需要本地化。在其下方是正在提出的问题，同样需要正确本地化。
- en: Below the question, we have several buttons; these need to be generated dynamically
    based on the question being asked. Not every question will have three answers;
    there may be some with two answers or some with four or more. The answers themselves
    also need to be properly localized.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题下方，我们有几个按钮；这些按钮需要根据提出的问题动态生成。并非每个问题都会有三个答案；可能有些有两个答案，或者有四个或更多。答案本身也需要正确本地化。
- en: Tapping a button will check to see if the button is labeled with the correct
    answer. If it is, we'll display a nice notice and increment the score. If it isn't,
    we'll indicate such and decrement the score.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 点击一个按钮将检查按钮是否标记了正确的答案。如果是，我们将显示一个漂亮的提示并增加分数。如果不是，我们将指出这一点并减少分数。
- en: 'After a question is answered or skipped, we''ll get a new question and display
    it on the screen. Then, after ten questions have been answered, we''ll end the
    game. The end view looks like the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答或跳过一个问题后，我们将得到一个新的问题并在屏幕上显示它。然后，在回答了十个问题之后，我们将结束游戏。结束视图看起来如下截图所示：
- en: '![Getting on with it](img/9403OS_01_03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403OS_01_03.jpg)'
- en: The end view is similar to the start view in that it isn't terribly complex,
    but it does have a little more going on. It needs to properly display the final
    score and permit the player to play the game again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结束视图与起始视图相似，它并不特别复杂，但它确实有一些额外的功能。它需要正确显示最终得分并允许玩家再次玩游戏。
- en: The navigation bar contains the text **Results** and also a **Back** button.
    If tapped, it is the same thing as starting the game all over again.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏包含文本**结果**以及一个**返回**按钮。如果被点击，它与从头开始玩游戏相同。
- en: The toolbar contains the **Try** **Again?** button. If tapped, it also starts
    the game again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏包含**重试？**按钮。如果被点击，它也会重新开始游戏。
- en: In the content area, we display a message containing the final score, and the
    date when it was achieved.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容区域，我们显示包含最终得分和完成日期的消息。
- en: Of course, all of the content on the view needs to be properly localized. Numbers
    are hard enough; dates are even worse. It's a good thing that we have jQuery/Globalize
    to fall back on, or we'd have to do the hard work of localizing the date ourselves.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，视图上的所有内容都需要进行适当的本地化。数字已经很难处理；日期更是如此。幸好我们有jQuery/Globalize可以依赖，否则我们就不得不自己进行日期的本地化工作。
- en: Now that we've sketched the user interface, it's time to start building some
    of the resources we'll need in our app. Open up your graphics editor and build
    a template of what any one of the views would look like. What we're doing here
    is determining what parts of the display will need to have images generated, and
    what parts will be able to be text or CSS-generated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经绘制了用户界面，是时候开始构建我们应用程序中需要的资源了。打开您的图形编辑器，构建一个任何视图可能看起来像的模板。我们在这里做的是确定显示的哪些部分需要生成图像，哪些部分可以使用文本或CSS生成。
- en: It's not super critical that you have the exact dimensions of any specific device.
    After all, the app can run on many different devices, each of which has a different
    screen size. We'll use 640 x 920 px, which just happens to be the available area
    on the screen for an iPhone 4 with a Retina display.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 并非绝对需要您有任何特定设备的精确尺寸。毕竟，应用程序可以在许多不同的设备上运行，每个设备都有不同的屏幕尺寸。我们将使用640 x 920 px，这恰好是iPhone
    4 Retina显示屏上的可用区域。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You do need to design using a high-enough resolution to get Retina-quality assets
    out of the design. That is, if you expect an icon to be 32 x 32 px, you will actually
    want it to be 64 x 64 px. Now whether you build on an exact size is up to you,
    but it's best to target the device you think will get the most use.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您确实需要使用足够高的分辨率进行设计，以便从设计中获得Retina品质的资产。也就是说，如果您期望一个图标为32 x 32 px，您实际上希望它是64
    x 64 px。现在，您是否构建在确切的大小上取决于您，但最好针对您认为将获得最多使用的设备。
- en: 'Here''s the final template we''re using:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们使用的最终模板：
- en: '![Getting on with it](img/9403_01_04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_01_04.jpg)'
- en: There's a little bit of a texture there. While it's possible to do this in CSS,
    it's easiest to use images instead. The texture itself is tile-able and so it
    can adapt to any screen size. The navigation bar should be placed in the `images`
    directory and named `NavigationBar.png`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有一点纹理。虽然您可以在CSS中完成这个任务，但使用图像更容易。这个纹理是可平铺的，因此它可以适应任何屏幕尺寸。导航栏应放置在`images`目录中，并命名为`NavigationBar.png`。
- en: Notice the title? While this could also be handled by CSS and adding the font
    to your app, that gets into a lot of sticky licensing issues. Instead, we'll use
    an image of it, which means the font itself will never get distributed. The title
    should be placed in the `images` directory and named `AppTitle-enus.png`. The
    Spanish version (which should read *¡Examen Tiempo!*) should be named `AppTitle-eses.png`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意标题吗？虽然这也可以通过CSS和将字体添加到您的应用程序中处理，但这会涉及到许多棘手的许可问题。相反，我们将使用它的图像，这意味着字体本身永远不会被分发。标题应放置在`images`目录中，并命名为`AppTitle-enus.png`。西班牙语版本（应读作*¡Examen
    Tiempo!）应命名为`AppTitle-eses.png`。
- en: The background will also be an image, though you could likely approximate it
    with CSS (though getting the texture there would be a bit painful). Since we're
    supporting many platforms and screen sizes, the image approach is the best. This
    image should be saved in the `images` directory and named `Background.jpg`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 背景也将是一张图片，尽管你很可能会用CSS来近似它（尽管在那里获得纹理可能会有些痛苦）。由于我们支持许多平台和屏幕尺寸，图片方法是最好的。这张图片应保存在`images`目录中，命名为`Background.jpg`。
- en: We'll build the app so that the image stretches to fill the screen. There will
    be some minor distortion, of course, but since this image is just a color splash,
    it doesn't really matter. (Other options include creating the background at various
    resolutions, or to create a tile-able background that fills easily to any resolution.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建应用程序，使图片拉伸以填充屏幕。当然，会有一些轻微的扭曲，但鉴于这张图片只是一个色彩泼溅，这并不重要。（其他选项包括创建不同分辨率的背景，或者创建一个可平铺的背景，可以轻松填充到任何分辨率。）
- en: The button, on the other hand, is easy to build in CSS, and it's easy enough
    to get right on many platforms. In the worst case, the button won't be quite as
    shiny or rounded, but it'll still convey that it should be touched.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，按钮在CSS中构建起来很容易，而且在许多平台上很容易正确设置。在最坏的情况下，按钮可能不会那么闪亮或圆润，但它仍然会传达出它应该被触摸的信息。
- en: The middle area is where everything else will go, the player's score, the current
    question, the answers to the question, and so on. Since all of that is easily
    achievable with HTML, CSS, and JavaScript, we're not going to worry about putting
    those elements into the template.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 中间区域是放置其他所有内容的地方，玩家的得分、当前问题、问题的答案等等。由于所有这些都可以用HTML、CSS和JavaScript轻松实现，所以我们不会担心将这些元素放入模板中。
- en: What did we do?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task we designed our user interface and also spelled out the interaction
    between the various views and widgets. We indicated what parts we knew would need
    to be localized (everything!) and then drew up a pretty version of it in our favorite
    graphics editor. From this version we can splice the various elements that need
    to be saved as images while also identifying what portions can be rendered with
    HTML, CSS, and JavaScript.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们设计了用户界面，并详细说明了各种视图和组件之间的交互。我们指出了哪些部分需要本地化（所有内容！）然后在我们的首选图形编辑器中绘制了一个漂亮的版本。从这个版本中，我们可以剪切需要保存为图片的各种元素，同时确定哪些部分可以用HTML、CSS和JavaScript渲染。
- en: Designing the data model
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计数据模型
- en: 'The data model is very important to get right: this is how we''ll store our
    questions, the answers to those questions, and which answer is the correct answer
    for each of the questions. We''ll also define how we should interact with the
    model, that is, how do we get a question, ask it if the answer is correct, and
    so forth.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型正确性至关重要：这是我们存储问题、问题的答案以及每个问题的正确答案的方式。我们还将定义如何与模型交互，即如何获取问题、询问答案是否正确，等等。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's get out our pencil and paper again, or if you'd prefer, a diagramming
    tool that you're comfortable with. What we're really trying to do in this step
    is to come up with the properties the model needs in order to store the questions,
    and the interactions it will need in order to properly do everything we're asking
    of it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次拿出铅笔和纸，或者如果你更喜欢，使用你熟悉的图表工具。我们真正试图在这个步骤中做的是找出模型需要存储问题的属性，以及它为了正确完成我们所要求的一切所需的交互。
- en: Getting on with it
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'We''ll essentially have two data models: a single question, and a collection
    of questions. Let''s start with what the question model should do:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基本上有两个数据模型：单个问题和问题集合。让我们从问题模型应该做什么开始：
- en: Store the actual question
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储实际问题
- en: Have a list of all the possible answers
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个所有可能答案的列表
- en: Know the correct answer
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道正确答案
- en: Set the question when created
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建时设置问题
- en: Return the question when asked
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当被要求时返回问题
- en: Add an answer to its list of answers
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将答案添加到其答案列表中
- en: Return the list of answers when asked (in a random order)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当被要求时返回答案列表（以随机顺序）
- en: Set the correct answer
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置正确答案
- en: Give the correct answer when asked
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当被要求时给出正确答案
- en: Return a specific answer in the list when asked
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当被要求时返回列表中的特定答案
- en: Check if a given answer is correct
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查给定的答案是否正确
- en: Return the number of answers
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回答案的数量
- en: 'We can indicate this by creating a simple diagram as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建以下简单的图表来表示这一点：
- en: '![Getting on with it](img/9403OS_01_05.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403OS_01_05.jpg)'
- en: 'Our collection of questions should:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的问题集合应该：
- en: Have a list of all the questions
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个所有问题的列表
- en: Be able to add a question to that list
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将问题添加到该列表中
- en: Return the total number of questions in the list
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回列表中的问题总数
- en: Return a random question from the list
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中返回一个随机问题
- en: 'The diagram covering these points would look like the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 包含这些点的图表看起来如下截图所示：
- en: '![Getting on with it](img/9403OS_01_06.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403OS_01_06.jpg)'
- en: 'Having both of the models defined, let''s come up with the questions we''re
    going to ask, as well as the answers that will go along with them (for the full
    list of questions, see `chapter1/www/models/quizQuestions.js` in the download
    for this book):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了两个模型之后，让我们想出我们将要提出的问题，以及与之相关的答案（对于问题的完整列表，请参阅本书下载中的`chapter1/www/models/quizQuestions.js`）：
- en: '| # | English | Spanish |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| # | 英语 | 西班牙语 |'
- en: '| --- | --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `1` | What is the color of the Sun? | ¿Cuál es el color del Sol? |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 太阳的颜色是什么？ | 太阳的颜色是什么？ |'
- en: '|   | Green | Verde |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|   | 绿色 | 绿色 |'
- en: '|   | White | Blanco |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|   | 白色 | 白色 |'
- en: '|   | Yellow (correct) | Amarillo (correct) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|   | 黄色（正确） | 黄色（正确） |'
- en: '| `2` | What is the name of the fourth planet? | ¿Cuál es el nombre del cuarto
    planeta? |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 第四颗行星的名字是什么？ | ¿Cuál es el nombre del cuarto planeta? |'
- en: '|   | Mars (correct) | Marzo (correct) |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|   | 火星（正确） | 火星（正确） |'
- en: '|   | Venus | Venus |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|   | 金星 | 金星 |'
- en: '|   | Mercury | Mercurio |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|   | 水星 | 水星 |'
- en: With the design of our model complete, and the questions we're going to ask,
    this task is complete. Next we'll write the code to implement the model.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型设计完成，以及我们将要提出的问题，这个任务就完成了。接下来，我们将编写代码来实现这个模型。
- en: What did we do?
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: 'In this task we designed two data models: a single question and a collection
    of questions. We also determined the questions we were going to ask, along with
    their localized variants.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们设计了两个数据模型：单个问题和问题集合。我们还确定了我们将要提出的问题，以及它们的本地化版本。
- en: Implementing the data model
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据模型
- en: 'We''ll be creating two JavaScript files in the `www/models` directory named
    `quizQuestion.js` and `quizQuestions.js`. The file `quizQuestion.js` will be the
    actual model: it will specify how the data should be formatted and how we can
    interact with it. `quizQuestions.js` will contain our actual question data.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`www/models`目录中创建两个JavaScript文件，分别命名为`quizQuestion.js`和`quizQuestions.js`。`quizQuestion.js`将是实际的模型：它将指定数据应该如何格式化以及我们如何与之交互。`quizQuestions.js`将包含我们实际的问题数据。
- en: Getting on with it
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: Before we define our model, let's define a namespace where it will live. This
    is an important habit to establish since it relieves us of having to worry about
    whether or not we'll collide with another function, object, or variable of the
    same name.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义我们的模型之前，让我们定义一个命名空间，它将驻留于此。这是一个重要的习惯，因为它使我们不必担心是否会与其他具有相同名称的函数、对象或变量发生冲突。
- en: 'While there are various methods used to create a namespace, we''re going to
    do it simply using the following code snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有各种方法可以创建命名空间，但我们将使用以下代码片段简单地完成它：
- en: '[PRE1]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that our namespace is defined, we can create our `question` object as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了命名空间，我们可以创建我们的`question`对象如下：
- en: '[PRE2]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note the use of `self`: this will allow us to refer to the object using `self`
    rather than using `this`. (Javascript''s `this` is a bit nuts, so it''s always
    better to refer to a variable that we know will always refer to the object.)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`self`的使用：这将允许我们使用`self`来引用对象，而不是使用`this`。（JavaScript的`this`有点疯狂，所以我们总是最好引用一个我们知道它始终指向对象的变量。）
- en: 'Next, we''ll set up the properties based on the diagram we created from step
    two using the following code snippet:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据第二步中创建的图表设置属性，使用以下代码片段：
- en: '[PRE3]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've set the `self.correctAnswer` value to `-1` to indicate that, at the moment,
    any answer provided by the player is considered correct. This means you can ask
    questions where all of the answers are right.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`self.correctAnswer`的值设置为`-1`，以表示，目前，玩家提供的任何答案都被认为是正确的。这意味着你可以提出所有答案都正确的问题。
- en: 'Our next step is to define the methods or interactions the object will have.
    Let''s start with determining if an answer is correct. In the following code,
    we will take an incoming answer and compare it to the `self.correctAnswer` value.
    If it matches, or if the `self.correctAnswer` value is `-1`, we''ll indicate that
    the answer is correct:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是定义对象将拥有的方法或交互。让我们从确定一个答案是否正确开始。在以下代码中，我们将取一个传入的答案并将其与`self.correctAnswer`值进行比较。如果它们匹配，或者`self.correctAnswer`的值是`-1`，我们将表示答案正确：
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re going to need a way to access a specific answer, so we''ll define the
    `answerAtIndex` function as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来访问特定的答案，所以我们将定义`answerAtIndex`函数如下：
- en: '[PRE5]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To be a well-defined model, we should always have a way of determining the
    number of items in the model as shown in the following code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成为一个定义良好的模型，我们应该始终有一种方法来确定模型中的项目数量，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to define a method that allows an answer to be added to our object.
    Note that with the help of the return value, we return ourselves to permitting
    daisy-chaining in our code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个方法，允许向我们的对象添加一个答案。注意，借助返回值，我们返回自己以允许代码中的链式调用：
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In theory we could display the answers to a question in the order they were
    given to the object. In practice, that would turn out to be a pretty boring game:
    the answers would always be in the same order, and chances would be pretty good
    that the first answer would be the correct answer. So let''s give ourselves a
    randomized list using the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以按照对象接收到的顺序显示问题的答案。在实践中，那将是一个非常无聊的游戏：答案总是以相同的顺序出现，而且第一个答案很可能是正确答案。所以让我们使用以下代码片段来给自己一个随机列表：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The randomized list is just an array of numbers that indexes into the `answers[]`
    array. To get the actual answer, we'll have to use the `answerAtIndex()` method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 随机列表只是一个数字数组，它索引到`answers[]`数组。为了获取实际的答案，我们必须使用`answerAtIndex()`方法。
- en: 'Our model still needs a way to set the correct answer. Again, notice the return
    value in the following code snippet permitting us to daisy-chain later on:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型仍然需要一个设置正确答案的方法。再次注意以下代码片段中的返回值，它允许我们稍后进行链式调用：
- en: '[PRE9]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we''ve properly set the correct answer, what if we need to ask the
    object what the correct answer is? For this let''s define a `getCorrectAnswer`
    function using the following code snippet:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确地设置了正确答案，如果我们需要询问对象正确答案是什么怎么办？为此，让我们定义一个`getCorrectAnswer`函数，使用以下代码片段：
- en: '[PRE10]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, our object also needs to return the question given to it whenever
    it was created; this can be done using the following code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的对象还需要返回在创建时给出的任何问题；这可以通过以下代码片段来完成：
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That''s it for the `question` object. Next we''ll create the container that
    will hold all of our questions using the following code line:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`question`对象来说，这就足够了。接下来，我们将创建一个容器来存储所有的问题，使用以下代码行：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We could go the regular object-oriented approach and make the container an object
    as well, but in this game we have only one list of questions, so it's easier to
    do it this way.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取常规的面向对象方法，将容器也做成一个对象，但在这个游戏中我们只有一个问题列表，所以这样做更简单。
- en: 'Next, we need to have the ability to add a question to the container, this
    can be done using the following code snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要有能力向容器中添加一个问题，这可以通过以下代码片段来完成：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Like any good data model, we need to know how many questions we have; we can
    know this using the following code snippet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 任何好的数据模型都需要知道我们有多少个问题；我们可以使用以下代码片段来了解这一点：
- en: '[PRE14]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we need to be able to get a random question out of the list so that
    we can show it to the player; this can be done using the following code snippet:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要能够从列表中随机获取一个问题，以便我们可以向玩家展示；这可以通过以下代码片段来完成：
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our data model is officially complete. Let''s define some questions using the
    following code snippet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据模型已经正式完成。让我们使用以下代码片段来定义一些问题：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice how we attach the `addAnswer` and `setCorrectAnswer` methods to the
    new question object. This is what is meant by daisy-chaining: it helps us write
    just a little bit less code.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何将`addAnswer`和`setCorrectAnswer`方法附加到新的问题对象上的。这就是所谓的链式调用：它帮助我们少写一点代码。
- en: 'You may be wondering why we''re using upper-case text for the questions and
    answers. This is due to how we''ll localize the text, which is next:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们使用大写字母来表示问题和答案。这是因为我们将如何本地化文本，这是下一步：
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The questions and answers themselves serve as keys to the actual translation.
    This serves two purposes: it makes the keys obvious in our code, so we know that
    the text will be replaced later on, and should we forget to include a translation
    for one of the keys, it''ll show up in uppercase letters.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 问题与答案本身是实际翻译的钥匙。这有两个作用：它使我们的代码中的键显而易见，这样我们知道文本将在以后被替换，如果我们忘记为某个键包含翻译，它将以大写字母的形式出现。
- en: '`PKLOC` as used in the earlier code snippet is the namespace we''re using for
    our localization library. It''s defined in `www/framework/localization.js`. The
    `addTranslation` method is a method that adds a translation to a specific locale.
    The first parameter is the locale for which we''re defining the translation, the
    second parameter is the key, and the third parameter is the translated text.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中使用的 `PKLOC` 是我们用于本地化库的命名空间。它在 `www/framework/localization.js` 中定义。`addTranslation`
    方法是一个将翻译添加到特定区域的方法。第一个参数是我们为定义翻译指定的区域，第二个参数是键，第三个参数是翻译文本。
- en: 'The `PKLOC.addTranslation` function looks like the following code snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`PKLOC.addTranslation` 函数看起来像以下代码片段：'
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `addTranslation` method first checks to see if an array is defined under
    the `PKLOC.localizedText` array for the desired locale. If it is there, it just
    adds the key/value pair. If it isn''t, it creates the array first and then adds
    the key/value pair. You may be wondering how the `PKLOC.localizedText` array gets
    defined in the first place. The answer is that it is defined when the script is
    loaded, a little higher in the file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`addTranslation` 方法首先检查在 `PKLOC.localizedText` 数组下是否定义了所需区域的数组。如果存在，它就添加键/值对。如果不存在，它首先创建数组，然后添加键/值对。你可能想知道
    `PKLOC.localizedText` 数组最初是如何定义的。答案是它在脚本加载时定义，在文件中稍微高一点的位置：'
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Continue adding questions in this fashion until you've created all the questions
    you want. The `quizQuestions.js` file contains ten questions. You could, of course,
    add as many as you want.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式继续添加问题，直到你创建了所有想要的问题。`quizQuestions.js` 文件包含十个问题。当然，你可以添加尽可能多的。
- en: What did we do?
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we created our data model and created some data for the model.
    We also showed how translations are added to each locale.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们创建了我们的数据模型并为模型创建了一些数据。我们还展示了如何将翻译添加到每个区域。
- en: What else do I need to know?
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: 'Before we move on to the next task, let''s cover a little more of the localization
    library we''ll be using. Our localization efforts are split into two parts: translation
    and data formatting.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行下一个任务之前，让我们先了解一下我们将要使用的本地化库的一些内容。我们的本地化工作分为两个部分：翻译和数据格式化。
- en: 'For the translation effort, we''re using our own simple translation framework,
    literally just an array of keys and values based on locale. Whenever code asks
    for the translation for a key, we''ll look it up in the array and return whatever
    translation we find, if any. But first, we need to determine the actual locale
    of the player, using the following code snippet:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于翻译工作，我们使用我们自己的简单翻译框架，实际上只是一个基于区域的键和值的数组。每当代码请求某个键的翻译时，我们将在数组中查找它，并返回我们找到的任何翻译，如果有的话。但首先，我们需要确定玩家的实际区域，使用以下代码片段：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Determining the locale isn't hard, but neither is it as easy as you would initially
    think. There is a property (`navigator.language`) under WebKit browsers that is
    technically supposed to return the locale, but it has a bug under Android, so
    we have to use the `userAgent`. For WP7, we have to use one of three properties
    to determine the value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 确定区域并不难，但也不是像你最初想象的那样容易。WebKit 浏览器下有一个属性（`navigator.language`），从技术上讲应该返回区域，但在
    Android 下有一个错误，因此我们必须使用 `userAgent`。对于 WP7，我们必须使用三个属性之一来确定值。
- en: 'Because that takes some work, we''ll check to see if we''ve defined it before;
    if we have, we''ll return that value instead:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这需要一些工作，所以我们会检查我们是否已经定义了它；如果我们已经定义了它，我们将返回那个值：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we determine the current device we''re on by using the `device` object
    provided by Cordova. We''ll check for it first, and if it doesn''t exist, we''ll
    assume we can access it using one of the four properties attached to the `navigator`
    object using the following code snippet:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用 Cordova 提供的 `device` 对象来确定我们当前所在的设备。我们首先检查它是否存在，如果不存在，我们将假设我们可以使用以下代码片段通过
    `navigator` 对象的四个属性之一来访问它：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll also provide a suitable default locale if we can''t determine the user''s
    locale at all as seen in the following code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法确定用户的区域设置，我们将提供合适的默认区域设置，如下代码片段所示：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, we handle parsing the user agent if we're on an Android platform. The
    following code is heavily inspired by an answer given online at [http://stackoverflow.com/a/7728507/741043](http://stackoverflow.com/a/7728507/741043).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们在 Android 平台上，我们将处理解析用户代理。以下代码大量借鉴了在线提供的答案 [http://stackoverflow.com/a/7728507/741043](http://stackoverflow.com/a/7728507/741043)。
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we''re on any other platform, we''ll use the `navigator` object to retrieve
    the locale as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在任何其他平台上，我们将使用 `navigator` 对象来检索区域设置，如下所示：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once we have the locale, we return it as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了区域设置，我们就如下返回它：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This method is called over and over by all of our translation codes, which
    means it needs to be efficient. This is why we''ve defined the `PKLOC.currentUserLocale`
    property. Once it is set, the preceding code won''t try to calculate it out again.
    This also introduces another benefit: we can easily test our translation code
    by overwriting this property. While it is always important to test that the code
    properly localizes when the device is set to a specific language and region, it
    often takes considerable time to switch between these settings. Having the ability
    to set the specific locale helps us save time in the initial testing by bypassing
    the time it takes to switch device settings. It also permits us to focus on a
    specific locale, especially when testing.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被所有我们的翻译代码反复调用，这意味着它需要高效。这就是为什么我们定义了 `PKLOC.currentUserLocale` 属性。一旦设置，前面的代码就不会再尝试计算它。这也带来了另一个好处：我们可以通过覆盖此属性轻松测试我们的翻译代码。虽然始终重要的是要测试当设备设置为特定语言和区域时代码是否正确本地化，但切换这些设置通常需要相当多的时间。能够设置特定的区域设置有助于我们在初始测试中节省时间，因为它绕过了切换设备设置所需的时间。它还允许我们专注于特定的区域设置，尤其是在测试时。
- en: Translation of text is accomplished by a convenience function named `__T()`.
    The convenience functions are going to be our only functions outside of any specific
    namespace simply because we are aiming for easy-to-type and easy-to-remember names
    that aren't arduous to add to our code. This is especially important since they'll
    wrap every string, number, date, or percentage in our code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 文本翻译是通过名为 `__T()` 的便利函数完成的。便利函数将成为我们除特定命名空间之外的唯一函数，因为我们旨在使用易于输入和易于记忆的名称，这些名称不会使我们的代码变得复杂。这尤其重要，因为它们将包装我们代码中的每个字符串、数字、日期或百分比。
- en: 'The `__T()` function depends on two functions: `substituteVariables` and `lookupTranslation`.
    The first function is defined as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`__T()` 函数依赖于两个函数：`substituteVariables` 和 `lookupTranslation`。第一个函数定义如下：'
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All this function does is handle the substitution variables. This means we can
    define a translation with `%1` in the text and we will be able to replace `%1`
    with some value passed into the function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数所做的只是处理替换变量。这意味着我们可以在文本中定义一个带有 `%1` 的翻译，并且我们能够用传递给函数的某个值替换 `%1`。
- en: 'The next function, `lookupTranslation`, is defined as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数 `lookupTranslation` 定义如下：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Essentially, we're checking to see if a specific translation exists for the
    given key and locale. If it does, we'll return the translation, but if it doesn't,
    we'll return `null`. Note that the key is always converted to uppercase, so case
    doesn't matter when looking up a translation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们正在检查是否存在针对给定键和区域设置的特定翻译。如果存在，我们将返回翻译，如果不存在，我们将返回 `null`。请注意，键始终被转换为大写，因此在查找翻译时大小写无关紧要。
- en: 'Our `__T()` function looks as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `__T()` 函数如下所示：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'First, we determine if the translation requested can be found in the locale,
    whatever that may be. Note that it can be passed in, therefore overriding the
    current locale. This can be done using the following code snippet:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确定请求的翻译是否可以在区域设置中找到，无论该区域设置是什么。请注意，它可以传递，因此可以覆盖当前区域设置。这可以通过以下代码片段完成：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Locales are often of the form `xx-YY`, where `xx` is a two-character language
    code and `YY` is a two-character character code. My locale is defined as `en-US`.
    Another player's might be defined as `es-ES`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 区域设置通常具有 `xx-YY` 的形式，其中 `xx` 是两位字符的语言代码，而 `YY` 是两位字符的区域代码。我的区域设置定义为 `en-US`。另一个玩家的可能被定义为
    `es-ES`。
- en: 'If you recall, we defined our translations only for the language. This presents
    a problem: the preceding code will not return any translation unless we defined
    the translation for the language and the country.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们只为语言定义了翻译。这带来了一个问题：前面的代码除非我们为语言和国家定义了翻译，否则不会返回任何翻译。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes it is critical to define a translation specific to a language and
    a country. While various regions may speak the same language from a technical
    perspective, idioms often differ. If you use an idiom in your translation, you'll
    need to localize them to the specific region that uses them, or you could generate
    potential confusion.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有时定义特定于语言和国家的翻译是至关重要的。虽然从技术角度来看，各个地区可能说同一种语言，但习语往往不同。如果你在翻译中使用习语，你需要将它们本地化到使用它们的特定地区，否则可能会产生混淆。
- en: 'Therefore, we chop off the country code, and try again as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们截断国家代码，并尝试以下操作：
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But we''ve only defined translations for English (`en`) and Spanish(`es`)!
    What if the player''s locale is `fr-FR` (French)? The preceding code will fail,
    because we''ve not defined any translation for the `fr` language (French). Therefore,
    we''ll check for a suitable default, which we''ve defined to be `en-US`, American
    English:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们只为英语（`en`）和西班牙语（`es`）定义了翻译！如果玩家的区域设置为`fr-FR`（法语），前面的代码将失败，因为我们没有为`fr`语言（法语）定义任何翻译。因此，我们将检查合适的默认值，我们将其定义为`en-US`，美国英语：
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Of course, we are now in the same boat as before: there are no translations
    defined for `en-US` in our game. So we need to fall back to `en` as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们现在又回到了之前的情况：在我们的游戏中没有为`en-US`定义翻译。因此，我们需要回退到`en`，如下所示：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But what happens if we can't find a translation at all? We could be mean and
    throw a nasty error, and perhaps you might want to do exactly that, but in our
    example, we're just returning the incoming key. If the convention of capitalizing
    the key is always followed, we'll still be able to see that something hasn't been
    translated.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们根本找不到翻译怎么办？我们可以抛出一个恶意的错误，也许你确实想这么做，但在我们的例子中，我们只是返回传入的键。如果始终遵循将键大写的约定，我们仍然能够看到某些内容尚未翻译。
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we pass the `currentValue` parameter to the `substituteVariables`
    property in order to process any substitutions that we might need as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`currentValue`参数传递给`substituteVariables`属性，以便处理我们可能需要的任何替换，如下所示：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Implementing the start view
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现起始视图
- en: 'To create our view, we need to create the file for it first. The files should
    be called `startView.html`, and should live under the `www/views` directory. The
    view we''re creating will end up looking like the following screenshot for iOS:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的视图，我们首先需要为其创建文件。文件应命名为`startView.html`，并位于`www/views`目录下。我们创建的视图最终将类似于以下iOS截图：
- en: '![Implementing the start view](img/9403_01_07.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![实现起始视图](img/9403_01_07.jpg)'
- en: 'For Android (localized to Spanish), the view will be as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于西班牙语本地化的Android，视图将如下所示：
- en: '![Implementing the start view](img/9403_01_08.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![实现起始视图](img/9403_01_08.jpg)'
- en: Before we actually create the view though, let's define the structure of our
    view. Depending upon the framework in use, the structure of a view can be vastly
    different. For the YASMF framework, our view will consist of some HTML that will
    depend on some pre-defined CSS, and some JavaScript defined below that same HTML.
    You could easily make the case that the JavaScript and inline styles should be
    separated out as well, and if you wish, you can do so.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际创建视图之前，让我们定义视图的结构。根据使用的框架，视图的结构可能会有很大的不同。对于YASMF框架，我们的视图将包含一些依赖于预定义CSS的HTML，以及在该HTML下方定义的一些JavaScript。你可以很容易地提出将JavaScript和内联样式也分离出来的观点，如果你愿意，你可以这样做。
- en: 'The HTML portion for all our views will be of the following form:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有视图的HTML部分将具有以下形式：
- en: '[PRE36]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, there's no visible text anywhere in this code. Since everything
    must be localized, we'll be inserting the text programmatically via JavaScript.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这段代码中没有任何可见的文本。由于一切都必须本地化，我们将通过JavaScript程序化地插入文本。
- en: 'The `viewBackground` class will be our view''s container: everything related
    to the view''s structure is defined within. The style is defined in `www/framework/base.css`
    and `www/style/style.css`; the latter is for our app''s custom styles.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewBackground`类将是我们的视图容器：与视图结构相关的所有内容都在其中定义。样式定义在`www/framework/base.css`和`www/style/style.css`中；后者是用于我们应用的定制样式。'
- en: 'The `navigationBar` class indicates that the `div` class is just a navigation
    bar. For iOS users, this has instant meaning, but it should be pretty clear to
    everyone else: this bar holds the title of the view, as well as any buttons that
    serve for navigation (such as a **back** button). Notice that the **title** and
    **back** button both have `id` values. This value makes it easy for us to access
    them in our JavaScript later on. Notice also that we are namespacing these `id`
    values with the view name and an underscore; this is to prevent any issues with
    using the same `id` twice.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigationBar` 类表示 `div` 类只是一个导航栏。对于 iOS 用户来说，这具有即时意义，但对于其他人来说应该也很清楚：这个栏包含视图的标题以及任何用于导航的按钮（例如**返回**按钮）。请注意，**标题**和**返回**按钮都有
    `id` 值。这个值使得我们稍后在 JavaScript 中访问它们变得容易。请注意，我们使用视图名称和下划线来命名空间这些 `id` 值；这是为了避免使用相同的
    `id` 两次时出现任何问题。'
- en: The next `div` class is given the class of `content avoidNavigationBar avoidToolBar`;
    this is where all the content will go. The latter two classes specify that it
    should be offset from the top of the screen and short enough to avoid both the
    navigation bar (already defined) and the toolbar (coming up).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 `div` 类被赋予 `content avoidNavigationBar avoidToolBar` 类；所有内容都将放在这里。后两个类指定它应该从屏幕顶部偏移，并且足够短，以避免导航栏（已定义）和工具栏（即将出现）。
- en: Finally, the toolbar is defined. This is a bar much like the navigation bar,
    but is intended to hold buttons that are related to the view. For Android this
    would be commonly shown near or at the top of the screen, while for iPhone and
    WP7 display this bar is at the bottom. (iPad, on the other hand, would display
    this just below the navigation bar or on the navigation bar. We'll worry about
    that in [Project 10](ch10.html "Chapter 10. Scaling Up"), *Scaling Up*.)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义了工具栏。这是一个与导航栏类似的栏，但目的是包含与视图相关的按钮。对于 Android，这通常会在屏幕顶部或附近显示，而对于 iPhone 和
    WP7，这个栏在底部显示。（另一方面，iPad 会将其显示在导航栏下方或导航栏上。我们将在 [项目 10](ch10.html "第 10 章。扩展") 中关注这一点，*扩展*。）
- en: Below this HTML block, we'll define any templates we may need for localization,
    and then finally, any JavaScript we need.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在此 HTML 块下方，我们将定义我们可能需要的任何本地化模板，然后最后，任何我们需要的 JavaScript。
- en: Getting on with it
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'With these pointers in mind, let''s create our start view, which should be
    named `startView.html` in the `www/views` directory as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑到这些提示后，让我们创建我们的起始视图，它应该命名为 `startView.html` 并位于 `www/views` 目录中，如下所示：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code looks almost exactly like our view template defined earlier
    except that we're missing a `back` button. This is due to the fact that the first
    view we display to the user doesn't have anything to go back to, so we omit that
    button. The `id` values have also changed to include the name of our view.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码几乎与之前定义的视图模板完全相同，只是我们缺少了一个 `back` 按钮。这是因为我们向用户显示的第一个视图没有返回的地方，所以我们省略了该按钮。`id`
    值也发生了变化，包括我们视图的名称。
- en: None of these define what our view will look like, though. To determine that,
    we need to override our framework styles in `www/framework/base.css` by setting
    them in `www/style/style.css`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这些都没有定义我们的视图将看起来是什么样子。为了确定这一点，我们需要通过在 `www/style/style.css` 中设置它们来覆盖我们的框架样式。
- en: 'First, to define the look of `navigationBar`, we use the glossy black bar from
    our template defined earlier in this project as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了定义 `navigationBar` 的外观，我们使用项目早期定义的模板中的哑光黑色栏，如下所示：
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The toolbar is defined similarly as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏的定义与此类似，如下所示：
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The view''s background is defined as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的背景定义如下：
- en: '[PRE40]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's everything needed to make our start view start to look like a real app.
    Of course, there's a lot of pre-built stuff in `www/framework/base.css`, which
    you're welcome to analyze and reuse in your own projects.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使我们的起始视图开始看起来像真实应用所需的一切。当然，`www/framework/base.css` 中有很多预构建的内容，您可以在自己的项目中分析和重用。
- en: 'Now that we''ve defined the view and the appearance, we need to define some
    of the view''s content. We''re going to do this by using a couple of hidden `div`
    elements that have the locale attached to their `id` values, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了视图和外观，我们需要定义一些视图的内容。我们将通过使用几个具有附加到其 `id` 值的本地化的隐藏 `div` 元素来完成此操作，如下所示：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These two `div` elements are classed `hidden` so that they won't be visible
    to the player. We'll then use some JavaScript to copy their content to the content
    area inside the view. Easier than using the `__T()` and `PKLOC.addTranslation()`
    functions for all that text, isn't it?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个`div`元素被标记为`hidden`，因此它们对玩家不可见。然后我们将使用一些JavaScript将它们的内容复制到视图内部的内容区域。这比使用`__T()`和`PKLOC.addTranslation()`函数处理所有文本要简单得多，不是吗？
- en: 'Next comes the JavaScript as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是以下JavaScript代码：
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our first act is to put all our script into a namespace. Unlike most of our
    other namespace definitions, we're actually going to piggyback onto the "`startView`"
    element (which the astute reader will notice has not been defined yet; that'll
    be near the end of this project). While the element is a proper DOM element, it
    also serves as a perfect place for us to attach to, as long as we avoid any of
    the cardinal sins of using the DOM method names as our own, which, I promise,
    we won't do.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是将所有脚本放入一个命名空间。与我们的其他大多数命名空间定义不同，我们实际上将利用"`startView`"元素（聪明的读者会注意到这个元素还没有定义；这将在本项目的末尾附近完成）。虽然这个元素是一个合适的DOM元素，但它也为我们提供了一个完美的附加点，只要我们避免使用DOM方法名称作为我们自己的，我保证我们不会这样做。
- en: 'You might be wondering what `$ge` does. Since we''re not including any JavaScript
    framework like jQuery, we don''t have a convenience method to get an element by
    its ID. jQuery does this with the `$()` method, and because you might actually
    be using jQuery along with the framework we''re using, I chose to use the `$ge()`
    method, short for *get element*. It''s defined in `www/framework/utility.js` like
    the following code snippet and all it does is act as a shortened version of `document.getElementById`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道`$ge`做什么。由于我们没有包含任何JavaScript框架如jQuery，我们没有通过ID获取元素的便利方法。jQuery使用`$()`方法做这件事，因为你可能会在实际使用jQuery的同时使用我们正在使用的框架，我选择使用`$ge()`方法，简称*获取元素*。它在`www/framework/utility.js`中定义，如下代码片段，它只是`document.getElementById`的简写版本：
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Getting back to our start view script, we define what needs to happen when
    the view is initialized. Here we *hook* into the various buttons and other interface
    elements that are in the view, as well as localize all the text and content as
    follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的起始视图脚本，我们定义了视图初始化时需要发生的事情。在这里，我们*挂钩*到视图中的各种按钮和其他界面元素，以及如下本地化所有文本和内容：
- en: '[PRE44]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is our first use of the `__T()` function. This is how we can properly localize
    an image. The `APP_TITLE_IMAGE` key is set to point at either the English version
    or the Spanish version of the title image, and the `__T()` function returns the
    correct one based on our locale.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一次使用`__T()`函数。这就是我们如何正确本地化一个图片。`APP_TITLE_IMAGE`键被设置为指向标题图片的英语版本或西班牙语版本，而`__T()`函数根据我们的区域设置返回正确的版本。
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we''ve properly localized our `start` button, but how do we make it do
    anything? We use a little function defined in `www/framework/ui-core.js` called
    `PKUI.CORE.addTouchListener()` as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确本地化了`start`按钮，但我们如何让它做些什么呢？我们使用一个在`www/framework/ui-core.js`中定义的小函数`PKUI.CORE.addTouchListener()`，如下所示：
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we need to display the correct *welcome* text in the content area
    using the following code snippet:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要使用以下代码片段在内容区域显示正确的*欢迎*文本：
- en: '[PRE47]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We now introduce another convenience function: the `$geLocale()` function.
    This function acts like the `$ge()` function, except that it assumes there will
    be a locale appended to the ID of the element we''re asking for. It''s defined
    in the same file (`utility.js`) and looks like the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍另一个便利函数：`$geLocale()`函数。这个函数的行为类似于`$ge()`函数，但它假设我们将有一个区域设置附加到我们请求的元素的ID上。它在同一个文件（`utility.js`）中定义，如下所示：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Much like our `__T()` function, it attempts to find an element with our full
    locale attached (that is, `_xx-YY`). If it can't find it, it tries `_xx`, and
    here it should succeed if our locale is English- or Spanish-speaking. If it isn't,
    we'll then look for `_en-US`, and if that isn't found, we'll look for `_en`. If
    no suitable element is found, we'll return the original element –which in our
    case doesn't exist, which means we'll return "`undefined`".
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`__T()`函数类似，它试图找到一个带有我们完整区域设置的元素（即`_xx-YY`）。如果找不到，它将尝试`_xx`，如果我们的区域是英语或西班牙语，这里应该会成功。如果不是，我们将寻找`_en-US`，如果找不到，我们将寻找`_en`。如果没有找到合适的元素，我们将返回原始元素——在我们的例子中，这个元素不存在，这意味着我们将返回"`undefined`"。
- en: 'Next up in our start view script, we have the function that is called whenever
    the start button is tapped as shown in the following code snippet:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的起始视图脚本中接下来，我们有一个函数，每当按下起始按钮时都会被调用，如下面的代码片段所示：
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Real short, but packs a punch. This displays our game view to the player, which
    actually starts the game. For devices that support it (as this was being written,
    iOS and Android), the player also sees a nice animation between this view (start)
    and the next one (game).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 简短而有力。这向玩家展示了我们的游戏视图，实际上开始游戏。对于支持它的设备（在撰写本文时，iOS和Android），玩家还会看到这个视图（起始）和下一个视图（游戏）之间的动画。
- en: If you want to know more about how the `pushView()` method works, visit [https://github.com/photokandyStudios/YASMF/wiki/PKUI.CORE.pushView](https://github.com/photokandyStudios/YASMF/wiki/PKUI.CORE.pushView).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`pushView()`方法的工作原理，请访问[https://github.com/photokandyStudios/YASMF/wiki/PKUI.CORE.pushView](https://github.com/photokandyStudios/YASMF/wiki/PKUI.CORE.pushView)。
- en: Whew! That was a lot of work for a pretty simple view. Thankfully, most of the
    work is actually done by the framework, so our actual `startView.html` file is
    pretty small.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！对于一个相当简单的视图来说，这是一项大量的工作。幸运的是，实际上大部分工作都是由框架完成的，所以我们的实际`startView.html`文件相当小。
- en: What did we do?
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We implemented our start view, which is presented to the player when they first
    launch the app. We properly localized the view's title image based on the player's
    locale, and we also properly localized HTML content based on the locale.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了起始视图，当玩家首次启动应用时呈现给玩家。我们根据玩家的地区正确本地化了视图的标题图像，并且根据地区正确本地化了HTML内容。
- en: We defined the various hooks and text for the widgets on the view such as the
    **Start** button, and attached touch listeners to the them to make them function
    correctly.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为视图上的小部件定义了各种钩子和文本，例如**起始**按钮，并将触摸监听器附加到它们上，使它们能够正确地工作。
- en: We covered a portion of the framework that provides support for pushing views
    onto the screen as well.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一部分框架，它提供了将视图推送到屏幕上的支持。
- en: What else do I need to know?
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: 'It probably doesn''t take much to guess, but there are several complementary
    functions to the `pushView` method: `popView`, `showView`, and `hideView`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测起来可能不难，但`pushView`方法有几个互补函数：`popView`、`showView` 和 `hideView`。
- en: The `popView` function does the exact opposite of `pushView`, that is, it moves
    the views right (instead of left) by popping them off the view stack.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`popView` 函数与 `pushView` 函数正好相反，即通过从视图栈中移除视图来将视图向右移动（而不是向左）。'
- en: The `showView` and `hideView` functions do essentially the same thing, but simpler.
    They don't do any animation at all. Furthermore, since they don't involve any
    other view on the stack, they are most useful at the beginning of an app when
    we have to figure out how to display our very first view with no previous view
    to animate.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`showView` 和 `hideView` 函数基本上做的是同一件事，但更简单。它们根本不做任何动画。此外，由于它们不涉及视图栈上的任何其他视图，所以在应用开始时最为有用，那时我们不得不确定如何显示我们的第一个视图，因为没有之前的视图来进行动画。'
- en: If you want to know more about view management, you might want to visit [https://github.com/photokandyStudios/YASMF/wiki/Understanding-the-View-Stack-and-View-Management](https://github.com/photokandyStudios/YASMF/wiki/Understanding-the-View-Stack-and-View-Management)
    and explore [https://github.com/photokandyStudios/YASMF/wiki/PKUI.CORE](https://github.com/photokandyStudios/YASMF/wiki/PKUI.CORE).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于视图管理的知识，你可能想访问[https://github.com/photokandyStudios/YASMF/wiki/Understanding-the-View-Stack-and-View-Management](https://github.com/photokandyStudios/YASMF/wiki/Understanding-the-View-Stack-and-View-Management)并探索[https://github.com/photokandyStudios/YASMF/wiki/PKUI.CORE](https://github.com/photokandyStudios/YASMF/wiki/PKUI.CORE)。
- en: Implementing our game view
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的游戏视图
- en: 'To get started, create a file named `gameView.html` under the `www/views` directory.
    When we''re done, we''ll have a view that looks like the following screenshot
    for iOS:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，在`www/views`目录下创建一个名为`gameView.html`的文件。完成之后，我们将有一个如下截图所示的视图，适用于iOS：
- en: '![Implementing our game view](img/9403_01_10.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![实现我们的游戏视图](img/9403_01_10.jpg)'
- en: 'For Android, the view will look like the following screenshot:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，视图将如下截图所示：
- en: '![Implementing our game view](img/9403_01_11.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![实现我们的游戏视图](img/9403_01_11.jpg)'
- en: 'Now, before we get too deep into the view itself, let''s go over the view stack
    and how it helps us deal with navigation. The view stack is shown in the following
    screenshot:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们深入探讨视图本身之前，让我们先了解一下视图栈以及它是如何帮助我们处理导航的。视图栈在下面的屏幕截图中有展示：
- en: '![Implementing our game view](img/9403OS_01_16.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![实现我们的游戏视图](img/9403OS_01_16.jpg)'
- en: The view stack is really just a stack that maintains the list of previously
    visible views and the currently visible view. When our app first starts, the stack
    will be empty as identified in the first step in the preceding screenshot. Then,
    the `startView` view is pushed onto the stack using the `showView` method, and
    you have the stack in (2). When the player taps the **Start** button, the `gameView`
    view is pushed onto the stack, which results in the stack as seen in (3). Then,
    when the game is over, we'll push the `endView` view on the stack, resulting in
    (4).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 视图堆栈实际上只是一个堆栈，它维护着之前可见的视图列表和当前可见的视图。当我们的应用首次启动时，堆栈将是空的，如前一个截图中的第一步所示。然后，使用 `showView`
    方法将 `startView` 视图推入堆栈，得到（2）中的堆栈。当玩家点击 **开始** 按钮时，`gameView` 视图被推入堆栈，结果是（3）中的堆栈。然后，当游戏结束时，我们将
    `endView` 视图推入堆栈，结果是（4）。
- en: Because we're tracking all these views, including the ones that are no longer
    visible (especially at the end of the game), it makes it easy to go back to a
    previous view. For iOS, this is done via the **back** button. For Android, the
    device often has a physical back button that is used instead. Regardless of how
    a `back` event is triggered, we need to be able to go backwards in the stack.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在跟踪所有这些视图，包括那些不再可见的视图（尤其是在游戏结束时），这使得返回到之前的视图变得容易。对于 iOS，这是通过 **后退** 按钮实现的。对于
    Android，设备通常有一个物理后退按钮被用来代替。无论 `back` 事件是如何触发的，我们都需要能够回退堆栈。
- en: Let's say that the user now decides to go back in the stack; we would have the
    stack in (5). If they decide to go back another step, (6) would result. At this
    point, iOS would permit no further backtracking, but for Android, another `back`
    event should exit the user out of the app.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户现在决定在堆栈中返回；我们将得到（5）中的堆栈。如果他们决定再退一步，将得到（6）。在这个时候，iOS 不允许进一步回退，但对于 Android，另一个
    `back` 事件应该让用户退出应用。
- en: Getting on with it
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: The game view will be very similar to our start view, except that it is a little
    more complicated. After all, it plays an entire game. Thankfully, there's really
    nothing terribly new here, so it should be smooth going.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏视图将非常类似于我们的起始视图，但它稍微复杂一些。毕竟，它要玩整个游戏。幸运的是，这里实际上没有什么特别新的东西，所以应该进展顺利。
- en: 'Let''s start with the HTML portion of the view given as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从视图的 HTML 部分开始，如下所示：
- en: '[PRE50]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'I''ve highlighted what''s new in the earlier code, but there is not much as
    you can see. First we''ve defined a `back` button that lives in the navigation
    bar, and in the content area we''ve defined two new areas: one for the player''s
    score, and another for the actual question (and answers).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在前面的代码中突出显示了新的内容，但正如你所见，并不多。首先，我们定义了一个位于导航栏中的 `back` 按钮，在内容区域中我们定义了两个新的区域：一个用于玩家的得分，另一个用于实际的问题（和答案）。
- en: 'Up next, while similar to the localized content in the start view, we have
    templates that specify how a question and its answers are displayed; this is given
    as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，虽然与起始视图中的本地化内容相似，但我们有模板指定了如何显示问题和其答案；如下所示：
- en: '[PRE51]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'First, we define the question template, which consists of a second-level heading
    that will have the question''s text, and a div element that will contain all the
    answers. But what will the answers look like? That''s next:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义问题模板，它由一个二级标题组成，将包含问题的文本，以及一个包含所有答案的 div 元素。但答案看起来会是什么样子？接下来就会揭晓：
- en: '[PRE52]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each answer will be presented as a button with the answer text inside, and an
    `onclick` event attached to call the `gameView.selectAnswer()` method with the
    selected answer.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 每个答案将以一个包含答案文本的按钮形式呈现，并且附加一个 `onclick` 事件来调用 `gameView.selectAnswer()` 方法以选择答案。
- en: 'Of course, as these are templates, they don''t appear to the player, and so
    they are given the `hidden` class. But we''ll definitely make use of them in our
    JavaScript when we construct an actual random question to display to the player.
    Let''s go over the script now:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于这些是模板，它们不会显示给玩家，因此它们被赋予了 `hidden` 类。但当我们构建一个实际随机问题以显示给玩家时，我们肯定会使用它们。现在让我们来看看脚本：
- en: '[PRE53]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By now you should be familiar with our namespacing technique, which comes first
    in our code. After that, though, we define the properties in our view. The question
    number, which will act as our counter so that when it reaches ten, we know the
    game is over; the score; and the current question. The latter isn't obvious, but
    it will be an actual question object, not an index to the object.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉我们的命名空间技术，这是我们代码中的第一部分。然而，之后我们定义了视图中的属性。问题编号，它将作为我们的计数器，以便当它达到十时，我们知道游戏结束了；得分；以及当前问题。后者并不明显，但它将是一个实际的问题对象，而不是对象的索引。
- en: 'After that, we have the `initializeView` function, which will wire up all the
    widgets and do the localization of the text, as seen in the following code snippet:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有`initializeView`函数，它将连接所有小部件并完成文本的本地化，如下代码片段所示：
- en: '[PRE54]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: I've highlighted a few areas in the preceding code block. The last ones are
    more or less the same, as we're storing the `gameView_scoreArea` and `gameView_questionArea`
    elements into properties for later use, so that's not really anything new. What
    is new about it is that we aren't loading any content into them yet.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前面的代码块中突出显示了一些区域。最后几个大致相同，因为我们正在将`gameView_scoreArea`和`gameView_questionArea`元素存储到属性中以供以后使用，所以这并不是什么新东西。它的新颖之处在于我们还没有将任何内容加载到它们中。
- en: The second highlight is not something you'd really ever add to a production
    game. You may ask, so why is it here? The idea is that this button lets us skip
    the current question without a penalty. Why? The answer is testing. I don't want
    to have to tap through an answer, tap through the alert saying if I got it right
    or wrong a million times to see if the localization is working for all the questions.
    Hence, skip was born.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个亮点并不是你真的会添加到生产游戏中的东西。你可能会问，为什么它在这里？这个按钮的目的是让我们能够无惩罚地跳过当前问题。为什么？答案是测试。我不想不得不点击答案，点击提示说如果我对或错了一百万次，看看本地化是否对所有问题都有效。因此，跳过功能就诞生了。
- en: The first highlight though, is more interesting. It's a JavaScript include.
    "Wait," I hear you saying, "JavaScript doesn't do includes." And you'd be right.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个亮点更有趣。它是一个JavaScript包含。 “等等，”我听到你说，“JavaScript不做包含。” 你是对的。
- en: But, it is possible to simulate an include by using `XmlHttpRequest`, which
    is often referred to as AJAX. With this short include statement, we're asking
    the browser to load the two referenced JavaScript files (`quizQuestions.js` and
    `quizQuestion.js`) on our behalf. It's important that this happens too; otherwise,
    our game would have no questions!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，可以通过使用`XmlHttpRequest`来模拟包含，这通常被称为AJAX。通过这个简短的包含语句，我们要求浏览器代表我们加载两个引用的JavaScript文件（`quizQuestions.js`和`quizQuestion.js`）。这一点也很重要；否则，我们的游戏将没有问题！
- en: The `PKUTIL.include()` function is defined in `www/framework/utility.js`. We'll
    worry about the full implementation details a little later in this project, but
    it would suffice to say, it does what it says. The scripts are loaded and waiting
    for us when we need to use the questions. (At this point the reader with a gazillion
    questions is asking this key question, "Does the order matter?", the answer is,
    "Yes." And you'll see why in a short bit.)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`PKUTIL.include()`函数定义在`www/framework/utility.js`中。我们将在本项目的稍后部分关注完整的实现细节，但可以说，它确实做了它所说的。当我们需要使用问题时，脚本已经加载并等待我们。（此时，有无数问题的读者会问这个关键问题，“顺序重要吗？”答案是，“是的。”你很快就会看到原因。）'
- en: 'So now that we have the initialization for `gameView` down, let''s look at
    another key method: `viewWillAppear`. It is shown in the following code snippet:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经完成了`gameView`的初始化，让我们看看另一个关键方法：`viewWillAppear`。它如下代码片段所示：
- en: '[PRE55]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The latter part of this code is fairly innocuous. We set the question number
    to 1, the score to zero, and call the `nextQuestion()` method, which, as it is
    turns out, renders the next question and displays it to the player.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的后半部分相当无害。我们将问题编号设置为1，得分设为零，并调用`nextQuestion()`方法，它实际上渲染下一个问题并显示给玩家。
- en: The `viewWillAppear()` function, as you may remember, is called by `PKUI.CORE.pushView()`
    and `PKUI.CORE.showView()` methods just prior to the actual animation that renders
    the view onscreen. Therefore, the act of the **Start** button on the start view
    pushing the game view on the stack will call this function, and start the game.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得的，`viewWillAppear()`函数是在`PKUI.CORE.pushView()`和`PKUI.CORE.showView()`方法在视图实际在屏幕上渲染之前的动画之前被调用的。因此，起始视图上的**开始**按钮将调用此函数，并开始游戏。
- en: It also works when we're coming back to the view by popping the end view off
    the stack. We'll receive a `viewWillAppear` notification, reset the game, and
    it's as if the user gets a whole new game. It's almost magic!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过弹出末尾视图从视图中返回时，它也适用。我们将收到一个`viewWillAppear`通知，重置游戏，就像用户得到了一个全新的游戏一样。这几乎是魔法！
- en: Note
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To those who have done any amount of Objective-C programming for iOS using Apple's
    frameworks, I'll apologize right now for using the concepts in the framework.
    It's just that, well, they fit the view model so well! If you prefer Android's
    methodology, or Microsoft's, feel free to substitute. I just happen to like the
    framework Apple has built up for their platform.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些使用苹果框架进行过任何Objective-C编程的iOS开发者，我现在就为使用框架中的概念道歉。只是，嗯，它们与视图模型非常契合！如果你更喜欢Android的方法，或者微软的方法，请随意替换。我只是碰巧喜欢苹果为他们平台构建的框架。
- en: 'Of course, we need to actually do something when the back button is pressed,
    the code for it is as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当按下返回按钮时，我们需要实际执行一些操作，以下是相应的代码：
- en: '[PRE56]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`The popView()` method is literally the reverse of `pushView`. It takes the
    currently visible view (`gameView`), pops it off the stack, and displays the underlying
    view, in this case, `startView`. The best thing to do here would be to prompt
    the player if they really wanted to do this; it will end their game, perhaps prematurely.
    For now, as an example, we''ll leave it at this.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`popView()`方法实际上是`pushView`的逆操作。它获取当前可见视图（`gameView`），将其从堆栈中弹出，并显示下层的视图，在这种情况下是`startView`。这里最好的做法是提示玩家他们是否真的想这样做；这将结束他们的游戏，可能过早。现在，作为一个例子，我们将保持这个状态。'
- en: 'Next, we need to define how a question is displayed on the screen. We do that
    in `nextQuestion()` , as seen in the following code snippet:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义如何在屏幕上显示问题。我们在`nextQuestion()`中这样做，如下面的代码片段所示：
- en: '[PRE57]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'First, we''ll get a random question from the `QQ` namespace:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`QQ`命名空间中随机获取一个问题：
- en: '[PRE58]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we get our templates:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取我们的模板：
- en: '[PRE59]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now that we have our templates, we''ll replace all occurrences of `"%QUESTION%`"
    with the translated question, as shown in the following code snippet:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模板，我们将按照以下代码片段替换所有`"%QUESTION%"`的出现，以替换为翻译后的问题：
- en: '[PRE60]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Generating the answers is a little more tricky. There may be two, three, or
    more answers for any one question, so we''ll ask the question for a list of randomized
    answers first, and then loop through that list while building up an HTML string,
    as shown in the following code snippet:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 生成答案稍微有些复杂。任何一个问题可能有两个、三个或更多答案，因此我们首先为随机答案列表中的问题提问，然后在该列表中循环，同时构建HTML字符串，如下面的代码片段所示：
- en: '[PRE61]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For each answer, we''ll replace the `%ANSWER%` text with the translated text
    of the answer, and `"%ANSWER_INDEX%`" with the current index (`i`), as shown in
    the following screenshot:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个答案，我们将用翻译后的答案文本替换`%ANSWER%`文本，并用当前索引（`i`）替换`"%ANSWER_INDEX%"`，如下面的截图所示：
- en: '[PRE62]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that we''ve got the HTML for our answers, we can replace `%ANSWERS%` in
    the question template with it as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了答案的HTML，我们可以按照以下方式将`%ANSWERS%`在问题模板中替换为它：
- en: '[PRE63]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'At this point, we can display the question to the player:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们可以向玩家显示问题：
- en: '[PRE64]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We also want to update the player's score. We're going to have an artificially
    absurd scoring system to highlight whether or not our localization is working
    correctly. Note that the `2` in the following code snippet specifies we want two
    decimal places in the score.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望更新玩家的分数。我们将采用一个人为的荒谬评分系统来突出我们的本地化是否正确工作。请注意，以下代码片段中的`2`指定我们希望在分数中保留两位小数。
- en: '[PRE65]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We''ll also update the view''s title with the current question number. This
    time the "`0`" following code snippet indicates no decimal points:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更新视图的标题为当前问题编号。这次代码片段后面的"`0"`表示没有小数点：
- en: '[PRE66]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'All of this is well and good, but it does nothing without the user being able
    to select an answer, which is where the next function comes in:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很不错，但没有用户能够选择答案，这就需要下一个函数来处理：
- en: '[PRE67]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'First, we''ll ask the current question if the answer selected is correct using
    the following code snippet:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下代码片段来检查所选答案是否正确，并询问当前问题：
- en: '[PRE68]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If it is, we''ll tell the user they got it right, and increment their score
    as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果答案是正确的，我们将告诉用户他们答对了，并按照以下方式增加他们的分数：
- en: '[PRE69]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'But if it is wrong, we''ll indicate that it is incorrect, and decrement their
    score (We''re mean, I guess. Not really though-we want to test that negative numbers
    work too.), using the following code snippet:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果它是错误的，我们将表明它是错误的，并减少他们的分数（我们可能有点苛刻。其实并不是这样——我们想要测试负数也能工作。），使用以下代码片段：
- en: '[PRE70]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we check to see if we''ve asked the last question in the set as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否已经问完了这个集合中的最后一个问题，如下所示：
- en: '[PRE71]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If we have, we''ll communicate the score to the end view and push it onto the
    stack. This ends the game, using the following code snippet:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有，我们将把分数传达给最终视图并将其推入堆栈。这样，游戏就结束了，使用以下代码片段：
- en: '[PRE72]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In this case, we''ve got more questions to answer, so we load the next question
    as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们还有更多的问题需要回答，所以我们按照以下方式加载下一个问题：
- en: '[PRE73]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: With that, we're done with the game view. Tell me, that wasn't too difficult,
    was it?
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了游戏视图。告诉我，这并不太难，对吧？
- en: What did we do?
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We implemented the actual game in one view. We also learned how to handle the
    back button on Android, and back navigation on iOS. We also gained an understanding
    of how to use HTML blocks that are hidden as templates for dynamic content.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个视图中实现了实际的游戏。我们还学会了如何处理Android上的后退按钮和iOS上的后退导航。我们还了解了如何使用作为动态内容模板的隐藏HTML块。
- en: What else do I need to know?
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要知道什么？
- en: 'If you remember, I mentioned that we''d talk about that wonderful little `include`
    function a little more. Let''s look at it a bit closer:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我提到过我们将会更详细地讨论那个奇妙的小`include`函数。让我们更仔细地看看它：
- en: '[PRE74]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'First off, let me clue you into something: we''re using recursion here to load
    the scripts. So, as you''ll see in the following code, we''re testing the length
    of the incoming array, and if it is zero, we call the `completion` method passed
    to us. This allows us—if we like—to have code called after all the scripts are
    loaded. This code block is as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我给你透露一点：我们在这里使用递归来加载脚本。所以，正如你将在下面的代码中看到的，我们在测试传入数组的长度，如果它是零，我们就调用我们传递给`completion`方法的`completion`方法。这允许我们——如果我们喜欢——在所有脚本加载后调用代码。这个代码块如下：
- en: '[PRE75]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the next section, we''ll pop off the next script to load. This also explains
    that the array must contain the scripts in reverse order of their dependencies.
    Yes, you could reverse the array yourself and you should, but I wanted to make
    the point. To pop off the script the following code instruction is used:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将弹出下一个要加载的脚本。这也解释了数组必须按照它们的依赖关系逆序包含脚本。是的，你可以自己反转数组，你应该这样做，但我想要强调这一点。弹出脚本的以下代码指令被使用：
- en: '[PRE76]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then we call another previously unknown function, `PKUTIL.load()` . This method
    takes the script filename, and then calls the `completion` function we''ve given
    it. It will call it regardless of success or failure. Notice that it is an incoming
    parameter to the completion function. This function is shown in the following
    screenshot:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用另一个之前未知的函数，`PKUTIL.load()`。这个方法接受脚本文件名，然后调用我们给它提供的`completion`函数。无论成功与否，它都会调用它。注意，它是完成函数的传入参数。这个函数在下面的屏幕截图中显示：
- en: '[PRE77]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If the script was successfully loaded, we create a `SCRIPT` DOM element and
    add the data to it. It is important to note that nothing happens with the script
    until we actually attach it to the DOM. We do this by appending the child to the
    `BODY`. It is at this point that whatever is in the script will be executed. This
    conditional `if` block is shown in the following code snippet:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本成功加载，我们创建一个`SCRIPT` DOM元素并将数据添加到其中。需要注意的是，直到我们将脚本实际附加到DOM上，脚本都不会有任何动作。我们通过将子元素添加到`BODY`来实现这一点。正是在这一点上，脚本中的内容将被执行。这个条件`if`块在下面的代码片段中显示：
- en: '[PRE78]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If we fail to load the script, we''ll generate a log message on the console.
    You could make a case that something worse should happen, like a fatal error that
    stops everything, but this also permits loading libraries that may or may not
    be there and taking advantage of them if they happen to exist. Perhaps not a feature
    one would use frequently, but useful at times nonetheless. The conditional `else`
    block is as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法加载脚本，我们将在控制台生成一个日志消息。你可以认为应该发生更糟糕的事情，比如一个停止一切操作的致命错误，但这也允许加载可能存在或不存在库，并利用它们。也许这不是一个经常使用的功能，但有时仍然很有用。条件`else`块如下：
- en: '[PRE79]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'And say hello to our little friend, recursion. We call ourselves with the array
    of script names (minus the one we just popped), with the `completion` function,
    and sooner or later, we''ll end up with no items in the array. Then, the `completion`
    function will be called as seen in the following code block:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后向我们的这个小帮手，递归，问好。我们用脚本名称数组（减去我们刚刚弹出的那个）和 `completion` 函数调用自己，迟早我们会结束于数组中没有项目。然后，`completion`
    函数将像以下代码块中所示那样被调用：
- en: '[PRE80]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `PKUTIL.load()` function is another interesting beast, which must work
    correctly for our includes to work. It''s defined something like the following
    (for full implementation details, visit [https://github.com/photokandyStudios/YASMF/blob/master/framework/utility.js#L126](https://github.com/photokandyStudios/YASMF/blob/master/framework/utility.js#L126)):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`PKUTIL.load()` 函数是另一个有趣的生物，它必须正确工作，以便我们的包含能够工作。它定义得像以下这样（对于完整的实现细节，请访问 [https://github.com/photokandyStudios/YASMF/blob/master/framework/utility.js#L126](https://github.com/photokandyStudios/YASMF/blob/master/framework/utility.js#L126)）：'
- en: '[PRE81]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'First, we''ll check to see if the browser understands `XMLHttpRequest`. If
    it doesn''t, we''ll call `completion` with a failure notice and a message describing
    that we couldn''t load anything, as shown in the following code block:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查浏览器是否理解 `XMLHttpRequest`。如果不理解，我们将使用失败通知和描述我们无法加载任何内容的消息调用 `completion`，如下所示：
- en: '[PRE82]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next we set up the `XMLHttpRequest` , and assign the `onreadystatechange` function
    as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们设置 `XMLHttpRequest`，并如下分配 `onreadystatechange` 函数：
- en: '[PRE83]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This function can be called many different times during the loading process,
    so we check for a specific value. In this case, `4` means that the content has
    been loaded:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载过程中，这个函数可以被多次调用，因此我们需要检查一个特定的值。在这种情况下，`4` 表示内容已经被加载：
- en: '[PRE84]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Of course, just because we got data doesn''t mean that it is useable data.
    We need to verify the status of the load, and here we get into a little bit of
    murky territory. iOS defines success with a zero value, while Android defines
    it with a `200`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅因为我们得到了数据并不意味着它是可用的数据。我们需要验证加载的状态，在这里我们进入了一个有点模糊的区域。iOS 使用 `0` 值定义成功，而
    Android 使用 `200`：
- en: '[PRE85]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'If we''ve successfully loaded the data, we''ll call the `completion` function
    with a success notification, and the data, as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功加载了数据，我们将使用成功通知和数据调用 `completion` 函数，如下所示：
- en: '[PRE86]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'But if we''ve failed to load the data, we call the `completion` function with
    a failure notification and the status value of the load, as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们未能加载数据，我们将使用失败通知和加载状态值调用 `completion` 函数，如下所示：
- en: '[PRE87]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Keep in mind that we're still just setting up the `XMLHttpRequest` object and
    that we've not actually triggered the load yet.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们仍在设置 `XMLHttpRequest` 对象，并且我们尚未实际触发加载。
- en: 'The next step is to specify the path to the file, and here we run into a problem
    on WP7 versus Android and iOS. On both Android and iOS we can load files relative
    to the `index.html` file, but on WP7, we have to load them relative to the `/app/www`
    directory. Subtle to track down, but critically important. Even though we aren''t
    supporting WP7 in this book, the framework does, and so it needs to handle cases
    like this using the following code snippet:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是指定文件的路径，在这里我们在 WP7 与 Android 和 iOS 之间遇到了问题。在 Android 和 iOS 上，我们可以相对于 `index.html`
    文件加载文件，但在 WP7 上，我们必须相对于 `/app/www` 目录加载它们。虽然难以追踪，但至关重要。尽管我们在这本书中不支持 WP7，但框架支持，因此它需要使用以下代码片段来处理此类情况：
- en: '[PRE88]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now that we''ve set the filename, we fire off the load:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了文件名，我们开始加载：
- en: '[PRE89]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Should you ever decide to support WP7, it is critical that even though the framework
    supports passing `false` for `aSync`, which should result in a synchronous load,
    you shouldn't actually ever do so. WP7's browser does funny things when it can't
    load data asynchronously. For one thing, it loads it asynchronously anyway (not
    your intended behavior), and for another thing, it has a tendency to think the
    file simply doesn't exist. So instead of loading scripts, you'll get errors in
    the console indicating that a 404 error occurred. And you'll scratch your head
    (I did!) wondering why in the world that could be when the file is right there.
    Then you'll remember this long note, change the value back to `true`, and things
    will suddenly start working. (You seriously do not want to know the hours it took
    me to debug on WP7 to finally figure this out. I want those hours back!)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定支持 WP7，那么即使框架支持为 `aSync` 传递 `false`，这应该会导致同步加载，但你实际上绝对不应该这样做。当 WP7 的浏览器无法异步加载数据时，它会做一些奇怪的事情。一方面，它仍然会异步加载（这不是你预期的行为），另一方面，它倾向于认为文件根本不存在。所以，你不会加载脚本，而是在控制台得到错误，表明发生了
    404 错误。你（我！）会挠头（我确实这样做了！）想不明白为什么文件就在那里却会出现这种情况。然后你会想起这个长长的笔记，将值改回 `true`，事情突然开始工作。（你真的不想知道我调试
    WP7 了多少小时才最终弄清楚这个问题。我想把那些时间要回来！）
- en: Implementing the end view
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现结束视图
- en: 'We''ll be creating the file name `endView.html` in the `www/views` directory.
    When we''re done, we''ll end up with this view for iOS:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `www/views` 目录下创建文件名 `endView.html`。完成之后，我们将得到以下 iOS 视图：
- en: '![Implementing the end view](img/9403_01_13.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![实现结束视图](img/9403_01_13.jpg)'
- en: 'The view for Android will be as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓的视图将如下所示：
- en: '![Implementing the end view](img/9403_01_14.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![实现结束视图](img/9403_01_14.jpg)'
- en: Getting on with it
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'As with our previous views, the first step is to define the HTML representation:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 和我们之前的视图一样，第一步是定义 HTML 表示：
- en: '[PRE90]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'I''ve highlighted two areas in this code: `resultsArea` where we''ll tell the
    player how they scored, and the button in the toolbar, which this time is a `Try
    Again?` button. It acts just like a back button, though.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这段代码中突出显示了两个区域：`resultsArea`，我们将告诉玩家他们的得分，以及工具栏中的按钮，这次是一个 `Try Again?` 按钮。它的工作方式就像一个返回按钮一样。
- en: 'Next, we need localized content. In this case, it''s both localized content
    and a template, as shown in the following code snippet:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要本地化内容。在这种情况下，它既是本地化内容又是模板，如下面的代码片段所示：
- en: '[PRE91]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Again, these `div` elements are hidden so that the player can't see them, but
    we'll take their content, replace `%SCORE%` and `%DATE%`, and then show the resulting
    content to the player.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这些 `div` 元素被隐藏起来，这样玩家就看不到它们，但我们会取它们的内容，替换 `%SCORE%` 和 `%DATE%`，然后将结果内容显示给玩家。
- en: 'Let''s look at our script:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的脚本：
- en: '[PRE92]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'First, we set the score to zero, mainly for initialization purposes. We''ll
    provide a utility function next that sets the score to any value. As you should
    remember, this is called when the game is ending in the game view. This initialization
    is shown in the following code snippet:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将分数设置为零，主要是为了初始化目的。我们将在下一节提供一个设置任何分数的实用函数。你应该记得，当游戏在游戏视图中结束时，会调用这个函数。初始化的代码片段如下：
- en: '[PRE93]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'As has been typical of all our previous views, we have an `initializeView()`
    method. What''s a little different is that it doesn''t localize the content area;
    that''s because we don''t know the score at this point. The `initializeView()`
    function is called well in advance of the game even starting, let alone being
    finished. This function is given as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们之前所有视图的典型做法，我们有一个 `initializeView()` 方法。有一点不同是它没有本地化内容区域；这是因为我们此时还不知道分数。`initializeView()`
    函数在游戏甚至开始之前就被调用了，更不用说完成游戏了。这个函数的定义如下：
- en: '[PRE94]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Notice that both buttons, the `back` button and the `try again` button do the
    same thing, they pop the view. This works because when we pop off the view, `gameView`
    will get the `viewWillAppear` notification, which resets the game.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到两个按钮，`back` 按钮和 `try again` 按钮都做同样的事情，它们弹出视图。这是因为当我们弹出视图时，`gameView` 将获得
    `viewWillAppear` 通知，这将重置游戏。
- en: 'This view also needs such a notification to set up the content area, since
    we''ll know the score by the time `endView` appears on screen:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图也需要这样的通知来设置内容区域，因为我们会在 `endView` 出现在屏幕上时知道分数：
- en: '[PRE95]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: We get the properly localized template and replace `%SCORE%` with the actual
    score, and `%DATE%` with the current date (the `D` here means long format date).
    We then show it to the end user. All of this happens just prior to the view animating
    on screen.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取了正确本地化的模板，并用实际得分替换`%SCORE%`，用当前日期替换`%DATE%`（这里的`D`表示长格式日期）。然后我们将其展示给最终用户。所有这些都在视图在屏幕上动画之前发生。
- en: 'We need to have code that will handle the `back` button should it be pressed,
    which is a pop back to the `gameView`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写能够处理按下“返回”按钮的代码，这将弹回到“游戏视图”：
- en: '[PRE96]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Astonishingly, that''s it. There''s really no new ground to cover here, no
    new methods in the framework, no new utility methods, no new localization concepts.
    The only thing that looks new is the `__D()` function, which, as you can probably
    guess, is what localizes dates. In fact, there are two more functions that are
    similar: `__C()`, which localizes currency and `__PCT()`, which localizes percentages.
    We''ll be dealing with these in later apps.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，就是这样。这里真的没有新的领域要覆盖，没有新的框架方法，没有新的实用方法，也没有新的本地化概念。唯一看起来新的就是`__D()`函数，正如你可能猜到的，它是用来本地化日期的。实际上，还有两个类似的功能：`__C()`，用于本地化货币，以及`__PCT()`，用于本地化百分比。我们将在后面的应用程序中处理这些。
- en: What did we do?
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We created the End view. We properly localized a content template, and localized
    both numbers and dates.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了结束视图。我们正确地本地化了内容模板，并本地化了数字和日期。
- en: Putting it all together
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切整合起来
- en: 'We''ve almost got a fully functional app on our hands, but we''re missing a
    couple of critical components: the part that loads it all and starts it off. For
    this, we''ll be creating an `app.js` file and two HTML files under the `www` directory.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎已经拥有了一个功能齐全的应用程序，但我们缺少几个关键组件：加载所有内容并启动它的部分。为此，我们将在`www`目录下创建一个`app.js`文件和两个HTML文件。
- en: Getting on with it
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: The `index.html` and `index_android.html` files are what kicks everything off
    by loading the necessary scripts and calling `app.js`. These are typically pretty
    standard for each app, so they aren't going to change much throughout the rest
    of the book.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`和`index_android.html`文件通过加载必要的脚本并调用`app.js`来启动一切。这些通常是每个应用程序的标准配置，因此在整个书籍的其余部分中它们不会发生太大变化。'
- en: 'First, `index.html`, which is intended for iOS, is as follows:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`index.html`，这是为iOS准备的，如下所示：
- en: '[PRE97]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Next, `index_android.html`, which is for Android is as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`index_android.html`，这是为Android准备的，如下所示：
- en: '[PRE98]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `app.js` file is what actually starts our app. It is also what initializes
    our localization, sets our current locale, loads various libraries (such as `ui-core.js`),
    and finally, starts our app. Let''s look at the code now:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`文件实际上是启动我们应用程序的文件。它也是初始化本地化、设置当前区域设置、加载各种库（如`ui-core.js`），并最终启动我们的应用程序的文件。现在让我们看看代码：'
- en: '[PRE99]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'As usual, we set up our namespace, this time as APP. Next, we''ll attach an
    event listener to the `deviceready` event; this fires whenever Cordova has finished
    loading its libraries. We must wait for this event before we can do much of anything,
    especially anything that relies on Cordova. If we don''t, we''ll get errors. We''ll
    set our namespace as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们设置了我们的命名空间，这次是APP。接下来，我们将为`deviceready`事件附加一个事件监听器；这个事件在Cordova完成加载其库时触发。我们必须等待这个事件，然后我们才能做很多事情，特别是依赖于Cordova的事情。如果我们不这样做，我们会得到错误。我们将命名空间设置如下：
- en: '[PRE100]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'All that the preceding function does is call the `APP.start()` function, which
    is defined as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数所做的只是调用`APP.start()`函数，该函数定义如下：
- en: '[PRE101]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You've already seen `PKUTIL.include`, so it isn't anything new to you, but here
    we're loading three libraries, and including a `completion` function to call `APP.initLocalization`.
    Because the include is asynchronous, we cannot continue writing the code after
    this call that relies on those libraries, or there's a good chance the library
    wouldn't be loaded in time. Therefore, we call the `initLocalization` function
    when all three libraries are fully loaded.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了`PKUTIL.include`，所以它对你来说不是什么新东西，但在这里我们正在加载三个库，并包含一个`completion`函数来调用`APP.initLocalization`。因为包含是异步的，所以我们不能在这次调用之后继续编写依赖于这些库的代码，否则有很大可能库不会及时加载。因此，我们在所有三个库完全加载后调用`initLocalization`函数。
- en: 'The next function, `initLocalization`, initializes our `jQuery/Globalize` by
    loading its libraries and when it is complete, we load any locales we might need.
    When those locales are finished loading, then we call `APP.init` and this is where
    the real work begins. The `APP.init` function is given as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数`initLocalization`通过加载其库来初始化`jQuery/Globalize`，当它完成时，我们加载我们可能需要的任何地区。当这些地区加载完成后，我们调用`APP.init`，这里真正的任务开始了。`APP.init`函数如下所示：
- en: '[PRE102]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `APP.init()` function defines our app''s basic translation matrix (you
    may see translations you''ve seen before; that''s because they originated from
    here), and we also proceed to load the three views we have created into the document:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`APP.init()`函数定义了我们应用程序的基本翻译矩阵（你可能在这里看到之前见过的翻译；那是因为它们起源于这里），我们接着将我们创建的三个视图加载到文档中：'
- en: '[PRE103]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: First, we fake our locale by setting it to Spanish language and the country
    of Spain. If you want the app to determine the locale by querying the system,
    comment the line out.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将其设置为西班牙语语言和西班牙国家来模拟我们的地区设置。如果你想让应用程序通过查询系统来确定地区，请取消注释该行。
- en: '[PRE104]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Next, we have our basic translation matrix, application titles, the translations
    for correct and incorrect, start, back and skip, and more:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的基本翻译矩阵，应用程序标题，正确和错误的翻译，开始，返回和跳过，等等：
- en: '[PRE105]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Next, we call a function in `PKUI.CORE` called `initializeApplication`. All
    this function does is attach a special event handler that tracks the orientation
    of the device. But by doing so, it also attaches the device, the form factor,
    and the orientation to the `BODY` element, which is what permits us to target
    various platforms with CSS. This function is given as follows:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`PKUI.CORE`中的一个函数`initializeApplication`。这个函数所做的只是附加一个特殊的事件处理器来跟踪设备的方向。但通过这样做，它也将设备、形态和方向附加到`BODY`元素上，这使得我们能够通过CSS针对各种平台。这个函数如下所示：
- en: '[PRE106]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Next, we load a view, `gameView` in this case (order doesn''t really matter
    here):'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们加载一个视图，在这种情况下是`gameView`（顺序在这里并不重要）：
- en: '[PRE107]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We call `PKUTIL.loadHTML` to accomplish this, and if you're thinking it would
    be a lot like `PKUTIL.include`, you'd be right. We'll look at the definition a
    little later, but it should suffice to say, we're loading the content inside `gameView.html`,
    wrapping it with another `div` with an `id` value of `gameView` and a class of
    `container`, attaching it to the `rootContainer`, and indicating that it can be
    loaded asynchronously.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`PKUTIL.loadHTML`来完成这个任务，如果你认为它和`PKUTIL.include`非常相似，你就对了。我们稍后会查看其定义，但可以简单地说，我们正在加载`gameView.html`内的内容，将其包裹在一个具有`id`值为`gameView`和`class`为`container`的`div`中，并将其附加到`rootContainer`上，并指示它可以异步加载。
- en: Once it finishes loading, we'll call `initializeView()` on it.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载完成，我们将在其上调用`initializeView()`。
- en: 'We load the end view the same way as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以相同的方式加载结束视图：
- en: '[PRE108]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We load the start view almost exactly the same way as all the others. I''ll
    highlight the difference in the following code block:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以几乎相同的方式加载起始视图，如下所示：
- en: '[PRE109]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The only thing we do differently is to show `startView` after we initialize
    it. At this point the game is fully loaded and running, and waiting for the player
    to tap **Start**.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一不同的地方是在初始化后显示`startView`。此时游戏已经完全加载并运行，等待玩家点击**开始**。
- en: What did we do?
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We tied everything together by creating the `app.js` file. We learned how to
    initialize the jQuery/Globalize library, how to fake a locale, and how to set
    up our translation matrix. We learned how to load views, and how to show the first
    one.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建`app.js`文件将所有内容整合在一起。我们学习了如何初始化jQuery/Globalize库，如何模拟地区设置，以及如何设置我们的翻译矩阵。我们还学习了如何加载视图，以及如何显示第一个视图。
- en: What else do I need to know?
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: 'Let''s look at `PKUTIL.loadHTML` a little closer:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`PKUTIL.loadHTML`：
- en: '[PRE110]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The first thing we do is pull out the `aSync` option, we need it to call `PKUTIL.load`.
    Again, the warning about WP7 and loading synchronously still applies. It is best
    to assume you''ll always be using `true` unless you can rule WP7 out of your supported
    platforms. We use the `aSync` option as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提取出`aSync`选项，我们需要它来调用`PKUTIL.load`。再次提醒，关于WP7和同步加载的警告仍然适用。最好假设你总是使用`true`，除非你可以排除WP7作为你的支持平台。我们使用`aSync`选项如下：
- en: '[PRE111]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'At this point, we''ve successfully loaded the HTML file, as seen in the following
    code snippet, and now we have to figure out what to do with it:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功加载了HTML文件，如下面的代码片段所示，现在我们必须弄清楚如何处理它：
- en: '[PRE112]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'First, we extract out the other parameters we need, namely, `id`, `className`,
    and `attachTo`:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们提取出我们需要的其他参数，即 `id`、`className` 和 `attachTo`：
- en: '[PRE113]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, we create a `div` element, and give it `id` and `class`. We also load
    the data into the element as shown in the following code block:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `div` 元素，并给它 `id` 和 `class`。我们还将数据加载到元素中，如下面的代码块所示：
- en: '[PRE114]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: If possible, we'll attach to the element specified in `attachTo`, but if it
    isn't defined, we'll attach to the `BODY` element. It is at this point that we
    become a real DOM element in the display hierarchy.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，我们将连接到 `attachTo` 中指定的元素，但如果它未定义，我们将连接到 `BODY` 元素。就在这一点上，我们成为了显示层次结构中的真实
    DOM 元素。
- en: 'Unfortunately this isn''t all. Remember that our HTML files have `SCRIPT` tags
    in them. For whatever reason, these scripts don''t execute automatically when
    loaded in this fashion. We have to create `SCRIPT` tags for them again, as shown
    in the following code snippet:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这还不是全部。记住，我们的 HTML 文件中包含 `SCRIPT` 标签。由于某种原因，这些脚本以这种方式加载时不会自动执行。我们必须再次为它们创建
    `SCRIPT` 标签，如下面的代码片段所示：
- en: '[PRE115]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'First, we get all the `SCRIPT` tags in our newly created element. Then we''ll
    iterate through each one, like this:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取我们新创建元素中的所有 `SCRIPT` 标签。然后我们将遍历每一个，如下所示：
- en: '[PRE116]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: If this code looks somewhat familiar, it's because `PKUTIL.include` has a variant
    of it. The important distinction is that it was only concerned about the data
    of the script; here we have to worry if the script is defined as an external script.
    That is why we check to see if the `SRC` attribute is defined.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码看起来有些熟悉，那是因为 `PKUTIL.include` 有一个类似的变体。重要的区别是它只关注脚本的 数据；这里我们必须担心脚本是否定义为外部脚本。这就是为什么我们要检查
    `SRC` 属性是否已定义。
- en: 'We also have surrounded this in a `try`/`catch` block, just in case the scripts
    have errors in them:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将其放在一个 `try`/`catch` 块中，以防脚本中存在错误：
- en: '[PRE117]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We''ve finished loading the HTML and the scripts, so we call the `completion`
    function:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 HTML 和脚本的加载，因此我们调用 `completion` 函数：
- en: '[PRE118]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'If, for whatever reason, we couldn''t load the view, we generate a log message
    and call the `completion` function with a failure notification as follows:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因我们无法加载视图，我们将生成一个日志消息，并调用 `completion` 函数，如下所示，带有失败通知：
- en: '[PRE119]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Next, we should review the new localization functions we encountered. The first
    was `PKLOC.initializeGlobalization()`:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该回顾我们遇到的新本地化功能。第一个是 `PKLOC.initializeGlobalization()`：
- en: '[PRE120]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: As you can see, all it does is load the `jQuery/Globalize` framework, and then
    call its completion handler.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它所做的只是加载 `jQuery/Globalize` 框架，然后调用其完成处理程序。
- en: 'The next function is `PKLOC.loadLocales`. It is designed to make it easy to
    load `jQuery/Globalize` culture files. These files live in the `www/framework/cultures`
    directory, and you can have and load as many as you like. Just remember that the
    more you have, the larger your app will be, and the longer it will take to start:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是 `PKLOC.loadLocales`。它旨在使加载 `jQuery/Globalize` 文化文件变得容易。这些文件位于 `www/framework/cultures`
    目录中，你可以拥有并加载尽可能多的文件。只需记住，你拥有的越多，你的应用程序就越大，启动所需的时间就越长：
- en: '[PRE121]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Here we take advantage of the fact that `PKUTIL.include` takes an array of script
    files. The incoming locales (in no real particular order; `jQuery/Globalize` culture
    files only depend upon the `jQuery/Globalize` library being loaded) are already
    in an array, and so we alter the array to include the full path and name of the
    culture file. When we're done, we include them, and the `completion` function
    will be called when they are all loaded.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用 `PKUTIL.include` 接受脚本文件数组的事实。传入的本地化（没有真正的特定顺序；`jQuery/Globalize` 文化文件只依赖于已加载的
    `jQuery/Globalize` 库）已经在一个数组中，因此我们修改数组以包含文化文件的完整路径和名称。完成之后，我们将它们包含进来，当它们全部加载完毕时，将调用
    `completion` 函数。
- en: Game Over..... Wrapping it up
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束..... 结束
- en: 'Wow, we''ve been through a lot together in this first project. We''ve learned
    a lot too, including:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，在这个第一个项目中，我们一起经历了许多。我们也学到了很多，包括：
- en: How to properly localize text
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何正确本地化文本
- en: How to properly localize numbers
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何正确本地化数字
- en: How to properly localize dates
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何正确本地化日期
- en: How to properly localize images
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何正确本地化图像
- en: How to properly localize HTML
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何正确本地化 HTML
- en: How to implement simple HTML templates
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现简单的 HTML 模板
- en: How to create a new view
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个新的视图
- en: How to display the view
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何显示视图
- en: How to push a new view onscreen, and pop a view offscreen
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将新视图推送到屏幕上，并将视图从屏幕上弹出
- en: How to handle the Android/WP7 back button
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理 Android/WP7 返回按钮
- en: How to include files within our JavaScript
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在我们的 JavaScript 中包含文件
- en: How to determine the user's locale
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确定用户的区域设置
- en: How to initialize jQuery/Globalize and load the locales we might need
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何初始化 jQuery/Globalize 以及加载我们可能需要的区域设置
- en: 'There are some resources that you might find interesting. You might want to
    look through the YASMF documentation to learn more about the framework we''re
    using. Some of these resources are mentioned as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 有些资源你可能觉得很有趣。你可能想查阅 YASMF 文档，了解更多关于我们使用的框架的信息。以下是一些资源的提及：
- en: Adobe Photoshop at [http://www.adobe.com/PhotoshopFamily](http://www.adobe.com/PhotoshopFamily)
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adobe Photoshop 在 [http://www.adobe.com/PhotoshopFamily](http://www.adobe.com/PhotoshopFamily)
- en: GIMP at [http://www.gimp.org](http://www.gimp.org)
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GIMP 在 [http://www.gimp.org](http://www.gimp.org)
- en: PhoneGap downloads at [http://www.phonegap.com/download](http://www.phonegap.com/download)
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PhoneGap 下载在 [http://www.phonegap.com/download](http://www.phonegap.com/download)
- en: PhoneGap documentation at [http://docs.phonegap.com](http://docs.phonegap.com)
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PhoneGap 文档在 [http://docs.phonegap.com](http://docs.phonegap.com)
- en: YASMF GitHub at [https://github.com/photokandyStudios/YASMF/](https://github.com/photokandyStudios/YASMF/)
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YASMF GitHub 在 [https://github.com/photokandyStudios/YASMF/](https://github.com/photokandyStudios/YASMF/)
- en: YASMF documentation at [https://github.com/photokandyStudios/YASMF/wiki/](https://github.com/photokandyStudios/YASMF/wiki/)
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YASMF 文档在 [https://github.com/photokandyStudios/YASMF/wiki/](https://github.com/photokandyStudios/YASMF/wiki/)
- en: Xcode at [https://developer.apple.com/xcode](https://developer.apple.com/xcode)
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xcode 在 [https://developer.apple.com/xcode](https://developer.apple.com/xcode)
- en: Eclipse Classic 4.2.1 at [http://www.eclipse.org/downloads/packages/eclipse-classic-421/junosr1](http://www.eclipse.org/downloads/packages/eclipse-classic-421/junosr1)
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse Classic 4.2.1 在 [http://www.eclipse.org/downloads/packages/eclipse-classic-421/junosr1](http://www.eclipse.org/downloads/packages/eclipse-classic-421/junosr1)
- en: Android SDK download at [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android SDK 下载在 [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)
- en: Can you take the HEAT? The Hotshot Challenge
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能承受住热度吗？热手挑战
- en: There are quite a few ways that this project could be enhanced. Why don't you
    try your hand at one or more of them?
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目可以通过很多种方式来增强。你为什么不尝试其中之一或更多呢？
- en: The game currently supports English and Spanish. Try adding another language.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏目前支持英语和西班牙语。尝试添加另一种语言。
- en: If you play the game for any length of time, you'll find that the same question
    is often asked again within the same set. Make it so that a question can only
    be asked once per set.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你玩这个游戏任何一段时间，你会发现同一个问题经常在同一个集合中再次被问起。让它变得如此，一个问题在每个集合中只能问一次。
- en: Add categories to the questions, and then allow the user to select which category
    they'd like to play through.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为问题添加类别，然后允许用户选择他们想要玩过的类别。
- en: Add difficulty levels to the questions. These could affect the score awarded
    as well. Allow the user to select the difficulty level they want to play at.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为问题添加难度级别。这些可能会影响所获得的分数。允许用户选择他们想要玩的难度级别。
- en: Come up with an alternative look and feel for the game and implement it. Perhaps
    even allow the user to decide which look and feel they want to use.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提出一个游戏的不同外观和感觉，并实现它。也许甚至允许用户决定他们想要使用的外观和感觉。
