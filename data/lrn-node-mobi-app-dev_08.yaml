- en: Chapter 8. Making Our App Interactive
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使我们的应用程序交互
- en: In the previous chapter, we gave you a gist of how to work with user interfaces
    in Ionic. While doing so, we also gave you a thorough introduction to AngularJS,
    the driving force behind Ionic apps, and explained how you can use it in order
    to let users interact with your app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向您介绍了如何在Ionic中处理用户界面。在这样做的同时，我们还向您全面介绍了AngularJS，这是Ionic应用背后的推动力，并解释了您如何使用它来让用户与您的应用程序进行交互。
- en: Here, we will continue building on this while simultaneously exploring new features
    of Ionic, including the interaction with the native features of your device. We
    will put this all into practice by building a concrete app that will load and
    display the contacts from your phonebook. By doing so, you will also learn how
    to compile and run the Ionic apps on physical devices (such as iPhones and Android
    phones), rather than the emulator that we have used so far.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将继续构建这一点，同时探索Ionic的新功能，包括与设备的本机功能交互。我们将通过构建一个具体的应用程序来将所有这些付诸实践，该应用程序将从您的电话簿中加载和显示联系人。通过这样做，您还将学会如何在物理设备（如iPhone和Android手机）上编译和运行Ionic应用程序，而不是迄今为止我们使用的模拟器。
- en: Creating a new project
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: Ionic comes with a powerful **Command Line Interface** (**CLI**), which quickly
    lets you create, modify, and extend Ionic projects. By automating chores such
    as module integration and scaffolding, it can drastically improve your productivity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Ionic配备了一个强大的**命令行界面**（**CLI**），可以快速创建、修改和扩展Ionic项目。通过自动化诸如模块集成和脚手架等琐事，它可以大大提高您的生产力。
- en: '''Let''s use the CLI to create a basic project for us to work with in this
    chapter. Go to your working directory and run the following in a terminal:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '''让我们使用CLI为我们创建一个基本项目，以便在本章中使用。转到您的工作目录，并在终端中运行以下命令：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a blank app containing only the basic components for a bare-bones
    working app. This is suitable for us, since we want to build an app from the ground
    up and learn as we go.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个仅包含基本组件的空白应用程序，适合我们，因为我们希望从零开始构建一个应用程序，并在学习过程中逐步学习。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ionic start` command has several other basic templates as well. For example,
    the `tabs` template gives you a basic app with tabbed navigation that you can
    extend, while side menu creates a basic app with a side menu for navigation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`ionic start`命令还有其他几个基本模板。例如，`tabs`模板为您提供了一个带有选项卡导航的基本应用程序，您可以扩展它，而`side menu`则创建了一个带有侧边菜单导航的基本应用程序。'
- en: When this command finishes running, you will have a complete project to work
    with. No extra fiddling is required! Now, let's go ahead and add some content
    in it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当此命令运行完成时，您将拥有一个完整的项目可供使用。无需额外的摆弄！现在，让我们继续在其中添加一些内容。
- en: Creating a basic MVC project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的MVC项目
- en: 'Our goal in this chapter is to create an app that can pull information from
    the contacts storage of the local device and display it to the user (a phonebook,
    if you like). To do so, we need to do the following things:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是创建一个应用程序，可以从本地设备的联系人存储中提取信息并显示给用户（如果您愿意，可以理解为电话簿）。为此，我们需要做以下几件事：
- en: Define a **view** (template file) to display the contact list
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个**视图**（模板文件）来显示联系人列表
- en: Define a **controller** in order to handle interactions with the list
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个**控制器**以处理与列表的交互
- en: Provide the necessary **model** logic in order to provide contacts' information.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供必要的**模型**逻辑以提供联系人信息。
- en: You may recall that this workflow fits nicely with the overall architecture
    of AngularJS, which follows the MVC pattern. We will take care of each item in
    turn.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，这个工作流程与AngularJS的整体架构非常匹配，遵循MVC模式。我们将逐个处理每个项目。
- en: Creating the view
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图
- en: 'Go ahead and add the following folder to your projects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并将以下文件夹添加到您的项目中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we will store all the view templates that we will use throughout our
    project. In this folder, let''s create our first view file, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将存储我们将在整个项目中使用的所有视图模板。在这个文件夹中，让我们创建我们的第一个视图文件，如下所示：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we need to add additional views to our app, we will do it in the same manner.
    Partitioning our views like this not only makes organization easier, but also
    boosts performance, since HTML will only be loaded on demand when it is needed,
    rather than all at once.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要向我们的应用程序添加额外的视图，我们将以相同的方式进行。这样分区我们的视图不仅使组织更容易，而且还提高了性能，因为HTML只会在需要时按需加载，而不是一次性加载所有内容。
- en: 'Let''s add some content in order to create an actual view:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些内容，以创建一个实际的视图：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Don''t concern yourself with the list-related tags yet; we will get to what
    they do in a moment. For now, let''s look at the two outer ones:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不要担心与列表相关的标签；我们将在稍后介绍它们的作用。现在，让我们先看看两个外部标签：
- en: '`ion-view`: This tag tells Ionic that this is a view that can be dynamically
    loaded from other parts of the application. We add the view-title attribute to
    it in order to create a label that can be used to refer to the view.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ion-view`：此标签告诉Ionic这是一个可以从应用程序的其他部分动态加载的视图。我们在其中添加了view-title属性，以创建一个可用于引用视图的标签。'
- en: '`ion-content`: This tag designates a content area in the view, which is especially
    good at displaying scrolling data. Since we want to display a list of contacts
    of an unknown length, this is what we will want to wrap our list in.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ion-content`：此标签指定视图中的内容区域，特别擅长显示滚动数据。由于我们想要显示一个未知长度的联系人列表，这就是我们想要将列表包裹在其中的内容。'
- en: Creating the list view
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建列表视图
- en: Lists are some of the most ubiquitous data structures in apps everywhere. So,
    it is no surprise that most frameworks provide powerful tools to work with them.
    Ionic is certainly no exception.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是应用程序中最普遍的数据结构之一。因此，大多数框架都提供了强大的工具来处理它们，这并不奇怪。Ionic当然也不例外。
- en: 'Have a look at the code that we added earlier. Especially note the tags inside
    the `ion-content` tag:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们之前添加的代码。特别注意`ion-content`标签内的标签：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following two tags encapsulate the majority of Ionic''s list rendering
    capabilities and are generally everything that you need in order to display the
    list:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个标签封装了Ionic的大部分列表渲染功能，通常是您需要的一切来显示列表：
- en: '`ion-list`: This indicates that the wrapped content is a list'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ion-list`：这表示封装的内容是一个列表'
- en: '`ion-item`: This indicates a single data node, which can be rendered in a list'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ion-item`：这表示一个可以在列表中呈现的单个数据节点'
- en: Since each item in our list will be a single contact, we will wrap each of them
    in an `ion-item` tag.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们列表中的每个项目都将是一个单独的联系人，我们将把它们包装在`ion-item`标记中。
- en: 'At present, our view does not really do much apart from displaying an empty
    list. We need to add some markup in order to show the details of the contact wrapped
    in each item. Let''s do something basic first, such as just showing the name and
    mobile number of the contact, if any:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的视图除了显示一个空列表之外并没有做太多事情。我们需要添加一些标记来显示每个联系人的详细信息。让我们先做一些基本的事情，比如只显示联系人的姓名和手机号码，如果有的话：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we defined two Angular expressions to render the name and number of a
    contact during runtime. The contact in this case is simply a **JavaScript Object
    Notation** (**JSON**) object holding information about a given person in our contact
    list. Next, we will see how to assign a concrete value to this JSON object; this
    will take place in the associated controller.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个Angular表达式，以在运行时呈现联系人的姓名和号码。在这种情况下，联系人只是一个包含我们联系人列表中给定人员信息的**JavaScript对象表示**（**JSON**）对象。接下来，我们将看到如何为这个JSON对象分配一个具体的值；这将在相关的控制器中进行。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As of AngularJS 1.3, which is the version that is officially shipped with Ionic
    at the time of writing this book, it is possible to make expressions behave in
    a bind-once fashion. This means that they take on the values that they initially
    compute to, and the values are skipped by the AngularJS DOM update cycle after
    this, which improves performance. In our case, this works well, since we will
    only display our data once after fetching it, as we will see later. The downside
    of this method at this point in time is that updates to the data model will not
    be reflected in this view.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从AngularJS 1.3开始，这是写作本书时Ionic官方发布的版本，可以使表达式以一次绑定的方式运行。这意味着它们最初计算的值将被接受，并且在此之后将被AngularJS
    DOM更新周期跳过，从而提高性能。在我们的情况下，这很有效，因为我们在获取数据后只会显示一次数据，我们稍后会看到。这种方法的缺点是，此时数据模型的更新不会在此视图中反映出来。
- en: 'To make your expressions bind-once, add two colons (`::`) before them, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的表达式一次绑定，可以在它们之前添加两个冒号（`::`），如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating the controller
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建控制器
- en: You may recall that the controller is the *glue* between your view and model
    (that is, your business logic). Its primary responsibility is to handle interactions
    with your UI from the user and delegate the processing of an appropriate response
    to the model.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，控制器是视图和模型（即业务逻辑）之间的“粘合剂”。它的主要责任是处理用户与UI的交互，并将适当的响应处理委托给模型。
- en: In the previous chapter, the example controllers were located in a separate
    JavaScript file, where they were declared as part of a module. This is a good
    design practice, since it makes it much easier to structure your app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，示例控制器位于一个单独的JavaScript文件中，它们被声明为模块的一部分。这是一个很好的设计实践，因为它可以更轻松地构建应用程序结构。
- en: 'Note that our blank project does not have such a file. So, let''s start by
    creating it. Add the following file to your project:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的空白项目没有这样的文件。因此，让我们从创建它开始。将以下文件添加到您的项目中：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this file, let''s add the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，让我们添加以下内容：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s recap in brief to see what the preceding code does:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下前面的代码做了什么：
- en: 'We defined a module using the core `angular.module()` function, which takes
    the following parameters:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用核心的`angular.module()`函数定义了一个模块，它接受以下参数：
- en: The first parameter is `phonebook.controllers`, which is the name of the module.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是`phonebook.controllers`，这是模块的名称。
- en: The second parameter is an empty list, which indicates that this module has
    no external dependencies. If it did, we would list their names here so that the
    AngularJS dependency injection system can resolve them during runtime.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个空列表，表示此模块没有外部依赖项。如果有的话，我们将在这里列出它们的名称，以便AngularJS依赖注入系统可以在运行时解析它们。
- en: 'Having created a module, we attach a controller to it using the (aptly named)
    core function `controller()`. The following arguments are passed to this function:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个模块后，我们使用（恰当命名的）核心函数`controller()`将控制器附加到它。将以下参数传递给此函数：
- en: '`ContactsCtrl`, which is the name of the controller, is the first argument.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContactsCtrl`，这是控制器的名称，是第一个参数。'
- en: The second argument is a `function` that defines what the controller does. In
    this controller, we will define any and all the actions that are taking place
    in the segment of the app controlled by this controller. Note that this function
    takes the `$scope` parameter (we will get to what it does a bit later). Just like
    the dependency list in the module, this parameter and all the others passed to
    the function (there can be any number of parameters or none at all) denote a dependency
    of this controller, which will be resolved at runtime using the dependency injection
    system.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个定义控制器功能的`function`。在这个控制器中，我们将定义在该控制器控制的应用程序部分中发生的所有操作。请注意，这个函数接受`$scope`参数（稍后我们将介绍它的作用）。就像模块中的依赖项列表一样，这个参数和传递给函数的所有其他参数（可以是任意数量的参数，也可以没有）表示这个控制器的依赖关系，它将在运行时使用依赖注入系统解析。
- en: For now, this is all we need in order to have a full-fledged controller. Next,
    we will need to connect it with our view.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这就是我们需要一个完整的控制器。接下来，我们需要将它与我们的视图连接起来。
- en: Connecting the view and controller
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接视图和控制器
- en: 'We have the following two choices if we need to bring our newly created view
    and controller together:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将我们新创建的视图和控制器连接在一起，我们有以下两种选择：
- en: We can use an inline view, where we put a reference to the view and controller
    directly in the `index.html` file or another template, which is in turn loaded
    from `index.html`
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用内联视图，在`index.html`文件或另一个模板中直接放置对视图和控制器的引用，然后从`index.html`加载。
- en: We can use a router to associate the view and its controller with a certain
    path within the application
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用路由器将视图及其控制器与应用程序中的某个路径关联起来
- en: Even though we only have one view for now, we will go for the second option.
    This might seem redundant, but it makes it much easier to structure the app in
    the event that we want to add new navigation states later on (spoiler—we will!)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们现在只有一个视图，我们也会选择第二个选项。这可能看起来多余，但如果以后想要添加新的导航状态，这样做会使得结构化应用程序变得更加容易（剧透-我们会！）
- en: 'Routing is normally configured in the `app.js` file. So, that is where we will
    go next. Open the file and make sure that it has the following content:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 路由通常在`app.js`文件中配置。所以，接下来我们将打开该文件并确保它具有以下内容：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's consider what is going on here, particularly in the `config` function.
    Here, we set up the core navigation settings for our app by configuring the routing
    module exposed by `$stateProvider` and `$urlRouterProvider`. By default, Ionic
    uses the `ui-router` (for more information, visit [https://github.com/angular-ui/ui-router](https://github.com/angular-ui/ui-router)).
    This router is state-oriented. That is, it lets you structure your app as a state
    machine, where each state can be connected to a path and a set of views and controllers.
    This setup makes it very easy to work with nested views, which is a frequent case
    when developing for mobile devices, where navigation elements like tabs, side
    menus, and the like are very common.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这里发生了什么，特别是在`config`函数中。在这里，我们通过配置由`$stateProvider`和`$urlRouterProvider`公开的路由模块来设置应用程序的核心导航设置。默认情况下，Ionic使用`ui-router`（有关更多信息，请访问[https://github.com/angular-ui/ui-router](https://github.com/angular-ui/ui-router)）。这个路由器是面向状态的。也就是说，它允许您将应用程序构建为状态机，其中每个状态都可以连接到一个路径和一组视图和控制器。这种设置使得在开发移动设备时非常容易处理嵌套视图的情况，其中导航元素如选项卡、侧边菜单等非常常见。
- en: 'Knowing this, let''s consider what this code actually does:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点，让我们考虑这段代码实际上做了什么：
- en: The `config` function itself takes two arguments, `$stateProvider` and `$urlRouterProvider`.
    Both are configuration interfaces belonging to `ui-router` and can be used to
    configure the router when the app bootstraps.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config`函数本身接受两个参数，`$stateProvider`和`$urlRouterProvider`。两者都是属于`ui-router`的配置接口，可以在应用启动时用于配置路由器。'
- en: 'We use the `$stateProvider` argument in order to add the state contacts to
    our app. When the application is in this state, we make the following properties
    hold:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`$stateProvider`参数来向我们的应用程序添加状态contacts。当应用程序处于此状态时，我们使以下属性保持：
- en: The current path within the app is root (`/`),that is, we are in this state
    whenever we are at the initial path of the app.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的当前路径是根路径（/），也就是说，只要我们在应用程序的初始路径上，我们就处于这种状态。
- en: The template to be loaded for this state is `templates/contacts.html`, which
    is the same view template that we created earlier.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载此状态的模板是`templates/contacts.html`，这是我们之前创建的相同视图模板。
- en: The controller associated with this view is `ContactsCtrl`, which was defined
    earlier as well. Since our `phonebook.controllers` module is loaded as a dependency
    for our app (see the first line of `app.js`), we only need to name the controller,
    and the dependency injection system will do the rest.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与此视图关联的控制器是`ContactsCtrl`，之前也已经定义。由于我们的`phonebook.controllers`模块作为我们应用程序的依赖项加载（请参见`app.js`的第一行），我们只需要命名控制器，依赖注入系统将完成其余部分。
- en: Finally, we configure a default route for our app. This is the route our navigation
    will resolve to if no other valid route is provided. In our case, we always default
    to the start screen.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为我们的应用程序配置了一个默认路由。这是我们的导航将解析到的路由，如果没有提供其他有效的路由。在我们的情况下，我们总是默认到起始屏幕。
- en: 'That''s all we need to get the routing going! Next, we need to make sure that
    the `index.html` file has the necessary content to load all the files that we
    configured so far, including the new contacts view. Open it, and make sure that
    it has the following content:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要进行路由的全部内容！接下来，我们需要确保`index.html`文件具有必要的内容，以加载到目前为止我们配置的所有文件，包括新的contacts视图。打开它，并确保它具有以下内容：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Pay attention to the highlighted parts:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意高亮显示的部分：
- en: The `script` tag simply imports the `phonebook.controllers` module.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script`标签只是导入`phonebook.controllers`模块。'
- en: The `ion-nav-bar` tag creates a standard navigation bar, which displays content
    specific to the current navigation context that the app is in.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ion-nav-bar`标签创建一个标准的导航栏，显示特定于应用程序当前导航上下文的内容。'
- en: If you own an Android device, this will be similar to the action bar at the
    top, where you have your app logo, the name of the current view, and so on
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您拥有Android设备，这将类似于顶部的操作栏，其中包含应用程序徽标、当前视图的名称等
- en: Likewise, if you own an iPhone, this bar will be the bottom bar, which commonly
    holds the app's navigation tabs
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您拥有iPhone，此栏将是底部栏，通常包含应用的导航选项卡
- en: The `ion-nav-back-button` tag creates a button to go backwards from the current
    navigation context to the previous one, much like a back button in a browser.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ion-nav-back-button`标签创建一个按钮，用于从当前导航上下文返回到上一个导航上下文，就像浏览器中的返回按钮一样。'
- en: Finally, `ion-nav-view` is a special tag, which tells AngularJS where the routing
    system should bind the templates. In our case, this is where the `templates/contacts.html`
    template will be rendered when our navigation context is the contacts state, as
    we defined in our router `config` earlier.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`ion-nav-view`是一个特殊的标签，告诉AngularJS路由系统应该绑定模板。在我们的情况下，当我们的导航上下文是contacts状态时，这就是`templates/contacts.html`模板将被呈现的地方，就像我们之前在路由器`config`中定义的那样。
- en: Testing the connection
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试连接
- en: 'This is all we need for a basic setup of our app. To make sure it runs, let''s
    try it out in the emulator. From the root of your project folder, run the following
    in a terminal or command line:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的应用程序的基本设置所需的一切。为了确保它能运行，让我们在模拟器中试一下。从项目文件夹的根目录，在终端或命令行中运行以下命令：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the following output of the preceding command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到前面命令的以下输出：
- en: '![Testing the connection](img/B04653_08_01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![测试连接](img/B04653_08_01.jpg)'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on the browser you run your emulator in, you may not see the top or
    bottom bar. This is not generated by Ionic, but rather by a Chrome plugin, which
    automatically sets the size of the window to match that of an iPhone 6\. The plugin
    is called **Mobile/Responsive Web Design Tester**, and we recommend that you try
    it for your own projects.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你在模拟器中运行的浏览器，你可能看不到顶部或底部的栏。这不是Ionic生成的，而是由一个Chrome插件生成的，该插件会自动设置窗口的大小以匹配iPhone
    6的大小。该插件称为**Mobile/Responsive Web Design Tester**，我们建议你尝试一下，看看它适用于你自己的项目。
- en: Creating the model
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型
- en: We now have a working view and controller. Next, we need a model that can provide
    the data we need in response to user input.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个工作的视图和控制器。接下来，我们需要一个模型，可以根据用户输入提供我们需要的数据。
- en: Services
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: In AngularJS, it is considered good design practice to keep as little logic
    in the controllers as possible. Remember that controllers should only be the *glue*
    between the view and the model. They should ideally not be responsible for doing
    any of the heavy fetching and crunching of data. For that, AngularJS provides
    the services.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中，将尽量少的逻辑放在控制器中被认为是良好的设计实践。记住，控制器应该只是视图和模型之间的*粘合剂*。它们理想情况下不应该负责获取和处理数据。为此，AngularJS提供了服务。
- en: Services are objects that are injected into other components of your app on
    demand by the dependency injection system. If you look back at the `app.js` code,
    you have seen some of them already; both the `$stateProvider` and `$urlRouterProvider`
    arguments fall in this category.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是通过依赖注入系统按需注入到应用程序的其他组件中的对象。如果回顾一下`app.js`代码，你已经看到了其中一些；`$stateProvider`和`$urlRouterProvider`参数都属于这一类。
- en: If you look at advanced AngularJS apps, you will start seeing services pretty
    much everywhere. They make up a large part of almost any app and can be used to
    contain almost any kind of functionality. For example, we can create a service
    that encapsulates access to a given REST API, allowing us to query it by a set
    of utility functions while the service itself handles connections to the server,
    security, and so on. Likewise, we can define a service that represents a set of
    mathematical operations, which can be fed simple data in order to get arithmetic
    results.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看过高级的AngularJS应用程序，你会发现服务几乎无处不在。它们构成了几乎任何应用程序的一个重要部分，并且可以用来包含几乎任何类型的功能。例如，我们可以创建一个封装对给定REST
    API访问的服务，允许我们通过一组实用函数查询它，而服务本身处理与服务器的连接、安全等。同样，我们可以定义一个代表一组数学运算的服务，可以向其提供简单数据以获得算术结果。
- en: '**Services** are **singletons**, which means that only a single instance of
    each exists during runtime.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**是**单例**，这意味着在运行时只存在一个实例。'
- en: 'Implementing your business logic in this fashion is important for several reasons,
    some of which are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式实现业务逻辑对于几个原因非常重要，其中一些原因如下：
- en: It provides modular interfaces to work with a certain aspect of your app's business
    logic. Your model can be built around several services, each providing a single,
    essential feature of your app's functionality.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了模块化接口，用于处理应用程序业务逻辑的某个方面。你的模型可以围绕几个服务构建，每个服务提供应用程序功能的单一、基本特性。
- en: It is efficient, since you only have a single instance of each service available
    throughout your entire app.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是高效的，因为你在整个应用程序中只有一个服务的实例可用。
- en: It makes it easier to extend your app, as units of functionality can be defined
    and injected wherever they are needed.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得扩展你的应用程序更容易，因为功能单元可以被定义和注入到需要它们的任何地方。
- en: Now that we have established how awesome services are, the natural question
    is, how are we going to go about their creation?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了服务有多棒，自然的问题是，我们将如何创建它们？
- en: Creating services
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建服务
- en: 'AngularJS provides several ways to create services. These ways are referred
    to as recipes. There are five of them in total—constants, values, providers, factories,
    and services. Each varies in complexity and the use cases that are suitable for
    them:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS提供了几种创建服务的方法。这些方法被称为配方。总共有五种——常量、值、提供者、工厂和服务。它们在复杂性和适用用例上各不相同：
- en: '**Constants**: The most simple service, this is used to define a single constant,
    which is available throughout the entire application. It varies from the other
    four in the sense that it is immediately instantiated when an app starts up, which
    means that it can be used during the configuration phase of the app''s lifecycle.
    Constants are often used to contain constant values such as base URLs.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**：最简单的服务，用于定义一个单一的常量，该常量在整个应用程序中都可用。它与其他四个不同之处在于，当应用程序启动时立即实例化，这意味着它可以在应用程序生命周期的配置阶段使用。常量通常用于包含诸如基本URL之类的常量值。'
- en: '**Values**: This is similar to constants, with the notable exception that it
    is not available during the configuration phase of the app. It may also be used
    in `decorators`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：这与常量类似，但有一个显著的例外，即它在应用程序的配置阶段不可用。它也可以用于`decorators`。'
- en: '**Factories**: Whereas constants and values are used to store simple values,
    factories begin making things much more interesting:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂**：常量和值用于存储简单值，而工厂开始变得更加有趣：'
- en: They provide factory functions, which can be used to define logic rather than
    just values. This means that a factory can provide multiple functions, which compute
    values based on input.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供工厂函数，可以用于定义逻辑而不仅仅是值。这意味着工厂可以提供多个函数，根据输入计算值。
- en: Factories can have dependencies, which means that you can construct them using
    other services.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂可以有依赖项，这意味着你可以使用其他服务来构建它们。
- en: Factories are lazily instantiated, which means that they are only instantiated
    when they are needed.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂是懒惰实例化的，这意味着只有在需要时才会实例化。
- en: For our app here this is the recipe that we will be using, and as such you will
    see its example soon. In fact, we contend that factories will fit most of the
    available use cases for most apps.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序来说，这是我们将要使用的配方，因此很快你将看到它的示例。事实上，我们认为工厂将适用于大多数应用程序的大多数可用用例。
- en: '**Services**: Services are very, very similar to factories. While there are
    some minor differences in semantics, their real contribution is to provide a concise
    syntax. Using a factory or service is almost always a matter of preference. Oh,
    and in case you are wondering about the name, the AngularJS developers themselves
    regret calling it *services*, likening it to naming your child *child*.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：服务与工厂非常相似。虽然在语义上有一些细微的差别，但它们真正的贡献在于提供简洁的语法。使用工厂或服务几乎总是一种偏好。哦，如果你想知道这个名字，AngularJS的开发人员自己后悔称其为*服务*，就像给你的孩子取名为*孩子*一样。'
- en: '**Providers**: Finally, the most advanced recipe is the **provider**, which
    offers the full range of functionality offered by services (no, not the ones that
    we just mentioned; we are talking about the actual services—the naming was a pretty
    bad idea, wasn''t it?) In particular, Providers allow you to expose the service
    to configuration during the `config` phase of the app before the service is actually
    used during the `run` phase. It is worth while (and perhaps surprising) to note
    that the provider is actually the only recipe for services; the previous four
    are just syntactic sugar simplifying its use. Because it is so complex, it is
    an overkill for most cases, which is why there are other options to choose from
    depending on how complex your model logic is.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供者**：最后，最高级的配方是**提供者**，它提供了服务提供的全部功能范围（不，不是我们刚提到的那些；我们说的是实际的服务——命名真是个糟糕的主意，不是吗？）特别是，提供者允许你在应用程序的`config`阶段之前对服务进行配置，在`run`阶段实际使用服务。值得注意的是，提供者实际上是服务的唯一配方；前面的四个只是简化其使用的语法糖。因为它非常复杂，对于大多数情况来说都是过度的，这就是为什么根据你的模型逻辑有多复杂，还有其他选择可供选择。'
- en: So much knowledge, so little space! Let's put what we have learned to good use
    by actually creating a factory to retrieve contacts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 知识如此之多，空间如此之小！让我们把我们所学到的知识应用到实践中，通过实际创建一个工厂来检索联系人。
- en: Creating a factory
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个工厂
- en: 'Like controllers, it is customary to place your service definitions in their
    own file (or files, if you prefer to have each service recipe in its own file.
    Here, we use a common file for all of them). In your project directory, create
    the following file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与控制器一样，习惯上将服务定义放在它们自己的文件中（或者如果你更喜欢将每个服务配方放在自己的文件中，也可以放在多个文件中。在这里，我们使用一个公共文件来存放所有服务）。在项目目录中，创建以下文件：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this file, put the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，放入以下内容：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s have a look at what we have done:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们做了什么：
- en: We created a module named `phonebook.services` to host our services
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`phonebook.services`的模块来托管我们的服务
- en: We defined a basic `factory` service named `contactsFactory`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`contactsFactory`的基本`工厂`服务
- en: The service which exposes a single utility method is called `all`, which currently
    does not do anything (we will change this soon, don't worry).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露单个实用方法的服务称为`all`，目前什么也不做（我们很快会改变这一点，不用担心）。
- en: 'Now, we need to modify the `app.js` and `index.html` files in order to make
    the app aware of the new service. Make sure that the `app.js` file starts with
    the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改`app.js`和`index.html`文件，以使应用程序了解新的服务。确保`app.js`文件以以下内容开头：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This injects the services module into the main app. Now, we just need to import
    the file the module is located in. To do so, make sure that your JavaScript imports
    in `index.html` look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将服务模块注入到主应用程序中。现在，我们只需要导入模块所在的文件。为此，请确保`index.html`中的JavaScript导入如下所示：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it! We now have the groundwork of our app in place. However, if you run
    the emulator again, you will notice that not much has changed. We are still greeted
    by the same blank screen. Now, it is time to add some actual content to our app
    by loading the contact list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在已经把我们的应用程序的基础工作放在了那里。然而，如果你再次运行模拟器，你会注意到并没有太多改变。我们仍然被同样的空白屏幕所迎接。现在，是时候通过加载联系人列表向我们的应用程序添加一些实际内容了。
- en: Accessing the device data
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问设备数据
- en: Now that the basics of our app are have been implemented, it is time to add
    some serious data to it. In our case, we want to load the contacts stored on the
    device that our app is running on so that we can show them in the list that we
    created earlier.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序的基础已经实现，是时候向其中添加一些严肃的数据了。在我们的情况下，我们希望加载设备上存储的联系人，以便在之前创建的列表中显示它们。
- en: Accessing native services
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问原生服务
- en: You may recall that Ionic is built on top of the Cordova platform, which provides
    the core interaction with the underlying operating system and hardware. In order
    to access native services, such as the contact list, we will frequently have to
    make use of Cordova directly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得Ionic是建立在Cordova平台之上的，它提供了与底层操作系统和硬件的核心交互。为了访问原生服务，比如联系人列表，我们经常需要直接使用Cordova。
- en: In this particular case, we are in a very easy spot; Cordova not only has a
    full-fledged plugin to interact with the contacts, but also sports a very convenient
    CLI method to install it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，我们处于一个非常容易的位置；Cordova不仅有一个完整的插件来与联系人交互，而且还有一个非常方便的CLI方法来安装它。
- en: 'Go to your project directory and run the following from a terminal or command
    line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 转到项目目录，从终端或命令行运行以下命令：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will install the Cordova Contacts plugin, which will be placed in the
    following folder:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Cordova联系人插件，它将放置在以下文件夹中：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Feel free to inspect the files before we move on. Next, we need to integrate
    this plugin with Ionic so that we can use it in our app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，随意检查文件。接下来，我们需要将此插件与Ionic集成，以便在我们的应用程序中使用它。
- en: ngCordova
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ngCordova
- en: Cordova itself knows nothing about either Ionic or AngularJS. So, accessing
    its services in an Angular fashion will often require wrapper code. Fortunately,
    there is already an extensive library for this exact end—**ngCordova**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Cordova本身对Ionic或AngularJS一无所知。因此，以Angular方式访问其服务通常需要包装代码。幸运的是，已经有一个广泛的库正好满足了这一需求——**ngCordova**。
- en: 'To install it, go to the root of your project folder and run the following
    from a terminal:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，转到项目文件夹的根目录，并从终端运行以下命令：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will install everything we need. Next, let''s again import it into our
    app by modifying the `app.js` and `index.html` files. In `app.js`, make sure that
    your app dependencies now include `ngCordova`, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装我们需要的一切。接下来，让我们通过修改`app.js`和`index.html`文件再次将其导入我们的应用程序。在`app.js`中，确保你的应用程序依赖项现在包括`ngCordova`，如下所示：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Likewise, in `index.html`, make sure that we import the corresponding JS library,
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`index.html`中，确保我们导入相应的JS库，如下所示：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Adding Cordova contacts to our factory
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Cordova联系人添加到我们的工厂
- en: 'The last step here is to integrate the Cordova contacts with the `contactsFactory`
    service in order to let it serve the contacts available on the device. Open the
    `js/services.js` file and make sure that it contains the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后一步是将Cordova联系人与`contactsFactory`服务集成，以便让它提供设备上可用的联系人。打开`js/services.js`文件，并确保它包含以下内容：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The important parts are highlighted. Let''s figure out what is going on:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重点部分已经突出显示。让我们弄清楚发生了什么：
- en: 'We inject the following dependencies for our factory:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为我们的工厂注入以下依赖项：
- en: '`$q`: This is the AngularJS service that is used to work with `promises`. This
    will allow us to create `deferred` functions, which resolve to a value at a later
    stage. At that point, something can be done with their results.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$q`：这是AngularJS服务，用于处理`promises`。这将允许我们创建`deferred`函数，它们在以后解析为一个值。在那时，可以对它们的结果进行处理。'
- en: '`$cordovaContacts`: This is the Cordova contacts plugin itself that is wrapped
    by ngCordova.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$cordovaContacts`：这就是ngCordova包装的Cordova联系人插件本身。'
- en: Since raw contact data is rather clunky, we define a utility method in order
    to process it into something more lightweight.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于原始联系人数据相当笨重，我们定义了一个实用方法来处理它，使其更加轻量级。
- en: We create a `promise`, which is returned to whoever uses our service. The `promise`
    in this case is that at some point, we will deliver either a list of contacts,
    or an error indicating why we could not do so.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个`promise`，返回给使用我们服务的人。在这种情况下，`promise`是在某个时刻，我们将提供联系人列表，或者指示我们无法这样做的错误。
- en: We invoke the `find()` function of `cordovaContacts`, which is very similar
    to the MongoDB function with the same name; it simply returns all the available
    contacts.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`cordovaContacts`的`find()`函数，它与同名的MongoDB函数非常相似；它简单地返回所有可用的联系人。
- en: If we can get the list of contacts, we resolve the `promise` and hand over the
    list to the caller.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们可以获取联系人列表，我们会解析`promise`并将列表交给调用者。
- en: If we cannot get the list of contacts, we reject the promise, indicating that
    we were not able to get what was requested. An error message created by `cordovaContacts`
    is returned to the user.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们无法获取联系人列表，我们会拒绝`promise`，指示我们无法获取所请求的内容。由`cordovaContacts`创建的错误消息将返回给用户。
- en: Our service is now all configured and good to go. There is still one major hurdle
    though. Emulators have no contacts for us to display! In order to move on, we
    will first have to take a detour and see how to deploy the app on physical devices
    before we finally wrap up our app by showing the contacts to the user.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务现在已经配置好并准备就绪。不过还有一个主要障碍。模拟器没有我们可以显示的联系人！为了继续，我们首先必须绕道一下，看看如何在物理设备上部署应用程序，然后最终通过向用户显示联系人来完成我们的应用程序。
- en: Building for native devices
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为原生设备构建
- en: So far, everything we have done in Ionic has been tested in emulators or remote
    services. Now that we have an app that uses real phone features, it is time we
    finally went all the way and built the ultimate end-product—a mobile app.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在Ionic中所做的一切都是在模拟器或远程服务中进行测试的。现在我们有一个使用真实手机功能的应用程序，是时候最终构建终极成品——一个移动应用了。
- en: Building and deploying Ionic apps on physical devices is remarkably easy thanks
    to the Ionic CLI. We will demonstrate how to do so in the following section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Ionic CLI在物理设备上构建和部署Ionic应用程序非常容易。我们将在下一节中演示如何做到这一点。
- en: Android
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android
- en: 'From the root of your project folder, run the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目文件夹的根目录运行以下命令：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will add all the files that are necessary to deploy your app on an Android
    device.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加部署应用程序到Android设备所需的所有文件。
- en: Next, we have two options for the running of our app—an actual Android emulator
    or a physical device.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有两个选项来运行我们的应用程序——实际的Android模拟器或物理设备。
- en: Emulator
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟器
- en: 'To run the app in the emulator, first build the project by running the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模拟器中运行应用程序，首先通过运行以下命令构建项目：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, start the emulator and deploy the app by running the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启动模拟器并通过运行以下命令部署应用程序：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A physical device
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理设备
- en: 'Running an app on a physical device is just as simple as running the app on
    the emulator. First, connect an Android device that can accept APK installations
    over USB (see [Chapter 1](ch01.html "Chapter 1. Setting Up Your Workspace"), *Setting
    Up Your Workspace*, for instructions on setting this up). Once this is done, run
    the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理设备上运行应用程序与在模拟器上运行应用程序一样简单。首先，连接一个可以通过USB接受APK安装的Android设备（请参阅[第1章](ch01.html
    "第1章。设置您的工作区")，“设置您的工作区”中的说明）。完成后，运行以下命令：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, run the following to install and run the APK on your connected device:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行以下命令来安装并在连接的设备上运行APK：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once the app is deployed, it will start automatically on your device.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序部署，它将自动在您的设备上启动。
- en: The list view revisited
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表视图重访
- en: 'We will now add the finishing touches to our app, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为我们的应用程序添加最后的修饰，如下所示：
- en: Use logic to display the contacts that we pulled from the contact list
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用逻辑来显示我们从联系人列表中提取的联系人
- en: Add the pull-to-refresh feature in order to enable users to dynamically refresh
    the list of users.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加下拉刷新功能，以便用户可以动态刷新用户列表。
- en: 'First, let''s modify the `contacts.html` file in order to handle the rendering
    of the list itself. Open the file and make sure that it looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改`contacts.html`文件，以处理列表本身的渲染。打开文件并确保它看起来像这样：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Most things look the same, but we have highlighted some important changes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数东西看起来都一样，但我们已经强调了一些重要的变化：
- en: We added an `ion-refresher` tag, which creates a pull-to-refresh interface for
    our view. When the user swipes a finger downward over the screen, the text **Pull
    to refresh** will be shown. If the full gesture is then carried out (that is,
    swipe and drop), the `doRefresh()` function, which was defined in the scope of
    this view, will be called. We will define this function in just a bit.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个`ion-refresher`标签，为我们的视图创建了一个下拉刷新的界面。当用户在屏幕上向下滑动手指时，将显示文本**下拉刷新**。如果然后完成了整个手势（即滑动和释放），则会调用在该视图范围内定义的`doRefresh()`函数。我们将在稍后定义这个函数。
- en: We added a `collection-repeat` attribute to the `ion-item` tag. This is a variation
    of the `ng-repeat` AngularJS attribute, which means that one `ion-item` will be
    created for each contact number in the contacts collection. The contacts collection
    needs to be defined in the scope of the view, which will be done next.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`ion-item`标签中添加了一个`collection-repeat`属性。这是`ng-repeat` AngularJS属性的一个变体，这意味着每个联系人号码在联系人集合中都会创建一个`ion-item`。联系人集合需要在视图的范围内定义，接下来将完成这一步。
- en: 'Modify the `controllers.js` file to make it look like the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`controllers.js`文件，使其看起来像以下代码：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s consider what happened here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下这里发生了什么：
- en: We created and bound the empty contacts list to the `scope` tag injected into
    this controller. This corresponds to the same contacts list that the `collection-repeat`
    directive in our view uses.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建并绑定了空的联系人列表到注入到该控制器的`scope`标签。这对应于我们视图中`collection-repeat`指令使用的相同联系人列表。
- en: 'Likewise, we bound the `doRefresh` function, which we already saw in the view,
    to our scope. We made it do the following:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，我们将`doRefresh`函数绑定到我们的作用域中，这个函数我们已经在视图中看到了。我们让它执行以下操作：
- en: Call the `all()` method of the `contactsFactory` class. This gives us a promise
    that a list of contacts will be delivered at some point in the future.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`contactsFactory`类的`all()`方法。这给了我们一个承诺，将来某个时候会提供联系人列表。
- en: If the promise is fulfilled, we bind the resulting list to the scope. Angular
    will respond to this change by refreshing the view in order to accommodate this
    change in the model and populating the list with contact information using collection-repeat.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果承诺得到了实现，我们将结果列表绑定到作用域。Angular将对此变化做出响应，通过刷新视图来适应模型中的这种变化，并使用collection-repeat填充联系人信息列表。
- en: If the promise fails, we display an error message.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果承诺失败，我们会显示错误消息。
- en: Angular promises allow us to listen to progress notifications from promises.
    We do not use this feature here, but we simply catch such messages.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Angular承诺允许我们监听来自承诺的进度通知。我们在这里没有使用这个功能，而是简单地捕获这样的消息。
- en: That's it! You should now be able to run your app and browse your contacts.
    Go through the build steps for native devices again and try it out!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在你应该能够运行你的应用程序并浏览你的联系人。再次按照原生设备的构建步骤尝试一下！
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we covered a lot of ground, going into great depth as regards
    AngularJS and learning more about the interaction of a model, view, and controller.
    We also saw how to use Cordova plugins and ngCordova in order to access native
    features (something that we will be doing a lot of in the future chapters). Finally,
    we saw how to create services and use them in order to serve data to our users.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，深入了解了AngularJS，并学习了有关模型、视图和控制器交互的更多知识。我们还看到了如何使用Cordova插件和ngCordova来访问原生功能（这在以后的章节中我们将经常做）。最后，我们看到了如何创建服务并使用它们来为用户提供数据。
- en: We also recommend the usage of your favorite browser's inspect element tools,
    which can give you an insight into any display errors that you might run into
    when running the application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还建议使用您喜欢的浏览器的检查元素工具，这可以让您了解在运行应用程序时可能遇到的任何显示错误。
