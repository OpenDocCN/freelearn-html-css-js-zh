- en: Chapter 5. Assembling Chains
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。链式组装
- en: So far, the examples we've looked at in this book used Lo-Dash functions independently
    of one another. That's not to say they're not working together; it's just that
    they could be cleaner, or more condensed. We would call the function to compute
    a value, store that value, call another function to compute a new value using
    the stored value as an argument, and repeat the same process. This is exhausting
    but can be easily remedied.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中我们讨论的例子都是独立使用 Lo-Dash 函数的。这并不意味着它们不能一起工作；只是它们可以更简洁，或者更紧凑。我们会调用一个函数来计算一个值，存储这个值，然后调用另一个函数使用存储的值作为参数来计算一个新的值，并重复这个过程。这很累人，但可以很容易地解决。
- en: The idea is to streamline this functionality into a chain of calls. This approach
    follows the concept of applicative programming, whereby we have a starting collection
    and at each stage in the chain, that collection is transformed. It's like an assembly
    line where the resulting product is a value that you need in a given context.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是将这个功能流线化为一系列调用。这种方法遵循应用编程的概念，即我们有一个起始集合，在链的每个阶段，这个集合都会被转换。它就像一条装配线，最终产品是在特定上下文中需要的值。
- en: Lo-Dash enables this mode of programming through the wrapper concept—a constructor
    function used to wrap primitive values that enable chained function calls. In
    this chapter, we'll see how we can use this approach to simplify complex code
    and even produce reusable components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 通过包装器概念实现了这种编程模式——一个构造函数，用于包装原始值，从而实现链式函数调用。在本章中，我们将看到如何使用这种方法简化复杂的代码，甚至产生可重用的组件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating Lo-Dash wrappers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Lo-Dash 包装器
- en: Building filters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建过滤器
- en: Testing truth conditions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试真值条件
- en: Counting items
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数项目
- en: Transformations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换
- en: Intermediary results
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间结果
- en: Keys and values
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键和值
- en: Returning chains
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回链
- en: Creating Lo-Dash wrappers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Lo-Dash 包装器
- en: In this section, we'll introduce the concept of wrapping values. Then we'll
    use the wrapper to chain function calls. We'll also look at how call chains are
    terminated.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍包装值的理念。然后我们将使用包装器来链式调用函数。我们还将探讨如何终止调用链。
- en: Chained calls
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链式调用
- en: Chaining function calls together is a pattern of applicative programming, where
    a collection is transformed into something different. This newly transformed collection
    is then passed to the next call in the chain, and so on. This is where the term
    applicative comes from; you're applying functions to every item in a collection.
    Since this process is repeated over and over, it's easy to package chained calls
    into a reusable component. It's a pipeline that's adding, removing, or modifying
    values along each step of the way, producing a result at the end.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数调用链在一起是应用编程的一种模式，其中集合被转换成不同的东西。这个新转换的集合随后被传递到链中的下一个调用，依此类推。这就是“应用”这个术语的来源；你正在将函数应用于集合中的每个项目。由于这个过程反复进行，很容易将链式调用打包成一个可重用的组件。这是一个在每一步添加、删除或修改值的管道，最终产生一个结果。
- en: 'Another way, perhaps, is a more practical view of chains, which is just a simpler
    way to make function calls. jQuery popularized this notion. When reading jQuery
    code, you''ll find that there are a lot of chained calls, and yet the code is
    readable. Often, chains can be built as a single statement, as shown in the following
    code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的方式是对链的更实际的观点，它只是调用函数的一种更简单的方式。jQuery 使这一概念流行起来。当阅读 jQuery 代码时，你会发现有很多链式调用，但代码仍然是可读的。通常，链可以作为一个单独的语句来构建，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This jQuery chain consists of four calls, expressed as a single statement. The
    first call is to the jQuery constructor, which wraps the specified DOM elements.
    Next, we call `children()` to get the child elements. The `first()` function returns
    the first child element. The chain is terminated with a call to `is()`, which
    returns a simple Boolean value, not a jQuery object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 jQuery 链由四个调用组成，表达为一个单独的语句。第一个调用是 jQuery 构造函数，它包装了指定的 DOM 元素。接下来，我们调用 `children()`
    来获取子元素。`first()` 函数返回第一个子元素。链通过调用 `is()` 结束，它返回一个简单的布尔值，而不是 jQuery 对象。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take note of the code formatting here. If you're going to compose chains of
    functionality, it is important to keep your code readable. The main convention
    that I would recommend to follow is to indent chained calls on the next line.
    This way, you don't have statements that span an obnoxious number of columns,
    and you can tell at a glance that this chunk of code is a chain of function calls.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的代码格式。如果你要组合功能链，保持代码的可读性非常重要。我推荐遵循的主要约定是，在下一行缩进链式调用。这样，你不会有不必要的跨多列的语句，并且可以一眼看出这段代码是一个函数调用链。
- en: Wrapping values
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装值
- en: Wrapping values in Lo-Dash works pretty much the same as with jQuery. There's
    a wrapper call that constructs the jQuery/Lo-Dash object. Each **chainable** call
    returns a wrapper object. There's a terminating call that returns a primitive
    type. There are some obvious differences too, with regard to how jQuery and Lo-Dash
    wrap values. For instance, you can't pass a CSS selector string to the Lo-Dash
    wrapper function and expect it to wrap DOM elements. Nor would you want it to—Lo-Dash
    is a low-level utility library, whereas jQuery works at a fundamentally higher
    level of abstraction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lo-Dash中包装值的工作方式基本上与jQuery相同。有一个包装器调用构建jQuery/Lo-Dash对象。每个**链式**调用返回一个包装器对象。有一个终止调用返回一个原始类型。也有一些明显的区别，关于jQuery和Lo-Dash如何包装值。例如，你不能传递一个CSS选择器字符串给Lo-Dash包装器函数，并期望它包装DOM元素。你也不希望这样做——Lo-Dash是一个低级实用程序库，而jQuery在根本上是更高层次的抽象。
- en: 'That''s not the whole story of how wrapping values and applying function call
    chains work. There are subtle nuances and edge cases around every corner, all
    of which we''ll address over the course of the chapter. But for now, let''s get
    into the code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是包装值和应用函数调用链的全部故事。在每一个角落都有细微的差别和边缘情况，我们将在本章的整个过程中解决这些问题。但就目前而言，让我们进入代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here is our hello-world chain. The `_` object we've been using throughout the
    book to access the Lo-Dash API is also a constructor function. It takes a JavaScript
    primitive as an argument. This is the value that's wrapped and passed to the first
    function call in the chain. Here, we're calling the `at()` function, saying that
    we want the items at indices `1` and `2`. The call to `value()` gets us the result
    we're after.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的hello-world链。我们一直在书中使用`_`对象来访问Lo-Dash API，它也是一个构造函数。它接受一个JavaScript原始值作为参数。这就是被包装并传递给链中第一个函数调用的值。在这里，我们调用`at()`函数，表示我们想要索引为`1`和`2`的项。调用`value()`函数得到我们想要的结果。
- en: 'The preceding code obviously doesn''t warrant using a wrapper—there''s only
    one function call. The point, however, isn''t conciseness but rather the basic
    anatomy of a call chain. As we get to more elaborate examples throughout the chapter,
    we''ll see how chains substantially reduce the amount of code written. Here are
    two more Lo-Dash wrapper constructors:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前面的代码不需要使用包装器——只有一个函数调用。然而，重点不是简洁性，而是调用链的基本结构。随着我们在本章中遇到更复杂的例子，我们将看到链如何显著减少代码量。这里还有两个Lo-Dash包装器构造函数：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first wrapper uses a plain object as its primitive value. The second wrapper
    uses a string. The chain is terminated immediately in both cases because we're
    calling `contains()`, which itself returns a primitive Boolean value. Again, we
    didn't have to write the preceding code using wrappers and call chains. It's better
    that you don't if you're calling only one function, since you'd only be confusing
    other readers of your code otherwise. The point of the preceding code is to illustrate
    that we can wrap both plain objects and strings and treat them as collections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包装器使用一个普通对象作为其原始值。第二个包装器使用一个字符串。在两种情况下，链都会立即终止，因为我们调用了`contains()`，它本身返回一个原始布尔值。再次强调，我们不需要使用包装器和调用链来编写前面的代码。如果你只调用一个函数，最好不要这样做，否则你只会让其他阅读你代码的人感到困惑。前面代码的目的在于说明我们可以包装普通对象和字符串，并将它们视为集合。
- en: Explicit and implicit chaining
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式和隐式链式调用
- en: Once we have a Lo-Dash wrapper instance, we can start making chained function
    calls. However, not all of these functions are chainable. **Non-chainable** functions
    return primitive values such as Booleans or numbers. This is what is referred
    to as implicit chaining. It's implicit because functions that would return a collection
    actually return a Lo-Dash wrapper instance. Other functions don't have collections
    as return values. Calls to these functions will terminate the chain.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 Lo-Dash 包装器实例，我们就可以开始进行链式函数调用了。然而，并非所有这些函数都是可链式的。**不可链式**的函数返回原始值，例如布尔值或数字。这被称为隐式链式。它是隐式的，因为那些本应返回集合的函数实际上返回了一个
    Lo-Dash 包装器实例。其他函数没有集合作为返回值。对这些函数的调用将终止链式调用。
- en: 'On the other hand, there''s explicit chaining—this will keep the chain alive
    until it''s explicitly terminated by calling `value()`. For example, if your chain
    is explicit, calling `contains()` will return a wrapper, instead of a Boolean
    as it normally would. The following are examples of implicit and explicit chaining:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，存在显式链式调用——这将保持链式调用直到通过调用 `value()` 显式终止。例如，如果你的链式调用是显式的，调用 `contains()`
    将返回一个包装器，而不是通常的布尔值。以下是一些隐式和显式链式调用的示例：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first chain uses the default Lo-Dash chaining configuration. The `first()`
    function grabs the first item in an array and returns it. Since this item could
    be anything (in this case, it's a number), the `first()` function isn't chainable.
    We don't need to make an explicit call to `value()` since functions that aren't
    chainable return **unwrapped** values. The second chain, however, uses explicit
    chaining. This is done by constructing the Lo-Dash wrapper instance with the `chain()`
    function. The resulting wrapper is the same in every way, except that we need
    to make an explicit call to `value()` to unwrap the value. With explicit chaining,
    every function is chainable. For example, the call to `first()` now returns a
    wrapper instance instead of a number. This is also done by `isNumber()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个链使用默认的 Lo-Dash 链式配置。`first()` 函数获取数组中的第一个元素并返回它。由于这个元素可以是任何东西（在这个例子中是一个数字），`first()`
    函数是不可链式的。我们不需要显式调用 `value()`，因为不可链式的函数返回**未解包**的值。然而，第二个链使用显式链式调用。这是通过使用 `chain()`
    函数构造 Lo-Dash 包装器实例来实现的。结果包装器在所有方面都是相同的，除了我们需要显式调用 `value()` 来解包值。在显式链式中，每个函数都是可链式的。例如，`first()`
    的调用现在返回一个包装器实例而不是一个数字。这也是通过 `isNumber()` 实现的。
- en: The main reason you would want to use explicit chains like this is to avoid
    temporary variables and additional statements after the chain is complete. In
    the explicit chain in the preceding code, for instance, we just need to know whether
    the first item in the sorted collection is a number or not. There's no need to
    store the first item in a new variable if we can get exactly what we're after
    from the chain.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要使用这种显式链式调用的主要原因是为了避免在链式调用完成后使用临时变量和额外的语句。例如，在前面代码的显式链式中，我们只需要知道排序集合中的第一个元素是否是数字。如果我们能从链式中直接得到我们想要的，就没有必要将第一个元素存储在一个新变量中。
- en: Building filters
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建过滤器
- en: A powerful use of chained function calls is building filters that successively
    filter out unwanted items from a larger collection. Let's say that you already
    have a piece of code that's using the `filter()` function on a collection. But
    now you need to alter that filtering operation, perhaps by adding additional constraints.
    Rather than messing around with the existing `filter()` code that you know works,
    you can build a filter chain.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 链式函数调用的强大用途是构建过滤器，依次从较大的集合中过滤掉不需要的项。假设你已经有了一段使用 `filter()` 函数对集合进行操作的代码。但现在你需要修改这个过滤操作，可能需要添加额外的约束。与其去修改你已知可以正常工作的现有
    `filter()` 代码，你不如构建一个过滤器链。
- en: Multiple filter() calls
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多次调用 filter()
- en: 'The simplest approach to assembling filter chains is to join together multiple
    calls to the `filter()` function. Here''s an example of what that might look like:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 组装过滤器链的最简单方法是将多个 `filter()` 函数调用连接起来。以下是一个这样的例子：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first call to `filter()`uses the pluck-style shorthand on the `enabled`
    property, which filters out items with false values for this property. The next
    call to `filter()` uses a callback function that filters out items where the `age`
    property value is less than `21`. We're left with a single item, which is unwrapped
    by calling `value()`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 的第一次调用使用 `enabled` 属性的 pluck 风格简写，过滤掉该属性为假值的项。下一次 `filter()` 调用使用一个回调函数，过滤掉
    `age` 属性值小于 `21` 的项。我们最终只剩下一个项，通过调用 `value()` 来解包。'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: So what's the point of two or more calls to `filter()` when we could just modify
    the callback function? Wouldn't that mean less code and faster execution? The
    real advantage is in reading and modifying this code. Do we want to see what happens
    when we remove the enabled filter? Just comment out the line. Readability and
    maintainability should almost always trump attempts to squeeze performance out
    of complicated callback functions. Of course, there are exceptions to this, but
    don't invent performance issues for the sake of it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们可以直接修改回调函数时，为什么还要调用两个或更多的 `filter()` 呢？这不会意味着更少的代码和更快的执行吗？真正的优势在于阅读和修改此代码。我们想看到当我们移除启用的过滤器时会发生什么吗？只需注释掉该行即可。可读性和可维护性几乎总是应该优于从复杂的回调函数中挤压性能的尝试。当然，这里有一些例外，但不要为了性能而发明性能问题。
- en: Combining filter() with where()
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 filter() 与 where() 结合使用
- en: 'The `where()` function is an expressive means to filter a collection using
    logical `and` conditions. Rather than trying to express all of your query constraints
    in a single `filter()` callback function, why not utilize the `where()` notation
    where it makes sense? Let''s see this in action:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`where()` 函数是一种表达性很强的过滤集合的方法，使用逻辑 `and` 条件。与其试图在一个 `filter()` 回调函数中表达所有的查询约束，为什么不利用
    `where()` 语法在合适的地方呢？让我们看看它是如何工作的：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This filter will include all female items and is a good candidate for the `where()`
    function. Next, we'd like to make sure that all items have an `age` property whose
    value is a finite number. We do this by composing a callback function that's passed
    to `filter()`. We're utilizing a couple of shortcuts here instead of defining
    our own inline callback function. The `flow()` function will construct a function
    for us, letting the result flow to each function argument we give it. We use the
    `property()` function to build a function that gets us the `age` property for
    each item, and gets passed to the `isFinite()` function. There are a couple of
    items in our collection that don't have `age` properties. These undefined values
    don't pass the test and are filtered out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器将包括所有女性项目，并且是 `where()` 函数的良好候选者。接下来，我们想确保所有项目都有一个 `age` 属性，其值是一个有限数字。我们通过将一个回调函数传递给
    `filter()` 来做到这一点。在这里，我们使用了一些快捷方式，而不是定义自己的内联回调函数。`flow()` 函数将为我们构造一个函数，让结果流向我们给出的每个函数参数。我们使用
    `property()` 函数构建一个函数，获取每个项目的 `age` 属性，并将其传递给 `isFinite()` 函数。在我们的集合中，有几项没有 `age`
    属性。这些未定义的值未通过测试，并被过滤掉。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The ordering of chained filter functions can be important. For example, it's
    wise to filter broadly first. That way, your collection shrinks in size faster
    as it flows through the pipeline, which means less work for other functions. Where
    this matters isn't immediately apparent, but as your code matures, you'll start
    to notice ordering tweaks. The nice thing about chained structures in your code
    is that order changes are trivial.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 连锁过滤函数的顺序可能很重要。例如，首先进行广泛过滤是明智的。这样，当集合通过管道流动时，它会更快地缩小规模，这意味着其他函数的工作量更少。在哪里这很重要并不立即明显，但随着你的代码成熟，你将开始注意到排序调整。代码中连锁结构的优点是，顺序更改是微不足道的。
- en: Dropping and taking collection items
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除和获取集合项目
- en: 'Lo-Dash has tools that let us filter collections from either the beginning
    or the end of a collection. These tools are especially useful in the context of
    function call chains, since using them usually depends on a prior transformation
    of the collection. For example, consider the sort order in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 有工具可以让我们从集合的开始或结束处过滤集合。这些工具在函数调用链的上下文中特别有用，因为使用它们通常取决于集合的先前转换。例如，考虑以下代码中的排序顺序：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first call in this chain sorts the collection by the `first` property using
    the `sortBy()` function. Now that the collection is sorted, we can call `dropWhile()`.
    Starting from the left-hand side, this function drops items from the collection
    until the callback returns `true`. Our particular callback gets the first character
    of the name string, and if it is less than `F`, we drop it. This leaves us with
    a collection that only has first names starting with `F` and above.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个链中的第一个调用使用 `sortBy()` 函数根据 `first` 属性对集合进行排序。现在集合已经排序，我们可以调用 `dropWhile()`。从左侧开始，这个函数会从集合中删除项目，直到回调返回
    `true`。我们的特定回调获取名字字符串的第一个字符，如果它小于 `F`，我们就删除它。这使我们只剩下一个只包含以 `F` 开头及以上的名字的集合。
- en: 'In addition to dropping items from the left-hand side of the collection, we
    can drop items from the right-hand side. Alternatively, we can combine the two
    approaches using a chain, as shown in the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从集合的左侧删除项目外，我们还可以从右侧删除项目。或者，我们可以使用链结合两种方法，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we're wrapping a string value instead of an array, emulating the functionality
    of `String.trim()`. So the first task for our chain is to use `toArray()` to split
    the string into individual characters. The drop functions expect an array. Next,
    we use the `dropWhile()` function and pass it our `emptyString()` callback function.
    This will drop characters from the string until it finds an actual character.
    It then uses `dropRightWhile()` to perform the same task but from the opposite
    side of the array, moving in the opposite direction. Lastly, we join the array
    back together as a string, minus the empty characters that have been dropped from
    either end.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包裹的是一个字符串值而不是一个数组，模拟了`String.trim()`的功能。因此，我们链的第一个任务就是使用`toArray()`将字符串拆分为单个字符。`drop`函数期望一个数组。接下来，我们使用`dropWhile()`函数并传递它我们的`emptyString()`回调函数。这将从字符串中删除字符，直到找到实际字符。然后使用`dropRightWhile()`从数组的另一端执行相同的任务，但方向相反。最后，我们将数组重新组合成一个字符串，去掉两端被删除的空字符。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Yes, you can get the same result using a regular expression and condensed code.
    Regular expressions are great, but they're not for everyone, and they only work
    with strings. Weigh your options before going in either direction.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以使用正则表达式和压缩代码得到相同的结果。正则表达式很棒，但它们不是为每个人而设计的，并且它们只适用于字符串。在采取任何方向之前权衡你的选项。
- en: 'We can perform the inverse of dropping items from either end of an array. We
    can take items, thus dropping everything else. For example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行从数组的两端删除项目的逆操作。我们可以取项目，从而删除其他所有内容。例如：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're only interested in items with `A` grades. The callback function we're
    using with `takeWhile()` returns `true` for items that have an `A`. Of course,
    this only works because the first step in the chain was to sort the array by the
    `grade` property. Had we not done that first, we would end up missing the items
    we're looking for.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对具有`A`等级的项目感兴趣。我们与`takeWhile()`一起使用的回调函数对具有`A`的项目返回`true`。当然，这仅因为链中的第一步是按`grade`属性对数组进行排序。如果我们没有先做这一步，我们就会错过我们正在寻找的项目。
- en: 'Items can also be taken from the collection in the opposite direction. That
    is, instead of moving from left to right, we move from right to left. This is
    ideal when ordering is important and you don''t want to perform additional steps
    to take what you need from the collection. This ordering is shown in the following
    code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 项目也可以从集合中以相反的方向取出。也就是说，我们不是从左到右移动，而是从右到左移动。这在排序很重要且你不想执行额外的步骤来从集合中取出所需项目时很理想。这种排序在下面的代码中显示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The collection used here is a random sampling of 10 integers. The first call
    in our chain is to `sortBy()`, which simply sorts the array with no arguments
    supplied. This is in ascending order and we want the top five items. We could
    have reversed the sort order, but instead, we're skipping that step and jumping
    right into the `takeRightWhile()` function. The callback used here will return
    numbers as long as the number is larger than `min` and as long as we haven't exceeded
    the total.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的集合是10个整数的随机抽样。我们链中的第一次调用是`sortBy()`，它只是简单地按无参数提供的数组进行排序。这是升序的，我们想要前五个项目。我们本可以反转排序顺序，但相反，我们跳过了这一步，直接进入`takeRightWhile()`函数。这里使用的回调函数将返回大于`min`的数字，并且只要我们没有超过总数。
- en: Rejecting items
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拒绝项目
- en: 'Rejecting works much in the same way as filtering does. In the case of filtering,
    you know what you want. In the case of rejecting, you know what you don''t want.
    These rejection operations can be chained together to build complex queries, as
    shown in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝操作与过滤操作非常相似。在过滤的情况下，你知道你想要什么。在拒绝的情况下，你知道你不需要什么。这些拒绝操作可以链接在一起来构建复杂的查询，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we're chaining together two `reject()` calls. The wrapped value is an object
    and we're only after those property values that aren't Booleans or strings. These
    functions—`isBoolean()` and `isString()`—already exist as a part of the Lo-Dash
    API, and we can just pass them directly to `reject()`. There's no need to write
    our own callback functions here.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将两个`reject()`调用链在一起。包装的值是一个对象，我们只关心那些不是布尔值或字符串的属性值。这些函数——`isBoolean()`和`isString()`——已经作为Lo-Dash
    API的一部分存在，我们可以直接将它们传递给`reject()`。在这里没有必要编写我们自己的回调函数。
- en: 'We can use the `result()` function to help us reject collection items in a
    chain. The `result()` function works in the same way, whether the specified property
    value is a function or a non-callable value. Here''s an illustration of the differences
    in calling `reject()` using `result()` or just a property name:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`result()`函数帮助我们链式拒绝集合项。`result()`函数无论指定的属性值是函数还是不可调用值，其工作方式都是相同的。以下是使用`result()`或仅使用属性名调用`reject()`时的差异说明：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `User` instances have a `disabled` property, and the `enabled()` method
    returns `true` if `disabled` is false. The `collection` variable holds an array
    of these `User` instances. The `enabled()` function is something we construct
    ourselves. We'll use it as a callback with `reject()`. This function uses `result()`
    to get the `enabled()` value from each item in the collection. The `identity()`
    function is used here as a trick to get `partialRight()` to work as a callback
    for `reject()`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`实例有一个`disabled`属性，如果`disabled`为`false`，则`enabled()`方法返回`true`。`collection`变量包含这些`User`实例的数组。`enabled()`函数是我们自己构建的。我们将将其用作`reject()`的回调。这个函数使用`result()`从集合中的每个项获取`enabled()`值。在这里，`identity()`函数被用作一个技巧，以便让`partialRight()`作为`reject()`的回调工作。'
- en: Using initial() and rest()
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用initial()和rest()
- en: 'The `initial()` function takes everything but the last element—this can be
    combined with chained operations in interesting ways. For example, let''s say
    we have a simple string we need to clean up:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`initial()`函数获取除了最后一个元素之外的所有元素——这可以通过链式操作以有趣的方式结合使用。例如，假设我们有一个需要清理的简单字符串：'
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we know the string is always going to end with something we don't care about,
    this is an easy way to drop that off. The same code works with arrays too; we're
    not limiting ourselves to strings. For example, the `slice()` function is a part
    of the chain and it makes the chain work with strings. If we passed an array,
    `slice()` wouldn't have any impact—the same code would still work. However, we
    might want to remove it later on, along with the `join()` call. Given the way
    our chain code is formatted, this is simple to do.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道字符串总是以我们不关心的内容结束，这是一个很容易将其删除的方法。相同的代码也适用于数组；我们并没有将范围限制在字符串上。例如，`slice()`函数是链式操作的一部分，它使链式操作能够与字符串一起工作。如果我们传递一个数组，`slice()`将没有任何影响——相同的代码仍然有效。然而，我们可能希望在稍后删除它，以及`join()`调用。鉴于我们的链式代码的格式，这很简单。
- en: 'The inverse of `initial()` is `rest()`—it takes everything in the array but
    the first item. Just like the case in which we don''t care about the last item,
    there could be cases where we don''t care about the first item. An illustration
    of using `rest()` is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`initial()`的逆操作是`rest()`——它获取数组中的所有元素，除了第一个元素。就像我们不在乎最后一个元素的情况一样，也可能有不关心第一个元素的情况。以下是如何使用`rest()`的示例：'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This collection has objects with `task()` methods. The collection is ordered,
    so the first task is always going to be the `init` task, which we don't care about
    because it's a `noop()` function. We test this by chaining `invoke()` to the `rest()`
    function, which if all goes well, we should end up with an array of random numbers,
    and no undefined values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合包含具有`task()`方法的对象。集合是有序的，所以第一个任务总是`init`任务，我们对此不感兴趣，因为它是一个`noop()`函数。我们通过将`invoke()`方法链接到`rest()`函数来测试这一点，如果一切顺利，我们应该得到一个随机数字数组，并且没有未定义的值。
- en: Testing truth conditions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试真值条件
- en: Beyond simply filtering collections, you often need to test a condition of a
    collection. This could include filtering a collection, and then answering a simple
    yes/no about the results. In those cases where you need to check a truth condition
    of a collection, it's often easier to perform the test at the end of a chain.
    There's usually no need to write several statements and allocate several variables
    along the way.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单地过滤集合外，你通常还需要测试集合的条件。这可能包括过滤一个集合，然后对结果进行简单的肯定/否定回答。在需要检查集合的真值条件的情况下，通常在链式操作的最后进行测试会更简单。通常没有必要在过程中编写多个语句和分配多个变量。
- en: Testing if a collection contains an item
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试集合是否包含项目
- en: 'Perhaps, the most straightforward test we can perform is whether or not a collection
    contains an item we''re looking for. The `contains()` function is handy in cases
    like these because it is easy to attach to the end of a chain that''s performing
    some other operations beforehand. One use of `contains()` is shown in the following
    example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，最直接的测试就是检查一个集合是否包含我们正在寻找的项目。在这种情况下，`contains()`函数很有用，因为它可以轻松地附加到执行其他操作之前的链的末尾。以下是一个`contains()`函数用法的示例：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are two collections in the code—a string and an array. Both chains that
    follow are identical, aside from wrapping different values. However, both return
    `true` in this case, since the string has `c` and so does the array.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中有两个集合——一个字符串和一个数组。接下来的两个链在除了包装不同的值之外都是相同的。然而，在这种情况下，两者都返回`true`，因为字符串中有`c`，数组中也有。
- en: It's always good practice to use functions such as `contains()` if all you care
    about is testing for the item's existence. These functions will stop looping early,
    or short-circuit, if a value is found, saving valuable CPU cycles.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只关心测试项目是否存在，那么使用`contains()`等函数总是一个好习惯。如果找到值，这些函数会提前停止循环，或者短路，从而节省宝贵的CPU周期。
- en: 'Often, you don''t have the exact value. Instead you have query constraints
    but you''re still only interested in whether they''re satisfied, and not the data
    itself. This can be accomplished using the `find()` and `filter()` methods:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你并不拥有确切的值。相反，你只有查询约束，但你仍然只对它们是否满足感兴趣，而不是数据本身。这可以通过使用`find()`和`filter()`方法来实现：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first chain in this code is for a string value. Notice how we've used `chain()`
    here to enable explicit chaining—meaning we'll have to explicitly call `value()`
    at the end to unwrap the result. The `filter()` call here returns items that match
    `A`. We do this so that we can count how many of them there are in the chain.
    In this case, the string passes the test because there are two `A` characters.
    The downside is that we're looking for an exact number—`2`. The `filter()` function
    will keep filtering away long after we've found two items.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的第一个链是针对字符串值的。注意我们在这里使用了`chain()`来启用显式链式调用——这意味着我们最终必须显式调用`value()`来展开结果。这里的`filter()`调用返回匹配`A`的项。我们这样做是为了计算链中这些项的数量。在这种情况下，字符串通过了测试，因为有两个`A`字符。缺点是我们寻找的是一个确切的数字——`2`。`filter()`函数会在找到两个项目之后继续过滤。
- en: The second chain uses a wrapped array. Here we're transforming the result of
    calling `find()` into a Boolean value. Here we're able to use more elaborate query
    conditions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个链使用了一个包装数组。在这里，我们将调用`find()`的结果转换为一个布尔值。在这里，我们可以使用更复杂的查询条件。
- en: Everything or anything is true
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何事物或任何东西都是真实的
- en: 'Our final look at checking truth conditions in this chapter involves validating
    either one item at least or the collection in its entirety. That is, a collection
    might be considered valid if one or more items pass the test we give it. Or perhaps
    the requirements are more stringent and every item in the collection must pass
    the test in order to be considered valid. Let''s see how these tests can be used
    in chains:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后关于检查真值条件的探讨，包括验证至少一个项目或整个集合的有效性。也就是说，如果一个或多个项目通过了我们所设定的测试，那么这个集合可能被认为是有效的。或者，也许要求更为严格，集合中的每个项目都必须通过测试才能被认为是有效的。让我们看看这些测试如何在链中使用：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This collection contains timestamp numbers, and so the first call in the chain
    is to `map()`, transforming each collection item into a `Date` instance. Now that
    every item is a date, we can use `every()` to validate that in this collection,
    every day is Halloween.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合包含时间戳数字，因此链中的第一个调用是`map()`，将每个集合项转换为`Date`实例。现在每个项都是日期，我们可以使用`every()`来验证在这个集合中，每一天都是万圣节。
- en: 'Now let''s look at using the `some()` function to terminate a chain. This will
    validate that at least one item passes the test and will stop looping as soon
    as one is found:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`some()`函数来终止链。这将验证至少有一个项目通过了测试，并且一旦找到就会停止循环：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see that after rejecting `Ember` and `Angular` enthusiasts, we make
    sure that there's at least one `Backbone` or `Marionette` programmer who is at
    least `25` years old.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在拒绝`Ember`和`Angular`爱好者之后，我们确保至少有一位`25`岁以上的`Backbone`或`Marionette`程序员。
- en: Counting items
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数项目
- en: A variation on the previous topic—*Testing truth conditions*—is counting items
    in a collection after their values have moved through a processing chain. For
    example, we might need to know how many items in a collection meet the given criteria.
    We can get that number using a call chain.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前主题的一个变体——*测试真值条件*——是在它们的值通过处理链移动后，在集合中计数项。例如，我们可能需要知道集合中有多少项满足给定的条件。我们可以使用调用链来获取那个数字。
- en: Using length and size()
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用长度和大小()
- en: 'The `size()` function is handy because we can call it directly on a Lo-Dash
    wrapper. This is the preferred way to count the resulting items in our collection
    after our chain runs:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`size()`函数很方便，因为我们可以直接在Lo-Dash包装器上调用它。这是我们链式操作运行后，在我们的集合中计数结果项的首选方式：'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have `array` and `object`. The first chain uses the `size()` function
    to count the number of properties after omitting the `first` property. The second
    chain wraps the array and, after dropping `5` items, counts what's left.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`数组`和`对象`。第一个链使用`size()`函数来计算在省略了`first`属性之后属性的数量。第二个链包裹了数组，并在删除`5`个项目之后计算剩余的项目数量。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can use the `length` property, but we have to call `value()` first. Using
    `size()` is just a shortcut.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`length`属性，但我们必须先调用`value()`。使用`size()`只是一个快捷方式。
- en: Grouping using countBy()
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用countBy()进行分组
- en: 'We can also count more than one item. That is, given a collection, we can divide
    it into groups and then count the number of items in each group. Using chains,
    we can write some fairly sophisticated code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以计数多个项。也就是说，给定一个集合，我们可以将其分成组，然后计算每个组中的项目数量。使用链，我们可以编写一些相当复杂的代码：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This chain kicks off by grouping the collection by the `gender` property. Next,
    we use the `pairs()` function to get an array of arrays. We do this so that we
    can sort the groups by the number of items in them. With the collection sorted,
    we can pluck the values we're interested in. In this case, the `f` gender is first
    since that group has a higher count.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链通过按`gender`属性对集合进行分组开始。接下来，我们使用`pairs()`函数获取一个数组的数组。我们这样做是为了能够按组中的项目数量对组进行排序。在集合排序后，我们可以提取我们感兴趣的价值。在这种情况下，`f`性别是第一个，因为那个组有更高的计数。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code uses two interesting tricks. Firstly, we're passing a numerical
    index to the `sortBy()` function. Since keys are accessed in the same way as indices,
    this works as expected. Secondly, we're passing a numerical index to the `pluck()`
    function and this works for the same reason as the `sortBy()` function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了两个有趣的技巧。首先，我们向`sortBy()`函数传递一个数值索引。由于键的访问方式与索引相同，所以这按预期工作。其次，我们向`pluck()`函数传递一个数值索引，这与`sortBy()`函数的原因相同。
- en: Reducing collections
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少集合
- en: 'Our final approach to counting items in chaining operations is to reduce the
    collection. This is useful when you want to reduce the entire collection to a
    sum computed using more involved functions that are applied to each item. Collections
    can be reduced with the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在链式操作中计数项的最终方法是减少集合。当你想要将整个集合减少为一个使用更复杂的函数计算得出的总和时，这很有用，这些函数应用于每个项目。可以使用以下代码减少集合：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we''re plucking the `skills` property from each item in the collection.
    We''re interested in knowing two things about the `skills` value: does it contain
    the string `grunt`? And does it have more than `2` items? If these criteria are
    met, then we increment the reduced sum value that''s returned by the `reduce()`
    call.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在从集合中的每个项目中提取`skills`属性。我们对`skills`值感兴趣的两个问题是：它是否包含字符串`grunt`？并且它是否有超过`2`个项？如果这些条件得到满足，那么我们就增加由`reduce()`调用返回的减少的总值。
- en: Transformations
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: Now it's time for us to look at transformations that happen to data as it passes
    through the processing pipelines we construct. What's interesting about Lo-Dash
    and how it transforms data in chains is that the original collection isn't modified—a
    new one is constructed. This reduces side effects and is fundamental to the immutability
    concept in other functional programming languages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看数据通过我们构建的处理管道时发生的转换。Lo-Dash和它在链中转换数据有趣的地方在于原始集合没有被修改——而是构建了一个新的集合。这减少了副作用，并且是其他函数式编程语言中不可变概念的基础。
- en: Building groups, unions, and unique values
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建组、并集和唯一值
- en: 'Some of the most powerful transformation tools found in Lo-Dash can be used
    out of the box with very little effort. These include grouping collection items
    by a specific value they contain, joining arrays together while retaining only
    unique values, and removing any duplicates from arrays. For example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lo-Dash中找到的一些最强大的转换工具可以无需太多努力即可直接使用。这包括根据它们包含的特定值对集合项进行分组、在保留唯一值的同时将数组连接起来，以及从数组中移除任何重复项。例如：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This chain wraps a collection of plain objects, and the first call in the chain
    maps the `item` object to an extended version of it. We're calculating a string
    version of their `experience` property and assigning that to a new property. Next,
    we use the `groupBy()` function to group the collection by this new `experience`
    property. The last step in this chain is to use `map()` again to generate a string
    representation of the various experience groups.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链式操作封装了一个普通对象的集合，链式操作中的第一次调用将`item`对象映射为其扩展版本。我们正在计算它们的`experience`属性的字符串版本，并将其分配给一个新的属性。接下来，我们使用`groupBy()`函数根据这个新的`experience`属性对集合进行分组。链式操作的最后一个步骤是再次使用`map()`来生成各种经验组的字符串表示。
- en: 'Using `union()` to join arrays together can come in handy if you''ve already
    got a wrapped array and you need to ensure it has certain values, but also ensure
    that those values aren''t duplicated. The application of `union()` is shown in
    the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`union()`函数连接数组可能很有用，如果你已经有一个封装的数组，并且需要确保它具有某些值，同时确保这些值不重复。`union()`函数的应用在以下示例中显示：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see that our wrapped array, a sampling of 10 random numbers, is joined
    with another array using the `union()` function. We then return the sorted result.
    If you examine the output, you'll notice it'll always have `25`, `50`, and `75`.
    You'll also notice that these numbers are never duplicated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的封装数组，10个随机数的样本，使用`union()`函数与另一个数组连接。然后我们返回排序后的结果。如果你检查输出，你会注意到它总是会包含`25`、`50`和`75`。你也会注意到这些数字永远不会重复。
- en: 'Finally, if you have a collection of values and you just need the duplicates
    removed, the `uniq()` function allows you to do that as a step in your chained
    processing:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你有一个值集合，并且只需要移除重复项，`uniq()`函数允许你在链式处理中执行此操作：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We're seeing three different approaches to extracting the unique values from
    the wrapped collection. The first uses the pluck-style shorthand to filter out
    duplicates. Since we passed it the string `last`, it'll look for unique values
    in this property. The second approach passes in a callback function, which joins
    together the `first` and the `last` name properties. Note that this same function
    is used by the `sortBy()` call in the same chain. The last approach doesn't pass
    any arguments to `uniq()` because the first step in the chain maps our array of
    objects to an array of strings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了从封装集合中提取唯一值的三种不同方法。第一种使用提取风格的简写来过滤重复项。由于我们传递了字符串`last`，它将在这个属性中查找唯一值。第二种方法传递了一个回调函数，该函数将`first`和`last`名称属性连接起来。请注意，这个相同的函数在同一个链式操作中的`sortBy()`调用中也被使用。最后一种方法没有向`uniq()`传递任何参数，因为链式操作的第一步将我们的对象数组映射为字符串数组。
- en: Plucking values
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取值
- en: 'Often, within your chains of functionality, you''ll realize that you don''t
    need the entirety of every object in your collection. This can make what you''re
    doing later on in the chain much simpler. To pluck values, the following code
    can be used:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在你的功能链中，你会意识到你不需要你的集合中每个对象的全部内容。这可以使链式操作中后续的操作变得更加简单。为了提取值，可以使用以下代码：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we're plucking the `dob` property values and this simplifies the `map()`
    handler that follows in the chain. Instead of having to look up the `dob` property,
    the item itself is the `dob` property value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在提取`dob`属性值，这简化了链式操作中后续的`map()`处理程序。无需查找`dob`属性，项目本身就是`dob`属性值。
- en: Creating arrays using without()
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`without()`函数创建数组
- en: 'If we need a new array constructed and there are certain values we know should
    not be present as items, we can use the `without()` function. This is typically
    the first action in a chain, since it creates a new array, but it''s not always
    the first. Let''s see an example of this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要构建一个新的数组，并且我们知道某些值不应作为项目出现，我们可以使用`without()`函数。这通常是链式操作中的第一个动作，因为它创建了一个新的数组，但并不总是第一个。让我们看看这个例子：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The wrapped collection in this code includes the numbers `1` through `10`. The
    first call in our chain copies the items out of this array and places them in
    a new array, aside from the argument values passed to the `without()` function.
    These are not included in the new array.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，包装的集合包括从`1`到`10`的数字。我们链中的第一次调用将此数组中的项目复制出来，并将它们放置在一个新的数组中，除了传递给`without()`函数的参数值。这些值不包括在新数组中。
- en: Finding the min and max values
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到最小和最大值
- en: 'With every collection, there''s a minimum and a maximum value. Finding these
    values with Lo-Dash is easy; you just have to use the respective `min()` and `max()`
    functions. But what if you need to adjust the range for which you''re seeking
    out the minimum values? Let''s use the following code to perform this task:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合都有一个最小值和最大值。使用Lo-Dash找到这些值很容易；你只需要使用相应的`min()`和`max()`函数。但如果你需要调整你正在寻找的最小值的范围呢？让我们使用以下代码来完成这个任务：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we're not concerned with items that have a `win` count of less
    than `5`. So we know that the absolute minimum returned by this code will have
    `5` wins or more. After the invalid `win` counts have been rejected, we use the
    pluck style shorthand to find the minimum value based on the `wins` property.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们并不关心具有小于`5`次`win`计数的项目。因此，我们知道此代码返回的绝对最小值将至少有`5`次胜利。在拒绝无效的`win`计数后，我们使用pluck风格简写来根据`wins`属性找到最小值。
- en: 'The `max()` function can be used as a chain operation in a similar fashion:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`函数可以以类似的方式用作链式操作：'
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This collection has objects with the `balance` and `credit` properties. The
    first two chain operations use the `filter()` function to remove objects where
    either of these fields is false. The `max()` function then closes the chain. This
    time, we're using a callback function that allows us to map the values we want
    to compare in order to figure out the maximum value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此集合包含具有`balance`和`credit`属性的对象。前两个链式操作使用`filter()`函数删除这些字段任一为假的对象。然后`max()`函数关闭链式操作。这次，我们使用一个回调函数，允许我们映射我们想要比较的值，以便确定最大值。
- en: Finding the index
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到索引
- en: 'Finding the index of a given element has its uses, and we can apply the `index()`
    function as a step in a call chain:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 找到给定元素的索引有其用途，我们可以在调用链中应用`index()`函数：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `rank()` function in this code accepts a `collection` argument and a `name`
    string. The function wraps the collection and uses a call chain to figure out
    the rank of the passed-in name, based on the `score` property. The first step
    is to sort the collection and then to reverse it so that it's in descending order
    based on the `score` property value. Next, we pluck the names from the collection,
    using the `pluck()` function, which maintains the sort order we just created.
    Now we can use `indexOf()` to figure out the rank of the given user.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中的`rank()`函数接受一个`collection`参数和一个`name`字符串。该函数包装集合，并使用调用链根据`score`属性确定传入名称的排名。第一步是对集合进行排序，然后将其反转，使其根据`score`属性值降序排列。接下来，我们使用`pluck()`函数从集合中提取名称，该函数保持我们刚刚创建的排序顺序。现在我们可以使用`indexOf()`来确定给定用户的排名。
- en: Using difference() and xor()
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用difference()和xor()
- en: 'The last section of the transformations topic is using the `difference()` and
    the `xor()` functions to merge together the contents of two arrays. Both work
    similarly but with subtle differences that are worth noting and paying attention
    to. These functions are useful at the start of chains where you have to make sure
    that the wrapped array has only the necessary values. For example, let''s say
    your array of numbers shouldn''t have any odd values. Then we can use the following
    code for this condition:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 变换主题的最后一部分是使用`difference()`和`xor()`函数合并两个数组的内容。这两个函数工作方式相似，但有一些细微的差别值得注意和关注。这些函数在链式操作的开始处非常有用，确保包装的数组只包含必要的值。例如，假设你的数字数组不应该有任何奇数。然后我们可以使用以下代码来满足这个条件：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our collection in this code consists of `50` numbers and the `odds` array contains
    odd numbers from `1` to `100`. Our chain starts off by calling the `difference()`
    function, passing in the `odds` array as an argument. Next, we take the top 10
    items from the resulting array and sort them. The thing to notice about the result
    is that there are no values above 50 present. We''ve removed all odd numbers below
    50, since that is the difference between the wrapped array and the array that
    was supplied as an argument. In other words, it''s not a symmetrical difference.
    For that, we would use the `xor()` function in our chain:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们的集合由`50`个数字组成，而`odds`数组包含从`1`到`100`的奇数。我们的链首先通过调用`difference()`函数开始，将`odds`数组作为参数传入。接下来，我们从结果数组中取出前10个元素并对其进行排序。要注意的是，结果中没有超过`50`的值。我们已经移除了所有低于`50`的奇数，因为这是包装数组与作为参数提供的数组之间的差。换句话说，这不是对称差。为此，我们会在链中使用`xor()`函数：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This time, our collection is an array of numbers from `1` to `25` and the `evens`
    array holds even numbers from `2` to `50`. We're using the `xor()` function in
    our chain to join the collection with the `evens` array. The difference between
    this and the `difference()` function is that it'll include all the values in the
    `evens` array that go beyond `25`, since `xor()` will compute the symmetrical
    difference.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的集合是一系列从`1`到`25`的数字，而`evens`数组则包含从`2`到`50`的偶数。我们在链中使用`xor()`函数将集合与`evens`数组连接起来。与`difference()`函数的区别在于，它将包括`evens`数组中超过`25`的所有值，因为`xor()`将计算对称差。
- en: Intermediary results
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间结果
- en: There are times when we don't want to wait until the call chain is terminated
    to have access to values computed at any given step along the way. Think about
    cases where the intermediate value produced by a function in the chain should
    be used by another function later in the chain. On other occasions, we need to
    completely override the value returned by the chain.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们不想等到调用链完成才访问在某个步骤计算出的值。考虑一下链中某个函数产生的中间值应该被链中稍后的另一个函数使用的情况。在其他情况下，我们需要完全覆盖链返回的值。
- en: Tapping into chains
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵链
- en: 'We can use the `tap()` function to inject our own callback function into the
    chain. This is different from the callbacks that we''d supply to other Lo-Dash
    functions. It doesn''t alter the value as it flows through the chain of function
    calls. Instead, think of `tap()` as a way of intercepting values as they flow
    through the chain, and possibly reacting to them in some way. Let''s see an example
    of this function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`tap()`函数将我们自己的回调函数注入链中。这与提供给其他Lo-Dash函数的回调不同。它不会改变值在函数调用链中流动时的值。相反，将`tap()`视为拦截值流经链的方式，并可能以某种方式对其做出反应。让我们看看这个函数的例子：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code wraps our collection and filters out items younger than 30\. Next,
    we use a `tap()` callback to set up our `min` and `max` variables. Note the scope
    of these variables; they're defined outside the chain, and are thus accessible
    to any future callbacks in the chain. And that's what we're doing here—we're rejecting
    any items where the `age` property equals the `max` age found. Note that the `max`
    value could turn out differently had we not computed it after the first filter
    in the chain.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将我们的集合包装起来，并过滤掉年龄低于30岁的项。接下来，我们使用`tap()`回调来设置我们的`min`和`max`变量。注意这些变量的作用域；它们是在链外部定义的，因此可以访问链中任何未来的回调。这正是我们在这里所做的——我们拒绝任何`age`属性等于找到的最大年龄的项。注意，如果没有在链的第一个过滤器之后计算它，`max`值可能会有所不同。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The only downside to this approach is that our chain is no longer a tightly
    encapsulated unit that can be moved around in our code. However, the trade-off
    is that we can elegantly compute the values needed for our chain on the fly. Something
    to keep in mind anyway, different programming styles may lean closer to one direction
    than others.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的唯一缺点是，我们的链不再是紧密封装的单元，不能在代码中移动。然而，这种权衡是我们可以优雅地即时计算链所需的值。无论如何，要注意的是，不同的编程风格可能更倾向于一个方向而不是另一个方向。
- en: Injecting values
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入值
- en: 'The other approach to manipulating what chains return at runtime is by using
    the `thru()` function. It behaves just like `tap()` but whatever is returned by
    this function becomes the new value:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 操作链在运行时返回的内容的另一种方法是使用`thru()`函数。它的工作方式与`tap()`类似，但这个函数返回的任何内容都成为新的值：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This chain is kicked off using the `thru()` function callback to validate the
    minimum size of the collection. If it is less than `5`, we don't even have to
    bother—we just return an empty array. It's important that we return something
    that'll work with the remaining chained functions, and an empty array fits the
    bill nicely. We're simply using `thru()` to state that any length less than `5`
    should have the same meaning as an empty array. This function is actually an ideal
    place in which to inject these nuanced business rules that often surface well
    after code is written.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链式操作是通过使用`thru()`函数回调来启动的，以验证集合的最小大小。如果它小于`5`，我们甚至不需要麻烦——我们只需返回一个空数组。返回一些可以与剩余链式函数一起使用的东西很重要，而空数组非常适合。我们只是使用`thru()`来声明任何小于`5`的长度应该与空数组具有相同的意义。这个函数实际上是一个注入这些细微业务规则的理想位置，这些规则通常在代码编写后很久才会显现出来。
- en: Keys and values
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键和值
- en: Now it's time to turn our attention to object keys and values and how they can
    be used in function call chains. Often, these involve wrapping a plain object
    in a Lo-Dash instance and then using the `keys()` or `values()` functions to bootstrap
    the processing. There are also times when you have a collection of objects and
    you want to work with certain property values only. For this purpose, there are
    the `pick()` and `omit()` functions that can be exercised in chains.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的注意力转向对象键和值，以及它们如何在函数调用链中使用。通常，这些涉及将一个普通对象包装在Lo-Dash实例中，然后使用`keys()`或`values()`函数来启动处理。也有时候，你有一组对象，只想处理某些属性值。为此，有`pick()`和`omit()`函数可以在链中使用。
- en: Filtered keys and values
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤后的键和值
- en: 'We can use the result of a filtered array of object keys at a later point in
    the chain. This comes in handy when we''re not exactly sure which keys are available
    and we only have a best guess. Let''s try filtering by keys and values:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在链式操作中的后续步骤使用过滤后的对象键数组的结果。当我们不确定哪些键可用，只有最佳猜测时，这非常有用。让我们尝试通过键和值进行过滤：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The object we''re wrapping has two property names that end in `name`. So we
    use the `keys()` function as the first step in the chain to grab all keys, and
    then we filter out the ones that don''t end in `name`. Next, we use the `thru()`
    function to return the object property values that correspond to our key filter
    results. Similar actions can take place with object property values, especially
    when there''s not much need to use keys. Let''s look at an example of this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在包装的对象有两个以`name`结尾的属性名。因此，我们将`keys()`函数作为链式操作的第一步来抓取所有键，然后过滤掉不以`name`结尾的键。接下来，我们使用`thru()`函数返回与我们的键过滤结果相对应的对象属性值。对于对象属性值，也可以进行类似操作，尤其是在不需要使用键的情况下。让我们看看一个例子：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This chain grabs the property values of the wrapped object and filters out anything
    that's not a date. Then the `Date` objects found get mapped to an array of strings.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链式操作会抓取被包装对象的属性值，并过滤掉所有非日期的项。然后，找到的`Date`对象会被映射到一个字符串数组中。
- en: Omitting and picking properties
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略和选择属性
- en: 'Picking certain object properties to use, as well as those to omit, has its
    uses in chains, especially when the wrapped value is a plain object and based
    on some criteria, there are certain properties we don''t care to use. For example,
    we might have a collection that we want to transform into an indexed object, but
    along the way, we need to pick or omit values that should or shouldn''t be there,
    respectively, as shown in the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在链中挑选某些对象属性使用，以及那些要忽略的属性，有其用途，尤其是在包装的值是一个普通对象，并且基于某些标准，有一些属性我们不想使用时。例如，我们可能有一个想要转换成索引对象的集合，但在过程中，我们需要挑选或忽略某些应该或不应该存在的值，如下面的例子所示：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code indexes the array of objects by the `last` property value. The next
    step in the chain is to pick only items that have an `age` greater than `34`.
    Finally, since each item is indexed by the last name, we don't need the `last`
    property any more, so the `transform()` function uses `omit()` to get rid of it
    for each item, which is the last step in the chain.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过`last`属性值对对象数组进行索引。链式操作的下一步是只选择`age`大于`34`的项目。最后，由于每个项目都是通过姓氏索引的，我们不再需要`last`属性，因此`transform()`函数使用`omit()`来为每个项目移除它，这是链式操作的最后一个步骤。
- en: Returning wrappers
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回包装器
- en: 'Wrappers and the function call chains that follow don''t exist randomly throughout
    our code. The next chapter covers this topic in more depth, so consider this as
    a teaser. So far, we''ve only looked at chains as they''re constructed and executed
    in the same statement. However, if we''re going through all the trouble of designing
    a call chain that serves a general purpose, wouldn''t it be good not to keep assembling
    that chain? Let''s design the chain with the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器和随后的函数调用链并不是随机存在于我们的代码中的。下一章将更深入地探讨这个主题，所以这可以被视为一个预告。到目前为止，我们只看了链在同一个语句中构建和执行的情况。然而，如果我们费尽心思设计一个具有通用目的的调用链，那么不持续组装这个链不是更好吗？让我们用以下代码来设计这个链：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `best()` function defined here returns a Lo-Dash wrapper instance. Notice
    that inside `best()`, we're actually chaining together function calls but none
    of them are actually called, which means that the return value of `best()` is
    a wrapper. This is illustrated by the `bestScrore` variable, which holds a wrapper
    instance. This wrapper can be called again and again without the need to reconstruct
    the function call chain. Nevertheless, if we need to tweak the chain slightly,
    we can build on it. We're doing this with `bestScore` by calling `reverse()` and
    `pluck()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的 `best()` 函数返回一个 Lo-Dash 包装器实例。注意，在 `best()` 内部，我们实际上正在链式调用函数，但它们实际上并没有被调用，这意味着
    `best()` 的返回值是一个包装器。这可以通过 `bestScore` 变量来说明，它持有包装器实例。这个包装器可以一次又一次地被调用，而无需重新构建函数调用链。尽管如此，如果我们需要稍微调整链，我们可以在其基础上构建。我们通过调用
    `reverse()` 和 `pluck()` 来对 `bestScore` 进行这样的操作。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the concept of wrapped values and the function call
    chains applied to them. This versatile programming model, fundamental to Lo-Dash,
    assists in building complex chunks of functionality using compact and legible
    code. Chained calls aren't unique to Lo-Dash—they're popular in many other libraries,
    perhaps mostly so in jQuery.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了包装值的概念以及应用于它们的函数调用链。这种多才多艺的编程模型，是 Lo-Dash 的基础，有助于使用紧凑且易于阅读的代码构建复杂的功能块。链式调用并不仅限于
    Lo-Dash，它们在许多其他库中也很受欢迎，也许在 jQuery 中最为常见。
- en: Applications are faced with the tough job of filtering data—lots of data and
    lots of hard constraints. Instead of creating messy code with lots of temporary
    variables, we addressed several ways to construct complex filters using chains.
    After that, we looked at testing truth conditions using chains. These are like
    filters, except they don't return collection results but only truth statements
    expressed as Boolean values. We also looked at how to count items after they've
    moved through a function call chain.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序面临着过滤数据的艰巨任务——大量的数据和大量的硬约束。我们不是创建带有许多临时变量的混乱代码，而是提出了几种使用链构建复杂过滤器的方法。之后，我们探讨了使用链测试真值条件。这些就像过滤器一样，除了它们不返回集合结果，而是只返回表示为布尔值的真值陈述。我们还探讨了如何在函数调用链之后计数项目。
- en: Another fundamental practice we learned was transforming collections into alternative,
    more usable representations that better fit a given context. Like filtering, transforming
    collections is often better done using chains as it reduces the amount of code
    you have to write.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学到了另一个基本实践，那就是将集合转换成更适合特定上下文的替代、更易用的表示形式。就像过滤一样，使用链来转换集合通常更好，因为它减少了你需要编写的代码量。
- en: We closed the chapter with a look at how your functions can return wrappers
    that aren't necessarily executed immediately. This is the next step we take in
    building reusable Lo-Dash components, in the next chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以探讨你的函数如何返回不一定立即执行的包装器来结束本章。这是我们在下一章中构建可重用 Lo-Dash 组件的下一步。
