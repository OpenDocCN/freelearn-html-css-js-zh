- en: Advanced Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级技术
- en: In the previous chapters of this book, we covered many foundational computer
    graphics concepts that, ultimately, gave us the knowledge and skills to build
    a 3D virtual car showroom. This means that at this point, you have all of the
    information you need to create rich 3D applications with WebGL. However, we've
    only just scratched the surface of what's possible with WebGL! Creative use of
    shaders, textures, and vertex attributes can yield fantastic results. In these
    final chapters, we'll cover a few advanced WebGL concepts that should leave you
    eager to explore more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们介绍了许多计算机图形学的基础概念，这些概念最终为我们提供了构建3D虚拟汽车展台所需的知识和技能。这意味着，到目前为止，你已经拥有了创建丰富的3D应用程序所需的全部信息，使用WebGL。然而，我们只是刚刚触及了WebGL的表面！创意地使用着色器、纹理和顶点属性可以产生惊人的效果。在这些最后的章节中，我们将介绍一些高级的WebGL概念，这些概念应该会激发你进一步探索的欲望。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Learn various post-processing effects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习各种后处理效果
- en: Implementing a particle system using point sprites
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点精灵实现粒子系统
- en: Understand how to use normal mapping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用正常贴图
- en: Implement how to use ray tracing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现如何使用光线追踪
- en: Post-Processing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后处理
- en: '**Post-processing** is the process of adding effects by re-rendering the image
    of the scene with a shader that alters the final image. You can think of this
    as the process of taking a screenshot of your scene (ideally at `60+` frames per
    second), opening it up in your favorite image editor, and applying various filters.
    The difference is, of course, that we can do so in real time!'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**后处理**是通过使用一个改变最终图像的着色器重新渲染场景图像的过程。你可以将其想象成对场景进行截图（理想情况下每秒`60+`帧），然后在你的首选图像编辑器中打开它，并应用各种过滤器。当然，区别在于我们可以在实时中这样做！'
- en: 'Some examples of simple post-processing effects include the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单的后处理效果示例包括以下：
- en: Grayscale
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰度效果
- en: Sepia tone
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 褐色调
- en: Inverted colors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转颜色
- en: Film grain
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胶片颗粒效果
- en: Blur
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊效果
- en: Wavy/dizzy effect
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波浪/眩晕效果
- en: 'The basic technique for creating these effects is relatively simple: create
    a framebuffer with the same dimensions as the `canvas` and have the entire scene
    rendered to it at the beginning of the `draw` cycle. Then, a quad is rendered
    to the default framebuffer using the texture that makes up the framebuffer''s
    color attachment. The shader used during the rendering of the quad is what contains
    the post-process effect. That shader can transform the color values of the rendered
    scene as they get written to the quad to produce the desired visuals.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些效果的基本技术相对简单：创建一个与`canvas`尺寸相同的帧缓冲区，并在`draw`循环开始时将整个场景渲染到该缓冲区。然后，使用构成帧缓冲区颜色附件的纹理将一个四边形渲染到默认帧缓冲区。在四边形渲染过程中使用的着色器包含了后处理效果。该着色器可以将渲染场景的颜色值转换为四边形，以产生所需的视觉效果。
- en: Let's investigate the individual steps of this process more closely.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地研究这个过程的各个步骤。
- en: Creating the Framebuffer
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建帧缓冲区
- en: 'The code we will use to create the framebuffer is nearly the same as what we
    created earlier in [Chapter 8](b06d92d3-3687-476f-a181-e7dd3aac1b8f.xhtml), *Picking*. There
    are, however, a few key differences worth noting:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于创建帧缓冲区的代码几乎与我们在[第8章](b06d92d3-3687-476f-a181-e7dd3aac1b8f.xhtml)，“拾取”中创建的相同。然而，有一些关键的区别值得注意：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We use the `width` and `height` of the `canvas` to determine our buffer size,
    instead of using the arbitrary values that were used for the picker. Because the
    content of the picker buffer is not for rendering to the screen, we don't need
    to worry about resolution as much. For the post-process buffer, however, we'll
    get the best results if the output matches the dimensions of the `canvas`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`canvas`的`width`和`height`来确定我们的缓冲区大小，而不是使用用于拾取器的任意值。因为拾取器缓冲区的内容不是用于屏幕渲染，所以我们不必过多担心分辨率。然而，对于后处理缓冲区，如果输出与`canvas`的尺寸匹配，我们将获得最佳结果。
- en: Since the texture will be exactly the same size as the `canvas`, and since we're
    rendering it as a full-screen quad, we've created a situation where the texture
    will be displayed at exactly a `1:1` ratio on the screen. This means that no filters
    need to be applied and that we can use `NEAREST` filtering with no visual artifacts.
    Also, in post-processing cases where we want to warp the texture coordinates (such
    as the wavy effect), we would benefit from using `LINEAR` filtering. We also need
    to use a wrap mode of `CLAMP_TO_EDGE`. That being said, the code is nearly identical
    to the `Picker` we used for framebuffer creation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纹理将与`canvas`的大小完全相同，并且由于我们将其渲染为全屏四边形，我们创造了一个情况，即纹理将在屏幕上以`1:1`的比例显示。这意味着不需要应用任何过滤器，并且我们可以使用`NEAREST`过滤器而不会出现视觉伪影。此外，在需要扭曲纹理坐标的后处理情况下（例如波浪效果），我们会从使用`LINEAR`过滤器中受益。我们还需要使用`CLAMP_TO_EDGE`的包裹模式。话虽如此，代码几乎与用于帧缓冲区创建的`Picker`相同。
- en: Creating the Geometry
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建几何形状
- en: 'Although we could load the quad from a file, the geometry is simple enough
    that we can include it directly in the code. All that''s needed are the vertex
    positions and texture coordinates:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以从文件中加载四边形，但几何形状足够简单，我们可以直接将其包含在代码中。所需的所有内容只是顶点位置和纹理坐标：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Setting up the Shader
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置着色器
- en: 'The vertex shader for the post-process draw is quite simple:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 后处理绘制的顶点着色器相当简单：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that unlike the other vertex shaders we've worked with so far, this one
    doesn't use any matrices. That's because the vertices we declared in the previous
    step are **pre-transformed**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与迄今为止我们使用的其他顶点着色器不同，这个着色器没有使用任何矩阵。这是因为我们在上一步中声明的顶点已经**预变换**。
- en: Recall from [Chapter 4](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml), *Cameras, *that
    we retrieved normalized device coordinates by multiplying the vertex position
    by the Projection matrix. Here, the coordinates mapped all positions to a `[-1,
    1]` range on each axis, which represents the full viewport. In this case, however,
    our vertex positions are already mapped to a `[-1, 1]` range; therefore, no transformation
    is needed because they will map perfectly to the viewport bounds when we render.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第4章](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml)中提到的，我们通过将顶点位置乘以投影矩阵来检索归一化设备坐标。在这里，坐标将所有位置映射到每个轴上的`[-1,
    1]`范围，这代表了整个视口。然而，在这种情况下，我们的顶点位置已经映射到`[-1, 1]`范围；因此，不需要变换，因为当渲染时，它们将完美映射到视口边界。
- en: 'The fragment shader is where most of the interesting operations happen. The
    fragment shader will be different for every post-process effect. Let''s look at
    a simple **grayscale effect** as an example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器是大多数有趣操作发生的地方。每个后处理效果都会有不同的片段着色器。让我们以一个简单的**灰度效果**为例：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we sample the original color rendered by the scene (available
    through `uSampler`) and output a color that is a weighted average of the red,
    green, and blue channels. The result is a simple grayscale version of the original
    scene:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们采样场景渲染的原色（通过`uSampler`可用）并输出一个加权平均的红、绿、蓝通道的颜色。结果是原始场景的简单灰度版本：
- en: '![](img/d0e14317-62cd-42b0-9c74-edfff270a994.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0e14317-62cd-42b0-9c74-edfff270a994.png)'
- en: Architectural Updates
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建筑更新
- en: We've added a new class, `PostProcess`, to assist with the post-processing effects.
    This code can be found in the `common/js/PostProcess.js` file. This class will
    create the appropriate framebuffer and quad geometry, compile the post-process
    shader, and set up the render needed to draw the scene out to the quad.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的类，`PostProcess`，以帮助进行后处理效果。此代码位于`common/js/PostProcess.js`文件中。此类将创建适当的帧缓冲区和四边形几何形状，编译后处理着色器，并设置绘制场景到四边形的渲染。
- en: Let's see how this component works with an example!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看看这个组件是如何工作的！
- en: Time for Action: Post-Process Effects
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：后处理效果
- en: 'Let''s see a few post-processing effects in action:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些后处理效果的实际应用：
- en: 'Open the `ch10_01_post-process.html` file in your browser, like so:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`ch10_01_post-process.html`文件，如下所示：
- en: '![](img/2f595736-ad10-4585-b60e-27a2d09232b3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f595736-ad10-4585-b60e-27a2d09232b3.png)'
- en: The controls dropdown allows you to switch between different sample effects.
    Try them out to get a feel for the effects they have on the scene. We've already
    looked at grayscale, so let's examine the rest of the filters individually.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制下拉菜单允许您在不同的采样效果之间切换。尝试它们以了解它们对场景的影响。我们已经看到了灰度效果，所以让我们单独检查其余的过滤器。
- en: 'The **invert effect**, similar to grayscale in that it only modifies the color
    output, inverts each color channel:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反转效果**，类似于灰度效果，它只修改颜色输出，反转每个颜色通道：'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/b6c2a988-ed35-4c64-9093-11daeb61d673.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6c2a988-ed35-4c64-9093-11daeb61d673.png)'
- en: 'The **wavy effect **manipulates the texture coordinates to make the scene swirl
    and sway. In this effect, we also provide the current time to allow the distortion
    to change as time progresses:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波浪效果**操纵纹理坐标，使场景旋转和摇摆。在这个效果中，我们还提供了当前时间，以便随着时间的变化，扭曲也会改变：'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/249f5635-ab2e-4923-94c9-8ba0f2c4167d.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/249f5635-ab2e-4923-94c9-8ba0f2c4167d.png)'
- en: 'The **blur effect **samples several pixels around the current pixel and uses
    a weighted blend to produce a fragment output that is the average of its neighbors.
    This gives a blurry feel to the scene. A new uniform, `uInverseTextureSize`, provides
    values that are `1` over the `width` and `height` of the viewport. We use these
    values to accurately target individual pixels within the texture. For example, `vTextureCoords.x
    + 2 * uInverseTextureSize.x` will be exactly 2 pixels to the left of the original
    texture coordinate:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模糊效果**在当前像素周围采样几个像素，并使用加权混合来产生一个片段输出，该输出是其邻居的平均值。这给场景带来了一种模糊感。一个新的统一变量`uInverseTextureSize`提供了视口宽度和高度的倒数。我们使用这些值来准确地在纹理中定位单个像素。例如，`vTextureCoords.x
    + 2 * uInverseTextureSize.x`将正好在原始纹理坐标的左侧2个像素处：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/938d5656-3092-425d-9bbb-024feb693459.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/938d5656-3092-425d-9bbb-024feb693459.png)'
- en: 'Our final example is a **film grain **effect. This uses a noisy texture to
    create a grainy scene, which simulates the use of an old camera. This example
    is significant because it demonstrates the use of a second texture besides the
    framebuffer when rendering:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后一个例子是**胶片颗粒效果**。这个效果使用噪点纹理来创建颗粒场景，模拟使用老式相机的效果。这个例子很重要，因为它展示了在渲染时除了帧缓冲区外还使用了第二个纹理：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/164be51d-f5d2-44f8-9653-7d214157d51d.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/164be51d-f5d2-44f8-9653-7d214157d51d.png)'
- en: '***What just happened?***'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: All of these effects are achieved by manipulating the rendered image before
    it is outputted to the screen. Since the amount of geometry processed for these
    effects is small, they are efficient, regardless of the scene's complexity. That
    being said, performance may be affected as the size of the `canvas` or the complexity
    of the post-process shader increases.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些效果都是通过在输出到屏幕之前操纵渲染的图像来实现的。由于这些效果处理的几何量很小，因此它们是高效的，无论场景的复杂程度如何。然而，随着`canvas`的大小或后处理着色器的复杂性的增加，性能可能会受到影响。
- en: 'Have a Go: Funhouse Mirror Effect'
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下：趣味屋镜面效果
- en: What would it take to create a post-process effect that stretches the image
    near the center of the viewport and squashes it toward the edges?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个在视口中心附近拉伸图像并在边缘挤压的效果，需要什么？
- en: Point Sprites
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点精灵
- en: '**Particle effects **is a common technique used in many 3D applications and
    games. A particle effect is a generic term for any special effect created by rendering
    groups of **particles** (displayed as points, textured quads, or repeated geometry),
    typically with some simple physics simulation acting on the individual particles.
    They can be used for simulating smoke, fire, bullets, explosions, water, sparks,
    and many other effects that are difficult to represent by a single geometric model.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**粒子效果**是许多3D应用程序和游戏中常用的技术。粒子效果是对通过渲染粒子群（以点、纹理四边形或重复的几何形状显示）创建的任何特殊效果的通称，通常在单个粒子上作用一些简单的物理模拟。它们可以用来模拟烟雾、火焰、子弹、爆炸、水、火花以及许多其他难以用单个几何模型表示的效果。'
- en: One very efficient way of rendering particles is to use **point sprites**. Throughout
    this book, we've been rendering triangle primitives, but if you render vertices
    with the `POINTS` primitive type, then each vertex will be rendered as a single
    pixel on the screen. A point sprite is an extension of the `POINTS` primitive
    rendering, where each point is provided a size and is textured in the shader.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染粒子的一种非常有效的方法是使用**点精灵**。在这本书中，我们一直在渲染三角形原语，但如果你使用`POINTS`原语类型渲染顶点，那么每个顶点将作为屏幕上的单个像素渲染。点精灵是`POINTS`原语渲染的扩展，其中每个点都提供了一个大小并在着色器中进行纹理化。
- en: 'A point sprite is created by setting the `gl_PointSize` value in the vertex
    shader. It can be set to either a constant value or a value calculated from shader
    inputs. If it''s set to a number greater than one, the point is rendered as a
    quad that always faces the screen (also known as a **billboard**). The quad is
    centered on the original point and has a width and height equal to the `gl_PointSize` in
    pixels:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在顶点着色器中设置`gl_PointSize`值来创建点精灵。它可以设置为常量值或从着色器输入计算出的值。如果设置为大于一的数字，点将以一个始终面向屏幕的四边形渲染（也称为**广告牌**）。四边形以原始点为中心，其宽度和高度等于以像素为单位的`gl_PointSize`：
- en: '![](img/938e6674-d890-4607-9d57-6a9fb0876d0e.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/938e6674-d890-4607-9d57-6a9fb0876d0e.png)'
- en: 'When the point sprite is rendered, it also generates texture coordinates for
    the quad, covering a simple `0-1` range from the upper left to the lower right:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当点精灵渲染时，它还会为四边形生成纹理坐标，覆盖从左上角到右下角的简单`0-1`范围：
- en: '![](img/9f53f4e7-6be9-4a49-b2ad-a0739bb6197b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f53f4e7-6be9-4a49-b2ad-a0739bb6197b.png)'
- en: 'The texture coordinates are accessible in the fragment shader by the built-in `vec2
    gl_PointCoord`. Combining these properties gives us a simple point sprite vertex
    shader that looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标可以通过内置的`vec2 gl_PointCoord`在片段着色器中访问。结合这些属性，我们得到一个简单的点精灵顶点着色器，看起来像这样：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The corresponding fragment shader looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的片段着色器看起来像这样：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is an example of the appropriate draw command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个适当的绘制命令的示例：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This renders each point in the vertex buffer as a `16x16` texture.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将顶点缓冲区中的每个点渲染为`16x16`纹理。
- en: Time for Action: Fountain of Sparks
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：火花喷泉
- en: 'Let''s see how we can use point sprites to create a fountain of sparks:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用点精灵创建一个火花喷泉：
- en: 'Open the `ch10_02_point-sprites.html` file in your browser:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`ch10_02_point-sprites.html`文件：
- en: '![](img/382fc860-9d2a-42be-a19c-2f298a87d2b9.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/382fc860-9d2a-42be-a19c-2f298a87d2b9.png)'
- en: This example showcases a simple *fountain of sparks *effect with point sprites.
    You can adjust the size and lifetime of the particles by using the sliders.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此示例展示了使用点精灵的简单**火花喷泉**效果。您可以通过使用滑块调整粒子的尺寸和寿命。
- en: The particle simulation is performed by maintaining a list of particles that
    are comprised of position, velocity, and lifespan. In every frame, we iterate
    through the list and move the particles according to the velocity; we also apply
    gravity and reduce the remaining lifespan. Once a particle's lifespan has reached
    `0`, it's reset to the origin with a random velocity and updated lifespan.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 粒子模拟是通过维护一个由位置、速度和寿命组成的粒子列表来完成的。在每一帧中，我们遍历列表并根据速度移动粒子；我们还应用重力并减少剩余寿命。一旦粒子的寿命达到`0`，它就会重置到原点，并带有随机速度和更新的寿命。
- en: With every iteration of the particle's simulation, the particle positions and
    lifespans are copied to an array that is then used to update a vertex buffer.
    This vertex buffer is what is rendered to produce the onscreen sprites.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在粒子的模拟迭代中，粒子位置和寿命被复制到一个数组中，然后用于更新顶点缓冲区。这个顶点缓冲区就是用于在屏幕上生成精灵的渲染内容。
- en: Let's experiment with some of the other values that control the simulation and
    see how they affect the scene. Open up `ch10_02_point-sprites.html` in your editor.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实验一下控制模拟的其他一些值，看看它们如何影响场景。在您的编辑器中打开`ch10_02_point-sprites.html`。
- en: First, locate the call to `configureParticles` at the bottom of the `configure` function.
    The number passed as an argument, initially set to `1024`, determines how many
    particles are created. Try changing it to a lower or higher value to see the effect
    it has on the particle system. Be careful, though, since extremely high values
    (for example, in the millions) may cause performance issues.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`configure`函数的底部定位到对`configureParticles`的调用。作为参数传递的数字，最初设置为`1024`，决定了创建多少个粒子。尝试将其更改为一个较低或较高的值，以查看它对粒子系统的影响。但请注意，极端高的值（例如，数百万）可能会导致性能问题。
- en: 'Next, find the `resetParticle` function. This function is called any time a
    particle is created or reset. There are several values here that can have a significant
    effect on how the scene renders:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，找到`resetParticle`函数。每当创建或重置粒子时都会调用此函数。这里有几个值可以显著影响场景的渲染方式：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `particle.position` is the `x`, `y`, `z` starting coordinates for the particle.
    Initially, all points start at the world origin `(0, 0, 0)`, but this could be
    set to anything. It's often desirable to have the particles originate from the
    location of another object so as to give the impression that the object is producing
    the particles. You can also randomize the position to make the particles appear
    within a given area.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`particle.position`是粒子的`x`、`y`、`z`起始坐标。最初，所有点都从世界原点`(0, 0, 0)`开始，但这也可能被设置为任何值。通常希望粒子从另一个物体的位置开始，以产生物体产生粒子的印象。你也可以随机化位置，使粒子看起来在给定区域内。'
- en: '`particle.velocity` is the initial velocity of the particle. Here, you can
    see that it has been randomized so that particles spread out as they move away
    from the origin. Particles that move in random directions tend to look more like
    explosions or sprays, while those that move in the same direction give the appearance
    of a steady stream. In this case, the `y` value is designed to always be positive,
    while the `x` and `z` values may either be positive or negative. Experiment with
    what happens when you increase or decrease these velocity values or remove the
    random element from one of the components.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`particle.velocity`是粒子的初始速度。在这里，你可以看到它已经被随机化，这样粒子在远离原点时就会分散开来。随机方向移动的粒子看起来更像爆炸或喷雾，而那些朝同一方向移动的粒子则给人一种稳定流的感觉。在这种情况下，`y`值被设计为始终为正，而`x`和`z`值可以是正也可以是负。尝试增加或减少这些速度值或从其中一个分量中移除随机元素，看看会发生什么。'
- en: Finally, `particle.lifespan` determines how long a particle is displayed before
    being reset. This uses the value from the controls while being randomized to provide
    visual variety. If you remove the random element from the particle lifespan, all
    of the particles will expire and reset at the same time, resulting in fireworks-like *bursts *of
    particles.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`particle.lifespan`决定了粒子在重置之前显示的时间长度。这使用控制器的值同时进行随机化，以提供视觉多样性。如果你从粒子寿命中移除随机元素，所有粒子将同时到期并重置，导致类似烟花般的*爆发*粒子。
- en: 'Next, find the `updateParticles` function. This function is called once per
    frame to update the position and velocity of all particles before pushing the
    new values to the vertex buffer. It''s interesting to note that in terms of manipulating
    the simulation behavior, gravity is applied mid-way through the function:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，找到`updateParticles`函数。这个函数每帧调用一次，用于更新所有粒子的位置和速度，在将新值推送到顶点缓冲区之前。值得注意的是，在操纵模拟行为方面，重力是在函数中途应用的：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `9.8` here is the acceleration applied to the `y` component over time. In
    other words, this is the gravity. We can remove this calculation entirely to create
    an environment where the particles float indefinitely along their original trajectories.
    We can increase the value to make the particles fall very quickly (giving them
    a *heavy* appearance), or we can change the component that the deceleration is
    applied to so that we can change the direction of gravity. For example, subtracting
    from `velocity[0]` makes the particles *fall* sideways.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的`9.8`是对`y`分量随时间施加的加速度。换句话说，这就是重力。我们可以完全移除这个计算来创建一个粒子沿其原始轨迹无限期漂浮的环境。我们可以增加这个值使粒子快速下落（赋予它们*沉重*的外观），或者我们可以改变减速施加的分量，以便我们可以改变重力的方向。例如，从`velocity[0]`中减去会使粒子*侧向下落*。
- en: This is also where we apply a simple collision response with the *floor*. Any
    particles with a `y`position less than `0` (below the floor) have their velocities
    reversed and reduced. This gives us a realistic bouncing motion. We can make the
    particles less bouncy by reducing the multiplier (that is, `0.25` instead of `0.75`)
    or even eliminate bouncing altogether by simply setting the `y` velocity to `0`.
    Additionally, we can remove the floor by taking away the check for `y < 0`, which
    will allow the particles to fall indefinitely.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也是我们应用简单的碰撞响应与*地板*的地方。任何`y`位置小于`0`（在地板下方）的粒子，其速度会被反转并减小。这给了我们一个真实的弹跳运动。我们可以通过减小乘数（即，`0.25`而不是`0.75`）来使粒子不那么弹跳，或者通过简单地将`y`速度设置为`0`来完全消除弹跳。此外，我们可以通过移除对`y
    < 0`的检查来移除地板，这将允许粒子无限期地落下。
- en: It's also worth seeing the different effects we can achieve with different textures.
    Try changing the path for the `spriteTexture` in the `configure` function to see
    what it looks like when you use different images.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值得注意的是，我们可以用不同的纹理实现不同的效果。尝试在`configure`函数中将`spriteTexture`的路径更改，看看使用不同图像时的效果。
- en: '***What just happened?***'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We've seen how point sprites can be used to efficiently render particle effects.
    We've also seen the different ways that we can manipulate a particle simulation
    to achieve various effects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用点精灵高效地渲染粒子效果。我们也看到了我们可以操纵粒子模拟以实现各种效果的不同方式。
- en: 'Have a Go: Bubbles!'
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下：气泡！
- en: The particle system in place here could be used to simulate bubbles or smoke
    floating upward just as easily as bouncing sparks. How would you change the simulation
    to make the particles float rather than fall?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的粒子系统可以用来模拟向上漂浮的气泡或烟雾，就像弹跳的火花一样容易。你将如何改变模拟，使粒子漂浮而不是下落？
- en: Normal Mapping
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法线贴图
- en: A very powerful and popular technique among real-time 3D applications is **normal
    mapping**. Normal mapping creates the illusion of highly detailed geometry on
    a low-poly model by storing surface normals in a texture map that can then be
    used to calculate the lighting of the objects. This method is especially popular
    in modern games, since this allows developers to strike a balance between high
    performance and scene detail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时3D应用中，**法线贴图**是一种非常强大且流行的技术。法线贴图通过在纹理图中存储表面法线，从而在低多边形模型上创建高度详细几何形状的错觉，然后可以用来计算对象的光照。这种方法在现代游戏中特别受欢迎，因为它允许开发者在高性能和场景细节之间取得平衡。
- en: 'Typically, lighting is calculated by using the surface normals of the triangles
    being rendered, meaning that the entire polygon will be lit as a continuous, smooth
    surface:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，光照是通过使用正在渲染的三角形的表面法线来计算的，这意味着整个多边形将被作为一个连续、平滑的表面来照亮：
- en: '![](img/ee00b4a8-4719-401e-a59e-bd24ef025568.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee00b4a8-4719-401e-a59e-bd24ef025568.png)'
- en: 'With normal mapping, the surface normals are replaced by normals that are encoded
    in a texture that give the appearance of a rough or bumpy surface. Note that the
    actual geometry is not changed when using a normal map – only how it''s lit changes.
    If you look at a normal mapped polygon from the side, it will still appear to
    be perfectly flat:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用法线贴图时，表面法线被编码在纹理中的法线所取代，这些法线给出了粗糙或凹凸表面的外观。请注意，使用法线贴图时，实际几何形状并未改变——只有光照方式发生了变化。如果你从侧面看一个法线贴图的多边形，它仍然看起来是完全平坦的：
- en: '![](img/60c3eee4-74e2-4112-a026-ef7161857799.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60c3eee4-74e2-4112-a026-ef7161857799.png)'
- en: 'The texture used to store the normals is called a **normal map**, and it''s
    typically paired with a specific diffuse texture that complements the surface
    that the normal map is trying to simulate. For example, here is a diffuse texture
    of some flagstones and the corresponding normal map:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储法线的纹理称为**法线图**，它通常与一个特定的漫反射纹理配对，以补充法线图试图模拟的表面。例如，这里有一些石板的漫反射纹理和相应的法线图：
- en: '![](img/8b264e92-611f-4032-bc33-bcef53831320.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b264e92-611f-4032-bc33-bcef53831320.png)'
- en: You can see that the normal map contains a similar pattern to the diffuse texture.
    Together, the two textures give the appearance that the stones are raised with
    a rough finish, while the grout is sunken in.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到法线贴图包含与漫反射纹理相似的图案。两者结合，给人一种石头表面粗糙且有凹凸纹理，而灰缝则是凹进去的印象。
- en: '**Mapping Techniques** Although normal mapping is a powerful technique for
    efficiently adding more detail to assets, there are many other mapping techniques
    that follow the same line of reasoning. You can read about some of the other techniques
    that are available for use here: [https://en.wikipedia.org/wiki/Category:Texture_mapping](https://en.wikipedia.org/wiki/Category:Texture_mapping).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射技术** 虽然法线贴图是一种高效地为资产添加更多细节的强大技术，但还有许多其他遵循相同推理路线的映射技术。您可以在以下链接中了解一些其他可用的技术：[https://en.wikipedia.org/wiki/Category:Texture_mapping](https://en.wikipedia.org/wiki/Category:Texture_mapping)。'
- en: 'The normal map contains custom-formatted color information that can be interpreted
    by the shader at runtime as a fragment normal. A fragment normal is essentially
    the same as a vertex normal: it is a three-component vector that points away from
    the surface. The normal texture encodes the three components of the normal vector
    into the three channels of the texture''s texel color. Red represents the `x-axis`,
    green represents the `y-axis`, and blue represents the `z-axis`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 法线图包含自定义格式的颜色信息，可以在运行时由着色器解释为片段法线。片段法线本质上与顶点法线相同：它是一个指向表面的三分量向量。法线纹理将法线向量的三个分量编码到纹理的texel颜色的三个通道中。红色代表`x`轴，绿色代表`y`轴，蓝色代表`z`轴。
- en: The normals that have been encoded are typically stored in **tangent space**, as
    opposed to world or object space. Tangent space is the coordinate system for the
    texture coordinates of a face. Normal maps are commonly blue, since the normals
    they represent generally point away from the surface and thus have larger `z`
    components.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的法线通常存储在**切线空间**中，而不是世界空间或对象空间。切线空间是面纹理坐标的坐标系。法线图通常呈蓝色，因为它们所表示的法线通常指向表面外部，因此具有更大的`z`分量。
- en: 'Time for Action: Normal Mapping in Action'
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：法线图的实际应用
- en: 'Let''s cover an example showcasing normal mapping in action:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示法线图的实际应用：
- en: 'Open the `ch10_03_normal-map.html` file in a browser:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`ch10_03_normal-map.html`文件：
- en: '![](img/be34f773-74b6-4a56-b78a-89b58c7f91bd.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![示例图片](img/be34f773-74b6-4a56-b78a-89b58c7f91bd.png)'
- en: Rotate the cube to see the effect that the normal map has on the lit cube. Keep
    in mind that the profile of the cube has not changed. Let's examine how this effect
    is achieved.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转立方体以查看法线图对光照立方体产生的影响。请记住，立方体的轮廓并没有改变。让我们看看这个效果是如何实现的。
- en: 'First, we need to add a new attribute to our vertex buffers. There are three
    vectors needed to calculate the tangent space coordinates for lighting: the **normal**,
    the **tangent**,and the **bitangent**:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要向我们的顶点缓冲区中添加一个新的属性。计算光照的切线空间坐标需要三个向量：**法线**、**切线**和**偏切线**：
- en: '![](img/aa0741c1-0221-41ff-ae40-fd2904f6bc31.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![示例图片](img/aa0741c1-0221-41ff-ae40-fd2904f6bc31.png)'
- en: We have already covered normals, so let's investigate the other two vectors.
    The tangent represents the *up* (positive `y`) vector for the texture relative
    to the polygon surface. The bitangent represents the *left* (positive `x`) vector
    for the texture relative to the polygon surface.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经介绍了法线，现在让我们研究其他两个向量。切线代表相对于多边形表面的纹理的**向上**（正`y`）向量。偏切线代表相对于多边形表面的纹理的**向左**（正`x`）向量。
- en: We only need to provide two of the three vectors as vertex attributes. Traditionally,
    the normal and tangent suffice, as the third vector is calculated as the cross-product
    of the other two in the vertex shader.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要提供三个向量中的两个作为顶点属性。传统上，法线和切线就足够了，因为第三个向量在顶点着色器中是通过其他两个向量的叉积计算得出的。
- en: 'It is common for 3D modeling packages to generate tangents for you. However,
    if they aren''t provided, they can be calculated from the vertex positions and
    texture coordinates, similar to calculating vertex normals:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3D建模软件通常可以为你生成切线。然而，如果没有提供，它们可以从顶点位置和纹理坐标中计算出来，类似于计算顶点法线：
- en: '**Tangent Generation Algorithm**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**切线生成算法**'
- en: We won't cover this algorithm here, but for reference, it has been implemented
    in `common/js/utils.js` as `calculateTangents` and used in `scene.add`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会介绍这个算法，但为了参考，它已经在`common/js/utils.js`中作为`calculateTangents`实现，并在`scene.add`中使用。
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the vertex shader, at the top of `ch10_03_normal-map.html`, the tangent
    needs to be transformed by the Normal matrix. The two transformed vectors can
    be used to calculate the third:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶点着色器中，在`ch10_03_normal-map.html`的顶部，切线需要通过法线矩阵进行变换。两个变换后的向量可以用来计算第三个向量：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The three vectors can then be used to create a matrix that transforms vectors
    into tangent space:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这三个向量可以用来创建一个矩阵，将向量转换到切线空间：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unlike before, where we applied lighting in the vertex shader, the bulk of
    the lighting calculations needs to happen in the fragment shader so that we can
    incorporate normals from the texture. That being said, we do transform the light
    direction into tangent space in the vertex shader before passing it to the fragment
    shader as a varying:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前在顶点着色器中应用光照不同，大部分光照计算需要在片段着色器中进行，以便我们可以结合纹理中的法线。也就是说，我们在将光方向传递到片段着色器之前，将其转换为切线空间：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the fragment shader, we start by extracting the tangent space normal from
    the normal map texture. Since texture texels don''t store negative values, the
    normal components must be encoded to map from a `[-1, 1]` to a `[0, 1]` range.
    Therefore, they must be *unpacked* into the correct range before being used in
    the shader. The algorithm to perform this operation can be easily expressed in
    ESSL:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们首先从法线贴图纹理中提取切线空间法线。由于纹理texel不存储负值，法线分量必须编码以从`[-1, 1]`映射到`[0, 1]`范围。因此，在着色器中使用之前，它们必须被*解包*到正确的范围。执行此操作的算法可以用ESSL轻松表达：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lighting is calculated nearly the same as the vertex-lit model, which is done
    by using the texture normal and tangent space light direction:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 光照的计算几乎与顶点光照模型相同，这是通过使用纹理法线和切线空间光照方向来完成的：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To help accentuate the normal mapping effect, the code sample also includes
    the calculation of a specular term.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了强调法线映射效果，代码示例还包括了镜面项的计算。
- en: '***What just happened?***'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We've seen how we can use normal information that's been encoded into a texture
    to add a new level of complexity to our lit models without additional geometry.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以使用编码到纹理中的法线信息，在不添加额外几何形状的情况下为我们的光照模型添加新的复杂度。
- en: Ray Tracing in Fragment Shaders
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光线追踪在片段着色器中
- en: A common (if somewhat impractical) technique used to demonstrate how powerful
    shaders can be is to use them to **ray trace** a scene. Thus far, all of our rendering
    has been done with **polygon rasterization**, which is the technical term for
    the triangle-based rendering that WebGL incorporates. Ray tracing is an alternate
    rendering technique that traces the path of light through a scene as it interacts
    with mathematically defined geometry.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的（尽管有些不切实际）技术，用于展示着色器的强大功能，是使用它们来**光线追踪**场景。到目前为止，我们的渲染都是通过**多边形光栅化**完成的，这是WebGL所采用的基于三角形的渲染的技术术语。光线追踪是一种替代渲染技术，它追踪光线在场景中与数学定义的几何体交互时的路径。
- en: Ray tracing has several advantages compared to traditional polygonal rendering.
    Primarily, this includes creating more realistic scenes due to a more accurate
    lighting model that can easily account for things like reflection and reflected
    lighting. That said, ray tracing tends to be considerably slower than polygonal
    rendering, which is the reason it's not often used for real-time applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的多边形渲染相比，光线追踪具有几个优势。主要优势包括由于更精确的光照模型而创建更逼真的场景，该模型可以轻松地考虑反射和反射光照等因素。尽管如此，光线追踪通常比多边形渲染慢得多，这也是它不常用于实时应用的原因。
- en: 'Ray tracing a scene is achieved by creating a series of rays (represented by
    an origin and direction) that start at the camera''s location and pass through
    each pixel in the viewport. These rays are then tested against every object in
    the scene to determine whether there are any intersections. If an intersection
    occurs, the closest intersection to the ray origin is returned, determining the
    color of the rendered pixel:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一系列从相机位置开始并穿过视口中的每个像素的光线（由一个起点和方向表示），可以实现对场景的光线追踪。然后，这些光线与场景中的每个对象进行测试，以确定是否存在任何交点。如果发生交点，则返回与光线起点最近的交点，从而确定渲染像素的颜色：
- en: '![](img/3aa28732-30bc-4a8a-8592-54763c70778e.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3aa28732-30bc-4a8a-8592-54763c70778e.png)'
- en: Although there are many algorithms that can be used to determine the color of
    the intersection point – ranging from simple diffuse lighting to multiple bounces
    of rays coming off other objects to simulate reflection – we'll keep our example
    simple. It's important to note that the rendered scene will entirely be the product
    of the shader code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多算法可以用来确定交点的颜色——从简单的漫反射光照到从其他物体反射出来的光线的多次弹跳以模拟反射——但我们将保持我们的示例简单。重要的是要注意，渲染的场景将完全是着色器代码的产物。
- en: 'Time for Action: Examining the Ray Traced Scene'
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：检查光线追踪场景
- en: 'Let''s cover an example showcasing the power of ray tracing:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示光线追踪的强大功能：
- en: 'Open the `ch10_04_ray-tracing.html` file in your browser. You should see a
    scene with a simple lit, bobbing sphere like the one shown in the following screenshot:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`ch10_04_ray-tracing.html`文件。您应该会看到一个场景，其中有一个简单的被光照、上下摆动的球体，就像以下截图所示：
- en: '![](img/a6829bb4-69c0-4d16-b69b-0e9a56925b16.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6829bb4-69c0-4d16-b69b-0e9a56925b16.png)'
- en: 'In order to trigger the shader, we need a way to draw a full-screen quad. Fortunately,
    we have a class from our post-processing examples earlier in this chapter to help
    us do just that. Since we don''t have a scene to process, we can omit a large
    part of the rendering code and simplify JavaScript''s `draw` function:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了触发着色器，我们需要一种绘制全屏四边形的方法。幸运的是，我们在这个章节早期的一些后处理示例中有一个类可以帮助我们做到这一点。由于我们没有要处理的场景，我们可以省略大部分渲染代码并简化JavaScript的`draw`函数：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's it. The remainder of our scene will be built in to the fragment shader.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这些。我们场景的其余部分将内置到片段着色器中。
- en: 'There are two functions at the core of our shader: one that determines if a
    ray is intersecting a sphere and one that determines the normal of a point on
    the sphere. We''re using spheres because they''re typically the easiest type of
    geometry to raycast, and they also happen to be a type of geometry that is difficult
    to represent accurately with polygons:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们着色器的核心有两个函数：一个用于确定光线是否与球体相交，另一个用于确定球面上某点的法线。我们使用球体，因为它们通常是射影最简单的几何形状，而且它们也是用多边形难以准确表示的几何形状：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we will use these two functions to determine where the ray is intersecting
    with a sphere (if at all), along with what the normal and color of the sphere
    are at that point. To keep things simple, the sphere information is hardcoded
    as global variables, but they could just as easily be provided as uniforms from
    JavaScript:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用这两个函数来确定光线是否与球体相交（如果相交的话），以及在该点球体的法线和颜色。为了简化问题，球体信息被硬编码为全局变量，但它们也可以很容易地从JavaScript中的uniform提供：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we can determine the normal and color of a point with a ray, we need
    to generate the rays for casting. We can do this by determining the pixel that
    the current fragment represents and then creating a ray that points from the camera
    position through that pixel. To do so, we will utilize the `uInverseTextureSize`
    uniform that the `PostProcess` class provides to the shader:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用光线来确定一个点的法线和颜色，我们需要生成用于投射的光线。我们可以通过确定当前片段代表的像素，然后创建一个从相机位置通过该像素的光线来实现。为此，我们将利用`PostProcess`类提供给着色器的`uInverseTextureSize`
    uniform：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using the ray we just generated, we call the `intersect` function to get the
    information about the sphere''s intersection. Then, we apply the same diffuse
    lighting calculations we''ve been using all along! To keep things simple, we''re
    using directional lighting here, but it would be easy enough to update the lighting
    model to point or spot lights:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们刚刚生成的光线，我们调用`intersect`函数来获取关于球体交点的信息。然后，我们应用我们一直在使用的相同的漫反射光照计算！为了简化问题，我们这里使用的是方向性光照，但很容易将光照模型更新为点光源或聚光灯：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Thus far, our example is a static lit sphere. How do we add a bit of motion
    to the scene to give us a better sense of how fast the scene renders and how the
    lighting interacts with the sphere? We do so by adding a simple looping circular
    motion to the sphere by using the `uTime` uniform to modify the `x` and `z` coordinates
    at the beginning of the shader:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们的例子是一个静态的照明球体。我们如何给场景添加一点运动，以便更好地了解场景的渲染速度以及光照如何与球体相互作用？我们通过在着色器开始时使用`uTime`
    uniform修改`x`和`z`坐标，给球体添加一个简单的循环圆周运动来实现这一点：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***What just happened?***'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We covered how we can construct a 3D scene, lighting and all, entirely in a
    fragment shader. It's a simple scene, of course, but also one that would be nearly
    impossible to render using polygon-based rendering. That's because perfect spheres
    can only be approximated with triangles.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了如何在片段着色器中完全构建一个3D场景，包括光照等。当然，这是一个简单的场景，但也是一个几乎不可能使用基于多边形的渲染来渲染的场景。这是因为完美的球体只能用三角形来近似。
- en: '**Shader Toy** Now that you''ve seen how to construct 3D scenes entirely in
    fragment shaders, you will find the demos on [ShaderToy.com](https://www.shadertoy.com/) both
    beautiful and inspiring.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**着色器玩具** 现在你已经看到了如何完全在片段着色器中构建3D场景，你会发现[ShaderToy.com](https://www.shadertoy.com/)上的演示既美丽又富有启发性。'
- en: 'Have a Go: Multiple Spheres'
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试：多个球体
- en: In our example, we've kept things simple by rendering only one single sphere.
    That being said, all of the pieces needed to render several spheres are in place!
    How would you render a scene of multiple spheres with different colors and motion?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们通过只渲染一个单独的球体来保持简单。但话说回来，渲染多个球体所需的所有组件都已经就位！你将如何渲染一个具有不同颜色和运动的多个球体的场景？
- en: '**Hint** The main shader function that needs editing is `intersect`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示** 需要编辑的主要着色器函数是 `intersect`。'
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let''s summarize what we''ve learned in this chapter:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下在本章中学到的内容：
- en: We covered a variety of advanced techniques to create more visually complex
    and compelling scenes.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了多种高级技术，以创建更视觉复杂和吸引人的场景。
- en: We learned how to apply post-processing effects by leveraging a framebuffer.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过利用帧缓冲区学习了如何应用后处理效果。
- en: We rendered particle effects using point sprites.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用点精灵渲染了粒子效果。
- en: We created the illusion of complex geometry by using normal maps.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过使用法线贴图创造了复杂几何形状的错觉。
- en: Finally, we rendered a scene entirely in a fragment shader using ray casting.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们通过光线投射在片段着色器中完全渲染了一个场景。
- en: These advanced effects are only a glimpse into the vast landscape of effects
    possible with WebGL. Given the power and flexibility of shaders, the possibilities
    are endless!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高级效果只是 WebGL 可实现效果广阔天地的一瞥。鉴于着色器的强大和灵活性，可能性是无限的！
- en: In the next chapter, we will cover the major differences between WebGL 1 (OpenGL
    ES 2.0) and WebGL 2 (OpenGL ES 3.0), along with a migration plan to WebGL 2.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 WebGL 1（OpenGL ES 2.0）和 WebGL 2（OpenGL ES 3.0）之间的主要区别，以及迁移到 WebGL
    2 的计划。
