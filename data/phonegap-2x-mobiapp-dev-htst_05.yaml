- en: Chapter 5. Talking to Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 与您的应用对话
- en: The media capabilities of our mobile devices are frankly amazing, especially
    when you consider where we were five, ten, fifteen years ago. The first mass-produced
    MP3 player was the *SaeHan/Eiger MPMan* ([http://en.wikipedia.org/wiki/Portable_media_player#SaeHan.2FEiger_MPMan](http://en.wikipedia.org/wiki/Portable_media_player#SaeHan.2FEiger_MPMan))
    introduced in 1997\. The device had 32 MB of storage, enough for roughly 6 to
    7 songs (assuming 1 MB/minute, 5m per song). While it may seem paltry by today's
    standards, it was a revolution and spawned a new way to listen to music.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移动设备的媒体功能实际上非常惊人，尤其是当你考虑到五年、十年、十五年前我们所在的位置。第一台大规模生产的MP3播放器是1997年推出的*SaeHan/Eiger
    MPMan* ([http://en.wikipedia.org/wiki/Portable_media_player#SaeHan.2FEiger_MPMan](http://en.wikipedia.org/wiki/Portable_media_player#SaeHan.2FEiger_MPMan))。该设备有32MB的存储空间，足以存储大约6到7首歌曲（假设每分钟1MB，每首歌5分钟）。虽然按照今天的标准可能看起来很少，但它是一场革命，并催生了一种新的听音乐的方式。
- en: Today's devices are now so much more, portable entertainment devices that can
    play games, video, and all sorts of audio. Being able to play sounds in your app
    is critical, and there are few apps that could make the case for having no sound
    whatsoever. Although a bit on the extreme side, perhaps, *TweetBot* is a classic
    example of an app that is enhanced by the sound it produces via the user's interactions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的设备现在不仅仅是便携式娱乐设备，可以玩游戏、视频和所有类型的音频。能够在您的应用程序中播放声音至关重要，而且很少有应用程序可以声称完全没有声音。虽然可能有些极端，但*TweetBot*是一个经典的例子，该应用程序通过用户的交互产生的声音得到了增强。
- en: Today's devices can also record audio for a variety of reasons, whether it be
    for a reminder later, recording a speech or meeting, and more. There are a lot
    of apps that wouldn't require this functionality, but for a certain segment, it's
    important that you know how to record.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的设备也可以出于各种原因记录音频，无论是为了稍后提醒，记录演讲或会议，还是更多。有很多应用程序可能不需要这种功能，但对于某些细分市场来说，了解如何录音是很重要的。
- en: What do we build?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要构建什么？
- en: 'We will build a fairly simple app with one purpose: to store and play back
    the end user''s recordings, whatever they may be. They could be a short memo or
    a meeting. We''ll be using a lot of our existing framework, and there''s not a
    lot visually, but there is a lot going on underneath to support audio playback
    and recording.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个相当简单的应用程序，其目的只有一个：存储和回放最终用户的录音，无论它们是什么。它们可能是一段简短的备忘录或一次会议。我们将大量使用我们现有的框架，从视觉上看可能不多，但在下面有很多东西在支持音频播放和录音。
- en: What does it do?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它能做什么？
- en: In this project, you will be able to play and record audio. We'll be recording
    to the `WAV` format for iOS and the `AMR` format for Android. Other platforms
    support other formats, so if you are targeting a platform other than Android or
    iOS, be sure to double-check what formats are supported.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您将能够播放和录音音频。我们将为iOS录制`WAV`格式，为Android录制`AMR`格式。其他平台支持其他格式，所以如果您针对的不是Android或iOS以外的平台，请务必核实支持哪些格式。
- en: You'll also be able to play audio; we'll support both `MP3` and `WAV` on Android
    and `WAV` on iOS (the primary reason we exclude MP3 for iOS here is a bug that
    causes `MP3` `format audios` to render with horrible quality and extremely loud
    volume).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将能够播放音频；我们将支持Android上的`MP3`和`WAV`，以及iOS上的`WAV`（我们在这里排除iOS上的MP3的主要原因是一个导致`MP3`格式音频以糟糕的质量和极其大的音量渲染的bug）。
- en: Why is it great?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这为什么很棒？
- en: 'There''s another reason why this project is so great: we''re introducing gesture
    support. That''s right: *swipe-to-delete* and *long-press* will feature in this
    app as well.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目之所以如此出色还有另一个原因：我们引入了手势支持。没错：*滑动删除*和*长按*也将在这个应用程序中体现。
- en: How are we going to do it?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何实现？
- en: 'We''ll be following the same task list as our previous projects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循与之前项目相同的任务列表：
- en: Designing the user interface and the look and feel
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用户界面和外观
- en: Designing the data model
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计数据模型
- en: Implementing the data model
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据模型
- en: Implementing gesture support
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现手势支持
- en: Implementing the main view
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现主视图
- en: What do I need to get started?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我需要准备些什么才能开始？
- en: As always, go ahead and create your project following the same steps we've used
    in previous projects. You might also want to refer to the PhoneGap Media API documentation,
    as we'll be using it extensively. (refer to [http://docs.phonegap.com/en/edge/cordova_media_media.md.html#Media](http://docs.phonegap.com/en/edge/cordova_media_media.md.html#Media))
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，按照我们在以前项目中使用的相同步骤创建您的项目。您可能还想参考PhoneGap媒体API文档，因为我们将会大量使用它。（参考[http://docs.phonegap.com/en/edge/cordova_media_media.md.html#Media](http://docs.phonegap.com/en/edge/cordova_media_media.md.html#Media)）
- en: Designing the user interface and the look and feel
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计用户界面和外观
- en: This app will be *visually* simpler than any of our previous apps. We only need
    one view, and the look of that view has already largely been defined by our Android
    interfaces for the last two projects. That's right; the view is essentially a
    list of items, nothing fancy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用将比我们之前的任何应用都要简单。我们只需要一个视图，而这个视图的外观已经由我们过去两个项目的Android界面在很大程度上定义了。没错；视图本质上是一个项目列表，没有太多花哨的地方。
- en: Getting on with it
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: There are some things we will change in our list of items. Essentially we will
    clean up the list by hiding the action icons (delete, share, and so on) and showing
    them only when we receive a gesture. We will also include *Play* and *Pause* buttons
    in the list item instead of any particular document image. After all, we don't
    have album art for recordings the user creates themselves.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目列表中做一些改变。本质上，我们将通过隐藏操作图标（删除、分享等）并在收到手势时显示它们来清理列表。我们还将列表项中包含**播放**和**暂停**按钮，而不是任何特定的文档图像。毕竟，我们没有用户自己创建的录音的专辑封面。
- en: 'Let''s look at the mockup:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看原型：
- en: '![Getting on with it](img/9403_05_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_05_01.jpg)'
- en: As you can see, this mockup is pretty similar to the Android file listings we've
    had in our previous projects. It is substantially different than the document-based
    list on iOS, but the preceding view is common enough that users will know how
    to use it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个原型与我们在以前项目中使用的Android文件列表非常相似。它与iOS上的基于文档的列表有很大不同，但前面的视图足够常见，用户会知道如何使用它。
- en: The icons in the list will not be document icons. Instead we'll use play and
    pause icons to show the state of the document. If it is currently being played,
    we'll show the pause icon, and if it is not being played, we'll show the play
    icon.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的图标将不是文档图标。相反，我们将使用播放和暂停图标来显示文档的状态。如果它目前正在播放，我们将显示暂停图标，如果没有播放，我们将显示播放图标。
- en: The **Delete** button on the right is shown by using the horizontal swipe gesture;
    these buttons are otherwise invisible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的**删除**按钮是通过使用水平滑动手势来显示的；这些按钮在其他情况下是不可见的。
- en: Where are the rest of our document actions, like rename or copy, you ask? That's
    a great question. They're still available, but only when a user holds their finger
    on the item for more than a second. At that point, the long-press swipe is recognized,
    and a small menu will pop up asking the user what they would like to do.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，我们的文档操作，比如重命名或复制，在哪里？这是一个很好的问题。它们仍然可用，但只有在用户将手指放在项目上超过一秒时才可用。到那时，长按滑动将被识别，并弹出一个小菜单，询问用户他们想做什么。
- en: The **Record** button is intended to start a recording session. It will ask
    for the filename, and once entered, it will display another pop up indicating
    that it is recording. The user can stop recording by pressing the *stop* button
    on the pop up. We'll also display a microphone icon on this pop up to indicate
    to the user that the app is recording.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**录音**按钮旨在开始录音会话。它将要求输入文件名，一旦输入，它将显示另一个弹出窗口，表明正在录音。用户可以通过按下弹出窗口上的**停止**按钮来停止录音。我们还会在这个弹出窗口上显示一个麦克风图标，以向用户表明应用正在录音。'
- en: 'Now that we have the mockup finished, let''s work on our graphical design in
    our graphics editor. The result will be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了原型，让我们在我们的图形编辑器中处理我们的图形设计。结果将如下所示：
- en: '![Getting on with it](img/9403_05_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_05_02.jpg)'
- en: The following are also some icons that we created as part of our mockup. You
    can find their images in the code files available for this project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们作为原型的一部分创建的一些图标。您可以在本项目的代码文件中找到它们的图像。
- en: 'A microphone is shown as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 麦克风如下所示：
- en: '![Getting on with it](img/9403_05_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_05_03.jpg)'
- en: 'A play button can be seen as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 播放按钮如下所示：
- en: '![Getting on with it](img/9403_05_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_05_04.jpg)'
- en: 'And a pause button will be as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停按钮将如下所示：
- en: '![Getting on with it](img/9403_05_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_05_05.jpg)'
- en: Notice that the background canvas and the navigation bar is the same as our
    previous project. All we really need for this task are the icons for the play
    state, the pause state, and the microphone. Everything else can be handled with
    CSS and HTML.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，背景画布和导航栏与我们的前一个项目相同。我们真正需要为此任务提供的只是播放状态、暂停状态和麦克风的图标。其他一切都可以通过 CSS 和 HTML
    处理。
- en: What did we do?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this section, we've designed the user interface and defined the feel of the
    app. We've also designed the icons we'll be needing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们设计了用户界面并定义了应用程序的感觉。我们还设计了我们将需要的图标。
- en: Designing the data model
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计数据模型
- en: The data model isn't terribly complex, but it is definitely a bit different
    from our previous projects. The document collection is fundamentally the same,
    so we won't cover that model, but the document itself is different. It must load
    and manage audio resources instead of regular files.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型并不特别复杂，但确实与我们的前一个项目略有不同。文档集合在本质上相同，所以我们不会介绍该模型，但文档本身是不同的。它必须加载和管理音频资源而不是常规文件。
- en: Getting on with it
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动
- en: 'Our model is defined as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式定义如下：
- en: '| VoiceRecDocument |   |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| VoiceRecDocument |   |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| - fileEntry | Object |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| - fileEntry | 对象 |'
- en: '| - filename | String |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| - filename | 字符串 |'
- en: '| - fileType | String |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| - fileType | 字符串 |'
- en: '| - completion | Function |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| - completion | 函数 |'
- en: '| - failure | Function |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| - failure | 函数 |'
- en: '| - state | String |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| - state | 字符串 |'
- en: '| - title | String |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| - title | 字符串 |'
- en: '| - media | Object |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| - media | 对象 |'
- en: '| - position | Number |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| - position | 数字 |'
- en: '| - duration | Number |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| - duration | 数字 |'
- en: '| - playing | Boolean |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| - playing | 布尔值 |'
- en: '| - recording | Boolean |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| - recording | 布尔值 |'
- en: '| - paused | Boolean |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| - paused | 布尔值 |'
- en: '| - positionTimer | Timer ID |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| - positionTimer | 定时器 ID |'
- en: '| - durationTimer | Timer ID |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| - durationTimer | 定时器 ID |'
- en: '| - getFileName() |   |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| - getFileName() |   |'
- en: '| - setFileName() |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| - setFileName() |'
- en: '| - initializeMediaObject() |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| - initializeMediaObject() |'
- en: '| - isPlaying() |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| - isPlaying() |'
- en: '| - isRecording() |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| - isRecording() |'
- en: '| - updatePosition() |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| - updatePosition() |'
- en: '| - updateDuration() |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| - updateDuration() |'
- en: '| - getPlaybackPosition() |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| - getPlaybackPosition() |'
- en: '| - setPlaybackPosition() |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| - setPlaybackPosition() |'
- en: '| - getDuration() |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| - getDuration() |'
- en: '| - startPlayback() |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| - startPlayback() |'
- en: '| - pausePlayback() |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| - pausePlayback() |'
- en: '| - releaseResources() |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| - releaseResources() |'
- en: '| - stopPlayback() |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| - stopPlayback() |'
- en: '| - startRecording() |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| - startRecording() |'
- en: '| - stopRecording() |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| - stopRecording() |'
- en: '| - dispatchFailure() |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| - dispatchFailure() |'
- en: '| - dispatchSuccess() |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| - dispatchSuccess() |'
- en: 'Let''s go over what each of these properties and methods should do:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看每个属性和方法应该做什么：
- en: The `fileEntry` property stores the file entry obtained from the File API.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileEntry` 属性存储从 File API 获取的文件条目。'
- en: The `fileName` property stores the full path to the audio file.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileName` 属性存储音频文件的完整路径。'
- en: The `fileType` property stores the extension of the audio file (WAV, MP3, and
    so on).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileType` 属性存储音频文件的扩展名（WAV、MP3 等）。'
- en: The `completion` and `failure` methods point to the `completion` and `failure`
    functions.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`completion` 和 `failure` 方法指向 `completion` 和 `failure` 函数。'
- en: The `title` property stores the name of the file (minus the path and extension).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title` 属性存储文件名称（不包括路径和扩展名）。'
- en: The `media` property will store the `Media` object from the `Media` API.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media` 属性将存储来自 `Media` API 的 `Media` 对象。'
- en: The `position` property will indicate the current playback position in seconds.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position` 属性将指示当前播放位置（以秒为单位）。'
- en: The `duration` property will indicate the current recording duration or length
    of the file for playback (in seconds).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration` 属性将指示当前录音时长或文件播放时长（以秒为单位）。'
- en: '`playing`, `recording`, `paused` are internal state methods used to track what
    is happening inside the object.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playing`、`recording`、`paused` 是用于跟踪对象内部发生情况的内部状态方法。'
- en: '`positionTimer` and `durationTimer` are timer IDs used to update the position
    and duration properties.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`positionTimer` 和 `durationTimer` 是用于更新位置和时长属性的定时器 ID。'
- en: The `get`/`setFileName` methods gets/sets the `fileName` property.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`/`setFileName` 方法获取/设置 `fileName` 属性。'
- en: The `isPlaying`/`isRecording` methods return the respective property.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPlaying`/`isRecording` 方法返回相应的属性。'
- en: '`updatePosition`/`updateDuration` are internal methods used to update the `position`
    and `duration` property during playback and recording.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updatePosition`/`updateDuration` 是在播放和录音期间更新 `position` 和 `duration` 属性的内部方法。'
- en: '`get`/`setPlaybackPosition` will get or set the current playback position.
    If setting, this will use the `seekTo()` method of the `Media` API.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`/`setPlaybackPosition` 将获取或设置当前播放位置。如果设置，这将使用 `Media` API 的 `seekTo()`
    方法。'
- en: '`start`/`pause`/`stopPlayback` will start, pause, or stop playback.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`/`pause`/`stopPlayback` 将开始、暂停或停止播放。'
- en: '`releaseResources` will allow the memory consumed by the media file to be released
    back to the device so that we don''t run out of memory.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`releaseResources` 将允许释放媒体文件消耗的内存，以便我们不会耗尽内存。'
- en: '`start`/`stopRecording` will start or stop recording.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`/`stopRecording` 将开始或停止录制。'
- en: '`dispatchFailure`/`Success` will call the `failure` or `completion` method.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatchFailure`/`Success` 将调用 `failure` 或 `completion` 方法。'
- en: What did we do?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we defined the model for `VoiceRecDocument` as well as the various
    interactions that go on internally.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们定义了 `VoiceRecDocument` 的模型以及内部进行的各种交互。
- en: Implementing the data model
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据模型
- en: Now that we've designed the model, let's go ahead and implement it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设计了模型，让我们继续实现它。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Like in our previous projects, we''ll have two data models: the first one to
    deal with the collection of playable files, and the second one to deal with handling
    a specific playable file. The first, `VoiceRecDocumentCollection.js` is quite
    similar to our previous projects, and so we won''t go over it in this task. But
    the `VoiceRecDocument.js` file is very different, so go ahead and open it up (it''s
    in the `www/models` directory), so you can follow along.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的工程项目一样，我们将有两个数据模型：第一个用于处理可播放文件的集合，第二个用于处理特定可播放文件的处理。第一个，`VoiceRecDocumentCollection.js`
    与我们之前的工程项目非常相似，所以我们不会在这个任务中详细说明。但 `VoiceRecDocument.js` 文件非常不同，所以请打开它（位于 `www/models`
    目录），这样你可以跟随操作。
- en: Getting on with it
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'Let''s start using the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用以下代码片段：
- en: '[PRE0]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As in our prior projects, the incoming parameters include a file entry obtained
    from the `File` API. We'll use this to determine the name of the audio file to
    play as well as its type. We're using some new functions, introduced in this version
    of the framework, to do work with the various portions that make up a file, namely,
    the path, the filename, and the file extension. Earlier, we use `PKUTIL.FILE.getFileExtensionPart()`
    to obtain the type of the file, whether it is an MP3, WAV, or something else.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们之前的工程项目，传入的参数包括从 `File` API 获取的文件条目。我们将使用它来确定要播放的音频文件的名称及其类型。我们使用一些新函数，这些函数是在本版本的框架中引入的，用于处理文件的不同部分，即路径、文件名和文件扩展名。之前，我们使用
    `PKUTIL.FILE.getFileExtensionPart()` 来获取文件的类型，无论是 MP3、WAV 还是其他类型。
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here we define several properties that we will use to keep track of the various
    states and timers we need to use to properly manage our audio:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了几个属性，我们将使用它们来跟踪我们需要用于正确管理音频的各种状态和定时器：
- en: '`title`: This property gives the title of the file, essentially the filename
    minus the path and extension.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 这个属性给出了文件的标题，基本上是文件名减去路径和扩展名。'
- en: '`media`: This property gives the `Media` object provided by PhoneGap. This
    property will be set whenever the program needs to play a sound or record something.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media`: 这个属性给出了 PhoneGap 提供的 `Media` 对象。每当程序需要播放声音或录制某些内容时，此属性将被设置。'
- en: '`position`: This property gives the approximate position in the sound file
    for playback. It''s approximate because it is updated every few milliseconds with
    the position. We''ll discuss why in a bit.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`: 这个属性给出了播放时的近似位置。它之所以是近似的，是因为它每隔几毫秒就会更新位置。我们稍后会讨论原因。'
- en: '`duration`: This property gives the duration of the sound file (if playing),
    or the approximate duration of the recording (while, or after, recording).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration`: 这个属性给出了声音文件的持续时间（如果正在播放），或者录制（在录制期间或之后）的近似持续时间。'
- en: '`playing`, `recording`, `paused`: These are simply Boolean variables intended
    to make it easy to determine what we''re doing. Are we playing the file, recording
    a file, and, if we''re playing, are we paused?'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playing`, `recording`, `paused`: 这些只是简单的布尔变量，旨在使我们能够轻松地确定我们在做什么。我们在播放文件，录制文件，如果我们正在播放，我们是否暂停？'
- en: '`durationTimer`, `positionTimer`: Timer IDs are used to track the intervals
    that get created whenever we load a media file or prepare one for recording. The
    `durationTimer` property updates the `duration` property, and the `positionTimer`
    property updates the position.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`durationTimer`, `positionTimer`: 定时器 ID 用于跟踪每次我们加载媒体文件或为其录制做准备时创建的间隔。`durationTimer`
    属性更新 `duration` 属性，而 `positionTimer` 属性更新位置。'
- en: '[PRE2]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code snippet handles getting and setting the filename. If we set
    a filename, we have to update the filename, type, and title.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段处理获取和设置文件名。如果我们设置了一个文件名，我们必须更新文件名、类型和标题。
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method is a very important method; we''ll be calling it at the top of
    most of our methods that work with playback or recording. This is to ensure that
    the `media` property is properly initialized. But it is also to ensure a few other
    details are correctly set up, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是一个非常重要的方法；我们将在大多数与播放或录制一起工作的方法顶部调用它。这是为了确保`media`属性被正确初始化。但这也是为了确保一些其他细节被正确设置，如下所示：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we do these steps if and only if we don't already have a `media` object
    at hand. If we do, there's no need to initialize it again.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只在这些步骤中执行这些步骤，如果我们已经有了`media`对象。如果我们已经有了，就没有必要再次初始化它。
- en: Secondly, we check if we're running on Android. If we are, the `file://` prefix
    that comes out of the `File` API will confuse the `Media` APIs, and so we remove
    it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们检查我们是否在Android上运行。如果是，从`File` API出来的`file://`前缀会混淆`Media` API，所以我们将其移除。
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we initialize the `media` property with a new `Media` object. This object
    requires the filename of the audio file, and two functions: one for when various
    audio functions complete successfully (generally only when playback or recording
    has stopped), and another for when something goes wrong.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用一个新的`Media`对象初始化`media`属性。这个对象需要音频文件的文件名，以及两个函数：一个用于各种音频功能成功完成时（通常只在播放或录制停止时），另一个用于出错时。
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, we also set up our two timers to update every quarter of a second.
    These times could be made faster or slower depending upon the granularity of updates
    you like, but `250` milliseconds seems to be enough.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们也设置了两个计时器，每四分之一秒更新一次。这些时间可以根据你喜欢的更新粒度加快或减慢，但`250`毫秒似乎已经足够了。
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, like any good model, we need to provide methods to indicate our state.
    Hence, `isPlaying` and `isRecording` are used in the preceding code snippet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像任何好的模型一样，我们需要提供方法来指示我们的状态。因此，在先前的代码片段中使用了`isPlaying`和`isRecording`。
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you recall, this function is called continuously during playback and recording.
    If playing, we ask the `Media` API what the current position is, but we have to
    supply a callback method in order to actually find out what the position is. This
    should usually be called nearly instantly, but we can't guarantee it, so this
    is why we have encapsulated obtaining the position somewhat. We'll define a `getPosition()`
    method later that just looks at the `position` property instead of having to do
    the callback every time we want to know where we are in the audio file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，这个函数在播放和录制过程中会连续调用。如果在播放，我们会询问`Media` API当前的位置，但我们必须提供一个回调方法才能实际找出位置。这通常应该几乎立即完成，但我们不能保证，这就是为什么我们稍微封装了获取位置的原因。我们将在后面定义一个`getPosition()`方法，它只是查看`position`属性，而不是每次我们想知道在音频文件中的位置时都要进行回调。
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Obtaining the duration is even harder than obtaining the current position, mainly
    because it is quite possible that the `Media` API is streaming a file from the
    Internet rather than playing a local file. Therefore, the duration may take some
    time to obtain.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 获取持续时间比获取当前位置更困难，主要是因为`Media` API很可能正在从互联网上流式传输文件，而不是播放本地文件。因此，获取持续时间可能需要一些时间。
- en: For as long as the duration timer is running, we'll ask the `Media` API if it
    has a duration for the file yet. If it doesn't, it'll return `-1`. If it does
    return a value greater than `-1`, we can stop the timer, since once we get a duration,
    it isn't likely to change.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 只要持续时间计时器在运行，我们就会询问`Media` API是否已经有了文件的持续时间。如果没有，它会返回`-1`。如果它确实返回一个大于`-1`的值，我们可以停止计时器，因为一旦我们得到持续时间，它不太可能改变。
- en: There's no need to keep asking for the duration forever, especially if we can't
    determine the duration, so we use the negative numbers `-1` to `-20` of our `duration`
    property as a kind of timeout. We subtract one each time we fail to obtain a valid
    duration, and if we go below `-20`, we give up by stopping the timer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要永远不断地询问持续时间，特别是如果我们无法确定持续时间，所以我们使用`duration`属性的`-1`到`-20`的负数作为超时。每次我们未能获取有效的持续时间，我们就减去一，如果我们低于`-20`，我们就停止计时器放弃。
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Getting the playback position is now simple, we just return our own `position`
    property. But sometimes we need to change the current playback position. To do
    this, we use the `seekTo()` method of the `Media` API to adjust the position.
    For whatever reason, the position used in the `seekTo()` method is in milliseconds,
    while the position we obtain constantly with our timer is in seconds, hence the
    multiplication by `1000`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 获取播放位置现在很简单，我们只需返回自己的`position`属性。但有时我们需要更改当前的播放位置。为此，我们使用`Media` API的`seekTo()`方法来调整位置。由于任何原因，`seekTo()`方法中使用的位置是以毫秒为单位的，而我们的计时器不断获取的位置是以秒为单位的，因此需要乘以`1000`。
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Starting playback is actually very simple: once we initialize the object, we
    just call the `play()` method on it. Playback will start as soon as possible.
    We also set our state properties to indicate that we are playing.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 开始播放实际上非常简单：一旦我们初始化对象，我们只需在它上面调用`play()`方法。播放将尽快开始。我们还设置我们的状态属性以指示我们正在播放。
- en: 'Once playing, we can also pause easily: we just have to call the `pause()`
    method. We update our state to reflect that we are paused as well.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始播放，我们也可以轻松暂停：我们只需调用`pause()`方法。我们更新我们的状态以反映我们已经暂停。
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since media files can consume a lot of memory, whenever they aren't in use,
    they should be released from memory. When we release the file, we also need to
    stop the timers, if running).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于媒体文件可能会消耗大量内存，因此当它们不再使用时，应该从内存中释放。当我们释放文件时，如果计时器正在运行，我们还需要停止计时器。
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Stopping playback is quite simple: just call the `stop()` method instead of
    the `pause() method`. The difference between the two is that pausing playback
    allows a subsequent call to the `play() method` to resume immediately where we
    paused. Calling the `stop()` method will reset our position to zero, so the next
    `play()` method will start from the beginning.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 停止播放相当简单：只需调用`stop()`方法而不是`pause()`方法。两者之间的区别在于，暂停播放允许后续调用`play()`方法立即从暂停的位置继续。调用`stop()`方法将重置我们的位置为零，因此下一个`play()`方法将从开头开始。
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Recording is similarly easy: we just call `startRecord()` or `stopRecord()`.
    There is no functionality for providing support for pausing in the middle of recording.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 录音同样简单：我们只需调用`startRecord()`或`stopRecord()`。在录音过程中没有提供暂停的功能。
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our `failure` method is pretty simple. If an error occurs, we'll log it, and
    then call the `failure` method given when creating this object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`failure`方法相当简单。如果发生错误，我们将记录它，然后调用在创建此对象时给出的`failure`方法。
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `success` function is even simpler: we just call the `completion()` method
    passed in when creating the object.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`success`函数甚至更简单：我们只需调用在创建对象时传入的`completion()`方法。'
- en: What did we do?
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we created the data model for a specific audio file as well as
    the methods for initiating, pausing, and stopping playback, and those for initiating
    and stopping recording.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们创建了特定音频文件的数据模型以及启动、暂停和停止播放的方法，以及启动和停止录音的方法。
- en: What else do I need to know?
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: The `completion` method is generally called at the end of playback, though it
    can be called for other reasons as well. In general, one would use this to clean
    up the media object, but if it is called when not expected, the result would be
    an abrupt stop of playback.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`completion`方法通常在播放结束时调用，尽管也可以出于其他原因调用。通常，人们会使用这个来清理媒体对象，但如果在预期之外调用，结果将是播放的突然停止。'
- en: 'The other important issue is that each platform supports only certain media
    files for playback and even different ones for recording. Here''s a short list:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的问题是，每个平台只支持某些媒体文件进行播放，甚至对于录音支持不同的文件。以下是一个简短的列表：
- en: '| Platform | Plays | Records |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | 扮演 | 记录 |'
- en: '| --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| iOS | WAV | WAV |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| iOS | WAV | WAV |'
- en: '| Android | MP3,WAV, 3GR | 3GR |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| Android | MP3,WAV, 3GR | 3GR |'
- en: Implementing gesture support
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现手势支持
- en: Gestures are a critical component of most mobile platforms these days, and users
    expect the apps they use to support them. A gesture can be fairly elaborate (say,
    drawing a shape, or using multiple fingers) or simple (just pressing an item for
    a certain time), but it is necessary that you get used to the idea.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 手势现在是大多数移动平台的一个关键组件，用户期望他们使用的应用程序支持它们。一个手势可以相当复杂（比如，绘制一个形状，或使用多个手指），或者很简单（只需按住一个项目一段时间），但重要的是你要习惯这个想法。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: When working on the device using native code, gesture recognition is typically
    provided to us nearly for free. That is, the framework provided by the OS does
    the hard work of recognizing a gesture.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用原生代码在设备上工作时，手势识别通常几乎免费提供给我们。也就是说，操作系统提供的框架完成了识别手势的繁重工作。
- en: Unfortunately, with PhoneGap, we lose that for free part and have to implement
    our gestures on our own. That's where `ui-gestures.js` in the `www/framework`
    directory comes in. Go ahead and open it up so that we can walk through some of
    what it does.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用 PhoneGap，我们失去了这部分免费服务，不得不自己实现手势。这就是 `www/framework` 目录中的 `ui-gestures.js`
    发挥作用的地方。请打开它，这样我们可以了解它的一些功能。
- en: Getting on with it
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'Let''s take a look at the following code, starting at the top:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码，从顶部开始：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first thing we do is define a new namespace called `GESTURES`. Then we create
    a `SimpleGesture` class within it. `SimpleGesture` will be the basis for all single-finger
    gestures that we support, which includes a long press gesture, a horizontal swipe
    gesture, and a vertical swipe gesture.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的命名空间，称为 `GESTURES`。然后我们在其中创建一个 `SimpleGesture` 类。`SimpleGesture` 将成为我们支持的所有单指手势的基础，包括长按手势、水平滑动手势和垂直滑动手势。
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's a lot of properties that go into detecting gestures. Essentially, we
    have to keep track of where a touch first started, and then where that touch ended
    (`touchStartX`, `touchStartY`, `touchX`, `touchY`). We also need to know how far
    away that final touch was from when it started (`deltaX`, `deltaY`, `distance`).
    In order to prevent gestures from being recognized when someone holds their finger
    on the screen for a long time to slowly scroll through a list, we also track the
    duration of the touch. If it goes for too long, we refuse to detect a gesture
    and possibly interrupt the user performing some other operation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多属性用于检测手势。本质上，我们必须跟踪触摸开始的位置，然后跟踪触摸结束的位置（`touchStartX`、`touchStartY`、`touchX`、`touchY`）。我们还需要知道最终触摸与开始时的距离（`deltaX`、`deltaY`、`distance`）。为了防止在某人长时间按住屏幕以缓慢滚动列表时识别手势，我们还跟踪触摸的持续时间。如果持续时间过长，我们拒绝检测手势，并可能中断用户执行的其他操作。
- en: We also keep track of whether or not the gesture has been recognized or cancelled.
    This is done with the `_cleared` property. If `_cleared` is `true`, the gesture
    has been recognized or cancelled and must not be recognized again (until the user
    lifts their finger from the screen).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还跟踪手势是否已被识别或取消。这是通过 `_cleared` 属性完成的。如果 `_cleared` 是 `true`，则手势已被识别或取消，并且不得再次识别（直到用户从屏幕上抬起手指）。
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first step, however, is to attach all our event listeners to a particular
    element. We attach six, namely, `touchstart`, `touchmove`, `touchend`, `mousedown`,
    `mousemove`, and `mouseup`. The first three are for WebKit browsers; the last
    three are for Windows Phone browsers. (Since gesture support is part of the YASMF
    framework, it needs to support more than just iOS and Android, hence the support
    here for WP7.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第一步是把我们所有的监听器都附加到特定的元素上。我们附加了六个，分别是 `touchstart`、`touchmove`、`touchend`、`mousedown`、`mousemove`
    和 `mouseup`。前三个是为 WebKit 浏览器准备的；后三个是为 Windows Phone 浏览器准备的。（由于手势支持是 YASMF 框架的一部分，它需要支持不仅仅是
    iOS 和 Android，因此这里也支持 WP7。）
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Part of what makes the `SimpleGesture` class so flexible is that it allows the
    `recognizeGesture()` method in the prior code snippet to be overridden using `attachGestureRecognizer()`
    . This also means that as part of the default implementation, we don't recognize
    any gesture at all yet. It's just a placeholder for the recognition engines later
    on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleGesture` 类之所以如此灵活的部分原因在于它允许使用 `attachGestureRecognizer()` 方法覆盖先前代码片段中的
    `recognizeGesture()` 方法。这也意味着作为默认实现的一部分，我们目前根本不识别任何手势。它只是一个为后续识别引擎预留的占位符。'
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When a suspected gesture is in progress, we call the `updateGesture()` method
    every `100` milliseconds. It will then helpfully calculate the distance from the
    initial touch and call the `recognizeGesture()` method, assuming that a gesture
    hasn't already been recognized yet.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个疑似的手势正在进行时，我们每 `100` 毫秒调用一次 `updateGesture()` 方法。然后它将有助于计算初始触摸的距离，并调用 `recognizeGesture()`
    方法，假设在此之前尚未识别出任何手势。
- en: Try to work out how we obtain the distance; you should recognize it from your
    geometry lessons.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找出我们如何获得距离；你应该能从你的几何课程中认出它。
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we recognize a gesture or determine that there is no gesture at all, there's
    really no reason to continue tracking the fingers and such, so the preceding method
    cancels out all the timers. However, it only prevents the default actions that
    would otherwise occur (such as clicks) if the gesture itself is physically recognized
    (not just cancelled). This is because as part of the recognition process, we can
    call this method once (cancelled) or twice (recognized). The second time through
    we'll cancel all the default actions. This means that attaching gestures to elements
    won't prevent the click events from firing as long as gesture isn't recognized.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们识别一个手势或确定根本不存在手势时，实际上没有必要继续跟踪手指等，因此前述方法取消所有计时器。然而，它仅阻止了如果手势本身被物理识别（而不仅仅是取消）时本将发生的默认操作（如点击）。这是因为识别过程的一部分，我们可以调用此方法一次（取消）或两次（识别）。第二次调用时，我们将取消所有默认操作。这意味着只要手势没有被识别，将手势附加到元素上不会阻止点击事件触发。
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`eventStart()` is a fairly generic function. All it does is clear out some
    of our properties and then set others to the first touch point. It also starts
    the timer that calls the `updateGesture` method.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`eventStart()` 是一个相当通用的函数。它所做的只是清除我们的一些属性，然后将其他属性设置为第一个触摸点。它还启动了调用 `updateGesture`
    方法的计时器。'
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You may wonder why we have such similar handlers for `touchstart` and `mousedown`.
    This is because this part of the framework can technically live outside of the
    framework. That means it could recognize mouse events on a desktop computer as
    well. The other thing, however, to remember is that WP7 thinks touches are mouse
    events, not touch events, which is why we have to keep track of the difference.
    Note that we call the `eventStart()` method to do the stuff that is common to
    each methodology.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们对 `touchstart` 和 `mousedown` 有如此相似的处理程序。这是因为框架的这一部分在技术上可以存在于框架之外。这意味着它可以在台式计算机上识别鼠标事件。然而，还有另一件事需要记住，WP7
    认为触摸是鼠标事件，而不是触摸事件，这就是为什么我们必须跟踪差异。注意，我们调用 `eventStart()` 方法来完成每种方法共有的操作。
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the touch moves, `eventMove` will eventually be called by `touchMove()`
    or `mouseMove()`. Their code is pretty similar to `touchStart`/`mouseStart()`
    so we won't cover their code here. The main point is that as the touch moves around,
    the deltas are continually updated so that when `updateGesture()` is called, it
    can accurately determine the distance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当触摸移动时，`eventMove` 最终将由 `touchMove()` 或 `mouseMove()` 调用。它们的代码与 `touchStart`/`mouseStart()`
    非常相似，所以我们在这里不会介绍它们的代码。主要点是，随着触摸的移动，增量会不断更新，以便当调用 `updateGesture()` 时，可以准确地确定距离。
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When the finger is lifted from the screen, `eventEnd()` will be called from
    either `touchEnd()` or `mouseUp()`. We call `clearEvent()` to reset all the tracking
    and timers involved.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当手指从屏幕上抬起时，`eventEnd()` 将由 `touchEnd()` 或 `mouseUp()` 调用。我们调用 `clearEvent()`
    来重置所有涉及的跟踪和计时器。
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, at the end of the object creation process, we attach the events to
    the incoming element. At that point, any gesture applied to the element will be
    tracked, but not yet recognized. That''s what is covered in the next snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在对象创建过程的最后，我们将事件附加到传入的元素上。在那个时刻，任何应用于元素的手势都将被跟踪，但尚未被识别。这正是下一段代码所涵盖的内容：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Detecting a long press is probably the easiest kind of gesture. Essentially
    a long press is a touch that stays within a certain spot for a certain amount
    of time. Since humans aren't perfect, we have to allow some tolerance to how much
    a finger can wiggle during this time. Thus, we can't cancel the gesture the instant
    we detect some finger movement. That said, we should cancel the gesture if the
    finger movement goes outside of a specific radius (here we'll use 25 px), because
    the user may be doing a different gesture altogether (or none at all).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 检测长按可能是最容易的手势类型。本质上，长按是在一定时间内停留在某个特定位置上的触摸。由于人类并不完美，我们必须允许手指在这段时间内可以摆动的某些容差。因此，我们不能在检测到手指移动的瞬间取消手势。话虽如此，如果手指移动超出特定半径（这里我们将使用
    25 px），我们应该取消手势，因为用户可能正在进行完全不同的手势（或者根本没有任何手势）。
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we create a new `SimpleGesture` object. Then we're going to extend it
    using a poor man's inheritance. (It isn't really object-oriented inheritance,
    but it is good enough for what we need.)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的 `SimpleGesture` 对象。然后我们将使用一种简陋的继承方式来扩展它。（这并不是真正的面向对象继承，但对于我们的需求来说已经足够好了。）
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We then attach the `whatToDo`, `delayToRecognition`, and `delayToCancel` parameters
    to the new object. If the latter two aren't supplied, we give defaults of `3000`
    milliseconds and we'll ignore the gesture, and `1000` milliseconds to the recognition
    of a long press.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将 `whatToDo`、`delayToRecognition` 和 `delayToCancel` 参数附加到新对象上。如果后两个参数未提供，我们将默认设置为
    `3000` 毫秒，并且忽略手势，以及将 `1000` 毫秒用于长按的识别。
- en: '`whatToDo` must be a function; we''ll call it if the gesture is recognized.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`whatToDo` 必须是一个函数；如果识别到手势，我们将调用它。'
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here's where we override the `SimpleGesture` object's *do-nothing* recognizer
    and attach our own. If the distance between the first position and current position
    of the touch is less than 25 px, we'll consider looking at the gesture. Then the
    duration of the gesture must be longer than the `delayToRecognition` (1000 milliseconds
    default) parameter, but not longer than the `delayToCancel` (3000 milliseconds
    default) parameter. If we fall in between, we'll clear the event and call `whatToDo()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们覆盖了 `SimpleGesture` 对象的 *do-nothing* 识别器，并附加了我们自己的识别器。如果触摸的第一个位置和当前位置之间的距离小于
    25 px，我们将考虑查看这个手势。然后手势的持续时间必须长于 `delayToRecognition`（默认为 1000 毫秒）参数，但不能长于 `delayToCancel`（默认为
    3000 毫秒）参数。如果我们处于两者之间，我们将清除事件并调用 `whatToDo()`。
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: On the other hand, if the distance is more than 25 px, the person isn't doing
    a long press. They're doing something else, so we cancel the gesture entirely.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果距离超过 25 px，那么这个人不是在进行长按。他们正在做其他事情，因此我们完全取消手势。
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Horizontal swipes are a little more complicated, but not by too much. First,
    we need to have a definition of horizontal. Again, the human finger is likely
    to wobble and wiggle a bit when making the gesture. We also need a minimum length;
    a movement horizontally of a couple pixels shouldn't be enough to trigger the
    gesture. Here we define a horizontal swipe as any swipe longer than 50 px and
    one that doesn't vary along the vertical axis by more than 25 px in either direction
    (50 px total).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 水平滑动稍微复杂一些，但并不太多。首先，我们需要有一个水平方向的定义。同样，当人们做出手势时，手指可能会轻微晃动和扭动。我们还需要一个最小长度；水平方向上移动几个像素不应该足以触发手势。在这里，我们将水平滑动定义为任何长度超过
    50 px 的滑动，并且垂直方向上没有超过 25 px 的变化（总共 50 px）。
- en: We also do away with the `delayToRecognition` we used for long presses – that's
    where the length of the swipe comes into play.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还取消了用于长按的 `delayToRecognition`，这是滑动长度发挥作用的地方。
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Just like for our long press, we'll create the new gesture from a `SimpleGesture`
    object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的长按一样，我们将从 `SimpleGesture` 对象创建新的手势。
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then we attach the various parameters. The `radiusToRecognition` parameter is
    really the length of the swipe. Anything inside that radius won't be considered
    at all, but anything outside the radius is long enough to be considered.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们附加各种参数。`radiusToRecognition` 参数实际上是滑动的长度。半径内的任何东西都不会被考虑，但半径外的任何东西都足够长，可以被考虑。
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The recognizer itself is pretty easy; the distance between the first and current
    point must be greater than the `radiusToRecognition` parameter, the duration must
    not be longer than the `delayToCancel` (3000 milliseconds by default) parameter,
    and the finger must not have gone up or down more than `25` px from that first
    touch. If all these conditions are met, we've had a horizontal swipe, and we clear
    the event and call `whatToDo()`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 识别器本身相当简单；第一个点和当前点之间的距离必须大于 `radiusToRecognition` 参数，持续时间不能超过 `delayToCancel`（默认为
    3000 毫秒）参数，并且手指从第一次触摸点起不能上下移动超过 `25` px。如果所有这些条件都满足，我们就检测到了水平滑动，然后清除事件并调用 `whatToDo()`。
- en: The vertical swipe is essentially identical except that instead of using `deltaY`
    in the earlier code, it uses `deltaX`. A vertical swipe is only valid if the finger
    doesn't vary on the horizontal axis by more than `25` px on either side. Since
    they are so similar, we won't go over the code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直滑动本质上与之前代码中的使用 `deltaY` 相同，只是它使用的是 `deltaX`。只有当手指在水平轴上没有超过 `25` px 的变化时，垂直滑动才是有效的。由于它们非常相似，我们不会详细讲解代码。
- en: What did we do?
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we've looked at how to recognize three simple gestures, namely,
    the long press gesture, the horizontal swipe gesture, and the vertical swipe gesture.
    In the next task, we'll implement the gesture recognizers in order to provide
    the various actions we can perform on a document, such as copying, renaming, or
    deleting them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们探讨了如何识别三种简单的手势，即长按手势、水平滑动手势和垂直滑动手势。在下一个任务中，我们将实现手势识别器，以便提供我们可以在文档上执行的各种操作，例如复制、重命名或删除它们。
- en: Implementing the main view
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现主视图
- en: 'Our main view is pretty simple visually, but it is definitely complex underneath.
    Let''s take a look at how the final result will appear. First, this is how it
    looks when recording:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主视图在视觉上相当简单，但下面却绝对复杂。让我们看看最终结果将如何呈现。首先，这是录制时的样子：
- en: '![Implementing the main view](img/9403_05_06.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![实现主视图](img/9403_05_06.jpg)'
- en: 'Next, this is how it looks after the recording:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是录制后的样子：
- en: '![Implementing the main view](img/9403_05_07.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![实现主视图](img/9403_05_07.jpg)'
- en: 'If we swipe on the newly recorded item, we get the **Delete** button as shown
    in the next screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在新录制的项上滑动，我们会在下一个屏幕截图中看到**删除**按钮：
- en: '![Implementing the main view](img/9403_05_08.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![实现主视图](img/9403_05_08.jpg)'
- en: 'If we long press on the recorded item, the following screen will appear:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们长按录制的项，会出现以下屏幕：
- en: '![Implementing the main view](img/9403_05_09.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![实现主视图](img/9403_05_09.jpg)'
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Go ahead and open the `documentsView.js` file in `www/views` so that you can
    follow along.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请打开`www/views`中的`documentsView.js`文件，以便您可以跟随操作。
- en: Getting on with it
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'Let''s first go over the HTML for our view. The first portion (with class `viewBackground`)
    is like all the previous projects, so we''ll skip that portion and go straight
    to the template that shows each list item on the screen, seen in the following
    code block:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看视图的HTML。第一部分（带有`viewBackground`类）与所有之前的项目类似，所以我们将跳过这部分，直接查看以下代码块中显示的屏幕上每个列表项的模板：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This template is similar to, though not exactly like, the template we used in
    prior projects. What we've done is to change the `documentImage` class of the
    `div` element into the state of the document. If it shows a *play* icon, this
    particular item can be tapped to start playback. If it shows *pause*, it can be
    tapped to pause playback.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板与之前项目中使用的模板类似，但并不完全相同。我们所做的是将`div`元素的`documentImage`类更改为文档的状态。如果它显示一个**播放**图标，则可以点击该特定项以开始播放。如果显示**暂停**，则可以点击以暂停播放。
- en: The **Delete** button is contained within the `documentActions` class of the
    `div` element (which is hidden by default). When tapped, it'll call `deleteDocument()`
    with the index of the item tapped.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除**按钮包含在`div`元素的`documentActions`类中（默认情况下是隐藏的）。当点击时，它会调用带有被点击项索引的`deleteDocument()`。'
- en: All the other elements, such as the `title`, call `documentContainerTapped()`.
    This allows tapping on everything except the **Delete** button when visible to
    *start* or *pause* playback. If we didn't have these `onclick` handlers everywhere,
    some elements would not respond to touch like we would expect.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他元素，如`title`，调用`documentContainerTapped()`。这允许在可见时点击除**删除**按钮以外的任何内容以**开始**或**暂停**播放。如果我们没有在这些地方使用`onclick`处理程序，一些元素可能不会像我们预期的那样响应用户触摸。
- en: 'Now let''s go over how the view works:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来了解一下视图的工作原理：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So far, pretty much the same as previous projects.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，与之前的项目的实现几乎相同。
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, however, we begin to diverge. We need to store both the current item that
    is playing and an index to that item. If we didn't, and we tapped two or more
    items, we'd end up with all of those items playing at once. Instead, we need to
    stop the previous item and start the tapped item so that only one audio file is
    playing at one time.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里我们开始有所不同。我们需要存储当前播放的项及其索引。如果我们不这样做，并且我们点击两个或多个项，最终所有这些项都会同时播放。相反，我们需要停止之前的项并开始点击的项，以确保一次只播放一个音频文件。
- en: 'We''ll skip over initializing the view, since it''s like all the other projects.
    Instead, we''ll look at the `documentContainterTapped()` method in the following
    code snippet:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过初始化视图，因为它与其他所有项目类似。相反，我们将查看以下代码片段中的`documentContainterTapped()`方法：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, we check to see if the index (`idx`) is the same as the currently playing
    file. If it is, we need to pause (or resume) it. We don't want to release any
    resources or stop the file – otherwise when the item is tapped again, playback
    will start all over. We also set the image of the particular item to either the
    *play* or *pause* icon as appropriate.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查索引 (`idx`) 是否与当前播放的文件相同。如果是，我们需要暂停（或恢复）它。我们不希望释放任何资源或停止文件——否则当项目再次被点击时，播放将从头开始。我们还根据需要将特定项目的图像设置为**播放**或**暂停**图标。
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the index (`idx`) is different, we first check to see if anything's currently
    playing (or paused). If it is, we release those resources so that we aren't keeping
    on to them when we're going to start playing a different item.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引 (`idx`) 不同，我们首先检查是否有任何内容正在播放（或暂停）。如果有，我们释放这些资源，这样在我们开始播放不同项目时就不会继续占用它们。
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next we create a new `VoiceRecDocument` function and start the playback.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的 `VoiceRecDocument` 函数并开始播放。
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `mediaSuccess()` method, which is passed when creating the `VoiceRecDocument`
    function earlier, is generally called whenever the audio file is forcibly stopped
    (not paused) or stops on its own. Since we don't provide our own *stop* method
    visually, we can safely assume that the file has stopped playing on its own. When
    that is the case, we release the resources so that the file isn't taking up any
    memory when it isn't being played.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `VoiceRecDocument` 函数时传递的 `mediaSuccess()` 方法，通常在音频文件被强制停止（未暂停）或自行停止时调用。由于我们没有提供自己的**停止**方法，我们可以安全地假设文件是自行停止播放的。在这种情况下，我们释放资源，这样当文件没有播放时就不会占用任何内存。
- en: 'Next, we''re going to skip to the `documentIterator()` method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将跳转到 `documentIterator()` 方法：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This first portion is fairly self-explanatory. We assign the title of the item
    to the file name (minus the path and extension), we assign the indexes, and then
    also fill in the word `delete` whenever we come across it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分相当直观。我们将项目的标题分配给文件名（减去路径和扩展名），分配索引，并在遇到 `delete` 时填写该单词。
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, we delay for a short time to make sure the DOM has had time to process
    all the new items before we go on to working with them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们延迟一段时间，以确保在继续处理新项目之前，DOM 已经有时间处理所有新项目。
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each element we created needs to have two gestures applied: a long press gesture
    and a horizontal swipe gesture. So first we look up the element using the preceding
    code snippet.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的每个元素都需要应用两个手势：一个长按手势和一个水平滑动手势。因此，我们首先使用前面的代码片段查找元素。
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, we create the long press gesture and attach it to the element. When the
    gesture is recognized, we'll call `longpressReceived()` with `o.data`. This data
    is what we set in the next line; it'll be the index of the item that has been
    long pressed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建长按手势并将其附加到元素上。当手势被识别时，我们将使用 `o.data` 调用 `longpressReceived()`。这些数据是我们下一行设置的数据；它将是长按的项目索引。
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Assigning a horizontal swipe gesture is much the same, except we call `horizontalSwipeReceived`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 分配水平滑动手势的过程几乎相同，只是我们调用 `horizontalSwipeReceived`。
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When a long press is received, we''ll call the preceding method. We''ll create
    a confirmation pop up with three possible actions: `Copy`, `Rename`, and `Cancel`.
    We''ve modified the framework a little to support more than two buttons on a pop
    up, so don''t worry that they''ll be crowding anything out.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到长按时，我们将调用前面的方法。我们将创建一个带有三个可能操作的确认弹出窗口：`复制`、`重命名`和`取消`。我们稍微修改了框架以支持弹出窗口上的按钮超过两个，所以不用担心它们会占用太多空间。
- en: If the user taps **Copy**, we'll call the `copyDocument()` method, and if they
    tap **Rename**, we'll call `renameDocument()`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击**复制**，我们将调用 `copyDocument()` 方法，如果他们点击**重命名**，我们将调用 `renameDocument()`。
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When a horizontal swipe is received, however, we do something different: we
    want to either display or hide the **Delete** button for that item. We can see
    if it is visible by checking the `style.display` property. We''ve taken the route
    of setting the `opacity` and `display` to show or hide it. This may not exactly
    match the native methodology (iOS slides this button in, for example), but it
    works well enough.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当接收到水平滑动时，我们会做不同的事情：我们希望显示或隐藏该项目的**删除**按钮。我们可以通过检查 `style.display` 属性来查看它是否可见。我们已经采取了设置
    `opacity` 和 `display` 来显示或隐藏它的方法。这可能并不完全符合原生方法（例如，iOS 会滑动此按钮），但它效果很好。
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Recording is probably the most complicated and difficult thing to get right.
    After all, each platform has different recording types that they support, but
    they also have their own quirks (such as whether or not the file must already
    exist or not).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 录制可能是最复杂且最难做正确的事情。毕竟，每个平台都支持不同的录制类型，但它们也有自己的怪癖（例如，文件是否必须已经存在）。
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First, we create the new document with the desired filename; we ask the user
    this in the `createDocument()` method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用期望的文件名创建新文档；我们在`createDocument()`方法中询问用户。
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Next, we display a simple alert that has the microphone image in it and a **Stop**
    button. (That `_` at the end tells the alert to let the button fill the entire
    alert's width so that it is easier to tap.) When the user taps the **Stop** button,
    we'll stop recording and release all the resources. We also have to reload the
    documents so that the user can tap on it to play it back if they want.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们显示一个包含麦克风图像和**停止**按钮的简单警告框。（结尾的`_`表示让按钮填充整个警告框的宽度，这样更容易点击。）当用户点击**停止**按钮时，我们将停止录制并释放所有资源。我们还需要重新加载文档，以便用户可以点击它来播放，如果他们想的话。
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here we take advantage of one important fact of our pop-up system—they don't
    block our script execution. That means, we can be showing the alert and then continue
    to do other work, in this case, recording.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了弹出系统的一个重要事实——它们不会阻塞我们的脚本执行。这意味着，我们可以在显示警告框的同时继续做其他工作，在这种情况下，就是录制。
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That was the easy part; getting ready to record is the hard part. We do this
    in `createNewDocument()`, which is called when the **REC** button is tapped.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分很简单；准备录制是难点。我们在`createNewDocument()`中做这件事，当按下**REC**按钮时会被调用。
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Like always, we ask the user to give us a new name for the document. Here we
    use `Memo` and the date.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们要求用户为我们文档提供一个新名称。这里我们使用`Memo`和日期。
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'First, we figure out what type of file we can record to based on the platform,
    and then pass that to `createDocument()`. Then, we define what should happen when
    `createDocument()` succeeds:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们根据平台确定可以录制到哪种类型的文件，然后将它传递给`createDocument()`。然后，我们定义当`createDocument()`成功时应该发生什么：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If we have an existing audio file playing, we stop it. We wouldn't want it to
    interfere with recording, after all.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在播放现有的音频文件，我们会停止它。毕竟，我们不希望它干扰录制。
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Then, for iOS, we create a new file with some junk text. For some reason, the
    `Media` API requires the file to exist prior to the recording, or it will fail
    to record. The other platforms don't have this restriction.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于iOS，我们创建一个包含一些垃圾文本的新文件。由于某种原因，`Media` API 要求在录制之前文件必须存在，否则将无法录制。其他平台没有这个限制。
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That said, the file gets created anyway, and can confuse Android. So we delete
    the file entirely before recording.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，文件仍然会被创建，可能会让Android感到困惑。因此，在录制之前，我们完全删除该文件。
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Previously, we only had to worry about one type of file in the list. But when
    renaming a file, or copying a file, we need to be sensitive to the type of file
    we are working with, because we need to duplicate the file extension on the new
    name. We do this by first getting the file extension in the preceding code snippet.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此前，我们只需要担心列表中的一种文件类型。但在重命名文件或复制文件时，我们需要对正在处理的文件类型保持敏感，因为我们需要在新的名称上复制文件扩展名。我们通过在先前的代码片段中获取文件扩展名来实现这一点。
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Then, if we're renaming (or deleting) a file (we don't do this for a copy),
    we stop any playback of the file we're renaming (or deleting) prior to actually
    doing the operation.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们正在重命名（或删除）文件（我们不为此复制），我们在实际执行操作之前停止正在重命名（或删除）的文件的播放。
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Next we construct the new filename with the same extension as the old file.
    From here on out, the code is identical to the prior projects, so we won't go
    over the rest of it. The important thing here is that you must preserve the file
    extension of any file when renaming or copying it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用与旧文件相同的扩展名构建新的文件名。从现在开始，代码与先前的项目相同，所以我们将不会详细说明。这里重要的是，在重命名或复制文件时，必须保留任何文件的文件扩展名。
- en: What did we do?
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We created a view that can list the available audio files, manage their playback,
    and also record new files. We also created a long press gesture and a horizontal
    swipe gesture for each item to implement the various file management operations
    necessary.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个可以列出可用音频文件、管理它们的播放以及录制新文件的视图。我们还为每个项目创建了一个长按手势和一个水平滑动手势来实现必要的文件管理操作。
- en: Game Over..... Wrapping it up
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束..... 总结
- en: We've created a simple media recorder and playback app. It can manage all the
    files it creates (and even play a few it didn't). It also supports, for the first
    time, simple gestures, which are key to simplifying the complexity of the user
    interface.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的媒体录制和回放应用程序。它可以管理它创建的所有文件（甚至播放它没有创建的一些文件）。它还首次支持简单的手势，这对于简化用户界面的复杂性至关重要。
- en: Can you take the HEAT? The Hotshot Challenge
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能承受热度吗？热手挑战
- en: 'There are, of course, many ways you could enhance this project, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以以许多方式增强这个项目，如下所示：
- en: Pop up a simple media player view over the document view while the item is playing.
    Give the user a way to go backward and forward in the audio file.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在播放项目时，在文档视图上弹出简单的媒体播放器视图。为用户提供一种在音频文件中向前和向后跳转的方法。
- en: Create a separate view while recording that displays the duration of the recording
    in a prominent fashion.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在录制时创建一个单独的视图，以突出显示的方式显示录制时长。
- en: If you want to get really creative, add this project to the `Filer` project.
    Allow a recording to be created as a document is written on the device, and then
    when that document is later viewed, play the recording so that the user can follow
    along.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想真正发挥创意，将这个项目添加到`Filer`项目中。允许在设备上编写文档时创建录音，然后在稍后查看该文档时播放录音，以便用户可以跟随。
