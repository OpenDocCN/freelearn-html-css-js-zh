- en: 5\. Interfaces and Inheritance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 接口和继承
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to interfaces and inheritance. You will learn how
    to use an interface to shape your classes, objects, and functions. You will also
    gain an appreciation of how interfaces will help you to write better code. By
    the end of this chapter, you will be able to write better, more maintainable code
    with well-structured functions, classes, and objects, and also be able to reuse
    your existing code efficiently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍接口和继承。你将学习如何使用接口来塑造你的类、对象和函数。你还将了解接口如何帮助你编写更好的代码。在本章结束时，你将能够编写更好、更易于维护的代码，具有结构良好的函数、类和对象，并且能够有效地重用现有代码。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The previous chapter discussed classes and objects. You learned that classes
    define objects and their functionality. Classes are the blueprint followed while
    constructing these objects. Now, we will go up one level of abstraction. We are
    now going to construct interfaces. Interfaces are descriptors and allow you to
    define the structure of your object. Interfaces allow you to define contracts,
    which are rules that govern how your data is shaped.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章讨论了类和对象。你了解到类定义了对象及其功能。类是构建这些对象时遵循的蓝图。现在，我们将抽象层次提高一级。我们现在将构建接口。接口是描述符，允许你定义对象的形状。接口允许你定义契约，即规定数据形状的规则。
- en: Interfaces are important because they enable your objects to be strongly typed,
    which gives you the ability to write cleaner code. Defining the shape of your
    objects may not be much of an issue with smaller applications, but when working
    with large applications, interfaces will prove their worth as they will make it
    possible for your application to scale without your code becoming confusing and
    hard to support.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接口之所以重要，是因为它们使你的对象能够具有强类型，这让你能够编写更干净的代码。在小型应用程序中，定义对象的形状可能不是一个大问题，但当与大型应用程序一起工作时，接口将证明其价值，因为它们将使你的应用程序能够扩展，而不会使你的代码变得混乱且难以支持。
- en: Inheritance allows new objects to take the properties of existing objects, enabling
    you to extend your code functionality without having to redefine common properties.
    Inheritance will give you a better understanding of how you should structure your
    code to be more efficient and logical in your approach. This chapter will first
    address interfaces and equip you with the skills you need to use them and will
    then progress onto the topic of inheritance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 继承允许新对象继承现有对象的属性，使你能够在不重新定义公共属性的情况下扩展代码功能。继承将帮助你更好地理解如何结构化你的代码，以使你的方法更高效和逻辑。本章将首先介绍接口，并为你提供使用它们的技能，然后继续讨论继承这一主题。
- en: Interfaces
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'Here we have an example of a simple interface that defines the shape of a user object:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个定义用户对象形状的简单接口示例：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we have defined an interface that we can implement on
    any object that should follow rules defined in our interface. The advantage this
    gives us over other web languages such as vanilla JavaScript is that all objects
    that implement this interface have to follow the structure defined by the interface.
    This means that our objects are now strongly typed and have language support such
    as syntax highlighting, autocompletion, and the throwing of exceptions when implemented
    incorrectly. If you are a developer working on a large application, this is very
    important as you have defined the rules and can now be sure that all the objects
    that implement `UserInterFace` will have the same properties as those defined
    in the interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个接口，我们可以在任何应该遵循接口中定义的规则的对象上实现它。这种优势使我们与其他网络语言（如纯JavaScript）相比具有优势，即所有实现此接口的对象都必须遵循接口定义的结构。这意味着我们的对象现在是强类型的，并且具有语言支持，如语法高亮、自动完成以及在实现错误时抛出异常。如果你是一位在大型应用程序上工作的开发者，这非常重要，因为你可以定义规则，现在可以确信所有实现`UserInterface`的对象都将具有接口中定义的相同属性。
- en: 'Here is an example of an object that implements the `UserInterface` interface:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个实现`UserInterface`接口的对象示例：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in the preceding example, we are now able to implement an object
    that adheres to the guidelines defined in the `UserInterFace` interface. When
    working with large teams or on complex web applications, it is important to have
    transparent, well-understood rules for your code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们现在能够实现一个遵守 `UserInterFace` 接口定义的指南的对象。当与大型团队或复杂网络应用程序一起工作时，拥有透明、易于理解的代码规则非常重要。
- en: Interfaces allow for the creation of a common point of reference for your objects,
    a place where rules are defined on how objects should be constructed. In the following
    section, we will cover in-depth interfaces in TypeScript.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接口允许为你的对象创建一个共同的参考点，一个定义对象应该如何构建的规则的地方。在下一节中，我们将深入探讨 TypeScript 中的接口。
- en: 'Interfaces are used when you want to set up rules for how your objects, classes,
    and functions should be implemented. They are a contract that governs structure
    but not functionality. Here we have a diagram that shows an interface and its
    relationship to two classes – `User` and `Admin`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想为你的对象、类和函数的实施设置规则时，会使用接口。它们是一个合同，它规定了结构但不规定功能。这里有一个图表示接口及其与两个类（`User` 和 `Admin`）的关系：
- en: '![Figure 5.1: Relation between interface and classes'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1：接口与类之间的关系](img/B14508_05_01.jpg)'
- en: '](img/B14508_05_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_05_01.jpg)'
- en: 'Figure 5.1: Relation between interface and classes'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：接口与类之间的关系
- en: In the diagram, we have a user interface that describes how a class belonging
    to this interface should be implemented. As you can see, we have a few properties
    (highlighted code in User Interface) and methods provided in two classes. The
    interface provides only basic information for the property's name, type, method
    structures, and return types, if not void. Note that the interface provides no
    rules related to how the methods work, only how they are structured. The actual
    functionality of the methods is defined in the class itself. As stated earlier,
    interfaces in TypeScript give you the rules and you implement them as you see
    fit. This is evident from the preceding diagram. The `AdminUser` class has a method
    not defined in `UserInterface`; however, this is not an issue because the class
    is in compliance with all the elements of the interface. There is no rule that
    says that you cannot add to your class, only that you need to meet the requirements
    of the interface that your class implements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们有一个用户界面，描述了属于此接口的类应该如何实现。正如你所看到的，我们在两个类中提供了一些属性（用户界面中突出显示的代码）和方法。接口只为属性的名称、类型、方法结构和返回类型（如果不是
    void）提供基本信息。请注意，接口不提供与方法工作相关的规则，只提供它们的结构。方法的实际功能是在类本身中定义的。如前所述，TypeScript 中的接口为你提供规则，你可以根据需要实现它们。这从前面的图中很明显。`AdminUser`
    类有一个在 `UserInterface` 中未定义的方法；然而，这不是问题，因为该类符合接口的所有元素。没有规则说你不能向你的类中添加内容，只是你需要满足你的类实现的接口的要求。
- en: Case Study – Writing Your First Interface
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 – 编写你的第一个接口
- en: 'Imagine you are working with an application development team building an application
    for warehouse floor workers. You have the task of building the product creation
    classes and functions. You have developed a plan for your classes based on the
    functional requirements of your application. You start by creating a product interface
    called `ProductTemplate`. `ProductTemplate` defines the structure of our product
    object and base requirements. Note that we could also use a type object in the
    same way, and it may be preferable since this is a simple object, not a class,
    which could not be represented by a type. However, for the sake of this example
    and also to enlighten you to the fact that interfaces can also be used as types
    when defining a simple object, we have constructed the `ProductTemplate` interface:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在与一个应用开发团队一起工作，为仓库地面工作人员开发应用程序。你的任务是构建产品创建类和函数。你已经根据应用程序的功能需求为你的类制定了一个计划。你首先创建了一个名为
    `ProductTemplate` 的产品接口。`ProductTemplate` 定义了我们的产品对象的结构和基本要求。请注意，我们也可以以相同的方式使用类型对象，这可能更可取，因为这是一个简单的对象，不是一个类，不能由类型表示。然而，为了这个示例，并且为了让你明白接口也可以在定义简单对象时用作类型，我们已经构建了
    `ProductTemplate` 接口：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When defining an interface, we start with the interface keyword, followed by
    the name of our interface, `ProductTemplate`, as shown in the preceding snippet.
    We have three properties that our product requires – height, width, and color.
    Now that we have described what our product data should look like, let''s use
    it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义接口时，我们首先使用接口关键字，然后是接口的名称，`ProductTemplate`，如前文代码片段所示。我们的产品需要三个属性 – 高度、宽度和颜色。现在我们已经描述了我们的产品数据应该是什么样子，让我们使用它：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have built a function, `productMaker`, that takes a product object as an
    argument. To ensure that only objects with the properties required by our `productMaker`
    function get passed to the function, we use our `ProductTemplate` interface, as
    shown in the preceding snippet. Now, all we need to do is define our product object;
    we will use our interface there as well:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为 `productMaker` 的函数，它接受一个产品对象作为参数。为了确保只有符合我们 `productMaker` 函数所需属性的对象被传递给该函数，我们使用了我们的
    `ProductTemplate` 接口，如前文代码片段所示。现在，我们只需要定义我们的产品对象；我们也将使用该接口：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have declared a product object, `myProduct`, with our `ProductTemplate` interface
    and added the properties required by our interface. Using the interface in this
    way ensures that we are fully compliant when creating the product object. Now,
    if we add a property not defined or remove a property that is defined in our `ProductTemplate`
    interface, the IDE and or TypeScript compiler will throw a helpful error message.
    IDE highlighting will depend on your IDE and the level of support for TypeScript.
    VS Code should highlight the following error messages for the preceding two scenarios.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了一个名为 `myProduct` 的产品对象，并使用 `ProductTemplate` 接口添加了接口所需的属性。使用接口这种方式确保我们在创建产品对象时完全符合要求。现在，如果我们添加一个未定义的属性或删除
    `ProductTemplate` 接口中定义的属性，IDE 或 TypeScript 编译器将抛出一个有用的错误信息。IDE 突出显示将取决于你的 IDE
    和对 TypeScript 的支持程度。VS Code 应该突出显示前两种情况下的以下错误信息。
- en: 'The following error message appears when you add a property length that is
    not defined in the interface:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加一个接口中未定义的属性 `length` 时，会出现以下错误信息：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following error message appears when you don''t use the color property,
    which is defined in the interface:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你没有使用接口中定义的颜色属性时，会出现以下错误信息：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have our product object, let''s pass it to our productMaker function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了产品对象，让我们将其传递给 `productMaker` 函数：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you run the file using `npx` `ts-node` `Example_Interface.ts`, you will
    obtain the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用 `npx` `ts-node` `Example_Interface.ts` 运行文件，你将获得以下输出：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the ideal scenario. But what would happen if you pass an object that
    does not comply with the `ProductTemplate` interface? Consider the following code
    representing this scenario:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是理想的情况。但是，如果你传递一个不符合 `ProductTemplate` 接口的对象会发生什么呢？考虑以下代码表示这种情况：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will receive the following error message when you run the file using `tsc`
    `[filename].ts`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `tsc` 运行文件 `[filename].ts` 时，你会收到以下错误信息：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: VS Code prevents you from making such errors. If you hover over the red-underlined
    code in the VS Code window, you will see a warning similar to the preceding error message.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 会阻止你犯这样的错误。如果你在 VS Code 窗口中将鼠标悬停在红色下划线代码上，你会看到一个类似于前文错误信息的警告。
- en: 'Let''s go back to our interface example (`Example_Interface.ts`). Now, we have
    an interface for our product. Let''s do the same for our `productMaker` function.
    We want to make sure that whenever a function takes our product as an argument,
    it is constructed in the right way. Hence, we construct the following interface
    – `productInterfaceFunction`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的接口示例 (`Example_Interface.ts`)。现在，我们为产品定义了一个接口。让我们为 `productMaker` 函数做同样的事情。我们希望确保每次一个函数以我们的产品作为参数时，它都是按照正确的方式构建的。因此，我们构建了以下接口
    – `productInterfaceFunction`：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We added the function interface, `productInterfaceFunction`, just after `ProductTemplate`.
    As you can see, the syntax is simple and just defines what arguments the function
    can take and what it should return. We can now use the function interface in our
    function declaration, as shown here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `ProductTemplate` 之后添加了函数接口 `productInterfaceFunction`。正如你所见，语法很简单，只是定义了函数可以接受哪些参数以及它应该返回什么。现在我们可以在函数声明中使用函数接口，如下所示：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should again get the same output as before:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该再次得到之前相同的输出：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have now used interfaces in two ways: to shape an object and a function.
    The only issue here is that it''s not very efficient to work this way. As good
    developers, we want to be as efficient as possible and comply with object-oriented
    standards of coding. To this end, we will now refactor our code to define a class
    that will encapsulate our product properties and methods:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经以两种方式使用了接口：用于塑造一个对象和一个函数。这里唯一的问题是这种方式并不非常高效。作为优秀的开发者，我们希望尽可能高效，并遵守面向对象编程的标准。为此，我们现在将重构我们的代码，定义一个类来封装我们的产品属性和方法：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding snippet, we have built an interface for our class where we
    have defined a `product` property and the makeProduct method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们为我们的类构建了一个接口，其中我们定义了一个`product`属性和`makeProduct`方法。
- en: 'We are also making good use of the interfaces we created previously for our
    product object and `makeProduct`. Next, we will use the new interface, `ProductClassInterface`,
    to instantiate a new class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在我们的产品对象和`makeProduct`上很好地使用了之前创建的接口。接下来，我们将使用新的接口`ProductClassInterface`来实例化一个新的类：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding snippet, we are using the `implements` keyword to apply the
    interface rules to our `ProductClass`. The syntax structure is as follows: `class`
    `ProductClass` followed by the `implements` keyword, and then the interface you
    would like to apply to the class: `class ProductClass implements ProductClassInterface`.
    As you can see, this code is a bit less verbose and easy to manage. Using an interface
    to define our product class allows us to be more descriptive as we can not only
    define our class but the methods and properties associated with it.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`implements`关键字将接口规则应用到我们的`ProductClass`上。语法结构如下：`class` `ProductClass`后面跟着`implements`关键字，然后是您希望应用到类上的接口：`class
    ProductClass implements ProductClassInterface`。如您所见，这段代码更加简洁，易于管理。使用接口来定义我们的产品类使我们能够更加详细地描述，因为我们不仅可以定义我们的类，还可以定义与之相关的方法和属性。
- en: ype aliases can also be used in a similar manner, but types are more of a validator
    than a descriptor, hence it is recommended to use types more to verify objects
    returned from a function or arguments received by a function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名也可以以类似的方式使用，但类型更多的是一个验证器而不是描述符，因此建议更多地使用类型来验证函数返回的对象或函数接收的参数。
- en: 'Interfaces and types can be used together, and they should be. However, how
    they are used, where they are used, and how they are applied in code is down to
    you, as they are similar in many respects and even more so in recent updates of
    the TypeScript language. Let''s now make a product object and use our class instance, `newProduct`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和类型可以一起使用，而且应该这样使用。然而，它们的使用方式、使用位置以及如何在代码中应用，取决于您，因为它们在许多方面相似，尤其是在TypeScript语言的最新更新中。现在，让我们创建一个产品对象并使用我们的类实例`newProduct`：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding snippet, we build a product object and then pass it to our
    class's `makeProduct` function. We then console out the results, which is the
    same as before, except now our functional code is wrapped in a class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们构建了一个产品对象，并将其传递给我们的类的`makeProduct`函数。然后我们在控制台输出结果，与之前相同，但现在我们的功能代码被封装在类中。
- en: 'You will obtain the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have a basic understanding of how to implement an interface with
    TypeScript, let's build a more realistic product creation process in the following exercise.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了如何在TypeScript中实现接口，让我们在接下来的练习中构建一个更现实的产品创建过程。
- en: 'Exercise 5.01: Implementing Interfaces'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.01：实现接口
- en: 'In this exercise, we will implement an interface on an object, function, and
    class. Some of the code is verbose and you may not implement it this way in a
    real-world application. However, this exercise will expose you to the different
    ways in which you can implement interfaces in your code. We will construct a class
    that manages product objects and use interfaces to enforce rules related to how
    our class should be implemented. We will also use interfaces to shape our product
    object and class methods. In a typical web application, this code would probably
    be part of a product management interface – an inventory management application,
    for example. Alternativley, it could also be part of the product creation process,
    where you have a form that takes user data and processes it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在一个对象、函数和类上实现一个接口。部分代码可能较为冗长，你可能在现实世界的应用中不会这样实现。然而，这个练习将让你了解在代码中实现接口的不同方式。我们将构建一个管理产品对象的类，并使用接口来强制实施与类实现相关的规则。我们还将使用接口来塑造我们的产品对象和类方法。在一个典型的Web应用中，这段代码可能属于产品管理接口的一部分——例如库存管理应用。或者，它也可能是产品创建过程的一部分，其中有一个表单用于接收用户数据并处理它：
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/SR8eg](https://packt.link/SR8eg).
    For this chapter, in order to run any TypeScript file, you need to go into the
    file directory and execute `npx ts-node filename.ts`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下链接找到：[https://packt.link/SR8eg](https://packt.link/SR8eg)。为了运行本章中的任何TypeScript文件，你需要进入文件目录并执行`npx
    ts-node filename.ts`。
- en: 'Create an interface called `ProductObjectTemplate`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ProductObjectTemplate`的接口：
- en: '[PRE18]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When creating an interface or a type object for that matter, you should take
    into consideration what are the common elements your interface or type will need.
    This could be based on the application requirements or dependent only on the functionality
    the application is required to have. `ProductObjectTemplate` is a simple object
    and, in most cases, should be a type, but in order to show that interfaces can
    also be used in this way, we have opted to make it an interface. As you can see,
    we have just defined some basic properties that we may have for a product – `height`,
    `width`, and `color`.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当创建一个接口或类型对象时，你应该考虑你的接口或类型需要哪些共同元素。这可能基于应用需求，或者仅依赖于应用所需的功能。`ProductObjectTemplate`是一个简单的对象，在大多数情况下应该是一个类型，但为了展示接口也可以这样使用，我们选择将其作为一个接口。正如你所见，我们只定义了一些可能的产品基本属性——`高度`、`宽度`和`颜色`。
- en: 'Using the interface defined in the preceding step, define a function called
    `ProductClass`Template:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面步骤中定义的接口，定义一个名为`ProductClassTemplate`的函数：
- en: '[PRE19]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding step, we used an interface to define a function and, by doing
    this, we are providing the rules on what arguments your function can take. This
    will ensure that any implementation of this function will only take `ProductObjectTemplate`
    as an argument.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们使用接口定义了一个函数，通过这样做，我们提供了函数可以接受哪些参数的规则。这将确保任何对这个函数的实现都只会接受`ProductObjectTemplate`作为参数。
- en: 'Build an interface for a class called `ProductClassTemplate`. Reuse `ProductFunctionTemplate`
    and `ProductObjectTemplate` in your new class:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为名为`ProductClassTemplate`的类构建一个接口。在你的新类中重用`ProductFunctionTemplate`和`ProductObjectTemplate`：
- en: '[PRE20]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding step, we are reusing the function and product interfaces defined
    in *Steps 1 and 2* to build our class interface. We can simplify the code in this
    step because we are reusing interfaces that we created in the first two steps.
    *Step 3* is a good example of how you can build complexity while also making your
    code less verbose.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们正在重用*步骤1和2*中定义的函数和产品接口来构建我们的类接口。我们可以简化这一步骤的代码，因为我们正在重用我们在前两个步骤中创建的接口。*步骤3*是一个很好的例子，说明了你如何在构建复杂性的同时使代码更加简洁。
- en: 'Create a `Product` class and implement our class interface:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Product`类并实现我们的类接口：
- en: '[PRE21]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this preceding step, we created our class implementing the `ProductClassTemplate`
    interface. This will ensure that our class adheres to the rules defined in our
    interface. We are also reusing the `ProductTemplate` interface to verify that
    our class method takes the right arguments and returns the correct data. In the
    previous steps, we did a bit of prep work setting up interfaces, and now we can
    reuse them in our code base, making the overall code easier to write, well supported,
    and understandable.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此之前的步骤中，我们创建了一个实现`ProductClassTemplate`接口的类。这将确保我们的类遵守接口中定义的规则。我们还重用了`ProductTemplate`接口来验证我们的类方法是否接受正确的参数并返回正确的数据。在前面的步骤中，我们做了一些准备工作来设置接口，现在我们可以在代码库中重用它们，使整体代码更容易编写、更容易支持和理解。
- en: 'Instantiate our class as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实例化我们的类：
- en: '[PRE22]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here again, we are making use of an interface, `ProductClassTemplate` to ensure
    the class we implement matches our ruleset.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用接口`ProductClassTemplate`来确保我们实现的类符合我们的规则集。
- en: If we try to call `makeProduct` with an empty object, we get a helpful error
    message we can use to resolve our issue. Feel free to perform a test to make sure
    that your interfaces are working as they should. Here, we have the correct implementation
    of our class instance method, `makeProduct`.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们尝试使用空对象调用`makeProduct`，我们会得到一个有用的错误消息，我们可以用它来解决我们的问题。请随意进行测试以确保你的接口按预期工作。在这里，我们有我们类实例方法`makeProduct`的正确实现。
- en: 'Call the `makeProduct` method and provide a valid product object as defined
    in our product interface:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`makeProduct`方法并提供一个符合我们产品接口定义的有效产品对象：
- en: '[PRE23]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Call the `allProducts` method and console out the results:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`allProducts`方法并将结果输出到控制台：
- en: '[PRE24]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `allProducts` method returns an array of products. This would be the equivalent
    of an API call that returns a list of products to your frontend.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`allProducts`方法返回一个产品数组。这相当于一个API调用，返回产品列表到你的前端。'
- en: 'Now, console out the results of the `allProducts` method:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输出`allProducts`方法的结果：
- en: '[PRE25]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the file by executing `npx` `ts-node` `Exercise01.ts`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`npx ts-node Exercise01.ts`来运行文件。
- en: 'You will obtain the following output:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '[PRE26]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once you have followed the steps correctly, your output should be an array or
    product object as shown in the preceding screenshot. Interfaces provide you with
    the means to define contracts that govern how your code should be implemented,
    which is the point of a strongly typed language such as TypeScript and its main
    advantage over JavaScript. By using interfaces as shown in the exercise, we now
    have code that is less prone to errors and easier to support when working with
    large applications or on a large team. Interfaces can be invaluable to the development
    process if they are implemented correctly.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦正确遵循了步骤，你的输出应该是一个数组或产品对象，如前一张截图所示。接口为你提供了定义合约的手段，这些合约规定了你的代码应该如何实现，这正是强类型语言如TypeScript及其相对于JavaScript的主要优势所在。通过在练习中使用接口，我们现在有了更不容易出错且在处理大型应用程序或大型团队时更容易支持的代码。如果正确实现，接口对于开发过程可能非常有价值。
- en: 'Exercise 5.02: Implementing Interfaces – Creating a Prototype Blogging Application'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.02：实现接口 – 创建原型博客应用程序
- en: Imagine that you are a developer working on a social networking site. You are
    tasked with setting up a blogging system that will allow users to post to the
    site. The project is intended to scale up globally, so it will be quite large.
    Hence, your code needs to be well defined with all the necessary contexts. The
    main theme here is context. You are coding in a manner that will lead to bug-free
    code that is well supported and understood.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一名正在社交网站上工作的开发者。你被分配了一个任务，即设置一个博客系统，允许用户在网站上发布内容。该项目旨在全球范围内扩展，因此它将非常大。因此，你的代码需要定义得很好，包含所有必要的上下文。这里的主要主题是上下文。你正在编写代码的方式将导致无错误的代码，且易于支持和理解。
- en: 'First, we start with the main object – the blog post. In order to build a blogging
    system, we need to define what a blog post is. Because this is a simple object,
    we create a type alias, `BlogPost`. As mentioned previously, we can use an interface
    to define this object, but types are more suited to simple, non-complex objects.
    A type is more of a descriptor of a unit of something, for example, a number or
    a string, while an interface is more like directions on how to interact with something,
    not what it is:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从主对象开始——博客帖子。为了构建一个博客系统，我们需要定义什么是博客帖子。因为这个对象很简单，我们创建了一个类型别名，`BlogPost`。如前所述，我们可以使用接口来定义此对象，但对于简单、非复杂对象来说，类型更合适。类型更像是描述某个单元的描述符，例如，一个数字或一个字符串，而接口更像是如何与某个东西交互的指示，而不是它是什么：
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/6uFmG](https://packt.link/6uFmG).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码文件的代码可以在此处找到：[https://packt.link/6uFmG](https://packt.link/6uFmG)。
- en: 'Define a blog type as shown in the following snippet:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码片段定义博客类型：
- en: '[PRE27]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create an interface called `AddToPost`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AddToPost`的接口：
- en: '[PRE28]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This interface will serve as the main interface for the method we will use to
    add to our blog list. As we elaborated in the previous exercise, the `AddToPost`
    interface defines how we will interact with our main method and also what it will
    return when called.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此接口将作为我们将用于添加到我们的博客列表的方法的主要接口。正如我们在前面的练习中所阐述的，`AddToPost`接口定义了我们将如何与我们的主要方法交互，以及当调用时它将返回什么。
- en: 'Create an interface to define a class, `BlogPostClass`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接口来定义一个类，`BlogPostClass`：
- en: '[PRE29]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we define our class interface. We know we need a place to hold our blogs,
    so we define an `allPost` global object that is of the `BlogPost` type array.
    We also define a method, `addToPost`, that implements the `AddPost` interface.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们定义我们的类接口。我们知道我们需要一个地方来存放我们的博客，因此我们定义了一个`allPost`全局对象，它是一个`BlogPost`类型数组。我们还定义了一个方法，`addToPost`，它实现了`AddPost`接口。
- en: 'Create a class called `blogPostClass` that implements the `blogPostClass` interface:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`blogPostClass`的类，该类实现了`blogPostClass`接口：
- en: '[PRE30]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding class, we reuse our type to enforce and validate. The logic
    of the `addToPost` method is up to you, the developer. In this step, the code
    implements the method once it adheres to the interface by taking an argument of
    the `BlogPost` type and returns a `BlogPost` array.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的类中，我们重用我们的类型来强制和验证。`addToPost`方法的逻辑取决于你，开发者。在此步骤中，代码通过接受一个`BlogPost`类型的参数并返回一个`BlogPost`数组来实现方法，一旦它符合接口。
- en: 'Create an instance of `blogPostClass`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`blogPostClass`的实例：
- en: '[PRE31]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Build three objects of the `BlogPost` type:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`BlogPost`类型的三个对象：
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This step simulates a user posting to your blog site. In a real-world application,
    this will be a web form that creates the object when submitted.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此步骤模拟用户向您的博客网站发布帖子。在实际应用中，这将是一个表单，当提交时创建对象。
- en: 'Call the `addToPost` method three times and pass the post objects you created
    in *Step 6*:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`addToPost`方法三次，并传递你在*步骤 6*中创建的帖子对象：
- en: '[PRE33]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In an actual web application, the call to `addToPost` would entail making an
    API call to send the updated data to the backend of your application, but for
    the purpose of this exercise, we are just updating an array. If, for example,
    you are using some kind of state management for your frontend, the preceding code
    could look very similar to the state management handling the backend updates.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实际的Web应用中，对`addToPost`的调用将涉及向应用程序的后端发送更新数据的API调用，但在此练习中，我们只是更新一个数组。例如，如果你正在使用某种前端状态管理，前面的代码可以非常类似于处理后端更新的状态管理。
- en: 'Console out the `allPost` global from the class instance created in *Step 5*:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建的类实例中控制台输出`allPost`全局对象，*步骤 5*：
- en: '[PRE34]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Run the file by executing `npx ts-node Exercise02.ts`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`npx ts-node Exercise02.ts`来运行文件。
- en: 'You should see the following output:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE35]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Exercise 5.03: Creating Interfaces for a Function for Updating a User Database'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.03：为更新用户数据库的函数创建接口
- en: 'As part of a web app developer team, you have been tasked with building an
    interface for a function that will update a user database. In a real-world application,
    this function might be part of a user registration form that updates a user database
    via an API call. The requirements are simple: the function should take an argument
    of the `User` type, which consists of `email` and `userId` properties.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网络应用开发团队的一员，你被分配了一个任务，即构建一个用于更新用户数据库的接口。在现实世界的应用中，这个函数可能是用户注册表单的一部分，通过API调用更新用户数据库。要求很简单：该函数应接受一个`User`类型的参数，该类型包含`email`和`userId`属性。
- en: 'For the sake of this exercise, assume that you are just working out the logic
    of the function and that the code is just temporary for testing purposes before
    you implement it in your working application. As such, we will have an array that
    will represent the database, which will be preloaded with some user objects:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个练习，假设你只是在处理函数的逻辑，并且代码只是在你将其实现到你的工作应用之前的测试目的。因此，我们将有一个表示数据库的数组，它将预先加载一些用户对象：
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/XLIz9](https://packt.link/XLIz9).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在以下位置找到：[https://packt.link/XLIz9](https://packt.link/XLIz9)。
- en: 'Create a user type with `email` and `userId` properties, as shown here:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有`email`和`userId`属性的`User`类型，如下所示：
- en: '[PRE36]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating a user type allows you to simplify your function interface. Now, you
    can reuse your `User` type when defining your interface in the next step.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个用户类型可以简化你的函数接口。现在，你可以在定义下一步的接口时重用`User`类型。
- en: 'Build a function interface called `SuperAddMe`, as shown here:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立一个名为`SuperAddMe`的函数接口，如下所示：
- en: '[PRE37]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In doing this, we have defined how we will interact with our function. This
    is a small thing, but now, all functions of this type will have set rules. We
    will know what it needs and what it will return.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这样做，我们定义了我们如何与我们的函数交互。这是一件小事，但现在，所有此类函数都将有明确的规则。我们将知道它需要什么以及它将返回什么。
- en: 'Initialize an array of the `User` type and populate it with a few users:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个`User`类型的数组，并填充一些用户：
- en: '[PRE38]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This array will simulate a database of users that we will add to.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此数组将模拟我们将要添加的用户数据库。
- en: 'Define a function of the `SuperAddMe` interface type:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`SuperAddMe`接口类型的函数：
- en: '[PRE39]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When implementing a function in this way, you must first declare it as being
    of the interface type, which in this case is the `SuperAddMe` interface. Next,
    use the function variable and assign a function to it that adheres to the specification
    of our interface. This implementation is very similar to a type assignment, but
    because of the complexity of the function, an interface is used. Also, note that
    this code could be simplified by doing the declaration and assignment on one line,
    but in order to show the process and make it more readable, the assignment is
    implemented in parts.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以这种方式实现函数时，你必须首先将其声明为接口类型，在这个例子中是`SuperAddMe`接口。接下来，使用函数变量，并分配一个符合我们接口规范的函数给它。这种实现与类型赋值非常相似，但由于函数的复杂性，使用了接口。此外，请注意，此代码可以通过在一行中完成声明和赋值来简化，但为了展示过程并使其更易于阅读，赋值被分部分实现。
- en: 'Display the results of a call to a new function, `adduser`, and pass a user
    object of the `User` type. Console out the results to show that the code is working:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示对新函数`adduser`的调用结果，并传递一个`User`类型的用户对象。将结果输出到控制台以显示代码正在工作：
- en: '[PRE40]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the code using the `npx ts-node` command. You should see the following output:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npx ts-node`命令运行代码。你应该看到以下输出：
- en: '[PRE41]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Activity 5.01: Building a User Management Component Using Interfaces'
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.01：使用接口构建用户管理组件
- en: 'Imagine that you are working on a web application and are tasked with building
    a user management component. You need to build a class to encapsulate the user
    management aspects of the application and, because you are a good developer, you
    will be using interfaces to ensure that your code is easy to reuse and support.
    For this activity, you can assume that your user interface will have at least
    three properties: email, token, and loginAt. These properties relate to a user''s
    email ID, the web token, and the time on the system when the user logged in.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在开发一个网络应用，并被分配构建用户管理组件的任务。你需要构建一个类来封装应用的用户管理方面，并且作为一个优秀的开发者，你会使用接口来确保你的代码易于重用和支持。对于这个活动，你可以假设你的用户接口至少有三个属性：email、token和loginAt。这些属性与用户的电子邮件ID、网络令牌以及用户登录系统的时间相关。
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this activity can be found here: [https://packt.link/xsOhv](https://packt.link/xsOhv).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的代码文件可以在以下位置找到：[https://packt.link/xsOhv](https://packt.link/xsOhv)。
- en: 'Here are some steps that will help you to complete this activity:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些帮助你完成此活动的步骤：
- en: 'Create a user object interface with the following properties: `email : string`,
    `loginAt : number`, and `token: string`. The `loginAt` and `token` properties
    should be optional properties.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个具有以下属性的`user`对象接口：`email : string`、`loginAt : number`和`token: string`。`loginAt`和`token`属性应该是可选属性。'
- en: Build a class interface with a global property, `user`, and use the interface
    created in the preceding step to apply user object rules.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有全局属性`user`的类接口，并使用上一步创建的接口应用用户对象规则。
- en: You need to define a `getUser` method that returns the `user` object and then
    use the interface to ensure that the return object is a user object. Finally,
    define a `login` method that takes a `user` object and `password(type string)`
    as arguments. Use the `user` object interface as the `user` argument type.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要定义一个`getUser`方法，该方法返回`user`对象，然后使用接口确保返回的对象是用户对象。最后，定义一个接受`user`对象和`password(type
    string)`作为参数的`login`方法。使用`user`对象接口作为`user`参数类型。
- en: Declare a class called `UserClass` that implements the class interface from
    the preceding step. Your login method should assign the local function's `user`
    argument to the global user property and return the global user. The `getUser`
    method should return the global user.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`UserClass`的类，该类实现了先前的步骤中的类接口。你的登录方法应将本地函数的`user`参数赋值给全局`user`属性，并返回全局`user`。`getUser`方法应返回全局`user`。
- en: Create an instance of your class declared in *Step 2*.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你在*步骤2*中声明的类的实例。
- en: Create a `user` object instance.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`user`对象实例。
- en: Console out our methods to ensure that they are working as expected.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的方法输出到控制台，以确保它们按预期工作。
- en: 'The expected output is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor402).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor402)找到。
- en: TypeScript was born out of the need to build less confusing, clearly defined
    code. Interfaces allow you to build out your code in the most structured way possible.
    Everything has rules and there is no confusion, unlike with vanilla JavaScript.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的诞生源于构建更不令人困惑、定义更清晰的代码的需求。接口允许你以最结构化的方式构建代码。一切都有规则，没有混淆，这与纯JavaScript不同。
- en: To summarize the importance of interfaces, you can say that now you can produce
    code that is better structured and easier for third parties to use.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要总结接口的重要性，你可以这样说：现在你可以生成结构更好、第三方更容易使用的代码。
- en: Let's say, for example, that you built a `user` class as you did in the preceding
    activity, and now you need to move on to a different part of your project. The
    interfaces you have built will be a great help to the developer taking over the
    user section of the application, or maybe some other developer wants to build
    a user class with a similar structure to your user class. By using the interfaces
    you have defined, they can build a structure that follows all the rules you have
    put in place. This is also helpful as regards debugging, as now they know how
    things are expected to function and can find where the issues are by using the
    interfaces as a guideline.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你像在先前的活动中做的那样构建了一个`user`类，现在你需要继续进行项目的另一部分。你构建的接口将对接管应用程序用户部分的开发者或可能其他开发者想要构建与你的用户类具有相似结构的用户类非常有帮助。通过使用你定义的接口，他们可以构建一个遵循你设定的所有规则的架构。这也对调试很有帮助，因为他们现在知道事情应该如何工作，并且可以通过使用接口作为指南来找到问题所在。
- en: The next section of this chapter is dedicated to inheritance in TypeScript.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一节将专门介绍TypeScript中的继承。
- en: TypeScript Inheritance
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript继承
- en: We will now dive into inheritance, which is one of the core principles of object-oriented
    programming. It allows us to stay DRY (don't repeat yourself). Inheritance also
    allows us to be polymorphic, by abstracting functionality. Inheritance gives you
    the ability to extend your classes from the original class to a child class, which
    allows you to retain the functionality from the parent or original class and add
    or override what you don't need.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将深入探讨继承，这是面向对象编程的核心原则之一。它允许我们遵循DRY（不要重复自己）原则。继承还允许我们通过抽象功能来实现多态。继承使你能够从原始类扩展到子类，这允许你保留父类或原始类的功能，并添加或覆盖你不需要的部分。
- en: Child classes can override methods of their parents and have their own methods
    and objects. Inheritance only allows you to build on the parent class; how you
    implement your child class is up to you. However, the rule is that there must
    be some code you need to reuse from your parent class in your child class or you
    should create a new class as there would be no need to extend a class you don't
    plan to use any code from.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以覆盖其父类的方法，并拥有自己的方法和对象。继承只允许你在父类的基础上构建；如何实现你的子类取决于你。然而，规则是，在子类中必须有一些需要从父类重用的代码，或者你应该创建一个新的类，因为没有必要扩展你不想使用任何代码的类。
- en: 'Let''s say you have a user class created to manage users in your application.
    You are working on a web application and, in the planning stages, you come to
    the realization that you need more than one user type, as different users will
    have different levels of access and be able to perform different actions depending
    on their roles. This is the perfect case for the use of inheritance. Any time
    you have common properties and functionality, you can extend and not duplicate
    your code. In this case, we have several user types, which all have common properties
    of a user: email, createDate, lastLogin, and token, for example.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个用户类，用于管理你的应用程序中的用户。你正在开发一个Web应用程序，在规划阶段，你意识到你需要不止一种用户类型，因为不同的用户将具有不同的访问级别，并且能够根据他们的角色执行不同的操作。这正是使用继承的完美案例。每次你有通用属性和功能时，你都可以扩展而不是重复代码。在这种情况下，我们有几种用户类型，它们都具有用户的通用属性：电子邮件、创建日期、最后登录和令牌等。
- en: Because these properties are common to all users, we can put them all into a
    user class. The user class will serve as the base class that we can extend to
    our child classes. Your child classes will now have all the common properties
    without you having to declare them for each child class. As you can see, this
    is a much more efficient way to do things; it stops code duplication and allows
    for the consolidation of functionality.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些属性对所有用户都是通用的，我们可以将它们全部放入一个用户类中。用户类将作为基类，我们可以将其扩展到子类中。现在，你的子类将拥有所有通用属性，而无需为每个子类单独声明它们。正如你所见，这是一种更有效的方法；它阻止了代码重复，并允许功能的整合。
- en: 'First, let''s go over some ground rules of inheritance in TypeScript:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下TypeScript中继承的一些基本规则：
- en: 'TypeScript only supports inheritance in two ways: single-level and multi-level.
    Thus, in TypeScript, a child can inherit from a parent (single-level inheritance)
    or a child can inherit from another child (multi-level inheritance).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript只支持两种继承方式：单级和多级。因此，在TypeScript中，子类可以继承自父类（单级继承），或者子类可以继承自另一个子类（多级继承）。
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: They are other types of inheritance, but since Typescript does not support those
    patterns, this chapter will not address these types here.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 他们是其他类型的继承，但由于TypeScript不支持这些模式，本章将不会涉及这些类型。
- en: 'Here, we have a diagram of the two types of inheritance that TypeScript supports
    – single-level and multi-level:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个TypeScript支持的两种继承类型的图示——单级和多级：
- en: '![Figure 5.2: An example of single- and multi-level inheritance'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2：单级和多级继承的示例'
- en: '](img/B14508_05_02.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_05_02.jpg](img/B14508_05_02.jpg)'
- en: 'Figure 5.2: An example of single- and multi-level inheritance'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：单级和多级继承的示例
- en: Single-level inheritance occurs when a child class inherits directly from a
    parent class, as shown in the preceding diagram. The Son child class is derived
    from the Father parent class and has all its attributes. It can also have its
    own properties and functions that are unique to the child class. One of the goals
    of inheritance is to build on top of an existing base, therefore, just creating
    a duplicate of the class would be pointless. Multi-level inheritance works the
    same as single-level inheritance, except the child class inherits from another
    child class and not directly from the parent, as shown in the preceding diagram.
    In other words, single-level is derived directly from the base class, which has
    no parents, while a multi-level child class inherits from a derived class. As
    you can see, the Grandfather class is the base class and therefore has no parents.
    Father is derived from GrandFather, but Son, in this case, is derived from Father,
    making this example multi-level.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 单级继承发生在子类直接从父类继承时，如前图所示。Son 子类是从 Father 父类派生出来的，并具有所有其属性。它也可以有自己的属性和函数，这些属性和函数是子类独有的。继承的一个目标是在现有基础上构建，因此，仅仅创建类的副本将是毫无意义的。多级继承与单级继承的工作方式相同，除了子类从另一个子类继承，而不是直接从父类继承，如前图所示。换句话说，单级继承直接从基类继承，该基类没有父类，而多级子类从派生类继承。如您所见，Grandfather
    类是基类，因此没有父类。Father 是从 GrandFather 派生出来的，但在这个例子中，Son 是从 Father 派生出来的，这使得这个例子是多级的。
- en: TypeScript makes use of the private and public keywords to allow you to hide
    code from a child class that is private and control how your class properties
    are accessed by a child class with getter and setter methods. You can override
    any method that is exposed by a parent class in the child that includes the constructor
    method by using the keyword super, which is a direct link to the parent class.
    super also allows you to access properties and methods of the parent class even
    if they are overridden in your child class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 使用 `private` 和 `public` 关键字来允许您隐藏子类中的代码，并控制子类如何通过 getter 和 setter
    方法访问类属性。您可以使用 `super` 关键字覆盖父类公开的任何方法，`super` 是指向父类的直接链接。`super` 还允许您访问父类的属性和方法，即使它们在子类中被覆盖。
- en: 'To see how inheritance works in code, let''s go back to our user example that
    we covered in the introduction to this section. The users of any given application
    have some common properties, email, createDate, lastLogin, and token, for example.
    We will use these common elements to build out a base user class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解代码中的继承是如何工作的，让我们回到本节引言中我们讨论过的用户示例。任何给定应用程序的用户都有一些共同的属性，例如电子邮件、创建日期、最后登录时间和令牌。我们将使用这些共同元素来构建基用户类：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is some information on the properties used in the base class. This will
    also help you understand why these properties are present in the base class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于在基类中使用的属性的信息。这也有助于您理解为什么这些属性存在于基类中：
- en: '`email`: This property serves as a unique identifier.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`: 这个属性作为唯一标识符。'
- en: '`createDate`: This property allows you to know when the user was added to the
    system.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createDate`: 这个属性允许您知道用户何时被添加到系统中。'
- en: '`lastLogin`: This property lets us know when the user was last active on the system.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastLogin`: 这个属性让我们知道用户上次在系统上活跃的时间。'
- en: '`token`: This property will validate user requests to the application''s API.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token`: 这个属性将验证用户对应用程序 API 的请求。'
- en: '`setToken`: This property allows us to set and reset the token property; for
    example, the user logs out of the application and the token needs to be set to null.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setToken`: 这个属性允许我们设置和重置令牌属性；例如，用户从应用程序注销，令牌需要被设置为 null。'
- en: '`resetPassword`: This property allows us to reset the current user''s password.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resetPassword`: 这个属性允许我们重置当前用户的密码。'
- en: We are also using the this keyword to access our class-level token in our `setToken`
    function. We have also provided a number of default values in our base class,
    such as setting an empty string for email and zero for `createDate`. This just
    makes it easier to create instances of the class as we do not need to provide
    values every time we initialize a class instance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 `setToken` 函数中使用 `this` 关键字来访问我们的类级别令牌。我们还在基类中提供了一些默认值，例如将电子邮件设置为空字符串，将
    `createDate` 设置为零。这只是为了使创建类的实例更容易，因为我们不需要每次初始化类实例时都提供值。
- en: 'Now, let''s move on to inheritance. We will now create a child class, `AdminUser`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论继承。我们将现在创建一个子类，`AdminUser`：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In order for us to create a child class, we must use the extends keyword followed
    by the parent class, as shown in the preceding snippet. The syntax structure is
    as follows: class keyword followed by the name of the child class, the extends
    keyword, and finally, the name of the parent class you would like to extend: class
    AdminUser extends UserOne.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们能够创建一个子类，我们必须使用`extends`关键字后跟父类，正如前面片段所示。语法结构如下：使用`class`关键字后跟子类的名称，然后是`extends`关键字，最后是你想要扩展的父类的名称：`class
    AdminUser extends UserOne`。
- en: 'Before we move on to some examples, let''s list a few things we cannot do with
    class inheritance in TypeScript:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续一些示例之前，让我们列出一些在TypeScript中使用类继承时不能做的事情：
- en: You cannot use other types of inheritance other than single- and multi-level.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能使用除了单级和多级继承之外的其他类型的继承。
- en: If you declare a property or a method private, you cannot access it directly
    in your derived classes.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你声明一个属性或方法为私有，你无法在派生类中直接访问它。
- en: You cannot override the constructor method of your base class unless you call
    `super` in your derived class's constructor.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你在派生类的构造函数中调用`super`，否则你不能覆盖基类的构造方法。
- en: 'Now, let''s go back to our child class, `AdminUser`. Note that we have added
    some properties and methods unique to our child class. Unique to `AdminUser` are
    adminPages, which is a list of pages only the admin user has access to, and resetUserPassword,
    which takes an email address of a user and returns a default password:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的子类`AdminUser`。请注意，我们为我们的子类添加了一些独特的属性和方法。对`AdminUser`独特的是`adminPages`，这是一个只有管理员用户可以访问的页面列表，以及`resetUserPassword`，它接受一个用户的电子邮件地址并返回一个默认密码：
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also reference directly the properties and methods of your parent class
    by using the `this` keyword in the child class, since `AdminUser` is now a combined
    class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在子类中使用`this`关键字直接引用父类的属性和方法，因为`AdminUser`现在是一个组合类。
- en: 'Now, consider the following snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下片段：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding snippet, we create an instance of our child class, `AdminUser`.
    We also declare a string, `propString`, as an empty string. This string will hold
    a list of your class properties. Using a `for` loop, we loop over our class instance
    and append the properties to `propString`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了一个子类`AdminUser`的实例。我们还声明了一个字符串`propString`，它是一个空字符串。这个字符串将保存你的类属性列表。使用`for`循环，我们遍历我们的类实例并将属性追加到`propString`。
- en: 'Now, console out an instance of our child class to verify that we have successfully
    inherited from our base class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出我们子类的一个实例以验证我们是否已成功从基类继承：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should see the properties and methods of our child and parent classes printed
    on the console:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在控制台上看到我们子类和父类的属性和方法被打印出来：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding output is the expected result. You now have a list of the combined
    properties of `UserOne` and `AdminUser`, showing that we have successfully extended
    our `UserOne` class to `AdminUser` or, in other words, we have shown that `AdminUser`
    inherits from `UserOne`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出是预期的结果。你现在有一个`UserOne`和`AdminUser`的组合属性列表，这表明我们已经成功将`UserOne`类扩展到`AdminUser`，换句话说，我们已经证明了`AdminUser`从`UserOne`继承。
- en: 'Let''s now take inheritance up one level by deriving a new class from the `AdminUser`
    class. Call the derived class `SuperAdmin`, because not all admins are created
    equal:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过从`AdminUser`类派生一个新的类来将继承提升一级。将派生类命名为`SuperAdmin`，因为并非所有管理员都是平等的：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see from the preceding snippet, we are now extending the `AdminUser`
    class to create a `SuperAdmin` class. This means that we now have multi-level
    inheritance as our current class is inheriting from a derived class. We have also
    added a new property, `superPages`, and a method, `createAdmin`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的片段所示，我们现在正在扩展`AdminUser`类以创建一个`SuperAdmin`类。这意味着我们现在具有多级继承，因为我们的当前类正在从派生类继承。我们还添加了一个新的属性`superPages`和一个方法`createAdmin`。
- en: Multi-level inheritance is useful for building complexity while still keeping
    your code easy to manage.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 多级继承在构建复杂性的同时，还能保持你的代码易于管理。
- en: Next, we are going to overload our `resetPassword` method in the `SuperAdmin`
    child class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`SuperAdmin`子类中重载`resetPassword`方法。
- en: 'We want to create a new method for resetting passwords in our `SuperAdmin`
    class. We require a method that adds a hash to make the user password more secure
    as this will be the admin super user''s password:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在`SuperAdmin`类中创建一个新的方法来重置密码。我们需要一个方法来添加哈希，使用户密码更安全，因为这将是管理员超级用户的密码：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding code snippet creates a new method, `resetPassword`, and adds a
    new `myHash` property to our `SuperAdmin` class. We gave our new method the same
    name, `resetPassword`, as the `resetPassword` method in our grandfather class,
    `UserOne`. However, this new method returns a password appended with our hash
    property.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段创建了一个新的方法 `resetPassword` 并向 `SuperAdmin` 类添加了一个新的 `myHash` 属性。我们给我们的新方法取了与祖父类
    `UserOne` 中的 `resetPassword` 方法相同的名字，即 `resetPassword`。然而，这个新方法返回了一个附加了我们的哈希属性的密码。
- en: This is called method overriding because the methods have the same name and
    signature, meaning they take the same arguments. The method in the grandfather
    class is overridden and the new method will take precedence with instances of
    the `SuperAdmin` class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为方法重写，因为方法具有相同的名称和签名，这意味着它们接受相同的参数。祖父类中的方法被重写，新的方法将优先于 `SuperAdmin` 类的实例。
- en: This is useful when you need to add some functionality to a method in a child
    class but don't want to change the signature, as the new method does something
    similar but not exactly the same. Consumers of your code will be able to use the
    same method but get different outcomes based on which derived child class they
    invoke.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要向子类中的方法添加一些功能，但又不想改变签名时，这很有用，因为新方法做的是类似但不完全相同的事情。你的代码的消费者将能够使用相同的方法，但根据他们调用的派生子类，得到不同的结果。
- en: 'In the following snippet, we will console out the results of an instance of
    the `SuperAdmin` and `AdminUser` classes and the `resetPassword` method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们将输出 `SuperAdmin` 和 `AdminUser` 类的实例以及 `resetPassword` 方法的结果：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You will obtain the following output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see from the output, we are calling the same method and getting a
    different output. This shows that we were able to successfully override the `resetPassword`
    method from our parent class, `UserOne`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中看到的，我们调用了相同的方法，但得到了不同的输出。这表明我们成功地重写了来自父类 `UserOne` 的 `resetPassword` 方法。
- en: 'You can also add some access modifiers to our classes to show how they will
    affect our child classes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以向我们的类添加一些访问修饰符，以显示它们将如何影响我们的子类：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding snippet, we have added the `private` access modifier to the
    `token` property. Now, we can only access the `token` property through the `setToken`
    method, which is public, and all derived classes have access to the `setToken`
    method. This is useful in cases where you want to restrict which methods and properties
    to grant access to in your child classes. This is also useful in cases where you
    want to abstract functionality, thereby making interfacing with your code easier
    for consumers.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们向 `token` 属性添加了 `private` 访问修饰符。现在，我们只能通过公共的 `setToken` 方法访问 `token`
    属性，而所有派生类都有权访问 `setToken` 方法。这在你想限制在子类中授予哪些方法和属性访问权限的情况下很有用。这也有助于抽象功能，从而使得消费者与你的代码交互更加容易。
- en: We want to make sure that every `AdminUser` class instance is initialized with
    an email address. Hence, we decide to add a constructor method to our `AdminUser`
    class to create an email address for our admin users whenever an `AdminUser` class
    is created.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要确保每个 `AdminUser` 类的实例都初始化了一个电子邮件地址。因此，我们决定在我们的 `AdminUser` 类中添加一个构造函数方法，以便在创建
    `AdminUser` 类实例时为我们的管理员用户创建一个电子邮件地址。
- en: However, we cannot just create a constructor as this is a child class, which
    means we already have a parent class with a constructor method and we cannot override
    a constructor method without invoking our base class's constructor method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能仅仅创建一个构造函数，因为这是一个子类，这意味着我们已经有了一个带有构造函数方法的父类，并且我们不能在不调用基类构造函数方法的情况下重写构造函数方法。
- en: 'To invoke our base class''s constructor method, we use `super()`, which is
    a direct reference to our base class''s constructor method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用基类的构造函数方法，我们使用 `super()`，这是对基类构造函数方法的直接引用：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see in the preceding snippet, we have a constructor method that takes
    an email address and sets the global email address. We also call the `super` method
    so that we can invoke the constructor method on our parent class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码片段中看到的，我们有一个接受电子邮件地址并设置全局电子邮件地址的构造函数方法。我们还调用了 `super` 方法，这样我们就可以在父类上调用构造函数方法。
- en: 'Now, you can create an instance of our `AdminUserTwo` class and pass an email
    address when the instance is created. This is all transparent to the user of our
    `AdminUser` class:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在创建 `AdminUserTwo` 类的实例时传递一个电子邮件地址。这对我们的 `AdminUser` 类的用户来说是完全透明的：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that we have covered inheritance, we will put what we have learned to good
    use in the upcoming exercise.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了继承，我们将把所学到的知识应用到即将到来的练习中。
- en: 'Exercise 5.04: Creating a Base Class and Two Extended Child Classes'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.04：创建基类和两个扩展子类
- en: 'Imagine that you are part of a development team working on a web application
    for a supermarket chain. You have the task of building a class to represent a
    user in the application. Because you are a good developer and are aware that you
    should not try to create one class for all use cases, you will build a base class
    with common attributes you think all users in your application should have and
    then extend that as required with child classes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您是开发团队的一员，正在为一家超市连锁店开发一个网络应用程序。您有建立一个表示应用程序中用户的类的任务。因为您是一位优秀的开发者，并且知道您不应该尝试为所有用例创建一个类，所以您将构建一个基类，其中包含您认为应用程序中所有用户都应该拥有的常见属性，然后根据需要扩展它为子类：
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/hMd62](https://packt.link/hMd62).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该练习的代码文件可以在此处找到：[https://packt.link/hMd62](https://packt.link/hMd62)。
- en: 'Create a `User` class, as shown in the following code snippet:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `User` 类，如下面的代码片段所示：
- en: '[PRE55]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The application requires all its users to have `username` and `token` upon creation
    of the user object, so we add those properties and they will be initialized in
    our constructor.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序要求所有用户在创建用户对象时都必须有 `username` 和 `token`，因此我们添加了这些属性，并在构造函数中初始化它们。
- en: We also set them to `private` as we do not want child classes to access our
    properties directly. We also have a `timestamp` property that we will use to set
    a creation date for the user object. This is set to `readonly` as it is created
    when the class is instanced and we don't want it to be modified.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还把它们设置为 `private`，因为我们不希望子类直接访问我们的属性。我们还有一个 `timestamp` 属性，我们将用它来为用户对象设置创建日期。这个属性被设置为
    `readonly`，因为它在类实例化时创建，我们不希望它被修改。
- en: Different parts of your application will also need to access the properties
    of your user object. Therefore, we have added `getUser`, a method that returns
    your user properties. The `getUser` method will also allow derived or child classes
    to access private properties in an indirect way. The application allows the user
    to be logged in for a set period of time, after which the user token is expired.
    In order for a user to keep working in the application, we will need to renew
    their token, so we have added the `renewToken` method to allow for the setting
    of the user token property without giving direct access to properties.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的应用程序的不同部分也需要访问用户对象的属性。因此，我们添加了 `getUser` 方法，该方法返回您的用户属性。`getUser` 方法还将允许派生或子类以间接方式访问私有属性。应用程序允许用户在一定时间内登录，之后用户令牌过期。为了使用户能够在应用程序中继续工作，我们需要更新他们的令牌，因此我们添加了
    `renewToken` 方法，允许设置用户令牌属性，而不直接访问属性。
- en: 'Create a `Cashier` class derived from the `User` class:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `User` 类派生一个 `Cashier` 类：
- en: '[PRE56]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We now have a new user class, `Cashier`, derived from `User`, with some unique
    traits. A user of the `Cashier` type would need to function in our application.
    We do not, however, have access to all the properties of our parent class. You
    cannot access `userName` and `token` directly. You are able to access the `renewToken`
    method, but not through an instance of the `Cashier` class. However, you can call
    that method while building out the `Cashier` class as part of your user management
    for cashiers.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有一个新的用户类 `Cashier`，它是从 `User` 类派生出来的，具有一些独特的特性。`Cashier` 类型的用户需要在我们的应用程序中发挥作用。然而，我们没有访问父类中所有属性的权限。您不能直接访问
    `userName` 和 `token`。您能够访问 `renewToken` 方法，但不是通过 `Cashier` 类的实例。然而，您可以在构建 `Cashier`
    类时调用该方法，作为您对收银员用户管理的部分。
- en: 'Why would we want to modify access in the child class as opposed to modifying
    a parent? This is because of encapsulation and standardization: we want to reduce
    the complexity of our code when consumed by others.'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么我们要在子类中修改访问权限，而不是在父类中修改？这是因为封装和标准化：我们希望当我们的代码被他人使用时，降低代码的复杂性。
- en: For example, you have been working on a library of useful functions. You want
    your coworkers to be able to use it, but they don't need to know the inner workings
    of your `User` class. They just need to be able to access the class using the
    exposed methods and properties. This allows you to guide the process even if you
    are not the person extending or implementing the code. A good example would be
    the `Date` class in JavaScript. You don't need to know how that works. You can
    simply instance it and use it as directed.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，你一直在开发一个有用的函数库。你希望你的同事能够使用它，但他们不需要了解你的`User`类的内部工作原理。他们只需要能够通过公开的方法和属性访问该类。这允许你在不是扩展或实现代码的人的情况下引导这个过程。一个很好的例子是JavaScript中的`Date`类。你不需要知道它是如何工作的。你只需实例化它并按指示使用它。
- en: 'Create an `Inventory` class derived from `User`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`User`类派生一个`Inventory`类：
- en: '[PRE57]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our new user type, `Inventory`, needs to be able to initialize products upon
    the declaration of a new inventory user, as this user will be dealing with products
    directly and should have some products in their user queue when the user logs
    in to the application.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的新用户类型`Inventory`需要在声明新的库存用户时初始化产品，因为这个用户将直接处理产品，并且当用户登录应用程序时，他们应该在用户队列中拥有一些产品。
- en: In order to make that possible, we have overridden our parent class constructor
    method in our child class. Our constructor now takes a new argument, `products`,
    which is an array of the string type. This means that we have changed the number
    of arguments our constructor should take based on what we defined in our parent
    class. Whenever we override our constructor, we need to call `super`, which is
    a reference to our parent class.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们在子类中重写了父类的构造函数方法。我们的构造函数现在接受一个新的参数`products`，它是一个字符串类型的数组。这意味着我们已经根据在父类中定义的内容改变了构造函数应该接受的参数数量。每次我们重写构造函数时，都需要调用`super`，这是对父类的引用。
- en: As you can see, this allows us to access the parent constructor method, so we
    can now initialize `userName` and `token` and, in doing so, fulfill our child
    class's parent requirements. The main thing to take away from this is that all
    our code changes were made in the child class. Your new code for the `Inventory`
    class does not affect the other classes derived from `User`. You have extended
    and customized your code to deal with unique cases without having to write new
    code for this user case, saving you time and keeping your code base simple.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这允许我们访问父构造函数方法，因此我们现在可以初始化`userName`和`token`，并在这样做的同时满足子类的父类要求。从这个例子中我们可以吸取的主要教训是，我们所有的代码更改都是在子类中进行的。你为`Inventory`类编写的新代码不会影响从`User`类派生的其他类。你已经扩展并定制了你的代码以处理独特的情况，而不必为这个用户案例编写新代码，这节省了你的时间并使你的代码库保持简单。
- en: So far, we have derived two classes from our `User` class, which is single inheritance,
    as the child classes we created are directly derived from a base class. The next
    step involves multi-level inheritance.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从我们的`User`类派生了两个类，这是单继承，因为我们所创建的子类直接从基类派生。下一步涉及到多层继承。
- en: 'Create a new derived class, `FloorWorker`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的派生类`FloorWorker`：
- en: '[PRE58]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is multi-level inheritance. This class takes into account floor workers.
    These are users that deal with stocking shelves in the store, so they need to
    access products from the inventory. They also need to have a count of the products
    they have removed to stock the store shelves. They need to have access to the
    `User` class' properties as well as access to the `Products` array from the `Inventory`
    class.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是多层继承。这个类考虑了楼层工作人员。这些是处理商店货架库存的用户，因此他们需要从库存中访问产品。他们还需要有一个移除产品的数量，以填充商店货架。他们需要能够访问`User`类的属性，以及访问`Inventory`类的`Products`数组。
- en: In the following code snippet, we will instantiate our different user classes
    and console out the results of the work we have done so far.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们将实例化我们的不同用户类，并输出我们迄今为止所做的工作的结果。
- en: 'Instantiate your basic user and console out the results:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化你的基本用户并输出结果：
- en: '[PRE59]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You will obtain the following output:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '[PRE60]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Instantiate the `Cashier` class user and console out the results:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`Cashier`类用户并输出结果：
- en: '[PRE61]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You will obtain the following output:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '[PRE62]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Instantiate the `Inventory` class user and console out the results:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`Inventory`类用户并输出结果：
- en: '[PRE63]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You will obtain the following output:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '[PRE64]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Instantiate the `FloorWorker` class user and console out the results:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`FloorWorker`类用户并输出结果：
- en: '[PRE65]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You will obtain the following output:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '[PRE66]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For *steps 5-8*, you can also instantiate and console out all your users belonging
    to the different classes at once, rather than individually, as shown in the exercise.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于*步骤5-8*，你也可以一次性实例化和控制台输出属于不同类别的所有用户，而不是单独输出，如下所示。
- en: In this exercise, you created a base class, child classes, and worked on multi-level
    and single-level inheritance. You also made use of `super` and access modifiers.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你创建了一个基类、子类，并处理了多层和单层继承。你还使用了`super`和访问修饰符。
- en: 'Exercise 5.05: Creating Bases and Extended Classes Using Multi-level Inheritance'
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.05：使用多层继承创建基类和扩展类
- en: You are a developer working at a cell phone company and you are given the task
    of building a cell phone simulation application. The company manufactures two
    types of phone – a smartphone and a standard phone. The testing department wants
    to be able to showcase a number of functions of their phones and requires the
    ability to add more features to both phone types as the real devices are updated.
    After looking at the requirements, you come to the realization that you need the
    ability to model two types of phone and you also want to make it easy to update
    your code without doing a lot of refactoring and breaking other code that your
    phone models may use. You also know that both phones have a lot in common – they
    both have the basic functionality of communicating through voice and text data.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一家手机公司的开发者，你被分配了一个构建手机模拟应用程序的任务。该公司制造两种类型的手机——智能手机和标准手机。测试部门希望能够展示他们手机的一些功能，并需要能够在实际设备更新时向这两种手机类型添加更多功能。在查看需求后，你意识到你需要能够模拟两种类型的手机，并且你还希望使更新你的代码变得容易，而无需进行大量的重构和破坏你的手机模型可能使用的其他代码。你还知道这两种手机有很多共同之处——它们都有通过语音和文本数据通信的基本功能。
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/pyqDK](https://packt.link/pyqDK).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 代码文件可以在这里找到：[https://packt.link/pyqDK](https://packt.link/pyqDK)。
- en: 'Create a `Phone` class that will serve as the base class for our child classes,
    as shown here:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个作为我们子类基类的`Phone`类，如下所示：
- en: '[PRE67]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `Phone` class is where we will store all the common elements of a phone.
    This will allow us to simplify our child classes to only deal with the elements
    unique to them.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Phone`类是我们将存储所有手机通用元素的地方。这将使我们能够简化子类，只处理它们特有的元素。'
- en: 'Create a `Smart` class that extends the base or parent class created in *Step
    1*:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展在*步骤1*中创建的基类或父类的`Smart`类：
- en: '[PRE68]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `Smart` child class allows us to isolate all the methods and properties
    of a `Smart` `Phone` class.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Smart`子类使我们能够隔离`Smart``Phone`类的所有方法和属性。'
- en: 'Create a `Standard` class that extends the parent class created in *Step 1*,
    as shown here:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展在*步骤1*中创建的父类的`Standard`类，如下所示：
- en: '[PRE69]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Steps 2 and 3 deal with the creation of our child class, which allows us to
    meet our goals of being able to update our code without issues and keep our code
    clean and well maintained. Because we are planning well at this stage, if we need
    to add features to our `Smart` phone, we just need to update one child class.
    This is also true for the `Standard` phone class. Also, if we have a method or
    property that we need in both child classes, we only need to update the `Phone`
    parent class. With class inheritance, we work smart, not hard.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第2步和第3步处理创建我们的子类，这使我们能够在不出现问题的情况下更新我们的代码，并保持我们的代码整洁和易于维护。因为我们在这个阶段计划得很好，如果我们需要向我们的`Smart`手机添加功能，我们只需更新一个子类即可。对于`Standard`手机类也是如此。此外，如果我们需要在两个子类中都使用的方法或属性，我们只需更新`Phone`父类。通过类继承，我们工作得聪明，而不是辛苦。
- en: 'Create two instances of our child classes and initialize them:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们子类的两个实例并初始化它们：
- en: '[PRE70]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Console out and call the unique methods of our class instances to verify that
    our child classes are working as defined:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出并调用我们类实例的独特方法，以验证我们的子类是否按预期工作：
- en: '[PRE71]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You will obtain the following output:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '[PRE72]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: if you revisit the respective class definitions of the `Smart` and `Standard`
    classes, you will be able to confirm that the preceding output is indeed evidence
    of the fact that the classes have worked as expected.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你回顾`Smart`和`Standard`类的相应类定义，你将能够确认前面的输出确实是类按预期工作的证据。
- en: 'Display the child class instance to show that we have all the properties and
    methods of our parent class and child classes:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示子类实例以表明我们拥有父类和子类的所有属性和方法：
- en: '[PRE73]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You will obtain the following output:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '[PRE74]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For this preceding output, too, revisiting the respective class definitions
    of the `Smart` and `Dumb` classes should be proof enough that inheritance, as
    applied in this exercise, works correctly.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于前面的输出，重新查看`Smart`和`Dumb`类的相应类定义应该足以证明在这个练习中应用的继承是正确的。
- en: Now that you have an understanding of how inheritance works in TypeScript, we
    will test our skills in the form of the following activity.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 TypeScript 中继承的工作原理，我们将通过以下活动来测试我们的技能。
- en: 'Activity 5.02: Creating a Prototype Web Application for a Vehicle Showroom
    Using Inheritance'
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.02：使用继承创建一个原型车辆展厅的 Web 应用程序
- en: You are tasked with creating a web application for a vehicle showroom. You have
    decided to use your new skills in inheritance to build out the classes and child
    classes that will shape the vehicle objects we will require for our complete application.
    Note that the showroom has several types of vehicles. However, all these types
    will have some common properties. For example, all vehicles have wheels and a
    body. You can use this information to build your base class.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求创建一个车辆展厅的 Web 应用程序。你决定使用你在继承方面的新技能来构建出我们将需要的车辆对象类和子类。请注意，展厅有几种类型的车辆。然而，所有这些类型都将有一些共同的属性。例如，所有车辆都有轮子和车身。你可以使用这些信息来构建你的基类。
- en: 'The following steps will help you to complete this activity:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成此活动：
- en: Note
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/6Xp8H](https://packt.link/6Xp8H).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在此处找到：[https://packt.link/6Xp8H](https://packt.link/6Xp8H)。
- en: Create a parent class that will hold all common methods and properties for a
    base vehicle. Define a constructor method that allows you to initialize the base
    properties of this class and add a method that returns your properties as an object.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个父类，它将包含所有基础车辆共有的方法和属性。定义一个构造函数方法，允许你初始化这个类的基类属性，并添加一个方法，该方法返回你的属性作为一个对象。
- en: Add an access modifier to properties and class methods you want to control access
    to if necessary.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，可以向希望控制访问权限的属性和类方法添加访问修饰符。
- en: Derive two child classes from your parent class that are types of vehicles,
    for example, `Car` and `Truck`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从父类派生两个子类，例如`Car`和`Truck`，作为车辆类型。
- en: Override your constructor to add some unique properties to your child classes
    based on the type of vehicle.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写你的构造函数，根据车辆类型向子类添加一些独特的属性。
- en: Derive a class from one of the child classes created in *Step 3*, for example,
    `Suv`, which will have some of the properties a truck might have, so it would
    be logical to extend `Truck`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第3步中创建的子类之一派生一个类，例如`Suv`，它将具有一些卡车可能具有的属性，因此扩展`Truck`是合理的。
- en: Instantiate your child classes and seed them with data.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化你的子类，并用数据初始化它们。
- en: Console out our child class instance.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出子类实例。
- en: 'The expected output is as follows:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE75]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor405).
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor405)找到。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered interfaces in TypeScript. You learned how interfaces
    allow you to build contracts around your objects, classes, and methods. You also
    learned that interfaces are rules that outline how your code is implemented. This
    chapter covered how using interfaces makes your code easier to understand and
    is better supported by you and other developers when working in larger teams.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 TypeScript 中的接口。你学习了接口如何让你围绕对象、类和方法构建契约。你还了解到接口是概述代码实现规则的规则。本章介绍了使用接口如何使代码更容易理解，并且在大型团队中工作时，你和其他开发者都能得到更好的支持。
- en: This chapter also taught you about inheritance, one of the core principles of
    object-oriented programing. You learned about the types of inheritance TypeScript
    supports and how you can use inheritance to build complexity in your code without
    making your code more complex. This chapter elucidated that stacking simple structures
    to make more complex ones is a good practice as it allows you to reuse code and
    not reinvent the wheel every time you need to build a class. This also lends itself
    to better code support as you will write only the code you need and have common
    parent classes that will remain constant throughout your application, thereby
    making mistakes and bugs easier to find.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还向你介绍了继承，这是面向对象编程的核心原则之一。你学习了 TypeScript 支持的继承类型以及如何使用继承在代码中构建复杂性，而不会使代码变得更加复杂。本章阐明，将简单结构堆叠以形成更复杂的结构是一种良好的实践，因为它允许你重用代码，每次需要构建类时不必重新发明轮子。这也使得代码支持更好，因为你将只编写所需的代码，并拥有在整个应用程序中保持恒定的公共父类，从而使得错误和漏洞更容易被发现。
- en: You now have a good understanding of interfaces and inheritance, two building
    blocks you will make good use of as you move forward in this book and in web development
    using TypeScript.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对接口和继承有了很好的理解，这两个构建块将在你继续阅读本书以及使用 TypeScript 进行 Web 开发时发挥重要作用。
- en: The concepts you have covered here will make you a better developer overall
    as now you have the tools to write well-supported, clean, bug-free code.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里学到的概念将使你成为一个更好的开发者，因为你现在有了编写良好支持、干净、无错误的代码的工具。
- en: In the next chapter, you will cover advanced types and will learn about type
    aliases, type literals, unions, and intersection types.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习高级类型，并了解类型别名、类型字面量、联合类型和交叉类型。
