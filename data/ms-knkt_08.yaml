- en: Chapter 8. Plugins and Other Knockout Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 插件和其他 Knockout 库
- en: 'A big part of effectively working in any area of software is to be familiar
    with the tools used by the community. It is often better to rely on existing libraries
    and plugins that have been used and tested in the real world than try to reinvent
    the wheel on each new project. In this chapter, we will be looking at some of
    the most popular Knockout plugins:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何软件领域的有效工作中，熟悉社区使用的工具是一个很大的部分。通常，依靠已经使用并经过实际测试的现有库和插件，比在每个新项目中重新发明轮子要好。在本章中，我们将探讨一些最受欢迎的
    Knockout 插件：
- en: Knockout Validation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knockout Validation
- en: Knockout Mapping
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knockout Mapping
- en: Knockout Kendo
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knockout Kendo
- en: KoGrid
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KoGrid
- en: Knockout Bootstrap
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knockout Bootstrap
- en: Knockout Switch-Case
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knockout Switch-Case
- en: Knockout Projections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knockout Projections
- en: Knockout-ES5
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knockout-ES5
- en: Knockout Validation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout Validation
- en: The validation of user input is a common enough task that nearly every web application
    will have at least some need for. By far the most popular Knockout plugin, with
    50 percent more stars on GitHub than the next Knockout related project, Knockout
    Validation creates several extenders and binding handlers that are designed to
    simplify HTML form validation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入的验证是一个常见的任务，几乎每个网络应用都将至少有一些需求。到目前为止，GitHub 上最受欢迎的 Knockout 插件，比下一个与 Knockout
    相关的项目多 50% 的星标，Knockout Validation 创建了几个扩展器和绑定处理程序，旨在简化 HTML 表单验证。
- en: 'The use of the plugin starts with extenders that apply validation logic to
    observables without replacing them:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的用法从将验证逻辑应用于可观察对象而不替换它们开始：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Binding against validation-extended values is done with the normal `value`
    binding:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对验证扩展值进行绑定使用正常的 `value` 绑定：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Knockout Validation modifies the standard value and checked bindings so that
    they display invalid value warnings. The default display behavior will place a
    span element that contains any errors after the value-bound input element. The
    error message `span` will be hidden when the value is valid and contain the error
    message text when invalid.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout Validation 修改了标准的值和已检查绑定，以便它们显示无效值警告。默认的显示行为将在值绑定输入元素之后放置一个包含任何错误的
    `span` 元素。当值有效时，错误消息 `span` 将被隐藏，当无效时将包含错误消息文本。
- en: This automatic error insertion can be disabled if you want to manually place
    the validation message in the view. To do this, use the `validationMessage` binding,
    which has the same behavior as the inserted span.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想手动将验证消息放置在视图中，可以禁用此自动错误插入。为此，请使用 `validationMessage` 绑定，它具有与插入的 `span` 相同的行为。
- en: Default validation rules
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认验证规则
- en: 'Knockout Validation provides several validation extenders by default, which
    it calls **rules**. Like normal extenders, multiple validation rules can be passed
    in order to extend in a single call, or they can be chained:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout Validation 默认提供几个验证扩展器，它称之为**规则**。像正常的扩展器一样，可以在单个调用中传递多个验证规则以进行扩展，或者它们可以串联：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The default rules cover most of the standard cases for checking values, including—but
    not limited to—numerical min and max, string length min and max, regex patterns,
    dates, and value equality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认规则涵盖了检查值的大部分标准情况，包括但不限于数值的最小和最大值、字符串长度的最小和最大值、正则表达式模式、日期和值相等性。
- en: Configuring validation options
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置验证选项
- en: 'Knockout Validation''s behavior is very configurable. Some of the more useful
    options include:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout Validation 的行为非常可配置。一些更有用的选项包括：
- en: '`insertMessages` (default: `true`): If true, a `span` will be inserted after
    an input that is bound to a validated observable.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertMessages` (默认: `true`): 如果为真，将在绑定到已验证可观察对象的输入之后插入一个 `span`。'
- en: '`errorElementClass` (default: `validationElement`): This is a class that is
    applied to elements when validated observables are invalid.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errorElementClass` (默认: `validationElement`): 这是一个在已验证的可观察对象无效时应用于元素的类。'
- en: '`messagesOnModified` (default: `true`): If true, validation messages will not
    get displayed until the validated value has been modified so that they are hidden
    until a user interacts with the form.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messagesOnModified` (默认: `true`): 如果为真，验证消息将不会显示，直到已验证的值被修改，这样它们就会在用户与表单交互之前隐藏。'
- en: '`messageTemplate` (default: `null`): This is an ID of a script element that
    will be used as the validation message template instead of inserting the message
    into a span.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messageTemplate` (默认: `null`): 这是一个脚本元素的 ID，将用作验证消息模板，而不是将消息插入到 `span` 中。'
- en: 'Configuration options can be set globally by passing an object to `ko.validation.init`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过传递一个对象到 `ko.validation.init` 来全局设置配置选项：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Options can also be set contextually using the `validationOption` binding (see
    the next section) or by passing a configuration object to `ko.applyBindingsWithValidation`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `validationOption` 绑定（参见下一节）或通过传递配置对象到 `ko.applyBindingsWithValidation`
    来上下文设置选项：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Validation binding handlers
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证绑定处理程序
- en: Knockout Validation adds a few binding handlers to assist in displaying validation
    errors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 验证添加了一些绑定处理程序来帮助显示验证错误。
- en: 'The `validationMessage` binding displays the error message for validated observables
    when they are invalid. When the value is valid, the element is hidden:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`validationMessage` 绑定在验证的观察者无效时显示错误信息。当值有效时，元素将被隐藏：'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `validationElement` binding is useful for applying attributes and classes
    to elements. It sets the title attribute to the validation message, which is useful
    for showing tooltips, and it sets `errorElementClass` (`validationElement` by
    default) as the element''s class attribute when the `decorateElement` configuration
    option is true:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`validationElement` 绑定对于应用属性和类到元素很有用。它将标题属性设置为验证消息，这对于显示工具提示很有用，并且当 `decorateElement`
    配置选项为 true 时，它将 `errorElementClass`（默认为 `validationElement`）设置为元素的类属性：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `validationOptions` binding is similar to a control flow binding in that
    it applies the specified configuration options to all descendant DOM nodes. It
    can take the same object format that the configuration options can take:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`validationOptions` 绑定与控制流绑定类似，因为它将指定的配置选项应用于所有子 DOM 节点。它可以采用与配置选项相同的对象格式：'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating custom rules
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义规则
- en: 'Custom rules can be created both globally so that they can be reused by multiple
    extenders or inline for use in a single extender. Adding global validation rules
    is done by adding a rule object to the `ko.validation.rules` object. A rule has
    two components, which are the **validator function** and the **default message**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义规则可以全局创建，以便多个扩展器可以重用，或者内联创建，以便在单个扩展器中使用。添加全局验证规则是通过将规则对象添加到 `ko.validation.rules`
    对象来完成的。规则有两个组成部分，即 **验证函数** 和 **默认消息**：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The validator function receives two arguments: the value of the observable
    and the value passed to the validation extender. The validation extender can take
    any valid JavaScript value, including objects and functions.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 验证函数接收两个参数：观察者的值和传递给验证扩展器的值。验证扩展器可以接受任何有效的 JavaScript 值，包括对象和函数。
- en: 'Once a validation rule has been added, its extender is created with the following
    call:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了验证规则，其扩展器将通过以下调用创建：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It can then be used to extend observables:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它可以用来扩展观察者：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inline validation rules work by passing the same validation rule object to
    the validation extender:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 内联验证规则通过传递相同的验证规则对象到验证扩展器来工作：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When using inline validation rules, the second parameter to the `validator`
    function is defined with the `params` property of the validation rule.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用内联验证规则时，`validator` 函数的第二个参数由验证规则的 `params` 属性定义。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Knockout Validation is a large library with many features and options that have
    not been discussed in this section. The complete documentation for the Knockout
    Validation library can be found on its GitHub repository at [https://github.com/Knockout-Contrib/Knockout-Validation](https://github.com/Knockout-Contrib/Knockout-Validation).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 验证是一个具有许多功能和选项的大型库，这些功能和选项在本节中未讨论。Knockout 验证库的完整文档可以在其 GitHub 仓库中找到：[https://github.com/Knockout-Contrib/Knockout-Validation](https://github.com/Knockout-Contrib/Knockout-Validation)。
- en: Knockout Mapping
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout 映射
- en: 'The Knockout Mapping plugin is the answer to projects that want to bind against
    their server''s AJAX responses without manually writing the JavaScript classes
    in order to convert them into observables. The mapping plugin will convert JavaScript
    objects or JSON strings into objects with observable properties:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 映射插件是针对那些想要绑定到其服务器 AJAX 响应，而不需要手动编写 JavaScript 类以将它们转换为观察者的项目的解决方案。映射插件将
    JavaScript 对象或 JSON 字符串转换为具有可观察属性的观察者对象：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For JSON, take a look at the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JSON，请查看以下代码：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The mapping plugin handles arrays by converting them into `observableArrays`.
    It also creates a copy of objects, allowing a complete object graph from the server
    to be converted into an observable object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 映射插件通过将它们转换为 `observableArrays` 来处理数组。它还创建了对象的副本，允许从服务器到客户端的完整对象图被转换为可观察对象。
- en: 'Updates against viewmodels created with the mapping plugin can be performed
    by passing the viewmodel as the second parameter to `fromJS` or `fromJSON`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将 viewmodel 作为 `fromJS` 或 `fromJSON` 的第二个参数传递来执行针对使用映射插件创建的 viewmodel 的更新：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see a simple example of the mapping plugin in action in the `cp8-mapping`
    branch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `cp8-mapping` 分支中看到一个映射插件作用的简单示例。
- en: Updating the viewmodel
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 viewmodel
- en: 'The `fromJS` and `fromJSON` methods can also be used to update an entire viewmodel
    in order to handle future server update responses by passing the viewmodel as
    the third parameter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromJS` 和 `fromJSON` 方法也可以用来更新整个 viewmodel，以便通过传递 viewmodel 作为第三个参数来处理未来的服务器更新响应：'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unmapping
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解包
- en: Normally, when sending data back to the server, you would use `ko.toJS` or `ko.toJSON`
    to unwrap the viewmodel into an object with normal JavaScript properties instead
    of observables ones. Because the mapping plugin adds several properties to your
    viewmodel that are intended for internal use, `ko.toJS` will produce a cluttered
    copy. Instead, you can use `ko.mapping.toJS` and `ko.mapping.toJSON` to get an
    unwrapped viewmodel without the added mapping properties.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在将数据发送回服务器时，你会使用 `ko.toJS` 或 `ko.toJSON` 将 viewmodel 解包为一个具有正常 JavaScript
    属性的对象，而不是可观察属性。因为映射插件为你的 viewmodel 添加了几个用于内部使用的属性，`ko.toJS` 将产生一个杂乱的副本。相反，你可以使用
    `ko.mapping.toJS` 和 `ko.mapping.toJSON` 来获取一个不带附加映射属性的解包 viewmodel。
- en: Mapping options
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射选项
- en: 'To control how objects are created or updated by the mapping plugin, options
    can be passed in when a viewmodel is first created. The mapping plugin will use
    the options to build the viewmodel, and then store the options so that they can
    be used for all future updates:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制映射插件如何创建或更新对象，可以在 viewmodel 首次创建时传递选项。映射插件将使用这些选项来构建 viewmodel，然后存储这些选项，以便它们可以用于所有未来的更新：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using keys for array updates
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用键进行数组更新
- en: 'The default behavior for updating arrays is to replace any elements that are
    not a perfect match with the new values. When working with arrays of objects,
    it is usually expected that the elements will have their values updated in place.
    To tell the mapping plugin how to determine that elements in the values to be
    updated are the same as the old values, a key can be defined:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更新数组的默认行为是用新值替换任何不完美匹配的元素。当处理对象的数组时，通常期望元素将在原地更新其值。为了告诉映射插件如何确定要更新的值中的元素与旧值相同，可以定义一个键：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using create for the object construction
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 create 进行对象构造
- en: 'You can provide a callback for individual properties to control their creation.
    A common use case is to provide a constructor for the object:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以提供一个回调来控制单个属性的创建。一个常见的用例是提供一个对象的构造函数：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Controlling updates
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制更新
- en: 'Similar to creation, an update callback can be provided. The return value will
    be used as the property''s value:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建类似，可以提供一个更新回调。返回值将用作属性的值：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Choosing which properties get mapped
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择哪些属性被映射
- en: 'Mapping options can specify an array of property names that control various
    aspects of mapping:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 映射选项可以指定一个属性名称数组，以控制映射的各个方面：
- en: '`ignore`: Mapping will not include these in the generated viewmodel.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore`: 映射将不包括这些属性在生成的 viewmodel 中。'
- en: '`copy`: Mapping will copy the values of these properties directly instead of
    converting them into observable properties.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy`: 映射将直接复制这些属性的值，而不是将它们转换为可观察属性。'
- en: '`observe`: If present, only the properties in this array will be converted
    into observable properties on the viewmodel. This is the inverse of the previous
    option.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observe`: 如果存在，只有此数组中的属性将被转换为 viewmodel 上的可观察属性。这是之前选项的逆操作。'
- en: '`include`: Normally when using `ko.mapping.toJS`, only properties that were
    originally in the mapping will be in the output. Any properties in the `include`
    array will also be copied into the output even if they weren''t in the original
    viewmodel.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`: 通常在使用 `ko.mapping.toJS` 时，只有原始映射中的属性会出现在输出中。`include` 数组中的任何属性也会被复制到输出中，即使它们不在原始的
    viewmodel 中。'
- en: 'All of these arrays will be combined with the default values in the `ko.mapping.defaultOptions`
    object. The defaults are all empty by default, but they can be modified:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数组都将与 `ko.mapping.defaultOptions` 对象中的默认值合并。默认情况下，所有默认值都是空的，但它们可以被修改：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Challenges
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战
- en: The Knockout Mapping plugin is very useful in cases where server responses drive
    the work being done by the application. When the application needs to work with
    models, the mapping plugin will not be able to create the viewmodel before the
    models have been sent by the server. This happens commonly when filling out forms
    to create new models for the first time. The properties of a viewmodel are also
    only half the story; business logic will still need to be written for most viewmodels.
    It can be challenging to write functions or computed properties against properties
    that are populated by the mapping plugin, as they are not in the class that will
    be served as a reference. In very complex cases, the mapping logic for some objects
    might exceed the same logic for an object defined with normal JavaScript. While
    this can save time in medium-to-large applications with many server responses,
    it might not always be the best fit for a project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器响应驱动应用程序的工作时，Knockout 映射插件非常有用。当应用程序需要与模型一起工作时，在模型被服务器发送之前，映射插件将无法创建视图模型。这种情况在填写表单以创建新模型时经常发生。视图模型的属性也只讲了一半的故事；对于大多数视图模型，仍然需要编写业务逻辑。由于映射插件填充的属性不在将作为参考的类中，因此针对这些属性编写函数或计算属性可能会很具挑战性。在非常复杂的情况下，某些对象的映射逻辑可能超过了用正常
    JavaScript 定义的相同逻辑。虽然这可以在具有许多服务器响应的中等到大型应用程序中节省时间，但它可能并不总是适合项目。
- en: Despite its popularity, it is no longer being maintained on GitHub. However,
    as of version 3.2, it still works with Knockout.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它很受欢迎，但它已不再在 GitHub 上维护。然而，截至版本 3.2，它仍然与 Knockout 兼容。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The documentation for the mapping plugin is on the official Knockout site at
    [http://knockoutjs.com/documentation/plugins-mapping.html](http://knockoutjs.com/documentation/plugins-mapping.html).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 映射插件的文档位于官方 Knockout 网站上，链接为 [http://knockoutjs.com/documentation/plugins-mapping.html](http://knockoutjs.com/documentation/plugins-mapping.html)。
- en: Knockout Kendo
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 击倒剑道
- en: Kendo UI ([http://www.telerik.com/kendo-ui](http://www.telerik.com/kendo-ui))
    is a popular HTML5 widgets library of Telerik that offers a large selection of
    professional-looking controls. Knockout Kendo is a library of bindings, which
    allows Knockout viewmodels to use Kendo controls. Knockout Kendo has over 30 bindings,
    each with a variety of options, which is far too many to cover here. While Knockout
    Kendo is free, Kendo UI itself is not free and requires you to purchase a license
    in order to use it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo UI ([http://www.telerik.com/kendo-ui](http://www.telerik.com/kendo-ui))
    是 Telerik 提供的一个流行的 HTML5 小部件库，它提供了大量外观专业的控件。Knockout Kendo 是一个绑定库，允许 Knockout
    视图模型使用 Kendo 控件。Knockout Kendo 有超过 30 个绑定，每个绑定都有多种选项，这里无法一一介绍。虽然 Knockout Kendo
    是免费的，但 Kendo UI 本身不是免费的，并且需要您购买许可证才能使用。
- en: 'Most of the bindings are simple wrappers around the Kendo widgets, offering
    an API with a few surprises. For example, here is the **autocomplete** binding,
    which takes an array of options and an observable that binds the selection:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数绑定都是围绕 Kendo 小部件的简单包装，提供了一个带有一些惊喜的 API。例如，这里有 **autocomplete** 绑定，它接受一个选项数组和一个绑定选择的观察：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`DateTimePicker`, which creates two independent selection controls for the
    date and time, binds against a single observable `Date` object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimePicker` 创建了两个独立的日期和时间选择控件，绑定到一个单一的观察 `Date` 对象：'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you have used Kendo previously, you will be familiar with the available controls,
    and Knockout Kendo even has bindings for the non-free Professional UI widgets.
    You can see a few examples of Kendo controls in the `cp8-kendo` branch.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过 Kendo，您将熟悉可用的控件，Knockout Kendo 甚至还有非免费的专业 UI 小部件的绑定。您可以在 `cp8-kendo`
    分支中看到一些 Kendo 控件的示例。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: You can find the complete documentation for Knockout Kendo on its GitHub site
    at [http://rniemeyer.github.io/knockout-kendo/](http://rniemeyer.github.io/knockout-kendo/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Knockout Kendo 的 GitHub 网站上找到完整的文档，链接为 [http://rniemeyer.github.io/knockout-kendo/](http://rniemeyer.github.io/knockout-kendo/)。
- en: KoGrid
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KoGrid
- en: KoGrid is a plugin that creates a binding that renders tabular data. As its
    GitHub page notes, it is "a direct knockout port of ng-grid which was originally
    inspired by KoGrid, which was inspired by SlickGrid." Its history might have been
    affected by the grandfather paradox.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: KoGrid 是一个插件，它创建了一个渲染表格数据的绑定。正如其 GitHub 页面所述，它是“ng-grid 的直接 Knockout 版本，ng-grid
    最初受到 KoGrid 的启发，而 KoGrid 又受到 SlickGrid 的启发。”其历史可能受到了祖父悖论的影响。
- en: 'In its most basic operation mode, KoGrid can bind against an array of objects,
    turning their properties into columns and their values into cells:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的工作模式下，KoGrid可以绑定到一个对象数组，将它们的属性转换为列，将它们的值转换为单元格：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can see this example in the `cp8-kogrid` branch. Except for needing to manually
    specify, through style of CSS, the dimensions of the grid itself, everything else
    is automatic. You get row sorting by clicking on the columns, the ability to toggle
    columns visibility, a scrollbar for overflow, item counts, and the columns can
    be reordered by dragging them. The biggest downside is that the data isn't rendered
    using a real table element, it's rendered using just a bunch of `div` elements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`cp8-kogrid`分支中看到这个示例。除了需要手动通过CSS样式指定网格本身的尺寸外，其他所有内容都是自动的。您可以通过点击列进行行排序，切换列的可见性，使用滚动条处理溢出，显示项目计数，并且可以通过拖动重新排序列。最大的缺点是数据不是使用真正的表格元素渲染的，而是使用一堆`div`元素渲染的。
- en: 'Of course, this is just the basic mode of operation. KoGrid comes with most
    of the features you would expect from a fully baked grid widget:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个基本的工作模式。KoGrid自带了您从完整的网格小部件中期望的大多数功能：
- en: '**Column definitions**: This specifies which row properties are displayed as
    columns.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列定义**：这指定了哪些行属性被显示为列。'
- en: '**Grouping**: This allows the user to select a column to pivot the table on,
    grouping all of the rows by matching values of the selected column.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分组**：这允许用户选择一个列来旋转表格，通过匹配所选列的值将所有行分组。'
- en: '**Selected rows**: With this, an observable array can be bound against the
    selected rows for the table. When the `multiSelect` option is false, this can
    be used to create a master/detail view with the selected row.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选中行**：使用此功能，可以将可观察数组绑定到表格的选中行。当`multiSelect`选项为false时，这可以用来创建一个主/详细视图，其中包含选中的行。'
- en: '**Templates**: This provides row and cell templates for the grid.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：这为网格提供行和单元格模板。'
- en: '**Themes**: This specifies themes on a per-grid basis through binding options.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：这指定了每个网格的绑定选项，从而指定主题。'
- en: '**Server-side paging**: This provides callbacks that allow the grid to get
    data asynchronously from an external source.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端分页**：这提供了回调函数，允许网格从外部源异步获取数据。'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want a binding that outputs real table elements, and you don't need all
    of the bells and whistles offered by KoGrid, check out the knockout-table plugin
    at [https://github.com/mbest/knockout-table](https://github.com/mbest/knockout-table).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要一个输出真实表格元素的绑定，并且不需要KoGrid提供的所有功能，请查看knockout-table插件[https://github.com/mbest/knockout-table](https://github.com/mbest/knockout-table)。
- en: 'Out of any of these features, templates are probably the most important. While
    their example page puts the templates in line in the viewmodel code, this is not
    a recommended practice unless you are loading the string from an external source
    (such as AJAX or the RequireJS text loader). KoGrid also supports using a script
    element as a template by referencing its ID, such as Knockout''s template system.
    However, the simplest approach is to use a URL string to refer to an HTML partial
    file as the template:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些功能中，模板可能是最重要的。虽然它们的示例页面将模板直接放在视图模型代码中，但这不是推荐的做法，除非您是从外部源（如AJAX或RequireJS文本加载器）加载字符串。KoGrid还支持通过引用其ID使用脚本元素作为模板，例如Knockout的模板系统。然而，最简单的方法是使用URL字符串来引用HTML部分文件作为模板：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding example shows you several grid options as well as the column definition
    that specifies which columns to show. Note that the last column does not have
    a property but has a template that will show you a delete button instead.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例向您展示了几个网格选项以及指定要显示哪些列的列定义。请注意，最后一列没有属性，但有一个模板，会显示一个删除按钮。
- en: It is possible to define these options in the viewmodel and pass only a single
    object to the KoGrid binding; however, this causes the viewmodel to be tightly
    coupled to its use by a KoGrid, which is a violation of the MVVM pattern. Defining
    the grid options in the view keeps the viewmodel agnostic with regards to how
    it is displayed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在视图模型中定义这些选项，并将单个对象传递给KoGrid绑定；然而，这会导致视图模型与其使用紧密耦合，这是违反MVVM模式的。在视图中定义网格选项可以保持视图模型与显示方式无关。
- en: 'The delete button template will be rendered by KoGrid inside the binding context
    of the cell:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 删除按钮模板将由KoGrid在单元格的绑定上下文中渲染：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The complete documentation for cell and row templates will not be covered here,
    but the preceding template demonstrates several important components.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不会涵盖单元格和行模板的完整文档，但前面的模板展示了几个重要组件。
- en: To control its width and position properly, cells need to include the `kgCellText`
    class as well as a 0-indexed class for the column it represents. As the cell will
    be used inside a column loop, it has access to the special binding context property
    `$index()` in order to get this value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确控制其宽度和位置，单元格需要包含`kgCellText`类以及代表该列的0索引类。由于单元格将在列循环中使用，它能够访问特殊的绑定上下文属性`$index()`来获取这个值。
- en: The default value for a click binding in Knockout is the current binding context.
    Inside the cell template, this will be the cell object and not the item from the
    data array. The bound item can be accessed using `$parent.entity`. To get access
    to the viewmodel, the grid is bound against `$parent.$userViewModel`. The `$parent`
    in both these cases is the binding context for the row; when creating row templates,
    `$data.entity` and `$userViewModel` can be used to access the same properties.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Knockout中，点击绑定的默认值是当前绑定上下文。在单元格模板内部，这将是指单元格对象而不是数据数组中的项目。可以通过`$parent.entity`访问绑定项。要访问视图模型，网格绑定到`$parent.$userViewModel`。在这两种情况下，`$parent`是行的绑定上下文；在创建行模板时，可以使用`$data.entity`和`$userViewModel`来访问相同的属性。
- en: You can see an example of this custom template in the `cp8-kogrid-template`
    branch.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cp8-kogrid-template`分支中看到这个自定义模板的例子。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete documentation for KoGrid can be found on its GitHub Wiki page at
    [https://github.com/Knockout-Contrib/KoGrid/wiki](https://github.com/Knockout-Contrib/KoGrid/wiki).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: KoGrid的完整文档可以在其GitHub Wiki页面上找到，网址为[https://github.com/Knockout-Contrib/KoGrid/wiki](https://github.com/Knockout-Contrib/KoGrid/wiki)。
- en: Knockout Bootstrap
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout Bootstrap
- en: Twitter Bootstrap has several beautiful jQuery-dependent widgets that can be
    used from JavaScript or in some cases, with their `data-*` attributes. If you
    are using Knockout, though, some work needs to be done in order to get it to work
    with observables and to initialize it from binding handlers. Knockout Bootstrap
    is a popular plugin that addresses this. Unfortunately, at the time of writing
    this, it hasn't been updated to work with Bootstrap 3 and therefore, some of its
    features do not work. When working with Knockout 3 and Bootstrap 3, the **ToolTip**,
    **Popover**, and **Alerts** bindings work correctly, but the **Progress Bar**
    and **Typeahead** bindings do not work.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter Bootstrap有几个依赖于jQuery的美丽小部件，可以从JavaScript中使用，或者在某些情况下，使用它们的`data-*`属性。如果你使用Knockout，则需要做一些工作才能使其与可观察对象一起工作，并从绑定处理程序中初始化它。Knockout
    Bootstrap是一个流行的插件，它解决了这个问题。不幸的是，在撰写本文时，它还没有更新以支持Bootstrap 3，因此，其中一些功能无法正常工作。当与Knockout
    3和Bootstrap 3一起工作时，**ToolTip**、**Popover**和**Alerts**绑定可以正常工作，但**Progress Bar**和**Typeahead**绑定则无法工作。
- en: 'Like Knockout Kendo, if you have used the Bootstrap widgets, the bindings in
    Knockout Bootstrap should be immediately familiar. The bindings are named after
    their widgets and take an object with the same properties the jQuery plugin initializers
    take. When sensible, the properties can be bound against:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如同Knockout Kendo，如果你使用过Bootstrap小部件，Knockout Bootstrap中的绑定应该会立即熟悉。绑定以它们的部件命名，并接受一个具有与jQuery插件初始化器相同属性的对象。当合理时，这些属性可以绑定到：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These can all be seen in the `cp8-knockout-bootstrap` branch. One thing to note
    is that the alert binding does not remove alerts from the bound array when they
    are closed on the UI, though it will show or hide array elements as they are added
    or removed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可以在`cp8-knockout-bootstrap`分支中看到。需要注意的是，当在UI上关闭警报时，警报绑定不会从绑定数组中删除警报，尽管它会根据添加或删除数组元素来显示或隐藏数组元素。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete documentation for Knockout Bootstrap is available at [http://billpull.com/knockout-bootstrap](http://billpull.com/knockout-bootstrap).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout Bootstrap的完整文档可在[http://billpull.com/knockout-bootstrap](http://billpull.com/knockout-bootstrap)找到。
- en: Knockout Switch-Case
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout Switch-Case
- en: 'Despite being a plugin that targets a single, specific use case, Knockout Switch-Case''s
    popularity on GitHub is evidence that a switch/case control flow binding is a
    very useful tool. Instead of writing out a series of `if`/`ifnot` bindings, a
    single case-switch binding can be used:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Knockout Switch-Case插件针对的是单一、特定的用例，但它在GitHub上的流行程度证明了switch/case控制流绑定是一个非常实用的工具。与其编写一系列`if`/`ifnot`绑定，不如使用单个case-switch绑定：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding example can be seen in the `cp8-case-switch` branch.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的例子可以在`cp8-case-switch`分支中看到。
- en: 'The switch binding can also act on truthy values. This can be done by looking
    for the first matching value in a series:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Switch 绑定也可以作用于真值。这可以通过在一系列中查找第一个匹配值来完成：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or, it can be done by serving as a shorthand for a pair of `if/ifnot` bindings:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以作为一对 `if/ifnot` 绑定的缩写来完成：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The switch-case binding can also be used as a container-less binding in any
    combination of the preceding cases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Switch-case 绑定也可以用作前面情况组合中的无容器绑定。
- en: As you might have noticed, there are also special `$default` and `$else` options
    that can be used if no matching value is found.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，还有特殊的 `$default` 和 `$else` 选项，可以在找不到匹配值时使用。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for Knockout Switch-Case is available on GitHub at [https://github.com/mbest/knockout-switch-case](https://github.com/mbest/knockout-switch-case).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout Switch-Case 的源代码可在 GitHub 上找到，链接为 [https://github.com/mbest/knockout-switch-case](https://github.com/mbest/knockout-switch-case)。
- en: Knockout Projections
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout 投影
- en: Using a computed observable to filter or project an observable array is an incredibly
    common operation; I don't think I've ever seen a Knockout project that didn't
    do this at least once. Knockout Projections is a plugin that adds a map and filter
    function to observable arrays, which creates a computed observable that only recomputes
    it's callback on dependent elements that have changed instead of re-evaluating
    every single dependent element.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算观察者来过滤或投影观察者数组是一个极其常见的操作；我认为我从未见过一个没有至少一次执行此操作的 Knockout 投影。Knockout Projections
    是一个插件，它向观察者数组添加了映射和过滤功能，这创建了一个仅在其依赖元素发生变化时才重新计算其回调的计算观察者，而不是重新评估每个依赖元素。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Steven Sanderson introduced this plugin via his blog at [http://blog.stevensanderson.com/2013/12/03](http://blog.stevensanderson.com/2013/12/03).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Steven Sanderson 通过他的博客 [http://blog.stevensanderson.com/2013/12/03](http://blog.stevensanderson.com/2013/12/03)
    介绍了这个插件。
- en: To better understand the problem this plugin solves, we are going to look at
    the example Sanderson uses on his blog to illustrate the differences between a
    normal computed observable array and an array made with Knockout Projections.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解此插件解决的问题，我们将查看 Sanderson 在他的博客上使用的示例，以说明正常计算观察者数组和使用 Knockout Projections
    制成的数组之间的区别。
- en: 'Consider the following model:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下模型：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This `selectedProducts` computed is defined using the standard ES5 Array's `filter`
    function, calling `products()` returns the underlying JavaScript array. Every
    time it runs, it will loop over all of the products and return an array of every
    element with `isSelected() === true`. The problem here is that computed observables
    always rerun when any of their dependencies change; the computed can only perform
    re-evaluation by running its callback, and has to recheck every single product
    every time it runs. This does not scale very well; it runs in O(N) time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `selectedProducts` 计算是通过标准的 ES5 数组的 `filter` 函数定义的，调用 `products()` 返回底层的
    JavaScript 数组。每次运行时，它都会遍历所有产品，并返回一个包含所有 `isSelected() === true` 的元素的数组。这里的问题是计算观察者总是在其依赖项的任何一项发生变化时重新运行；计算只能通过运行其回调来执行重新评估，并且每次运行时都必须重新检查每个产品。这扩展性不好；它在
    O(N) 时间内运行。
- en: 'When using Knockout Projections, you will create this same computed using the
    `filter` function on the observable array itself:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Knockout Projections 时，您将使用观察者数组上的 `filter` 函数创建相同的计算：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This creates a read-only observable array that creates individual dependencies
    on each product''s `isSelected` observable. When a product is changed, the callback
    is run against only that product, and the `selectedProducts` array is updated
    with the change. Performance now has a fixed cost: no matter how large the array
    gets, the callback will only be run once per dependency change. The declaring
    code is also shorter and easier to read!'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个只读的观察者数组，它为每个产品的 `isSelected` 观察者创建单独的依赖。当产品发生变化时，回调将仅针对该产品运行，并且 `selectedProducts`
    数组将根据变化进行更新。性能现在有一个固定的成本：无论数组有多大，回调都将在每个依赖项变化时只运行一次。声明代码也更短，更容易阅读！
- en: 'Knockout Projections also creates a map function on observables, which runs
    a callback that produces an array transformation instead of a filter. For example,
    you can create an observable array of product names that only received updates
    when individual names were changed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout Projections 还在观察者上创建了一个映射函数，该函数运行一个产生数组转换的回调而不是过滤。例如，您可以创建一个只接收单个名称更改时更新的产品名称的观察者数组：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As the read-only arrays created by filter and map are also observable arrays,
    these methods can be chained together:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于由 filter 和 map 创建的只读数组也是可观察数组，因此可以将这些方法链接在一起：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The performance gain from using Knockout Projections is minor in small arrays
    but significant in larger ones. If you are working with even medium-sized data
    sets, using Knockout Projections is a no-brainer.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Knockout Projections 的性能提升在小数组中微乎其微，但在大数组中则非常显著。如果您正在处理即使是中等规模的数据集，使用 Knockout
    Projections 是不言而喻的。
- en: Knockout-ES5
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout-ES5
- en: 'Knockout-ES5 is a plugin for Knockout that uses JavaScript getters and setters
    to hide observables behind object properties, allowing your application code to
    use standard syntax to work with them. Basically, it gets rid of the observable
    parentheses:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout-ES5 是 Knockout 的一个插件，它使用 JavaScript 的 getter 和 setter 来隐藏在对象属性背后的可观察对象，允许您的应用程序代码使用标准语法与它们一起工作。基本上，它消除了可观察对象的括号：
- en: 'Take a look at the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code becomes this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码变为这样：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you remember the Durandal observable plugin, it's very similar; they even
    came out around the same time. The biggest difference between the two is that
    Durandal's observable plugin performs deep object conversion, and Knockout ES5
    performs shallow conversion.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得 Durandal 的可观察插件，它们非常相似；它们甚至几乎同时出现。这两个插件之间最大的区别是，Durandal 的可观察插件执行深度对象转换，而
    Knockout ES5 执行浅度转换。
- en: 'To convert a viewmodel''s properties to observables, call `ko.track`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '将视图模型的属性转换为可观察对象，请调用 `ko.track`:'
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To optionally specify which properties are to be converted in order to pass
    an array of names, take a look at the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要可选地指定要转换的属性，以便传递一个属性名称数组，请查看以下代码：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Observables that already exist on the model, such as those created with `ko.observable`
    or `ko.computed`, are also converted into ES5 properties by `ko.track`. Optionally,
    you can define computed observables using `ko.defineProperty`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 已经存在于模型上的可观察对象，例如使用 `ko.observable` 或 `ko.computed` 创建的，也会被 `ko.track` 转换为 ES5
    属性。您还可以使用 `ko.defineProperty` 定义计算可观察对象：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The third parameter follows the same rules as the first parameter sent to `ko.computed`;
    a function will be used to create a read-only computed, or an object can be used
    to supply a read/write function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数遵循与发送给 `ko.computed` 的第一个参数相同的规则；一个函数将用于创建只读计算，或者一个对象可以用来提供读写函数。
- en: 'Once observables have been created, you can access them with `ko.getObservable`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了可观察对象后，您可以使用 `ko.getObservable` 来访问它们：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is useful while applying extenders or adding subscriptions. Extenders can
    also be applied by creating observables with `ko.observable` before calling `ko.track`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这在应用扩展器或添加订阅时非常有用。扩展器也可以通过在调用 `ko.track` 之前使用 `ko.observable` 创建可观察对象来应用。
- en: An example of all of these techniques can be seen in the `cp8-es5` branch.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术的示例可以在 `cp8-es5` 分支中看到。
- en: Browser support
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器支持
- en: As Knockout-ES5 uses JavaScript getters and setters, it will not work in browsers
    that do not support this feature. This is not a feature that can be shimmed or
    polyfilled with scripts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Knockout-ES5 使用 JavaScript 的 getter 和 setter，它将不支持此功能的浏览器中无法工作。这不是可以通过脚本模拟或填充的功能。
- en: Knockout gets a lot of flak for the syntax that results from the decision to
    make observable object functions. Going by the popularity of questions on Stack
    Overflow, it is certainly one of the most confusing aspects to newcomers. The
    decision to do this was made so that support for older browsers such as Internet
    Explorer 6, which doesn't support JavaScript getters and setters, was possible.
    Now that Internet Explorer 6 is finally starting to lose its death grip on the
    browser market share, this supportability issue is becoming less and less important
    to web developers. Unfortunately, Internet Explorer didn't add support for ES5
    getters and setters until IE 9, which is still a high bar for most projects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Knockout 在创建可观察对象函数时的决策导致其语法受到很多批评。根据 Stack Overflow 上问题的流行程度，这无疑是新用户最困惑的方面之一。做出这个决定的目的是为了支持像
    Internet Explorer 6 这样的旧浏览器，这些浏览器不支持 JavaScript 的 getter 和 setter。现在，随着 Internet
    Explorer 6 终于开始失去对浏览器市场份额的控制，这个问题对网络开发者来说变得越来越不重要。不幸的是，直到 IE 9，Internet Explorer
    才添加了对 ES5 getter 和 setter 的支持，这对大多数项目来说仍然是一个很高的门槛。
- en: Realistically, as using Knockout ES5 has such a drastic impact on application
    syntax, switching to it on a that is project already underway is rarely feasible.
    Knockout ES5 should only be considered for new projects that do not have an old
    browser support requirement.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于使用 Knockout ES5 对应用语法有如此大的影响，因此在项目已经开始的情况下切换到它通常是不切实际的。Knockout ES5 应仅考虑用于没有旧浏览器支持要求的新项目。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Narrowing down the plugins and libraries to include in this chapter was difficult.
    Knockout's Wiki page on GitHub contains a long list of plugins ([https://github.com/knockout/knockout/wiki/Plugins](https://github.com/knockout/knockout/wiki/Plugins))—far
    too many to discuss here. If you are working with Knockout, you are encouraged
    to check out the community offerings, as it could end up saving you a lot of work.
    Not all of these plugins will be useful to everyone or every project, but hopefully,
    they give you an idea of what can be done with Knockout and motivate you to share
    some of your own work with the community.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 确定要包含在本章中的插件和库是一个难题。Knockout 在 GitHub 上的 Wiki 页面包含了一个长长的插件列表([https://github.com/knockout/knockout/wiki/Plugins](https://github.com/knockout/knockout/wiki/Plugins))——这里讨论的太多，难以一一列举。如果你在使用
    Knockout，我们鼓励你查看社区提供的资源，因为这可能会为你节省大量工作。并非所有这些插件都对每个人或每个项目都有用，但希望它们能给你一些关于 Knockout
    可以做什么的灵感，并激励你与社区分享你的一些工作。
- en: In the next chapter, we will be taking a deep dive into Knockout's internals
    to see how it works.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 Knockout 的内部机制，以了解其工作原理。
