- en: The State of JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 的现状
- en: avaScript has not traditionally been considered a backend language; that space
    belonged to the likes of Java, Python, C/C++, C#/.NET, PHP, Ruby and so on. JavaScript
    was just a 'toy language' that allowed web developers to add animation to websites
    in order to improve its aesthetics. But this all changed with the advent of **Node.js**.
    With Node.js, developers can now write JavaScript code that executes on the server,
    as well as the client. In other words, developers can now write both front and
    backend code using *the same language*!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 一直未被传统地视为后端语言；那个领域属于 Java、Python、C/C++、C#/.NET、PHP、Ruby 等语言。JavaScript
    只是一个允许网页开发者添加动画以改善其美学的“玩具语言”。但随着 **Node.js** 的出现，这一切都改变了。有了 Node.js，开发者现在可以编写在服务器端以及客户端执行的
    JavaScript 代码。换句话说，开发者现在可以使用 *同一种语言* 编写前后端代码！
- en: This provides huge productivity benefits, as common code can now be shared across
    the stack. Furthermore, developers can avoid context switching between different
    languages, which often breaks concentration and reduces output.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了巨大的生产力优势，因为现在可以跨整个技术栈共享通用代码。此外，开发者可以避免在不同语言之间切换上下文，这通常会导致注意力分散并降低产出。
- en: It also led to the rise in **Isomorphic**, or **Universal**, JavaScript frameworks,
    such as *Meteor*. These types of frameworks allow you to write applications entirely
    in JavaScript that run on both the client and the server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这也导致了 **同构** 或 **通用** JavaScript 框架（如 *Meteor*）的兴起。这类框架允许你完全使用 JavaScript 编写在客户端和服务器上运行的应用程序。
- en: 'Here''s what we''ll cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Examining a short history on the evolution of the web application and its transition
    from the **client-server model** to **Single-Page Applications (SPAs)**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检视网络应用程序的演变简史及其从 **客户端-服务器模型** 向 **单页应用程序 (SPAs**) 的转变
- en: Explaining the concept of Isomorphic JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释同构 JavaScript 的概念
- en: Exploring the benefits of using JavaScript across the entire stack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索在整个技术栈中使用 JavaScript 的好处
- en: Evolution of the web application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序的演变
- en: 'When you type a URL, such as `www.example.com`, into your browser, what actually
    happens? First, the browser would send a request to one of Example Corp''s servers,
    which retrieves the resource requested (for example, an HTML file), and sends
    it back to the client:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中输入一个 URL，例如 `www.example.com`，实际上会发生什么？首先，浏览器会向 Example Corp 的服务器之一发送请求，该服务器检索请求的资源（例如，一个
    HTML 文件），并将其发送回客户端：
- en: '![](img/142965cf-7095-49d0-b30b-51d24cc0dd30.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/142965cf-7095-49d0-b30b-51d24cc0dd30.jpg)'
- en: The browser then parses the HTML, retrieves all the files the web page depends
    on, such as CSS, JavaScript, and media files, and renders it onto the page.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器随后解析 HTML，检索网页所依赖的所有文件，例如 CSS、JavaScript 和媒体文件，并将它们渲染到页面上。
- en: '![](img/bf7fadd0-1869-4b96-8c8c-263b01bb6f27.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf7fadd0-1869-4b96-8c8c-263b01bb6f27.jpg)'
- en: The browser consumes flat, one-dimensional texts (HTML, CSS) and parses them
    into tree-like structures (DOM, CSSOM) before rendering it onto the page.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器消耗平面、一维文本（HTML、CSS），并在将其渲染到页面上之前将它们解析成树状结构（DOM、CSSOM）。
- en: This scheme is known as the *client-server model*. In this model, most of the
    processing is handled server-side; the client's role is limited to simple and
    superficial uses, such as rendering the page, animating menus and image carousels,
    and providing event-based interactivity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案被称为 *客户端-服务器模型*。在这个模型中，大部分处理都在服务器端进行；客户端的角色仅限于简单的表面用途，例如渲染页面、动画菜单和图片轮播，以及提供基于事件的交互性。
- en: This model was popular in the 1990s and 2000s, when web browsers were not very
    powerful. Creating entire applications with JavaScript on the client side was
    unheard of, and those that had that requirement resorted to Java applets and Adobe
    Flash (and, to a certain extent, Microsoft Silverlight). However, over time, the
    computing power of personal devices, such as desktop computers, laptops, and smartphones
    increased dramatically, and this allowed browsers to handle more elaborate operations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型在 1990 年代和 2000 年代非常流行，当时网络浏览器的功能并不强大。在客户端使用 JavaScript 创建整个应用程序是闻所未闻的，那些有这种需求的人求助于
    Java 小程序和 Adobe Flash（以及在一定程度上，Microsoft Silverlight）。然而，随着时间的推移，个人设备（如台式电脑、笔记本电脑和智能手机）的计算能力大幅提升，这使得浏览器能够处理更复杂的操作。
- en: Just-in-time (JIT) compilers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时 (JIT) 编译器
- en: Between 2008 and 2009, Mozilla, the company behind Firefox, slowly introduced
    *TraceMonkey*, the first **Just-in-time (JIT)** compiler for JavaScript, in different
    versions of Firefox 3.x, starting with 3.1\. Similarly, the *V8* JavaScript Engine,
    which powers Chrome and Safari, and *Chakra*, which powers Internet Explorer and
    Edge, also included a JIT compiler.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在2008年至2009年之间，Firefox背后的公司Mozilla，在Firefox 3.x的不同版本中缓慢引入了*TraceMonkey*，这是JavaScript的第一个**即时编译器（JIT**），从3.1版本开始。同样，Chrome和Safari背后的*V8*
    JavaScript引擎，以及为Internet Explorer和Edge提供动力的*Chakra*，也包含了JIT编译器。
- en: Traditionally, the JavaScript engine uses an **interpreter**, which translates
    the JavaScript source code into **machine code** that your computer can run. The
    JIT compiler improved the performance of the engine by identifying blocks of code
    that are frequently run, compiling them, and adding them to a cache. When the
    same block of code needs to be run again at a later time, the JavaScript engine
    can simply run the cached, pre-compiled machine code, skipping the interpreter
    altogether. Needless to say, this is much faster and the JavaScript engine can
    execute more operations per unit time, greatly increasing performance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，JavaScript引擎使用**解释器**，它将JavaScript源代码翻译成计算机可以运行的**机器代码**。JIT编译器通过识别频繁运行的代码块，编译它们并将它们添加到缓存中，从而提高了引擎的性能。当同一代码块需要在以后的时间再次运行时，JavaScript引擎可以简单地运行缓存的预编译机器代码，完全跳过解释器。不用说，这要快得多，JavaScript引擎可以在单位时间内执行更多的操作，从而大大提高性能。
- en: Single page applications (SPAs)
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用程序（SPAs）
- en: Because of this increased performance, developers can now build feature-rich
    JavaScript applications that run on the browser. Google was the first major company
    to take advantage of this, when they released the first **client-side web application
    framework**—*Angular* - on 20 October 2010\. Since then, many competitors have
    emerged, including *Ember*, *React*, and *Vue.js*, but Angular still remains relevant
    today.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种性能的提升，开发者现在可以构建运行在浏览器上的功能丰富的JavaScript应用程序。谷歌是第一个利用这一优势的主要公司，他们在2010年10月20日发布了第一个**客户端Web应用程序框架**——*Angular*。从那时起，许多竞争对手相继出现，包括*Ember*、*React*和*Vue.js*，但Angular至今仍具有相关性。
- en: Angular is a framework for building SPAs. Instead of delegating the bulk of
    the processing to the server, the client takes on most of the responsibility.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个用于构建SPAs的框架。它不像将大部分处理委托给服务器，而是客户端承担了大部分责任。
- en: Let's take an e-commerce web application as an example. In the client-server
    model, when the server receives a request from the client, it will compose a fully-formed
    HTML and attach it as the payload of the response. If it needs data from the database,
    it will query the database and inject the data into an HTML template to produce
    the fully-formed HTML. The client, usually a browser, is then entrusted with the
    simple task of rendering the HTML onto the screen.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个电子商务Web应用程序为例。在客户端-服务器模型中，当服务器收到客户端的请求时，它将组合一个完整的HTML并将其作为响应的有效负载附加。如果它需要从数据库中获取数据，它将查询数据库并将数据注入HTML模板以生成完整的HTML。然后，客户端，通常是一个浏览器，被委托执行简单的任务，将HTML渲染到屏幕上。
- en: 'In the SPA model, the server would initially send the entire application, including
    any HTML, CSS, and JavaScript files, to the client. All the application logic,
    including routing, now resides on the client. Because of this, the client can
    update the UI of the application very quickly, as it does not need to wait for
    a response from the server. Whenever the client requires information it does not
    have, such as certain entries in the database, it will send a request to the server.
    The server would then respond with the raw data, usually presented in JSON format,
    and nothing else. It is then the client''s job to process this information and
    update the UI appropriately. With SPAs, most of the logic is handled client-side;
    the server''s job is simply to retrieve and send back data:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在SPA模型中，服务器最初会将整个应用程序发送给客户端，包括任何HTML、CSS和JavaScript文件。所有应用程序逻辑，包括路由，现在都驻留在客户端。正因为如此，客户端可以非常快速地更新应用程序的用户界面，因为它不需要等待服务器的响应。每当客户端需要它没有的信息，例如数据库中的某些条目时，它将向服务器发送请求。然后服务器会以原始数据的形式响应，通常是JSON格式，不再发送其他内容。然后客户端的任务就是处理这些信息并适当地更新用户界面。在SPAs中，大部分逻辑都在客户端处理；服务器的任务仅仅是检索并发送数据：
- en: '![](img/23fcb8b6-092c-4a84-9d8b-278dee9a49c1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23fcb8b6-092c-4a84-9d8b-278dee9a49c1.jpg)'
- en: 'The SPA model has many benefits over the client-server model:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端-服务器模型相比，SPA模型有许多优点：
- en: It frees up the server to handle more requests, as requests are simpler to process.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它释放了服务器以处理更多请求，因为请求更容易处理。
- en: It allows the UI of the app to respond more quickly to user interaction because
    the UI does not need to wait for the server to respond before updating itself.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得应用程序的UI能够更快地响应用户交互，因为UI不需要等待服务器响应才能更新自己。
- en: Nowadays, most web applications are built with an SPA framework. Tesla, Sony,
    Microsoft Support, Genius, Renault, Staples, Udemy, and Healthcare.gov are all
    websites built with Angular; Airbnb, Asana, BBC, Dropbox, Facebook, Lyft, Netflix,
    PayPal, and Uber all use React on their websites; although Vue.js is relatively
    new, several major Asian companies have already adopted it, such as Alibaba, Baidu,
    Tencent, Xiaomi, and Line.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数Web应用程序都是使用SPA框架构建的。Tesla、Sony、Microsoft Support、Genius、Renault、Staples、Udemy和Healthcare.gov都是使用Angular构建的网站；Airbnb、Asana、BBC、Dropbox、Facebook、Lyft、Netflix、PayPal和Uber都在他们的网站上使用React；尽管Vue.js相对较新，但一些主要亚洲公司已经采用了它，例如阿里巴巴、百度、腾讯、小米和Line。
- en: Isomorphic JavaScript applications
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同构JavaScript应用
- en: However, everything has its drawbacks, and SPAs are no exception. The most obvious
    shortcoming of SPAs is that more code needs to be transferred at the beginning,
    which can increase the initial load time of the page. To counteract this deficiency,
    a technique called **server-side rendering** (**SSR**) can be employed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何事物都有其缺点，SPA也不例外。SPA最明显的缺点是需要传输更多的代码，这可能会增加页面的初始加载时间。为了克服这一缺陷，可以采用称为**服务器端渲染**（**SSR**）的技术。
- en: With SSR, the initial page is processed and rendered on the server in the same
    way as the traditional client-server model. However, the returned HTML contains
    a tag that'll request the rest of the application to be downloaded at a later
    time, after the initial page has been successfully rendered. This allows us to improve
    the initial page load speed, whilst keeping all the benefits of the SPA. Furthermore,
    SSR is also useful for ensuring **Search Engine Optimization** (**SEO**) performance,
    as it helps web crawlers to quickly decipher how a page should look, without having
    to download all the assets.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSR（服务器端渲染），初始页面以与传统客户端-服务器模型相同的方式在服务器上处理和渲染。然而，返回的HTML包含一个标签，将在稍后时间请求下载应用程序的其余部分，在初始页面成功渲染之后。这使我们能够提高初始页面加载速度，同时保持所有SPA（单页应用）的优点。此外，SSR对于确保**搜索引擎优化**（**SEO**）性能也非常有用，因为它帮助网络爬虫快速解析页面应该如何显示，而无需下载所有资源。
- en: SSR can be used alongside other techniques, such as **code splitting** and **tree
    shaking**, to reduce the size of the initial response payload, thus reducing the
    **time-to-first-render** (**TTFR**) and improving the user experience.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SSR可以与其他技术（如**代码拆分**和**树摇**）结合使用，以减小初始响应负载的大小，从而减少**首次渲染时间**（**TTFR**）并提高用户体验。
- en: This is the state of the web application today. New web standards such as **HTTP/2**
    and **WebAssembly** (a.k.a. *Wasm*) may all change how we approach building web
    applications in the near future. In the fast-moving world of front-end development,
    this SPA + SSR model may soon be superseded by a new paradigm.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是当今Web应用程序的状态。新的Web标准，如**HTTP/2**和**WebAssembly**（又称*Wasm*），可能会在不久的将来改变我们构建Web应用程序的方法。在前端开发快速发展的世界中，这种SPA
    + SSR模型可能会很快被新的范式所取代。
- en: Benefits of Node.js
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的优点
- en: JavaScript is the language of the browser. There's no denying that. Next, let's
    examine the reasons why a developer should pick Node.js as the back-end language
    for their application. Although there are many reasons, here we've boiled it down
    to two factors—**context switching** and **shared code**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是浏览器的语言。这一点无可否认。接下来，让我们探讨为什么开发者应该选择Node.js作为他们应用程序的后端语言。尽管有许多原因，但在这里我们将其归结为两个因素——**上下文切换**和**共享代码**。
- en: Context switching
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文切换
- en: Context switching, or *task switching*, is when a developer is working on multiple
    projects, or in different languages, at the same time and has to switch between
    them regularly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文切换，或称*任务切换*，是指开发者同时处理多个项目或在不同的语言中工作，并需要定期在这之间切换。
- en: '"Doing more than one task at a time, especially more than one complex task,
    takes a toll on productivity."'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: “同时做多项任务，尤其是同时做多项复杂任务，会对生产力造成影响。”
- en: '– Multitasking: Switching costs (American Psychological Association)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: – 多任务：切换成本（美国心理学会）
- en: ([http://www.apa.org/research/action/multitask.aspx](http://www.apa.org/research/action/multitask.aspx))
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ([http://www.apa.org/research/action/multitask.aspx](http://www.apa.org/research/action/multitask.aspx))
- en: Switching between projects
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目间的切换
- en: Programming is an activity that requires you to keep many variables in memory
    at the same time—variable names, interfaces of different modules, application
    structure and many more. If you switch to a different project, you'll have to
    dump the context of the current project and load in the context of the new project.
    The time required for this switch increases with the complexity of the project,
    and varies from one individual to the next, but can take anything from a few minutes
    to a few hours. This makes development extremely inefficient.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是一项需要你同时记住许多变量的活动——变量名、不同模块的接口、应用程序结构等等。如果你切换到另一个项目，你将不得不丢弃当前项目的上下文并加载新项目的上下文。这种切换所需的时间会随着项目的复杂性而增加，并且因人而异，但可能从几分钟到几小时不等。这使得开发过程极其低效。
- en: This is why, instead of multitasking, you should complete one project before
    moving on to another.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么，你应该在开始另一个项目之前先完成一个项目，而不是同时处理多个任务。
- en: Switching between languages
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言间的切换
- en: 'The same principle applies when switching between different programming languages.
    When switching between projects, you need to juggle between different contexts;
    when switching between languages, you need to juggle between different syntax,
    data structures, and ecosystems. To demonstrate, the following table illustrates
    some key differences between Python and JavaScript:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同编程语言之间切换时，同样适用这个原则。在项目间切换时，你需要在不同上下文之间切换；在语言间切换时，你需要在不同语法、数据结构和生态系统之间切换。为了说明，以下表格展示了
    Python 和 JavaScript 之间的一些关键差异：
- en: '| **Python** | **JavaScript** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **JavaScript** |'
- en: '| Has many data types, including `None`, Boolean, `int`, `float`, `complex`, `list`,
    `tuple`, `range`, `str`, `bytes`, `bytearray`, `memoryview`, `set`, `frozenset`,
    `dict`, and many more | Has seven data types: `undefined`, `null`, `Boolean`,
    `number`, `string`, `symbol`, and `object` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 有许多数据类型，包括 `None`，布尔型，`int`，`float`，`complex`，`list`，`tuple`，`range`，`str`，`bytes`，`bytearray`，`memoryview`，`set`，`frozenset`，`dict`
    等等 | 有七个数据类型： `undefined`，`null`，布尔型，`number`，`string`，`symbol` 和 `object` |'
- en: '| Statements are grouped by indentation | Statements are grouped by blocks,
    expressed using enclosing braces (`{}`) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 语句通过缩进来分组 | 语句通过使用括号（`{}`）表示的块来分组 |'
- en: '| Uses [`virtualenv`](https://virtualenv.pypa.io/en/stable/) to create isolated
    environments | Uses **Node Version Manager** ([https://github.com/creationix/nvm](https://github.com/creationix/nvm))
    (**nvm**), `package.json`, and the local `node_modules` directory to create isolated
    environments |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 使用 [`virtualenv`](https://virtualenv.pypa.io/en/stable/) 来创建隔离环境 | 使用 **Node
    版本管理器** ([https://github.com/creationix/nvm](https://github.com/creationix/nvm))
    （**nvm**），`package.json` 和本地的 `node_modules` 目录来创建隔离环境 |'
- en: '| Uses a class-based inheritance model | Uses a prototype-based inheritance
    model |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 使用基于类的继承模型 | 使用基于原型的继承模型 |'
- en: In addition to syntactical differences, different languages may also follow
    different paradigms—Elixir is a functional language, whereas Java is an **object-oriented**
    (**OO**) **language**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语法上的差异，不同的语言可能还会遵循不同的范式——Elixir 是一种函数式语言，而 Java 是一种**面向对象**（**OO**）的**语言**。
- en: Therefore, context-switching between different languages also makes the development
    process very inefficient.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在不同语言之间进行上下文切换也会使开发过程非常低效。
- en: The business perspective
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业视角
- en: 'From a business point of view, using different languages for the front- and
    back-end means they need to hire two different types of developer: JavaScript
    developers for the front-end and, say, Python developers for the back-end. If
    there''s a large backlog in back-end tasks, front-end developers wouldn''t be
    able to help (unless they also know Python). This makes resource allocation more
    difficult for project managers. But if everyone develops in JavaScript, then this
    problem becomes null.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从商业角度来看，前端和后端使用不同的语言意味着他们需要雇佣两种不同类型的开发者：前端使用 JavaScript 开发者，后端可以使用 Python 开发者。如果后端任务有大量积压，前端开发者就无法提供帮助（除非他们也了解
    Python）。这使得项目经理的资源分配更加困难。但如果每个人都使用 JavaScript 进行开发，那么这个问题就消失了。
- en: Furthermore, using JavaScript for the entire stack makes the development process
    more efficient. Apart from the efficiencies gained by avoiding context switching,
    a single developer can now develop an entire feature from start to finish, as
    they can code both the front- and back-end.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 JavaScript 整个栈可以使开发过程更加高效。除了避免上下文切换带来的效率提升外，现在单个开发者可以从头到尾开发一个完整的功能，因为他们可以编写前端和后端。
- en: Shared code
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享代码
- en: As Node.js and SPAs have became more popular, more and more JavaScript libraries
    are being written every day. At the time of writing, over 775,000 packages are
    listed on [npmjs.com](http://npmjs.com), the *de facto* package manager for JavaScript. These
    include libraries for handling time and date (`moment.js`), utility libraries
    (`lodash`), and even a deep learning library (`convnetjs`).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Node.js和SPAs变得越来越受欢迎，每天都有越来越多的JavaScript库被编写。在撰写本文时，超过775,000个包列在[npmjs.com](http://npmjs.com)，这是JavaScript的*事实上的*包管理器。这些包括处理时间和日期的库（`moment.js`）、实用库（`lodash`），甚至深度学习库（`convnetjs`）。
- en: '**npm packages** were originally only meant to be installed and run by server-side
    Node.js; however, tools such as **Browserify** and **Webpack** allowed us to bundle
    these dependencies and send them to the client. Now, many npm packages can be
    used in both the front- and back-end.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm包**最初仅意味着由服务器端Node.js安装和运行；然而，像**Browserify**和**Webpack**这样的工具允许我们将这些依赖项打包并发送到客户端。现在，许多npm包可以在前端和后端同时使用。'
- en: Likewise, by using JavaScript across your entire stack, you can encapsulate
    common logic and use it across both environments. For example, authentication
    checks should be performed on both the server (for security reasons) as well as
    the client (to ensure performance by preventing unnecessary requests).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过在整个堆栈中使用JavaScript，你可以封装通用逻辑并在两个环境中使用它。例如，身份验证检查应在服务器（出于安全原因）以及客户端（通过防止不必要的请求来确保性能）上执行。
- en: If JavaScript is used for front- and back-end code, then the code can be shared
    and reused. If, however, we use Python in the back-end, then the same logic must
    be duplicated in JavaScript. This violates the **Don't Repeat Yourself** (**DRY**)
    principle and makes our development process slower and more error-prone.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JavaScript用于前端和后端代码，那么代码可以共享和重用。然而，如果我们使用Python作为后端，那么相同的逻辑必须在JavaScript中重复。这违反了**不要重复自己**（DRY）原则，并使我们的开发过程变得更慢且更容易出错。
- en: The project also becomes harder to maintain. Now, when we need to make changes
    to the code, we must update it twice, in two different languages, possibly across
    two different projects; both projects may also need to be deployed at the same
    time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 项目也变得更加难以维护。现在，当我们需要修改代码时，我们必须在两种不同的语言中更新两次，可能是在两个不同的项目中；这两个项目可能还需要同时部署。
- en: Therefore, using JavaScript in the front-end and Node.js in the back-end allows
    you to improve maintainability, reduce compatibility issues, and conserve manpower
    and development time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前端使用JavaScript，在后端使用Node.js，可以使你提高可维护性，减少兼容性问题，并节省人力和开发时间。
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described the evolution of web applications from using the
    client-server model to SPAs, and how advances in JavaScript engines facilitated
    this transformation. Then, we discussed the benefits of using JavaScript across
    the stack, focusing on the topics of context switching and shared code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了从使用客户端-服务器模型到单页应用（SPAs）的演变过程，以及JavaScript引擎的进步如何促进了这一转变。然后，我们讨论了在堆栈中使用JavaScript的好处，重点关注上下文切换和共享代码的话题。
