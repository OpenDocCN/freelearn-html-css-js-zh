- en: Developing the Backend
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发后端
- en: Developing the backend without servers is the main drive of the serverless concept
    and what makes it so interesting. In this model, a paradigm shift is to break
    the project into small pieces of logic that can be deployed separately instead
    of one single bloated application. How to architecture this separation is covered
    in this chapter. Also, we will continue the development of our serverless online
    store building the backend using the REST principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有服务器的情况下开发后端是无服务器概念的主要驱动力，也是它如此有趣的原因。在这个模型中，范式转变是将项目分解成可以单独部署的小逻辑块，而不是一个单一的庞大应用程序。如何架构这种分离将在本章中介绍。此外，我们将继续开发我们的无服务器在线商店，使用REST原则构建后端。
- en: 'In a nutshell, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将涵盖以下主题：
- en: An overview of serverless architectures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器架构概述
- en: Organizing the project's code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织项目的代码
- en: How to create RESTful services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建RESTful服务
- en: After this chapter, you'll have built the backend of our serverless online store.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章之后，你将构建我们无服务器在线商店的后端。
- en: Defining the project architecture
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义项目架构
- en: 'In this section, we will cover four different architectural approaches for
    serverless projects:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍四种不同的无服务器项目架构方法：
- en: '**Nanoservices**: This is where **each functionality** has its **own Lambda**
    function'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纳米服务**：这里每个**功能**都有自己的**Lambda**函数'
- en: '**Microservices**: This is where **each Lambda** handles **all HTTP verbs**
    of a single resource'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务**：这里每个**Lambda**处理单个资源的**所有HTTP动词**'
- en: '**Monolith**: This is where **one single Lambda** function handles **all functionalities**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单体**：这里**单个Lambda**函数处理**所有功能**'
- en: '**Graph**: This uses the **GraphQL** standard, which is an alternative to REST
    APIs'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图**：这使用的是**GraphQL**标准，它是REST API的替代品'
- en: As we will see, each architectural approach has its pros and cons and there
    is no *silver bullet*. You need to weigh the benefits and choose what you think
    is the best for your specific use case. Let's see more about them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，每种架构方法都有其优点和缺点，没有**万能药**。你需要权衡利弊，选择你认为最适合你特定用例的方案。让我们更深入地了解它们。
- en: Monolith versus Microservices
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体与微服务
- en: The first thing that we need to think about when choosing a serverless architecture
    is if the application will execute with just one Lambda function (**Monolith**
    or **Graph**) or if it will have multiple Lambdas (**Microservices** or **Nanoservices**).
    The number of Lambda functions represents how many deployment units it has.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 选择无服务器架构时，我们首先需要考虑的是应用程序是否仅使用一个Lambda函数执行（**单体**或**图**）或者它将拥有多个Lambda函数（**微服务**或**纳米服务**）。Lambda函数的数量代表了它有多少个部署单元。
- en: A monolith is a self-contained application where all functionalities are developed
    in a single solution and a modification in one piece of the code requires a new
    deployment of the whole solution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单体是一个包含所有功能的自包含应用程序，所有功能都在单个解决方案中开发，对代码中某一部分的修改需要整个解决方案的新部署。
- en: The microservices architecture is the opposite. You have multiple units that
    can be deployed separately, where each one is responsible for a distinct part
    of the whole solution. To follow the microservices architecture, you need to add
    modularity to the application. You break a large application into a set of small
    services that can communicate with each other through HTTP requests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是相反的。你有多个可以单独部署的单元，每个单元负责整个解决方案的一个特定部分。要遵循微服务架构，你需要向应用程序添加模块化。你将一个大应用程序分解成一组小型服务，这些服务可以通过HTTP请求相互通信。
- en: Microservices uses the concept of bounded context. For example, in an online
    store, we have a context for **sales**, which represents all business rules related
    to selling products, and another context for **support**, which involves the features
    related with customer service. We can separate those concerns considering that
    they have different business rules and are able to evolve independently. Modifications
    in a support rule must not impact a sales feature, so you can deploy one service
    without deploying the other, which makes it easier for different teams to work
    in different contexts at the same time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务使用边界上下文的概念。例如，在一个在线商店中，我们有**销售**上下文，它代表与销售产品相关的所有业务规则，还有另一个**支持**上下文，涉及与客户服务相关的功能。我们可以根据它们有不同的业务规则并且能够独立演进来分离这些关注点。支持规则的修改不应影响销售功能，因此你可以部署一个服务而不部署另一个，这使得不同的团队能够同时在不同上下文中工作。
- en: 'In general, microservices offer the following benefits:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，微服务提供以下好处：
- en: Better separation of concerns and modularity
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的关注点分离和模块化
- en: Independent and frequent deployment
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立且频繁的部署
- en: Easier parallel development using separated teams
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分离的团队更容易进行并行开发
- en: 'As with everything else, it is accompanied with some drawbacks, which are as
    follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一切一样，它也伴随着一些缺点，如下所示：
- en: More DevOps effort (which is mitigated by the Serverless Framework)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更多的DevOps工作（但可以通过Serverless Framework缓解）
- en: A distributed system adds complexity
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式系统增加了复杂性
- en: Integration tests between multiple services are harder
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之间多个服务的集成测试更困难
- en: Nanoservices
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纳米服务
- en: A nanoservice is the smallest part that you can extract from a monolithic application.
    You can split a monolith into multiple microservices, but those microservices
    can also be split into multiple nanoservices.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 纳米服务是从单体应用程序中可以提取的最小部分。你可以将单体拆分为多个微服务，但这些微服务也可以进一步拆分为多个纳米服务。
- en: For example, you can have a **users** microservice that is responsible for handling
    all operations related with users such as create, retrieve, update, delete, password
    recovery, and others. *Retrieving* a user is a single functionality that can be
    very simple, implemented with less than 10 lines of code. If you create a Lambda
    function just for this piece of logic, you are creating a nanoservice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以有一个**用户**微服务，负责处理与用户相关的所有操作，如创建、检索、更新、删除、密码恢复等。*检索*用户是一个单一的功能，可以非常简单，用不到10行代码实现。如果你只为这一段逻辑创建一个Lambda函数，你就是在创建一个纳米服务。
- en: 'The following diagram shows that each exposed functionality has its own Lambda
    function and an HTTP endpoint:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了每个公开的功能都有自己的Lambda函数和HTTP端点：
- en: '![](img/fbbf9f4c-58b2-4876-8d33-3589541e5bcb.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbbf9f4c-58b2-4876-8d33-3589541e5bcb.png)'
- en: 'To build an application like this, we need to configure the `serverless.yml`
    file giving each function its own endpoint:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这样的应用程序，我们需要配置`serverless.yml`文件，为每个函数分配其自己的端点：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Due to simplicity, this example has ignored the `OPTIONS` verb that would be
    required in this solution because the browser, in cross-origin requests, preflights
    an `OPTIONS` request to check the CORS headers before executing `POST`, `PUT`,
    `PATCH`, and `DELETE`. We'll cover more about this later in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于简单性，这个例子忽略了在这个解决方案中所需的`OPTIONS`动词，因为在跨源请求中，浏览器在执行`POST`、`PUT`、`PATCH`和`DELETE`之前，会预先发送一个`OPTIONS`请求来检查CORS头。我们将在本章后面更详细地介绍这一点。
- en: 'For this architecture, we can list the pros and cons as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种架构，我们可以列出以下优缺点：
- en: '**Pros**:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: Separation of concerns allows you to modify one feature without affecting other
    parts of your system. Autonomous teams will also benefit from a minimized number
    of conflicts.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点的分离允许你修改一个功能而不影响系统的其他部分。自治团队也将从最小化冲突中受益。
- en: Debugging problems is much easier when a function has a single responsibility.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个函数只有一个责任时，调试问题会更容易。
- en: '**Cons**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: Performance can be slower. Since some functions will be rarely triggered, cold
    start delays will be more frequent.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能可能会较慢。由于某些函数很少被触发，冷启动延迟会更频繁。
- en: In a big project, you can end up with hundreds of functions! A huge number of
    logical parts may cause more harm than benefit.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型项目中，你可能会拥有数百个函数！大量的逻辑部分可能会造成弊大于利。
- en: Microservices
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'The microservices pattern adds modularization of functionalities related to
    the bounded context of an application. In this architecture, each Lambda function
    handles all HTTP verbs of a single resource. It generally results in having five
    endpoints (**GET**, **POST**, **PUT**, **DELETE**, **OPTIONS**) per function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务模式增加了与应用程序边界上下文相关的功能模块化。在这个架构中，每个Lambda函数处理单个资源的所有HTTP动词。这通常导致每个函数有五个端点（**GET**、**POST**、**PUT**、**DELETE**、**OPTIONS**）：
- en: '![](img/979fae5f-25dd-479d-8655-30052162db06.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/979fae5f-25dd-479d-8655-30052162db06.png)'
- en: 'The preceding system can be defined by the `serverless.yml` file as two bounded
    contexts, where all HTTP verbs of a given context reference the same Lambda function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述系统可以通过`serverless.yml`文件定义为两个边界上下文，其中给定上下文的所有HTTP动词都引用相同的Lambda函数：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This architecture has the following pros and cons:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构有以下优缺点：
- en: '**Pros**:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: Results in a reduced number of Lambda functions to manage
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果是管理的Lambda函数数量减少
- en: With less cold starts, performance can be slightly better than nanoservices
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于冷启动较少，性能可能略优于纳米服务
- en: '**Cons**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: Debugging is a little bit more complicated, since each function has more options
    and possible outcomes
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试稍微复杂一些，因为每个函数都有更多的选项和可能的输出
- en: Requires implementing a routing mechanism to handle each request correctly
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要实现一个路由机制来正确处理每个请求
- en: 'This routing mechanism can be implemented with a simple `switch…case` statement
    using the Lambda event to find the HTTP method and the REST resource:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种路由机制可以通过使用 Lambda 事件来查找 HTTP 方法以及 REST 资源的简单 `switch…case` 语句来实现：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Monolith
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体
- en: 'The monolith pattern uses just one Lambda function to handle all functionalities
    of our application. In this case, we have all of the application''s endpoints
    triggering the same Lambda function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单体模式仅使用一个 Lambda 函数来处理我们应用程序的所有功能。在这种情况下，我们所有的应用程序端点都会触发同一个 Lambda 函数：
- en: '![](img/ac0aba89-cf96-4c75-8112-823ef5d39353.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac0aba89-cf96-4c75-8112-823ef5d39353.png）'
- en: 'The preceding example can be represented as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例可以表示如下：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A monolith architecture is not necessarily bad. For small applications that
    need to minimize cold delays, it can be indeed the best option. Let's now look
    at the pros and cons.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构并不一定不好。对于需要最小化冷启动延迟的小型应用程序，它确实可能是最佳选择。现在，让我们看看其优缺点。
- en: '**Pros**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: When all endpoints use the same Lambda function, the code will be constantly
    cached and cold starts will hardly happen
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有端点都使用同一个 Lambda 函数时，代码将会被持续缓存，冷启动几乎不会发生
- en: Fast deployments as there is just one resource
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署快速，因为只有一个资源
- en: '**Cons**:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: Requires building a complex routing system to handle each request, for big applications,
    it can be transformed in a *big ball of mud*
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要构建一个复杂的路由系统来处理每个请求，对于大型应用程序，它可能会变成一个 *一团糟*
- en: If the code base grows too much with too many dependencies, the performance
    of a single execution will be reduced
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码库因为过多的依赖而变得过于庞大，单个执行的性能将会降低
- en: Debugging problems will be much more difficult
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试问题将会更加困难
- en: It's much harder to provision memory and set timeouts since each code path has
    a distinct execution
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个代码路径都有独特的执行，因此分配内存和设置超时更加困难
- en: Graph
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: The Graph pattern is based on the GraphQL standard that was proposed by Facebook.
    It is an emerging technology with the objective to provide an alternative to RESTful
    APIs. Since it is growing in popularity among serverless projects, it deserves
    a section in this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图模式基于 Facebook 提出的 GraphQL 标准。它是一种新兴技术，旨在提供 RESTful API 的替代方案。由于它在无服务器项目中越来越受欢迎，本书中应该有一节来介绍它。
- en: 'In this pattern, we have just one Lambda function with a single endpoint. This
    endpoint is a query that will trigger the GraphQL to fetch the corresponding data
    in any form that the client needs:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式中，我们只有一个 Lambda 函数和一个单一端点。此端点是一个查询，它将触发 GraphQL 以获取客户端需要的任何形式的数据：
- en: '![](img/6ee76037-ced9-489e-a48d-b9e81f1866ed.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ee76037-ced9-489e-a48d-b9e81f1866ed.png)'
- en: Having just one endpoint is not a restriction. You can have multiple endpoints,
    but the objective of this pattern is to reduce the number of interfaces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个端点并不构成限制。你可以有多个端点，但此模式的目的是减少接口数量。
- en: 'The `serverless.yml` file is very simplified:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`serverless.yml` 文件非常简化：'
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we will see a simple example of how to build a GraphQL API inside a Lambda
    function. Let''s take a look at the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到一个如何在 Lambda 函数内部构建 GraphQL API 的简单示例。让我们看看以下步骤：
- en: 'Install the GraphQL module (`npm install graphql --save`) and require it inside
    the `handler.js` function:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 GraphQL 模块（`npm install graphql --save`）并在 `handler.js` 函数中引入它：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step is to describe how your data is organized. In the following example,
    we have a `ShoppingCart` entity which contains a list of `Products` that the user
    wants to buy. The object key is the property name and the value is its data type.
    The schema is a string input that will be compiled by the `buildSchema` function:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是描述你的数据是如何组织的。在下面的示例中，我们有一个 `ShoppingCart` 实体，它包含用户想要购买的一组 `Products`。对象键是属性名，值是其数据类型。模式是一个字符串输入，它将被
    `buildSchema` 函数编译：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `decimal` data type is not a built-in data type, but you can count money
    in pennies instead of dollars with the `integer` type. GraphQL offers the `float`
    data type, but it is not reliable for handling currencies.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal` 数据类型不是一个内置的数据类型，但你可以使用 `integer` 类型以分而不是美元来计数货币。GraphQL 提供了 `float`
    数据类型，但它不适用于处理货币。'
- en: 'Now, take a look in this JSON object that follows the defined schema:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，看看下面这个遵循定义模式的 JSON 对象：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the entire dataset will be provided as an input to the `graphql`
    function through the `data` variable. However, in a real-world application, it
    would not be feasible to load the entire database to memory. What is done in this
    case is to define a resolver function in the schema definition that tells the
    GraphQL engine how to fetch the required data, which means how to query the database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，整个数据集将通过 `data` 变量作为输入提供给 `graphql` 函数。然而，在实际应用中，将整个数据库加载到内存中是不可行的。在这种情况下所做的是在模式定义中定义一个解析器函数，告诉
    GraphQL 引擎如何获取所需的数据，这意味着如何查询数据库。
- en: 'After defining how your data is structured and where it is, you can use `graphql`
    to query the data. This query will be defined by the client and will be available
    in the `event` input of the Lambda function. For example, consider this query
    sent by the client:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义了数据的结构和位置之后，你可以使用 `graphql` 查询数据。这个查询将由客户端定义，并将可在 Lambda 函数的 `event` 输入中找到。例如，考虑客户端发送的这个查询：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this query, the client wants to know the list of selected products, but there
    is some information that the client is not interested in. For example, the client
    doesn't want to know the `code` of the products or whether there is a `promotionCode`
    associated with this cart.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，客户端想要知道所选产品的列表，但有一些信息客户端不感兴趣。例如，客户端不想知道产品的 `code` 或是否与该购物车关联的 `promotionCode`。
- en: 'To use it in a Lambda function, call the `graphql` function passing the `schema`,
    `query`, and `data` arguments:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 Lambda 函数中使用它，请调用 `graphql` 函数并传递 `schema`、`query` 和 `data` 参数：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A request to this function would return the following JSON object:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对此函数的请求将返回以下 JSON 对象：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What makes GraphQL powerful is its simple syntax, that allows the client to
    request exactly what it needs and receive that data in the format that it expects.
    In this model, a single request can bring data from multiple resources. It can
    be an interesting alternative to RESTful APIs, but it also has its limitations.
    Ignoring the pros and cons related to REST, the following list compares the Graph
    pattern as a solution for a serverless architecture:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使 GraphQL 强大的是其简单的语法，它允许客户端请求它确切需要的数据，并以它期望的格式接收这些数据。在这个模型中，单个请求可以获取来自多个资源的数据。它可以是一个有趣的
    RESTful API 的替代品，但它也有其局限性。忽略与 REST 相关的优缺点，以下列表比较了图模式作为无服务器架构解决方案：
- en: '**Pros**:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: The Graph query can be a better replacement for the routing mechanism of the
    monolithic approach
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图查询可以更好地替代单体方法的路由机制
- en: When all endpoints use the same Lambda function, the code will be constantly
    cached and cold starts will hardly happen
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有端点都使用相同的 Lambda 函数时，代码将不断缓存，冷启动几乎不会发生
- en: Fast deployments as there is just one function and one endpoint
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署快速，因为只有一个函数和一个端点
- en: '**Cons**:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: The Lambda size may hurt the performance if the code base grows too much with
    too many dependencies
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码库随着太多依赖项的增长而变得太大，Lambda 的大小可能会影响性能
- en: It's much harder to provision memory and set timeouts since each query has a
    distinct execution
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个查询都有独特的执行，因此分配内存和设置超时时间要困难得多
- en: GraphQL has many other features and requires extensive material, which is not
    the focus of this book. For a start, you can learn more at [http://graphql.org/learn](http://graphql.org/learn).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 有许多其他功能，需要大量的资料，但这本书的重点不是这个。为了入门，你可以在 [http://graphql.org/learn](http://graphql.org/learn)
    上了解更多。
- en: Naming differences
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名差异
- en: The Serverless Framework's team shares a similar view of the serverless architectures,
    which you can check out at [https://serverless.com/blog/serverless-architecture-code-patterns](https://serverless.com/blog/serverless-architecture-code-patterns).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework 的团队对无服务器架构持有相似的看法，你可以在 [https://serverless.com/blog/serverless-architecture-code-patterns](https://serverless.com/blog/serverless-architecture-code-patterns)
    上查看。
- en: However, what I call “nanoservices”, they call “microservices”. In my opinion,
    microservice is not a good term to describe the architecture style where every
    single feature is considered as one microservice. The concept of microservices
    was created to designate monolithic applications that were broken down into a
    few distinct pieces to better handle the management and evolution of features.
    When you have too many pieces, the principles do not apply so easily. Fortunately,
    the Serverless Framework makes it easier to handle dozens of services, but for
    a traditional application, when a microservice is too fine-grained, the overhead
    of maintenance and communication overweighs its benefits and, for the purpose
    of differentiation, it is called here a nanoservice.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我所说的“纳米服务”，他们称之为“微服务”。在我看来，微服务不是一个很好的术语来描述每个单独的功能都被视为一个微服务的架构风格。微服务的概念是为了指代那些被分解成几个不同部分的单体应用程序，以便更好地处理功能和特性的管理和演进。当你有太多的部分时，这些原则就不那么容易应用了。幸运的是，Serverless
    Framework使得处理数十个服务变得更加容易，但对于传统应用程序来说，当微服务过于细粒度时，维护和通信的开销超过了它的好处，为了区分，这里将其称为纳米服务。
- en: Also, note that they have named the pattern that I call “microservices” as “services”.
    You can name these patterns as you prefer, but understand that those terms can
    be confusing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，他们将我称为“微服务”的模式命名为“服务”。您可以按自己的喜好命名这些模式，但请理解这些术语可能会造成混淆。
- en: 'The following diagram illustrates the difference between **Monolith**, **Microservices**,
    and **Nanoservices** architectures in my point of view:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了从我的角度来看，**单体**、**微服务**和**纳米服务**架构之间的区别：
- en: '![](img/ce9ba8e3-a048-4e04-aba2-4171ecd97410.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce9ba8e3-a048-4e04-aba2-4171ecd97410.png)'
- en: Developing the backend
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发后端
- en: After this overview of architectures, we can start building the backend. In
    this sample, which is only an experiment, I've opted for the monolith architecture
    because it reduces the cold start delays and our backend logic is very small.
    In your solution, you need to think about the use cases and weigh the benefits
    and drawbacks of each option.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在对架构进行了概述之后，我们可以开始构建后端。在这个仅作为实验的示例中，我选择了单体架构，因为它减少了冷启动延迟，而且我们的后端逻辑非常小。在你的解决方案中，你需要考虑用例，权衡每个选项的利弊。
- en: Defining the functionalities
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义功能
- en: 'In the previous chapter, we developed the frontend and hardcoded some data
    to display static pages. Now, we are going to create the backend to expose the
    necessary information that will be used by the frontend. Take a look at the following
    frontend views and what functionalities they will need from the backend:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开发了前端并硬编码了一些数据来显示静态页面。现在，我们将创建后端以公开前端将使用的信息。请查看以下前端视图以及它们将需要后端提供的哪些功能：
- en: '**Home page**: This page requires a list of all available products to display'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主页**：这个页面需要显示所有可用的产品列表'
- en: '**Product details**: This page requires the detailed information about a product,
    including the list of user comments'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**产品详情**：这个页面需要关于产品的详细信息，包括用户评论列表'
- en: '**Shopping Cart**: This page needs to display the selected products and allow
    the user to save or checkout the cart'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**购物车**：这个页面需要显示选定的产品，并允许用户保存或结账'
- en: '**Signup page**: The logic of this page will be implemented in [Chapter 8](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml),
    *Securing the Serverless Application*'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注册页面**：这个页面的逻辑也将在这个[第8章](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml)中实现，*保护无服务器应用程序*'
- en: '**Login page**: The logic of this page will also be implemented in [Chapter
    8](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml), *Securing the Serverless Application*'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**登录页面**：这个页面的逻辑也将在这个[第8章](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml)中实现，*保护无服务器应用程序*'
- en: '**Page not found**: There is no need to request the backend when the URL is
    invalid'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**页面未找到**：当URL无效时，无需请求后端'
- en: '**Error page**: This page won''t make any additional request to the backend
    when an error occurs'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**错误页面**：当发生错误时，这个页面不会向后端发出任何额外的请求'
- en: Besides those pages, we have a Navbar component that will be displayed for all
    pages and it has a notification icon. We are going to implement this feature in
    [Chapter 9](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml), *Handling Serverless
    Notifications*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些页面之外，我们还有一个将显示在所有页面上的Navbar组件，它有一个通知图标。我们将在这个[第9章](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml)中实现这个功能，*处理无服务器通知*。
- en: 'In a nutshell, we need to implement now the following functionalities:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们现在需要实现以下功能：
- en: Retrieve all available products to sell
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索所有可销售的产品
- en: Retrieve the details of a specific product
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索特定产品的详细信息
- en: Retrieve the list of selected products of the user's Shopping Cart
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索用户购物车中选定的产品列表
- en: Save the list of selected products
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存选定的产品列表
- en: Checkout a Shopping Cart
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结账购物车
- en: To make it simpler, second and third features will be provided in the result
    of the first feature, which means that when the user requests the list of all
    available products, the response object will bring all information about each
    product, as well as the information on whether the user has added the product
    to the Shopping Cart.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，第二和第三个功能将在第一个功能的结果中提供，这意味着当用户请求所有可用产品的列表时，响应对象将带来每个产品的所有信息，以及用户是否已将该产品添加到购物车的信息。
- en: Organizing the code
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织代码
- en: 'Choosing how to organize the files of a project is a personal choice. You just
    need to place the files using meaningful names that will make it easier to find
    them later. In this project, I''ve used the following structure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 选择如何组织项目的文件是一个个人选择。你只需使用有意义的名称放置文件，这样以后更容易找到它们。在这个项目中，我使用了以下结构：
- en: '![](img/28bda533-e59c-4168-b0a6-dc249ef3672c.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/28bda533-e59c-4168-b0a6-dc249ef3672c.png)'
- en: 'Here''s a brief description about each folder shown in the preceding screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是关于前一张截图显示的每个文件夹的简要描述：
- en: '`functions`: These are the Lambda functions that will be directly deployed
    to AWS. We have just one function because our application is a monolith. This
    function will handle all things related to products. We don''t need a Lambda function
    to handle user creation/authentication because we are going to use Cognito for
    this task.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functions`：这些是直接部署到 AWS 的 Lambda 函数。我们只有一个函数，因为我们的应用程序是一个单体。这个函数将处理与产品相关的一切。我们不需要
    Lambda 函数来处理用户创建/身份验证，因为我们打算使用 Cognito 来完成这项任务。'
- en: '`lib`: This is the common application logic that can be used by different Lambda
    functions.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`：这是可以被不同 Lambda 函数使用的通用应用程序逻辑。'
- en: '`node_modules`: These are Node dependencies that were installed in this project
    folder and are referenced by the `package.json` file. They will be zipped to be
    used by the Lambda functions.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules`：这些是安装在本项目文件夹中的 Node 依赖项，并由 `package.json` 文件引用。它们将被压缩以供 Lambda
    函数使用。'
- en: '`repositories`: This folder holds the infrastructure code to connect with the
    database and define the queries. It will be implemented in [Chapter 7](436e582c-0a4c-4257-b8eb-aa2c1dbd98c4.xhtml),
    *Using a Serverless Database*. In the screenshot, you can see that we are going
    to implement queries for SimpleDB and DynamoDB. The FakeDB will be used in this
    chapter to provide hardcoded data for testing.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repositories`：此文件夹包含连接数据库和定义查询的基础设施代码。它将在第 7 章，*使用无服务器数据库*中实现。在截图上，你可以看到我们将实现
    SimpleDB 和 DynamoDB 的查询。在本章中，将使用 FakeDB 提供硬编码数据以进行测试。'
- en: '`test`: This folder holds the unit and integration test files. It will be implemented
    in Chapter 10, *Testing, Deploying, and Monitoring*.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：此文件夹包含单元和集成测试文件。它将在第 10 章，*测试、部署和监控*中实现。'
- en: Referencing Lambda functions in other folders
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在其他文件夹中引用 Lambda 函数
- en: 'When you create a new service with the Serverless Framework, it will create
    a `serverless.yml` file to reference a sample function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Serverless Framework 创建新的服务时，它将创建一个 `serverless.yml` 文件来引用一个示例函数：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What you should note here is that `handler.hello` means that the Serverless
    Framework will try to find a `handler.js` file in the *same directory* as your
    `serverless.yml` file and look for an exported `hello` function. When you have
    a big project, you may prefer to separate your handler functions in subfolders.
    The syntax is pretty straightforward, `foldername/file.function`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意这里的是 `handler.hello` 意味着 Serverless Framework 将尝试在 `serverless.yml` 文件相同的目录下找到一个
    `handler.js` 文件，并查找导出的 `hello` 函数。当你有一个大项目时，你可能更喜欢将处理函数分离到子文件夹中。语法相当简单，`foldername/file.function`。
- en: 'Consider the following example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意的以下示例：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this project, I''ve used the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我使用了以下代码：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using multiple services
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个服务
- en: Another thing that you should note is that the Serverless Framework will create
    a ZIP folder only with the contents that are in the same level of the `serverless.yml`
    file or lower. It is not possible to include dependencies of upper levels. The
    implication is that if your project uses two different services, each one of them
    with a distinct `serverless.yml` file, you can't share dependencies directly between
    them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点你应该注意的是，Serverless Framework只会创建一个包含与`serverless.yml`文件同一级别或以下内容的ZIP文件夹。无法包含上级的依赖项。这意味着如果你的项目使用两个不同的服务，每个服务都有一个不同的`serverless.yml`文件，你无法直接在它们之间共享依赖项。
- en: 'The following screenshot illustrates an example of a project with this issue:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了具有此问题的项目示例：
- en: '![](img/bfd77654-e53b-40e5-9bce-1cdf0157220c.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfd77654-e53b-40e5-9bce-1cdf0157220c.png)'
- en: 'The `greetings.js` file is a simple Node.js module with just one line of code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`greetings.js`文件是一个简单的Node.js模块，只有一行代码：'
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Both the `handler.js` files from `service1` and `service2` were implemented
    to return a message using the `greetings` module:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`service1`和`service2`的`handler.js`文件都被实现为使用`greetings`模块返回消息：'
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The only difference between them is how the `greetings` module is loaded. In
    the first service, as it is in the same level, we load using the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的唯一区别在于如何加载`greetings`模块。在第一个服务中，由于它处于同一级别，我们使用以下代码进行加载：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the second service, we need to reference the `service1` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个服务中，我们需要引用`service1`文件：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you test the `service2` function locally (`serverless invoke local --function
    hello`), it will run without problems, but it will fail if deployed to AWS because
    the ZIP file will not be published with the dependency.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本地测试`service2`函数（`serverless invoke local --function hello`），它将无问题运行，但如果部署到AWS，则会失败，因为ZIP文件将不会发布依赖项。
- en: 'The following are two solutions for this problem:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此问题的两种解决方案：
- en: Avoid using several services. Aggregate them into a single service and place
    the merged `serverless.yml` file in the project root.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用多个服务。将它们聚合到一个单一的服务中，并将合并的`serverless.yml`文件放置在项目根目录。
- en: Use local npm packages to manage common dependencies.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地npm包来管理公共依赖项。
- en: 'Although I prefer the first option, the second option is also valid. To create
    a local npm package, browse to the folder that contains the common dependencies
    and run the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我更喜欢第一个选项，但第二个选项也是有效的。要创建一个本地的npm包，浏览到包含公共依赖项的文件夹，并运行以下命令：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This command will create a zipped package with the exact same format that would
    be created for a public `npm` module.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个与为公共`npm`模块创建的格式完全相同的压缩包。
- en: 'Now, in the folder that contains your serverless service, install the package
    locally using the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在包含您的无服务器服务的文件夹中，使用以下命令本地安装包：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You need to repeat this process every time that the common dependency is modified.
    If it is constantly updated, you would need to include this stage into your build
    workflow.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每当公共依赖项被修改时，您需要重复此过程。如果它不断更新，您可能需要将此阶段包含到您的构建工作流程中。
- en: Setting the endpoints
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置端点
- en: 'As we already know, we need to create the API Gateway endpoints to expose to
    the world our serverless functions. This is done in the `serverless.yml` file,
    and the following example shows how to create the endpoints for the serverless
    store:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，我们需要创建API网关端点以向世界展示我们的无服务器函数。这是在`serverless.yml`文件中完成的，以下示例显示了如何为无服务器商店创建端点：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Setting an `OPTIONS` endpoint is mandatory in cases where you want to support
    the `POST`, `PUT`, `PATCH`, or `DELETE` verbs in a cross-origin request. The reason
    is a security measure used by browsers, that is, before making an HTTP request
    that can modify the resource, it preflights a request with `OPTIONS` to check
    whether CORS is enabled and whether the HTTP verb is allowed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要支持跨域请求中的`POST`、`PUT`、`PATCH`或`DELETE`动词的情况下，设置`OPTIONS`端点是强制性的。原因是浏览器使用的一种安全措施，即在发出可能修改资源的HTTP请求之前，它先使用`OPTIONS`进行预检请求，以检查CORS是否启用以及HTTP动词是否允许。
- en: RESTful APIs
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API
- en: 'If you are not already familiar with RESTful APIs, you should know at least
    the following common HTTP verbs and how they are used:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还不熟悉RESTful API，您至少应该了解以下常见的HTTP动词及其用法：
- en: '`GET`: This is used to request data to the server'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：用于向服务器请求数据'
- en: '`POST`: This is used to create or modify resources:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：用于创建或修改资源：'
- en: '`POST/resource`: Without an ID, a new element will be created'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST/resource`：如果没有ID，将创建一个新的元素'
- en: '`POST/resource/id`: If you know the ID and pass it in the request, the element
    will be updated, however, it is typically used only to create and not to update
    resources'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST/resource/id`: 如果你知道ID并将其包含在请求中，元素将被更新，然而，它通常仅用于创建资源而不是更新资源'
- en: '`POST/resource/new-id`: If there is no resource for a given ID, this request
    must return an error'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST/resource/new-id`: 如果没有给定ID的资源，此请求必须返回一个错误'
- en: '`PUT`: This is used to create or modify the following resources:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: 这用于创建或修改以下资源：'
- en: '`PUT/resource`: This should return an error because the ID is expected'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT/resource`: 这应该返回一个错误，因为预期会有ID'
- en: '`PUT/resource/id`: This replaces the entire object with the data provided'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT/resource/id`: 这将用提供的数据替换整个对象'
- en: '`PUT/resource/new-id`: If there is no resource for a given ID, it will be created'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT/resource/new-id`: 如果没有给定 ID 的资源，它将被创建'
- en: '`PATCH`: This is used to do partial updates, instead of replacing the entire
    resource with the given data, it won''t update or remove properties that do not
    match with the input'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`: 这用于执行部分更新，而不是用给定的数据替换整个资源，它不会更新或删除与输入不匹配的属性'
- en: '`DELETE`: This is used to delete resources and an ID must be provided'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 这用于删除资源，必须提供一个ID'
- en: '`OPTIONS`: This returns the allowed HTTP verbs and informs if CORS is enabled'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`: 这返回允许的HTTP动词并告知是否启用了CORS'
- en: Routing the HTTP verbs
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由HTTP动词
- en: As already exemplified, for our routing strategy, we can use a `switch…case`
    statement using `httpMethod` and `resource` to identify the path. I suggest adding
    a `try…catch` statement to warn the client about unexpected errors instead of
    letting Lambda swallow the messages.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，对于我们的路由策略，我们可以使用 `httpMethod` 和 `resource` 的 `switch…case` 语句来识别路径。我建议添加
    `try…catch` 语句来警告客户端关于意外错误，而不是让Lambda吞噬这些消息。
- en: 'The following example shows how to implement the routes for the `products`
    function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何实现`products`函数的路由：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember that you need to run `serverless deploy` to create the Lambda function
    and endpoints, but after that, the command `serverless deploy function --function
    products` can be used for a faster deployment.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你需要运行 `serverless deploy` 来创建Lambda函数和端点，但之后可以使用 `serverless deploy function
    --function products` 命令进行更快的部署。
- en: The next section will explain how the `utils` module was created to handle the
    responses.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释如何创建 `utils` 模块来处理响应。
- en: Handling HTTP responses
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理HTTP响应
- en: 'Usually, we need to handle at least four response types:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要处理至少四种响应类型：
- en: '**Success**: Return HTTP `200 OK` when the request is processed successfully.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**成功**: 当请求成功处理时，返回 HTTP `200 OK`。'
- en: '**Error**: Return HTTP `500 Internal Server Error` when an error happens in
    the backend.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**错误**: 当后端发生错误时，返回 HTTP `500 内部服务器错误`。'
- en: '**Not found**: Return HTTP `404 Not Found` when the client requests a resource
    that doesn''t exist.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未找到**: 当客户端请求不存在的资源时，返回 HTTP `404 未找到`。'
- en: '**Options**: Return HTTP `200 OK` along with the allowed methods for this resource.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选项**: 返回 HTTP `200 OK` 并附带此资源的允许方法。'
- en: There are many other HTTP status codes, like `400 Bad Request` when the client
    sends a request without the necessary parameters, but covering an extensive list
    of status codes is out of the scope of this book and most of them are not used
    in the majority of applications.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的 HTTP 状态码，例如当客户端发送没有必要参数的请求时，返回 `400 错误请求`，但涵盖广泛的状态码超出了本书的范围，并且大多数状态码在大多数应用程序中都没有使用。
- en: 'The following code snippet shows how to implement those handlers:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何实现这些处理程序：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Regarding the `OPTIONS` verb, we need to answer the requests with the status
    code `200 OK` and set the allowed methods and headers:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `OPTIONS` 动词，我们需要用状态码 `200 OK` 回应请求并设置允许的方法和头信息：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implementing the Lambda functions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Lambda函数
- en: In this section, we are going to see how to implement the backend features.
    After implementing and deploying the Lambda functions, we can modify the frontend
    code to make Ajax requests to the backend.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何实现后端功能。在实现和部署Lambda函数之后，我们可以修改前端代码以向后端发送Ajax请求。
- en: Retrieving all products
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索所有产品
- en: 'This feature has the following three responsibilities:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能具有以下三个职责：
- en: Retrieve all products from the products table
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从产品表中检索所有产品
- en: Retrieve all user comments/ratings and join them with the product list
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索所有用户评论/评分并将它们与产品列表连接
- en: Retrieve the user Shopping Cart and merge with the product list to identify
    what products were already selected
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户购物车并将其与产品列表合并，以确定已选择哪些产品
- en: Those queries will be created and executed by `repository` and its implementation
    will be defined in the next [Chapter 7](cb2f92df-5bc3-4c8e-8872-fbee58e5b0be.xhtml),
    *Managing a Serverless Database*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询将由`repository`创建和执行，其实现将在下一章[第7章](cb2f92df-5bc3-4c8e-8872-fbee58e5b0be.xhtml)，*管理无服务器数据库*中定义。
- en: 'By now, let''s use the FakeDB to return hardcoded values:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，让我们使用FakeDB来返回硬编码的值：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this case, the FakeDB will just return a list of products:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，FakeDB将只返回产品列表：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Saving the Shopping Cart
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存购物车
- en: This request receives as the input a list of selected products and the `UserID`.
    In our sample application, the `UserID` will uniquely identify the shopping cart,
    which means that each user has just one cart.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求接收一个选定产品的列表和`UserID`作为输入。在我们的示例应用程序中，`UserID`将唯一标识购物车，这意味着每个用户只有一个购物车。
- en: If the user is logged in, the frontend knows the `UserID`. However, we can't
    receive an `ID` directly from the client and take actions trusting that this information
    is valid. We know that a malicious user can modify the JavaScript code to send
    an `ID` of another user.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已登录，前端知道`UserID`。然而，我们不能直接从客户端接收`ID`并信任该信息是有效的。我们知道一个恶意用户可以修改JavaScript代码以发送另一个用户的`ID`。
- en: For a reliable operation, we must analyze the authentication tokens that are
    passed through the headers of all requests from logged users and check if the
    `ID` is correct. This step will be implemented in [Chapter 8](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml),
    *Securing the Serverless Application*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可靠地运行，我们必须分析所有已登录用户请求头中传递的认证令牌，并检查`ID`是否正确。这一步骤将在[第8章](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml)，*保护无服务器应用程序*中实现。
- en: Checking out
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检出
- en: Handling payments is a complex feature that won't be covered in this book. So,
    when the user tries to checkout the Shopping Cart, a message will be displayed
    to show that this is just a demo application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 处理支付是一个复杂的特性，本书不会涉及。因此，当用户尝试结账购物车时，将显示一条消息，表明这只是一个演示应用程序。
- en: However, we can use this feature to learn how serverless notifications work.
    When the user starts a payment process, the backend receives the credit card information
    and makes a request to process the payment. As this step can take a long time,
    instead of using the client to make repetitive requests (polling), we can use
    WebSockets to notify the user when the response is available. Serverless notifications
    will be covered using IoT in [Chapter 9](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml),
    *Handling Serverless Notifications*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用这个特性来学习无服务器通知是如何工作的。当用户开始支付流程时，后端接收信用卡信息并请求处理支付。由于这一步骤可能需要很长时间，我们不必使用客户端进行重复请求（轮询），而是可以使用WebSockets在响应可用时通知用户。无服务器通知将在[第9章](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml)，*处理无服务器通知*中使用物联网进行介绍。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned the serverless architectures such as nanoservices,
    microservices, monolith, and Graph. For our serverless store, the monolith architecture
    was selected and used to build the backend. We also covered how to structure the
    project's code and build RESTful APIs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了无服务器架构，如纳米服务、微服务、单体和图。对于我们的无服务器商店，我们选择了单体架构来构建后端。我们还介绍了如何构建项目的代码和构建RESTful
    API。
- en: In the next chapter, you will learn about the SimpleDB serverless database.
    Due to the fact that SimpleDB may not be good enough for most applications, we
    are also going to learn about DynamoDB, which is not a serverless database, but
    requires minimal management.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解SimpleDB无服务器数据库。由于SimpleDB可能不足以满足大多数应用程序的需求，我们还将学习DynamoDB，它不是一个无服务器数据库，但需要最少的维护。
