- en: Chapter 3. SPA Essentials – Creating the Ideal Application Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. 单页应用（SPA）基础 - 创建理想的应用程序环境
- en: 'You should now be fairly comfortable working within the Node.js ecosystem of
    modules, tasks, and package management. In this chapter, we will dive a bit deeper
    into the intricacies of a JavaScript SPA and its dependencies. We will explore
    various data formats and database types, SPA encapsulation architectural patterns,
    and more through the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经相当熟悉 Node.js 生态系统中的模块、任务和包管理。在本章中，我们将更深入地探讨 JavaScript SPA 及其依赖的复杂性。我们将通过以下主题来探索各种数据格式和数据库类型、SPA
    封装架构模式等：
- en: JSON and other data formats
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 和其他数据格式
- en: The differences between SQL and NoSQL databases
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 和 NoSQL 数据库之间的区别
- en: When to use SQL versus NoSQL databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用 SQL 相比 NoSQL 数据库
- en: Methods of presenting a single page application container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示单页应用程序容器的各种方法
- en: Serving and managing layouts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供和管理布局
- en: The JSON data format
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON 数据格式
- en: '**JavaScript Object Notation** (**JSON**) is something that most JavaScript
    developers today are quite familiar with. Despite its name, JSON is a language-independent
    standard that is really just a text document, and it must first be parsed by JavaScript,
    or any language interpreter, before it can be used as data representing objects
    with name-value pairs, or as simple sequences of values.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 对象表示法**（**JSON**）是当今大多数 JavaScript 开发者都非常熟悉的东西。尽管其名称如此，JSON 实际上是一个与语言无关的标准，它实际上只是一个文本文档，在它被用作表示具有名称-值对的对象的
    数据或作为简单值序列之前，必须首先由 JavaScript 或任何语言解释器进行解析。'
- en: The reason the JSON acronym includes the word *JavaScript* is because its formatting
    is based on the structure of JavaScript objects and arrays. This is why working
    with JSON data and JavaScript is so straightforward, and why it makes a lot of
    sense to consume JSON data from within JavaScript applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 的缩写中包含单词 *JavaScript* 的原因是因为其格式基于 JavaScript 对象和数组的结构。这就是为什么处理 JSON 数据和
    JavaScript 是如此直接，以及为什么在 JavaScript 应用程序中消费 JSON 数据非常有意义。
- en: 'The contents of the `user.json` file we created in *[Chapter 2](ch02.html "Chapter 2. Model-View-Whatever")*
    , *Model-View-Whatever* is an example of the JSON data interchange format:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *[第 2 章](ch02.html "第 2 章. 模型-视图-任何")* 中创建的 `user.json` 文件的内容，*模型-视图-任何*
    是 JSON 数据交换格式的一个示例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'JSON follows the format of standard JavaScript objects, but must also adhere
    to a few important rules to be valid:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 遵循标准 JavaScript 对象的格式，但还必须遵守一些重要规则才能有效：
- en: Property names must be formatted as strings in double quotes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性名必须用双引号格式化
- en: A value can be a string in double quotes, a number, `true` or `false`, an object,
    or an array
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值可以是双引号中的字符串、数字、`true` 或 `false`、对象或数组
- en: Objects and arrays can be nested
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象和数组可以嵌套
- en: Double quotes contained within a string must be escaped using backslashes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串中的双引号必须使用反斜杠转义
- en: These rules allow the JSON format to be parsed directly to native JavaScript
    while still being strict enough to make it an easily interchangeable format across
    languages. Although native JavaScript object notation does not enforce the use
    of double quotes around property names, it is required for JSON in order to prevent
    JavaScript reserved word exceptions from occurring.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则允许 JSON 格式直接解析为原生 JavaScript，同时仍然足够严格，使其成为跨语言之间易于交换的格式。尽管原生 JavaScript 对象表示法不强制要求在属性名周围使用双引号，但对于
    JSON 来说这是必需的，以防止发生 JavaScript 保留字异常。
- en: 'Reserved words in JavaScript are not allowed to be used as variable or function
    names because they represent some current or potential future construct of the
    language. For example, the reserved word `class` is often misused by inexperienced
    developers as a variable name for holding a CSS class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的保留字不允许用作变量或函数名，因为它们代表语言的一些当前或潜在的未来结构。例如，保留字 `class` 经常被缺乏经验的开发者误用作
    CSS 类的变量名：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This example would throw an exception because `class` is a reserved word. Additionally,
    using it as a straight property name in a JavaScript object would throw an exception:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子会抛出异常，因为 `class` 是一个保留字。此外，将其用作 JavaScript 对象中的直接属性名也会抛出异常：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An experienced JavaScript developer would know not to use this word as a property
    name due to it being a reserved word, but if your application is consuming JSON
    data from an external source, you have no control over the property names that
    may be pulled in with an object. For example, you may retrieve data from an application
    running on another server that is not JavaScript and has no awareness of the reserved
    word restrictions of any other application that may consume it. If this application
    wants to convey CSS class information, it is likely that it may use the word `"class"`
    to do so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的 JavaScript 开发者会知道不要将这个单词用作属性名，因为它是一个保留字，但如果你的应用程序正在从外部源消费 JSON 数据，你无法控制可能随对象一起拉入的属性名。例如，你可能从运行在另一个服务器上的应用程序中检索数据，该服务器不是
    JavaScript，并且没有意识到任何可能消费它的应用程序的保留字限制。如果这个应用程序想要传达 CSS 类信息，它很可能使用单词 `"class"` 来实现：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the property name is valid because it is in double quotes and
    thereby parsed as a string instead of as a reserved word. For this reason, the
    rule requiring double quotes around property names is strictly enforced, and no
    JSON parser will allow property names without them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，属性名是有效的，因为它被双引号包围，因此被解析为字符串而不是保留字。因此，要求属性名周围使用双引号的规则被严格执行，没有任何 JSON 解析器会允许没有双引号的属性名。
- en: Other data formats
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他数据格式
- en: JSON was first conceived of in 2001 by Douglas Crockford. Before then, data
    interchange had long been a practice using established formats that were already
    integrated with many programming languages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 首次由 Douglas Crockford 在 2001 年构想出来。在此之前，数据交换一直是通过使用已经与许多编程语言集成的既定格式来实践的。
- en: XML
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML
- en: 'Long before JSON was commonly known, **Extensible Markup Language** (**XML**)
    was one of the most widely used web application data interchange formats. XML
    was first introduced in 1996 and would become an international standard. It is
    a form of **Standard Generalized Markup Language** (**SGML**) and was created
    by the **World Wide Web Consortium** (**W3C**):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 众所周知之前，**可扩展标记语言**（**XML**）是使用最广泛的网络应用程序数据交换格式之一。XML 首次在 1996 年推出，并成为国际标准。它是一种
    **标准通用标记语言**（**SGML**）的形式，由 **万维网联盟**（**W3C**）创建：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a simple example of a XML document. If you haven't worked with XML before,
    you most likely have at least heard of it. XML was a precursor to many other data
    formats, including SOAP, RSS, Atom, and XHTML. XHTML is also well known to many
    web developers, and it was the recommended standard for serving web pages before
    the HTML5 specification was introduced. Notice that the formatting of the preceding
    example is similar to HTML.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 XML 文档示例。如果你之前没有使用过 XML，你很可能至少听说过它。XML 是许多其他数据格式的先驱，包括 SOAP、RSS、Atom
    和 XHTML。XHTML 也为许多网络开发者所熟知，在 HTML5 规范引入之前，它是提供网页的推荐标准。注意，前面示例的格式与 HTML 类似。
- en: YAML
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: YAML
- en: 'YAML is a recursive acronym, meaning it refers to itself, for *YAML Ain''t
    Markup Language*. What makes YAML interesting, aside from its silly name, is that
    its syntax for hierarchy requires the use of lines and indentation as delimiters,
    rather than structured enclosures such as curly braces and brackets, which are
    used in JSON:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 是一个递归缩写词，意味着它指的是自己，即 *YAML Ain't Markup Language*。除了它的愚蠢名字之外，使 YAML 有趣的是，它的层次结构语法要求使用行和缩进来作为分隔符，而不是
    JSON 中使用的结构化括号和方括号：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The syntax for YAML was designed to make the hierarchy structure of data more
    easily human-readable by requiring the lines and spaces for explicit delineation
    of its structure. In contrast, other data formats that use characters such as
    brackets for defining structure can find it difficult to convey hierarchy to the
    human eye, especially when in compressed format.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 的语法设计是为了使数据的层次结构更容易被人类阅读，它要求使用行和空格来明确界定其结构。相比之下，其他使用括号等字符定义结构的格式，在压缩格式下可能难以向人类眼睛传达层次结构。
- en: YAML was first created around the same time as JSON, but it has not received
    nearly the amount of notoriety that JSON has in the web development community.
    YAML is arguably more flexible than JSON in that it allows for more features,
    such as comments and relational anchors, but it is likely the simplicity of JSON
    that makes it a more popular data format for consumption within web applications
    and beyond.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: YAML最初是在与JSON大致相同的时间创建的，但它并没有像JSON在Web开发社区中那样获得那么多的知名度。YAML在灵活性方面可能比JSON更胜一筹，因为它允许更多的功能，如注释和关系锚点，但可能是JSON的简单性使其成为Web应用程序以及更广泛的数据消费中的更受欢迎的数据格式。
- en: BSON
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BSON
- en: '**Binary JSON** (**BSON**) is a binary form of JSON that is used primarily
    as the data storage format for the MongoDB document-oriented database system.
    BSON is just like JSON, with the main difference being that BSON supports more
    complex data types such as Date, Timestamp, and `ObjectId`. An `ObjectId` in BSON
    and MongoDB is a 12-byte unique identifier for a stored object. MongoDB requires
    that every object has a unique identifier field named `_id` and an `ObjectId`
    is the default mechanism for assigning this field a value. This concept is much
    like a *primary key* in a relational database system.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制JSON** (**BSON**) 是JSON的二进制形式，主要用于MongoDB面向文档的数据库系统的数据存储格式。BSON与JSON类似，主要区别在于BSON支持更复杂的数据类型，如日期、时间戳和`ObjectId`。在BSON和MongoDB中，`ObjectId`是一个12字节的唯一标识符，用于存储的对象。MongoDB要求每个对象都有一个名为`_id`的唯一标识符字段，而`ObjectId`是为此字段赋值的默认机制。这个概念与关系型数据库系统中的*主键*类似。'
- en: 'A BSON document that uses the `ObjectId` and `Timestamp` data types might look
    something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用`ObjectId`和`Timestamp`数据类型的BSON文档可能看起来像这样：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we discuss MongoDB and document-oriented databases in this text, the term
    JSON may be used interchangeably for BSON with the implication that this distinction
    is understood. You can learn more about the BSON specification at bsonspec.org.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本文中讨论MongoDB和面向文档的数据库时，术语JSON可能与BSON互换使用，其含义是理解这种区别。您可以在bsonspec.org上了解更多关于BSON规范的信息。
- en: Why does JSON reign supreme?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么JSON如此盛行？
- en: JSON is simple, easy to read, and structured in a way that is easily understood
    by just about any programming language in existence. Lists (or arrays) and name-value
    pairs (or associative arrays) are a fundamental concept and common implementation
    in computer languages. The simpler a format is, the easier it is to parse, and
    thus more platforms will develop a way to inherently consume that data format.
    Such has been the case with JSON.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JSON简单、易于阅读，并以一种几乎所有现有的编程语言都能轻松理解的方式结构化。列表（或数组）和名称-值对（或关联数组）是计算机语言中的基本概念和常见实现。格式越简单，解析起来就越容易，因此更多平台将开发出一种固有的方式来消费该数据格式。JSON的情况就是这样。
- en: Additionally, the JSON specification was only changed a few times after it was
    first developed. Its creator, Douglas Crockford, intentionally gave no version
    number to the specification so that it would be set in stone and could not change
    over time. This may likely be the biggest factor in JSON's dominance over other
    data formats. Since it does not change over time, the parsers built to consume
    it across myriad programming languages and platforms don't have to change either.
    This has created an ecosystem in which JSON exists with only one version in every
    place, making it entirely predictable, widely understandable, and virtually unbreakable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JSON规范在最初开发后只更改了几次。其创造者Douglas Crockford故意没有为规范指定版本号，以便使其成为固定不变的，并且随着时间的推移不能改变。这可能是JSON在数据格式中占据主导地位的最大因素。由于它不会随时间改变，因此为消费它而构建的跨众多编程语言和平台的解析器也不需要改变。这创造了一个生态系统，其中JSON在每个地方都只有一个版本，使其完全可预测、广泛理解且几乎坚不可摧。
- en: The differences between SQL and NoSQL databases
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL和NoSQL数据库之间的差异
- en: In [*Chapter 2*](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*,
    we briefly discussed document-oriented databases, otherwise known as NoSQL databases.
    This concept is imperative to the MEAN stack, as the *M* in the MEAN acronym stands
    for MongoDB, a widely used NoSQL database implementation. NoSQL databases are
    conceptually divergent from traditional relational, or SQL, databases.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](ch02.html "第二章。模型-视图-无论")中，我们简要讨论了面向文档的数据库，也称为NoSQL数据库。这个概念对于MEAN栈至关重要，因为MEAN缩写中的*M*代表MongoDB，这是一个广泛使用的NoSQL数据库实现。NoSQL数据库在概念上与传统的关系型，或SQL，数据库有所不同。
- en: Non-relational databases have existed for decades, but they did not achieve
    any widespread use until more recently. This rise in popularity led to the term
    *NoSQL* first being applied to these types of databases. The reason for the increase
    in the use of NoSQL databases has primarily been to solve the problem of handling
    *Big Data*, or massive and complex datasets, and *scaling* that data horizontally
    in modern web applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库已经存在了几十年，但直到最近才得到广泛应用。这种流行度的上升导致了术语*NoSQL*首先被应用于这些类型的数据库。NoSQL数据库使用量增加的主要原因主要是为了解决处理*大数据*的问题，即大规模和复杂的数据集，以及在现代Web应用程序中水平扩展这些数据。
- en: NoSQL data typing
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL数据类型
- en: 'The term NoSQL means *non-SQL* which implies that it is a non-relational database
    type. NoSQL databases that are document-oriented, like MongoDB, store their data
    in documents represented by structured JSON objects. The data *types* in a NoSQL
    database like this are defined by the data itself, as is the case with standard
    JSON:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 术语NoSQL意味着*非SQL*，这暗示它是一种非关系型数据库类型。像MongoDB这样的面向文档的NoSQL数据库将它们的数据存储在由结构化JSON对象表示的文档中。这种类型的NoSQL数据库中的数据*类型*由数据本身定义，就像标准JSON一样：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For example, if you have a field in a NoSQL database with the key `id` and
    the value is `1`, a number, you could easily change the value to `myID`, a string,
    without needing to change any other reference to that data type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在NoSQL数据库中有一个键为`id`的字段，其值为`1`，一个数字，你可以轻松地将该值更改为`myID`，一个字符串，而无需更改对该数据类型的任何其他引用：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this way, the data *type* for that value is entirely dependent upon what
    it is defined as. In a relational database, making this change would not be so
    straightforward.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，该值的*数据类型*完全取决于其定义。在关系型数据库中，进行这种更改不会那么直接。
- en: Relational data typing
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据类型
- en: In contrast to document-oriented databases, traditional SQL databases use tables
    to structure their data. Each table column is set to a specific data type and
    the data stored under that column must adhere to the defined type. If you have
    a large SQL database and wish to change the type for a particular column, it can
    be potentially problematic and could require the change to be executed on thousands
    of rows of data. Changing a data type in a JSON document is relatively easy compared
    to this, as it only involves changing the data itself, and there is no concept
    of a table column defining the data type across multiple records.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向文档的数据库相比，传统的SQL数据库使用表格来结构化其数据。每个表格列都设置为特定的数据类型，存储在该列下的数据必须遵守定义的类型。如果你有一个大型的SQL数据库，并且希望更改特定列的类型，这可能会带来潜在的问题，并且可能需要更改在数千行数据上执行。与更改JSON文档中的数据类型相比，这相对容易，因为它只涉及更改数据本身，并且没有跨多个记录定义数据类型的表格列的概念。
- en: The term *relational* in regard to relational databases refers to the tabular
    relation of the data stored. Each table of data is considered a relation because
    the different data stored within it is related to one another in some manner defined
    by the applications and programs that will be consuming it. A table in a SQL database
    can be compared to a JSON object in a NoSQL database. The biggest difference between
    the two, however, is that a table is composed of rows and columns, and the data
    is further related by column types and rows containing records of related data.
    In a NoSQL database, there is no concept of rows and columns, and data can be
    nested with unlimited scope.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库中的*关系*术语指的是存储数据的表格关系。每个数据表被视为一个关系，因为其中存储的不同数据以某种方式相互关联，这种关联由将消费它的应用程序和程序定义。SQL数据库中的一个表可以与NoSQL数据库中的一个JSON对象相比较。然而，两者之间最大的区别是，表由行和列组成，数据通过列类型和包含相关数据记录的行进一步关联。在NoSQL数据库中，没有行和列的概念，数据可以无限嵌套。
- en: In order to retrieve *nested* data within a SQL database, relations must also
    be identified between tables. Since data cannot actually be nested, references
    from one or more tables to one or more other tables must be used to create related
    sets of data for use in application Models and Views. SQL is a programming language
    used to manage and extract the data from relational database tables and format
    it in such a way that is required for an application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索SQL数据库中的*嵌套*数据，还必须在表之间识别关系。由于数据实际上不能嵌套，因此必须使用一个或多个表到一个或多个其他表的引用来创建用于应用程序模型和视图的相关数据集。SQL是一种编程语言，用于管理从关系型数据库表中提取数据，并以满足应用程序所需的方式对其进行格式化。
- en: ACID transactions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACID事务
- en: The majority of NoSQL database systems do not support *transactions* which conform
    to the properties of **ACID**, which stands for **Atomicity**, **Consistency**,
    **Isolation,** and **Durability**. This set of properties is required for a database
    to handle transactions in a reliable fashion. A transaction is any change made
    to a database. That change can be to a single value for a field in one table,
    or it can be a change that spans multiple tables and affects multiple rows within
    those tables. Most widely used relational databases support the ACID properties
    for transactions, no matter the complexity of the operation that is performed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数NoSQL数据库系统不支持符合**ACID**属性的事务，**ACID**代表**原子性**、**一致性**、**隔离性**和**耐用性**。这一组属性是数据库以可靠方式处理事务所必需的。事务是对数据库的任何更改。这种更改可以是单个表中某个字段的单个值，也可以是跨越多个表并影响这些表中的多行的更改。大多数广泛使用的数据库管理系统都支持事务的ACID属性，无论执行的操作有多复杂。
- en: Atomicity
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原子性
- en: The Atomicity property of ACID refers to atomic operations within a database,
    meaning that the changes required for a transaction must all be ensured to occur,
    otherwise none will occur. This property provides a guarantee that partial changes
    are not made, which could lead to corrupt data sets. If an atomic transaction
    fails at any point within a database, the changes made up to that point are rolled
    back to their previous state.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ACID的原子性属性指的是数据库内的原子操作，意味着事务所需的更改必须确保全部发生，否则不会发生任何更改。这一属性提供了一种保证，即不会进行部分更改，这可能导致数据集损坏。如果一个原子事务在数据库中的任何一点失败，那么到该点为止所做的更改将回滚到其之前的状态。
- en: Consistency
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一致性
- en: The Consistency property of ACID is the requirement that a transaction only
    causes *valid* data changes as defined by that database system. This includes
    ensuring that data is not corrupt, that rollbacks are enforced when necessary,
    and that all the necessary database triggers related to a transaction are executed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ACID的一致性属性要求事务只能根据该数据库系统定义的**有效**数据更改。这包括确保数据不被破坏，在必要时强制执行回滚，以及执行与事务相关的所有必要数据库触发器。
- en: Isolation
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离性
- en: The Isolation property of ACID requires that a simultaneously executed transaction,
    or concurrency, does not result in database errors in related data. This can involve
    different levels of strictness, dependent upon the database system being used.
    The primary goal of Isolation is that the end result of a set of concurrent transactions
    is the same as if you were to go back and replay them one after another. Isolation
    is closely tied to Consistency, and it should always ensure that Consistency is
    maintained.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ACID的隔离性属性要求同时执行的事务或并发不会导致相关数据出现数据库错误。这可以涉及不同级别的严格性，取决于所使用的数据库系统。隔离性的主要目标是确保一组并发事务的最终结果与如果你依次回放它们是相同的。隔离性与一致性紧密相关，并且始终应确保一致性得到维护。
- en: Durability
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 耐用性
- en: The Durability property of ACID requires that a transaction is not *lost* while
    being executed. You can imagine any number of things going wrong with a computer
    that could occur during the execution of a transaction, such as a power outage.
    When something like this occurs, Durability provides that the database system
    *remembers* the transaction that was in the middle of execution by recording it
    to disk and ensuring that it isn't lost, even after a reboot.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ACID的耐用性属性要求在执行过程中事务不会被**丢失**。你可以想象在事务执行过程中可能会发生任何数量的计算机故障，比如断电。当发生类似情况时，耐用性确保数据库系统**记住**正在执行中的事务，通过将其记录到磁盘并确保即使在重启后也不会丢失。
- en: MongoDB and ACID
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MongoDB和ACID
- en: It is true that many NoSQL database systems do not conform to the ACID properties;
    however, MongoDB does to a certain degree. As mentioned, MongoDB is a document-oriented
    database system, which is a more terse subset of NoSQL databases. In this fashion,
    MongoDB has the ability to support ACID transactions at the single-document level.
    It cannot support multi-document transactions, so in this way it falls short of
    most relational databases, which can support ACID transactions across multiple
    tables, but MongoDB still stands out among document-oriented databases at the
    document level.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，许多NoSQL数据库系统并不符合ACID属性；然而，MongoDB在一定程度上做到了。正如之前提到的，MongoDB是一个面向文档的数据库系统，它是NoSQL数据库的一个更简洁的子集。以这种方式，MongoDB能够在单文档级别支持ACID事务。它不能支持多文档事务，因此在这方面它不如大多数关系型数据库，后者可以在多个表中支持ACID事务，但MongoDB在文档级别仍然在面向文档的数据库中脱颖而出。
- en: Write-ahead logging with MongoDB
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MongoDB的写入前日志
- en: Another feature that MongoDB touts above others is **Write-Ahead Logging** (**WAL**).
    This is a set of features allowing a database system to conform to the Atomicity
    and Durability properties of ACID. To do this, MongoDB writes a record of all
    operations and their results to an internal log before actually executing the
    operations. This is a simple and effective way to ensure the Durability of document-level
    transactions because with all operations logged ahead of execution, evidence of
    what occurred is not lost in the event of a sudden interruption to an operation.
    Similarly, this feature ensures Atomicity because it gives MongoDB the ability
    to *undo* and *redo* these operations upon reboot after determining what changes
    were made and comparing them to the state of the database before the interrupted
    operation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB吹嘘的另一个超过其他特性的功能是**写入前日志**（**WAL**）。这是一组功能，允许数据库系统符合ACID的原子性和持久性属性。为此，MongoDB在执行操作之前，将所有操作及其结果记录到一个内部日志中。这是一种简单而有效的方式来确保文档级别事务的持久性，因为所有操作都在执行之前进行了记录，因此即使在操作突然中断的情况下，也不会丢失发生事件的证据。同样，这个特性确保了原子性，因为它使MongoDB能够在确定更改内容并将其与中断操作之前数据库的状态进行比较后，重新启动时能够*撤销*和*重做*这些操作。
- en: When to use SQL versus NoSQL databases
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用SQL数据库与NoSQL数据库
- en: There are clearly major differences between SQL and NoSQL databases, not only
    in how they are structured, but in how developers and applications interact with
    them. These differences can have serious implications for the development of an
    application from both an architectural and a functional perspective. This is why
    choosing your database type is no small matter and should always be thoroughly
    evaluated before moving forward with the development of an application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库和NoSQL数据库之间显然存在重大差异，这不仅体现在它们的结构上，还体现在开发者和应用程序如何与之交互。这些差异从架构和功能的角度来看，都可能对应用程序的开发产生严重影响。这就是为什么选择数据库类型不是一件小事，在开始应用程序的开发之前，应该始终对其进行彻底评估。
- en: Scalability
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: It was mentioned earlier that the needs of modern web applications have led
    to the rise in popularity of NoSQL databases. *Scalability*, or the ability to
    continuously handle growing amounts of data and operations on that data, is one
    of these needs. You can imagine this being the scenario for a social media company
    such as Facebook or Twitter, and any other social applications that may interact
    with social data received from resources like this. In the following, scalability
    is a feature you may need to take under consideration when deciding on the type
    of database you want to use for your application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到，现代Web应用程序的需求导致了NoSQL数据库的流行。*可扩展性*，即持续处理不断增长的数据量和数据操作的能力，是这些需求之一。你可以想象这种情况适用于像Facebook或Twitter这样的社交媒体公司，以及可能与此类资源交互的任何其他社交应用程序。在下面的内容中，可扩展性是在决定为应用程序选择哪种类型的数据库时可能需要考虑的一个特性。
- en: Horizontal scaling
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平扩展
- en: In particular, *horizontal scaling* is a necessity for a growing number of modern-day
    web applications. This refers to the need for distributed servers and databases
    geographically with a growing user base. Effective horizontal scaling allows users
    of an application to receive data from a server that is closest to them, rather
    than a single server or set of servers that may be in a data warehouse halfway
    around the world.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是对于越来越多的现代网络应用来说，**水平扩展**是必需的。这指的是随着用户基础的扩大，需要在地理上分布服务器和数据库。有效的水平扩展使得应用程序的用户能够从离他们最近的服务器接收数据，而不是从可能位于世界另一端的数据仓库中的单个服务器或服务器组。
- en: Horizontal scaling is certainly not impossible with a relational database, but
    it is difficult, and it requires the use of a sophisticated **Database Management
    System** (**DBMS**). NoSQL databases, on the other hand, are simpler in design,
    and this makes data replication across clusters of machines and networks much
    simpler as well.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中实现水平扩展当然不是不可能的，但这很困难，并且需要使用复杂的**数据库管理系统**（**DBMS**）。另一方面，NoSQL数据库在设计上更简单，这使得在机器和网络集群之间进行数据复制变得更加简单。
- en: Big Data
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**大数据**'
- en: 'Another need for modern web applications is **Big Data**, which can mean exactly
    what its name implies: a massive amount of data. More often than not, however,
    Big Data refers to a high degree of complexity among data sets such that it can
    be difficult to analyze and extract value from them without the aid of sophisticated
    techniques for doing so.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络应用还需要另一个需求，即**大数据**，这可以确切地意味着其名称所暗示的：大量数据。然而，更多的时候，大数据指的是数据集之间的高度复杂性，以至于没有使用复杂的分析技术，很难从中分析和提取价值。
- en: NoSQL databases lend themselves perfectly to handling Big Data due to their
    support for *dynamic schema design*, which simply means that you do not have to
    define a specific schema for a data set before you store it, as is required by
    traditional relational databases. This goes back to the flexibility of data typing
    in NoSQL, which doesn't require that the type for a field be governed by a rule,
    as it is for a column in a tabular data schema. Additionally, the schema for a
    relational database table cannot be changed without affecting all of the data
    for that table. In contrast, the schema of a particular data set in a JSON document,
    for instance, can change at any time without affecting previously stored data
    sets in that same document.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库非常适合处理大数据，因为它们支持**动态模式设计**，这简单意味着在存储之前，您不需要为数据集定义特定的模式，正如传统的关系型数据库所要求的。这回到了NoSQL中数据类型的灵活性，它不需要字段类型受规则控制，就像表格数据模式中的列一样。此外，关系型数据库表的模式不能更改，否则会影响到该表的所有数据。相比之下，例如，JSON文档中特定数据集的模式可以随时更改，而不会影响该文档中先前存储的数据集。
- en: If Big Data is a foreseeable need for your web application, then the *type*
    of Big Data is a further consideration you should make before choosing a database
    type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大数据是您网络应用的可预见需求，那么在选择数据库类型之前，您应该进一步考虑大数据的类型。
- en: Operational Big Data
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作大数据**'
- en: '**Operational Big Data** refers to data that is consumed and managed in real
    time to support the operation of currently running processes in distributed applications.
    Document-oriented databases such as MongoDB are built with operational Big Data
    support in mind and focus on *speed* of concurrent read and write operations to
    provide for this.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作大数据**指的是在分布式应用程序中实时消耗和管理的数据，以支持当前运行过程中的操作。例如，MongoDB这样的面向文档的数据库就是考虑到操作大数据的支持而构建的，并专注于提供并发读写操作的速度。'
- en: MongoDB, and other NoSQL systems designed to work with operational Big Data,
    do so by taking advantage of modern distributed network computing power to increase
    the efficiency of operations. Traditional relational databases were not built
    with this ability in mind because computer systems were more isolated when they
    were developed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB以及其他旨在与操作大数据一起工作的NoSQL系统，通过利用现代分布式网络计算能力来提高操作效率。然而，传统的数据库系统在开发时并没有考虑到这种能力，因为那时的计算机系统更加孤立。
- en: Analytical Big Data
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分析大数据**'
- en: '**Analytical Big Data** contrasts greatly with operational Big Data in that
    its focus is on **Massively Parallel Processing** (**MPP**). This means that massive
    amounts of data are consumed and later analyzed for any number of requirements
    that give value to the application using it. In contrast to operational Big Data,
    database systems designed for analytical Big Data focus on massive *throughput*
    and retrospective processing of that data, rather than speed of concurrent, unrelated
    operations.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析型大数据**与操作型大数据有很大不同，因为它的重点是**大规模并行处理**（MPP）。这意味着消耗了大量的数据，随后为了给使用该应用的应用提供价值，对这些数据进行各种分析。与操作型大数据相比，为分析型大数据设计的数据库系统专注于巨大的*吞吐量*和数据的回顾性处理，而不是并发、无关操作的速度。'
- en: The need to handle analytical Big Data is not always apparent at the outset
    when developing an application. Anticipation of this requirement is often difficult
    because when you start out with a small data set, you may not know what massive
    amounts of data you might want to analyze as your database matures over time.
    Fortunately, this problem can be handled by the implementation of a solution subsequent
    to identifying its need. MPP databases are built for this specific purpose, in
    addition to *MapReduce*, which is an alternative implementation to handle MPP
    across distributed computers in a cluster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用时，处理分析型大数据的需求并不总是从一开始就明显。预测这种需求往往很困难，因为当你从一个小的数据集开始时，你可能不知道随着时间的推移，你可能会想要分析哪些大量的数据。幸运的是，这个问题可以通过在确定其需求后实施解决方案来解决。MPP数据库就是为了这个特定目的而构建的，此外还有*MapReduce*，它是一种替代实现，用于在集群中的分布式计算机上处理MPP。
- en: Overall considerations
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总体考虑因素
- en: When deciding whether to use a SQL or NoSQL database for your application, you
    should consider the needs of your application both at the initial release and
    what you foresee further down the line. If you expect a large user base and the
    potential for viral growth, then you will want to consider a NoSQL database built
    for handling operational Big Data and scalability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定为你的应用使用SQL或NoSQL数据库时，你应该考虑应用在初始发布时的需求以及你预见的未来需求。如果你预期会有一个庞大的用户基础和病毒式增长的可能性，那么你可能需要考虑一个专为处理操作型大数据和可扩展性而构建的NoSQL数据库。
- en: If you are developing an application that you anticipate having a smaller user
    base, or perhaps no users other than administrators of the data, then a relational
    SQL database may be more appropriate. Additionally, if your application may have
    many users, but has no need for horizontal scalability, a SQL database is likely
    suitable as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个预期用户基础较小的应用，或者可能除了数据管理员外没有其他用户，那么关系型SQL数据库可能更合适。此外，如果你的应用可能有众多用户，但没有横向扩展的需求，SQL数据库也可能是一个合适的选择。
- en: Also consider that many modern, distributed web applications started out using
    only relational databases, and they later implemented NoSQL solutions in congruence
    with the existing databases to handle growing needs. This is also a use case that
    can be planned for and adapted to as needed during the life cycle of an application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑到许多现代、分布式Web应用最初只使用了关系型数据库，后来在现有数据库的基础上实现了NoSQL解决方案，以处理不断增长的需求。这也是一个可以在应用生命周期中根据需要规划和适应的场景。
- en: Methods of presenting an SPA container
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示SPA容器的方案
- en: In a Single Page Application, the *container* is the object in which the application
    is initially loaded and displayed to the user. This concept is different from
    that of a *software container*, which is an isolated environment that an application
    lives in, much like a virtual machine.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页应用中，*容器*是应用最初加载并显示给用户的对象。这个概念与*软件容器*不同，后者是一个应用生活的隔离环境，就像虚拟机一样。
- en: 'For a single page web application, the container could be the `<body>` element,
    or any element within the `<body>` element. For instance, you may have some static
    welcome text initially loaded on the page in a `<p>` element, and the SPA will
    then load dynamically below that element in a `<div>` element:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单页Web应用，容器可以是`<body>`元素，或者`<body>`元素内的任何元素。例如，你可能在页面上用`<p>`元素加载一些初始的静态欢迎文本，然后单页应用（SPA）将在该元素下方动态加载到`<div>`元素中：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In a scenario like this, you will always have some fixed content on the page
    that doesn''t need to change based on the user''s interaction with the application.
    This is just a simple example, but the same could be done for a common `<header>`,
    `<footer>`, and `<nav>` element:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的场景中，页面上总会有一些固定内容，这些内容不需要根据用户与应用程序的交互而改变。这是一个简单的例子，但同样的方法也可以用于常见的 `<header>`、`<footer>`
    和 `<nav>` 元素：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to define your SPA container
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何定义您的SPA容器
- en: There is no *right* way to define your SPA container; it really just depends
    on the type of application you are building and what your preference is. It can
    also depend on the server-side limitations of the system you are using to serve
    your *layout* - the HTML page used to house your app.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 定义您的SPA容器的*正确*方式并不存在；这实际上完全取决于您正在构建的应用程序类型以及您的偏好。它也可能取决于您用于提供布局的系统（即用于容纳您的应用程序的HTML页面）的客户端限制。
- en: Partial page container
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分页容器
- en: As shown in previous sections, you may want to show some static content in your
    SPA layout before the application loads. This is useful when you anticipate a
    long initial load time for an app, or if you require some user interaction to
    trigger the loading of your app.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所示，您可能希望在应用程序加载之前在您的SPA布局中显示一些静态内容。当您预计应用程序的初始加载时间较长，或者需要某些用户交互来触发应用程序的加载时，这很有用。
- en: Full page container
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全页容器
- en: If your application can be completely controlled through API endpoints accessed
    by **XMLHttpRequest**, commonly known as **Asynchronous JavaScript and XML** (**AJAX**),
    then there is no need to load any static content in your SPA layout unless you
    want to. One reason you may load static content in your layout is to have something
    for the user to view or read while they are waiting for the application to load.
    This can be particularly useful when you anticipate long initial load times for
    your app and you want to help deter a user from leaving before the application's
    initial *state* is ready.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序可以通过**XMLHttpRequest**（通常称为**Asynchronous JavaScript and XML**（AJAX））完全控制，那么除非您想要，否则不需要在您的SPA布局中加载任何静态内容。您可能在布局中加载静态内容的一个原因是为用户提供在等待应用程序加载期间查看或阅读的内容。当您预计应用程序的初始加载时间较长，并且希望帮助防止用户在应用程序的初始*状态*准备好之前离开时，这尤其有用。
- en: A *state* in a SPA refers to a particular version of the **Document Object Model**
    (**DOM**), at any point in time. A *loading state* is one you might show within
    your container element while waiting for it to load the next requested state.
    A loading indicator of some sort is often enough to let the user know that something
    is happening and the application will load soon, but when you have any excessive
    latency in your app, a user may think something has gone wrong and leave the app
    layout page before the process completes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在SPA中的*状态*指的是在任何时间点上的特定版本的**Document Object Model**（DOM）。一个*加载状态*是在等待容器元素加载下一个请求的状态时您可能会在其中显示的状态。某种类型的加载指示器通常足以让用户知道正在发生某些事情，并且应用程序很快就会加载，但当您的应用程序有任何过度的延迟时，用户可能会认为出了问题，并在过程完成之前离开应用程序布局页面。
- en: How to load your SPA container
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何加载您的SPA容器
- en: The way you initially load your SPA is highly dependent upon the nature of your
    application. There could be any number of requirements that must be fulfilled
    before your app can be loaded.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您最初加载SPA的方式高度依赖于您应用程序的性质。在您的应用程序加载之前，可能需要满足任何数量的要求。
- en: Loading on user interaction
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户交互时的加载
- en: 'Many web applications require some type of user interaction before the full
    SPA is loaded. For example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web应用程序在完全加载SPA之前需要某种类型用户交互。例如：
- en: User authentication
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户身份验证
- en: User acceptance of an agreement to enter
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户接受进入协议
- en: Interstitial content that must be shown and either engaged or dismissed by the
    user, such as an advertisement
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须显示并由用户参与或忽略的间隔内容，例如广告
- en: Scenarios like these are quite common in web applications, and they can often
    be challenging to solve in a fluid manner.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的场景在Web应用程序中相当常见，并且通常很难以流畅的方式解决。
- en: Login page transition
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 登录页面过渡
- en: In many web applications, the login screen is loaded on a secure page and submitted
    using HTTP POST to another secure page to authenticate the user and load the actual
    SPA. This pattern is generally used due to limitations in the server-side framework
    that is being used to handle authentication.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多Web应用程序中，登录界面在安全页面上加载，并使用HTTP POST提交到另一个安全页面以验证用户并加载实际的SPA。这种模式通常由于正在使用的服务器端框架在处理身份验证方面的限制而被采用。
- en: If you think about a financial application for accessing your bank account that
    you log in to on your phone, you will likely not see much more than a login screen
    until you have authenticated with your username and password. This will typically
    bring you to a second page that loads the full single page application with your
    sensitive banking information that you would not otherwise want available to someone
    else who picks up your phone.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您考虑一个用于访问您在手机上登录的银行账户的金融应用程序，您在通过用户名和密码进行身份验证之前，可能看不到比登录界面更多的内容。这通常会将您带到第二个页面，该页面加载了包含您敏感银行信息的完整单页应用程序，而这些信息您不希望其他人拿起您的手机时也能看到。
- en: A login screen is arguably the most common use case requiring user interaction
    to load an application, and it is one that is often handled with little elegance.
    The most fluid way to handle this use case, if your REST framework allows for
    it, is to load a login screen as part of your SPA and request authentication via
    a REST endpoint from your login form. When you receive a properly authenticated
    response from your API request, you can then load the data you need into the existing
    SPA container and replace the login state with a new *logged in* state.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 登录界面可以说是最常见的一种需要用户交互来加载应用程序的使用场景，而且通常处理得并不优雅。如果您的REST框架允许这样做，处理这种用例最流畅的方式是将登录界面作为SPA的一部分加载，并通过登录表单从REST端点请求身份验证。当您从API请求中收到正确验证的响应时，您可以将所需的数据加载到现有的SPA容器中，并用新的*已登录*状态替换登录状态。
- en: Loading based on the DOMContentLoaded event
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于DOMContentLoaded事件加载
- en: If your SPA does not require user authentication or any other interaction for
    initial loading, or if you detect a user that is already authenticated at the
    time the page is loaded and you can skip that step, then you will want a way to
    automatically load your SPA upon initial page load, and as soon as possible.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的SPA不需要用户身份验证或任何其他交互来初始加载，或者如果您在页面加载时检测到已经验证的用户，并且可以跳过该步骤，那么您将需要一个方法来自动在初始页面加载时尽快加载您的SPA。
- en: 'The best time to load a single page application is generally as soon as the
    DOM is completely loaded and can be parsed by the browser. Modern browsers fire
    an event on the `document` object when this happens, called `DOMContentLoaded`,
    and that can be used for this purpose. To do this, you would simply add an `EventListener`
    on the `document` to detect when the event is fired, and then call a function
    to load your app:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 加载单页应用程序的最佳时机通常是DOM完全加载并且可以被浏览器解析的时候。现代浏览器在发生这种情况时会在`document`对象上触发一个事件，称为`DOMContentLoaded`，这可以用于此目的。为此，您只需在`document`上添加一个`EventListener`来检测事件何时被触发，然后调用一个函数来加载您的应用程序：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, if you are using jQuery, you can call the handy jQuery `.ready()`
    method to listen for the `DOMContentLoaded` event and trigger your custom application
    code within an anonymous function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您正在使用jQuery，您可以调用方便的jQuery `.ready()` 方法来监听 `DOMContentLoaded` 事件，并在匿名函数中触发您的自定义应用程序代码：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Loading based on the document readystatechange event
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于文档readystatechange事件加载
- en: 'Modern browsers also provide an event that is fired on the `document` object
    when you first load a page called `readystatechange`. This event can be used to
    determine three states of the DOM, which are returned as the following via the
    `document.readyState` property:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器还提供了一个在首次加载页面时在`document`对象上触发的事件，称为`readystatechange`。此事件可以用来确定DOM的三个状态，这些状态通过以下方式通过`document.readyState`属性返回：
- en: '`loading` - This is when the document is still loading and has not been entirely
    parsed by the browser.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading` - 这是指文档仍在加载且尚未被浏览器完全解析的情况。'
- en: '`interactive` - This is when all DOM elements have finished loading and can
    be accessed, but certain external resources may have not fully loaded, such as
    images and stylesheets. This state change also indicates that the `DOMContentLoaded`
    event has been fired.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interactive` - 这是指所有DOM元素都已加载并可以访问，但某些外部资源可能尚未完全加载，例如图像和样式表。这种状态变化还表明`DOMContentLoaded`事件已被触发。'
- en: '`complete` - This is when all DOM elements and external resources have fully
    loaded.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complete` - 这是在所有DOM元素和外部资源都已完全加载时。'
- en: 'To use the `readystatechange` event to load your application at the same time
    as the `DOMContentLoaded` event, you would assign a function to be called on the
    `readystatechange` event and then check whether the `document.readyState` property
    is set to `interactive`. If it is, then you can call your application code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`readystatechange`事件在`DOMContentLoaded`事件的同时加载您的应用程序，您需要将一个函数分配给在`readystatechange`事件上被调用的函数，然后检查`document.readyState`属性是否设置为`interactive`。如果是，那么您可以调用您的应用程序代码：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using this method to detect the state of the document provides more flexibility
    in the event that you want to call custom application code for any of the three
    document states, and not just on the `DOMContentLoaded` event, or `interactive`
    state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法来检测文档的状态提供了更多的灵活性，在您想要为三个文档状态中的任何一个调用自定义应用程序代码时，而不仅仅是`DOMContentLoaded`事件或`interactive`状态时。
- en: Loading directly from the document.body
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接从`document.body`加载
- en: 'The more traditional way of loading `<script>` tags is by placing them within
    the document `<head>` element. Adding the `<script>` tags to the `<head>` is fine
    for loading an SPA if you are using the document `DOMContentLoaded` or `readystatechange`
    events within your external JavaScript to initialize your application code at
    the appropriate time:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 加载`<script>`标签的更传统方式是将它们放置在文档的`<head>`元素中。如果您在您的外部JavaScript中使用`DOMContentLoaded`或`readystatechange`事件来在适当的时间初始化应用程序代码，那么将`<script>`标签添加到`<head>`中对于加载SPA来说是完全可以接受的：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you want to avoid using these custom DOM events and trigger your application
    code precisely when you need it, however, a different and more direct approach
    can be taken.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想避免使用这些自定义DOM事件，并在需要时精确触发您的应用程序代码，则可以采取不同的更直接的方法。
- en: 'A common technique for loading JavaScript into a web page today is by placing
    the `<script>` tag, which loads your external JavaScript file, directly within
    the `<body>` element of the page. The ability to do this lies in the way the DOM
    is parsed by a browser: from the top to the bottom.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的网页中加载JavaScript的常见技术是将加载您的外部JavaScript文件的`<script>`标签直接放置在页面的`<body>`元素中。能够这样做的原因在于浏览器解析DOM的方式：从上到下。
- en: 'Take this code, for example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以此代码为例：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Loading the external JavaScript `app.js` file from within the `document.body`
    and just above the closing `</body>` tag will ensure that all DOM elements above
    the `<script>` tag are parsed before it is loaded, and the `app.js` file is loaded
    precisely after the `<div class="container">` element. If that element is where
    you will load your SPA, then this technique ensures that your application code
    within `app.js` will be executed immediately following the `container` element
    being parsed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从`document.body`内部和紧接在关闭的`</body>`标签上方加载外部JavaScript文件`app.js`将确保在加载之前解析所有位于`<script>`标签之上的DOM元素，并且`app.js`文件将在`<div
    class="container">`元素之后精确加载。如果该元素是您将加载SPA的地方，那么这种技术确保了`app.js`中的应用程序代码将在解析`container`元素之后立即执行。
- en: Another advantage to loading your `<script>` tags near the bottom of the DOM
    and below the elements that are required for loading your application is that
    the loading of those `<script>` tags will not block the loading of any content
    above them, due to the browser's top-down parsing of the DOM. Once the `<script>`
    tag is reached, there may be some blocking preventing the browser from being usable
    while it is being loaded, but the user will at least see everything on the page
    that has been loaded up until that point.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是在DOM底部和加载应用程序所需的元素附近加载您的`<script>`标签是，由于浏览器的自上而下的DOM解析，这些`<script>`标签的加载不会阻塞它们上方内容的加载。一旦到达`<script>`标签，可能会有一些阻塞阻止浏览器在加载时可用，但用户至少会看到直到那个点已经加载的页面上的一切。
- en: For this reason, loading a `<script>` tag within the `<body>` and near the bottom
    of the DOM is preferable to loading it with the traditional `<head>` tag insertion
    so that no blocking occurs before anything is visible on the page.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`<body>`中靠近DOM底部的位置加载`<script>`标签，而不是使用传统的`<head>`标签插入，这样可以避免在页面上任何内容可见之前发生阻塞。
- en: Using the script tag async attribute
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`<script>`标签的`async`属性
- en: 'One method for preventing a `<script>` tag from blocking the browser usability
    while it is loaded is the `async` attribute. This attribute can be added to ensure
    that your `app.js` file is loaded asynchronously once parsed, and so that the
    rest of the DOM continues to be parsed and loaded, regardless of when the loading
    of that script completes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 防止`<script>`标签在加载时阻塞浏览器可用性的一个方法是使用`async`属性。可以将此属性添加到`app.js`文件中，以确保一旦解析，该文件就会异步加载，并且DOM的其余部分将继续解析和加载，无论该脚本的加载何时完成：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The advantage to this is, again, there is no blocking. The disadvantage to it,
    however, is that when you are loading multiple scripts asynchronously, there is
    no guarantee in what order they will finish loading and eventually execute. This
    is why it also a good practice to load only a single, compressed JavaScript file
    for your application as much as possible. The fewer `<script>` tags there are,
    the fewer external resources have to be parsed and downloaded, and in the case
    of using the `async` attribute, using only one `<script>` tag means waiting for
    only one asynchronous resource to load and not having to worry about the unpredictable
    sequence of loading multiples files, which could potentially break your application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，同样没有阻塞。然而，缺点是，当你异步加载多个脚本时，无法保证它们加载和最终执行的顺序。这就是为什么尽可能只加载一个压缩的JavaScript文件也是一项良好的实践。脚本标签越少，需要解析和下载的外部资源就越少。在使用`async`属性的情况下，只使用一个`<script>`标签意味着只需等待一个异步资源加载，而不必担心多个文件加载的不可预测顺序，这可能会破坏你的应用。
- en: Using the script tag defer attribute
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`<script>`标签的`defer`属性
- en: Another method for loading a `<script>` tag directly from the body and not causing
    the document parser to be blocked is the `defer` attribute. Unlike `async`, this
    attribute ensures that the `<script>` tag will not be loaded until the document
    parsing is complete, or upon the `DOMContentLoaded` event.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从`<body>`中直接加载`<script>`标签而不阻塞文档解析的另一种方法是使用`defer`属性。与`async`不同，此属性确保在文档解析完成或`DOMContentLoaded`事件发生之前，不会加载`<script>`标签。
- en: 'Using the `defer` attribute, your `<script>` tag can be placed anywhere within
    the `<body>` and always be guaranteed to load after the `DOMContentLoaded` event:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`defer`属性，你的`<script>`标签可以放置在`<body>`中的任何位置，并始终保证在`DOMContentLoaded`事件之后加载：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Managing layouts
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理布局
- en: As mentioned in *[Chapter 2](ch02.html "Chapter 2. Model-View-Whatever")* ,
    *Model-View-Whatever*, a *layout* in relation to an SPA is the server-side HTML
    page that is used to house, initialize, and display your app. The layout will
    contain similar HTML markup to the examples in the previous section regarding
    how to load your SPA container.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如*[第2章](ch02.html "第2章。模型-视图-任意")*所述，*模型-视图-任意*，与SPA相关的布局是用于存放、初始化和显示应用的HTML页面。布局将包含与上一节中关于如何加载SPA容器的示例类似的HTML标记。
- en: The layout is generally the only native server-side component necessary to create
    an SPA, the other components being the native frontend code and the external API
    for providing endpoints for data consumption and manipulation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 布局通常是创建单页应用（SPA）所需的唯一原生服务器端组件，其他组件包括原生前端代码以及用于提供数据消费和操作端点的外部API。
- en: Static layouts
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态布局
- en: A layout can be something as simple as a static HTML page that is loaded onto
    a web server and calls the resources necessary for loading your app within a defined
    container element on that page. Ideally, once that initial HTML page is loaded,
    no other server-side HTML pages need to be accessed to run your app, hence the
    term *Single Page Application*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 布局可以是加载到Web服务器上的静态HTML页面，并在该页面上调用加载应用所需的资源，在定义的容器元素内。理想情况下，一旦加载了初始HTML页面，就不需要访问其他服务器端HTML页面来运行你的应用，这就是“单页应用”这个术语的由来。
- en: If you do not require any server-side framework interaction for setting up environment
    variables, testing login state, and so on, then a static HTML page is the quickest
    and easiest way to launch your SPA.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要任何服务器端框架交互来设置环境变量、测试登录状态等，那么静态HTML页面是启动SPA最快、最简单的方式。
- en: 'A static HTML layout page could be something as simple as the following example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静态HTML布局页面可能像以下示例那样简单：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A drawback to using a static HTML file simply being served on a web server is
    that you have to go directly to that file in order to load your app. If your app
    is reached at `myapp.com`, for instance, and your static HTML layout page is named
    `index.html`, most web servers will route the *root* server request to this page
    automatically, so a user would not need to navigate directly to `myapp.com/index.html`
    in order to reach it, but just to `myapp.com`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态 HTML 文件简单地作为 Web 服务器上的服务的一个缺点是，您必须直接访问该文件才能加载您的应用程序。例如，如果您的应用程序在 `myapp.com`
    上，并且您的静态 HTML 布局页面命名为 `index.html`，大多数 Web 服务器会自动将 *root* 服务器请求路由到该页面，因此用户不需要直接导航到
    `myapp.com/index.html` 来访问它，只需访问 `myapp.com` 即可。
- en: If a user were to go to `myapp.com/profile`, however, where they might find
    their user profile information, the app layout would not be loaded and the server
    would generate a **HTTP 404**, or **Not Found**, response. In order to provide
    for this use case and allow custom URLs for your app, a *dynamic layout* is necessary.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果用户访问 `myapp.com/profile`，他们可能会找到他们的用户资料信息，应用程序布局将不会被加载，服务器将生成一个 **HTTP
    404**，或 **未找到**，响应。为了提供这种用例并允许您的应用程序有自定义的 URL，需要一个 *动态布局*。
- en: Dynamic layouts
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态布局
- en: When you have control over the server-side framework for your single page application,
    as would be the case when using the MEAN stack, then you may want to develop a
    more dynamic server layout page that can load variables and some minimal logic
    from the server side when your app initially loads.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当您控制单页应用程序的后端框架时，例如在使用 MEAN 栈时，您可能希望开发一个更动态的服务器布局页面，以便在应用程序最初加载时从服务器端加载变量和一些基本逻辑。
- en: Express is a server-side web framework for Node.js, and it is the *E* in the
    MEAN stack acronym. When you are developing with the MEAN stack, you will be using
    Express to define and handle all of your REST API endpoints, but you will also
    want to handle your main application entry point.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Express 是一个用于 Node.js 的服务器端 Web 框架，它是 MEAN 栈缩写中的 *E*。当您使用 MEAN 栈进行开发时，您将使用 Express
    来定义和处理所有您的 REST API 端点，但您也想要处理您的主要应用程序入口点。
- en: Installing Express
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Express
- en: 'Let''s go back to our Node.js environment we have been using to work with NPM,
    Bower, and Grunt, and install Express:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们一直在使用的 Node.js 环境，使用 NPM、Bower 和 Grunt，并安装 Express：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, we are using the `--save` parameter to save Express to our main
    NPM dependencies, since it is not just being used for development.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `--save` 参数将 Express 保存到我们的主要 NPM 依赖项中，因为它不仅用于开发。
- en: Setting up a basic server with Express
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Express 设置基本服务器
- en: 'Once you have Express installed, create a file called `server.js` in the root
    directory of your app:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了 Express，请在您的应用程序根目录中创建一个名为 `server.js` 的文件：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Within this file, add the following code to include the Express module and
    initialize your application object:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，添加以下代码以包含 Express 模块并初始化您的应用程序对象：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `app` object within your `server.js` file will allow you to call methods
    on it for defining routes. In the case of our SPA example, we only need to define
    one route for the time being.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `server.js` 文件中的 `app` 对象将允许您调用它来定义路由。在我们的 SPA 示例中，我们目前只需要定义一个路由。
- en: Basic routing with Express
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Express 进行基本路由
- en: Routing in Express refers to defining URL paths which are used to respond to
    server requests. Express can define routes for any type of HTTP request, including
    `GET`, `POST`, `PUT`, and `DELETE` requests, which are necessary for creating
    a REST API. At this point, however, we simply want to define a route for loading
    a HTML page.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Express 中的路由是指定义用于响应服务器请求的 URL 路径。Express 可以定义任何类型的 HTTP 请求的路由，包括 `GET`、`POST`、`PUT`
    和 `DELETE` 请求，这对于创建 REST API 是必要的。然而，在此阶段，我们只想定义一个用于加载 HTML 页面的路由。
- en: 'Defining a route for your main application entry point would be a GET request,
    and this is quite simple to do with Express. In the `server.js` file you just
    created, add the following code below the `app` object definition:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的应用程序主入口点定义一个路由将是一个 GET 请求，使用 Express 来做这件事非常简单。在您刚刚创建的 `server.js` 文件中，在
    `app` 对象定义下方添加以下代码：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command adds a route that will serve the `index.html` file you created
    earlier as the root response for the app. The second parameter, which defines
    a `root` property as `__dirname`, simply sets the root server path for the app
    to the current directory.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令添加了一个路由，它将为您之前创建的 `index.html` 文件提供服务，作为应用程序的根响应。第二个参数，它定义了一个 `root` 属性为
    `__dirname`，只是将应用程序的根服务器路径设置为当前目录。
- en: Now we want to use Express to serve our app instead of the simple `http-server`
    module from earlier.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想使用 Express 来提供我们的应用程序，而不是之前简单的 `http-server` 模块。
- en: Running a server with Express
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Express 运行服务器
- en: 'Now that you have your `server.js` file set up with a basic route to the root
    of your application, all that is left is to set up a HTTP port to listen on and
    to load the app. In your `server.js` file, add the following code to your route
    definition:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了 `server.js` 文件，并添加了一个指向应用程序根目录的基本路由，剩下要做的就是设置一个 HTTP 端口来监听并加载应用程序。在你的
    `server.js` 文件中，向路由定义中添加以下代码：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This tells the server to listen on HTTP `port 8080` for serving the app layout.
    Now all you have to do is run the server from the command line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉服务器在 HTTP `端口 8080` 上监听以提供应用程序布局。现在你只需要从命令行运行服务器：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will run the server and display the console message `App now listening
    on port 8080` in the terminal.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行服务器并在终端显示控制台消息 `App now listening on port 8080`。
- en: Now go to `localhost:8080` in your browser and you should see the simple SPA
    page we created in *[Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"), Model-View-Whatever*.
    You will notice some errors in your browser console, however, because the local
    JavaScript files which are linked to in `index.html` are not found. This is occurring
    because you have not defined a route for loading static asset files.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到浏览器中的 `localhost:8080`，你应该看到我们在 *[第 2 章](ch02.html "第 2 章。模型-视图-Whatever")*
    模型-视图-Whatever* 中创建的简单 SPA 页面。然而，你会在浏览器控制台中注意到一些错误，因为链接到 `index.html` 的本地 JavaScript
    文件找不到。这是因为你还没有为加载静态资源文件定义路由。
- en: Loading static assets with Express
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Express 加载静态资源
- en: 'First, stop the app by pressing *Ctrl* + *C* from the command line. Now edit
    `server.js` again and add the following code *above* the SPA layout page route
    definition:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在命令行中按 *Ctrl* + *C* 停止应用程序。现在再次编辑 `server.js` 并在 SPA 布局页面路由定义之上添加以下代码：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command will set the app to load static assets from the root directory.
    Now if you run `nodeserver.js` again from the command line and reload the page
    in your browser, the SPA should load all assets and work just as it did before
    with `http-server`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将设置应用程序从根目录加载静态资源。现在如果你再次从命令行运行 `nodeserver.js` 并在浏览器中重新加载页面，SPA 应该加载所有资源并像之前使用
    `http-server` 一样正常工作。
- en: Dynamic routing with Express
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Express 进行动态路由
- en: 'As mentioned earlier, our app should allow a user to go to something like `myapp.com/profile`,
    or in our case `localhost:8080/profile`, to load a dynamic request that will trigger
    a different view than the main root view for the app. If you go to `localhost:8080/profile`
    in your app now, you will get the following response in your browser:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的应用程序应该允许用户访问类似 `myapp.com/profile` 或在我们的情况下 `localhost:8080/profile`
    的位置，以加载一个将触发与应用程序主根视图不同的视图的动态请求。如果你现在在应用程序中访问 `localhost:8080/profile`，你将在浏览器中收到以下响应：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To fix this, stop your local server again, edit the `server.js` file and make
    the following change to the app layout route definition:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，再次停止本地服务器，编辑 `server.js` 文件，并对应用程序布局路由定义进行以下更改：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we simply changed the path parameter in the `GET` route definition from
    `'/'` to `'*'`. Express allows for regular expression syntax within route definitions,
    so what this does is tell the server to route all dynamic path requests to the
    `index.html` page, instead of just the root `'/'` path.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将 `GET` 路由定义中的路径参数从 `'/'` 更改为 `'*'`。Express 允许在路由定义中使用正则表达式语法，所以这告诉服务器将所有动态路径请求路由到
    `index.html` 页面，而不仅仅是根 `'/'` 路径。
- en: Save this change, and now if you run `node server.js` again on the command line
    and go to `localhost:8080/profile` in your browser, you will see the SPA displayed
    again just as it did from the root path, and all static asset files should be
    loaded as expected.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此更改，现在如果你再次在命令行中运行 `node server.js` 并在浏览器中访问 `localhost:8080/profile`，你将再次看到从根路径显示的
    SPA，并且所有静态资源文件都应该按预期加载。
- en: 'After setting up this basic Node.js Express server, your final `server.js`
    file should look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置此基本的 Node.js Express 服务器之后，你的最终 `server.js` 文件应该看起来像这样：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our simple SPA has now become a bit more sophisticated, with the ability to
    serve a dynamic layout file, and to use dynamic routes for loading the layout
    via custom URLs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的 SPA 现在变得更加复杂，能够提供动态布局文件，并使用动态路由通过自定义 URL 加载布局。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have a better understanding of various data interchange formats
    such as JSON, BSON, XML, and YAML, and how they are used in web applications.
    You should understand the differences between SQL and NoSQL databases and what
    the advantages are of using one or the other depending on the needs of your application,
    and you have also learned about MongoDB and its use of BSON as a binary form of
    JSON. Additionally, you have learned about using web SPA container elements, and
    various methods of initializing and loading your app into that container.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对各种数据交换格式有了更好的理解，例如JSON、BSON、XML和YAML，以及它们在Web应用中的使用方式。你应该了解SQL和NoSQL数据库之间的区别，以及根据应用需求选择使用其中一种数据库的优势，并且你已经学习了MongoDB及其将BSON作为JSON的二进制形式的使用。此外，你还学习了如何使用Web
    SPA容器元素，以及将你的应用初始化和加载到该容器中的各种方法。
- en: These concepts are fundamental to understanding SPA development in general,
    and to understanding the inner workings of the MEAN stack and how it differs from
    other application development architectures.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念对于理解SPA（单页应用）开发至关重要，并且有助于理解MEAN栈的内部工作原理以及它与其它应用开发架构的不同之处。
- en: Now that you have gotten a glimpse into the server side of a Node.js application
    and built a basic server with Express, let's go deeper into working with Express
    and learn about creating REST API requests for consumption within an SPA.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经对Node.js应用程序的客户端有了初步的了解，并且使用Express构建了一个基本的服务器，那么让我们进一步学习如何使用Express，并了解如何在SPA内部创建REST
    API请求。
