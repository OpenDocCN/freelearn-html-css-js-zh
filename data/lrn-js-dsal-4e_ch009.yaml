- en: 8 Dictionaries and Hashes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 字典和散列
- en: '**Before you begin: Join our book community on Discord**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**在开始之前：加入我们的 Discord 书籍社区**'
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“学习 JavaScript 数据结构算法第 4 版”频道下找到“EARLY
    ACCESS SUBSCRIPTION”）。
- en: '![](img/file0.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file0.png)'
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
- en: 'In the previous chapter, we delved into the world of sets, focusing on their
    ability to efficiently store unique values. Building upon this foundation, we
    will now explore two more data structures designed for storing distinct elements:
    dictionaries and hashes.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入探讨了集合的世界，关注它们高效存储唯一值的能力。在此基础上，我们现在将探索两个旨在存储不同元素的数据结构：字典和哈希。
- en: While sets prioritize the value itself as the primary element, dictionaries
    and hashes take a different approach. Both structures store data as key-value
    pairs, allowing us to associate a unique key with a corresponding value. This
    pairing is fundamental to how dictionaries and hashes work.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然集合优先考虑值本身作为主要元素，但字典和哈希采取了不同的方法。这两种结构都以键值对的形式存储数据，使我们能够将一个唯一的键与相应的值关联起来。这种配对是字典和哈希工作的基本原理。
- en: However, there is a subtle yet important distinction in implementation. Dictionaries,
    as we will soon discover, adhere to a strict rule of one value per key. Hashes,
    on the other hand, offer some flexibility in handling multiple values associated
    with the same key, opening up additional possibilities for data organization and
    retrieval.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实现上存在一个微妙但重要的区别。正如我们很快就会发现的，字典遵循每个键一个值的严格规则。另一方面，哈希表在处理与同一键关联的多个值时提供了一些灵活性，为数据组织和检索开辟了额外的可能性。
- en: 'In this chapter, we will cover:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The dictionary data structure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典数据结构
- en: The hash table data structure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表数据结构
- en: Handling collisions in hash tables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理哈希表中的冲突
- en: The JavaScript native `Map`, `WeakMap`, and `WeakSet` classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 原生的 `Map`、`WeakMap` 和 `WeakSet` 类
- en: The dictionary data structure
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典数据结构
- en: As we have explored, a set is a collection of unique elements, ensuring that
    no duplicates exist within the structure. In contrast, a **dictionary** is designed
    to store pairs of keys and values. This pairing enables us to utilize keys as
    identifiers to efficiently locate specific elements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所探讨的，集合是一组唯一的元素集合，确保在结构中不存在重复的元素。相比之下，**字典**被设计用来存储键值对。这种配对使我们能够利用键作为标识符，有效地定位特定的元素。
- en: While dictionaries share similarities with sets, there is a crucial distinction
    in the type of data they store. Sets maintain a collection of key-key pairs, where
    both elements of the pair are identical. Dictionaries, on the other hand, house
    key-value pairs, associating each unique key with a corresponding value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字典与集合有相似之处，但它们存储的数据类型存在一个关键的区别。集合维护一组键键对，其中对的两元素是相同的。另一方面，字典包含键值对，将每个唯一的键与相应的值关联起来。
- en: 'It is worth noting that dictionaries are known by various names in different
    contexts, including **maps**, **symbol tables**, and **associative arrays**. These
    terms highlight the fundamental purpose of dictionaries: to establish associations
    between keys and values, facilitating efficient data retrieval and organization.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在不同的环境中，字典有不同的名称，包括 **映射**、**符号表**和**关联数组**。这些术语突出了字典的基本目的：在键和值之间建立关联，促进高效的数据检索和组织。
- en: In computer science, dictionaries are frequently employed to store the reference
    addresses of objects. These addresses serve as unique identifiers for objects
    residing in memory. To visualize this concept, consider opening the *Chrome Developer
    Tools* and navigating to the **Memory** tab. Running a snapshot will reveal a
    list of objects along with their respective address references, typically displayed
    in the format *@<number>*. The following screenshot illustrates how dictionaries
    can be used to associate keys with these memory addresses, enabling efficient
    object retrieval and manipulation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，字典经常被用来存储对象的引用地址。这些地址作为内存中对象的唯一标识符。为了可视化这个概念，请考虑打开 *Chrome 开发者工具* 并导航到
    **内存** 选项卡。运行快照将显示一个对象列表及其相应的地址引用，通常以 *@<数字>* 的格式显示。以下截图说明了字典如何将这些键与这些内存地址关联起来，从而实现高效的对象检索和处理。
- en: '![Memory tab of a browser displaying the memory allocation for address references](img/file59.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器内存标签页显示地址引用的内存分配](img/file59.png)'
- en: Memory tab of a browser displaying the memory allocation for address references
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器内存标签页显示地址引用的内存分配
- en: In this chapter, we will also cover some examples of how to use the dictionary
    data structure in real world projects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将涵盖一些如何在现实世界项目中使用字典数据结构的示例。
- en: Creating the Dictionary class
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建字典类
- en: In addition to the `Set` class, **ECMAScript 2015** (ES6) introduced the `Map`
    class, a fundamental data structure often referred to as a dictionary in programming.
    This native implementation serves as the basis for the custom dictionary class
    we will develop in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Set`类之外，**ECMAScript 2015** (ES6) 还引入了`Map`类，这是一个在编程中常被称为字典的基本数据结构。这种原生实现是我们将在本章中开发的自定义字典类的基础。
- en: The `Dictionary` class we will construct draws heavily from the design principles
    of the JavaScript Map implementation. As we explore its structure and functionality,
    you will observe striking similarities to the `Set` class. However, a key distinction
    lies in the data storage mechanism. Instead of storing only values, as in a Set,
    our dictionary class will accommodate key-value pairs. This modification allows
    us to associate unique keys with their corresponding values, thereby unlocking
    the full power and versatility of dictionaries as a data structure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的`Dictionary`类在很大程度上借鉴了JavaScript Map实现的设计原则。在我们探索其结构和功能时，你会观察到与`Set`类惊人的相似之处。然而，一个关键的区别在于数据存储机制。与Set只存储值不同，我们的字典类将容纳键值对。这种修改使我们能够将唯一的键与其对应的值关联起来，从而释放字典作为数据结构的全部功能和灵活性。
- en: 'Our implementation will reside in the src/08-dictionary-hash/dictionary.js
    file. We will start by defining the `Dictionary` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现将位于`src/08-dictionary-hash/dictionary.js`文件中。我们将首先定义`Dictionary`类：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We utilize an object (`{}`) to store elements within the `#items` private property.
    The keys of this object represent the unique keys, while the corresponding values
    can be anything. We will also keep track of the number of elements in the set
    with the property `size`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个对象（`{}`）在`#items`私有属性中存储元素。这个对象的键代表唯一的键，而相应的值可以是任何东西。我们还将使用`size`属性跟踪集合中的元素数量。
- en: In an ideal scenario, a dictionary would seamlessly store keys of the string
    type alongside values of any type, whether they are primitive values like numbers
    or strings, or more complex objects. However, JavaScript's dynamically typed nature
    introduces a potential challenge. Since we cannot guarantee that keys will consistently
    be strings, we must implement a mechanism to transform any object passed as a
    key into a string format. This transformation simplifies the process of searching
    for and retrieving values within our Dictionary class, enhancing its overall functionality.
    The same logic can also be applied to the Set class we explored in the previous
    chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，一个字典可以无缝地存储字符串类型的键和任何类型的值，无论是原始值如数字或字符串，还是更复杂的对象。然而，JavaScript的动态类型特性引入了一个潜在的挑战。由于我们无法保证键始终是字符串，我们必须实现一个机制来将任何作为键传递的对象转换为字符串格式。这种转换简化了在字典类中搜索和检索值的过程，增强了其整体功能。相同的逻辑也可以应用于我们在上一章中探讨的Set类。
- en: Note that we do not have this issue in the TypeScript implementation, as we
    can define the type of the key as string.
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，在TypeScript实现中我们没有这个问题，因为我们可以将键的类型定义为字符串。
- en: 'To achieve this key transformation, we require a function that can reliably
    convert objects into strings. As a default option, we will leverage the `#elementToString`
    method we have defined earlier this book in previous data structures. This function
    provides a reusable solution for stringifying keys, making it adaptable to any
    data structure we create:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一关键转换，我们需要一个能够可靠地将对象转换为字符串的函数。作为一个默认选项，我们将利用本书之前在先前数据结构中定义的`#elementToString`方法。这个函数提供了一个可重用的解决方案，用于将键字符串化，使其适用于我们创建的任何数据结构：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method efficiently converts data into a string representation. If the data
    is a complex object (excluding `null`), it utilizes `JSON.stringify()` to produce
    a **JSON** string. Otherwise, it leverages the `toString` method to ensure a string
    conversion for any other data type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有效地将数据转换为字符串表示。如果数据是一个复杂对象（不包括`null`），它将使用`JSON.stringify()`生成**JSON**字符串。否则，它利用`toString`方法确保任何其他数据类型的字符串转换。
- en: 'Now, let''s define the methods that will empower our dictionary/map data structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义将赋予我们的字典/映射数据结构功能的方法：
- en: '`set(key, value)`: inserts a new key-value pair into the dictionary. If the
    specified key already exists, its associated value will be updated with the new
    value.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(key, value)`: 将新的键值对插入到字典中。如果指定的键已经存在，其关联的值将使用新值进行更新。'
- en: '`remove(key)`: removes the entry corresponding to the provided key from the
    dictionary.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(key)`: 从字典中移除与提供的键对应的条目。'
- en: '`hasKey(key)`: determines whether a given key is present in the dictionary,
    returning `true` if it exists and `false` otherwise.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasKey(key)`: 确定给定的键是否存在于字典中，如果存在则返回`true`，否则返回`false`。'
- en: '`get(key)`: retrieves the value associated with the specified key.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(key)`: 获取与指定键关联的值。'
- en: '`clear()`: empties the dictionary, removing all key-value pairs.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 清空字典，移除所有键值对。'
- en: '`size()`: returns the count of key-value pairs currently stored in the dictionary,
    similar to the length property of an array.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 返回当前存储在字典中的键值对数量，类似于数组的长度属性。'
- en: '`isEmpty()`: checks if the dictionary is empty, returning `true` if the size
    is zero and `false` otherwise.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty()`: 检查字典是否为空，如果大小为零则返回`true`，否则返回`false`。'
- en: '`keys()`: generates an array containing all the keys present in the dictionary.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys()`: 生成一个包含字典中所有键的数组。'
- en: '`values()`: produces an array containing all the values stored in the dictionary.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`: 生成一个包含字典中所有值的数组。'
- en: '`forEach(callbackFn)`: iterates over each key-value pair in the dictionary.
    The `callbackFn` function, which accepts a key and a value as parameters, is executed
    for each entry. This iteration process can be terminated if the callback function
    returns `false`, mirroring the behavior of the `every` method in the `Array` class.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach(callbackFn)`: 遍历字典中的每个键值对。接受键和值作为参数的`callbackFn`函数对每个条目执行。如果回调函数返回`false`，则可以终止迭代过程，这与`Array`类中的`every`方法的行为类似。'
- en: We will implement each of these methods in detail in the following sections.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细实现这些方法。
- en: Verifying whether a key exists in the dictionary
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证键是否存在于字典中
- en: 'The first method we will implement is the `hasKey(key)` method. This method
    is fundamental, as it will be utilized in other methods like `set` and `remove`.
    Let''s examine its implementation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一种方法是`hasKey(key)`方法。这个方法是基本的，因为它将在`set`和`remove`等其它方法中使用。让我们来看看它的实现：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In JavaScript, object keys are inherently strings. Therefore, if a complex object
    is provided as a key, we must convert it to a string representation. To achieve
    this, the `#elementToString` method is invoked consistently, ensuring that keys
    are always treated as strings within our dictionary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，对象的键本质上是字符串。因此，如果提供了一个复杂对象作为键，我们必须将其转换为字符串表示形式。为了实现这一点，我们一致地调用`#elementToString`方法，确保在我们的字典中键始终被视为字符串。
- en: The `hasKey` method checks if there is a value associated with the given key
    within the items table (the underlying storage for our dictionary). If the corresponding
    position in the table is not `null` or `undefined`, indicating the presence of
    a value, the method returns `true`. Otherwise, if no value is found, the method
    returns `false`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasKey`方法检查在项目表中（我们字典的底层存储）是否有与给定键关联的值。如果表中对应的位置不是`null`或`undefined`，表明存在值，则方法返回`true`。如果没有找到值，则方法返回`false`。'
- en: And now that we have this method, we can proceed with the implementation of
    the methods for adding and removing values.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个方法，我们可以继续实现添加和移除值的相应方法。
- en: Setting a key and value in the dictionary
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在字典中设置键和值
- en: 'Next, we will implement the `set` method in our `Dictionary` class. The `set`
    method serves a dual purpose: it can both add a new key-value pair to the dictionary
    and update the value of an existing key:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的`Dictionary`类中实现`set`方法。`set`方法具有双重作用：它既可以向字典中添加新的键值对，也可以更新现有键的值：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method accepts a `key` and a `value` as input. If both the key and value
    are valid (not `null` or `undefined`), the method proceeds to convert the key
    into a string representation. This is a crucial step because JavaScript object
    keys can only be strings. This conversion is handled internally by the private
    `#elementToString` method, ensuring consistency and reliability across all key
    types. With the key in string form, the method then stores the value within the
    dictionary's internal storage (`#items`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个`key`和一个`value`作为输入。如果键和值都有效（不是`null`或`undefined`），则方法继续将键转换为字符串表示形式。这是一个关键步骤，因为JavaScript对象键只能是字符串。这个转换由私有的`#elementToString`方法内部处理，确保所有键类型的一致性和可靠性。在键以字符串形式存在后，该方法将值存储在字典的内部存储（`#items`）中。
- en: Finally, the method communicates its success by returning `true`, signaling
    that the key-value pair was successfully inserted or updated and we increment
    its size. If either the key or value is invalid (`null` or `undefined`), the method
    returns `false`, signaling that the insertion or update operation failed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该方法通过返回`true`来传达其成功，表示键值对已成功插入或更新，并且我们增加其大小。如果键或值无效（`null`或`undefined`），则方法返回`false`，表示插入或更新操作失败。
- en: Removing and clearing all values from the dictionary
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除和清除字典中的所有值
- en: 'The delete method''s primary function is to remove a key-value pair from the
    dictionary based on the provided key. It ensures the integrity of the dictionary
    by checking for the key''s existence before attempting removal and updating the
    size accordingly:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 删除方法的主要功能是根据提供的键从字典中删除键值对。它在尝试删除之前检查键的存在性，并相应地更新大小，以确保字典的完整性：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We start by verifying if the provided key exists within the dictionary. This
    is achieved by calling the `has` method, which checks the dictionary's underlying
    storage for the presence of the specified key. This check is crucial to prevent
    errors that might arise from trying to delete a non-existent entry.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先验证提供的键是否存在于字典中。这是通过调用`has`方法实现的，该方法检查字典的底层存储中是否存在指定的键。这个检查是至关重要的，以防止在尝试删除不存在的条目时出现错误。
- en: If the key is found, the `delete` operator in JavaScript is employed to remove
    the corresponding key-value pair from the dictionary's internal data structure
    (`#items`). Following the successful removal of the entry, the dictionary's internal
    size counter (`#size`) is decremented by one to accurately reflect the change
    in the number of stored elements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到键，JavaScript中的`delete`运算符被用来从字典的内部数据结构（`#items`）中删除相应的键值对。在成功删除条目后，字典的内部大小计数器（`#size`）减一，以准确反映存储元素数量的变化。
- en: As a last step, the method signals the outcome of the operation by returning
    `true` to indicate that the key existed and was successfully deleted, and `false`
    to indicate that the key was not found and no deletion occurred.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，方法通过返回`true`来表示操作的结果，以指示键存在且已成功删除，或者返回`false`以指示键未找到且未发生删除。
- en: 'And if we want to remove all the elements from the set, we can use the `clear`
    method, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从集合中移除所有元素，我们可以使用`clear`方法，如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This effectively discards all previous key-value pairs and creates a fresh,
    empty container for future additions. And we also reset the `#size` property back
    to 0 to accurately reflect that the set now contains no elements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上丢弃了所有之前的键值对，并为未来的添加创建了一个全新的空容器。我们还把`#size`属性重置为0，以准确反映集合现在不包含任何元素。
- en: Retrieving the size and checking if it is empty
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索大小并检查是否为空
- en: 'The next method we will implement is the size method as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要实现的方法是`size`方法，如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method simply returns the size property we are using to keep count.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法简单地返回我们用来计数的`size`属性。
- en: 'And to determine if the dictionary is empty, we implement the `isEmpty()` method,
    following a pattern consistent with other data structures we have covered in this
    book:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定字典是否为空，我们实现了`isEmpty()`方法，遵循与本书中覆盖的其他数据结构一致的模式：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method directly compares the private `#size` property to 0\. The property
    `#size` is meticulously maintained to always reflect the number of elements in
    the set.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法直接比较私有的`#size`属性与0。属性`#size`被精心维护，始终反映集合中的元素数量。
- en: Retrieving a value from the dictionary
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从字典中检索值
- en: 'To search for a specific key within our dictionary and retrieve its associated
    value, we utilize the `get` method. This method streamlines the process of accessing
    stored data by encapsulating the necessary logic and is presented as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的字典中搜索特定的键并检索其关联的值，我们使用 `get` 方法。这个方法通过封装必要的逻辑简化了访问存储数据的过程，如下所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Upon receiving a `key` as input, the `get` method first transforms it into
    a string representation using the private `#elementToString` function. Next, the
    method directly accesses the corresponding value from the dictionary''s internal
    storage (`#items`). This is achieved by using the stringified key to index into
    the #items object, which presumably holds the key-value pairs. The value associated
    with the given key, if found, is then returned by the method.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '当接收到 `key` 作为输入时，`get` 方法首先使用私有的 `#elementToString` 函数将其转换为字符串表示。然后，方法直接从字典的内部存储（`#items`）访问相应的值。这是通过使用字符串化的键来索引到
    #items 对象来实现的，该对象假设包含键值对。如果找到，方法将返回与给定键关联的值。'
- en: Retrieving all the values and all the keys from the dictionary
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从字典中检索所有值和键
- en: 'Let''s explore how to retrieve all values and keys from our custom dictionary
    class in JavaScript. We will start by declaring the method `values`, which will
    retrieve all the values stored in the Dictionary class as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何从我们的自定义 JavaScript 字典类中检索所有值和键。我们将从声明方法 `values` 开始，该方法将检索字典类中存储的所有值，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method is quite straightforward. It leverages the built-in `Object.values()`
    function, which takes an object (in this case, our private `#items` storage) and
    returns an array containing all of its values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常直接。它利用了内置的 `Object.values()` 函数，该函数接受一个对象（在这种情况下，我们的私有 `#items` 存储）并返回一个包含所有值的数组。
- en: 'Next, we have the `keys` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `keys` 方法：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similarly, the `keys` method uses the `Object.keys()` function. This function,
    when given an object, returns an array of all the string-based keys (property
    names) in that object. Since we ensure that all keys are strings in our dictionary
    implementation, this works perfectly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`keys` 方法使用了 `Object.keys()` 函数。这个函数，当给定一个对象时，会返回该对象中所有基于字符串的键（属性名）的数组。由于我们确保在字典实现中所有键都是字符串，所以这工作得非常完美。
- en: In most cases, these methods have good performance. However, for exceptionally
    large dictionaries, iterating directly over the `#items` object might be slightly
    more efficient in some JavaScript engines. Let's see how we can achieve this in
    the next topic.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这些方法都有良好的性能。然而，对于特别大的字典，在某些 JavaScript 引擎中直接遍历 `#items` 对象可能会稍微高效一些。让我们看看我们如何在下一节中实现这一点。
- en: Iterating each value-pair of the dictionary with forEach
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `forEach` 迭代字典中的每个值-键对
- en: Thus far, we have not implemented a method that facilitates iteration through
    each value stored within our data structures. We will now introduce the `forEach`
    method for the `Dictionary` class, with the added benefit that this behavior can
    also be applied to other data structures we have previously constructed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有实现一个方法来方便地遍历存储在我们数据结构中的每个值。现在，我们将介绍 `Dictionary` 类的 `forEach` 方法，它带来的额外好处是这种行为也可以应用于我们之前构建的其他数据结构。
- en: 'Here is the `forEach` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `forEach` 方法：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `forEach` method is designed to iterate over every key-value pair within
    our dictionary, applying a provided callback function to each entry. For each
    key-value pair, the provided `callbackFn` function is executed, receiving the
    value and key as arguments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach` 方法旨在遍历字典中的每个键值对，对每个条目应用提供的回调函数。对于每个键值对，提供的 `callbackFn` 函数被执行，接收值和键作为参数。'
- en: We use a `for...in` loop for iterating over object properties. However, to ensure
    that we only process the dictionary's own properties (and not inherited ones from
    its prototype chain), a safeguard is employed. The `hasOwnProperty` method checks
    whether a property belongs directly to the object. In this case, it verifies if
    the current `key` in the loop is an actual key within the `#items` object, the
    dictionary's underlying storage. Then, we apply the provided callback function
    to each entry, retrieving the value from the dictionary and passing the key as
    an argument to the callback.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for...in`循环遍历对象属性。然而，为了确保我们只处理字典的自身属性（而不是从其原型链继承的属性），我们采取了一种保护措施。`hasOwnProperty`方法检查属性是否直接属于对象。在这种情况下，它验证循环中的当前`key`是否是`#items`对象中的实际键，即字典的底层存储。然后，我们将提供的回调函数应用于每个条目，从字典中检索值并将键作为参数传递给回调。
- en: Now that we have our data structure, let's test it!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的数据结构，让我们来测试它！
- en: Using the Dictionary class
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字典类
- en: Imagine we are building a simple language learning program. We want to store
    translations for frequently-used words and phrases to help users quickly look
    up meanings in different languages.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在构建一个简单的语言学习程序。我们想要存储常用单词和短语的翻译，以帮助用户快速查找不同语言中的含义。
- en: 'The source code for this example can be found in the file `src/08-dictionary-hash/01-using-dictionary-class.js`.
    Let''s start by creating the dictionary and adding some values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的源代码可以在文件`src/08-dictionary-hash/01-using-dictionary-class.js`中找到。让我们先创建字典并添加一些值：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We use `set` to populate the dictionary with key-value pairs representing word
    translations. The keys are words in English, and the values are their Portuguese
    translations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`set`来用表示单词翻译的键值对填充字典。键是英语单词，值是它们的葡萄牙语翻译。
- en: 'Next, we will create a function so the user can interact with it to retrieve
    the translation of a particular word or phrase:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数，以便用户可以与之交互以检索特定单词或短语的翻译：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `translateWord` function takes a `word` as input. It uses `hasKey` to check
    if the word exists in the dictionary. If the word is found, it retrieves the translation
    using the `get` method and prints it. If not found, it displays a "no translation
    found" message.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`translateWord`函数接受一个`word`作为输入。它使用`hasKey`来检查单词是否存在于字典中。如果找到单词，它使用`get`方法检索翻译并打印出来。如果没有找到，它显示“未找到翻译”的消息。'
- en: 'We can try this function with the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码尝试这个函数：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also check all translations available:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查所有可用的翻译：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And alls words we have transactions available:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有所有可用的交易词汇：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And in case we would like to print the dictionary, we can use the `forEach`
    method as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想打印字典，可以使用`forEach`方法如下：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will get the following output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, now that we have a very similar implementation of the native JavaScript
    Map class,
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有了与原生JavaScript Map类非常相似的实现，
- en: The JavaScript Map class
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript Map类
- en: ECMAScript 2015 introduced a Map class as part of the JavaScript API. We developed
    our Dictionary class based on the ES2015 Map class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2015将Map类作为JavaScript API的一部分引入。我们的字典类是基于ES2015 Map类开发的。
- en: 'At its core, a Map is a collection of key-value pairs, similar to a dictionary
    or hash table in other programming languages. However, unlike plain JavaScript
    objects, a Map offers several key advantages as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Map是一个键值对的集合，类似于其他编程语言中的字典或哈希表。然而，与纯JavaScript对象不同，Map提供了以下几个关键优势：
- en: The Map class allows keys of any data type, including objects, functions, or
    even other Map objects. In contrast, object keys are automatically converted to
    strings.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map类允许任何数据类型的键，包括对象、函数，甚至是其他Map对象。相比之下，对象键会自动转换为字符串。
- en: The Map class maintains the order in which key-value pairs were inserted, making
    iteration predictable.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map类维护键值对插入的顺序，使得迭代可预测。
- en: We can easily get the number of entries using the size property, whereas with
    objects, we typically need to use `Object.keys(obj).length`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以轻松地使用`size`属性获取条目数量，而对于对象，我们通常需要使用`Object.keys(obj).length`。
- en: The Map class natively supports iteration using `for...of` loops, making it
    more convenient to work with.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map类原生支持使用`for...of`循环进行迭代，这使得与它一起工作更加方便。
- en: 'Now, let''s take a look at the methods and features available in the native
    Map class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看原生Map类中可用的方法和功能：
- en: '`set(key, value)`: adds or updates a key-value pair.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(key, value)`: 添加或更新一个键值对。'
- en: '`get(key)`: retrieves the value associated with the key.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(key)`: 获取与键关联的值。'
- en: '`has(key)`: checks if a key exists.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has(key)`: 检查键是否存在。'
- en: '`delete(key)`: removes a key-value pair.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete(key)`: 移除键值对。'
- en: '`size`: returns the number of entries.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`: 返回条目的数量。'
- en: '`clear()`: removes all entries.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 移除所有条目。'
- en: '`forEach(callbackFn)`: iterates over all entries.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach(callbackFn)`: 遍历所有条目。'
- en: 'If we would like to rewrite our translation application example, can we simply
    replace `Dictionary` with `Map` and the code would still work as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要重写我们的翻译应用程序示例，我们是否可以简单地用`Map`替换`Dictionary`，代码仍然可以按以下方式工作：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The other methods, such as `get`, check the `size`, `has`, `values` and `forEach`
    would also work as expected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法，如`get`、`size`、`has`、`values`和`forEach`也会按预期工作。
- en: Constructing our custom `Dictionary` class has proven to be an enlightening
    educational endeavor, granting us a deeper understanding of the inner mechanisms
    of map data structures. While the built-in JavaScript Map class offers efficiency
    and convenience for most everyday scenarios, the experience of creating our own
    dictionary equips us with valuable knowledge.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构建我们的自定义`Dictionary`类已经证明是一个富有教育意义的努力，让我们对映射数据结构的内部机制有了更深入的理解。虽然内置的JavaScript
    `Map`类为大多数日常场景提供了效率和便利，但创建我们自己的字典使我们获得了宝贵的知识。
- en: 'JavaScript also supports a weak version of the Map and Set classes: `WeakMap`
    and `WeakSet`. Let''s briefly take a look at them.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还支持Map和Set类的弱版本：`WeakMap`和`WeakSet`。让我们简要地看看它们。
- en: The JavaScript WeakMap and WeakSet classes
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript的`WeakMap`和`WeakSet`类
- en: In addition to the standard `Map` and `Set` classes, JavaScript offers two specialized
    collection types known as `WeakMap` and `WeakSet`. These classes provide a unique
    way to manage object references and can be particularly useful in scenarios where
    memory management is a concern.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的`Map`和`Set`类之外，JavaScript还提供了两种称为`WeakMap`和`WeakSet`的专用集合类型。这些类提供了一种独特的方式来管理对象引用，在内存管理是关注点的情况下尤其有用。
- en: Similar to a `Map`, a `WeakMap` stores key-value pairs. However, the keys in
    a `WeakMap` *must* be *objects*, and the references to these keys are weak. This
    means that if the only reference to an object is its presence as a key in a `WeakMap`,
    the JavaScript garbage collector can remove that object from memory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Map`类似，`WeakMap`存储键值对。然而，`WeakMap`中的键必须是*对象*，并且对这些键的引用是弱引用。这意味着如果对象的唯一引用是作为`WeakMap`中的键存在，JavaScript垃圾回收器可以将其从内存中移除。
- en: A `WeakSet` functions like a `Set`, storing a collection of unique values. However,
    it can only store `objects`, and the references to these objects are weak. Similar
    to `WeakMap`, if an object's only reference is its presence in a `WeakSet`, it
    can be garbage collected.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakSet`的功能类似于`Set`，存储一组唯一的值。然而，它只能存储`对象`，并且对这些对象的引用是弱引用。类似于`WeakMap`，如果一个对象的唯一引用是它在`WeakSet`中的存在，那么它可以被垃圾回收。'
- en: '`WeakMap` and `WeakSet` also have fewer methods than their regular counterparts.
    They lack `size`, `clear`, and iteration methods (like `forEach` and `keys()`).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakMap`和`WeakSet`也与其常规对应物相比方法较少。它们缺少`size`、`clear`和迭代方法（如`forEach`和`keys()`）。'
- en: 'Let''s review a real-world scenario where we would use these classes. Imagine
    we are designing a program that provides a Person class. We want to store some
    sensitive private data associated with each person instance, like their social
    security number (or tax id) or medical records. However, we do not want to clutter
    the object itself with these properties, and we want to ensure they can be garbage
    collected when the Person object is no longer needed. Here is the code to exemplify
    this scenario:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个现实场景，我们会使用这些类。想象一下，我们正在设计一个提供`Person`类的程序。我们希望存储与每个实例相关的一些敏感的私有数据，例如他们的社会保险号（或税号）或医疗记录。然而，我们不希望对象本身被这些属性所杂乱，并且我们想要确保它们可以在`Person`对象不再需要时被垃圾回收。以下是演示此场景的代码：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A `WeakMap` is created to store the private data. The key is the `Person` object
    itself (`this`). Inside the `Person` `constructor`, we use `privateData.set(this,
    { ... })` to associate private data with the newly created person object (`this`).
    The `getSSN` method retrieves the private SSN data using `privateData.get(this)`.
    Note the **optional chaining** (`?.`) to safely handle cases where the `Person`
    object might no longer exist (and this way we do not get a *null pointer* error).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `WeakMap` 来存储私有数据。键是 `Person` 对象本身（`this`）。在 `Person` 构造函数内部，我们使用 `privateData.set(this,
    { ... })` 将私有数据与新创建的人对象（`this`）关联起来。`getSSN` 方法使用 `privateData.get(this)` 获取私有
    SSN 数据。注意 **可选链** (`?.`) 以安全地处理 `Person` 对象可能不再存在的情况（这样我们就不会得到一个 *null pointer*
    错误）。
- en: Why use a `WeakMap` instead of a `Map` here? When a Person object becomes inaccessible
    (no references to it remain), the garbage collector can remove the reference of
    the object and the associated private data in the `WeakMap`, preventing memory
    leaks. This can be considered a good practice for managing sensitive or temporary
    data that does not need to outlive the objects it is associated with.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在这里使用 `WeakMap` 而不是 `Map`？当一个 `Person` 对象变得不可访问（没有对其的引用）时，垃圾收集器可以移除对象的引用以及
    `WeakMap` 中相关的私有数据，防止内存泄漏。这可以被认为是一种管理敏感或临时数据的好做法，这些数据不需要比与之关联的对象存活得更久。
- en: This pattern also could be used to implement private properties in JavaScript
    classes before the hash (#) notation was introduced to JavaScript private properties.
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种模式也可以用来在引入哈希（#）符号之前在 JavaScript 类中实现私有属性。
- en: Now that we understand the map or dictionary data structure, let's take it to
    the next level with hash tables.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了映射或字典数据结构，让我们通过哈希表将其提升到下一个层次。
- en: The hash table data structure
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希表数据结构
- en: The **hash table** data structure, also known as **hash map**, is a hash implementation
    of the dictionary or map data structures. A hash table is also a collection of
    key-value pairs. The key is a unique identifier, and the value is the data you
    want to associate with that key. Hash tables achieve their speed by using a **hash
    function**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希表**数据结构，也称为 **哈希映射**，是字典或映射数据结构的哈希实现。哈希表也是一个键值对的集合。键是一个唯一的标识符，值是你想要与该键关联的数据。哈希表通过使用
    **哈希函数** 来实现其速度。'
- en: 'This is how hash tables work:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是哈希表的工作方式：
- en: '*Hash Function*: a hash function takes a key as input and produces a unique
    numerical value called a **hash code** (or **hash value**). This hash code is
    like a fingerprint of the key.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈希函数*：哈希函数接受一个键作为输入，并产生一个唯一的数值，称为 **哈希码**（或 **哈希值**）。这个哈希码就像键的指纹。'
- en: '*Storage (buckets/slots)*: the hash table internally consists of an array (or
    similar structure like a linked list) with fixed-size buckets or slots. Each bucket
    can store one or more key-value pairs.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储（桶/槽）*：哈希表内部由一个数组（或类似的结构，如链表）组成，具有固定大小的桶或槽。每个桶可以存储一个或多个键值对。'
- en: '*Insertion*: when you insert a key-value pair:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*插入*：当你插入一个键值对时：'
- en: The hash function is applied to the key to get its hash code.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数应用于键以获取其哈希码。
- en: The hash code is used to determine the index (bucket) where the key-value pair
    should be stored.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希码用于确定键值对应该存储的索引（桶）。
- en: The pair is placed in that bucket.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这对数据被放入那个桶中。
- en: '*Retrieval*: when you want to retrieve a value, you provide and key and:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检索*：当你想要检索一个值时，你提供一个键和：'
- en: The hash function is applied to the key again, producing the same hash code.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数再次应用于键，产生相同的哈希码。
- en: The hash code is used to directly access the bucket where the value should be
    stored.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希码用于直接访问应存储值的桶。
- en: The value is found (hopefully) in that bucket.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值（希望）就在那个桶中。
- en: 'Hash tables are present in many different places. For example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表存在于许多不同的地方。例如：
- en: 'Databases: used for indexing data for fast retrieval.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库：用于为快速检索索引数据。
- en: 'Caches: store recently accessed data for quick lookups.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存：存储最近访问的数据以快速查找。
- en: 'Symbol Tables: in compilers, used to store information about variables and
    functions.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号表：在编译器中用于存储有关变量和函数的信息。
- en: 'One of the most classical examples for a hash table is an email address book.
    For example, whenever we want to send an email, we look up the person''s name
    and retrieve their email address. The following image exemplifies this process:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表最经典的例子之一是电子邮箱簿。例如，每当我们想要发送电子邮件时，我们会查找人的名字并检索他们的电子邮件地址。以下图像展示了这个过程：
- en: '![A hash table used to store email addresses based on the contact name](img/file60.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![一个基于联系名的电子邮件地址存储的哈希表](img/file60.png)'
- en: A hash table used to store email addresses based on the contact name
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基于联系名的电子邮件地址存储的哈希表
- en: For this example, we will use a hash function which will simply sum up the ASCII
    values of each character of the key length. This is called a **lose-lose hash**
    function, which is very simple function that can lead into different issues that
    we will explore in the next sections.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一个哈希函数，该函数将简单地累加键长度的每个字符的ASCII值。这被称为**输输哈希**函数，这是一个非常简单的函数，可能导致我们在下一节中将要探讨的不同问题。
- en: Let's translate this diagram into a source code by creating a `HashTable` class
    in the new topic so we can dive into this concept.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个图表翻译成源代码，通过在新的主题中创建一个`HashTable`类，这样我们就可以深入探讨这个概念。
- en: Creating the HashTable class
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建哈希表类
- en: 'Our hash table implementation will be located in the `src/08-dictionary-hash/hash-table.js`
    file. We begin by defining the `HashTable` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的哈希表实现将位于`src/08-dictionary-hash/hash-table.js`文件中。我们首先定义`HashTable`类：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This initial step simply initializes the private `#table` array, which will
    serve as the underlying storage for our key-value pairs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始步骤只是初始化私有的`#table`数组，它将作为我们的键值对的底层存储。
- en: 'Next, we will equip our `HashTable` class with three essential methods:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的`HashTable`类配备三个基本方法：
- en: '`put(key, value)`: this method either adds a new key-value pair to the hash
    table or updates the value associated with an existing key.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`put(key, value)`：这个方法要么将新的键值对添加到哈希表中，要么更新与现有键关联的值。'
- en: '`remove(key)`: this method removes the value and its corresponding key from
    the hash table based on the provided key.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`remove(key)`：这个方法根据提供的键从哈希表中删除值及其对应的键。'
- en: '`get(key)`: this method retrieves the value associated with a specific key
    from the hash table.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get(key)`：这个方法从哈希表中检索与特定键关联的值。'
- en: 'To enable the functionality of these methods, we also need to create a crucial
    component: the hash function. This function will play a vital role in determining
    the storage location of each key-value pair within the hash table, making it a
    cornerstone of our implementation.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些方法的功能得以实现，我们还需要创建一个关键组件：哈希函数。这个函数将在确定哈希表中每个键值对的存储位置中发挥至关重要的作用，成为我们实现的基础。
- en: Creating the lose-lose hash function
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建输输哈希函数
- en: 'Before implementing the core `put`, `remove`, and `get` methods, we must first
    establish a `hash` method. This method is fundamental, as it will determine the
    storage location of key-value pairs within the hash table. The code is presented
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现核心的`put`、`remove`和`get`方法之前，我们必须首先建立一个`hash`方法。这个方法是基本的，因为它将决定哈希表中键值对的存储位置。代码如下所示：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `hash` method acts as a wrapper around the `loseLoseHashCode` method, forwarding
    the provided `key` as its parameter. This wrapper design serves a strategic purpose:
    it allows for future flexibility in modifying the hash function without impacting
    other areas of our code that utilize the hash code. The `loseLoseHashCode` method
    is where the actual hash calculation takes place:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash`方法作为`loseLoseHashCode`方法的包装器，将提供的`key`作为其参数。这种包装器设计具有战略意义：它允许我们在不影响我们代码的其他使用哈希码的区域的情况下，未来灵活地修改哈希函数。`loseLoseHashCode`方法是实际哈希计算发生的地方：'
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Within `loseLoseHashCode`, we begin by checking if the key is already a string.
    If not, we convert it into a string using the `#elementToString` method we created
    in previous chapters to ensure consistent handling of keys.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loseLoseHashCode`中，我们首先检查键是否已经是字符串。如果不是，我们使用我们在前几章中创建的`#elementToString`方法将其转换为字符串，以确保对键的一致处理。
- en: Next, we calculate a hash value by summing the ASCII values of each character
    in the key string. It leverages two powerful array methods, `split` and `reduce`,
    to achieve this efficiently. It first splits the string into an array of individual
    characters. Then, it uses the reduce method to iterate over these characters,
    accumulating their ASCII values into a single hash value. For each character,
    we retrieve its ASCII value using the `charCodeAt` method and add it to the hash
    variable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过计算键字符串中每个字符的ASCII值的总和来计算一个哈希值。它利用两个强大的数组方法`split`和`reduce`来有效地实现这一点。它首先将字符串拆分为一个包含单个字符的数组。然后，它使用`reduce`方法遍历这些字符，将它们的ASCII值累加到一个单一的哈希值中。对于每个字符，我们使用`charCodeAt`方法检索其ASCII值，并将其添加到哈希变量中。
- en: Finally, to avoid working with potentially large numbers that might not fit
    within a numeric variable, we apply a *modulo* operation (the remainder after
    dividing one number by another) to the hash value using an arbitrary divisor (in
    this case, 37). This ensures that the resulting hash code falls within a manageable
    range, optimizing storage and retrieval within the hash table.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了避免处理可能不适合数字变量的较大数字，我们使用一个任意的除数（在这种情况下，37）对哈希值应用模运算（除以另一个数后的余数）。这确保了生成的哈希码在一个可管理的范围内，优化了哈希表中的存储和检索。
- en: Now that we have our hash function, we can start diving into the next methods.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了哈希函数，我们可以开始深入研究下一个方法。
- en: Putting a key and a value in the hash table
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在哈希表中放置键和值
- en: 'Having established our `hash` function, we can now proceed to implement the
    `put` method. This method mirrors the functionality of the `set` method in the
    `Dictionary` class, with a slight difference in naming convention to align with
    customary practice in other programming languages. The `put` method is presented
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了我们的`hash`函数之后，我们现在可以继续实现`put`方法。此方法与`Dictionary`类中的`set`方法的功能相似，只是在命名约定上略有不同，以符合其他编程语言中的惯例。`put`方法如下所示：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `put` method facilitates the insertion or updating of key-value pairs within
    the hash table. It first validates the provided key and value, ensuring that neither
    is `null` or `undefined`. This check prevents the storage of incomplete or meaningless
    data within the hash table.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`put`方法便于在哈希表中插入或更新键值对。它首先验证提供的键和值，确保它们都不是`null`或`undefined`。这个检查防止在哈希表中存储不完整或无意义的数据。'
- en: If both the `key` and value are deemed valid, we proceed to calculate the hash
    code for the given key. This hash code, determined by the `hash` function, will
    serve as the index for storing the value in the underlying `#table` array.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键和值都被认为是有效的，我们就继续计算给定键的哈希码。这个哈希码由`hash`函数确定，将作为在底层`#table`数组中存储值的索引。
- en: Finally, the put method returns `true` to indicate that the key-value pair was
    successfully inserted or updated. Conversely, if either the key or value is invalid,
    the method returns `false`, signifying that the operation was not successful.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`put`方法返回`true`以指示键值对已成功插入或更新。相反，如果键或值无效，该方法返回`false`，表示操作未成功。
- en: Once a value is present in the table, we can try to retrieve it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦值存在于表中，我们就可以尝试检索它。
- en: Retrieving a value from the hash table
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从哈希表中检索值
- en: 'Retrieving a value from the `HashTable` instance is a straightforward process,
    facilitated by the `get` method. This method enables us to efficiently access
    data stored within the hash table based on its associated key:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从`HashTable`实例中检索值是一个简单的过程，由`get`方法提供便利。此方法使我们能够根据其关联的键高效地访问哈希表中存储的数据：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We start by validating the input key, ensuring it is not `null` or `undefined`.
    If the key is indeed valid, we proceed to determine its position within the hash
    table using the previously defined `hash` function. This function transforms the
    key into a numerical hash code, which directly corresponds to the index of the
    value in the underlying array.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先验证输入的键，确保它不是`null`或`undefined`。如果键确实有效，我们继续使用先前定义的`hash`函数确定其在哈希表中的位置。这个函数将键转换为一个数值哈希码，该哈希码直接对应于底层数组中值的索引。
- en: Leveraging this calculated index, the method accesses the corresponding element
    in the table array and returns its value. This provides a seamless way to retrieve
    data from the hash table, as the `hash` function eliminates the need for linear
    search and directly points to the desired value's location.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个计算出的索引，方法访问表数组中的相应元素并返回其值。这提供了一种无缝的方式从哈希表中检索数据，因为`hash`函数消除了线性搜索的需要，并直接指向所需值的存储位置。
- en: It is worth noting that in our `HashTable` implementation, we have included
    input validation to ensure the provided keys and values are not invalid (`null`
    or `undefined`). This is a recommended practice that can be applied to all data
    structures we have developed thus far in this book. By proactively validating
    inputs, we enhance the robustness and reliability of our data structures, preventing
    errors and unexpected behavior caused by incorrect or incomplete data.
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 值得注意的是，在我们的`HashTable`实现中，我们已经包括了输入验证，以确保提供的键和值不是无效的（`null`或`undefined`）。这是一种推荐的做法，可以应用于我们在这本书中迄今为止开发的所有数据结构。通过主动验证输入，我们增强了数据结构的健壮性和可靠性，防止了由错误或不完整数据引起的错误和意外行为。
- en: 'Finally, let''s turn our attention to the remaining method in our class: the
    `remove` method.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将注意力转向我们类中的剩余方法：`remove`方法。
- en: Removing a value from the hash table
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从哈希表中删除一个值
- en: 'The final method we will implement for our `HashTable` is the `remove` method,
    designed to eliminate a key-value pair based on the provided key. This method
    is essential for maintaining a dynamic and adaptable hash table structure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的`HashTable`实现的最后一个方法是`remove`方法，它旨在根据提供的键删除键值对。此方法对于维护动态和可适应的哈希表结构至关重要：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To successfully remove a value, we first need to identify its location within
    the hash table. This is achieved by obtaining the hash code corresponding to the
    given key using the `hash` function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功删除一个值，我们首先需要确定它在哈希表中的位置。这是通过使用`hash`函数获取给定键对应的哈希码来实现的。
- en: Next, we retrieve the value pair stored at the calculated hash position. If
    this value pair is not `null` or `undefined`, indicating that the key exists within
    the hash table, we proceed to remove it. This is accomplished by utilizing the
    JavaScript `delete` operator, which effectively eliminates the key-value pair
    from the hash table's internal storage.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从计算出的哈希位置检索存储的值对。如果这个值对不是`null`或`undefined`，表明键存在于哈希表中，我们就继续删除它。这是通过使用JavaScript的`delete`运算符来实现的，它有效地从哈希表的内部存储中消除了键值对。
- en: To provide feedback on the operation's success, we return `true` if the removal
    was successful (meaning the key existed and was deleted) and `false` if the key
    was not found in the hash table.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供操作成功与否的反馈，如果删除成功（意味着键存在且已被删除），我们返回`true`；如果键在哈希表中未找到，则返回`false`。
- en: It is worth noting that, as an alternative to using the delete operator, we
    could also assign `null` or `undefined` to the corresponding hash position to
    indicate its vacancy. This approach would still effectively remove the key-value
    association from the hash table while potentially offering a different strategy
    for managing empty slots within the array.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，作为使用删除运算符的替代方案，我们也可以将`null`或`undefined`分配给相应的哈希位置，以表示其空缺。这种方法仍然可以有效地从哈希表中删除键值关联，同时可能提供管理数组中空槽位的不同策略。
- en: Now that the implementation of our class is complete, let's see it in action.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们类的实现已经完成，让我们看看它是如何工作的。
- en: Using the HashTable class
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`HashTable`类
- en: 'Let''s illustrate how our `HashTable` class can be employed to create an email
    address book:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们说明如何使用我们的`HashTable`类来创建一个电子邮件地址簿：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can gain insights into the internal structure of our hash table by inspecting
    the hash codes generated for specific keys. For instance, we can observe the hash
    values calculated for "Gandalf," "John," and "Tyrion" using the hash method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查为特定键生成的哈希码，我们可以深入了解我们哈希表的内部结构。例如，我们可以观察使用哈希方法计算出的"Gandalf"、"John"和"Tyrion"的哈希值：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The resulting hash codes (19, 29, and 16, respectively) reveal how the hash
    table distributes these keys into different positions within its underlying array.
    This distribution is crucial for efficient storage and retrieval of values.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的哈希码（分别是19、29和16）揭示了哈希表如何将这些键分布在其底层数组的不同位置。这种分布对于高效存储和检索值至关重要。
- en: 'The following diagram represents the `HashTable` data structure with these
    values in it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示包含这些值的`HashTable`数据结构：
- en: '![A hash table with three contacts](img/file61.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含三个联系人的哈希表](img/file61.png)'
- en: A hash table with three contacts
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含三个联系人的哈希表
- en: 'Now let''s put our `get` method to the test. By executing the following code,
    we can verify its behavior:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试我们的`get`方法。通过执行以下代码，我们可以验证其行为：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since "Gandalf" is a key that exists within our `HashTable`, the get method
    successfully retrieves and outputs its associated value, "gandalf@email.com".
    However, when we attempt to retrieve a value for "Loiane," a non-existent key,
    the `get` method returns undefined, indicating that the key is not present in
    the hash table.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“Gandalf”是我们`HashTable`中存在的一个键，因此`get`方法成功检索并输出了其关联的值“gandalf@email.com”。然而，当我们尝试检索“Loiane”的值，一个不存在的键时，`get`方法返回`undefined`，表示该键不在哈希表中。
- en: 'Next, let''s remove "Gandalf" from the `HashTable` using the `remove` method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`remove`方法从`HashTable`中移除“Gandalf”：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After removing "Gandalf," calling `hash.get('Gandalf')` now results in `undefined`.
    This confirms that the entry has been successfully deleted, and the key no longer
    exists within the hash table.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除“Gandalf”后，调用`hash.get('Gandalf')`现在结果为`undefined`。这证实了条目已被成功删除，并且该键不再存在于哈希表中。
- en: Occasionally, different keys can result in identical hash values, a phenomenon
    known as a **collision**. Let's delve into how we can effectively manage collisions
    within our hash table.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，不同的键会导致相同的哈希值，这种现象被称为**碰撞**。让我们深入了解如何在我们的哈希表中有效地管理碰撞。
- en: Collisions between keys in a hash table
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希表中的键碰撞
- en: In certain scenarios, distinct keys may produce identical hash values. We refer
    to this phenomenon as a collision, as it leads to attempts to store multiple key-value
    pairs at the same index within the hash table.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，不同的键可能会产生相同的哈希值。我们将这种现象称为碰撞，因为它会导致在哈希表中同一索引处尝试存储多个键值对。
- en: 'For example, let''s review at the following email address book:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回顾以下电子邮件地址簿：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To illustrate the collision concept, let''s examine the output generated by
    evoking the `addressBook.hash` method for each name mentioned:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明碰撞概念，让我们检查每个提到的名字调用`addressBook.hash`方法生成的输出：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that multiple keys share the same hash values:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到多个键共享相同的哈希值：
- en: Nathan and Sargeras both have a hash value of 10.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内森和萨格拉斯都有一个哈希值10。
- en: Jack and Athelstan both have a hash value of 7.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杰克和艾瑟尔斯坦都有一个哈希值7。
- en: Jonathan, Jamie, Sue, and Aethelwulf all share a hash value of 5.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乔纳森、杰米、苏和艾瑟尔乌尔夫都共享一个哈希值5。
- en: 'What happens within the hash table after adding all the contacts? Which values
    are ultimately retained? To answer these questions, let''s introduce a `toString`
    method to inspect the hash table''s contents:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加所有联系人后，哈希表内部发生了什么？哪些值最终被保留？为了回答这些问题，让我们引入一个`toString`方法来检查哈希表的内容：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `toString` method provides a string representation of the hash table's contents.
    Since we cannot directly determine which positions in the underlying array contain
    values, we utilize `Object.keys` to retrieve an array of keys from the `#table`
    object. We then iterate through these keys, constructing a formatted string that
    displays each key-value pair.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString`方法提供了哈希表内容的字符串表示。由于我们无法直接确定底层数组中哪些位置包含值，我们使用`Object.keys`从`#table`对象中检索一个键数组。然后我们遍历这些键，构建一个格式化的字符串，显示每个键值对。'
- en: 'Upon invoking `console.log(hashTable.toString())`, we observe the following
    output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`console.log(hashTable.toString())`后，我们观察到以下输出：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In his example, Jonathan, Jamie, Sue, and Aethelwulf all share the same hash
    value of 5\. Due to the nature of our current hash table implementation, Aethelwulf,
    being the last added, occupies position 5\. The values for Jonathan, Jamie, and
    Sue have been overwritten. Similar overwriting occurs for keys with other colliding
    hash values.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的例子中，乔纳森、杰米、苏和艾瑟尔乌尔夫都共享相同的哈希值5。由于我们当前哈希表实现的性质，作为最后添加的艾瑟尔乌尔夫占据了位置5。乔纳森、杰米和苏的值已被覆盖。具有其他碰撞哈希值的键也会发生类似的覆盖。
- en: Losing values due to collisions is undesirable in a hash table. The purpose
    of this data structure is to preserve all key-value pairs. To address this issue,
    we need collision resolution techniques. There are several approaches, including
    **separate chaining**, **linear probing**, and **double hashing**, we will explore
    the first two in detail.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于碰撞而丢失值在哈希表中是不希望的。这种数据结构的目的在于保留所有键值对。为了解决这个问题，我们需要碰撞解决技术。有几种方法，包括**分离链接**、**线性探测**和**双重哈希**，我们将详细探讨前两种。
- en: Handling collisions with separate chaining technique
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用分离链接技术处理碰撞
- en: Separate chaining is a widely used technique to handle collisions in hash tables.
    Instead of storing a single value at each index (bucket) of the hash table, separate
    chaining allows each bucket to hold a *linked list* (or another similar data structure)
    of values. When a collision occurs (multiple keys hash to the same index), the
    new key-value pair is simply appended to the linked list at that index.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 分离链接是一种广泛用于处理哈希表冲突的技术。在哈希表的每个索引（桶）中，不是存储单个值，分离链接允许每个桶持有值的*链表*（或类似的数据结构）。当发生冲突时（多个键哈希到相同的索引），新的键值对将简单地追加到该索引处的链表中。
- en: 'To visualize this concept, let''s consider the code used for testing in the
    previous section. If we were to apply separate chaining and represent the resulting
    structure diagrammatically, the output would resemble the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化这个概念，让我们考虑上一节中用于测试的代码。如果我们应用分离链接并图示化地表示结果结构，输出将类似于以下内容：
- en: '![A hash table with separate chaining technique](img/file62.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![使用分离链接技术的哈希表](img/file62.png)'
- en: A hash table with separate chaining technique
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分离链接技术的哈希表
- en: In this representation, position 5 would contain a linked list with four elements,
    while positions 7 and 10 would each hold linked lists with two elements. Positions
    4, 8, and 9 would each house linked lists with a single element. This illustrates
    how separate chaining effectively handles collisions by storing multiple key-value
    pairs in linked lists within the same bucket.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种表示中，位置5将包含一个包含四个元素的链表，而位置7和10将各自包含包含两个元素的链表。位置4、8和9将各自包含包含单个元素的链表。这说明了分离链接如何通过在同一个桶中存储多个键值对的链表来有效地处理冲突。
- en: 'There are some advantages of using the separate chaining technique:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分离链接技术有一些优点：
- en: Handles collisions gracefully by not overwriting data when collisions occur.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生冲突时，优雅地处理冲突，不会覆盖数据。
- en: The implementation is relatively straightforward to code compared to other collision
    resolution techniques.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他冲突解决技术相比，该实现相对简单易懂。
- en: Linked lists have dynamic size and can grow as needed, accommodating more collisions
    without requiring a hash table resize.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表具有动态大小，可以根据需要增长，从而可以容纳更多的冲突，而无需对哈希表进行大小调整。
- en: As long as the chains (linked lists) remain relatively short, search, insertion,
    and deletion operations remain efficient (close to *O(1)* in the average case),
    meaning it has satisfactory performance.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要链（链表）保持相对较短，搜索、插入和删除操作仍然高效（平均情况下接近*O(1)*），这意味着它具有令人满意的表现。
- en: 'And as any technique, it also has some drawbacks:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 任何技术一样，它也有一些缺点：
- en: Extra memory overhead as linked lists require additional memory.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表需要额外的内存开销。
- en: In the worst case, if many keys hash to the same index, the linked list could
    become long, impacting performance.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最坏的情况下，如果许多键哈希到相同的索引，链表可能会变得很长，影响性能。
- en: 'To demonstrate the practical application of separate chaining, let''s create
    a new data structure called `HashTableSeparateChaining`. This implementation will
    focus primarily on the put, get, and remove methods, showcasing how separate chaining
    enhances collision handling within a hash table. To implement separate chaining
    in our hash table, we begin with the following code, housed within the `src/08-dictionary-hash/hash-table-separate-chaining.js`
    file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示分离链接的实际应用，让我们创建一个新的数据结构，称为`HashTableSeparateChaining`。这个实现将主要关注put、get和remove方法，展示分离链接如何增强哈希表中的冲突处理。为了在我们的哈希表中实现分离链接，我们从以下代码开始，该代码位于`src/08-dictionary-hash/hash-table-separate-chaining.js`文件中：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This initial code snippet accomplishes two key tasks:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始代码片段完成了两个关键任务：
- en: It imports the `LinkedList` class from another file (`../06-linked-list/linked-list.js`)
    we previously created in *Chapter 6, Linked Lists*.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从另一个文件（`../06-linked-list/linked-list.js`）中导入`LinkedList`类，这是我们之前在*第6章，链表*中创建的。
- en: It also defines the `HashTableSeparateChaining` class, which will encapsulate
    our hash table functionality. The class has a private property `#table`, initialized
    as an empty array. This array will serve as the backbone of our hash table, with
    each element acting as a bucket that can potentially store a linked list of key-value
    pairs.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还定义了`HashTableSeparateChaining`类，该类将封装我们的哈希表功能。该类有一个私有属性`#table`，初始化为空数组。这个数组将作为我们哈希表的主干，每个元素都充当一个桶，可以潜在地存储键值对的链表。
- en: The subsequent steps will involve filling in the core methods (`put`, `get`,
    and `remove`) that leverage linked lists to efficiently handle collisions and
    manage key-value pairs within the hash table.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的步骤将涉及填充核心方法（`put`、`get`和`remove`），这些方法利用链表来有效地处理冲突并在哈希表中管理键值对。
- en: Putting a key and a value with separate chaining technique
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用分离链接技术插入键和值
- en: 'Let''s implement the first method, the put method using the separate chaining
    technique as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现第一个方法，使用分离链接技术实现的`put`方法如下：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The put method in our `HashTableSeparateChaining` class is responsible for inserting
    or updating key-value pairs. Its first step is to validate the input, ensuring
    both the key and value are not `null` or `undefined`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`HashTableSeparateChaining`类的`put`方法负责插入或更新键值对。其第一步是验证输入，确保键和值都不是`null`或`undefined`。
- en: Next, we compute the hash code (index) using the hash function. This index determines
    the bucket where the key-value pair should be stored.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用哈希函数计算哈希码（索引）。这个索引决定了键值对应该存储的桶。
- en: 'We then check if the bucket at the calculated index is empty. If it is, a new
    `LinkedList` is created to store values at this index. This is the core of separate
    chaining: using linked lists to accommodate multiple values that hash to the same
    index.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查计算出的索引处的桶是否为空。如果是空的，则创建一个新的`LinkedList`来存储该索引处的值。这是分离链接法的核心：使用链表来容纳散列到相同索引的多个值。
- en: Finally, the key-value pair, encapsulated as an object `{key, value}`, is appended
    to the linked list at the specified index. If the key already exists in the linked
    list, its associated value is updated. The method returns `true` upon successful
    insertion or update, and `false` if the key or value is invalid.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，键值对，封装为对象`{key, value}`，被追加到指定索引处的链表中。如果链表中已存在该键，则其关联的值将被更新。方法在成功插入或更新后返回`true`，如果键或值无效则返回`false`。
- en: Retrieving a value with separate chaining technique
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用分离链接技术检索值
- en: 'Now, let''s implement the get method to retrieve a value from our `HashTableSeparateChaining`
    class based on a given key:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`get`方法，根据给定的键从我们的`HashTableSeparateChaining`类中检索值：
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this method, we first hash the provided key to determine its corresponding
    index in the hash table. We then access the linked list stored at that index.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先将提供的键哈希，以确定其在哈希表中的对应索引。然后我们访问存储在该索引处的链表。
- en: If there is a linked (`linkedList != null`), we iterate through its elements
    using a `forEach` loop, passing a callback. For each element in the linked list,
    we compare its key property to the input key. If we find a match, we return the
    corresponding value property of that element.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在链表（`linkedList != null`），我们使用`forEach`循环遍历其元素，传递一个回调函数。对于链表中的每个元素，我们比较其键属性与输入键。如果我们找到一个匹配项，我们返回该元素的对应值属性。
- en: If the key is not found within the linked list, or if the linked list at the
    calculated index is empty, the method returns `undefined` to indicate that the
    key was not present in the hash table.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在链表中找不到键，或者计算出的索引处的链表为空，则该方法返回`undefined`，表示键不在哈希表中。
- en: By incorporating the linked list structure and traversal, this `get` method
    effectively handles potential collisions caused by multiple keys hashing to the
    same index, ensuring that we retrieve the correct value even in the presence of
    collisions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合链表结构和遍历，这个`get`方法有效地处理了由多个键散列到相同索引引起的潜在冲突，确保即使在冲突存在的情况下，我们也能检索到正确的值。
- en: The LinkedList forEach method
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`LinkedList`的`forEach`方法'
- en: Since our previous `LinkedList` class lacked a `forEach` method, we will need
    to add it for the efficient traversal required in the `HashTableSeparateChaining`
    class's get method.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前的`LinkedList`类缺少`forEach`方法，我们需要为`HashTableSeparateChaining`类的`get`方法中所需的效率遍历添加它。
- en: 'Here is the implementation of the `forEach` method for the `LinkedList` class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`LinkedList`类的`forEach`方法的实现：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `current` variable keeps track of the current node in the list. It starts
    at the head of the list (`this.#head`). The loop continues as long as there are
    nodes left to process (`current is not null`). In each iteration, the provided
    `callback` function is called, passing the element stored in the current node
    and its index as arguments. The `current` variable is updated to the next node
    in the list, moving the iteration forward.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`current`变量跟踪列表中的当前节点。它从列表的头部（`this.#head`）开始。循环继续，直到处理完所有节点（`current is not
    null`）。在每次迭代中，提供的`callback`函数被调用，传递当前节点存储的元素及其索引作为参数。`current`变量更新为列表中的下一个节点，将迭代向前推进。'
- en: Removing a value with separate chaining technique
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用分离链接技术删除值
- en: Removing a value from the `HashTableSeparateChaining` instance presents a slight
    variation compared to the previous `remove` method we implemented. Due to the
    utilization of linked lists, we now need to specifically target and remove the
    element from the relevant linked list within the hash table.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从`HashTableSeparateChaining`实例中删除值与之前实现的`remove`方法略有不同。由于使用了链表，我们现在需要特别针对并从哈希表中的相关链表中删除元素。
- en: 'Let''s analyze the implementation of the `remove` method:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析`remove`方法的实现：
- en: '[PRE39]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We begin by calculating the hash code (`index`) for the given key, similar to
    the `get` method. It then retrieves the linked list stored at that index. If the
    linked list exists (`linkedList != null`), we define a comparison function (`compareFunction`)
    that will be used to identify the element to be removed. This function compares
    the keys of two objects (`a` and `b`).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算给定键的哈希码（`index`），类似于`get`方法。然后检索存储在该索引处的链表。如果链表存在（`linkedList != null`），我们定义一个比较函数（`compareFunction`），该函数将用于识别要删除的元素。此函数比较两个对象的键（`a`和`b`）。
- en: Next, we use the `indexOf` method of the linked list to find the index of the
    element we want to remove. The `indexOf` method takes the element to search for
    (`{key}`) and the comparison function as arguments. If the element is found, `indexOf`
    returns its index; otherwise, it returns -1.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用链表的`indexOf`方法找到要删除的元素的索引。`indexOf`方法接受要搜索的元素（`{key}`）和比较函数作为参数。如果找到元素，`indexOf`返回其索引；否则，返回-1。
- en: If the element is found (`toBeRemovedIndex >= 0`), we remove it from the linked
    list using the `removeAt` method, which removes the element at the specified index.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到元素（`toBeRemovedIndex >= 0`），我们使用`removeAt`方法从链表中删除它，该方法从指定的索引删除元素。
- en: After removing the element, we check if the linked list is now empty. If it
    is, we set the corresponding bucket in the hash table (`this.#table[index]`) to
    `undefined`, effectively removing the empty linked list. Finally, we return `true`
    to indicate successful removal.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 删除元素后，我们检查链表是否现在为空。如果是，我们将哈希表中的相应桶（`this.#table[index]`）设置为`undefined`，从而有效地删除空链表。最后，我们返回`true`以指示删除成功。
- en: If the key is not found within the linked list, or if the linked list at the
    calculated index is empty, we return `false`, signaling that the key was not present
    in the hash table.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在链表中找不到键，或者计算出的索引处的链表为空，我们返回`false`，表示键不在哈希表中。
- en: By incorporating linked list removal logic, this enhanced `remove` method seamlessly
    integrates with the separate chaining approach, enabling efficient removal of
    key-value pairs even in the presence of collisions. Next, let's delve into a different
    technique to handle collisions.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合链表删除逻辑，这个增强的`remove`方法无缝地与分离链接方法集成，即使在发生冲突的情况下也能有效地删除键值对。接下来，让我们深入了解另一种处理冲突的技术。
- en: Handling collisions with the linear probing technique
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用线性探测技术处理冲突
- en: Linear Probing is another technique to handle collisions in hash tables, differing
    from separate chaining in its approach to storing multiple key-value pairs with
    the same hash code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 线性探测是处理哈希表冲突的另一种技术，其处理存储具有相同哈希码的多个键值对的方法与分离链接不同。
- en: Instead of using linked lists, linear probing directly stores all key-value
    pairs in the hash table array itself. When a collision occurs, linear probing
    sequentially searches for the next available empty slot in the array, starting
    from the original hash index.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 线性探测不是使用链表，而是直接在哈希表数组本身中存储所有键值对。当发生冲突时，线性探测按顺序搜索数组中下一个可用的空槽，从原始哈希索引开始。
- en: 'The following diagram demonstrates this process:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了此过程：
- en: '![A hash table with linear probing technique](img/file63.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![使用线性探测技术的哈希表](img/file63.png)'
- en: A hash table with linear probing technique
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性探测技术的哈希表
- en: Let's consider a scenario where our hash table already contains several values.
    When adding a new key-value pair, we calculate the hash for the new key. If the
    corresponding position in the table is vacant, we can directly insert the value
    at that index. However, if the position is occupied, we initiate a *linear probe*.
    We increment the index by one and check the next position. This process continues
    until we find an available slot or determine that the table is full.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，即我们的哈希表已经包含几个值。当添加一个新的键值对时，我们计算新键的哈希值。如果表中相应位置是空的，我们就可以直接在该索引处插入值。然而，如果位置已被占用，我们则启动*线性探测*。我们将索引加一，并检查下一个位置。这个过程会一直持续，直到我们找到一个空槽位或确定表已满。
- en: Linear probing offers a simple and space-efficient collision resolution mechanism.
    However, it can lead to clustering, where consecutive occupied slots decrease
    performance as the table fills up.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 线性探测提供了一个简单且空间高效的冲突解决机制。然而，它可能导致聚类，随着表的填充，连续占用的槽位会降低性能。
- en: 'To illustrate linear probing in practice, we will develop a new data structure
    called `HashTableLinearProbing`. This class will reside in the `src/08-dictionary-hash/hash-table-linear-probing.js`
    file. We begin by defining the basic structure:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明线性探测的实际应用，我们将开发一个新的数据结构，称为`HashTableLinearProbing`。这个类将位于`src/08-dictionary-hash/hash-table-linear-probing.js`文件中。我们首先定义基本结构：
- en: '[PRE40]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This initial structure mirrors the `HashTable` class, with a private property
    `#table` initialized as an empty array to store key-value pairs. However, we will
    override the `put`, `get`, and `remove` methods to incorporate the linear probing
    technique for collision resolution. This modification will fundamentally alter
    how the hash table handles situations where multiple keys hash to the same index,
    demonstrating a distinct approach compared to separate chaining.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始结构反映了`HashTable`类，有一个私有属性`#table`，初始化为一个空数组以存储键值对。然而，我们将重写`put`、`get`和`remove`方法，以采用线性探测技术来解决冲突。这种修改将从根本上改变哈希表处理多个键哈希到相同索引的情况的方式，与分离链接方法相比，展示了一种独特的方法。
- en: Putting a key and a value with linear probing technique
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用线性探测技术插入键和值
- en: 'Now, let''s implement the first of our three core methods: the `put` method.
    This method is responsible for inserting or updating key-value pairs within the
    hash table, incorporating the linear probing technique for collision resolution:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现我们的三个核心方法中的第一个：`put`方法。该方法负责在哈希表中插入或更新键值对，并采用线性探测技术来解决冲突：
- en: '[PRE41]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We start by ensuring that both the key and value are valid (not `null`). We
    then calculate the hash code for the key, which determines the initial position
    where the value should be stored.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保键和值都是有效的（不是`null`）。然后我们计算键的哈希码，这决定了值应该存储的初始位置。
- en: However, if the initial position is already occupied, the linear probing process
    begins. The method enters a while loop that continues if the current index is
    occupied by a value. Inside the loop, it first checks if the `key` at the current
    index matches the provided `key`. If so, the value is updated, and `true` is returned.
    Otherwise, the index is incremented, and the process wraps around to the beginning
    of the table if necessary, continuing the search for an empty slot.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果初始位置已经被占用，线性探测过程就开始了。该方法进入一个while循环，如果当前索引被一个值占用，则循环继续。在循环内部，它首先检查当前索引的`key`是否与提供的`key`匹配。如果是，则更新值，并返回`true`。否则，索引递增，如果需要，过程会绕回表的开始，继续寻找空槽位。
- en: Once an empty slot is found, the key-value pair is stored at that index, and
    `true` is returned to indicate a successful insertion. If either the key or value
    is invalid, the method returns `false`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到空槽位，键值对就存储在该索引处，并返回`true`以指示成功插入。如果键或值无效，则该方法返回`false`。
- en: In some programming languages, we need to define the size of the array. One
    of the concerns of using linear probing is when the array is out of unoccupied
    positions. When the algorithm reaches the end of the array, it needs to loop back
    to its beginning and continue iterating its elements - and if necessary, we also
    need to create a new bigger array and copy the elements to the new array. In JavaScript,
    we benefit from the dynamic nature of arrays, which can grow automatically as
    needed. Therefore, we do not have to explicitly manage the table's size or worry
    about running out of space. This simplifies our implementation and allows the
    hash table to adapt to the amount of data being stored.
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在某些编程语言中，我们需要定义数组的大小。使用线性探测的一个担忧是当数组没有未占用的位置时。当算法到达数组的末尾时，它需要回到开始并继续迭代其元素——如果需要，我们还需要创建一个更大的数组并将元素复制到新数组中。在JavaScript中，我们得益于数组的动态特性，它可以自动按需增长。因此，我们不需要显式管理表的大小或担心空间不足。这简化了我们的实现，并允许哈希表适应存储的数据量。
- en: 'Let''s simulate the insertion process within our hash table using linear probing
    to handle collisions:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用线性探测来处理冲突，在我们的哈希表中模拟插入过程：
- en: '***Ygritte***: the hash value for "Ygritte" is 4\. Since the hash table is
    initially empty, we can directly insert it at position 4.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***Ygritte***: “Ygritte”的哈希值为4。由于哈希表最初为空，我们可以直接在位置4插入它。'
- en: '***Jonathan***: the hash value is 5, and position 5 is available, so we insert
    "Jonathan" there.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***Jonathan***: 哈希值为5，且位置5是可用的，所以我们将其插入那里。'
- en: '***Jamie***: this also hashes to 5, but position 5 is now occupied. We probe
    to position 6 (5 + 1), which is empty, and insert "Jamie" there.'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***Jamie***: 这也哈希到5，但位置5现在被占用。我们探测到位置6（5 + 1），该位置是空的，所以我们将其插入那里。'
- en: '***Jack***: the hash value is 7, and position 7 is empty, so we insert "Jack"
    without any collisions.'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***Jack***: 哈希值为7，且位置7是空的，所以我们无冲突地插入“Jack”。'
- en: '***Jasmine***: the hash value is 8, and position 8 is available, so "Jasmine"
    is inserted.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***Jasmine***: 哈希值为8，且位置8是可用的，所以“Jasmine”被插入。'
- en: 'Jake: The hash value is 9, and position 9 is open, allowing us to insert "Jake"
    without collision.'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Jake: 哈希值为9，且位置9是开放的，这允许我们无冲突地插入“Jake”。'
- en: '***Nathan***: with a hash value of 10 and an empty position 10, "Nathan" is
    inserted smoothly.'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***Nathan***: 哈希值为10，且位置10是空的，“Nathan”被顺利插入。'
- en: '***Athelstan***: this also hashes to 7, but position 7 is occupied by "Jack."
    We probe linearly to positions 8, 9, 10 (all occupied), and finally insert "Athelstan"
    at the first available position, 11.'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***Athelstan***: 这也哈希到7，但位置7被“Jack”占用。我们线性探测到位置8、9、10（都已被占用），最后在第一个可用位置11插入“Athelstan”。'
- en: '***Sue***: hashing to 5, we find positions 5 through 11 occupied. We continue
    probing and insert "Sue" at position 12.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***Sue***: 将“Sue”哈希到5，我们发现位置5到11已被占用。我们继续探测，并在位置12插入“Sue”。'
- en: '***Aethelwulf***: similarly hashing to 5, we probe past occupied positions
    and insert "Aethelwulf" at position 13.'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***Aethelwulf***: 类似地，哈希到5，我们探测过被占用的位置，并在位置13插入“Aethelwulf”。'
- en: '***Sargeras***: the hash value is 10, and positions 10 to 13 are occupied.
    We probe further and insert "Sargeras" at position 14.'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***Sargeras***: 哈希值为10，位置10到13已被占用。我们进一步探测，并在位置14插入“Sargeras”。'
- en: This simulation highlights how linear probing resolves collisions by systematically
    searching for the next available slot in the hash table array. While effective,
    it is important to note that linear probing can lead to clustering, which can
    potentially impact the performance of subsequent insertions and retrievals.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟突出了线性探测如何通过在哈希表数组中系统地搜索下一个可用槽位来解决冲突。虽然有效，但重要的是要注意，线性探测可能导致聚集，这可能会影响后续插入和检索的性能。
- en: Next, let's review how to retrieve a value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下如何检索一个值。
- en: Retrieving a value with linear probing technique
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用线性探测技术检索值
- en: 'Now that our hash table contains elements, let''s implement the get method
    to retrieve values based on their corresponding keys:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在哈希表包含元素后，让我们实现get方法来根据相应的键检索值：
- en: '[PRE42]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To retrieve a value, we first need to determine its location within the hash
    table. We use the hash function to calculate the initial index for the given key.
    If the key exists within the hash table, its value should be located either at
    the initial index or somewhere further along due to potential collisions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索一个值，我们首先需要确定它在哈希表中的位置。我们使用哈希函数计算给定键的初始索引。如果键存在于哈希表中，其值应位于初始索引或由于潜在的冲突而更远的位置。
- en: If the initial index is not empty (`this.#table[index] != null`), we need to
    verify whether the element at that position matches the key we are searching for.
    If the keys match, we return the corresponding value immediately.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始索引不为空（`this.#table[index] != null`），我们需要验证该位置的元素是否与我们正在搜索的键匹配。如果键匹配，我们立即返回相应的值。
- en: However, if the keys do not match, it is possible that the desired value has
    been displaced due to linear probing. We enter a `while` loop to iterate through
    subsequent positions in the table, incrementing the index and wrapping around
    if necessary. The loop continues until either the key is found, or an empty slot
    is encountered, signaling that the key does not exist.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果键不匹配，由于线性探测，可能已将所需的值移位。我们进入一个 `while` 循环，遍历表中的后续位置，增加索引，并在必要时进行环绕。循环继续，直到找到键或遇到空槽，这表示键不存在。
- en: If, after iterating through the table, the index points to an empty slot (`undefined`
    or `null`), it means the key was not found, and the method returns `undefined`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在遍历表之后，索引指向一个空槽（`undefined` 或 `null`），这意味着未找到键，该方法返回 `undefined`。
- en: Next, let's review how to remove values using the linear probing technique.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾如何使用线性探测技术移除值。
- en: Removing a value with linear probing technique
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用线性探测技术移除值
- en: Removing a value from a hash table using linear probing presents a unique challenge
    compared to other data structures. In linear probing, elements are not necessarily
    stored at the index directly calculated from their hash value due to potential
    collisions. Simply deleting the element at the hash index could disrupt the probing
    sequence and render other elements inaccessible.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性探测从哈希表中移除值与其他数据结构相比，提出了独特的挑战。在线性探测中，由于潜在的冲突，元素不一定存储在直接从其哈希值计算出的索引处。简单地删除哈希索引处的元素可能会破坏探测序列，使其他元素不可访问。
- en: 'To address this, we need a strategy that maintains the integrity of the probe
    sequence while still removing the desired key-value pair. There are two primary
    approaches:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要一种策略，在移除所需的键值对的同时，仍然保持探测序列的完整性。有两种主要的方法：
- en: Soft deletion, also known as tombstone marking.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软删除，也称为墓碑标记。
- en: Hard deletion and rehashing the table.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬删除和重新哈希表。
- en: 'In the soft deletion method, instead of physically removing the element, we
    mark it as *deleted* using a special value (often called a tombstone or flag).
    This value indicates that the slot was previously occupied but is now available
    for reuse. This method is simple to implement, however, this will gradually deteriorate
    the hash table''s efficiency, as searching for key-values will become slower over
    time. This method also requires additional logic to handle tombstones during insertion
    and search operations. The following diagram demonstrates the process of the search
    operation with soft deletion method:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在软删除方法中，我们不是物理删除元素，而是使用特殊值（通常称为墓碑或标志）将其标记为 *已删除*。此值表示该槽位之前被占用，但现在可供重用。此方法易于实现，然而，随着时间的推移，搜索键值将变得缓慢，这会逐渐降低哈希表的效率。此方法还需要额外的逻辑来处理插入和搜索操作中的墓碑。以下图表展示了使用软删除方法的搜索操作过程：
- en: '![Linear probing removal with soft deletion](img/file64.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![使用软删除的线性探测移除](img/file64.png)'
- en: Linear probing removal with soft deletion
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用软删除的线性探测移除
- en: 'The second approach, hard deletion, involves physically removing the deleted
    element and then rehashing all subsequent elements in the probe sequence. This
    ensures that the probe sequence remains intact for future searches. In this method,
    there are no wasted spaces due to tombstones and it maintains an optimal probe
    sequence. However, it can be computationally expensive, especially for large hash
    tables or frequent deletions. This implementation is also more complex than soft
    deletion. When searching for a key, this approach prevents finding an empty spot,
    but if it is necessary to move elements, this means we will need to shift key-values
    within the hash table. The following diagram exemplifies this process:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，硬删除，涉及物理删除已删除的元素，然后重新哈希探测序列中的所有后续元素。这确保了探测序列在未来的搜索中保持完整。在此方法中，由于墓碑而造成的空间浪费不存在，并且它保持了一个最佳的探测序列。然而，它可能计算成本较高，尤其是在大型哈希表或频繁删除的情况下。此实现也比软删除更复杂。在搜索键时，这种方法可以防止找到空位，但如果需要移动元素，这意味着我们将在哈希表中移动键值。以下图表展示了此过程：
- en: '![Linear probing removal with rehashing](img/file65.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![带有重新散列的线性探测删除](img/file65.png)'
- en: Linear probing removal with rehashing
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 带有重新散列的线性探测删除
- en: 'Both approaches have their pros and cons. For this chapter, we will implement
    the second approach (rehashing: move one or more elements to a backward position).
    To check the implementation of the lazy deletion approach (`HashTableLinearProbingLazy`
    class), please refer to the source code of this book. The download link for the
    source code is mentioned in the Preface of the book, or it can also be accessed
    at [http://github.com/loiane/javascript-datastructures-algorithms](http://github.com/loiane/javascript-datastructures-algorithms).'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 两种方法都有其优缺点。对于本章，我们将实现第二种方法（重新散列：将一个或多个元素移动到向后位置）。要检查懒删除方法的实现（`HashTableLinearProbingLazy`类），请参阅本书的源代码。源代码的下载链接在本书的序言中提及，或者也可以在[http://github.com/loiane/javascript-datastructures-algorithms](http://github.com/loiane/javascript-datastructures-algorithms)访问。
- en: Let's see the code for the remove method next.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看删除方法的代码。
- en: Implementing the remove method with rehashing
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现带有重新散列的删除方法
- en: 'The `remove` method in our hash table closely resembles the `get` method but
    with a crucial difference. Instead of simply retrieving the value, it deletes
    the entire key-value pair:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们散列表中的`remove`方法与`get`方法非常相似，但有一个关键的区别。它不是简单地检索值，而是删除整个键值对：
- en: '[PRE43]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the `get` method, upon finding the key, we returned its value. However, in
    `remove`, we use the `delete` operator to eliminate the element from the hash
    table. This could be at the original hash position or a different one due to previous
    collisions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get`方法中，当我们找到键时，我们返回其值。然而，在`remove`中，我们使用`delete`运算符从散列表中删除元素。这可能是在原始散列位置，也可能是因为之前的冲突而位于不同的位置。
- en: 'The challenge arises because we do not know if other elements with the same
    hash value were placed elsewhere due to a collision. If we simply delete the found
    element, we might leave gaps in the probe sequence, leading to errors when searching
    for those displaced elements. To address this, we introduce a helper method, `#verifyRemoveSideEffect`.
    This method is responsible for managing the potential side effects of removing
    an element. Its purpose is to move any collided elements backward in the probe
    sequence to fill the newly created empty spot, ensuring the integrity of the hash
    table''s structure. This process is also known as rehashing:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于我们不知道由于冲突，具有相同散列值的其他元素是否被放置在其他地方。如果我们简单地删除找到的元素，我们可能会在探测序列中留下空隙，导致在搜索这些被替换的元素时出现错误。为了解决这个问题，我们引入了一个辅助方法，`#verifyRemoveSideEffect`。此方法负责管理删除元素可能产生的潜在副作用。其目的是将任何碰撞元素在探测序列中向后移动以填充新创建的空位，确保散列表结构的完整性。这个过程也被称为重新散列：
- en: '[PRE44]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We begin by initializing several variables: the `key` to be removed, the `removedPosition`
    where the key-value pair was located, the `size` of the hash table array, and
    an `index` variable to iterate through the table. The index starts at the position
    immediately after the removed element (`removedPosition + 1`).'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化几个变量：要删除的`key`，键值对所在的`removedPosition`，散列表数组的`size`，以及一个用于遍历表的`index`变量。索引从删除元素后的位置开始（`removedPosition
    + 1`）。
- en: The core of the method lies in a `while` loop that continues as long as there
    are elements in the table to examine. In each iteration, the `key` and its hash
    value are extracted from the element at the current `index`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的核心在于一个`while`循环，只要表中还有要检查的元素，它就会继续。在每次迭代中，从当前`index`处的元素中提取`key`及其散列值。
- en: A crucial condition, `currentHash <= removedPosition`, is then evaluated. This
    checks if the element's original hash value (before linear probing) falls within
    the range of indices from the start of the table up to the `removedPosition`.
    If this condition holds `true`, it implies that the element was originally placed
    further down the probe sequence due to a collision with the removed element. To
    rectify this, the element at the current `index` is moved back to the now-empty
    `removedPosition`. Its original position is then cleared, and the `removedPosition`
    is updated to the current `index`. This ensures that subsequent elements in the
    probe sequence are also considered for repositioning.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后评估一个关键条件，`currentHash <= removedPosition`。这检查元素的原哈希值（在线性探测之前）是否在表的起始索引到 `removedPosition`
    的范围内。如果这个条件为 `true`，则意味着元素最初由于与被移除元素的冲突而被放置在探测序列的更下游。为了纠正这一点，将当前 `index` 处的元素移动回现在为空的
    `removedPosition`。然后清除其原始位置，并将 `removedPosition` 更新为当前 `index`。这确保了探测序列中的后续元素也被考虑进行重新定位。
- en: The process repeats, incrementing the index and wrapping around if the end of
    the table is reached, until all potentially affected elements have been checked
    and repositioned if necessary. By meticulously evaluating the hash values and
    repositioning elements, we guarantee that the probe sequence remains intact after
    a removal, ensuring the continued functionality and efficiency of the hash table.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程重复进行，增加索引，并在达到表尾时回绕，直到检查并必要时重新定位所有可能受影响的元素。通过仔细评估哈希值并重新定位元素，我们保证在移除后探测序列保持完整，确保哈希表的持续功能和效率。
- en: This is a simplified implementation, as we could add validations for edge cases
    and optimize the performance. However, this code demonstrates the core logic of
    how to manage the side effects of removing an element in a hash table with linear
    probing.
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个简化的实现，因为我们本可以添加对边缘情况的验证并优化性能。然而，这段代码展示了如何通过线性探测管理哈希表中删除元素时的副作用的核心逻辑。
- en: Let's simulate the removal of "Jonathan" from the hash table we created earlier
    to demonstrate the process of linear probing with deletion and the subsequent
    side effect verification.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟从我们之前创建的哈希表中移除 "Jonathan" 的过程，以展示线性探测删除和随后副作用验证的过程。
- en: '***Locating and removing Jonathan***: we find "Jonathan" at position 5 (hash
    value 5) and remove it, leaving position 5 empty. Now, we need to assess the side
    effects of this removal.'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***定位和移除 Jonathan***：我们在位置 5（哈希值 5）找到 "Jonathan" 并将其移除，留下位置 5 为空。现在，我们需要评估这次移除的副作用。'
- en: '***Evaluating Jamie***: we move to position 6, where "Jamie" (also with hash
    value 5) is stored. Since Jamie''s hash value is less than or equal to the removed
    position (5), we recognize that Jamie was originally placed here due to a collision.
    We copy Jamie to position 5 and delete the entry at position 6.'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***评估 Jamie***：我们将位置移动到 6，其中存储着 "Jamie"（同样具有哈希值 5）。由于 Jamie 的哈希值小于或等于被移除的位置（5），我们认识到
    Jamie 是由于冲突而最初放置在这里的。我们将 Jamie 复制到位置 5，并删除位置 6 的条目。'
- en: '***Skipping Jack and Jasmine***: we continue to positions 7 and 8, where "Jack"
    (hash value 7) and "Jasmine" (hash value 8) are stored. Since their hash values
    are greater than both the removed position (5) and the current position (6), we
    determine that they were not affected by Jonathan''s removal and should remain
    in their current positions.'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***跳过 Jack 和 Jasmine***：我们继续到位置 7 和 8，其中存储着 "Jack"（哈希值 7）和 "Jasmine"（哈希值 8）。由于它们的哈希值大于被移除的位置（5）和当前的位置（6），我们确定它们没有受到
    Jonathan 移除的影响，应保持在其当前位置。'
- en: We repeat this evaluation for positions 9 through 11, finding no elements that
    need repositioning.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复此评估，从位置 9 到 11，没有发现需要重新定位的元素。
- en: '***Repositioning Sue***: at position 12, we find "Sue" (hash value 5). Since
    the hash value is less than or equal to the removed position (5), we copy Sue
    to position 6 (the originally vacated position) and delete the entry at position
    12.'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***重新定位 Sue***：在位置 12，我们找到 "Sue"（哈希值 5）。由于哈希值小于或等于被移除的位置（5），我们将 Sue 复制到位置 6（最初空出的位置）并删除位置
    12 的条目。'
- en: '***Repositioning Aethelwulf and Sargeras***: we continue this process for positions
    13 and 14, finding that both "Aethelwulf" (hash value 5) and "Sargeras" (hash
    value 10) need to be moved back. Aethelwulf is copied to position 12, and Sargeras
    is copied to position 13.'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***重新定位 Aethelwulf 和 Sargeras***：我们继续对位置 13 和 14 进行此过程，发现 "Aethelwulf"（哈希值
    5）和 "Sargeras"（哈希值 10）都需要被移动回原位。Aethelwulf 被复制到位置 12，Sargeras 被复制到位置 13。'
- en: By following these steps, the remove method, along with the `#verifyRemoveSideEffect`
    helper function, ensures that the removal of "Jonathan" does not leave any gaps
    in the probe sequence. All elements are repositioned as necessary to maintain
    the integrity and searchability of the hash table.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，`remove`方法以及`#verifyRemoveSideEffect`辅助函数确保了移除"Jonathan"不会在探测序列中留下任何空隙。所有元素都根据需要重新定位，以保持哈希表的完整性和可搜索性。
- en: In our examples, we deliberately employed the lose-lose hash function to highlight
    the occurrence of collisions and illustrate the mechanisms for resolving them.
    However, in practical scenarios, it is crucial to utilize more robust hash functions
    to minimize collisions and optimize hash table performance. We will delve into
    better hash function options in the next section.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们故意使用了lose-lose哈希函数来突出碰撞的发生并说明解决碰撞的机制。然而，在实际场景中，使用更健壮的哈希函数来最小化碰撞并优化哈希表性能至关重要。我们将在下一节深入探讨更好的哈希函数选项。
- en: Creating better hash functions
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建更好的哈希函数
- en: A well-designed hash function strikes a balance between performance and collision
    avoidance. It should be fast to calculate for efficient insertion and retrieval
    of elements, while also minimizing the likelihood of collisions, where different
    keys produce the same hash code. While numerous implementations exist online,
    we can also craft our own custom hash function to suit specific needs.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的哈希函数在性能和碰撞避免之间取得平衡。它应该快速计算以实现高效的元素插入和检索，同时最大限度地减少碰撞的可能性，即不同的键产生相同的哈希码。虽然网上有众多实现，我们也可以创建自己的自定义哈希函数以满足特定需求。
- en: 'One alternative to the lose-lose hash function is the `djb2` hash function,
    known for its simplicity and relatively good performance. Here is its implementation:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: lose-lose哈希函数的一个替代方案是`djb2`哈希函数，以其简单性和相对良好的性能而闻名。以下是其实施方法：
- en: '[PRE45]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After transforming the `key` to a string, the key string is split into an array
    of individual characters. The `reduce` method is then employed to iterate over
    these characters, accumulating their ASCII values. Starting with an initial value
    of 5381 (a prime number that is the most common found in this algorithm), the
    reducer multiplies the accumulator by 33 (used as a magical number) and sums the
    result with the ASCII code of each character, effectively generating a sum of
    these codes.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`key`转换为字符串之后，键字符串被分割成一个单独字符的数组。然后使用`reduce`方法遍历这些字符，累积它们的ASCII值。从初始值5381（在这个算法中最常见的素数）开始，累加器乘以33（用作一个神奇数字），然后将结果与每个字符的ASCII码相加，从而有效地生成这些码的总和。
- en: Finally, we will use the remainder of the division of the total by another random
    prime number (1013), greater than the size we think the hash table instance can
    have. In our scenario, let's consider 1000 as the size.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用总数量除以另一个随机素数（1013）的余数，这个素数大于我们认为哈希表实例可能具有的大小。在我们的场景中，让我们将1000作为大小。
- en: 'Let''s revisit the insertion scenario from the linear probing section, but
    this time using the `djb2HashCode` function instead of `loseloseHashCode`. The
    resulting hash codes for the same set of keys would be:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下线性探测部分中的插入场景，但这次使用`djb2HashCode`函数而不是`loseloseHashCode`。对于相同的一组键，生成的哈希码将是：
- en: 807 - Ygritte
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 807 - 伊格丽特
- en: 288 - Jonathan
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 288 - 约翰逊
- en: 962 - Jamie
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 962 - 詹姆斯
- en: 619 - Jack
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 619 - 杰克
- en: 275 - Jasmine
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 275 - 贾丝明
- en: 877 - Jake
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 877 - 杰克
- en: 223 - Nathan
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 223 - 内森
- en: 925 - Athelstan
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 925 - 阿塞尔斯坦
- en: 502 - Sue
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 502 - 苏
- en: 149 - Aethelwulf
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 149 - 埃塞尔沃尔夫
- en: 711 - Sargeras
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 711 - 萨格拉斯
- en: Notably, we observe no collisions in this scenario. This is due to the improved
    distribution of hash values provided by the `djb2HashCode` function compared to
    the simplistic `loseloseHashCode`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其值得注意的是，在这个场景中我们没有观察到任何碰撞。这是由于`djb2HashCode`函数提供的哈希值分布比简单的`loseloseHashCode`函数得到了改进。
- en: While not the absolute best hash function available, `djb2HashCode` is widely
    recognized and recommended within the programming community for its simplicity,
    effectiveness, and relatively good performance in many use cases. Its ability
    to significantly reduce collisions in this example underscores the importance
    of selecting an appropriate hash function for your specific data and application
    requirements.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`djb2HashCode`不是最好的哈希函数，但在编程社区中，由于其简单性、有效性和在许多用例中相对良好的性能，它被广泛认可和推荐。它在这个示例中显著减少碰撞的能力强调了选择适合您特定数据和应用程序需求合适的哈希函数的重要性。
- en: Now that we have a solid grasp of hash tables, let's revisit the concept of
    sets and explore how we can leverage hashing to enhance their implementation and
    create a powerful data structure known as a **hash set**.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对哈希表有了坚实的掌握，让我们回顾集合的概念，并探讨如何利用哈希来增强其实现，创建一个称为**哈希集合**的强大数据结构。
- en: The hash set data structure
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希集合数据结构
- en: A **hash set** is a collection of unique values (no duplicates allowed). It
    combines the characteristics of a mathematical set with the efficiency of hash
    tables. Like hash tables, hash sets use a hash function to calculate a hash code
    for each element (value) we want to store. This hash code determines the index
    (bucket) where the value should be placed in an underlying array.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希集合**是一组唯一的值（不允许重复）。它结合了数学集合的特性与哈希表的效率。像哈希表一样，哈希集合使用哈希函数计算每个我们想要存储的元素（值）的哈希码。这个哈希码决定了值应该放置在底层数组中的索引（桶）。'
- en: 'We can reuse the code we created in this chapter to create the hash set data
    structure as well, but with one important detail: we would need to check for duplicate
    values before the insertion operation.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用本章中创建的代码来创建哈希集合数据结构，但有一个重要的细节：在插入操作之前，我们需要检查重复的值。
- en: The benefits of using hash sets are that it is guaranteed that all values in
    the set are unique. In JavaScript, the native Set class is considered a hash set
    data structure as well. For example, we could use a hash set to store all the
    English words (without their definitions).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希集合的好处是，可以保证集合中的所有值都是唯一的。在 JavaScript 中，原生的 Set 类也被认为是哈希集合数据结构。例如，我们可以使用哈希集合来存储所有英语单词（不包括它们的定义）。
- en: Maps and TypeScript
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Maps 和 TypeScript
- en: Implementing data structures like maps or hash maps in TypeScript can significantly
    benefit from the language's static typing capabilities. By explicitly defining
    types for variables and method parameters, we enhance code clarity, reduce the
    risk of runtime errors, and enable better tooling support.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中实现像映射或哈希映射这样的数据结构可以显著受益于语言静态类型的能力。通过显式定义变量和方法参数的类型，我们增强了代码的清晰度，减少了运行时错误的风险，并使更好的工具支持成为可能。
- en: 'Let''s examine the TypeScript signature for our `HashTable` class:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `HashTable` 类的 TypeScript 签名：
- en: '[PRE46]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this TypeScript implementation, we introduce a generic type parameter `<V>`
    to represent the type of values stored in the hash table. This allows us to create
    hash tables that hold values of any specific type (for example: `HashTable<string>`,
    `HashTable<number>`, and so on). The `table` property is typed as an array of
    the generic type `V[]`, indicating that it stores an array of values of the specified
    type.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 TypeScript 实现中，我们引入了一个泛型类型参数 `<V>` 来表示哈希表中存储的值的类型。这允许我们创建可以存储任何特定类型值的哈希表（例如：`HashTable<string>`，`HashTable<number>`
    等）。`table` 属性被定义为泛型类型 `V[]` 的数组，表示它存储了指定类型的值数组。
- en: 'A significant advantage of using TypeScript becomes evident in the `loseLoseHashCode`
    method. Since the `key` parameter is explicitly typed as a `string`, we no longer
    need to check its type within the method. The type system guarantees that only
    strings will be passed as keys, eliminating the need for redundant checks, and
    streamlining the code:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript 的一个显著优势在 `loseLoseHashCode` 方法中变得明显。由于 `key` 参数被显式地定义为 `string`
    类型，我们不再需要在方法中检查其类型。类型系统保证只有字符串会被作为键传递，消除了冗余检查的需要，并简化了代码：
- en: '[PRE47]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By leveraging TypeScript's type system, we enhance the robustness, maintainability,
    and readability of our hash table implementation, making it easier to reason about
    and work within larger projects.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 TypeScript 的类型系统，我们增强了哈希表实现的健壮性、可维护性和可读性，使其更容易在大项目中推理和工作。
- en: Reviewing the efficiency of maps and hash maps
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查映射和哈希映射的效率
- en: 'Let''s review the efficiency of each method by reviewing the Big O notation
    in terms of time of execution:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过审查每个方法的 Big O 符号来审查其执行时间效率：
- en: '| **Method** | **Dictionary** | **Hash Table** | **Separate Chaining** | **Linear
    Probing** |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **字典** | **哈希表** | **分离链接** | **线性探测** |'
- en: '| `put(key, value)` | *O(1)* | *O(1)* | *O(1)** | *O(1)** |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `put(key, value)` | *O(1)* | *O(1)* | *O(1)** | *O(1)** |'
- en: '| `get(key)` | *O(1)* | *O(1)* | *O(1)** | *O(1)** |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `get(key)` | *O(1)* | *O(1)* | *O(1)** | *O(1)** |'
- en: '| `remove(key)` | *O(1)* | *O(1)* | *O(1)** | *O(1)** |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `remove(key)` | *O(1)* | *O(1)* | *O(1)** | *O(1)** |'
- en: For the `Dictionary` class, all operations are generally *O(1)* in the average
    case due to direct access to the underlying object using the stringified key.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Dictionary`类，由于可以直接通过字符串化的键访问底层对象，平均情况下所有操作通常是*O(1)*。
- en: For the `HashMap` class, similar to the dictionary, all operations are typically
    *O(1)* in the average case, assuming a good hash function. However, it lacks collision
    handling, so collisions will cause data loss or overwrite existing entries.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`HashMap`类，类似于字典，在平均情况下，所有操作通常是*O(1)*，假设有一个好的哈希函数。然而，它缺乏冲突处理，因此冲突会导致数据丢失或覆盖现有条目。
- en: For the `HashTableSeparateChaining`, in the average case, all operations are
    still *O(1)*. Separate chaining effectively handles collisions, so even with some
    collisions, the linked lists at each index are likely to remain short. In the
    worst case (all keys hash to the same index), the performance degrades to *O(n)*
    as you need to traverse the entire linked list.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`HashTableSeparateChaining`，在平均情况下，所有操作仍然是*O(1)*。分离链接法有效地处理了冲突，因此即使有一些冲突，每个索引处的链表也可能会保持较短。在最坏的情况下（所有键都散列到相同的索引），性能下降到*O(n)*，因为你需要遍历整个链表。
- en: Finally, for the `HashTableLinearProbing`, the average case complexity is also
    *O(1)* if the hash table is sparsely populated (low load factor). However, as
    the load factor increases and collisions become more frequent, linear probing
    can lead to clustering, where multiple keys are placed in consecutive slots. This
    can degrade the worst-case performance to *O(n)*.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`HashTableLinearProbing`，如果哈希表稀疏填充（低负载因子），平均情况下的复杂度也是*O(1)*。然而，随着负载因子的增加和冲突变得更加频繁，线性探测可能导致聚集，其中多个键被放置在连续的槽位中。这可能会将最坏情况下的性能降低到*O(n)*。
- en: 'Reviewing the execution time, the quality of the hash function significantly
    affects performance. A good hash function minimizes collisions, keeping performance
    closer to *O(1)*. In often cases, separate chaining tends to handle collisions
    more gracefully than linear probing, especially at higher load factors. In a hash
    table, the **load factor** is a crucial metric that measures how full the table
    is. It is defined as:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 检查执行时间，哈希函数的质量会显著影响性能。一个好的哈希函数最小化冲突，使性能更接近*O(1)*。在许多情况下，分离链接法通常比线性探测更优雅地处理冲突，尤其是在较高的负载因子下。在哈希表中，**负载因子**是一个关键指标，用于衡量表有多满。它定义为：
- en: '*Load Factor = (Number of Elements in the Table) / (Total Number of Buckets)*'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '*负载因子 = （表中元素的数量）/（总桶数）*'
- en: 'Next, let''s review the space complexity of each data structure:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾每种数据结构的空间复杂度：
- en: '| **Data Structure** | **Space Complexity** | **Explanation** |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| **数据结构** | **空间复杂度** | **说明** |'
- en: '| Dictionary | *O(n)* | The space used grows linearly with the number of key-value
    pairs stored. Each pair occupies space in the underlying object. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 字典 | *O(n)* | 使用的空间随着存储的键值对数量线性增长。每个对都占用底层对象的空间。|'
- en: '| HashTable | *O(n)* | The array has a fixed size, but you still need space
    for each stored key-value pair. Unused slots also consume space, especially if
    there are few collisions. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| 哈希表 | *O(n)* | 数组的大小是固定的，但你仍然需要为每个存储的键值对留出空间。未使用的槽位也会消耗空间，特别是如果冲突很少的话。|'
- en: '| Separate Chaining | *O(n + m)* | *n* is the number of elements, and *m* is
    the number of buckets. In addition to the space for elements, each bucket holds
    a linked list, which adds memory overhead. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 分离链接 | *O(n + m)* | *n*是元素的数量，*m*是桶的数量。除了元素的空间外，每个桶还持有链表，这增加了内存开销。|'
- en: '| Linear Probing | *O(n)* | Similar to the simple hash table, but linear probing
    tends to use space more efficiently than separate chaining as there are no linked
    lists. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 线性探测 | *O(n)* | 与简单的哈希表类似，但线性探测通常比分离链接法更有效地使用空间，因为没有链表。|'
- en: Which data structure should we use?
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用哪种数据结构？
- en: 'If we store 100 elements in a hash table with 150 buckets:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在有150个桶的哈希表中存储100个元素：
- en: '***Dictionary***: space usage is proportional to 100 elements.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***字典***：空间使用与100个元素成比例。'
- en: '***HashTable*** (no collision handling): space usage is still for 100 elements,
    plus potentially wasted space in the remaining 50 empty buckets.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***哈希表***（没有冲突处理）：空间使用仍然是100个元素，加上剩余50个空桶中可能浪费的空间。'
- en: '***HashTableSeparateChaining***: space usage is for 100 elements, plus the
    overhead of the linked lists in each bucket (which could vary depending on how
    many collisions there are).'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***HashTableSeparateChaining***：空间使用是100个元素，加上每个桶中链表的额外开销（这可能会根据冲突的数量而变化）。'
- en: '***HashTableLinearProbing***: space usage is likely closer to 100 elements,
    as it tries to fill the array more densely.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***HashTableLinearProbing***：空间使用可能接近 100 个元素，因为它试图更密集地填充数组。'
- en: At the end of the day, it all depends on the scenario we are working with.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 到最后，一切都取决于我们正在处理的场景。
- en: Let's put our knowledge into practice with some exercises.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些练习来将我们的知识付诸实践。
- en: Exercises
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: We will resolve one exercise from **LeetCode** using the map data structure
    to transform integer numbers to roman numbers.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用映射数据结构从整数数字转换成罗马数字，来解决来自 **LeetCode** 的一个练习。
- en: 'However, there are many fun exercises available in LeetCode that we should
    be able to resolve with the concepts we learned in this chapter. Below are some
    additional suggestions you can try to resolve, and you can also find the solution
    along with the explanation within the source code from this book:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，LeetCode 上有许多有趣的练习，我们应该能够用我们在本章中学到的概念来解决它们。以下是一些额外的建议，你可以尝试解决，你还可以在本书的源代码中找到解决方案及其解释：
- en: '1\. Two Sum: given an array of integers, find two numbers that add up to a
    target sum. This is a classic problem that introduces you to using a hash map
    to store complements and quickly find matches.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1. 两数之和：给定一个整数数组，找到两个数，它们的和等于目标总和。这是一个经典问题，它介绍了如何使用哈希表存储补数并快速找到匹配项。
- en: '242\. Valid Anagram: determine if two strings are anagrams of each other (contain
    the same characters but in a different order). Hash maps are useful for counting
    character frequencies.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 242. 有效的字母异位词：确定两个字符串是否是彼此的字母异位词（包含相同的字符，但顺序不同）。哈希表对于计数字符频率很有用。
- en: '705\. Design HashSet: implement the hash set data structure.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 705. 设计 HashSet：实现哈希集合数据结构。
- en: '706\. Design HashMap: implement the hash map data structure.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 706. 设计 HashMap：实现哈希映射数据结构。
- en: '13\. Roman to Integer: similar to the problem we will resolve, but the other
    way around.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13. 罗马数字转整数：与我们将要解决的问题类似，但方向相反。
- en: Integer to Roman
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数转罗马数字
- en: The exercise we will resolve the is the *12\. Integer to Roman* problem available
    at [https://leetcode.com/problems/integer-to-roman/description/](https://leetcode.com/problems/integer-to-roman/description/).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解决的练习是位于 [https://leetcode.com/problems/integer-to-roman/description/](https://leetcode.com/problems/integer-to-roman/description/)
    的 *12. 整数转罗马数字* 问题。
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function function intToRoman(num: number): string, which
    receives a numerical input and returns its corresponding Roman numeral representation
    as a string.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用 JavaScript 或 TypeScript 解决这个问题时，我们需要在函数 `intToRoman(num: number): string`
    中添加我们的逻辑，该函数接收一个数值输入并返回其对应的罗马数字表示字符串。'
- en: 'Let''s explore a solution using a map data structure to facilitate the conversion
    process:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用映射数据结构来简化转换过程的一个解决方案：
- en: '[PRE48]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At the heart of this function lies the `romanMap`, which acts as a dictionary,
    associating Roman numeral symbols with their corresponding integer values. This
    map includes both standard Roman numerals (M, D, C) and special combinations for
    subtraction (CM, XC). The arrangement of keys in descending order of value is
    crucial for the greedy algorithm employed in the conversion process so we do not
    need to sort the data structure before the conversion process.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的核心是 `romanMap`，它作为一个字典，将罗马数字符号与它们对应的整数值关联起来。这个映射包括标准的罗马数字（M, D, C）和用于减法的特殊组合（CM,
    XC）。在转换过程中，键按值降序排列对于使用的贪婪算法至关重要，因此我们不需要在转换过程之前对数据结构进行排序。
- en: Next, we initialize an empty string, `result`, to accumulate the Roman numeral
    characters. It then enters a loop that iterates through the keys of the `romanMap`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化一个空字符串，`result`，用于累积罗马数字字符。然后它进入一个循环，遍历 `romanMap` 的键。
- en: Within the loop, a nested `while` loop repeatedly checks if the input number
    (`num`) is greater than or equal to the integer value of the current Roman numeral.
    If so, the Roman numeral is appended to the `result` string, and its integer value
    is subtracted from `num`. This process continues until `num` becomes smaller than
    the value of the Roman numeral, indicating that we need to move on to the next
    smaller numeral in the map.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，一个嵌套的 `while` 循环会反复检查输入的数字 (`num`) 是否大于或等于当前罗马数字的整数值。如果是，则将罗马数字追加到 `result`
    字符串中，并从 `num` 中减去其整数值。这个过程会一直持续到 `num` 变得小于罗马数字的值，这表明我们需要移动到映射中下一个更小的罗马数字。
- en: By iteratively selecting the largest possible Roman numeral that fits the remaining
    input value, the function constructs the Roman numeral representation in a *greedy*
    manner. Once the entire `romanMap` has been traversed, the function returns the
    completed result string, which now holds the accurate Roman numeral equivalent
    of the original input integer.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代选择可以适应剩余输入值的最大可能罗马数字，该函数以*贪婪*的方式构建罗马数字表示。一旦遍历完整个`romanMap`，函数将返回完成的字符串结果，此时它现在包含了原始输入整数的准确罗马数字等价物。
- en: The time complexity of this function is *O(1)*. It iterates over a fixed set
    of Roman numeral symbols (13 symbols in total). For each symbol, it performs a
    series of subtractions and concatenations. The number of operations is bounded
    by the number of symbols and the maximum value of the input number, but since
    the set of symbols and their values are constant, the operations do not scale
    with the input size.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的时间复杂度是*O(1)*。它遍历一组固定的罗马数字符号（总共13个符号）。对于每个符号，它执行一系列的减法和连接操作。操作次数受符号数量和输入数字最大值的限制，但由于符号及其值是固定的，操作不会随着输入大小的增加而扩展。
- en: 'The space complexity is also *O(1)*. The `romanMap` object is a constant and
    its size does not change with the input, so it contributes a constant space overhead.
    The result string grows based on the number of Roman numeral characters needed
    to represent the input number. However, since the maximum number of characters
    needed to represent any integer in Roman numerals is fixed (for example: 3999
    is MMMCMXCIX), this also contributes a constant space overhead. No additional
    data structures are used that scale with the input size.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度也是*O(1)*。`romanMap`对象是一个常量，其大小不会随着输入而改变，因此它贡献了一个常量空间开销。结果字符串的大小基于表示输入数字所需的罗马数字字符数量。然而，由于表示任何整数所需的罗马数字字符的最大数量是固定的（例如：3999是MMMCMXCIX），这也贡献了一个常量空间开销。没有使用与输入大小成比例扩展的额外数据结构。
- en: We could also use the native `Map` class to store the `romanMap` key-value pairs,
    however, in the `for` loop, we would need to extract they keys and sort them first.
    The `Map` class does not guarantee the order of keys, so we would need to extract
    and sort the keys before iterating, which adds overhead. So, in this case, the
    simplest data structure works in our favour for a more performant solution.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用原生的`Map`类来存储`romanMap`键值对，然而，在`for`循环中，我们需要首先提取键并对其进行排序。`Map`类不保证键的顺序，因此我们需要在迭代之前提取和排序键，这会增加开销。所以，在这种情况下，最简单的数据结构在我们的解决方案中更有效。
- en: Summary
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored the world of dictionaries, mastering the techniques
    to add, remove, and retrieve elements, while also understanding how they differ
    from sets. We delved into the concept of hashing, learning how to construct hash
    tables (or hash maps) and implement fundamental operations like insertion, deletion,
    and retrieval. Moreover, we learned how to craft hash functions and examined two
    distinct techniques for handling collisions: separate chaining and linear probing.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了字典的世界，掌握了添加、删除和检索元素的技术，同时了解了它们与集合的不同之处。我们深入研究了哈希的概念，学习了如何构建哈希表（或哈希映射）以及实现插入、删除和检索等基本操作。此外，我们还学习了如何构造哈希函数，并考察了处理冲突的两种不同技术：分离链接和线性探测。
- en: We also explored JavaScript's built-in `Map` class, as well as the specialized
    `WeakMap` and `WeakSet` classes, which offer unique capabilities for memory management.
    Through a variety of practical examples and a LeetCode exercise, we solidified
    our understanding of these data structures and their applications.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了JavaScript的内置`Map`类，以及专门的`WeakMap`和`WeakSet`类，它们为内存管理提供了独特的功能。通过各种实际示例和LeetCode练习，我们巩固了对这些数据结构和它们应用的理解。
- en: 'Equipped with this knowledge, we are now prepared to tackle the concept of
    **recursion** in the next chapter, paving the way for our exploration of another
    essential data structure: **trees**.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们现在准备迎接下一章中**递归**的概念，为探索另一个基本的数据结构：**树**铺平道路。
