- en: Click-Click Boom! Applying Interactivity to Your Map
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击-点击-爆炸！将交互性应用到你的地图上
- en: In the previous chapter, you learned what is needed to build a basic map with
    D3.js. We also discussed the concepts of enter, update, and exit and how they
    apply to maps. You should also understand how D3 mixes and matches HTML with data.
    However, let's say you want to take it a step further and add more interactivity
    to your map. We covered only the tip of the iceberg regarding click events in
    the previous chapter. Now, it's time to dig deeper.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用 D3.js 构建基本地图所需的内容。我们还讨论了 enter、update 和 exit 的概念以及它们如何应用于地图。你也应该理解
    D3 如何将 HTML 与数据混合匹配。然而，假设你想更进一步，给你的地图添加更多交互性。在上一章中，我们只触及了冰山一角，关于点击事件。现在，是时候深入挖掘了。
- en: 'In this chapter, we will expand our knowledge of events and event types. We
    will progress by experimenting and building upon what you''ve learned. The following
    topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展我们对事件和事件类型的知识。我们将通过实验和构建你所学的内容来逐步前进。本章涵盖了以下主题：
- en: Events and how they occur
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件及其发生方式
- en: Experiment 1 - hover events and tooltips
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 1 - 悬停事件和工具提示
- en: Experiment 2 - tooltips with visualizations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 2 - 带有可视化的工具提示
- en: Experiment 3 - panning and zooming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 3 - 平移和缩放
- en: Experiment 4 - orthographic projections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 4 - 正射投影
- en: Experiment 5 - rotating orthographic projections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 5 - 旋转正射投影
- en: Experiment 6 - dragging orthographic projections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 6 - 拖动正射投影
- en: Events and how they occur
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件及其发生方式
- en: 'The following is taken directly from the w3 specifications:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容直接来自 w3 规范：
- en: '"The Event interface is used to provide contextual information about an event
    to the handler processing the event. An object that implements the Event interface
    is generally passed as the first parameter to an event handler. More specific
    context information is passed to event handlers by deriving additional interfaces
    from Event which contain information directly relating to the type of event they
    accompany. These derived interfaces are also implemented by the object passed
    to the event listener."'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “事件接口用于向处理事件的处理器提供关于事件的上下文信息。实现事件接口的对象通常作为事件处理器的第一个参数传递。通过从事件派生出包含与伴随事件类型直接相关的信息的额外接口，可以更具体地传递上下文信息到事件处理器。这些派生接口也由传递给事件监听器的对象实现。”
- en: 'In other words, an event is a user input action that takes place in the browser.
    If your user clicks, touches, drags, or rotates, an event will fire. If you have
    event listeners registered to those particular events, the listeners will catch
    the event and determine the event type. The listeners will also expose properties
    associated with the event. For example, if we want to add an event listener in
    plain JavaScript, we would add the following lines of code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，事件是在浏览器中发生的用户输入动作。如果你的用户点击、触摸、拖动或旋转，就会触发一个事件。如果你为这些特定事件注册了事件监听器，监听器将捕获事件并确定事件类型。监听器还将公开与事件相关的属性。例如，如果我们想在纯
    JavaScript 中添加事件监听器，我们会添加以下几行代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that you first need to have the button in the DOM in order to get its ID.
    Once you have it, you can simply add an event listener to listen to the element's
    click event. The event listener will catch the click event every time it fires
    and logs `Hello world` to the console.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你首先需要在 DOM 中有按钮，以便获取其 ID。一旦你有了它，你就可以简单地添加一个事件监听器来监听元素的点击事件。每当点击事件触发时，事件监听器都会捕获点击事件并将“Hello
    world”记录到控制台。
- en: Until jQuery, events were very tricky, and different browsers had different
    ways of catching these events. However, thankfully, this is all in the past. Now,
    we live in a world where modern browsers are more consistent with event handling.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jQuery 之前，事件处理非常复杂，不同的浏览器有不同的捕获这些事件的方式。然而，幸运的是，这些都已成为过去。现在，我们生活在一个现代浏览器在事件处理上更加一致的世界。
- en: In the world of D3, you won't have to worry about this. Generating events, catching
    them, and reacting to them is baked into the library and works across all browsers.
    A good example of this is the hover event.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 D3 的世界中，你不必担心这个问题。生成事件、捕获它们和响应它们是库内置的，并且可以在所有浏览器中工作。一个很好的例子是悬停事件。
- en: Experiment 1 – hover events and tooltips
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 1 – 悬停事件和工具提示
- en: 'Building on our previous example, we can easily swap our `click` method with
    a `hover` method. Instead of having `var click`, we will now have `var hover`
    with the corresponding function. Feel free to open `example-1.html` of the `chapter-5`
    code base to go over the complete example (`http://localhost:8080/chapter-5/example-1.html`).
    Let''s review the necessary code to change our click event to a hover event. In
    this particular case, we will need a little more CSS and HTML. In our `<style>`
    tag, add the following lines:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在先前的示例之上，我们可以轻松地将我们的`click`方法与`hover`方法交换。不再有`var click`，我们现在将拥有`var hover`以及相应的函数。请随意打开`chapter-5`代码库中的`example-1.html`来查看完整的示例（`http://localhost:8080/chapter-5/example-1.html`）。让我们回顾一下将我们的点击事件更改为悬停事件的必要代码。在这种情况下，我们需要更多的CSS和HTML。在我们的`<style>`标签中，添加以下行：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This style is for a basic tooltip. It is positioned **absolutely** so that
    it can take whatever *x* and *y* coordinates we give it (left and top). It also
    has some filler styles for the fonts and colors. The `tooltip` is styled to the
    element in the DOM that has the ID of `#tooltip`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此样式适用于基本工具提示。它被绝对定位，以便它可以接受我们给出的任何*x*和*y*坐标（左和顶）。它还有一些填充样式用于字体和颜色。`tooltip`被样式化为DOM中具有ID为`#tooltip`的元素：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we add the logic to handle a `hover` event when it is fired:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加处理悬停事件的逻辑：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function, aside from logging the event, will find the DOM element with
    an ID of `tooltip` and position it at the *x* and *y* coordinates of the event.
    These coordinates are a part of the properties of the event and are named `pageX`
    and `pageY`, respectively. Next, we will insert text with the state name (`d.properties.NAME_1`)
    into the `tooltip`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数除了记录事件外，还将找到具有ID为`tooltip`的DOM元素，并将其定位在事件的*x*和*y*坐标上。这些坐标是事件属性的一部分，分别命名为`pageX`和`pageY`。接下来，我们将插入包含状态名称（`d.properties.NAME_1`）的文本到`tooltip`中：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, we will change our binding from a click to a `mouseover` event in the
    on section of the code. We will also change the event handler to the `hover` function
    we created earlier.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更改代码中的绑定，从点击事件更改为`mouseover`事件。我们还将将事件处理程序更改为我们之前创建的`hover`函数。
- en: 'Once the changes have been saved and viewed, you should notice basic tooltips
    on your map:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并查看更改后，你应该会在地图上注意到基本的工具提示：
- en: '![](img/e2101ebd-e276-43e9-848e-064c471387c3.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2101ebd-e276-43e9-848e-064c471387c3.png)'
- en: Experiment 2 – tooltips with visualizations
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验2 – 带有可视化的工具提示
- en: In this next experiment, we will enhance our tooltips with additional visualizations.
    In a similar fashion, we will outline the additional code to provide this functionality
    (`http://localhost:8080/chapter-5/example-2.html`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的实验中，我们将通过额外的可视化增强我们的工具提示。以类似的方式，我们将概述额外的代码以提供此功能（`http://localhost:8080/chapter-5/example-2.html`）。
- en: 'To our CSS, we will need to add the following lines of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的CSS中添加以下代码行：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will style our SVG container (inside our tooltip DOM element) to align
    it with the label of the state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的SVG容器（在我们的tooltip DOM元素内部）与州的标签对齐。
- en: 'Next, we''ll include two new scripts to create visualizations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将包含两个新的脚本以创建可视化：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding JavaScript files contain the D3 code for creating a line chart
    visualization. The chart itself contains and leverages the *Towards* *Reusable
    Chart* described by Mike Bostock at: [http://bost.ocks.org/mike/chart/](http://bost.ocks.org/mike/chart/).
    Feel free to examine the code; it is a very simple visualization that follows
    the enter, update, and exit pattern. We will explore this chart further in [Chapter
    7](ded15f0d-44ff-4b2d-a2ac-ecbba7d5dd63.xhtml), *Testing*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述JavaScript文件包含创建折线图可视化的D3代码。图表本身包含并利用了Mike Bostock所描述的*可重用图表*：[http://bost.ocks.org/mike/chart/](http://bost.ocks.org/mike/chart/)。请随意检查代码；这是一个非常简单的可视化，遵循进入、更新和退出的模式。我们将在[第7章](ded15f0d-44ff-4b2d-a2ac-ecbba7d5dd63.xhtml)中进一步探讨此图表，*测试*：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will now declare two new variables. The `db` variable will hold a hashmap
    to quickly lookup values by `geoID`. The `sparkline` variable is the function
    that will draw our simple line chart:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将声明两个新变量。`db`变量将包含一个hashmap，以便可以通过`geoID`快速查找值。`sparkline`变量是绘制我们的简单折线图的函数：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function parses data and formats it into a structure that the `sparkline`
    function can use to create the line chart:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数解析数据并将其格式化为`sparkline`函数可以使用的结构，以创建折线图：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will bring back our `geoID` function from [Chapter 4](c22382c6-84d9-411f-b795-681df2321005.xhtml),
    *Creating a Map*, in order to quickly create unique IDs for each state:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把来自 [第 4 章](c22382c6-84d9-411f-b795-681df2321005.xhtml)，*创建地图*，的 `geoID`
    函数重新引入，以便为每个州快速创建唯一的 ID：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For our hover event handler, we need to add two new lines. First, we will declare
    an ID variable that holds the unique `geoID` for the state we are hovering over.
    Then, we will call our `sparkline` function to draw a line chart in the `tooltip`
    selection. The data is retrieved from the preceding `db` variable. For more information
    on how the call works, refer to: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的悬停事件处理程序，我们需要添加两行新代码。首先，我们将声明一个 ID 变量，它持有我们悬停的州的唯一 `geoID`。然后，我们将调用我们的
    `sparkline` 函数在 `tooltip` 选择中绘制折线图。数据是从前面的 `db` 变量中检索的。有关调用工作方式的更多信息，请参阅：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We load our `.csv` file via AJAX and invoke the `setDb()` function (described
    earlier).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 AJAX 加载我们的 `.csv` 文件，并调用前面描述的 `setDb()` 函数。
- en: 'You should now see a map that displays a `tooltip` with a line chart for every
    state in Mexico. In summary:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到一个显示每个墨西哥州带有折线图的 `tooltip` 的地图。总之：
- en: The map is drawn as usual.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地图按常规绘制。
- en: We will create a small lookup `db` that contains additional data about each
    state.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个小的查找 `db`，其中包含关于每个州的额外数据。
- en: Then, we will register a hover event that fires whenever the user's mouse passes
    over a state.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将注册一个悬停事件，当用户的鼠标悬停在某个州上时，该事件将被触发。
- en: The hover event fires and retrieves data about the state.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 悬停事件被触发并检索关于该州的数据。
- en: The hover event also places the name of the state in the DOM and calls a function
    that creates a line chart with the retrieved data:![](img/2f2788b5-1820-4e55-b32f-d3465e138d29.png)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 悬停事件还将州名放入 DOM 中，并调用一个函数来使用检索到的数据创建一个折线图：![img/2f2788b5-1820-4e55-b32f-d3465e138d29.png]
- en: Experiment 3 – panning and zooming
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 3 – 平移和缩放
- en: A very common request when working with maps is to provide the ability to pan
    and zoom around the visualization. This is especially useful when a large map
    contains abundant detail. Luckily, D3 provides an event listener to help with
    this feature. In this experiment, we will outline the principles to provide basic
    panning and zooming for your map. This experiment requires us to start with `example-1.html`;
    however, feel free to look at `http://localhost:8080/chapter-5/example-3.html`
    for reference.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理地图时，一个非常常见的请求是提供在可视化周围平移和缩放的能力。当一个大地图包含大量细节时，这尤其有用。幸运的是，D3 提供了一个事件监听器来帮助实现此功能。在本实验中，我们将概述为您的地图提供基本平移和缩放原理。本实验需要我们从
    `example-1.html` 开始；然而，您可以自由地查看 `http://localhost:8080/chapter-5/example-3.html`
    以获取参考。
- en: 'First, we will add a simple CSS class in our `<style>` section; this class
    will act as a rectangle over the entire map. This will be our zoomable area:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在 `<style>` 部分添加一个简单的 CSS 类；这个类将在整个地图上作为矩形。这将是我们可缩放的区域：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we need to define a function to handle the event when the zoom listener
    is fired. The following function can be placed right below the map declaration:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个函数来处理缩放监听器触发的事件。以下函数可以放在地图声明下方：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function takes advantage of two variables exposed while panning and zooming:
    `d3.event.scale` and `d3.event.translate`. The variables are defined as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数利用了在平移和缩放时暴露的两个变量：`d3.event.scale` 和 `d3.event.translate`。这些变量定义如下：
- en: '`d3.event.scale`: This defines the zoom level in terms of an SVG scale.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.event.scale`：这定义了以 SVG 缩放级别为单位的缩放级别。'
- en: '`d3.event.translate`: This defines the position of the map in relation to the
    mouse in terms of an SVG translate.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.event.translate`：这定义了地图相对于鼠标的位置，以 SVG 平移为单位。'
- en: 'With this information available, we can set the SVG attributes (scale and translate)
    of the map container to the event variables:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得这些信息后，我们可以将地图容器的 SVG 属性（缩放和平移）设置为事件变量：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similar to the hover event listener, we need to create a new zoom event listener.
    Create the preceding function after the `zoom()` function. Note that there is
    one additional setting to understand, `scaleExtent()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与悬停事件监听器类似，我们需要创建一个新的缩放事件监听器。在 `zoom()` 函数之后创建前面的函数。请注意，有一个额外的设置需要理解，即 `scaleExtent()`。
- en: The `scaleExtent()` setting provides a scale range of the zooming amount. The
    first element in the array is the maximum that the map can zoom out. The second
    element in the array is the maximum that the map can zoom in. Remember that `1`
    is the original size of our map based on our bounding-box formula from [Chapter
    4](c22382c6-84d9-411f-b795-681df2321005.xhtml), *Creating a Map*. The minimum
    value that `scaleExtent()` can be set to is `0`, to zoom out. In `example-3.html`,
    alter these numbers to get a feel of how they work. For example, if you change
    `1` to `5`, you will see that the map can zoom out to half its original size.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`scaleExtent()` 设置提供了缩放量的缩放范围。数组中的第一个元素是地图可以缩放到的最大范围。数组中的第二个元素是地图可以缩放到最大的范围。记住，`1`
    是基于我们来自 [第 4 章](c22382c6-84d9-411f-b795-681df2321005.xhtml)，*创建地图* 的边界框公式的地图原始大小。`scaleExtent()`
    可以设置为的最小值是 `0`，用于缩放。在 `example-3.html` 中，改变这些数字以了解它们的工作方式。例如，如果你将 `1` 改为 `5`，你会看到地图可以缩放到其原始大小的一半。'
- en: 'There are additional settings to this event listener that can be reviewed at: [https://github.com/mbostock/d3/wiki/Zoom-Behavior](https://github.com/mbostock/d3/wiki/Zoom-Behavior):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下位置可以查看此事件监听器的附加设置：[https://github.com/mbostock/d3/wiki/Zoom-Behavior](https://github.com/mbostock/d3/wiki/Zoom-Behavior)：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, right after the `mexico.exit` section, we will add a transparent rectangle
    to the entire visualization and bind the new listener. Remember that the rectangle
    is using the CSS class we defined at the beginning of the experiment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `mexico.exit` 部分之后，我们将在整个可视化中添加一个透明的矩形并绑定新的监听器。记住，这个矩形使用我们在实验开始时定义的 CSS
    类。
- en: 'Now, you should have full zooming and panning capabilities on the Mexican map.
    You can either double-click to zoom in or use your scroll wheel. The interactions
    should also work for swipe and pinch gestures on a tablet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在墨西哥地图上拥有完整的缩放和平移功能。你可以双击来缩放或使用鼠标滚轮。这些交互也应该适用于平板电脑上的滑动和捏合手势：
- en: '![](img/644dc9cc-0d9f-452e-95b3-64cea8a3e087.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/644dc9cc-0d9f-452e-95b3-64cea8a3e087.png)'
- en: Experiment 4 – orthographic projections
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 4 – 正射投影
- en: 'For the next set of experiments in this chapter, we will switch gears and look
    at interactivity with orthographic projections (representing a three-dimensional
    map on a two-dimensional screen). A better visualization to illustrate these concepts
    is the entire globe instead of a single country. This experiment will start with
    `http://localhost:8080/chapter-5/example-4.html` and require a new datafile, which
    is provided for you. You will notice that the code base is almost identical, with
    the exception of three changes that we will outline here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章接下来的实验，我们将转换方向，查看正射投影（在二维屏幕上表示三维地图）的交互性。为了更好地说明这些概念，整个地球比单个国家是一个更好的可视化。这个实验将从
    `http://localhost:8080/chapter-5/example-4.html` 开始，并需要一个新数据文件，它已经为你提供了。你会注意到代码库几乎相同，除了以下三个我们将概述的更改：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we will change our `d3.geo` projection from `d3.geo.mercator` to `d3.geo.orthographic`.
    We also have an additional setting to configure: the `clipAngle` at `90` degrees.
    This places an imaginary plane through the globe and clips the back of the projection:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将我们的 `d3.geo` 投影从 `d3.geo.mercator` 更改为 `d3.geo.orthographic`。我们还有一个额外的设置来配置：`clipAngle`
    为 `90` 度。这将在地球中放置一个假想的平面并裁剪投影的背面：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we will substitute the old `geo-data.json` file for the new datafile,
    `world.json`. We will also set up new variables for our data joining in order
    to provide better readability in the code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将用新的数据文件 `world.json` 替换旧的 `geo-data.json` 文件。我们还将为我们的数据连接设置新的变量，以便在代码中提供更好的可读性：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we have seen many times now, we will apply the standard `enter()` pattern.
    You should now have a static map of the globe, as seen in the following screenshot.
    You can also work directly with `example-4.html`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见多次，我们将应用标准的 `enter()` 模式。你现在应该有一个静态的地球地图，如下面的截图所示。你也可以直接使用 `example-4.html`。
- en: In the last two sections, we will bring the globe to life!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两节中，我们将使地球变得生动起来！
- en: '![](img/36a69fdf-fade-4ec3-94f7-c3e6690a03e8.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36a69fdf-fade-4ec3-94f7-c3e6690a03e8.png)'
- en: Experiment 5 – rotating orthographic projections
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 5 – 旋转正射投影
- en: 'Our previous example was very fascinating. We went from visualizing a map in
    two dimensions to three dimensions with just a few lines. The next step is to
    animate it. For this experiment, open `http://localhost:8080/chapter-5/example-5.html`
    in the code samples. Let''s now piece it together:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的例子非常引人入胜。我们只用了几行代码，就从二维地图的可视化转换到了三维。下一步是动画化它。对于这个实验，请在代码示例中打开`http://localhost:8080/chapter-5/example-5.html`。现在让我们把它拼凑起来：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We added an index variable that will hold the rotation rate. Don''t worry;
    we''ll explain how this is used here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个索引变量来保存旋转速率。别担心，我们将在这里解释它是如何使用的：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As Mexico is the center of the universe and requires special attention, we
    isolated it into its own variable by taking the corresponding feature from the
    countries'' feature array. This will allow us to manipulate it separately from
    the rest of the globe:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于墨西哥是宇宙的中心，需要特别注意，我们通过从国家的特征数组中提取相应的特征将其隔离到自己的变量中。这将允许我们单独操作它，而不影响地球的其他部分：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will data join the information we isolated earlier to its own variable.
    This way, we will have one map that represents the entire world and another one
    that represents just Mexico:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将之前隔离的信息与自己的变量进行数据连接。这样，我们将有一个代表整个世界的地图，另一个只代表墨西哥的地图：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will inject the map of Mexico and apply the `geo.path` that contains the
    same projection we used for the world map. We will also add a light yellow background
    to Mexico using the `fill` CSS style and an orange border using the stroke:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注入墨西哥的地图，并应用包含与我们用于世界地图相同的投影的`geo.path`。我们还将使用`fill` CSS样式添加浅黄色背景，并使用`stroke`添加橙色边框：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is where the action starts, literally. We created an interval that executes
    every 20 milliseconds. This interval contains a function that utilizes our index
    variable and increments the value by `0.2`. This value is then applied to the
    `rotate` function of our projection. Specifically, we will adjust the rotation
    every `20` ms on this line of code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是动作开始的地方，字面上讲。我们创建了一个每20毫秒执行一次的间隔。这个间隔包含一个函数，该函数使用我们的索引变量并将值增加`0.2`。然后，这个值被应用到我们的投影的`rotate`函数上。具体来说，我们将在这行代码上每`20`毫秒调整旋转：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Yaw is represented by the first value of the array (in this case, `i`), pitch
    represented by the second value, and roll by the third value. Yaw, pitch, and
    roll are rotation angles and are applied in their respective vectors. The following
    image provides an illustration of how the angles rotate:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 偏航由数组的第一个值表示（在这种情况下，`i`），俯仰由第二个值表示，翻滚由第三个值表示。偏航、俯仰和翻滚是旋转角度，并应用于它们各自的向量。以下图像展示了这些角度的旋转方式：
- en: '![](img/4e02e608-c616-4261-b527-1a2d6c55e0c2.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e02e608-c616-4261-b527-1a2d6c55e0c2.png)'
- en: Here, we see that the yaw vector points in the *z* direction and is around the
    center axis. The pitch goes along our *x* axis, and the yaw goes around our *y*
    axis. The Greek characters (in parentheses in the preceding image) are often used
    to depict yaw, pitch, and roll.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到偏航向量指向*z*方向，并围绕中心轴旋转。俯仰沿着我们的*x*轴，而偏航则围绕*y*轴旋转。希腊字符（在前面图像中的括号内）通常用来表示偏航、俯仰和翻滚。
- en: 'In our case, the index variable, `i`, is increasing and is allocated to the
    yaw rotation. This means that our globe will spin from left to right around the
    center axis. If we were to swap the position of our index so that it is in the
    pitch location (the second array element), our globe would spin vertically:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，索引变量`i`正在增加，并分配给偏航旋转。这意味着我们的地球将围绕中心轴从左向右旋转。如果我们交换索引的位置，使其位于俯仰位置（第二个数组元素），我们的地球将垂直旋转：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we will use the same D3 update pattern and update all the paths with
    the new projection. Give it a shot, play around with the example, and see how
    the globe spins in different directions. When complete, you will see the rotating
    globe in your browser, as in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用相同的D3更新模式并更新所有路径以使用新的投影。试一试，玩一玩这个例子，看看地球是如何在不同方向上旋转的。完成后，你将在浏览器中看到旋转的地球，如下面的截图所示：
- en: '![](img/a7deb056-1d3c-4323-87a0-c2731f5e91f5.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7deb056-1d3c-4323-87a0-c2731f5e91f5.png)'
- en: Experiment 6 – dragging orthographic projections
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验6 – 拖动正射投影
- en: 'For our last example, we will add the ability to drag our globe so that the
    user can spin it to the left or right. Open `http://localhost:8080/chapter-5/example-6.html`
    from the code samples and let''s get started:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一个例子，我们将添加拖动地球的功能，这样用户就可以将其向左或向右旋转。从代码示例中打开`http://localhost:8080/chapter-5/example-6.html`，让我们开始吧：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our first piece of new code is our dragging event handler. This function will
    be executed every time the user drags the mouse on the screen. The algorithm executes
    the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一段新代码是我们的拖动事件处理器。这个函数将在用户在屏幕上拖动鼠标时执行。算法执行以下步骤：
- en: Stores the current rotation value.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储当前的旋转值。
- en: Updates the projection's rotation based on the distance it is dragged.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据拖动的距离更新投影的旋转。
- en: Updates all the paths in the world map.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新世界地图中的所有路径。
- en: Updates all the paths in the map of Mexico.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新墨西哥地图中的所有路径。
- en: 'The second step deserves a little more explanation. Just like the `d3.behavior.zoom`
    event handler, `d3.behavior.drag` exposes information about the performed action.
    In this case, `d3.event.dx` and `d3.event.dy` indicate the distance dragged from
    the previous location. The `c[0] + d3.event.dx/2` code tells us that we need to
    take the previous yaw value and add the amount of drag the user is performing.
    We will divide the drag amount by two to slow down the rotation by half; otherwise,
    every pixel the user drags will correlate to *1* degree of rotation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步需要更多的解释。就像`d3.behavior.zoom`事件处理器一样，`d3.behavior.drag`暴露了执行动作的信息。在这种情况下，`d3.event.dx`和`d3.event.dy`表示从上一个位置拖动的距离。`c[0]
    + d3.event.dx/2`代码告诉我们，我们需要取上一个偏航值并加上用户执行的拖动量。我们将拖动量除以二，以减半旋转速度；否则，用户每拖动一个像素都将对应于*1*度的旋转：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we will bind our `dragging` method to our drag event, as we saw earlier,
    with click, hover, and zoom:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的`dragging`方法绑定到拖动事件，就像我们之前看到的，通过点击、悬停和缩放：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we need an area to bind our drag event. Using our previous technique,
    we will add a transparent rectangle on top of the visualization. This will allow
    us to very clearly detect the *x* and *y* positions on our SVG element.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个区域来绑定我们的拖动事件。使用我们之前的技术，我们将在可视化上添加一个透明的矩形。这将允许我们非常清楚地检测SVG元素上的*x*和*y*位置。
- en: 'Give it a spin! You''ll notice that if you click-and-drag the world, it will
    spin in the corresponding yaw direction:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 给它一个旋转！你会注意到，如果你点击并拖动世界，它将在相应的偏航方向上旋转：
- en: '![](img/3097f608-1f0f-412b-959b-d0159a2e35c5.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3097f608-1f0f-412b-959b-d0159a2e35c5.png)'
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered many examples to get you started with interactivity for your D3 map
    visualizations. We went over the basics of event handling, explored various methods
    to bind events to the map, outlined the two `d3.behavior` APIs, and even dipped
    our toes into orthographic projections. If you wish to dig deeper into world rotations,
    and the math involved, check out the Jason Davies article at: [http://www.jasondavies.com/maps/rotate/](http://www.jasondavies.com/maps/rotate/).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了许多示例，帮助你开始使用D3地图可视化进行交互。我们讨论了事件处理的基础，探索了将事件绑定到地图的各种方法，概述了两个`d3.behavior`
    API，甚至涉足了正射投影。如果你想要深入了解世界旋转和相关的数学，请查看Jason Davies的文章：[http://www.jasondavies.com/maps/rotate/](http://www.jasondavies.com/maps/rotate/)。
- en: After two chapters of drawing and interacting with maps, the next chapter will
    explain how to obtain geo data in order to create any map you want. We'll also
    include some techniques to optimize the data files for viewing the web.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制和与地图交互了两章之后，下一章将解释如何获取地理数据以创建你想要的任何地图。我们还将包括一些优化数据文件以供网页查看的技术。
