- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Creating Matchers to Simplify Tests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建匹配器以简化测试
- en: 'This chapter introduces another method for simplifying tests: building custom
    matchers. Most of the time, it makes sense to stick to the built-in matchers.
    For instance, the powerful combination of the `toEqual` matcher with the `expect.objectContaining`
    and `expect.arrayContaining` functions make it easy to build expressive expectations.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了另一种简化测试的方法：构建自定义匹配器。大多数时候，坚持使用内置匹配器是有意义的。例如，`toEqual` 匹配器与 `expect.objectContaining`
    和 `expect.arrayContaining` 函数的强大组合使得构建表达式的期望变得容易。
- en: But sometimes it makes sense to build a matcher that can scoop up a number of
    different checks into one single check. This not only shortens tests but can make
    them more readable, too.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时构建一个可以将多个不同的检查合并到一个单独的检查中的匹配器是有意义的。这不仅缩短了测试，还可以使它们更容易阅读。
- en: 'In [*Chapter 5*](B19611_05.xhtml#_idTextAnchor070), *Validating Form Data*,
    each of the form validation rules was tested by a `describe` context with four
    tests, like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第5章*](B19611_05.xhtml#_idTextAnchor070) *验证表单数据* 中，每个表单验证规则都通过一个包含四个测试的
    `describe` 上下文进行测试，如下所示：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since all the validation rules have the same format, it seems like a good candidate
    for abstracting some shared code. The matcher we’ll create will scoop three of
    these tests into a custom matcher – the `toBeUnprocessableEntity` matcher – that
    can be used to replace them all with a single test:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有验证规则都具有相同的格式，因此似乎是一个很好的候选者来抽象一些共享代码。我们将创建的匹配器将把这三个测试中的三个合并到一个自定义匹配器中——`toBeUnprocessableEntity`
    匹配器——这样就可以用一个测试来替换它们：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There’s one final important point: the custom matcher requires its own set
    of unit tests. That’s so you can be sure that the matcher does the right thing:
    it passes when it’s meant to pass, and it fails when it’s meant to fail. Just
    like how you want to be sure that your application code does the right thing.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还有一个重要的一点：自定义匹配器需要它自己的单元测试集。这样你就可以确保匹配器做了正确的事情：当它应该通过时通过，当它应该失败时失败。就像你想要确保你的应用程序代码做正确的事情一样。
- en: Testing test code
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 测试测试代码
- en: 'The general rule I have is this: if your code contains any kind of control
    structure or branching logic, such as `if` statements or loop constructs, then
    it needs tests.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我的一般规则是这样的：如果你的代码包含任何类型的控制结构或分支逻辑，例如 `if` 语句或循环结构，那么它需要测试。
- en: 'This chapter covers the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下内容：
- en: Test-driving the pass or failure of an expectation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试期望的通过或失败
- en: Providing extra information in failure messages
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在失败消息中提供额外信息
- en: Implementing the negated matcher
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现否定匹配器
- en: Updating existing tests to use the matcher
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有测试以使用匹配器
- en: By the end of the chapter, you’ll understand how to build a matcher and how
    to write tests for it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何构建一个匹配器以及如何为其编写测试。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter08/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter08/Start).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在网上找到，地址为 [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter08/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter08/Start)。
- en: Test-driving the pass or failure of an expectation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试期望的通过或失败
- en: In this section, you’ll build the basic functionality of the `toBeUnprocessableEntity`
    matcher, ensuring that it will correctly pass or fail your test. But first, we’ll
    look at the structure of a matcher and then the approach to unit testing matchers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将构建 `toBeUnprocessableEntity` 匹配器的基本功能，确保它能够正确地通过或失败你的测试。但首先，我们将查看匹配器的结构，然后是单元测试匹配器的方法。
- en: Understanding matcher structure
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解匹配器结构
- en: 'Let’s look at the basic structure of a matcher and how we can test it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看匹配器的基本结构以及我们如何测试它：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `received` parameter value is the object passed to the `expect` call. The
    `expected` value is the value passed to the matcher. So, in the example from the
    introduction, the result is the received object, and the object containing the
    `error`, `name`, and `dob` properties is the expected object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`received` 参数值是传递给 `expect` 调用的对象。`expected` 值是传递给匹配器的值。因此，在引言中的示例中，结果是接收到的对象，包含
    `error`、`name` 和 `dob` 属性的对象是期望的对象。'
- en: 'The `return` value has two important properties: `pass` and `message`. The
    `pass` boolean should be `true` if your matcher passes the check, and `false`
    otherwise. However, for a negated matcher, the opposite happens: a `true` value
    for `pass` means that the expectation fails.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 值有两个重要的属性：`pass` 和 `message`。如果匹配器通过了检查，`pass` 布尔值应该是 `true`，否则为 `false`。然而，对于否定匹配器，情况正好相反：`pass`
    的 `true` 值意味着期望失败。'
- en: 'The `message` property is a function that returns a string. This string is
    what the test runner displays in the event that your test fails. The contents
    of the string should be enough for the developer to pinpoint what error occurs.
    The property itself is defined as a function so that it can be lazily evaluated:
    there’s no point running this code if the test passes.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`message` 属性是一个返回字符串的函数。这个字符串是测试运行器在测试失败时显示的内容。字符串的内容应该足够让开发者定位到发生的错误。这个属性本身被定义为函数，以便它可以延迟评估：如果测试通过，运行此代码就没有意义。'
- en: Unlike other code samples in this book, the matcher function will be defined
    using the standard `function` keyword. This means it gains access to the `this`
    bound variable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他代码示例不同，匹配器函数将使用标准的 `function` 关键字定义。这意味着它能够访问 `this` 绑定变量。
- en: 'Vitest primes `this` with a number of useful utility functions that the matcher
    can use. We’ll use a couple of them in this chapter: `this.equals` and `this.utils.diff`.
    Another useful property is `this.isNot`, which is `true` if your matcher was invoked
    in its negated form.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest 为 `this` 提供了一些有用的实用函数，匹配器可以使用。我们将在本章中使用其中几个：`this.equals` 和 `this.utils.diff`。另一个有用的属性是
    `this.isNot`，如果匹配器以否定形式调用，则该属性为 `true`。
- en: Testing a matcher
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试匹配器
- en: There are a couple of ways to test a matcher. One way is to test the function
    return values, as you would with any other function. The difficulty with this
    approach is that you’ll need to set up the `this` variable, and that’s not straightforward.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 测试匹配器有几种方法。一种方法是与任何其他函数一样测试函数返回值。这种方法的问题是需要设置 `this` 变量，而这并不简单。
- en: 'Another approach, and the approach we’ll use this in this chapter, is to use
    the `toThrowError` matcher to wrap the matcher under test, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，也是我们将在本章中使用的方法，是使用 `toThrowError` 匹配器来包装要测试的匹配器，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `toThrowError` matcher takes a function as the parameter to expect; this
    is then executed within a `try` block. The caught `Error` object then has its
    `message` value checked against the expected value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`toThrowError` 匹配器接受一个函数作为参数来期望；然后在 `try` 块中执行该函数。捕获的 `Error` 对象然后会检查其 `message`
    值是否与期望值匹配。'
- en: For this approach to work, we’ll need to ensure `toBeUnprocessableEntity` is
    registered with the Vitest test runner. We can do that with the `beforeAll` function
    that runs once at the very beginning test suite.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种方法有效，我们需要确保 `toBeUnprocessableEntity` 已注册到 Vitest 测试运行器。我们可以通过在测试套件开始时运行一次的
    `beforeAll` 函数来实现这一点。
- en: With all that knowledge, we’re ready to begin writing the matcher.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有所有这些知识，我们就可以开始编写匹配器了。
- en: Writing the toBeUnprocessableEntity matcher
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 `toBeUnprocessableEntity` 匹配器
- en: 'Let’s get started with the test suite:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写测试套件：
- en: 'Create a new file named `src/matchers/toBeUnprocessableEntity.test.js`, and
    start with the following imports. They include all the Vitest imports, which we’ll
    use in the next step. We’ll also import the `fail` SvelteKit function, which we’ll
    use in our tests:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `src/matchers/toBeUnprocessableEntity.test.js` 的新文件，并从以下导入开始。它们包括所有我们将要使用的
    Vitest 导入。我们还将导入 `fail` SvelteKit 函数，我们将在测试中使用它：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, create a new `describe` block with a `beforeAll` block at the start.
    This ensures that the new matcher is registered before our tests run. This only
    needs to be done once:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在开始处创建一个新的 `describe` 块和一个 `beforeAll` 块。这确保了新匹配器在我们运行测试之前被注册。这只需要做一次：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our first test will cause the expectation to fail. Add the following test code,
    which creates a failure reason with a `500` error code rather than a `422`, and
    then use the `toThrowError` matcher to check that the expectation fails:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一项测试将导致期望失败。添加以下测试代码，它使用 `500` 错误代码而不是 `422` 创建一个失败原因，然后使用 `toThrowError`
    匹配器来检查期望是否失败：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To make that test pass, all we need to do is build a matcher that returns a
    `pass` value of `false`. Create a new file named `src/matchers/toBeUnprocessableEntity.js`
    with the following content. As mentioned previously, this uses the `function`
    keyword syntax so that we gain access to Vitest’s matcher utility functions that
    are attached to the `this` variable:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使该测试通过，我们只需要构建一个返回`pass`值为`false`的匹配器。创建一个名为`src/matchers/toBeUnprocessableEntity.js`的新文件，并包含以下内容。如前所述，这使用`function`关键字语法，以便我们可以访问附加到`this`变量的Vitest匹配器实用函数：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the first test passing, add the second. This one checks the opposite –
    that the matcher does not throw if the response has a `422` error code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个测试通过后，添加第二个。这个测试检查的是相反的情况——即如果响应有`422`错误代码，匹配器不会抛出异常：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To make that pass, wrap the original code in a conditional so that it becomes
    a guard clause, and if that condition isn’t met, then return a `pass` value of
    `true`, as shown:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使测试通过，将原始代码包裹在条件中，使其成为一个守卫子句，如果该条件不满足，则返回`pass`值为`true`，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If a failure occurs, we want the test runner to display a helpful message about
    why the expectation failed. To do that, you can pass a string value to the `toThrowError`
    matcher that defines the error message. This is what the Vitest test runner will
    display on the screen. Add the following test:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生失败，我们希望测试运行器显示有关期望失败原因的有用消息。为此，你可以向`toThrowError`匹配器传递一个字符串值，该值定义了错误消息。这就是Vitest测试运行器将在屏幕上显示的内容。添加以下测试：
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Making that pass involves sending back the `message` property. The value of
    this property is a function that is only invoked if the test fails. It’s a form
    of lazy evaluation, allowing the test runner to avoid doing unnecessary work.
    Update the guard clause to include the `message` property, as shown:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使其通过涉及返回`message`属性。该属性的值是一个仅在测试失败时调用的函数。这是一种懒加载的形式，允许测试运行器避免进行不必要的操作。更新守卫子句以包含`message`属性，如下所示：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we also need to check the `response` body. In our application code, any
    `422` result returns an `error` property along with the original form values.
    We want the matcher to fail the test if the actual response doesn’t match the
    expected value:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还需要检查`response`体。在我们的应用程序代码中，任何`422`结果都会返回一个包含原始表单值的`error`属性。我们希望匹配器在实际响应与预期值不匹配时使测试失败：
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To make that pass, all we need is to add a very simple second guard clause.
    If an argument is passed to the matcher, then we fail the test. This implementation
    isn’t even close to a correct implementation, but it’s enough to make the test
    pass. We’ll need to triangulate with more tests. But for now, you can start with
    this code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使测试通过，我们只需要添加一个非常简单的第二个守卫子句。如果向匹配器传递了一个参数，那么测试就会失败。这个实现甚至离正确实现还差得远，但它足以使测试通过。我们还需要通过更多测试来验证。但就目前而言，你可以从以下代码开始：
- en: '[PRE13]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next test is very similar, but this time, the two response bodies *do*
    match. This case shouldn’t cause a failure error:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试非常相似，但这次，两个响应体*确实*匹配。这种情况不应该导致失败错误：
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update the second guard clause to use the `this.equals` function to perform
    a deep equality check on the `received.data` value and the `expected` parameter.
    This is enough to make the test pass:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个守卫子句更新为使用`this.equals`函数对`received.data`值和`expected`参数进行深度相等性检查。这足以使测试通过：
- en: '[PRE15]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The final test is a check that partial objects match:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终测试是一个检查部分对象是否匹配的测试：
- en: '[PRE16]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To make that pass, we will use the `expect.objectContaining` constraint function,
    which can be passed into the call to `this.equals`. Start by importing the `expect`
    object at the top of the test file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使该测试通过，我们将使用`expect.objectContaining`约束函数，该函数可以传递到`this.equals`的调用中。首先，在测试文件顶部导入`expect`对象：
- en: '[PRE17]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, update the guard class to wrap the `expected` value in a call to `expect.objectContaining`,
    as shown:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新守卫类，将`expected`值包裹在`expect.objectContaining`的调用中，如下所示：
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, if you run tests now, you’ll find the very first test fails because
    the value of `expected` is `undefined`, and `expect.objectContaining` doesn’t
    like that. To fix the issue, set a default value for the `expected` argument,
    like this:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果你现在运行测试，你会发现第一个测试失败了，因为`expected`的值是`undefined`，而`expect.objectContaining`不喜欢这个值。要修复这个问题，为`expected`参数设置一个默认值，如下所示：
- en: '[PRE19]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You’ve now seen how to test-drive a matcher function. The next section focuses
    on improving the error messages that are displayed when a failure occurs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了如何测试驱动匹配器函数。下一节将重点介绍在发生失败时显示的错误消息的改进。
- en: Providing extra information in failure messages
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在错误消息中提供额外信息
- en: This section improves the detailed information that is presented to the developer
    when a test fails. The purpose of this extra information is to help pinpoint the
    issue with the application code so that the developer isn’t left scratching their
    head about what went wrong.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本节改进了在测试失败时向开发者展示的详细信息。额外信息的目的是帮助定位应用程序代码中的问题，以便开发者不会对出了什么问题感到困惑。
- en: 'Let’s begin:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'Add the next test, which checks that a basic message is shown when the response
    bodies do not match:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加下一个测试，该测试检查当响应体不匹配时是否显示基本消息：
- en: '[PRE20]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To make that pass, add the `message` property to the second guard clause `return`
    value. We’ll expand on this in the next test:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现这个跳过，请将`message`属性添加到第二个保护子句的`return`值。我们将在下一个测试中进一步说明这一点：
- en: '[PRE21]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Vitest includes a built-in object `diff` helper that will print out a colorful
    diff. Colors are added into the text string using ANSI color codes, which the
    Terminal will decipher and use to switch on and off colors. The presence of these
    codes means that checking the text content within the `toThrowError` matcher is
    not straightforward. The following test shows a pragmatic way of checking the
    same thing in a simpler way, by checking that both the `c` and `a` properties
    appear somewhere in the output:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vitest包含一个内置的`diff`辅助对象，它将打印出彩色的差异。颜色是通过ANSI颜色代码添加到文本字符串中的，终端将解析并使用这些代码来切换颜色。这些代码的存在意味着在`toThrowError`匹配器中检查文本内容并不简单。以下测试展示了以更简单的方式检查相同内容的实用方法，通过检查`c`和`a`属性是否出现在输出中：
- en: '[PRE22]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To make that pass, we’ll append the diff onto the end of `message` that we’re
    already printing. First, import the `EOL` constant from Node.js’s `os` module,
    which gives us the current platform’s line-ending:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现这个跳过，我们将把差异追加到我们正在打印的`message`的末尾。首先，从Node.js的`os`模块中导入`EOL`常量，它提供了当前平台的行结束符：
- en: '[PRE23]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the matcher code, update the second guard clause’s `message` property to
    use the `this.utils.diff` function to print the diff of the `expected` and `received.data`
    objects:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在匹配器代码中，更新第二个保护子句的`message`属性，使用`this.utils.diff`函数来打印`expected`和`received.data`对象的差异：
- en: '[PRE24]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That completes the display of detailed error information. We’ll finish off our
    matcher in the next section by ensuring it works nicely when used in a negated
    sense.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了详细错误信息的显示。我们将在下一节中完成我们的匹配器，确保它在被否定使用时工作良好。
- en: Implementing the negated matcher
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现否定匹配器
- en: Negating a matcher is a tricky business, mainly because negated matchers can
    have confusing meanings. For example, what does the following expectation mean?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 否定匹配器是一项棘手的工作，主要是因为否定匹配器可能有令人困惑的含义。例如，以下期望意味着什么？
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Presumably, it should fail if the response is `422` and the response body matches
    the object provided. But should it also fail if the response is, say, a `500`
    or `200` response? If that was what was expected, wouldn’t it be enough to write
    this?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 据推测，如果响应是`422`且响应体与提供的对象匹配，它应该失败。但是，如果响应是`500`或`200`响应，它也应该失败吗？如果这是预期的，那么写这个就足够了吗？
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I find that when writing matchers for domain-specific ideas, negated matchers
    are best avoided, or at least restricted in their use. However, to show how it’s
    done, let’s carry on with the matcher.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，在编写针对特定领域思想的匹配器时，最好避免使用否定匹配器，或者至少限制其使用。然而，为了展示如何实现，让我们继续使用匹配器。
- en: When we negate the matcher, the Vitest test runner will fail the test if the
    matcher returns a `pass` value of `true`. We have exactly one scenario where this
    occurs, as all our guard clauses return a `pass` value of `false`. So, all these
    remaining tests simply check the `message` property in this case.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们否定匹配器时，Vitest测试运行器会在匹配器返回`pass`值为`true`时失败测试。我们恰好有一个场景会发生这种情况，因为所有保护子句都返回`pass`值为`false`。因此，所有这些剩余的测试只是在这种情况下检查`message`属性。
- en: 'Let’s start by creating a nested `describe` block:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个嵌套的`describe`块开始：
- en: 'Add a nested `describe` block named simply `not`, and add the first test:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`not`的嵌套`describe`块，并添加第一个测试：
- en: '[PRE27]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To make that pass, head to the bottom of the matcher and add the basic `message`
    property value to the last `return` value in the function, as shown:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现这个跳过，请转到匹配器的底部，并将基本的`message`属性值添加到函数中的最后一个`return`值，如下所示：
- en: '[PRE28]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can improve upon that by ensuring that the actual `response` body is returned
    in the message. Add the next test:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过确保实际`response`体在消息中返回来改进这一点。添加下一个测试：
- en: '[PRE29]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To make that pass, you can make use of the `this.utils.stringify` utility function,
    which does all the hard work for you:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，您可以使用`this.utils.stringify`实用函数，它为您做了所有艰苦的工作：
- en: '[PRE30]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we need to be careful about the case when no expected object is passed
    in. When this happens, the actual body isn’t relevant for the developer since,
    by omitting it from the expectation, they have expressed that they aren’t interested
    in it:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要注意没有传递预期对象的情况。当这种情况发生时，实际的身体对于开发者来说并不相关，因为通过从期望中省略它，他们已经表示他们对此不感兴趣：
- en: '[PRE31]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To make that pass, add a third guard clause, as shown:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，添加一个第三条守卫子句，如下所示：
- en: '[PRE32]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You’ve now test-driven a complete matcher, with useful error messages and support
    for the negated form. Next, it’s time to make use of it in our existing test suites.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经测试驱动了一个完整的匹配器，它具有有用的错误消息和对否定形式的支持。接下来，是时候在我们的现有测试套件中使用它了。
- en: Updating existing tests to use the matcher
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新现有测试以使用匹配器
- en: In this final section, we’ll use the matcher we’ve just built to simplify the
    form validation error test suite.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将使用我们刚刚构建的匹配器来简化表单验证错误测试套件。
- en: 'Let’s get started:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'First, register the matcher for our test runs by adding an `import` statement
    and call to `expect.extend` in the `src/vitest/registerMatchers.js` file:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过在`src/vitest/registerMatchers.js`文件中添加一个`import`语句和调用`expect.extend`来为我们的测试运行注册匹配器：
- en: '[PRE33]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, in `src/routes/birthdays/page.server.test.js`, find the nested `describe`
    block with the description `when the name is not provided`. It contains four tests.
    Leave the first one in place, and replace the last three tests with the following
    test:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`src/routes/birthdays/page.server.test.js`中，找到具有描述`当名称未提供时`的嵌套`describe`块。它包含四个测试。保留第一个测试，并用以下测试替换最后三个测试：
- en: '[PRE34]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, do the same for the nested `describe` block with the description `when
    the date of birth is in the wrong format`, replacing the last three tests with
    the test shown:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对具有描述`当出生日期格式错误时`的嵌套`describe`块执行相同的操作，用显示的测试替换最后三个测试：
- en: '[PRE35]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Do exactly the same thing with the `when the id is` `unknown` context:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`当id是` `未知`上下文完全做同样的事情：
- en: '[PRE36]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, there are a couple of tests specifically for ensuring `id` is returned.
    Update the expectations for them both, as shown:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，有一些特定的测试是为了确保返回`id`。更新它们的期望，如下所示：
- en: '[PRE37]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: And that completes the changes. Make sure to run all tests and check that everything
    is passing. Take a step back and look at how much clearer and simpler your tests
    have become.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了更改。请确保运行所有测试并检查是否一切通过。退后一步，看看您的测试变得多么清晰和简单。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has shown you how to build a custom matcher to simplify your test
    expectations. It also discussed the importance of test-driving matcher code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了如何构建一个自定义匹配器以简化您的测试期望。它还讨论了测试驱动匹配器代码的重要性。
- en: Your unit test files act as a specification of your software. It’s imperative
    that these files are clear and concise so that the specifications are clear. Sometimes,
    writing custom matchers can help you achieve that clarity.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您的单元测试文件是您软件的规范。这些文件必须清晰简洁，以便规范清晰。有时，编写自定义匹配器可以帮助您实现这种清晰性。
- en: Why do we test-drive matcher implementations? Because almost all matchers have
    branching logic – sometimes they’ll pass and sometimes they’ll fail – and you
    want to be sure that the right branches are used at the right times.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要测试驱动匹配器的实现？因为几乎所有的匹配器都有分支逻辑——有时会通过，有时会失败——你想要确保在正确的时间使用正确的分支。
- en: In the next chapter, we’ll switch back to refactoring our application code,
    with the intention of improving its testability.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将切换回重构我们的应用程序代码，目的是提高其可测试性。
