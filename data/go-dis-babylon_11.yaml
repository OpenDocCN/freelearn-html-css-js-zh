- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Scratching the Surface of Shaders
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索着色器的表面
- en: Captain Edward J. Smith of the erstwhile and ill-fated ship the Titanic would
    no doubt be among the first to acknowledge the fact that the visible surface of
    an iceberg represents but a small fraction of an immensely greater object. When
    used as an analogy, the phrase “tip of the iceberg” is commonly understood to
    mean that what is visible, isn’t and shouldn’t be taken to be representative of
    the entire thing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 泰坦尼克号前船长爱德华·J·史密斯无疑会是第一个承认冰山可见表面只是巨大物体一小部分的船长。当用作类比时，短语“冰山一角”通常被理解为可见的并不代表整个事物。
- en: Note
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The aforementioned, oddly specific call-out to Captain Ed Smith, is a fantastic
    Random Fact to know on Trivia Night.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上述对爱德华·史密斯船长的奇怪具体提及，是Trivia Night（知识之夜）上一个极好的随机事实。
- en: Similarly, the idea of scratching the surface of a topic evokes imagery of kids
    attempting to dig a hole to the other side of the planet. Juxtaposed with a to-scale
    globe, it suggests the immensity of the digger’s undertaking. In no way does it
    diminish the enjoyment the children get from their quixotic adventure, but by
    depicting the differentiated layers of crust, mantle, and core, it acknowledges
    how a serious endeavor involves more than doing existing things on larger scales.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，探索一个主题的表面会唤起孩子们试图挖洞到达地球另一侧的意象。与一个按比例的地球仪并置，它暗示了挖掘者任务的浩大。这绝不是减少了孩子们从他们荒唐的冒险中获得的乐趣，但通过描绘地壳、地幔和核心的不同层，它承认一项严肃的尝试不仅是在更大规模上做现有的事情。
- en: The preceding paragraph could come straight out of a self-help book with how
    hard it tries to hit its reader over the head with the analogy, but it does accurately
    describe the subject matter of this chapter. Shaders and programming for the GPU
    are the topics of this chapter in a broad sense, with a focus on the tools and
    how to use them in service of the topic. This leaves us with a problem like previous
    ones we encountered when we looked at input and control systems ([*Chapter 5*](B17266_05_Final_AM.xhtml#_idTextAnchor103)*,
    Adding a Cut Scene and Handling Input*). As you may recall, the problem was that
    the amount of material needed to gain a solid understanding of the topic requires
    a book of its own to properly cover it!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段落几乎可以直接出自一本自助书籍，它试图用类比重重打击读者的头脑，但它确实准确地描述了本章的主题。从广义上讲，本章的主题是着色器和GPU编程，重点是工具以及如何使用这些工具来服务于这一主题。这使我们面临一个像之前遇到的问题一样的问题：当我们查看输入和控制系统时（[*第5章*](B17266_05_Final_AM.xhtml#_idTextAnchor103)*，添加场景和输入处理*）。如您所忆，问题在于要获得对这一主题的深入理解所需的材料量，需要一本自己的书来适当涵盖它！
- en: As we did in previous instances, we’re going to cover as much of the fundamentals
    as possible while still laying the groundwork for whatever next steps you decide
    to take in learning this subject. This means that there might be things that don’t
    get a whole lot of space, but that will be made up for (hopefully) by the excellent
    links and resources that are available and listed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的情况一样，我们将尽可能涵盖基础知识，同时为你在学习这一主题时决定采取的任何下一步学习打下基础。这意味着可能会有一些东西没有得到太多空间，但（希望）由可用的优秀链接和资源来弥补。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding Shader Concepts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解着色器概念
- en: Writing and Using Shaders in Babylon.js
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Babylon.js 中编写和使用着色器
- en: Shader Programming with the Node Material Editor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用节点材质编辑器进行着色器编程
- en: This is a far more limited number of topics than what could have been covered,
    but by the end of this chapter, you’ll know enough to be immediately productive
    in current projects while also having enough grounding to see where your next
    steps in learning lead.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是可能涵盖主题的一小部分，但到本章结束时，你将了解足够多的知识，可以立即在当前项目中发挥作用，同时也有足够的根基来了解你下一步学习的方向。
- en: Technical Requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are the same as the previous ones;
    however, there are some subjects and areas that might be useful to refresh or
    catch up on:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求与之前相同；然而，有一些主题和领域可能有用，需要复习或补充：
- en: '**Vector math operations**: This includes addition, subtraction, dot, cross,
    and others. You won’t need to perform the calculations or memorize any equations,
    but knowing the significance or purpose of them (for example, you can use vector
    subtraction to find the direction between two objects) is the key to making the
    knowledge useful.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量数学运算**：这包括加法、减法、点积、叉积和其他运算。你不需要执行计算或记住任何方程，但了解它们的含义或目的（例如，你可以使用向量减法来找到两个对象之间的方向）是使知识有用的关键。'
- en: '**Function graphs**: Both Windows and macOS have built-in or freely available
    graphing calculators that can graph entered equations. This is useful in understanding
    the output of a piece of shader code across varying inputs. Graph like it’s TI-89!
    An online-only option is the Desmos Graphing Calculator at [https://www.desmos.com/calculator](https://www.desmos.com/calculator).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数图像**：Windows 和 macOS 都内置或提供免费的可用图形计算器，可以绘制输入的方程图。这在理解不同输入下片段代码的输出非常有用。图形绘制就像使用
    TI-89 一样！仅在线选项是 Desmos 图形计算器，位于 [https://www.desmos.com/calculator](https://www.desmos.com/calculator)。'
- en: Understanding Shader Concepts
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解着色器概念
- en: 'In the days before standalone GPUs were commonplace, drawing pixels to the
    screen was a lot different than it is today. Kids these days just don’t know how
    good things have gotten with their programmable shaders! Back then, you would
    write pixel color values directly into a buffer in memory that becomes the next
    frame sent to the display. The advent and proliferation of the dedicated graphics
    processor as an add-on came in the late 1990s, and it changed the landscape completely.
    Access to display pixels was abstracted around two major **Application Programming
    Interfaces** (**APIs**): DirectX and OpenGL. There’s an incredibly rich history
    of the evolution of those interfaces but this isn’t a book on graphics hardware
    interfaces and their history – it’s a book on present 3D graphics development,
    so let’s just leave the details to those tomes and summarize them in short.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在独立 GPU 变得普遍之前的日子里，将像素绘制到屏幕上的方式与今天大不相同。现在的孩子们根本不知道可编程着色器让事情变得有多好！当时，你会直接将像素颜色值写入内存中的一个缓冲区，这个缓冲区将成为发送到显示器的下一帧。专用图形处理器作为附加组件的出现和普及始于
    1990 年代末，这彻底改变了整个行业。显示像素的访问被抽象为两个主要的 **应用程序编程接口**（**API**）：DirectX 和 OpenGL。这些接口的演变有着极其丰富的历史，但这本书不是关于图形硬件接口及其历史的书籍——这是一本关于当前
    3D 图形开发的书籍，所以我们只需将细节留给那些专著，并简要总结它们。
- en: To avoid the need for developers and end user software to support every model
    and make of graphics cards, a set of APIs was developed that a hardware manufacturer
    could then implement. Two competing standards emerged – DirectX and OpenGL – and
    for the subsequent decade or so, drama ensued as each tried to adapt and change
    to a rapidly evolving graphics technology landscape. We’re going to finish this
    section by looking at shaders themselves, which requires us to understand how
    a shader relates to the rest of the computer hardware and software. Before we
    can understand that aspect, however, we need to understand why it’s important
    to make these types of distinctions in the first place.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免开发者和最终用户软件需要支持每种型号和品牌的显卡，开发了一套 API，硬件制造商可以据此实现。两个竞争标准应运而生——DirectX 和 OpenGL——在接下来的十年左右的时间里，随着每个标准试图适应和改变快速发展的图形技术格局，随之而来的是一系列的戏剧性事件。我们将通过查看着色器本身来结束本节，这需要我们理解着色器如何与计算机硬件和软件的其余部分相关联。然而，在我们能够理解这一方面之前，我们需要了解为什么一开始就需要做出这些类型的区分。
- en: Differences Between a GPU and a CPU
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**GPU 与 CPU 的区别**'
- en: A graphics processor isn’t built the same way as a regular CPU. At a fundamental
    hardware level, a graphics processor is built around performing certain types
    of tasks very fast. This meant that applications needed to contain specialized
    code that could leverage these capabilities to their fullest. As opposed to code
    that you may typically write for the frontend or backend of a website, where code
    is executed sequentially, one instruction after another, a GPU wants to execute
    as many operations in parallel as possible. Still, this is not an illuminating
    way to describe how a GPU is programmed differently from how we may know from
    previous experience and intuition. A better analogy might be in thinking about
    how a painter might render a large mural onto a wall, as seen in *Figure 11.1*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图形处理器并不是以与常规CPU相同的方式构建的。在基本的硬件层面上，图形处理器是围绕快速执行某些类型任务而构建的。这意味着应用程序需要包含专门的代码，以充分利用这些能力。与为网站的前端或后端编写的代码不同，那里的代码是顺序执行的，一条指令接着另一条指令，GPU希望尽可能并行执行尽可能多的操作。然而，这并不是描述GPU编程方式与我们的先前经验和直觉不同的一个很有启发性的方式。一个更好的类比可能是考虑一位画家如何将一幅大型壁画绘制到墙上，正如*图
    11.1*所示。
- en: 'Like traditional programs, most printing that people are familiar with at the
    consumer level is done by a process known as rasterization – a print head scans
    the paper, spraying down ink of specific colors at times and places it corresponding
    to the patterns of colors of the print. In this way, a picture is progressively
    built from one corner to its opposite, line by line, pixel by pixel. Our painter
    works similarly, starting from one part of the painting and building up the mural
    piece by piece:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就像人们熟悉的消费级打印程序一样，大多数打印都是由称为光栅化的过程完成的 – 打印头扫描纸张，在特定的时间和地点喷洒特定颜色的墨水，并将其放置在打印颜色图案的对应位置。这样，图片就是从一角到另一角，逐行、逐像素地逐渐构建起来的。我们的画家以类似的方式工作，从画作的某一部分开始，一块一块地构建壁画：
- en: '![Figure 11.1 – An analogy of traditional computing has a single painter working
    on the entire portrait themselves as being analogous to how a CPU processes instructions'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 传统计算的类比是一位画家自己完成整个肖像，这类似于CPU处理指令的方式'
- en: '](img/Figure_11.01_B17266.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_11.01_B17266.jpg)'
- en: Figure 11.1 – An analogy of traditional computing has a single painter working
    on the entire portrait themselves as being analogous to how a CPU processes instructions
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 传统计算的类比是一位画家自己完成整个肖像，这类似于CPU处理指令的方式
- en: 'In contrast to our lone painter-as-a-CPU, graphics processors ditch the raster
    process and go with a more distributed shotgun approach to painting an image.
    Here, thousands of painters are all assigned to work on different small slices
    of the same piece. None of the individual “painters” has any knowledge about what
    their brethren are up to; they just have their instructions for painting their
    tiny piece of the full picture:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们那位作为CPU的孤独画家相比，图形处理器放弃了光栅化过程，转而采用更分散的散弹射击方法来绘制图像。在这里，数千名画家都被分配去处理同一幅画的不同小部分。没有任何一个“画家”了解他们的同伴在做什么；他们只是按照指令来绘制他们的小部分画面：
- en: '![Figure 11.2 – Graphics cards execute instructions simultaneously, with each
    “painter” getting only a tiny piece of the full canvas to work on, and with no
    knowledge of any other painter'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – 图形卡同时执行指令，每个“画家”只得到一小部分完整画布来工作，并且对其他画家一无所知'
- en: '](img/Figure_11.02_B17266.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_11.02_B17266.jpg)'
- en: Figure 11.2 – Graphics cards execute instructions simultaneously, with each
    “painter” getting only a tiny piece of the full canvas to work on, and with no
    knowledge of any other painter
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 图形卡同时执行指令，每个“画家”只得到一小部分完整画布来工作，并且对其他画家一无所知
- en: It is in this manner that graphics cards can handle the billions of calculations
    per second needed to drive modern 3D graphics applications and games. As the previous
    diagram implies, instead of a single painter (processor) methodically laying down
    each line and each layer of paint until the picture is complete, there is a legion
    of painters that each execute the same set of instructions, but with data wholly
    specific to their part of the canvas.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正是通过这种方式，图形卡可以处理每秒数亿次的计算，以驱动现代3D图形应用程序和游戏。正如前面的图表所暗示的，不是只有一个画家（处理器）有系统地铺下每一笔和每一层颜料，直到画面完成，而是一群画家各自执行相同的指令集，但数据完全特定于他们自己的画布部分。
- en: Shaders are GPU Applications
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器是GPU应用程序
- en: How can applications take advantage of this way of processing? More importantly,
    how can a developer write code that takes advantage of this massively parallel
    processing resource? To answer those questions fully and with the appropriate
    context would (again) require an entire book of its own. The *Extended Topics*
    section of this chapter contains several such excellent tomes! We will leave historical
    context, fundamental concepts, and the hard mathematics to those more worthy voices
    and instead focus on more practical aspects of writing the instructions handed
    to those legions of painters in the form of graphics card programs, more commonly
    referred to as shaders.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序如何利用这种处理方式？更重要的是，开发者如何编写利用这种大规模并行处理资源的代码？要全面且恰当地回答这些问题，需要（再次）一本完整的书。本章的“扩展主题”部分包含了几本这样的优秀著作！我们将历史背景、基本概念和艰难的数学留给更值得的声音，而将重点放在编写指令的更实际方面，这些指令以图形卡程序的形式，更常见地被称为着色器，交给那些成千上万的画家。
- en: 'In the graphics rendering process, we start with various data from the Scene,
    such as geometry, lighting, and materials, and we finish with a frame displayed
    on the screen. This result comprises a collection of pixels and their colors,
    one pixel/color combination for every point displayed on the screen. In the space
    between the Scene and the Screen, there are several important steps, but at a
    high level, this is the Rendering Pipeline:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形渲染过程中，我们从场景中的各种数据开始，例如几何形状、光照和材质，并以屏幕上显示的帧结束。这个结果包括像素及其颜色，屏幕上每个显示点的像素/颜色组合。在场景和屏幕之间，有几个重要的步骤，但在高层次上，这是渲染管线：
- en: '![Figure 11.3 – Simplified rendering pipeline. Starting with the Scene as initial
    the input, sequentially executed shader programs convert the scene geometry into
    pixel locations, and then finally pixel locations into colors'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 – 简化的渲染管线。以场景作为初始输入，依次执行的着色器程序将场景几何形状转换为像素位置，然后最终将像素位置转换为颜色]'
- en: '](img/Figure_11.03_B17266.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.03_B17266.jpg]'
- en: Figure 11.3 – Simplified rendering pipeline. Starting with the Scene as initial
    the input, sequentially executed shader programs convert the scene geometry into
    pixel locations, and then finally pixel locations into colors
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 简化的渲染管线。以场景作为初始输入，依次执行的着色器程序将场景几何形状转换为像素位置，然后最终将像素位置转换为颜色
- en: Each step of the pipeline receives input from the previous steps’ output. The
    logic specific to each step that we’re interested in is handled and represented
    by an individual shader program. However, recall that in this context, an individual
    shader program is a piece of code that will be executed in a massively parallel
    fashion, with the data relevant to each part of the screen or scene making up
    the inputs and the processed equivalents of their outputs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的每一步都接收来自前一步输出的输入。我们感兴趣的每个步骤的特定逻辑由一个单独的着色器程序处理和表示。然而，请记住，在这个上下文中，一个单独的着色器程序是一段将以大规模并行方式执行，与屏幕或场景的每个部分相关的数据作为输入，以及它们输出的处理等效物。
- en: About Shaders
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于着色器
- en: As mentioned earlier, a shader is a type of executable program that runs on
    the GPU. The shader program is provided a set of constants, or uniforms, that
    contain the input data that can be used by the shader. Shaders can also reference
    textures as input for sampling purposes – a powerful capability we’ll exploit
    later in this chapter. Some examples of common uniforms are animation time multipliers,
    vector positions or colors, and other data useful in providing configuration data
    to the shader. The output of a given shader varies; for a vertex shader, the output
    is the given geometry’s projection from world to screen space at the vertex level.
    A fragment shader’s output is completely different – it is a pixel color value.
    Something more advanced is a **WebGPU Compute shader**, whose output can be arbitrary
    – later in this chapter, we will look at this more closely!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，着色器是一种在GPU上运行的可执行程序。着色器程序提供一组常量，或称为统一变量，这些变量包含着色器可以使用的输入数据。着色器还可以引用纹理作为采样输入
    – 我们将在本章后面利用这一强大功能。一些常见的统一变量示例包括动画时间乘数、向量位置或颜色，以及其他对向着色器提供配置数据有用的数据。给定着色器的输出各不相同；对于一个顶点着色器，输出是在顶点级别从世界空间到屏幕空间的给定几何投影。片段着色器的输出则完全不同
    – 它是一个像素颜色值。更高级的是**WebGPU计算着色器**，其输出可以是任意的 – 本章后面我们将更详细地探讨这一点！
- en: 'The shader program types we’re going to be working with here fall into two
    categories: **Vertex** and **Fragment**. Although they’re being introduced as
    separate things, they are usually contained and defined within the same shader
    code. Two main languages are used to write shader programs in use today: **Hardware
    Lighting and Shading Language** (**HLSL**) and **OpenGL Shader Language** (**GLSL**).
    The first, **HLSL**, is used by the Microsoft DirectX graphics API. We’re not
    going to spend any time on HLSL because **WebGL**, **WebGL2**, and **WebGPU**
    (with a caveat; see the following *Note*) all use the second language, **GLSL**.
    Since Babylon.js is built on a WebGL/2/GPU platform, GLSL is what we’re going
    to focus on in our brief overviews.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要处理的着色器程序类型分为两大类：**顶点**和**片段**。尽管它们被作为独立的事物引入，但它们通常包含并定义在相同的着色器代码中。目前编写着色器程序使用的两种主要语言是：**硬件光照和着色语言**（**HLSL**）和**OpenGL着色语言**（**GLSL**）。第一种，**HLSL**，被微软DirectX图形API使用。我们不会在HLSL上花费任何时间，因为**WebGL**、**WebGL2**和**WebGPU**（有一个注意事项；见以下*注意*）都使用第二种语言，**GLSL**。由于Babylon.js建立在WebGL/2/GPU平台上，因此我们将重点关注我们的简要概述中的GLSL。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**WebGPU** uses a variant of GLSL called **wGLSL**, but because Babylon.js
    is so focused on maintaining backward compatibility, you have the choice to use
    wGLSL or continue writing shaders in regular GLSL – either way, you can still
    use WebGPU thanks to the way Babylon.js transpiles shader code. See [https://doc.babylonjs.com/advanced_topics/webGPU/webGPUWGSL](https://doc.babylonjs.com/advanced_topics/webGPU/webGPUWGSL)
    for more information on wGLSL and Babylon.js transpilation features.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebGPU**使用GLSL的一个变体，称为**wGLSL**，但由于Babylon.js非常注重保持向后兼容性，您可以选择使用wGLSL或继续用常规GLSL编写着色器——无论哪种方式，您都可以通过Babylon.js转换着色器代码的方式继续使用WebGPU。有关wGLSL和Babylon.js转换功能的更多信息，请参阅[https://doc.babylonjs.com/advanced_topics/webGPU/webGPUWGSL](https://doc.babylonjs.com/advanced_topics/webGPU/webGPUWGSL)。'
- en: Both HLSL and GLSL are syntactically related in flavor to the C/C++ family of
    programming languages, and though JavaScript is a much higher-level language,
    there should be enough familiar concepts for people familiar with it to gain a
    good starting position for learning GLSL. Coming from JavaScript, it’s probably
    the most important to keep in mind that, unlike JS, GLSL is strongly typed and
    doesn’t like trying to infer the types of variables and such on its own. There
    are other quirks to keep in mind, such as the need to add a `.` suffix to numbers
    when a floating-point variable is set to an integer value. This is a good segue
    to talk a little bit more about how shader programs are different from other software
    programs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: HLSL和GLSL在语法风格上与C/C++编程语言家族相关，尽管JavaScript是一种更高级的语言，但对于熟悉它的人来说，应该有足够熟悉的概念，以便为学习GLSL打下良好的基础。从JavaScript开始，最重要的是记住，与JS不同，GLSL是强类型的，并且不喜欢自己推断变量和此类数据的类型。还有其他需要注意的怪癖，例如，当浮点变量被设置为整数值时，需要给数字添加一个`.`后缀。这很好地过渡到更多地讨论着色器程序与其他软件程序的不同之处。
- en: 'Shaders, as a class of software, have several distinctive features:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一类软件，着色器有几个独特的特性：
- en: They are stateless. Because a given graphics processor (of which a graphics
    card might have thousands or millions available) might be tasked with rendering
    Instagram pics one moment, it could just as easily be rendering an email or text
    document the next. Any data needed by the shader, whether it’s a texture, a constant,
    or a uniform, must be either defined within the shader itself or passed into it
    at runtime.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是无状态的。因为一个特定的图形处理器（一个图形卡可能有数千或数百万个可用）可能在这一刻被分配渲染Instagram图片的任务，它同样可能在下一次渲染电子邮件或文本文档。着色器所需的所有数据，无论是纹理、常量还是统一变量，都必须在着色器内部定义或在运行时传递给它。
- en: There is no access to shared state or thread data – each process stands alone,
    executing with no knowledge of its neighbors.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有访问共享状态或线程数据的能力——每个进程独立运行，执行时对其邻居一无所知。
- en: Shader code is written to address the entire view or screen space, but the instructions
    that are given to each instance must be formulated in such a way that each instance
    gets the same directions yet produces the desired individual results.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器代码是针对整个视图或屏幕空间编写的，但给每个实例提供的指令必须以这种方式制定，即每个实例都得到相同的方向，但产生所需的个别结果。
- en: Between the first two items causing the third is the genesis of the reputation
    for the fiendish difficulty that shaders have gotten. Like everything, writing
    shader code is something that requires practice. Eventually, with practice, it
    will become easier and easier to slip into the shader mindset and solve increasingly
    more complex and difficult problems; you’ll soon be wondering what all the fuss
    was about! In the next section, you will learn about a few of the different ways
    to incorporate a custom shader into a project. Again, don’t sweat the next section
    too much if this is outside of your comfort zone – let it soak through you. The
    concepts we’re covering here will be useful later when we learn how to use the
    **Node Material Editor** (**NME**) to do all the heavy lifting of writing shader
    code while you focus on what you want to get done.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个项目之间，第三个项目的产生是着色器获得令人难以置信的难度声誉的起源。就像所有事情一样，编写着色器代码需要练习。最终，随着练习的深入，它将变得越来越容易，你将能够轻松地进入着色器思维模式，解决越来越复杂和困难的问题；你很快就会想知道所有这些喧嚣究竟是为了什么！在下一节中，你将了解将自定义着色器融入项目的几种不同方法。再次提醒，如果这超出了你的舒适区，不要过于担心下一节——让它慢慢渗透。我们在这里讨论的概念将在我们学习如何使用
    **节点材质编辑器**（**NME**）来编写着色器代码时变得非常有用，而你则可以专注于你想要完成的工作。
- en: Writing and Using Shaders in Babylon.js
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Babylon.js 中编写和使用着色器
- en: 'Being that shaders are defined using plain text, there are a lot of different
    ways to store and load shaders in a project. We’ll review some of the ways to
    accomplish this after we learn a bit about how shader code is structured. The
    **Create Your Own Shader** (**CYOS**) tool is the shader equivalent of the Babylon.js
    Playground and is just one way to write shader code for Babylon.js. Navigating
    to the **CYOS** URL at [https://cyos.babylonjs.com](https://cyos.babylonjs.com)
    shows the shader code on the left pane and a live preview of the output on the
    right:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于着色器是用纯文本定义的，因此在项目中存储和加载着色器有众多不同的方法。在学习了一些关于着色器代码结构的知识之后，我们将回顾一些实现这一目标的方法。**创建您的自己的着色器**（**CYOS**）工具是
    Babylon.js 操场（Babylon.js Playground）的着色器版本，并且是编写 Babylon.js 着色器代码的一种方式。访问 **CYOS**
    网址 [https://cyos.babylonjs.com](https://cyos.babylonjs.com) 可以在左侧面板看到着色器代码，并在右侧实时预览输出结果：
- en: '![Figure 11.4 – The Babylon.js Create Your Own Shader tool functions similarly
    to the BJS Playground'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.4 – The Babylon.js Create Your Own Shader tool functions similarly
    to the BJS Playground](img/Figure_11.04_B17266.jpg)'
- en: '](img/Figure_11.04_B17266.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.04_B17266.jpg](img/Figure_11.04_B17266.jpg)'
- en: Figure 11.4 – The Babylon.js Create Your Own Shader tool functions similarly
    to the BJS Playground
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – Babylon.js 创建您的自己的着色器工具的功能与 BJS 操场类似
- en: In the preceding screenshot, you can see that the shader code is defined for
    vertex and fragment shaders in the left-hand pane, while a live preview shows
    on the right. Starter templates can be selected from the dropdowns, along with
    different meshes to use in the preview.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到在左侧面板中定义了顶点和片段着色器的着色器代码，而实时预览显示在右侧。可以从下拉菜单中选择起始模板，以及用于预览的不同网格。
- en: Just like the Playground, you can save your work to a snippet server, or you
    can download a ZIP file containing the shader code embedded into a template HTML
    file. Also, just like the PG, the Play button compiles and runs live the results
    of your shader programs. That’s the overall mechanics and usage of the tool. Now,
    let’s see how it fits into what we’ve been learning about the different types
    of shaders.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就像操场一样，您可以将您的作品保存到片段服务器，或者下载一个包含嵌入模板 HTML 文件的着色器代码的 ZIP 文件。同样，就像 PG 一样，播放按钮会实时编译并运行您的着色器程序的结果。这就是工具的整体机制和用法。现在，让我们看看它是如何融入我们所学到的不同类型着色器的知识中的。
- en: Fragment and Vertex Shaders
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段着色器和顶点着色器
- en: 'Let’s remind ourselves of what the top section, the `constructor` function
    and the like, a shader program is required to have at least a definition for the
    `void main(void)` function because that is the function that is executed by the
    GPU. Outside of the main function, subroutines or helper functions are commonly
    used to help encapsulate and isolate code, just as you would do with any other
    well-written code that you may write. Inputs to the shader are specified at the
    top along with other declarations. Depending on the type of shader and how it
    is defined, there might be several different arbitrary declarations present, but
    two that are always provided are the `position` and `uv` attribute declarations.
    The former is a **Vector3**, while the latter is a **Vector2**; both represent
    data coming from the source mesh geometry:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提醒自己，顶部的部分，如 `constructor` 函数等，着色器程序至少需要为 `void main(void)` 函数提供一个定义，因为这是由
    GPU 执行的函数。在主函数之外，子程序或辅助函数通常被用来封装和隔离代码，就像你可能会对任何其他编写良好的代码所做的那样。着色器的输入在顶部指定，与其他声明一起。根据着色器的类型和定义方式，可能会有几个不同的任意声明，但始终提供的是
    `position` 和 `uv` 属性声明。前者是 **Vector3**，而后者是 **Vector2**；两者都代表来自源网格几何形状的数据：
- en: The local space `position` of the vertex is the coordinates relative to the
    mesh origin, not the world origin.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点的局部空间 `position` 是相对于网格原点的坐标，而不是世界原点。
- en: The `uv` attribute is the texture coordinates. It is so-called to avoid confusion
    with the `xy` coordinates outside of the texture space.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uv` 属性是纹理坐标。之所以这样称呼，是为了避免与纹理空间之外的 `xy` 坐标混淆。'
- en: 'Other declarations include the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 其他声明包括以下内容：
- en: A uniform four-by-four Matrix called `worldViewProjection` that contains the
    transformations needed to convert the vertex position from local into World and
    then into View (screen, or 2D) space.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个称为 `worldViewProjection` 的统一四乘四矩阵，它包含将顶点位置从局部转换为世界，然后转换为视图（屏幕或二维）空间所需的变换。
- en: A varying (reference type variable capable of being mutated or changed) `vUV`.
    This is one piece of (optional) data that’s passed to the fragment shader. It’s
    important for looking up pixel colors from a sampled texture.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可变（可变或更改的引用类型变量）`vUV`。这是传递给片段着色器的一份数据（可选），对于从采样纹理中查找像素颜色非常重要。
- en: The output of the Vertex shader is a Vector3, in the form of the `gl_Position`
    variable, and must be set in the shader before reaching the end of `main`. Its
    value is computed by applying the provided matrix transformation to the vertex
    position after any custom computations have been applied to the position value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器的输出是一个 Vector3，以 `gl_Position` 变量的形式，必须在 `main` 函数结束之前在着色器中设置。它的值是通过将提供的矩阵变换应用于位置值（在应用任何自定义计算之后）来计算的。
- en: Important note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A lot of detail about these concepts isn’t being covered here because otherwise,
    we wouldn’t be able to cover everything about other topics. However, these basics
    should be enough to help you start being able to read and understand shader code,
    and that’s the first step to attaining proficiency!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有涵盖这些概念的大量细节，否则我们就无法涵盖其他主题的所有内容。然而，这些基础知识应该足以帮助你开始能够阅读和理解着色器代码，这是达到熟练的第一步！
- en: The bottom part of the CYOS screen’s code panel is where the Fragment shader
    lives. Instead of receiving the vertex position of a mesh, the fragment shader
    receives a 2D screen position in the form of `varying vUV` and outputs a color
    to `gl_FragColor`. This color value represents the final color of the current
    pixel on the screen. When using textures with shaders, `textureSampler` references
    a loaded texture in the GPU memory, with the texture coordinates `vUV` used to
    look up the color value. These coordinates can be supplied by the mesh geometry
    (in the case of a material), view or screen coordinates (for post-processes or
    particles), by some computational process (as is the case for procedurally generated
    digital art), or with some combination of all three techniques. Change the dropdown
    selector labeled **Templates** to see more examples of how you can use shaders
    for fun and profit!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: CYOS屏幕代码面板的下半部分是片段着色器所在的位置。片段着色器不是接收网格的顶点位置，而是接收以`varying vUV`形式存在的2D屏幕位置，并将颜色输出到`gl_FragColor`。这个颜色值代表了屏幕上当前像素的最终颜色。当使用着色器中的纹理时，`textureSampler`引用GPU内存中加载的纹理，使用纹理坐标`vUV`来查找颜色值。这些坐标可以由网格几何形状（在材料的情况下）、视图或屏幕坐标（用于后期处理或粒子）、某些计算过程（如过程式生成的数字艺术）或这三种技术的某种组合提供。更改标记为**模板**的下拉选择器，以查看更多如何使用着色器用于娱乐和盈利的示例！
- en: Compute Shaders (New to v5!)
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算着色器（新到v5！）
- en: The availability of programmable shaders exposes the power of the modern GPU
    to everyday desktop applications. With the latest **WebGL2** and **WebGPU** standards
    becoming more and more commonly implemented by major web browser vendors, that
    power is now available to web applications too. The biggest **WebGPU** feature
    when it comes to shaders is a new generation that’s intended for general-purpose
    computation, called the **Compute shader**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可编程着色器的可用性展示了现代GPU在桌面应用程序中的强大功能。随着最新的**WebGL2**和**WebGPU**标准越来越普遍地被主要网络浏览器供应商实现，这种功能现在也适用于网络应用程序。在着色器方面，**WebGPU**最大的特性是新一代旨在通用计算的着色器，被称为**计算着色器**。
- en: For specific documentation on how to write and use **WebGPU Compute shaders**,
    go to [https://doc.babylonjs.com/advanced_topics/shaders/computeShader](https://doc.babylonjs.com/advanced_topics/shaders/computeShader).
    Vertex and fragment shaders are purposefully limited in the extent and scope as
    to what they can accomplish, especially when those tasks don’t directly involve
    Scene geometry. Compute shaders, on the other hand, are a way to run more arbitrary
    – though no less massively parallel – calculations and output. Let’s look at a
    concrete example of the types of problems that Compute shaders are good at solving.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何编写和使用**WebGPU计算着色器**的特定文档，请访问[https://doc.babylonjs.com/advanced_topics/shaders/computeShader](https://doc.babylonjs.com/advanced_topics/shaders/computeShader)。顶点和片段着色器在完成范围和范围上被有意限制，特别是当这些任务不直接涉及场景几何时。另一方面，计算着色器是一种运行更任意（尽管不是更少大规模并行）的计算和输出的方式。让我们看看计算着色器擅长解决的具体问题类型。
- en: In this scenario, we want to simulate the effects of water erosion on terrain.
    Things such as an ocean tide besieging a sandcastle or long-term weathering of
    mountains are more accurate when the underlying calculations have finer resolution
    – more particles involved means that each particle can represent a smaller and
    smaller piece of the overall fluid volume. There are a few things that make this
    scenario quite nice for Compute shaders. When modeling fluids, approximations
    are used to simplify calculations. As mentioned previously, the number and size
    of the individual calculation units are directly tied to the overall accuracy
    and performance of the simulation. If the simulation were a mural, the speed it
    is painted and the resolution or detail depend on how many “painters” are assigned
    to handle painting the mural. What makes a Compute shader the ideal choice is
    that vertex and fragment shaders have more limitations on how many, what types,
    and which data can be updated, whereas Compute shaders are capable of writing
    output (similar to a texture) that isn’t displayed directly onto the screen. They
    even make passing data back to the CPU from the GPU more practical, although it
    is still not a great idea if you can avoid it – passing any data in that direction
    will always be a slow operation. Additionally, the increased computing power makes
    more accurate but computationally intensive calculations available.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们想要模拟水侵蚀对地形的影响。例如，海洋潮汐围攻沙堡或长期风化作用下的山脉，当底层计算具有更高的分辨率时，这些情况会更准确——涉及的粒子越多，每个粒子就能代表整体流体体积越小的一部分。有几个因素使得这个场景非常适合使用计算着色器。在建模流体时，使用近似值来简化计算。如前所述，单个计算单元的数量和大小直接关系到整个模拟的准确性和性能。如果模拟是一幅壁画，其绘画速度和分辨率或细节取决于有多少“画家”被分配来处理壁画的绘制。计算着色器成为理想选择的原因是，顶点和片段着色器在可以更新多少、什么类型和哪些数据方面有更多的限制，而计算着色器能够写入输出（类似于纹理）而不直接显示在屏幕上。它们甚至使从
    GPU 向 CPU 传递数据变得更加实用，尽管如果你能避免的话，这仍然不是一个好主意——向那个方向传递任何数据都将是一个缓慢的操作。此外，增加的计算能力使得更准确但计算密集型的计算成为可能。
- en: This may not seem like a big deal, but it is. Being able to persist and then
    reference output of and from a compute shader allows for a huge amount of utility
    – it’s like Inspector Gadget and his signature catchphrase. Yell “Go Go Gadget
    Compute shader!” and anything can happen! The output from a compute shader can
    be used to drive a terrain height map, compute the values of a vector field, and
    much more.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不是什么大事，但实际上很重要。能够持续并引用计算着色器的输出和输入，可以带来巨大的实用性——就像 Inspector Gadget 和他的标志性口号。大喊“Go
    Go Gadget Compute shader！”然后任何事都可能发生！计算着色器的输出可以用来驱动地形高度图，计算矢量场的值，以及更多。
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See [https://playground.babylonjs.com/?webgpu#C90R62#12](https://playground.babylonjs.com/?webgpu%23C90R62%2312)
    to learn how to use a Compute shader to simulate erosion with a height map and
    dynamic terrain. Note the addition of `webgpu` to the query string – running **WebGPU**
    samples requires a browser with **WebGPU** support. As of April 2022, only Chrome
    and Edge Canary builds support **WebGPU** features. See [https://github.com/gpuweb/gpuweb/wiki/Implementation-Status](https://github.com/gpuweb/gpuweb/wiki/Implementation-Status)
    to view the latest implementation support and status in Chromium-based browsers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [https://playground.babylonjs.com/?webgpu#C90R62#12](https://playground.babylonjs.com/?webgpu%23C90R62%2312)
    了解如何使用计算着色器通过高度图和动态地形模拟侵蚀。注意查询字符串中添加了 `webgpu` —— 运行 **WebGPU** 示例需要支持 **WebGPU**
    的浏览器。截至 2022 年 4 月，只有 Chrome 和 Edge Canary 版本支持 **WebGPU** 功能。查看 [https://github.com/gpuweb/gpuweb/wiki/Implementation-Status](https://github.com/gpuweb/gpuweb/wiki/Implementation-Status)
    了解基于 Chromium 的浏览器中最新实现支持和状态。
- en: '**Compute shaders** require **WebGPU** and carry with them a great deal of
    complexity, but some problems are worth that added complexity. Able to perform
    massive numbers of calculations in parallel, Compute shaders are different from
    vertex or fragment shaders because they can write to textures or other storage
    buffers to read and write values from that can then be used by other processes
    in the rendering pipeline. Still nascent in its eventual ascendancy to widespread
    adoption and replacement of **WebGL2**, and with support only beginning to appear
    in major web browsers, **WebGPU** and **Compute shaders** are technologies worth
    getting familiar with sooner rather than later.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算着色器**需要**WebGPU**，并且伴随着大量的复杂性，但一些问题值得这种额外的复杂性。能够并行执行大量计算，计算着色器与顶点或片段着色器不同，因为它们可以写入纹理或其他存储缓冲区，从而读取和写入可以由渲染管线中的其他进程使用的值。尽管它在最终上升至广泛采用和取代**WebGL2**的过程中仍处于起步阶段，并且仅在主要网络浏览器中开始出现支持，**WebGPU**和**计算着色器**是值得尽早熟悉的技术。'
- en: Continuing the Shader Code Journey
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续着色器代码之旅
- en: It mentioned earlier, the topic of shaders is a vast and complex enough topic
    to warrant its own book rather than just a chapter. Fortunately, books such as
    those do exist, and one of the best is *The Book of Shaders*, by **Patricio Gonzalez
    Vivo** and **Jen Lowe**. Completely free and accessible at [https://thebookofshaders.com](https://thebookofshaders.com),
    *The Book of Shaders* describes itself as “a gentle step-by-step guide through
    the abstract and complex universe of Fragment shaders,” and it’s a case where
    the description closely matches reality. As it says, the book focuses on Fragment
    shaders only, but its wider value comes from the immersion and practices it provides
    for thinking in shader code. Filled with self-executing examples and exercises,
    it won’t take long to start having fun and being productive with shaders!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，着色器这个主题足够广泛和复杂，足以成为一本书的主题，而不仅仅是章节。幸运的是，这样的书确实存在，其中最好的之一是**Patricio Gonzalez
    Vivo**和**Jen Lowe**所著的《着色器之书》。它完全免费，可在[https://thebookofshaders.com](https://thebookofshaders.com)访问。《着色器之书》自称是“通过片段着色器的抽象和复杂宇宙的温和逐步指南”，并且描述与实际情况非常接近。正如它所说，这本书只关注片段着色器，但其更大的价值来自于它提供的着色器代码思维沉浸和实践。书中充满了自执行示例和练习，很快你就可以开始享受并有效地使用着色器了！
- en: 'Let’s recap on the different types of shaders and what they are used for with
    this handy table:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这张实用的表格回顾一下不同类型的着色器及其用途：
- en: '![](img/Table_11.01_B17266.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Table_11.01_B17266.jpg](img/Table_11.01_B17266.jpg)'
- en: 'With how easy WebGL2 makes it to expose shader logic and GPU features in the
    web browser, there are many tools and resources to explore in your journey of
    learning shaders. Maybe your experience is more on the design and art side of
    things, and the idea of writing code could be intimidating or otherwise off-putting
    in some way. Perhaps it’s simply difficult to keep in mind both the goal of what
    you want to accomplish while holding the concepts of vertex and fragment shader
    syntax. Or it could be that you’re unsure of how to write a particular shader
    effect and need to experiment and explore to discover how to proceed. All these
    reasons, plus many more not listed, are good reasons to take a good long look
    at one of the flagship features of Babylon.js: the **Node Material Editor** (**NME**).
    This is what we are going to do in the next section.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL2使得在网页浏览器中暴露着色器逻辑和GPU功能变得非常容易，因此在学习着色器的旅程中有很多工具和资源可以探索。也许你的经验更多在设计艺术方面，编写代码的想法可能让你感到害怕或以其他方式令人望而却步。也许简单地同时记住你想要达成的目标以及顶点和片段着色器语法的概念很困难。或者可能是你不确定如何编写特定的着色器效果，需要实验和探索以发现如何继续。所有这些原因，以及许多未列出的原因，都是仔细研究Babylon.js的一个旗舰功能——**节点材质编辑器**（**NME**）的好理由。这就是我们在下一节将要做的。
- en: Shader Programming with the Node Material Editor
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用节点材质编辑器进行着色器编程
- en: As something that has been referred to numerous times throughout this book,
    the NME may have taken on an almost mythic status as a productivity tool. Its
    plug-and-play, drag-and-drop nature allows just about anyone to assemble shaders
    using visual blocks. It democratizes the GPU in the seamless way it integrates
    with the Inspector. Its simple deployment in tandem with the Playground provides
    a short runway from fancy to flight. The NME may just be about the best thing
    to happen since sliced bread met butter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在本书中多次被提及，NME可能已经获得了几乎神话般的地位，成为一款生产力工具。它的即插即用、拖放特性使得几乎任何人都可以使用视觉块来组装着色器。它以无缝的方式与检查器集成，民主化了GPU。它与Playground的简单部署提供了一个从复杂到实用的短跑道。NME可能是自面包遇到黄油以来最好的事情。
- en: All these statements are true, except the part about the NME being better than
    sliced bread and butter – that one isn’t. It’s better than sliced bread and butter,
    falling just short of being better than sliced bread alone. It’s a thin leavened
    line, but it’s one worth baking. Hyperbole aside, the NME is truly one of the
    most powerful, if not the most powerful, tools in the Babylon.js toolbox.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些陈述都是真实的，除了关于NME比面包和黄油更好的部分——这一点并不成立。它比面包和黄油更好，但仅仅略逊于单独的面包。这是一条薄薄的发酵线，但值得烘焙。抛开夸张的说法，NME确实是Babylon.js工具箱中最强大，如果不是最强大的工具之一。
- en: In this section, we’re going to learn how to get the most out of the NME. By
    the end, you’ll find it easy to “think in nodes”! First, we’ll explore how to
    create and apply a **NodeMaterial** to a mesh. Next, we’ll explore using the NME
    to create procedural textures. Finally, we’ll wrap things up with a quick look
    at how to use NME to create a Post Process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何充分利用NME。到结束时，你会发现“以节点思考”变得很容易！首先，我们将探索如何创建和应用**NodeMaterial**到网格上。接下来，我们将探索使用NME创建程序纹理。最后，我们将简要看看如何使用NME创建后处理。
- en: Using the NME to Build the Planet Earth Material
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NME构建地球材质
- en: 'Sometimes, when learning something new, it can be helpful to have a concrete
    example to work toward, with the example being the end goal to reach. Other times,
    it can be more illuminating to begin not with the example of a finished product,
    but with an atomic subset of that final goal. The goal we’re going to start with
    – our first atomic subset – will be simple: create a new NodeMaterial that renders
    a texture onto a sphere mesh. Easy, right?'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在学习新事物时，有一个具体的例子去努力实现，而这个例子就是最终的目标，这可能会很有帮助。其他时候，从最终目标的原子子集开始，而不是从成品例子开始，可能会更加启发人心。我们将要开始的目标——我们的第一个原子子集——将会很简单：创建一个新的NodeMaterial，将纹理渲染到球体网格上。容易，对吧？
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike most rhetorical questions framed similarly, the answer to the preceding
    question is an unambiguous, full-throated “YES!”. If it isn’t already apparent
    that Babylon.js places an incredibly high emphasis on ease of use, it would be
    helpful to go back and re-read (or simply read for the first time) the previous
    chapters of this book. It’s OK, no one’s judging you for skimming or skipping!
    Well, OK. Maybe a little bit. But not much.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数类似形式的修辞问题不同，前一个问题答案是明确且响亮的“YES！”。如果之前没有明显地感觉到Babylon.js对易用性给予了极高的重视，那么回到这本书的前几章重新阅读（或者简单地第一次阅读）可能会有所帮助。没关系，没有人会因为你浏览或跳过而评判你！好吧，好吧。也许有一点。但不多。
- en: As we work through this chapter, we’re going to start by covering a lot more
    details on the mechanics of how to accomplish various tasks with the NME, but
    as we make progress through the following sections, we’ll have to start zooming
    out from those mechanical details to make sure we leave enough space and time
    for bigger-picture topics. As always, the Babylon.js docs are a great place to
    learn more about the topics we’re covering, with great material on the NME that
    includes combination Playground and NME examples for a wide variety of tasks.
    The BJS forums are a great place to view examples from the community, as well
    as to solicit feedback and ask questions. There’s even a thread dedicated to NME
    examples at [https://forum.babylonjs.com/t/node-materials-examples](https://forum.babylonjs.com/t/node-materials-examples)!
    Let’s get started.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章的过程中，我们将首先详细介绍如何使用 NME 完成各种任务的机制，但随着我们进入以下部分，我们将不得不从这些机械细节中退出来，以确保我们有足够的空间和时间来探讨更宏观的主题。一如既往，Babylon.js
    文档是学习我们正在讨论的主题的绝佳地方，其中包括关于 NME 的丰富材料，包括组合游乐场和 NME 示例，用于各种任务。BJS 论坛是查看社区示例、征求反馈和提问的好地方。甚至还有一个专门用于
    NME 示例的线程，[https://forum.babylonjs.com/t/node-materials-examples](https://forum.babylonjs.com/t/node-materials-examples)！让我们开始吧。
- en: NME Overview
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NME 概述
- en: 'Navigate to [https://nme.babylonjs.com](https://nme.babylonjs.com); the default
    material mode “blank slate” is the initial node graph to be loaded. Broken down
    into four functional areas with a fifth preview pane, the first pane – the left-hand
    side vertical column – hosts a searchable list of different nodes that can be
    placed into the center pane of the work canvas:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 [https://nme.babylonjs.com](https://nme.babylonjs.com)；默认材质模式“空白画布”是初始要加载的节点图。分为四个功能区域和一个第五个预览面板，第一个面板
    – 左侧的垂直列 – 包含可以放置到工作画布中间面板的不同节点的可搜索列表：
- en: '![Figure 11.5 – The default Node Material Editor view'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.5 – 默认节点材质编辑器视图'
- en: '](img/Figure_11.05_B17266.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.05_B17266.jpg)'
- en: Figure 11.5 – The default Node Material Editor view
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 默认节点材质编辑器视图
- en: In the preceding screenshot, the left-hand pane contains the list of nodes.
    The center pane work canvas is where nodes and their connections are displayed,
    while the right-hand pane shows contextual properties for the selected item. Note
    the render preview pane.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，左侧面板包含节点列表。中间面板的工作画布是显示节点及其连接的地方，而右侧面板显示所选项目的上下文属性。注意渲染预览面板。
- en: The right-hand pane displays a contextual list of properties that can be modified,
    or if nothing is selected, the snippet properties and options. Tucked into the
    bottom (scroll down if it’s not visible initially) of the **Property** pane is
    the **Preview** panel. Pop that out into its own window right away – being able
    to immediately see the effects of making a change is one of the keys to success
    in this type of development. The bottom well or gutter, depending on how you want
    to term it, contains console output from the shader compilation process of the
    node graph – if the bottom line is red, then your nodes aren’t compiling!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧面板显示可以修改的上下文属性列表，如果没有选择任何内容，则显示片段属性和选项。在**属性**面板的底部（如果最初不可见，请向下滚动）中藏有**预览**面板。立即将其弹出到一个自己的窗口中
    – 能够立即看到更改的效果是这种类型开发成功的关键之一。底部的水井或沟槽，根据您如何称呼它，包含节点图着色器编译过程的控制台输出 – 如果最后一行是红色，则您的节点没有编译！
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Sometimes, it can be tough to tell if a particular change is extremely subtle
    or whether it has no effect at all. Always make sure to check that your most recent
    console output isn’t colored red or contains an error; otherwise, you may mistake
    a broken node with an ineffectual change!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，很难判断某个特定的更改是否非常微妙，或者它是否完全没有效果。始终确保检查您最新的控制台输出是否没有着色为红色或包含错误；否则，您可能会将损坏的节点与无效的更改混淆！
- en: Background Context
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景上下文
- en: Nodes are connected by lines between specific connector ports on the two involved
    nodes. Any given node represents a particular operation that can be performed
    on a series of inputs and outputs, connected by dragging lines from the former
    to the latter. The graph of nodes and their connection follows two simple rules
    that result in strikingly complex behaviors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 节点通过在两个相关节点上特定连接端口之间的线条连接。任何给定的节点都代表可以在一系列输入和输出上执行的操作，通过从前者拖动线条到后者来连接。节点及其连接的图遵循两个简单的规则，这些规则导致产生惊人的复杂行为。
- en: First, nodes always accept input on the left-hand side connectors and output
    values on their right. What happens inside the node between the input and output
    is nobody’s business but the nodes’. An interesting implication of this is that
    uniforms, attributes, constants, or other externally provided data do not have
    input connectors. Rather, values are set via code, the Inspector, or at design
    time in the property pane. Conversely, a few nodes only contain inputs and have
    no output connector. These are the endpoints for the node’s shader code generation;
    in other words, they represent the return value of the applicable shader, such
    as a color for the fragment shader and a position vector for the vertex. Since
    they are the final result of the shader calculations, they must always be the
    last item in the node graph.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，节点总是接受左侧连接器的输入，并在其右侧输出值。节点内部在输入和输出之间发生的事情是节点的私事。这个有趣的影响是，统一体、属性、常量或其他外部提供的数据没有输入连接器。相反，值通过代码、检查器或在设计时的属性面板中设置。相反，一些节点只包含输入而没有输出连接器。这些是节点着色器代码生成的端点；换句话说，它们代表适用着色器的返回值，例如片段着色器的颜色和顶点着色器的位置向量。由于它们是着色器计算的最后结果，它们必须始终是节点图中最后一个项目。
- en: The second rule for node graphs, and following from the first, is that only
    nodes connected to an output node are included in the generated shader code. Remember,
    the final goal is to generate a vector for the vertex shader and a color for the
    fragment. This means that a properly formed node graph executes a sequential path
    from start to finish (usually left to right), but which is defined by that path
    traced from end to start (the opposite, or right to left).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 节点图的第二规则，并且遵循第一条规则，是只有连接到输出节点的节点才包含在生成的着色器代码中。记住，最终目标是生成用于顶点着色器的向量和用于片段的颜色。这意味着一个正确构建的节点图执行从开始到结束的顺序路径（通常是左到右），但由从终点到起点的路径定义（相反，或右到左）。
- en: This mismatch in mental models (try saying that five times fast!) can sometimes
    make it difficult to visualize the steps needed to get to a particular goal line.
    That’s why it’s important to make things easy to change or add to without having
    to make unrelated changes to the application that are needed just to be able to
    make a change. In our case, we’re going to structure our work so that we can incrementally
    build an ultra-high detail and quality Planet Earth material.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种心理模型的不匹配（试着快速说五遍！）有时会使得可视化达到特定目标所需的步骤变得困难。这就是为什么在不需要对应用程序进行无关更改的情况下，使事物易于更改或添加变得重要的原因。在我们的案例中，我们将构建我们的工作结构，以便我们可以逐步构建一个超高细节和质量的地球材料。
- en: Back to the NME window, drag out the **fragment** and **vertex** output nodes
    out to the right to make room for the new nodes we’re going to add. Make sure
    that the render preview is set to **Sphere**, and while you’re at it, pop the
    preview out into a separate window if you haven’t done that yet. Now, we’re ready
    to accomplish our first micro-goal of learning how to add and use textures.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 回到NME窗口，将**片段**和**顶点**输出节点拖到右边，为新添加的节点腾出空间。确保渲染预览设置为**球体**，并且如果你还没有这样做，将预览弹出到一个单独的窗口。现在，我们准备好实现我们的第一个微观目标——学习如何添加和使用纹理。
- en: Adding a Texture to the Material
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将纹理添加到材质中
- en: 'In the default configuration for the Node Material Editor’s Material mode,
    the inputs for the vertex shader are `mesh.position`, `World Matrix`, and `View
    Projection Matrix`. A series of `texture` to filter the list down to display the
    `mesh.uv` node hooked up to the `uv` connector of the Texture block will be created.
    In general, this is a consistent pattern – if the required inputs for a node block
    aren’t present, they will be added automatically:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点材质编辑器的材质模式默认配置中，顶点着色器的输入为`mesh.position`、`World Matrix`和`View Projection
    Matrix`。将创建一系列`texture`以过滤列表并显示连接到纹理块`uv`连接器的`mesh.uv`节点。一般来说，这是一个一致的模式——如果节点块所需的输入不存在，它们将自动添加：
- en: '![Figure 11.6 – Dragging the Texture node onto the surface also adds the mesh.uv
    value. This is used to select the portion of the texture corresponding to the
    mesh vertex'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6 – 将纹理节点拖放到表面上也会添加mesh.uv值。这用于选择与网格顶点对应的纹理部分](img/Figure_11.06_B17266.jpg)'
- en: '](img/Figure_11.06_B17266.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.06_B17266.jpg](img/Figure_11.06_B17266.jpg)'
- en: Figure 11.6 – Dragging the Texture node onto the surface also adds the mesh.uv
    value. This is used to select the portion of the texture corresponding to the
    mesh vertex
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 将纹理节点拖动到表面也会添加 mesh.uv 值。这个值用于选择与网格顶点对应的纹理部分
- en: 'The preceding screenshot shows the setup, but it also shows our next step:
    dragging out the source input port on `Texture` block, as depicted in the previous
    screenshot. It’s a good practice to tidy as we go along, so rename the node by
    selecting the node if it isn’t already and changing the `baseTexture`. Half of
    our initial objective has now been achieved by bringing in the texture. Now, we
    need to paint it onto the preview mesh.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了设置，但也显示了我们的下一步：将 `Texture` 块的源输入端口拖动出来，如前一个截图所示。边做边整理是一个好习惯，所以如果节点尚未重命名，请选择节点并更改
    `baseTexture`。通过引入纹理，我们已经实现了初始目标的一半。现在，我们需要将它绘制到预览网格上。
- en: 'Accomplishing this is incredibly easy, but it’s valuable to remember the underlying
    mechanisms involved since they will be important soon. Recall that the vertex
    shader is passed the mesh position and a UV texture coordinate corresponding to
    that vertex location, which passes the `UV` coordinates into the fragment shader.
    Now, we need to sample the texture to set the fragment shader’s final color, and
    we do that by dragging the `rgb` output of the `rgb` input of the **FragmentOutput**
    node. Look at the Render Preview; a familiar-looking globe should be visible:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一点非常简单，但记住涉及的底层机制是有价值的，因为它们很快就会变得重要。回想一下，顶点着色器传递了网格位置和对应于该顶点位置的 UV 纹理坐标，这些坐标将
    `UV` 坐标传递到片段着色器。现在，我们需要采样纹理以设置片段着色器的最终颜色，我们通过拖动 `FragmentOutput` 节点的 `rgb` 输出的
    `rgb` 输入来实现这一点。查看渲染预览；应该可以看到一个看起来熟悉的地球：
- en: '![Figure 11.7 – The Render preview of the Planet Earth material after adding
    baseTexture and sampling it for FragmentOutput](img/Figure_11.07_B17266.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 添加 baseTexture 并对其采样以用于片段输出的地球材料的渲染预览](img/Figure_11.07_B17266.jpg)'
- en: Figure 11.7 – The Render preview of the Planet Earth material after adding baseTexture
    and sampling it for FragmentOutput
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 添加 baseTexture 并对其采样以用于片段输出的地球材料的渲染预览
- en: 'You can check your work-in-progress against the snippet at #YPNDB5\. If your
    preview doesn’t match the preceding screenshot perfectly, it’s OK – it’s just
    a preview at this point and the important thing is that you can see the texture
    on the sphere. Our first mission is accomplished! What’s next? It’s time to start
    adding nodes to our graph that will use additional textures to add further detail
    to our Planet Earth material.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以将您的作品与 #YPNDB5 中的片段进行比较。如果您的预览与前面的截图不完全匹配，没关系——这只是一个预览，重要的是您可以看到球体上的纹理。我们的第一个任务已经完成！接下来是什么？现在是时候开始添加节点到我们的图中，这些节点将使用额外的纹理来为我们的地球材料添加更多细节。'
- en: Mixing Clouds
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合云层
- en: Start by adding another Texture node and ImageSource to the canvas. Name them
    `cloudTexture` and `cloudTextureSource` and upload or link to the file at [https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/textures/2k_earth_clouds.jpg](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/textures/2k_earth_clouds.jpg)
    to load the cloud texture into the design surface. The simplest way to get the
    clouds overlaid on top of the base texture is to add the colors from each texture,
    so drag an `Mix Cloud and Base Textures`. This highlights an important property
    of nodes that may catch those who aren’t familiar with this type of editing surface
    off guard – type matching.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在画布上添加另一个纹理节点和图像源。将它们命名为 `cloudTexture` 和 `cloudTextureSource`，并将文件上传或链接到[https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/textures/2k_earth_clouds.jpg](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/textures/2k_earth_clouds.jpg)，以便将云纹理加载到设计表面。将云层叠加到基础纹理上的最简单方法是将每个纹理的颜色混合在一起，因此拖动一个
    `Mix Cloud and Base Textures`。这突显了节点的一个重要属性，可能会让那些不熟悉这种编辑表面的人感到意外——类型匹配。
- en: When the node is initially added to the canvas, both the input and output ports
    are a solid red color, indicating that the type of input and output has yet to
    be designated. In this case, the possible types could include a Vector of 2, 3,
    or even 4 elements (or a color comprised of the same number), a single scalar
    number, or even a matrix. Which type the block turns into depends on the first
    connection made to the node. Connect the `rgb` ports of the two textures to the
    separate inputs of the node and replace the fragment shader’s output with the
    output from the Mix Cloud and Base Textures node to finish the operation. The
    clouds are visible on the render preview, but they’re a bit faint and hard to
    see.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点最初添加到画布上时，输入和输出端口都是实心的红色，这表明输入和输出的类型尚未指定。在这种情况下，可能的类型可能包括2、3或4个元素的向量（或由相同数量的颜色组成的颜色），一个单一的标量数字，甚至是一个矩阵。块变成哪种类型取决于节点第一次连接的类型。将两个纹理的`rgb`端口连接到节点的单独输入，并将片段着色器的输出替换为混合云彩和基础纹理节点的输出以完成操作。云彩在渲染预览中可见，但它们有点淡，难以看清。
- en: 'This can easily be fixed by applying a scaling factor to the cloud color before
    it is mixed with the base texture color. This mixing of colors is a very common
    operation, especially more so when we move on to the next section, *Procedural
    Textures and the NME*. Add a Float input block and name it `cloudBrightness`.
    Give it an initial value of `1.25` or so and then use it as the input factor to
    a new Scale node that you’ll also add to the canvas. Name that node `Scale Cloud
    Levels` and connect the other input to the output of the `cloudTexture` node.
    The output of the `Scale Cloud Levels` node replaces the input to the `Mix Cloud
    and Base Textures` node:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在混合到基础纹理颜色之前对云彩颜色应用一个缩放因子来轻松修复。这种颜色的混合是一个非常常见的操作，尤其是在我们进入下一节，*程序纹理和NME*时更是如此。添加一个浮点输入块，并将其命名为`cloudBrightness`。给它一个初始值约为`1.25`，然后将其用作新添加到画布上的缩放节点的输入因子。将这个节点命名为`Scale
    Cloud Levels`，并将另一个输入连接到`cloudTexture`节点的输出。`Scale Cloud Levels`节点的输出将替换`Mix Cloud
    and Base Textures`节点的输入：
- en: '![Figure 11.8 – (a) After adding the cloud texture and a scale factor to the
    base texture color, clouds can be seen floating over a serene Planet Earth. (b)
    The node material graph for mixing and scaling the cloud texture with base Earth
    texture. The cloudBrightness value can be set to a value that matches the desired
    look and feel of the clouds](img/Figure_11.08_B17266.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – (a) 在添加云彩纹理和缩放因子到基础纹理颜色后，可以看到云彩在宁静的地球上方漂浮。(b) 混合和缩放云彩纹理与基础地球纹理的节点材质图。云彩亮度值可以设置为与云彩所需的外观和感觉相匹配的值](img/Figure_11.08_B17266.jpg)'
- en: Figure 11.8 – (a) After adding the cloud texture and a scale factor to the base
    texture color, clouds can be seen floating over a serene Planet Earth. (b) The
    node material graph for mixing and scaling the cloud texture with base Earth texture.
    The cloudBrightness value can be set to a value that matches the desired look
    and feel of the clouds
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – (a) 在添加云彩纹理和缩放因子到基础纹理颜色后，可以看到云彩在宁静的地球上方漂浮。(b) 混合和缩放云彩纹理与基础地球纹理的节点材质图。云彩亮度值可以设置为与云彩所需的外观和感觉相匹配的值
- en: 'The result should look like the first screenshot. If it doesn’t, compare your
    node graph to the second screenshot or to the snippet at #YPNDB5#1 to see what
    might be different between them. Once you’re happy with the output, it would be
    a good idea to save the snippet as a unique URL.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像第一张截图。如果它不是这样，请比较你的节点图与第二张截图或#YPNDB5#1中的片段，看看它们之间可能有什么不同。一旦你对输出满意，保存片段为唯一的URL会是一个好主意。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While working on something with the NME, it’s quickest to save snippets as URLs
    until you are ready to download the definition file and use it in your project.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在使用NME（NME未知）处理某个项目时，最快的方式是将片段保存为URL，直到你准备好下载定义文件并在你的项目中使用它。
- en: Our **Planet Earth Material** is looking pretty good now, but what is cooler
    than a boring old static texture? An animated texture! Let’s animate the clouds
    to give our material some life.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**地球材质**现在看起来相当不错，但有什么比无聊的静态纹理更酷的呢？一个动态纹理！让我们让云彩动起来，给我们的材质增添一些活力。
- en: Framing Animations
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架动画
- en: When we think about animations, it’s easy to forget that there are many different
    methods of animating things in a scene. One of the simplest, most straightforward
    means is to manipulate the texture coordinates (the `uv` value) over time. Furthermore,
    by changing just the `u` (or *X*-axis) value, the texture will be shifted in an
    East-to-West or West-to-East fashion, similar to how it might look for a geostationary
    satellite!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑动画时，很容易忘记场景中有很多不同的动画方法。其中最简单、最直接的方法是在时间上操作纹理坐标（`uv` 值）。此外，只需改变 `u`（或 *X*
    轴）值，纹理就会以从东到西或从西到东的方式移动，这可能与地球同步卫星的外观相似！
- en: Search for and add a `timeScaleFactor` in the `scaleSceneTime` node, we can
    control the precise speed of the animation at design and runtime.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `scaleSceneTime` 节点中搜索并添加 `timeScaleFactor`，我们可以在设计和运行时控制动画的精确速度。
- en: Important note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Why are we using Time instead of Delta Time? Remember, shaders have no memory
    of past events. They only deal with the data passed in, and the data passed in
    doesn’t persist between frames. Therefore, instead of storing the delta time and
    adding it to the `u` coordinate, we use total scene time and scale.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用时间而不是时间差？记住，着色器没有对过去事件的记忆。它们只处理传入的数据，而传入的数据在帧之间不会持续。因此，我们不是存储时间差并将其添加到
    `u` 坐标，而是使用总场景时间和比例。
- en: 'It’s important to keep a node graph readable, as much for your future self
    as for others reading it. One great way to do that is to organize nodes into collapsible
    Frames. Arrange the three Time, scale, and Multiply nodes close to each other,
    then hold down the *Shift* key while clicking and dragging a box around the three
    nodes to create a Frame:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 保持节点图可读性很重要，这不仅是为了你未来的自己，也是为了阅读它的人。做到这一点的一个很好的方法是将节点组织成可折叠的框架。将三个时间、比例和乘法节点靠近排列，然后按住
    *Shift* 键，同时点击并拖动一个框围绕三个节点以创建一个框架：
- en: '![Figure 11.9 – The SceneTimeScaled frame encapsulates the logic for exposing
    an animation frame counter to the rest of a node graph. This is the expanded form
    of the frame](img/Figure_11.09_B17266.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – SceneTimeScaled 框架封装了将动画帧计数器暴露给节点图其余部分的逻辑。这是框架的展开形式](img/Figure_11.09_B17266.jpg)'
- en: Figure 11.9 – The SceneTimeScaled frame encapsulates the logic for exposing
    an animation frame counter to the rest of a node graph. This is the expanded form
    of the frame
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – SceneTimeScaled 框架封装了将动画帧计数器暴露给节点图其余部分的逻辑。这是框架的展开形式
- en: Frames are an easy and fast way to make a complex node graph more manageable,
    much as a function helps to separate and isolate pieces of code from each other.
    The `SceneTimeScaled` frame (or any frame) can even be reused across different
    Node Materials by downloading its JSON definition, then using the `cloudTexture`
    U coordinate.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 框架是一种简单快捷的方法，可以将复杂的节点图变得更加易于管理，就像函数有助于将代码片段彼此分离和隔离一样。`SceneTimeScaled` 框架（或任何框架）甚至可以通过下载其
    JSON 定义，然后使用 `cloudTexture` U 坐标在不同的节点材料之间重用。
- en: 'Unlike when we mixed the cloud texture with the base texture where everything
    involved is of the same type, we need to be able to change a single element of
    a Vector2 value. First, we’ll need to split the source vector into its components
    before adding the `scaledSceneTime` value to the `x` component. Then, we’ll recombine
    the Vector and hook it into the `cloudTexture` UV input:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们将云纹理与基础纹理混合时涉及的所有内容都是同一类型不同，我们需要能够改变 Vector2 值的单个元素。首先，我们需要将源向量拆分成其组成部分，然后在
    `x` 组件中添加 `scaledSceneTime` 值。然后，我们将重新组合向量并将其连接到 `cloudTexture` UV 输入：
- en: '![Figure 11.10 – Connecting the SceneTimeScaled frame with the u (x) texture
    coordinate using the Vector merger and Vector Splitter nodes](img/Figure_11.10_B17266.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 使用向量合并和向量拆分节点将 SceneTimeScaled 框架与 u (x) 纹理坐标连接](img/Figure_11.10_B17266.jpg)'
- en: Figure 11.10 – Connecting the SceneTimeScaled frame with the u (x) texture coordinate
    using the Vector merger and Vector Splitter nodes
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 使用向量合并和向量拆分节点将 SceneTimeScaled 框架与 u (x) 纹理坐标连接
- en: When this is connected, pull up the render preview and marvel at the slowly
    moving banks of clouds over serene blue oceans. If you don’t see the expected
    results, check the output well to make sure the last (current) line isn’t an error
    or in red. If needed, compare your NME graph with the one at T7BG68#2 to see what
    you’re doing differently.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接完成后，打开渲染预览，惊叹于在宁静的蓝色海洋上缓慢移动的云层。如果你没有看到预期的结果，仔细检查输出，确保最后一行（当前行）不是一个错误或红色。如果需要，将你的
    NME 图与 T7BG68#2 中的图进行比较，看看你做了什么不同。
- en: There’s much more to the NME material mode than what we’ve accomplished in just
    a few short paragraphs. In that short span of text, we were able to create a nice
    render effect of an animated Planet Earth globe using the NME in **Material Mode**
    and with high-resolution textures provided by the kind folks at NASA. Dragging
    nodes out onto the canvas is fast becoming a familiar activity as we learned how
    to mix textures into a final Fragment Color, and even animate the cloud cover.
    Using built-in **Time** counters and **Vector Splitter** and **Merger** nodes
    will become second nature to us with practice and experience. There’s more to
    be covered than just how to map a texture onto a mesh with the NME, though. In
    the next section, we’ll take away the **Vertex shader** and focus on the **Fragment
    shader** as we finally learn how our Radar Procedural Texture is built (see [*Chapter
    9*](B17266_09_Final_AM.xhtml#_idTextAnchor186), *Calculating and Displaying Scoring
    Results*, for more information on how this fits into the game).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: NME 材料模式的内容远不止我们在短短几段文字中所取得的成就。在那短短的文字空间里，我们能够利用 NME 在 **材料模式** 下创建一个动画地球仪的渲染效果，并使用来自
    NASA 的好心人提供的高分辨率纹理。将节点拖拽到画布上正变得越来越熟悉的活动，因为我们学会了如何将纹理混合到最终的片段颜色中，甚至可以动画化云层。通过练习和经验，使用内置的
    **时间** 计数器和 **向量分割器** 以及 **合并器** 节点将变得像呼吸一样自然。然而，NME 不仅仅能将纹理映射到网格上，还有更多内容需要探讨。在下一节中，我们将移除
    **顶点着色器**，专注于 **片段着色器**，以便我们最终了解我们的雷达程序纹理是如何构建的（更多信息请参阅 [*第 9 章*](B17266_09_Final_AM.xhtml#_idTextAnchor186)，*计算和显示评分结果*，了解这是如何融入游戏的）。
- en: Procedural Textures and the NME
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序纹理和 NME
- en: In most specialized fields of study, a particularly hard foundational subject
    for the field at hand is often given to students early on in their journeys to
    weed or wash out students from the program. It sounds harsh, but exposing pupils
    early on to the realities of their chosen field can be a valuable way to save
    time and effort on both the students’ and teacher’s behalf. This part of the chapter
    is *not* intended to have that effect because presumably, you’re here by choice
    and by interest, and this isn’t a gatekeeping exercise, it’s an inclusive one.
    The **Procedural Texture** mode of the NME will still contain the vertex shader
    output – and it is still required to be present on the canvas – but our attention
    will be focused on the Fragment shader, because what else is better equipped to
    process a bunch of arbitrary pixels all at the same time than the **Fragment shader**?
    Nothing! In the case of procedural textures, the Fragment shader outputs to a
    texture buffer instead of the screen buffer – which is what a post-process uses.
    That texture, as we’ve seen with the Radar texture, can then be applied to various
    material texture slots in the scene for rendering.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数专业研究领域，一个特别困难的学科基础往往是早期就交给学生，以此来筛选或淘汰那些可能不太自信的学生。听起来很严厉，但让学生早期接触他们选择领域的现实可以是一种节省时间和精力的有价值方式，既对学生也有利于教师。本章的这一部分
    **不是** 为了达到那种效果，因为假设你是出于选择和兴趣而在这里，这不是一个门槛练习，而是一个包容性的练习。NME 的 **程序纹理** 模式仍然包含顶点着色器的输出
    – 并且它仍然需要在画布上存在 – 但我们的注意力将集中在片段着色器上，因为还有什么比 **片段着色器** 更适合同时处理一大堆任意像素呢？没有！在程序纹理的情况下，片段着色器输出到一个纹理缓冲区而不是屏幕缓冲区
    – 这正是后处理所使用的。正如我们通过雷达纹理所看到的，这个纹理然后可以被应用到场景中的各种材质纹理槽位上进行渲染。
- en: 'It is in that regard and spirit that the node graph for the Radar Texture should
    be accepted – not as a scarecrow to frighten off those who might be less confident
    but to bolster and support those people. That’s why we’ll start with the simplest
    depiction of this node graph that still conveys the essentials. The reason for
    this is that while there are a decent number of moving parts involved in making
    this texture, each is fairly easy to understand once broken down. Follow along
    with the text by loading up snippet XB8WRJ#13 in the NME. Refer to the following
    diagram for notes on each specific component of the texture:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正是基于这种考虑和理念，我们应该接受雷达纹理的节点图 – 它不是用来吓跑那些可能不太自信的人的稻草人，而是用来支持和鼓励那些人的。这就是为什么我们将从最简单的节点图开始，这个节点图仍然传达了基本内容。之所以这样做，是因为虽然制作这个纹理涉及到相当多的移动部件，但一旦分解开来，每个部件都相对容易理解。请按照文本加载
    NME 中的片段 XB8WRJ#13，并参考以下图表了解纹理每个具体组件的说明：
- en: '![Figure 11.11 – The components of the Radar procedural texture'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.11 – 雷达程序纹理的组成部分'
- en: '](img/Figure_11.11_B17266.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.11_B17266.jpg)'
- en: Figure 11.11 – The components of the Radar procedural texture
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 雷达程序纹理的组件
- en: 'In the preceding diagram, the three circles (A), the two crossed lines (B),
    and the sweeping line (C) can each be examined independently of each other. Three
    concentric circles bind the texture, each a slightly different shade of light
    blue. Meeting at the center, each perpendicular to the other and oriented at 45
    degrees concerning the upward direction are the crosses, in a darker blue-gray
    tone. Rounding out the static parts of the texture is the sweeping line, a turquoise-ish
    colored animated pizza slice with an opacity gradient. In the following screenshot,
    the node graph is shown fully collapsed down to its largest constituent components.
    Each element from *Figure 11.12* has its own frame in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，三个圆圈（A）、两条交叉线（B）和扫过的线条（C）可以独立于彼此进行检查。三个同心圆将纹理绑定在一起，每个都是略带不同色调的浅蓝色。在中心相遇，每个都垂直于另一个，并且相对于向上方向呈45度角的是交叉线，色调为较深的蓝灰色。纹理的静态部分还包括扫过的线条，这是一块带有不透明度渐变的青色动画披萨切片。在下面的屏幕截图中，节点图完全折叠到其最大的组成部分。*图11.12*中的每个元素在下面的屏幕截图中都有自己的框架：
- en: '![Figure 11.12 – A node graph of the radar procedural texture'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.12 – 雷达程序纹理的节点图'
- en: '](img/Figure_11.12_B17266.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_11.12_B17266.jpg)'
- en: Figure 11.12 – A node graph of the radar procedural texture
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – 雷达程序纹理的节点图
- en: 'After grouping the major elements of the radar procedural texture, the node
    graph is still complex, but much easier to understand. Organizing and naming elements
    in the NME is important! For reference, the NME snippet can be found at #XB8WRJ#13.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在将雷达程序纹理的主要元素分组后，节点图仍然复杂，但更容易理解。在NME中组织和命名元素非常重要！为了参考，NME片段可以在#XB8WRJ#13找到。
- en: To examine the specifics of any individual piece of the shader graph, expand
    the frame to see the steps comprising that portion of the fragment shader logic.
    The output of each frame varies a bit. Each **CircleShape** frame outputs a color
    value in the **Add Circles** frame, which, as its name implies, adds the color
    values together. A key element of procedural shape generation is that pixels that
    aren’t a part of the shape will be assigned a clear or empty color value. That’s
    why, if you peek inside the **CircleShape**, **Cross**, or **Moving Line** frames,
    you’ll find conditional nodes and other node operations that result in the output
    being set to a value between zero and one [0…1]. A value of 0 means the pixel
    isn’t a part of the shape at all. Any other value is indicative of the relative
    brightness of whatever the pixel’s final color ends up being.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查着色器图的任何单个部分的详细信息，展开框架以查看组成该部分片段着色器逻辑的步骤。每个框架的输出略有不同。每个**CircleShape**框架在**Add
    Circles**框架中输出一个颜色值，正如其名称所暗示的，将颜色值相加。程序形状生成的关键元素是，不属于形状的像素将被分配一个清晰或空的颜色值。这就是为什么，如果你查看**CircleShape**、**Cross**或**Moving
    Line**框架内部，你会找到导致输出设置为0到1之间[0…1]的值的条件节点和其他节点操作。0的值意味着像素根本不是形状的一部分。任何其他值都表明像素最终颜色的相对亮度。
- en: The final color value is arrived at by individually scaling each element’s defined
    color (various shades of blue or white) by that brightness factor, then adding
    it together with the color output of all the other elements. Like magic, shapes
    emerge from a blank canvas! Regarding magic, one of the essential references mentioned
    at the beginning of this chapter was *The Book of Shaders*. The radar procedural
    texture was adapted from a **ShaderToy** example listed as part of its chapter
    on Shapes, located at [https://thebookofshaders.com/07/](https://thebookofshaders.com/07/).
    Even though there isn’t a node graph to be found on the site, every code snippet
    is interactive. Anyone interested in procedural textures or similar topics should
    make the time and effort to read through this concise, gentle, and amazingly well-put-together
    resource as part of continuing their journey in this area.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的颜色值是通过将每个元素定义的颜色（各种蓝色或白色色调）分别按该亮度因子缩放，然后将它们与所有其他元素的颜色输出相加得到的。就像魔法一样，形状从空白画布中浮现出来！关于魔法，本章开头提到的基本参考资料之一是*着色器之书*。雷达程序纹理是从其形状章节中列出的**ShaderToy**示例改编的，该章节位于[https://thebookofshaders.com/07/](https://thebookofshaders.com/07/)。尽管网站上找不到节点图，但每个代码片段都是交互式的。任何对程序纹理或类似主题感兴趣的人都应该抽出时间和精力阅读这本简洁、温和且组织得惊人的资源，作为继续在这一领域旅程的一部分。
- en: Very similar to Procedural Textures, the Post-Process mode of the NME works
    against the Fragment Shader. Let’s take a quick stroll through the landscape of
    Post-Processes in the NME.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序纹理非常相似，NME的后处理模式是与片段着色器相反工作的。让我们快速浏览一下NME中后处理的景观。
- en: Developing Post-Processes with the NME
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NME开发后处理
- en: Unlike the Procedural Texture mode, the `Current Screen` node. This node is
    an input texture that’s passed to the fragment shader. It contains a screenshot
    preview of the frame as it would be rendered without any post-processing. You
    can set any texture for this; its purpose is just to provide visual feedback on
    the post-process output.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序纹理模式不同，`Current Screen`节点。这个节点是一个输入纹理，它被传递到片段着色器中。它包含了一个没有后处理的帧的截图预览。你可以为这个设置任何纹理；它的目的只是提供后处理输出的视觉反馈。
- en: 'One of the simplest Post-Processes that can be constructed with the NME is
    the never-out-of-style fade in/fade out mechanic:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用NME构建的最简单的后处理之一是永不过时的淡入/淡出机制：
- en: '![Figure 11.13 – Simple fade in/out post-process in the MNE'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13 – MNE中的简单淡入/淡出后处理](img/Figure_11.13_B17266.jpg)'
- en: '](img/Figure_11.13_B17266.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: Figure 11.13 – Simple fade in/out post-process in the MNE
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 – MNE中的简单淡入/淡出后处理
- en: The Preview Animation frame is there to provide an animated view of what the
    post-process looks like in action. The `fadeFactor` uniform controls the degree
    of the effect. The snippet is hosted at Z4UNYG#2.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 预览动画帧用于提供后处理在实际操作中的动画视图。`fadeFactor`统一变量控制效果的程度。代码片段托管在Z4UNYG#2。
- en: In the logic depicted in the preceding screenshot, the `fadeColor` node is scaled
    by a `fadeFactor`. To help visualize the effect, the `Preview Animation` frame
    passes the `fadeFactors` ranging from 0 (completely black) to 1 (normal) and up
    to 10 (completely white).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一张截图所示的逻辑中，`fadeColor`节点通过`fadeFactor`进行缩放。为了帮助可视化效果，`Preview Animation`帧传递了从0（完全黑色）到1（正常）再到10（完全白色）的`fadeFactors`。
- en: Important note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Because our scale starts at zero, assigning a value of 10 to `fadeFactor` is
    the same as cranking things up to 11, because that’s how far Babylon.js goes.
    You’ve been warned!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的比例从零开始，将10分配给`fadeFactor`与将事情提高到11一样，因为这就是Babylon.js所能达到的。你已经收到警告了！
- en: We started this section by learning about the basics of the NME and using our
    newly learned techniques to build a high-resolution **Planet Earth Material**,
    complete with animated cloud coverage. Because we took our time to go over the
    basics, we were able to pick up some steam heading into the topic of **Procedural
    Textures**. We learned that they are built very similarly to **Materials**, except
    the work is all done in the fragment shader. Like the Procedural Texture, **Post-Processes**
    do not operate against Scene geometry. A post-process is identical in function
    to a procedural texture because the **Current Screen** node is the rendered texture
    buffer for each pixel of the screen.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本节开始时，学习了NME的基础知识，并使用我们新学的技术构建了一个高分辨率的**地球材料**，其中包括动画云覆盖。因为我们花了时间来讲解基础知识，所以我们能够在这个关于**程序纹理**的话题上取得进展。我们了解到，它们与**材料**构建得非常相似，除了所有工作都是在片段着色器中完成的。像程序纹理一样，**后处理**不针对场景几何形状操作。后处理在功能上与程序纹理相同，因为**当前屏幕**节点是屏幕上每个像素的渲染纹理缓冲区。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If it feels like we’ve been skirting a deep examination of this and the other
    topics we’ve covered so far in this chapter, then either you have a good sense
    of intuition or you read the title of this chapter. As this chapter’s title suggests,
    we’re only scratching the surface of a topic not only wide but deep in its complexity.
    That doesn’t mean that we haven’t covered a lot of material – quite the opposite!
    We started this chapter by learning a bit about some of the shader concepts and
    the differences between Vertex, Fragment, and Compute shaders. Each type of shader
    is a specialized software program that runs on the GPU once for every piece of
    geometry (vertex) and every pixel (fragment) on the screen.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果感觉我们一直在回避对这个以及其他我们在本章中已经涵盖的主题的深入探讨，那么要么是你有很好的直觉，要么是你阅读了本章的标题。正如本章标题所暗示的，我们只是在触及一个不仅广度大而且复杂性深的主题的表面。这并不意味着我们没有涵盖很多材料——恰恰相反！我们本章开始时，通过学习一些着色器概念以及顶点、片段和计算着色器之间的区别来入门。每种类型的着色器都是一种专门软件程序，它在GPU上为屏幕上的每一块几何形状（顶点）和每一个像素（片段）运行一次。
- en: None of the shader instances has any memory about things that happened in the
    previous frame and don’t know what any of their neighbors are doing. This makes
    shader programs a little bit mind-bending to work with initially. Fortunately,
    the language shader code used in Babylon.js is written in **GLSL**, which you
    should be familiar with if you are used to working with Python or JavaScript.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何着色器实例会记住前一个帧中发生的事情，也不知道它们的邻居在做什么。这使得着色器程序在最初使用时有点令人费解。幸运的是，Babylon.js中使用的着色器代码语言是**GLSL**，如果你习惯于使用Python或JavaScript，你应该对此很熟悉。
- en: '**Compute shaders** are new to Babylon.js v5.0 and are a powerful new addition
    to the **WebGPU** toolbox. Compute shaders are a more generalized form of a shader
    and unlike the vertex or fragment shader, they are capable of writing output to
    more than just a texture target or a mesh position. Therefore, they can perform
    parallel calculations of complicated systems such as fluid dynamics, weather,
    climate simulations, and many more things waiting to be invented.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算着色器**是Babylon.js v5.0的新功能，是**WebGPU**工具箱中的一个强大新补充。计算着色器是着色器的一种更通用的形式，与顶点或片段着色器不同，它们能够将输出写入不仅仅是纹理目标或网格位置。因此，它们可以执行复杂系统（如流体动力学、天气、气候模拟等）的并行计算，以及更多等待被发明的事物。'
- en: Once we had a solid foundational understanding of shaders, we applied that knowledge
    to writing shader programs using the NME. The NME has several modes of operation,
    and we started again with the basics with the Material mode and the Planet Earth
    Material. After quickly learning how to add and mix textures, we topped the cake
    off with some icing by adding an animated effect to the cloud texture, learning
    about Frames as we went.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对着色器有了坚实的基础理解，我们就将这一知识应用于使用NME编写着色器程序。NME有几种操作模式，我们再次从基础开始，使用材质模式和平行地球材质。在快速学习如何添加和混合纹理后，我们通过添加动画效果到云纹理上，并在过程中学习帧，为这个蛋糕增添了糖霜。
- en: This knowledge of Frames came in handy when we tried to understand the much
    more complex Radar Procedural Texture. Ignoring the vertex output, the procedural
    texture and post-process modes operate against the fragment output. This similarity
    made it an easy transition to the Post-Process editor. Always classy and simple
    to implement, a basic fade in/fade out effect is quick to assimilate into our
    growing understanding of this important topic.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图理解更加复杂的雷达程序纹理时，关于帧的知识派上了用场。忽略顶点输出，程序纹理和后处理模式作用于片段输出。这种相似性使得它很容易过渡到后处理编辑器。始终优雅且易于实现，基本的淡入/淡出效果很快就能融入我们对这个重要主题不断增长的理解中。
- en: Like an iceberg’s tip peeking out of the water, there’s so much more to shaders
    and the NME than what’s visible from the surface. If this chapter were to do the
    topic its full justice, it would undoubtedly require another couple hundred pages!
    Be sure to check the next section, *Extended Topics*, for suggestions on where
    to go next and what to do.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就像冰山露出水面的尖顶一样，着色器和NME中还有许多东西比表面可见的要多。如果这一章要公正地对待这个主题，无疑需要再增加几百页！请确保查看下一节*扩展主题*，以获取下一步的建议和行动指南。
- en: We’ve come incredibly far along in our journey across the vastness of Babylon.js,
    but there’s still more ground to be covered. In the next chapter, we’re going
    to start moving from the express lanes over to the exit lane, but there are still
    a few more landmarks to make before we reach our destination terminal. In real-world
    terms, we’re going to shift our focus back to the overall application and learn
    about how to make Space-Truckers run offline and record high scores before publishing
    it to a major app store. If that sounds like a refreshing change of scenery, then
    read on! Otherwise, if you’re looking for some side-quests to keep things going
    in the Land of Shaders, the *Extended Topics* section might have some interesting
    challenges you can undertake. See you in the next chapter!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在穿越Babylon.js广阔世界的旅程中，我们已经取得了惊人的进展，但仍有更多领域需要探索。在下一章中，我们将从快速通道开始转向出口车道，但在到达目的地终端之前，我们还需要标记几个地标。从现实世界的角度来看，我们将把焦点重新转向整体应用程序，学习如何让Space-Truckers在离线状态下运行并记录高分，然后再发布到主要的应用商店。如果这听起来像是一种令人耳目一新的环境变化，那么请继续阅读！否则，如果你在寻找一些支线任务来保持Shader领域的活力，*扩展主题*部分可能有一些有趣的挑战可以接受。下一章见！
- en: Extended Topics
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题
- en: 'Here are some ideas on ways to further your journey with the NME in particular,
    but also some resources on shaders in general:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于如何进一步使用NME（特别是）以及一般着色器资源的想法：
- en: Use the techniques we learned about in this chapter to create procedural clouds
    for the Planet Earth Material. One way to approach this would be to start with
    the existing cloud texture and distort it using some type of Noise node.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本章中我们学到的技术为地球材质创建程序云。一种方法是从现有的云纹理开始，并使用某种类型的噪声节点对其进行扭曲。
- en: The Book of Shaders ([https://thebookofshaders.com/](https://thebookofshaders.com/))
    is a free online resource that, while still an evolving work-in-progress, can
    be, as the authors describe it, “a gentle step-by-step guide through the abstract
    and complex universe of Fragment shaders.” Even though it focuses entirely on
    Fragment shaders, it is nonetheless a spring-powered steppingstone toward improving
    your understanding of shaders. Each chapter introduces examples and exercises
    along with the necessary material – try reproducing examples from this book in
    the NME. Post your results on the BJS forums and see what others have done at
    [https://forum.babylonjs.com/c/demos/9](https://forum.babylonjs.com/c/demos/9).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《着色器之书》（[https://thebookofshaders.com/](https://thebookofshaders.com/））是一个免费在线资源，虽然它仍在不断进化中，但正如作者所描述的，它“是一个温和的、逐步引导您进入片段着色器这个抽象而复杂的宇宙的指南。”尽管它完全专注于片段着色器，但它无疑是一个弹簧驱动的垫脚石，有助于提高您对着色器的理解。每一章都介绍了示例、练习以及必要的材料——尝试在NME中重现这本书中的示例。在BJS论坛上发布您的结果，看看其他人做了什么。[https://forum.babylonjs.com/c/demos/9](https://forum.babylonjs.com/c/demos/9)。
- en: It can be tough to understand what’s going on in the GPU, especially since there’s
    no easy way to attach a debugger and step through code like many might be used
    to doing with regular code. SpectorJS is a browser extension that can give insights
    into what is happening on the GPU. You can learn more at [https://spector.babylonjs.com/](https://spector.babylonjs.com/).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解GPU中发生的事情可能很困难，特别是因为没有简单的方法可以附加调试器并像许多人习惯于常规代码那样逐步执行代码。SpectorJS是一个浏览器扩展，可以提供关于GPU上发生的事情的见解。您可以在[https://spector.babylonjs.com/](https://spector.babylonjs.com/)了解更多信息。
- en: The TrailMesh that extrudes along the route taken by the simulated cargo passes
    through different encounter zones on its journey. Create a Node Material or Texture
    that takes in encounter zone information and uses it to render the trail mesh
    in a unique pattern for every zone.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着模拟货物所经过的路线挤压的TrailMesh在其旅途中会穿过不同的遭遇区域。创建一个节点材质或纹理，它接受遭遇区域信息并使用它为每个区域渲染独特的轨迹网格。
- en: Related to the preceding bullet point, create an effect that is triggered whenever
    an encounter is rolled during route planning. The effect should be positioned
    at the location of the encounter and can be different according to the type of
    encounter (although it needn’t be). For gameplay purposes, it probably shouldn’t
    reveal too much information to the player, but it can certainly tease!
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与前面的要点相关，创建一个在路线规划期间遭遇发生时触发的效果。该效果应位于遭遇的位置，并且可以根据遭遇的类型不同而不同（尽管不一定需要）。出于游戏玩法的目的，它可能不应该向玩家透露太多信息，但确实可以引起兴趣！
- en: 'The Babylon.js Docs contain numerous topics and resources about the NME. They
    also contain links to various YouTube videos that provide tutorials on different
    aspects of using the NME:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babylon.js文档包含许多关于NME的主题和资源。它还包含链接到各种YouTube视频，这些视频提供了关于使用NME不同方面的教程：
- en: 'Creating and using Node Materials in code. If you are writing a paper or a
    book about programming and want to sound smart, “Imperatively Reflecting JavaScript
    into GLSL” is a good title: [https://doc.babylonjs.com/divingDeeper/materials/node_material/nodeMaterial](https://doc.babylonjs.com/divingDeeper/materials/node_material/nodeMaterial).'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中创建和使用节点材质。如果您正在撰写关于编程的论文或书籍，并希望听起来很聪明，“强制性地将JavaScript反射到GLSL”是一个不错的标题：[https://doc.babylonjs.com/divingDeeper/materials/node_material/nodeMaterial](https://doc.babylonjs.com/divingDeeper/materials/node_material/nodeMaterial)。
- en: A list of related videos can be found at the bottom of the preceding link. Video
    topics include PBR Nodes, Procedural Projection Textures, Procedural Node Materials,
    Anisotropy, and more!
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关视频列表可以在前一个链接的底部找到。视频主题包括PBR节点、程序投影纹理、程序节点材质、各向异性等！
