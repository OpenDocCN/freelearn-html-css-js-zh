- en: Chapter 5. Coffee with Strangers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 与陌生人喝咖啡
- en: In this chapter, we will write an API that allows users to go for a coffee!
    This comprises of a simple yet extendable user matching system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将编写一个API，允许用户去喝咖啡！这包括一个简单但可扩展的用户匹配系统。
- en: Initially, we'll just ask the user to enter their name and e-mail, which is
    stored on MongoDB. Whenever we can match these with the nearest other user, e-mails
    are sent to both sides and then it's coffee time. After we set up the base, it's
    time to make sure we keep a record of the matches and avoid duplicates from happening
    for a better user experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们只需让用户输入他们的姓名和电子邮件，这些信息将存储在MongoDB中。每当我们可以匹配到最近的其他用户时，就会给双方发送电子邮件，然后就是喝咖啡的时间。在设置好基础之后，我们需要确保我们记录匹配情况，以避免重复发生，从而提供更好的用户体验。
- en: Soon after, let's make ourselves ready to go global and take into account their
    geo positioning.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，让我们做好准备，使其全球化，并考虑他们的地理位置。
- en: Assuming everything goes well (which is a mistake), we are validated. So it's
    time to refactor to a more maintainable architecture, where the pairing becomes
    a service by itself.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利（这是一个错误），我们已经进行了验证。所以是时候重构到一个更易于维护的架构中，其中配对本身成为一个服务。
- en: Finally, let's allow our users to rate how their meeting was and tell us whether
    it was a successful meeting or not in real-world applications, the usage of user
    generated feedback is invaluable!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们允许我们的用户对他们的会议进行评分，并告诉我们它是否是一个成功的会议，在现实世界应用中，用户生成的反馈是无价的！
- en: We expect that this sort of application structure will offer the reader inspiration
    to create real world matching applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望这种应用程序结构将为读者提供灵感，以创建现实世界的匹配应用程序。
- en: Code structure
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码结构
- en: Before getting into actual code, we want to provide a heads up on the structure
    for the code in this chapter, which is a bit different than before, and we hope
    it adds another view to structure code for Express and Node.js in general.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入实际代码之前，我们想要提供关于本章代码结构的提示，这比之前有所不同，我们希望它能为Express和Node.js的代码结构提供另一个视角。
- en: 'Some may call it a **Factory pattern**; it consists of wrapping each of the
    file''s code with a function that can be used to configure or test it. While this
    requires a bit more of scaffolding, it frees our code from depending on a static
    state. It will often look as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会称之为**工厂模式**；它由将每个文件的代码包裹在一个可以用来配置或测试它的函数中组成。虽然这需要更多的脚手架，但它使我们的代码摆脱了对静态状态的依赖。它通常会看起来如下：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A corollary of this structure is that each invocation of this file will have
    its own state, exactly like the instance of a class, except we don't depend on
    this, but the scope that never goes missing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构的推论是，这个文件的每次调用都将有自己的状态，就像类的实例一样，但我们不依赖于它，而是依赖于永远不会丢失的作用域。
- en: Going a bit further, we'll try centralizing the structure of the pieces per
    folder, each with a respective `index.js`, the main responsibilities of which
    are to initialize instances when needed, keep references to dependencies that
    will be passed down, and return only public methods.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 再进一步，我们将尝试将每个文件夹的组件结构集中化，每个文件夹都有一个相应的`index.js`，其主要职责是在需要时初始化实例，保留将被传递下来的依赖项的引用，并仅返回公共方法。
- en: Defining routes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义路由
- en: Let's start by defining the first routes we need and how we want them to behave
    and simple logical steps building what's strictly essential first, in a TDD style.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义我们需要的第一个路由以及我们希望它们如何表现，并按照TDD风格，先构建严格必要的简单逻辑步骤。
- en: 'The first thing is that we need users to be able to register; the smallest
    test case to register our user is as follows:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一件事是我们需要让用户能够注册；注册我们的用户的最小测试用例如下：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Assuming you have Mocha installed with `npm i -g mocha`, execute `mocha`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你已经通过`npm i -g mocha`安装了Mocha，执行`mocha`。
- en: See 404? Good start! Now let's expand and create a file, `src/route/index.js`,
    which will declare all the routes known to the app. It uses controllers that handle
    each concern.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看到404了吗？这是个好开始！现在让我们扩展并创建一个文件，`src/route/index.js`，它将声明应用所知道的所有路由。它使用控制器来处理每个关注点。
- en: 'Start with `user.js`, which implements a create action, as shown in the following
    code:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`user.js`开始，它实现了一个创建动作，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This amount of code should be enough to make the tests pass with Mocha.![Defining
    routes](img/0818_05_01.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码应该足以让Mocha通过测试。![定义路由](img/0818_05_01.jpg)
- en: For this app, we'll have all route definitions in one place, that is, `routes/index.js`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个应用，我们将所有的路由定义放在一个地方，即`routes/index.js`。
- en: At this stage, we know that the testing setup works. Next, let's move onto persistence
    and some business logic!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们知道测试设置是有效的。接下来，让我们转向持久性和一些业务逻辑！
- en: Persisting data
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化数据
- en: Adding some diversity to the libraries, let's experiment with Mongojs ([https://github.com/mafintosh/mongojs](https://github.com/mafintosh/mongojs)),
    a simple library for MongoDB that aims to be as close as possible to the native
    client.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在库中添加一些多样性，让我们尝试Mongojs ([https://github.com/mafintosh/mongojs](https://github.com/mafintosh/mongojs))，这是一个旨在尽可能接近原生客户端的简单MongoDB库。
- en: First things first, let's create a small config file, `./config.js`, to store
    all the common data and just return a simple object with relevant configurations
    for each environment. For now let's just make sure we have a URLin a format accepted
    by Mongojs.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个小的配置文件，`./config.js`，用于存储所有常用数据，并返回一个包含每个环境相关配置的简单对象。现在让我们确保我们有一个Mongojs接受的URL格式。
- en: This file should be able to hold all global configs for the app. It ensures
    we also have different settings depending on the environment.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此文件应能够存储应用的所有全局配置。它确保我们根据环境有不同的设置。
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This file needs to be in `app.js`, a central place to initialize and gather
    dependencies, and it will be passed to our DB, which then returns public methods.
    Let''s see that happening in the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此文件需要位于`app.js`中，这是一个初始化和收集依赖项的中心位置，它将被传递给我们的数据库，然后返回公共方法。让我们在以下代码中看看这是如何发生的：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For our models, let's define one file to rule them all s`rc/models/index.js`
    with its main responsibilities being to instantiate the db and expose public methods
    to other modules so that storage details stay encapsulated, keeping the code clean
    and decoupled.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的模型，让我们定义一个文件来管理所有模型`s`rc/models/index.js`，其主要职责是实例化数据库并公开公共方法给其他模块，以便存储细节保持封装，使代码保持清洁和松耦合。
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our first model, `user`, has the ability to create one user. Notice that we
    are not making any validations in this model to keep things simple. Don't go to
    production without having the models double-checked.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个模型，`user`，具有创建一个用户的能力。请注意，在这个模型中我们没有进行任何验证以保持简单。在没有对模型进行双重检查的情况下不要投入生产。
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s update our `user.js` route to make use of our DB:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新我们的`user.js`路由以使用我们的数据库：
- en: '[PRE7]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this simple change, we should have a user created in our DB.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这个简单的更改，我们应该在我们的数据库中创建了一个用户。
- en: Let's open Robomongo ([http://robomongo.org/](http://robomongo.org/)) to see
    what user data was created; it's super handy to lookup what data we have in MongoDB
    no matter what library we use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开Robomongo ([http://robomongo.org/](http://robomongo.org/))来查看创建了哪些用户数据；无论我们使用什么库，查找我们在MongoDB中的数据都非常方便。
- en: '![Persisting data](img/0818_05_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![持久化数据](img/0818_05_02.jpg)'
- en: Exception handling
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: Let's open a parenthesis here and talk about the `if(err) return next(err);`.command
    This is a pattern that is used to abstract error handling in a single action that
    is supposed to be treated in Express further down the stack, via `app.use`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里打开一个括号，并讨论`if(err) return next(err);`。这是一个用于在单个操作中抽象错误处理的模式，该操作应该在Express的后续堆栈中进一步处理，通过`app.use`。
- en: To keep things neat, we can abstract error handling to a file of its own where
    we will define specific handlers for each type of error `src/routes/errorHandler.js`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持整洁，我们可以将错误处理抽象到一个单独的文件中，我们将为每种类型的错误定义特定的处理程序`src/routes/errorHandler.js`。
- en: Let's define a `catchAll()` method for now. Express will know the type of use
    for this function because its functionality is 4.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先定义一个`catchAll()`方法。Express将知道这个函数的用途，因为它的功能是4。
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lastly, it''s activated in `routes/index.js`. error handling should be the
    very last middleware(s):'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它在`routes/index.js`中被激活。错误处理应该是最后一个中间件（s）：
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Naive pairing
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单配对
- en: The simplest pairing system we can implement is to simply lookup if there is
    another user available without a pair whenever someone signs up.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现的 simplest 配对系统是，当有人注册时，简单地查找是否有其他未配对的可用用户。
- en: 'In order to do so, we''ll start a new collection and model: Meeting, which
    will be the base matching structure we''ll be expanding on. The fundamental idea
    here is that each document will represent a meeting; either it''s in the request
    phase, already set or occurred, finally will also store the feedback.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将开始一个新的集合和模型：Meeting，它将成为我们将扩展的基本匹配结构。基本思想是每个文档将代表一个会议；无论是请求阶段、已经设置或发生，最后也会存储反馈。
- en: We'll be elaborating and defining the structure for it as it goes. For an initial
    implementation, let's run the scheduling logic right when the user decides to
    be matched. The strategy will be to look for a meeting document, where only the
    first user is set, and update it. In case there is no document like that, let's
    create a new one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将随着进展详细阐述并定义其结构。对于初始实现，让我们在用户决定配对时立即运行调度逻辑。策略将是查找一个只有第一个用户被设置的会议文档，并更新它。如果没有这样的文档，让我们创建一个新的。
- en: 'There are a couple of race conditions that might kick in, which we certainly
    want to avoid. These are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会触发一些竞争条件，我们当然希望避免。具体如下：
- en: The user who's trying to find someone to schedule gets scheduled in the middle
    of the process.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在尝试找到安排对象的用户在过程中被安排。
- en: The user who's available to be scheduled is selected but then reserved by someone
    else.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于安排的用户被选中，但随后被其他人保留。
- en: Lucky MongoDB offers the `findAndModify()` method, which can find and update
    on a single document automatically, while also returning the updated document.
    Keep in mind that it also offers an `update()` method to update multiple methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，MongoDB 提供了 `findAndModify()` 方法，它可以在单个文档上自动查找和更新，同时返回更新后的文档。请注意，它还提供了一个
    `update()` 方法来更新多个方法。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'Check out the docs from the following link: [http://docs.mongodb.org/manual/reference/method/db.collection.findAndModify/#comparisons-with-the-update-method](http://docs.mongodb.org/manual/reference/method/db.collection.findAndModify/#comparisons-with-the-update-method)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下链接的文档：[http://docs.mongodb.org/manual/reference/method/db.collection.findAndModify/#comparisons-with-the-update-method](http://docs.mongodb.org/manual/reference/method/db.collection.findAndModify/#comparisons-with-the-update-method)
- en: 'Let''s get started with a new collection, `Meeting`, where we will keep track
    of a user''s interest in finding a pair as well as keeping track of meetings as
    follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个新的集合 `Meeting` 开始，我们将跟踪用户寻找配对的兴趣以及跟踪会议，如下所示：
- en: This document will contain all of the user's info up to that point in time,
    so we can use it as a history, as well as use its contents to send e-mails and
    setup reviews.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此文档将包含用户到该时间点的所有信息，因此我们可以将其用作历史记录，同时也可以使用其内容发送电子邮件和设置审查。
- en: 'Let''s see what the code looks like in `src/models/meeting.js`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看 `src/models/meeting.js` 中的代码是什么样的：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the case of a successful pairing, `user2` would be set in the `Meeting` object
    to meet the following day at noon, as you can see on the attribute `at`, which
    we set via the `aux` `arrangeTime()` function and the lightweight library moment.js
    ([http://momentjs.com/](http://momentjs.com/)). It's amazing to deal with dates
    in a super readable way. It is recommended that you take a look and become more
    familiar with it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功配对的情况下，`user2` 将被设置在 `Meeting` 对象中，以便第二天中午进行会面，正如您在属性 `at` 中所看到的，我们通过 `aux`
    的 `arrangeTime()` 函数和轻量级库 moment.js ([http://momentjs.com/](http://momentjs.com/))
    来设置。以这种方式处理日期非常易于阅读。建议您查看并熟悉它。
- en: 'Also, notice `new: true` as a parameter. It ensures that MongoDB returns the
    updated version of the object, so we don''t need to duplicate the logic in the
    app.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，请注意作为参数的 `new: true`。它确保 MongoDB 返回对象的更新版本，因此我们不需要在应用程序中重复逻辑。'
- en: The new object `Meeting` needs to be created, as it carries the information
    of the users at that point in time and can be used to compose the emails/notification
    for both.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一个新的对象 `Meeting`，因为它携带了当时用户的信息，并且可以用来为双方编写电子邮件/通知。
- en: 'This is a good opportunity to define some basic structure for our tests that
    will follow a pattern of making several calls to the endpoints and asserting the
    response. There is a thorough explanation about the decisions to implement tests
    immediately, as shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个定义我们后续测试的基本结构的好机会，这些测试将遵循对端点进行多次调用并断言响应的模式。有关立即实施测试的决定有详细的解释，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (Source:git checkout e4fbf672d409482028de7c7427eab769ab0a20d2)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: （来源：git checkout e4fbf672d409482028de7c7427eab769ab0a20d2）
- en: '![Naive pairing](img/0818_05_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![简单的配对](img/0818_05_03.jpg)'
- en: Notes about tests
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试笔记
- en: When using Mocha, a test is much like any javascript file and is executed as
    expected, allowing for any sort of regular Node.js require as you would do usually.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Mocha 时，测试就像任何 JavaScript 文件一样，按预期执行，允许进行任何常规 Node.js require 操作。
- en: The `describe()` method is the context on which our tests execute; in our case,
    it's a full run of a certain functionality. The `before()` method will run once;
    in this case, our logic is set to clean up all of our MongoDB collections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()`方法是我们测试执行的上下文；在我们的情况下，它是一定功能性的完整运行。`before()`方法将只运行一次；在这种情况下，我们的逻辑是清理所有的MongoDB集合。'
- en: It stands for a simple expectation to be fulfilled. It will run in the same
    order it's declared, and we will try to make the assertions small and predictable
    as far as possible. Each of these functions defines steps and in this case, because
    we are doing end-to-end tests, we make requests to the API and check the results,
    and sometimes save it to variables that are used later to assert.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表了一个简单的期望得以实现。它将以声明的相同顺序运行，我们将尽可能使断言小而可预测。这些函数中的每一个都定义了步骤，在这种情况下，因为我们正在进行端到端测试，我们向API发送请求并检查结果，有时将其保存到稍后用于断言的变量中。
- en: There are advices that say that tests shouldn't be dependent on the previous
    state, but those don't usually test the application flow, rather, individual portions
    of logic. For this particular test scenario, in case of a failure, it's important
    to interpret the error from the first `it` that fails; fixing it will likely fix
    errors after it. You can configure Mocha to stop at the first error by using the
    `-b` flag.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有建议说测试不应该依赖于之前的状态，但这些通常不是测试应用程序流程，而是逻辑的各个部分。对于这个特定的测试场景，如果发生失败，重要的是从第一个失败的`it`中解释错误；修复它可能会修复之后的错误。您可以通过使用`-b`标志来配置Mocha在第一个错误时停止。
- en: While testing, the most important point to make sense is that our test cases
    should make sure all of the expected cases are checked, and bad behaviors don't
    happen. We can never expect to predict everything that may go wrong of course,
    but it's still our duty to test as many points as we are certain about common
    issues.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，最重要的要点是确保我们的测试用例检查了所有预期的案例，并且不会发生不良行为。当然，我们永远无法预测可能出错的所有事情，但测试我们确信的常见问题点仍然是我们的责任。
- en: Considering user history
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑用户历史
- en: Our users will probably want to always be paired to meet new people, so we have
    to avoid repetitive meetings. How should we handle this?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户可能希望始终配对以结识新朋友，因此我们必须避免重复的会议。我们该如何处理这种情况？
- en: First, we need to allow for a method to set up new meetings. Think of it as
    a button in an app that would trigger a request to the route `POST/meeting/new`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要允许设置新会议的方法。想象一下，它就像一个应用中的按钮，会触发对`POST/meeting/new`路由的请求。
- en: This endpoint will reply with the status `200` when the request is allowed and
    a pair is found, or if there is no pair but they are now attached to a `meeting`
    object and can now be matched with another user; `412` if the user is already
    scheduled in another meeting and `400` in case the expected e-mail of the user
    isn't sent; in this case, it can't be fulfilled because the user wasn't specified.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求被允许并且找到一对或没有一对但现在附属于一个`meeting`对象并且可以与另一个用户匹配时，此端点将以状态`200`回复；如果用户已经安排在另一个会议中，则回复`412`，如果用户期望的电子邮件未发送，则回复`400`；在这种情况下，它不能被满足，因为用户未指定。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The usage of status codes is somewhat subjective, (see a more comprehensive
    list on Wikipedia at [http://en.wikipedia.org/wiki/List_of_HTTP_status_codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes)).
    However, having distinct responses is important so that the client can display
    meaningful messages to the user.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码的使用有些主观，（在维基百科上查看更全面的列表：[http://en.wikipedia.org/wiki/List_of_HTTP_status_codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes)）。然而，拥有不同的响应是很重要的，这样客户端就可以向用户显示有意义的消息。
- en: Let's implement an Express.js middleware, that requires an e-mail for all requests
    that are made on behalf of the user. It should also load their document and attach
    it to `res.locals`, which can be used in subsequent routes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个Express.js中间件，该中间件要求所有代表用户提出的请求都提供电子邮件。它还应加载他们的文档并将其附加到`res.locals`，这可以在后续的路由中使用。
- en: 'Our `src/routes/index.js` will look like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`src/routes/index.js`将看起来像这样：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The goal of this middleware is to stop and return an error message for every
    request that doesn't have a user email. It's a validation that would usually require
    a username and password or a secret token.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间件的目标是对于每个没有用户电子邮件的请求停止并返回错误消息。这是一个通常需要用户名和密码或秘密令牌的验证。
- en: 'Let''s set up a small but important test suite for this middleware:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个中间件设置一个小型但重要的测试套件：
- en: Clear DB
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清空数据库
- en: Try to get me without email and fail
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试不使用电子邮件获取我并失败
- en: Create a valid user; it succeeds
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个有效的用户；它成功了
- en: Try to get me with another email; it fails
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用另一个电子邮件获取我；它失败了
- en: Access me with the email we registered and it works!
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们注册的电子邮件访问我，它成功了！
- en: Now that we have a way to load the user who's making the request, let's go back
    to the goal of matching people without repetition. As a pre-condition, their past
    meeting time has to be in the past already, otherwise it returns a `412` code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种加载请求用户的方法，让我们回到不重复匹配人的目标。作为先决条件，他们的过去会议时间必须已经过去，否则它将返回`412`代码。
- en: 'If we want to schedule a meeting for our users but any scheduled meeting will
    be set for tomorrow, how can we test it? Meet timekeeper ([https://github.com/vesln/timekeeper](https://github.com/vesln/timekeeper)),
    library with a simple interface to alter the system dates in Node.js; this is
    especially useful for tests. Look closely for the snippet of this test:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为我们的用户安排会议，但任何安排的会议都将定在明天，我们如何测试它？时间记录器([https://github.com/vesln/timekeeper](https://github.com/vesln/timekeeper))，一个具有简单界面的Node.js库，可以更改系统日期；这对于测试特别有用。仔细查看以下测试片段：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It's of vital importance to set an `after` hook to reset timekeeper so that
    the dates go back to normal after the scenario is finished in either success or
    failure; otherwise, there is a chance it will alter the results of other tests.
    It's also worth checking how date manipulation is made easy with `moment()` method
    and once you use `timekeeper.travel() function`, the time is warped to that date.
    For all Node.js knows, the new warped time is the actual time (although it does
    not affect any other applications). We can also switch it back and forth as required.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个`after`钩子来重置时间记录器非常重要，这样在场景成功或失败完成后，日期才能恢复正常；否则，有可能改变其他测试的结果。还值得检查如何使用`moment()`方法轻松地进行日期操作，一旦使用`timekeeper.travel()`函数，时间就会扭曲到那个日期。对于所有Node.js来说，新的扭曲时间实际上是实际时间（尽管它不会影响任何其他应用程序）。我们也可以根据需要来回切换。
- en: 'The `Meeting` method to perform this check on our user (defined at `models/meeting.js`)
    is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此检查的`Meeting`方法（在`models/meeting.js`中定义）如下：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `$or` operator is necessary because we don't know whether the user we are
    looking for is going to be `user1` or `user2`, so we take advantage of the query
    capabilities of MongoDB that can look inside objects in a document and match the
    `email` as a `String`, and the `at` field as mentioned earlier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`$or`运算符是必要的，因为我们不知道我们正在寻找的用户将是`user1`还是`user2`，所以我们利用MongoDB的查询功能，可以在文档中的对象内部查找，并将`email`作为`String`匹配，以及前面提到的`at`字段。'
- en: 'Our newly created `src/routes/meeting.js`, is given as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新创建的`src/routes/meeting.js`如下所示：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Moving on, we'll define a very important helper function that finds previous
    meetings involving the user who's making the request and returns the emails of
    everyone they have been matched with, so we can avoid matching those two users
    again.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个非常重要的辅助函数，该函数用于查找涉及请求用户的先前会议，并返回他们匹配到的每个人的电子邮件，这样我们就可以避免再次将这两位用户匹配在一起。
- en: Helper functions like this are super useful to keep the code understandable
    when dealing with complicated pieces of logic. As a rule of thumb, always separate
    into smaller functions when a chunk of code can be abstracted into a concept.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的辅助函数在处理复杂的逻辑时非常有用，可以保持代码的可理解性。一般来说，当一大块代码可以抽象成一个概念时，总是将其分离成更小的函数。
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The key to `userMatchHistory` object; is through the MongoDB `$nin` operator,
    which performs a match when the element doesn't match what's in the array. The
    matching logic follows the very same logic we had in naive pairing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`userMatchHistory`对象的键是通过MongoDB的`$nin`运算符实现的，它在元素不匹配数组中的内容时执行匹配。匹配逻辑与我们在简单配对中使用的逻辑完全相同。'
- en: In our `Meeting` model, we removed our previous `pairNaive` method with the
    `pair` method, which does similar, but first build a list of the previous matches
    to ensure we don't match those again.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Meeting`模型中，我们用`pair`方法替换了之前的`pairNaive`方法，它做的是类似的事情，但首先构建一个先前匹配的列表，以确保我们不会再次匹配这些用户。
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Optimizing for distance
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化距离
- en: Let's use a down-to-earth geolocation approach (ah! I'm so funny) to the match.
    We have to be realistic. Our service was born in Smallville but it's going global
    and we can't match people who are too far apart.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个接地气的地理位置方法（啊！我真是太有趣了）来匹配。我们必须现实。我们的服务起源于小城，但正在走向全球，我们不能匹配距离太远的人。
- en: 'Because our meetings are arranged free of racing conditions on the `Meeting`
    collection and we would like to keep it that way, let''s adapt our existing `pair`
    method to incorporate the user''s location. We can assume that at registration,
    they will supply their location (or we could also easily update the meeting document
    once they provide the location). In our existing strategy, we have one user who
    creates a meeting document; in this case, let''s also set their location, so the
    next user looking for a match will have to be in a similar location as an additional
    constraint, as shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的会议在`Meeting`集合上没有竞态条件，我们希望保持这种状态，因此让我们调整现有的`pair`方法以包含用户的位置。我们可以假设在注册时，他们将提供他们的位置（或者我们也可以很容易地更新会议文档，一旦他们提供位置）。在我们的现有策略中，有一个用户创建会议文档；在这种情况下，让我们也设置他们的位置，这样下一个寻找匹配的用户就必须在相似的位置，作为额外的约束，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our `Meeting` collection now has `location1` indexed as `2dsphere`. The geoquery
    for this field can easily be integrated with our previous query, using the operator
    `$nearSphere` to match geo positions in a sphere object. `$maxDistance` is the
    maximum radius for the match. It's expressed in meters and in this case, we intersect
    the coordinates with `Point`, which is a previously registered user. `7km` was
    chosen arbitrarily because it seems like a reasonable enough radius to meet someone.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Meeting`集合现在将`location1`索引为`2dsphere`。可以使用操作符`$nearSphere`轻松地将此字段的geo查询与之前的查询集成，以匹配球对象中的地理位置。`$maxDistance`是匹配的最大半径。它以米为单位表示，在这种情况下，我们使用`Point`与坐标相交，`Point`是一个之前注册的用户。`7km`是任意选择的，因为它似乎是一个足够合理的半径来与人见面。
- en: If we changed `$maxDistance` to something considerably smaller, some of our
    tests would fail because matches wouldn't happen; see `test/meeting_near.js`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`$maxDistance`改为相当小的值，一些测试将失败，因为匹配不会发生；请参阅`test/meeting_near.js`。
- en: Clear DB
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清空数据库
- en: Create user 1 in Santiago
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在圣地亚哥创建用户1
- en: Create user 4 in Valparaiso
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在瓦尔帕莱索创建用户4
- en: Check whether there is a match
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否有匹配
- en: Create user 2 in Santiago
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在圣地亚哥创建用户2
- en: Check whether there was a match between 1 and 2
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查1和2之间是否有匹配
- en: Create user 3 in Vancouver
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在温哥华创建用户3
- en: Check whether 3 has a match
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查3是否有匹配
- en: Create user 5 in Valparaiso
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在瓦尔帕莱索创建用户5
- en: Check whether there is a match between 4 & 5
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查4和5之间是否有匹配
- en: (Source:git checkout 52e8f80b7fe3b9482ff27ea1bcc410270752a796)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: （来源：git checkout 52e8f80b7fe3b9482ff27ea1bcc410270752a796）
- en: E-mail follow up
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮件跟进
- en: Users can now be matched. The meetings are unique and made between people that
    are nearby, which is awesome! There is no end to possible improvements on a matching
    system; so instead, lets now collect some data about how their meeting went!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以进行匹配。会议是独特的，并且是在附近的人之间进行的，这真是太棒了！匹配系统可能的改进没有尽头；因此，现在让我们收集一些关于他们的会议如何进行的数据！
- en: 'To do so, we''ll send an email to each of the attendees, which will consist
    of a few simple options to promote engagement. Some of them are listed as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将向每位与会者发送一封电子邮件，其中包含一些简单的选项来促进参与。其中一些如下列出：
- en: It was awesome
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真棒
- en: It was awful
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真糟糕
- en: Meh…
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿...
- en: My pair didn't show up!
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的搭档没有出现！
- en: Those values are added to `src/models/meeting.js` as key-value pairs, which
    we can store for ratings and use them to communicate back to users.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值被添加到`src/models/meeting.js`中作为键值对，我们可以存储它们以供评分，并使用它们向用户传达信息。
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We could store these responses in the respective `meeting` object, associating
    it with the user who responded.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些响应存储在相应的`meeting`对象中，将其与回复的用户关联起来。
- en: For this purpose, we'll rely primarily on the package `Nodemailer` ([https://github.com/andris9/Nodemailer](https://github.com/andris9/Nodemailer)).
    It is broadly used and offers support for a number of integrations, including
    transport providers and templates so we can make our e-mails dynamic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将主要依赖包`Nodemailer`([https://github.com/andris9/Nodemailer](https://github.com/andris9/Nodemailer))。它被广泛使用，并提供了对许多集成（包括传输提供者和模板）的支持，这样我们就可以使我们的电子邮件动态化。
- en: Coming to the setup decision, as you probably realized Node.js & Express are
    free of conventions about how to set up your code because these apps may do very
    different things and there is no one-size-fits-all. Let's make mailing a concern
    of its own, as much as persistence and routes are separated concerns integrated
    into `src/app.js`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 来到设置决策，正如你可能意识到的，Node.js和Express在如何设置代码方面没有约定，因为这些应用程序可能做非常不同的事情，没有一种适合所有情况的解决方案。让我们将邮件作为一个单独的关注点，就像持久性和路由一样，它们是分离的关注点，集成到`src/app.js`中。
- en: The `src/mailer/index.js` will be our entry point and its main responsibility
    is to instantiate the `nodemailer` variable and provide public methods other files
    can refer to.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/mailer/index.js`将是我们的入口点，其主要责任是实例化`nodemailer`变量并提供其他文件可以引用的公共方法。'
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When it comes to the test environment, we definitely don't want to be sending
    real e-mails, that's why we register the stub transport. For other environments,
    we decided to go with `Mailgun` but we could also go with any service that integrates
    via SMTP (remember to use Gmail since there is a risk of failing to send e-mails,
    as they have a bunch of heuristics to prevent spam).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试环境时，我们绝对不希望发送真实的电子邮件，这就是为什么我们注册了存根传输。对于其他环境，我们决定使用`Mailgun`，但我们也可以选择任何通过SMTP集成的服务（记住使用Gmail，因为存在发送电子邮件失败的风险，因为它们有一系列启发式方法来防止垃圾邮件）。
- en: When it comes to testing, this section is one of the harder ones to test, we
    will implement something very basic in `test/send_mail.js`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试时，这个部分是较难测试的部分之一，我们将在`test/send_mail.js`中实现一些非常基本的测试。
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Add to `config.js`, and have the correspondent environment variables defined
    because it's not a good idea to keep our secrets in the code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到`config.js`中，并定义相应的环境变量，因为将我们的秘密保留在代码中不是一个好主意。
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When I disable the `test` environment, I can actually see the email in my inbox.
    Win! To make the service look better, let's experiment with some templates, which
    is what email-templates ([https://github.com/niftylettuce/node-email-templates](https://github.com/niftylettuce/node-email-templates))
    is all about.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我禁用`test`环境时，我实际上可以在我的收件箱中看到电子邮件。胜利！为了让服务看起来更好，让我们尝试一些模板，这正是email-templates
    ([https://github.com/niftylettuce/node-email-templates](https://github.com/niftylettuce/node-email-templates))所关注的。
- en: It makes it easy to implement dynamic e-mails including packing the CSS inline;
    these are required to be inline by many e-mail clients.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得实现动态电子邮件变得容易，包括将CSS内联打包；许多电子邮件客户端要求这些内容必须内联。
- en: On `src/mailer/followUp.js`
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/mailer/followUp.js`中
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Essentially, we send two identical emails so we get feedback from both users.
    There is a bit of complexity there that we will manage by using `async.parallel()`
    method. It allows us to start two asynchronous operations and callbacks (done)
    when both are completed. See [https://github.com/caolan/async#parallel](https://github.com/caolan/async#parallel).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们发送两封相同的电子邮件，以便从两个用户那里获得反馈。这里有一些复杂性，我们将通过使用`async.parallel()`方法来管理。它允许我们启动两个异步操作和回调（完成），当两者都完成时。请参阅[https://github.com/caolan/async#parallel](https://github.com/caolan/async#parallel)。
- en: 'The actual print of the email is created by two files, `src/mailer/templates/followup/followUp.html.swig`
    and `style.css`, which are combined and set via our transport solution, respectively:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件的实际打印由两个文件创建，分别是`src/mailer/templates/followup/followUp.html.swig`和`style.css`，它们分别通过我们的传输解决方案组合和设置：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can choose from many template solutions. swig ([http://paularmstrong.github.io/swig/docs/](http://paularmstrong.github.io/swig/docs/))
    comes with convenient helpers, makes it easy to work with lists, and has the familiar
    HTML visual. A bit of insight is given as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从许多模板解决方案中选择。swig ([http://paularmstrong.github.io/swig/docs/](http://paularmstrong.github.io/swig/docs/))提供了方便的辅助工具，使得处理列表变得容易，并且具有熟悉的HTML视觉。以下是一些见解：
- en: '`{{string}}` is the general interpolating method'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{string}}`是通用的插值方法'
- en: '`|` is for helpers (aka filters); you can use built-ins or define your own'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|`用于辅助工具（也称为过滤器）；您可以使用内置的或定义自己的'
- en: '`for k,v in obj` is a tag and works looping over key-value pairs'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for k,v in obj`是一个标签，用于遍历键值对'
- en: '![E-mail follow up](img/0818_05_04.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![电子邮件跟进](img/0818_05_04.jpg)'
- en: 'When it came to the logic for the follow-up links, we made it really easy for
    the user to provide feedback; usually, the less friction, the better for outstanding
    UX. All they have to do is click on the link and their review is instantly recorded!
    In terms of Express.js, this means we have to set up a route that links all the
    piece of data together; in this case, in `src/routes/index.js`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到跟进链接的逻辑时，我们让用户提供反馈变得非常简单；通常，摩擦越少，对卓越的用户体验越好。他们只需点击链接，他们的评论就会立即记录！在Express.js方面，这意味着我们必须设置一个路由，将所有数据片段连接起来；在这种情况下，在`src/routes/index.js`中：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To have an endpoint that actually changes the data defined as a `GET` is an
    exception to HTTP & REST conventions, but the reason is that email clients will
    send the request as a `GET`; not a lot we can do about it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个实际更改数据的`GET`端点，这是HTTP & REST约定的例外，但原因是电子邮件客户端将请求作为`GET`发送；我们对此无能为力。
- en: 'The method is defined at `src/routes/meeting.js` as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 方法在`src/routes/meeting.js`中定义如下：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method does quite a bit of checking and that's because there is a considerable
    amount of input that needs validation along with providing the appropriate response.
    First, we check whether the `feedback` provided is valid, since we are only taking
    quantitative data. `didMeetingHappened` returns `two` important pieces of info
    about the meeting; the ID may be completely wrong, or it might not have happened
    yet. Both scenarios should deliver different results. Finally, if everything looks
    good, we attempt to rate the meeting, which should work just fine and return some
    data to respond with and finish the request with an implied `200` status.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法进行了相当多的检查，这是因为有相当多的输入需要验证，并提供适当的响应。首先，我们检查提供的`feedback`是否有效，因为我们只接受定量数据。`didMeetingHappened`返回关于会议的两条重要信息；ID可能完全错误，或者它可能还没有发生。这两种情况都应该提供不同的结果。最后，如果一切看起来都很好，我们尝试评分会议，这应该会正常工作并返回一些数据以响应，并以隐含的`200`状态完成请求。
- en: The implementation of the preceding methods are available at `src/models/meeting.js`
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的实现可在`src/models/meeting.js`中找到
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The implementation method should be pretty readable. The `didMeetingHappened()`
    method looks for a maximum of one document with `_id`, where `user1` and `user2`
    are filled. When this document is found, we look at the `at` field and compare
    with the current time to check whether it already happened.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方法应该是相当易读的。`didMeetingHappened()`方法寻找最多一个带有`_id`的文档，其中`user1`和`user2`被填写。当找到这个文档时，我们查看`at`字段并与当前时间比较，以检查它是否已经发生。
- en: The rate is a bit longer but just as simple. We find the `meeting` object and
    figure out which user is being rated. Such feedback belonging to the opposite
    user is stored in an atomic operation, setting either field `user1reviewed` or
    `user2reviewed` with the key for the feedback.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 速率略长，但同样简单。我们找到`meeting`对象，并确定哪个用户正在被评分。这种属于相反用户的反馈存储在原子操作中，设置字段`user1reviewed`或`user2reviewed`与反馈的键。
- en: We have a thorough test suite implemented for this case, where we mind both
    success & failure cases. It can be used to check the emails by simply calling
    the test with `NODE_ENV=development mocha test/meeting_followup.js`, which then
    overrides the test environment with development and delivers emails to our provider,
    so we can see how it looks and fine-tune it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这种情况实现了一个详尽的测试套件，我们关注成功和失败的情况。可以通过简单地调用带有`NODE_ENV=development mocha test/meeting_followup.js`的测试来检查电子邮件，这将覆盖测试环境为开发模式，并将电子邮件发送到我们的提供商，这样我们就可以看到它的样子并进行微调。
- en: Our test for this whole scenario is a bit long but we need to test several things!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个整个场景的测试略长，但我们需要测试几个事情！
- en: Clean up DB
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理数据库
- en: Setting up the meeting
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置会议
- en: Register user 1
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册用户1
- en: Register user 2 at the same position
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相同位置注册用户2
- en: STest that non-existent meetings can't be reviewed
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试不存在会议无法被审查
- en: Status 412 on meeting reviews that still didn't happen
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态412在尚未发生的会议审查中
- en: Travel time two days ahead
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提前两天计算旅行时间
- en: Send an email
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: Taking up a review that makes sense
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择有意义的复习内容
- en: User 1 should be able to review the meeting
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户1应该能够审查会议
- en: User 2 should be able to review the meeting as well
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户2也应该能够审查会议
- en: Seems like we can now send emails and receive reviews, which is great, but how
    do we send the emails in a time-sensitive manner? A couple of minutes after the
    meeting has started, the emails should be sent to both parties.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们现在可以发送电子邮件并接收评论，这很好，但我们如何以时间敏感的方式发送电子邮件？会议开始后几分钟，电子邮件应该发送给双方。
- en: (Source:git checkout 7f5303ef10bfa3d3bfb33469dea957f63e0ab1dc)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: (来源：git checkout 7f5303ef10bfa3d3bfb33469dea957f63e0ab1dc)
- en: Periodical tasks with node-cron
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用node-cron进行周期性任务
- en: Maybe you are familiar with cron ([http://en.wikipedia.org/wiki/Cron](http://en.wikipedia.org/wiki/Cron)).
    It's a Unix-based task scheduling system that makes running tasks easy. One problem
    with it is that it's linked to your platform, and it's not trivial to turn it
    on and off from code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你熟悉cron ([http://en.wikipedia.org/wiki/Cron](http://en.wikipedia.org/wiki/Cron))。它是一个基于Unix的任务调度系统，使得运行任务变得容易。它的问题之一是与你的平台相关联，从代码中开启和关闭它并不简单。
- en: Meet node-cron ([https://github.com/ncb000gt/node-cron](https://github.com/ncb000gt/node-cron)).
    It's basically the same task scheduler but it runs directly from your Node application,
    so as long as it is up, your jobs should run.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 认识一下`node-cron`（[https://github.com/ncb000gt/node-cron](https://github.com/ncb000gt/node-cron)）。它基本上是一个相同的任务调度器，但它直接从您的Node应用程序运行，因此只要它运行，您的作业就应该运行。
- en: 'Our strategy is simple: Periodically select all meetings that need mailing,
    call our mailer with each of these meetings, and then mark it as emailed.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略很简单：定期选择所有需要邮寄的会议，调用我们的邮件发送者，并针对这些会议中的每一个，将其标记为已邮寄。
- en: 'Following this app''s convention, let''s separate concerns into their own folders,
    starting with `src/tasks/index.js`, as shown in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 按照此应用程序的约定，让我们将关注点分离到它们自己的文件夹中，从以下代码中的`src/tasks/index.js`开始：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It needs to take `models` and `mailer` as parameters, which can be used inside
    tasks. `followupMail` is the single user defined for now because it''s all we
    need. The exported method `init` is what will kick start the cron job, the timer
    presenting respectively: `00` defined as the seconds, meaning it will run at second
    `00`, for every `*/15` minutes, any hour, any day of the month, any month, any
    day of the week. For the actual task, see `src/mailer/followUp.js`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要将`models`和`mailer`作为参数，这些参数可以在任务中使用。`followupMail`是目前唯一定义的用户，因为我们只需要它。导出的`init`方法将启动cron作业，定时器分别表示：`00`定义为秒，意味着它将在每`*/15`分钟的第`00`秒运行，任何小时，任何月份的任何一天，任何月份，任何星期的任何一天。关于实际任务，请参阅`src/mailer/followUp.js`
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It returns a function, which when executed, looks up all meeting documents that
    still need to be mailed and for each one, use `mailer.followUp` as we defined
    before and upon completion, mark each email as sent. Notice that fails here have
    nowhere to communicate and that's because it's an automated task. It's important
    for web servers to have meaningful log reporting, so in this case, the warning
    messages should be reported.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个函数，当执行时，查找所有仍需要邮寄的会议文档，并对每个文档使用我们之前定义的`mailer.followUp`，完成后，将每封电子邮件标记为已发送。请注意，这里的失败没有地方可以通信，因为这是一个自动化的任务。对于Web服务器来说，有意义的日志报告很重要，因此在这种情况下，警告消息应该被报告。
- en: 'Of course, this would require us to add two methods to `src/models/meeting.js`,
    which you should be able to easily make sense of by now:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这需要我们在`src/models/meeting.js`中添加两个方法，你现在应该能够轻松理解：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For our final test, we'll be creating four users implying 2 meetings, travel
    2 days in the future and try sending the emails through the task, it should work
    and mark both emails as sent.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最终测试中，我们将创建四个用户，意味着有2个会议，提前2天旅行，并通过任务尝试发送电子邮件，它应该工作并标记两封电子邮件为已发送。
- en: Clear DB
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清空数据库
- en: Register users 1, 2, 3, and 4 at the same location
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一地点注册用户1、2、3和4
- en: Travel time after the meeting is done
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会议结束后，旅行时间
- en: Task should send an email
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务应发送电子邮件
- en: Verify that the emails were sent
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证电子邮件是否已发送
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created an API that can set up meetings between users taking
    into account their matching history and the pair of longitude and latitude, while
    providing them the chance to give feedback on how it went-essential information
    which can be used in many ways to further improve the algorithm!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个API，该API可以在考虑用户的匹配历史和经纬度对的情况下为用户安排会议，同时给他们提供机会对会议进行反馈——这些信息可以以多种方式使用，以进一步改进算法！
- en: We hope you learned about many interesting and practical concepts, such as making
    geo queries, testing time-sensitive code, sending e-mails with style, and tasks
    that run periodically.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您了解了许多有趣且实用的概念，例如进行地理查询、测试时间敏感的代码、以风格发送电子邮件以及定期运行的任务。
- en: Besides the technical bits, hope you had fun and perhaps were able to spark
    some insight on the framework behind match-making apps!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了技术细节之外，希望您玩得开心，也许能够激发一些关于匹配应用框架的洞察！
- en: Next on, we'll see how `Koa.js` works by leveraging the power of generators,
    bringing the readability of synchronous code on top of the async features of Node.js.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过利用生成器的力量来了解`Koa.js`的工作原理，将同步代码的可读性置于Node.js的异步功能之上。
