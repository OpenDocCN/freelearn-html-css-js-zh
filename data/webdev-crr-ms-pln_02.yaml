- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Bridging the Divide – Client (Frontend) versus Server (Backend) Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥梁建设——客户端（前端）与服务器（后端）开发
- en: Now, I’d like to delve deeper into the idea that was introduced in [*Chapter
    1*](B18315_01.xhtml#_idTextAnchor015) – that a web developer is a software developer
    – and then talk about the various job titles that you might find yourself with
    these days (it might surprise you to learn that “web developer” might be the *least*
    likely!).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想深入探讨在[*第一章*](B18315_01.xhtml#_idTextAnchor015)中引入的想法——即网络开发者是软件开发者——然后讨论你可能会遇到的各种职位（你可能会被惊讶地发现“网络开发者”可能是*最不常见*的！）。
- en: In the process, I’ll begin to introduce some of the concepts that go into building
    that technological foundation, such as getting into HTML, CSS, and JavaScript
    in more detail, what event handlers are, what the DOM is, introducing server-side
    programming ideas such as Node, and finally a look at some of the job titles you
    might encounter in this field.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我将开始介绍构建这个技术基础所需的一些概念，例如更详细地了解HTML、CSS和JavaScript，什么是事件处理器，什么是DOM，介绍服务器端编程思想如Node，最后看看你在这个领域可能会遇到的某些职位名称。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Understanding the client (the frontend)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解客户端（前端）
- en: Understanding the server (the backend)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务器（后端）
- en: Defining web developer types and job titles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义网络开发者类型和职位名称
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: GitHub is an online service – free for personal use – where you can store your
    code and, optionally, share it with the world. GitHub, as the name clues you into,
    uses the Git source code repository, or SCM, software. We’re going to get into
    that later, but for now, it’s enough to know that GitHub is where you put stuff,
    as well as access the stuff others make available. This “stuff,” which is usually
    code, gets put into repositories, or repos for short. For now, just think of a
    repo as you would a directory on your computer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub是一个在线服务——个人使用免费——你可以在这里存储你的代码，并且可以选择与全世界分享。GitHub，正如名字所暗示的，使用Git源代码仓库，或称为SCM（源代码管理）软件。我们稍后会详细介绍这一点，但就目前而言，只需知道GitHub是你放置东西的地方，以及访问他人提供的内容即可。这些“东西”，通常是代码，被放入仓库，或简称repos。现在，你可以把repo想象成你电脑上的一个目录。
- en: 'For this book, head here: [https://github.com/PacktPublishing/Web-Development-Career-Master-Plan](https://github.com/PacktPublishing/Web-Development-Career-Master-Plan).
    This is the repository where you’ll find all the source code for this book. At
    this point, take a few moments to create an account for yourself there and download
    the code so that you’re ready to go from this point on. After creating your account
    and going to this book’s repository, you can download the code by clicking the
    big green **Code** button; from there, you can download a ZIP file that will contain
    all the content from the repo.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，请访问此处：[https://github.com/PacktPublishing/Web-Development-Career-Master-Plan](https://github.com/PacktPublishing/Web-Development-Career-Master-Plan)。这是你将找到这本书所有源代码的仓库。在此阶段，花几分钟时间在那里为自己创建一个账户并下载代码，以便从这个点开始准备。在创建账户并访问这本书的仓库后，你可以通过点击大绿色的**代码**按钮来下载代码；从那里，你可以下载一个包含仓库所有内容的ZIP文件。
- en: Understanding the client (the frontend)
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解客户端（前端）
- en: When a developer says **frontend**, what they are generally referring to is
    the client side of a website. *Okay, that’s great*, I hear you say, but what does
    that mean?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个开发者说**前端**时，他们通常指的是网站的客户端。*好吧，那很好*，你可能会说，但这意味着什么呢？
- en: 'In [*Chapter 1*](B18315_01.xhtml#_idTextAnchor015), I showed you a very simple
    example of a web page. That page was built with three main technologies: HTML,
    CSS, and JavaScript. These three technologies are ultimately all that a web browser
    understands. Also in that chapter, I explained that HTML stands for Hypertext
    Markup Language, but I didn’t explain what that meant. To do so, we have to break
    it down, word by word.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18315_01.xhtml#_idTextAnchor015)中，我向你展示了一个非常简单的网页示例。该页面使用三种主要技术构建：HTML、CSS和JavaScript。这三种技术是网络浏览器最终理解的所有内容。在那章中，我还解释了HTML代表超文本标记语言，但我没有解释它的含义。为了做到这一点，我们必须逐字分解。
- en: Dissecting HTML
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构HTML
- en: 'To explain HTML, I’m going to skip over the first word, Hypertext (we’ll come
    back to it later). For now, let me ask you this question. Imagine that I wrote
    the following on a piece of paper:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释HTML，我将跳过第一个词，超文本（我们稍后会回到它）。现在，让我问你一个问题。想象一下，我在一张纸上写了以下内容：
- en: '*“Please return my dog Betty* *if found!”*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*“如果找到我的狗贝蒂，请归还！*”'
- en: Then, I gave that paper to a sign maker, and I wanted them to make that text
    red on a sign. How would I direct them to do that?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我把那张纸给了招牌制造商，我想让他们在招牌上把那段文字做成红色。我会如何指导他们这样做？
- en: 'There are many ways I might do this, but whatever form I choose, what would
    I call that instruction? Well, there’s a term that provides the answer: **markup**.
    We might write something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能会有很多种方法来做这件事，但无论我选择哪种形式，我会称这个指令为什么？嗯，有一个术语可以提供答案：**标记**。我们可能会写一些像这样的事情：
- en: '*“RED -> Please return my dog Betty* *if found!”*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*“RED -> 请归还我的狗贝蒂* *如找到！”*'
- en: That `RED->` text, we could say, “marks up” the content and provides an instruction
    – make this red – to someone who understands your markup language. If you’ve agreed
    on that language beforehand, then you can communicate what you want to happen
    in this way.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样说，那个 `RED->` 文本“标记”了内容，并为理解你的标记语言的人提供了一个指令——使这个变红。如果你事先已经同意了这种语言，那么你就可以通过这种方式传达你想要发生的事情。
- en: Another way to say this is that the `RED->` text is **metadata**. Metadata is
    a common programming concept that, in its simplest terms, means data that describes
    other data. We want the underlying data – the text on the sign – to be red, so
    we need some other data to describe the color of that data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种说法是，`RED->` 文本是 **元数据**。元数据是一个常见的编程概念，用最简单的术语来说，就是描述其他数据的数据。我们希望底层数据——标牌上的文本——是红色的，因此我们需要一些其他数据来描述该数据的颜色。
- en: HTML is such a standardized metadata language, and that’s where the M in Markup
    comes from. The idea is that the content to be displayed on the screen is marked
    up in various ways to tell the browser how to display it or do something with
    it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 是一种标准化的元数据语言，这就是“标记”中的 M 的来源。其理念是，要在屏幕上显示的内容以各种方式标记，以告诉浏览器如何显示它或对它进行操作。
- en: 'In HTML, marking up the content is done using **tags**, and they take a common
    form:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，标记内容是通过使用 **标签** 来完成的，并且它们具有一个常见的格式：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you need to mark up some content, you must start by creating an *opening*
    tag. Some examples you might see are `<body>`, `<div>`, `<p>`, and `<span>`. The
    text within the `<>` characters determines the type of tag it is, which provides
    the meaning of what you’re marking up. Then, the content (`xxx`, in this example,
    to denote it might be anything) to be marked up comes next. At the end of that
    content, you add a *closing* tag, which is the same as the opening tag but with
    `/` before the name of the tag. Every opening tag must have a matching closing
    tag, forming a pair of tags (or a *block*, as it’s sometimes called); otherwise,
    you’ll run into problems, usually in the form of the page not appearing on the
    screen how you expect. Also, note that some tags can be *self-closing*, such as
    `<hr/>`, essentially combining the opening and closing tags. There aren’t too
    many of those, though.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要标记一些内容时，你必须首先创建一个 *开始* 标签。你可能看到的例子包括 `<body>`、`<div>`、`<p>` 和 `<span>`。`<>`
    字符内的文本决定了标签的类型，这提供了你标记的意义。然后，接下来是你要标记的内容（在这个例子中，用 `xxx` 来表示它可能是任何东西）。在该内容的末尾，你添加一个
    *结束* 标签，它与开始标签相同，但在标签名称前有一个 `/`。每个开始标签都必须有一个匹配的结束标签，形成一个标签对（或者有时被称为 *块*）；否则，你可能会遇到问题，通常表现为页面没有按照你预期的样子显示在屏幕上。此外，请注意，一些标签可以是
    *自闭合* 的，例如 `<hr/>`，这实际上是将开始和结束标签合并在一起。不过，这样的标签并不多。
- en: 'Speaking of “not too many,” there is a finite set of standard HTML tags that
    exist that the browser understands. As with most things, you don’t have to try
    and memorize them all, and some you will use very infrequently. In addition, over
    time, some get *deprecated*, meaning they are no longer used, or at least shouldn’t
    be used. But web browsers like to maintain backward compatibility, meaning that
    older sites should still work in newer browsers, so deprecated tags tend to stick
    around for a while, sometimes many years. Here’s an example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 说到“不多”，存在一组有限的、浏览器能够理解的标准化 HTML 标签。和大多数事情一样，你不必试图记住它们所有，而且有些你可能会很少使用。此外，随着时间的推移，一些标签会被弃用，这意味着它们不再被使用，或者至少不应该被使用。但是，网络浏览器喜欢保持向后兼容性，这意味着旧网站应该在新的浏览器中仍然有效，所以弃用的标签往往会持续一段时间，有时甚至很多年。以下是一个例子：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `<b>` tag has been deprecated for a long time and should no longer be used,
    but you’ll find it still works in the most recent browsers. It makes text bold,
    and it’s deprecated because that job can be done better with CSS.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`<b>` 标签已经很久以前就被弃用了，不应该再被使用，但你仍然会在最新的浏览器中找到它仍然有效。它可以使文本加粗，但它被弃用是因为这项工作可以用 CSS
    更好地完成。'
- en: Before we go any further, let me state that tag names are not case-sensitive.
    You can write `<body>`, `<BODY>`, `<Body>`, or even `<BoDy>` if you like, and
    the browser will handle all of them just fine. That said, most developers tend
    to write them in all lowercase, and that’s the convention I’ll use throughout
    as well. It’s also worth noting that there are a lot of things in software development
    that are case-sensitive – CSS and JavaScript, for example – but HTML isn’t, at
    least not as far as tag names go. It’s not so important what convention you use,
    but it is of critical importance that you are consistent with whatever it is.
    When you get into a professional environment, that will very much be expected
    of you, so it’s a habit I strongly encourage you to get into now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我明确一点：标签名称不区分大小写。你可以写成 `<body>`，`<BODY>`，`<Body>`，甚至 `<BoDy>`，只要你喜欢，浏览器都会很好地处理它们。话虽如此，大多数开发者倾向于将它们全部写成小写，这也是我将在整个文档中使用的惯例。值得注意的是，软件开发中有许多东西是区分大小写的——例如
    CSS 和 JavaScript——但 HTML 不是，至少就标签名称而言不是。使用哪种惯例并不那么重要，但保持一致性至关重要。当你进入专业环境时，这将是对你的一种很大期望，所以这是一个我强烈建议你养成的习惯。
- en: Now, let’s look at the basic structure of a web page.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看网页的基本结构。
- en: The anatomy of an HTML document
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML 文档的结构
- en: 'When we write HTML, we create what’s called an HTML document. This document
    is a file, usually with a `.html` or `.htm` extension. It’s a plain text file
    that can be edited in any text editor, such as Notepad on Windows – no special
    tools are needed. An HTML document has a standard structure that, at a high level,
    looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写 HTML 时，我们创建了一个被称为 HTML 文档的东西。这个文档是一个文件，通常带有 `.html` 或 `.htm` 扩展名。它是一个纯文本文件，可以在任何文本编辑器中编辑，例如
    Windows 上的记事本——不需要任何特殊工具。HTML 文档有一个标准的结构，从高层次来看，看起来像这样：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The HTML document itself is created by starting it with an `<html>` tag and
    ending it with its closing partner, `</html>`. Everything between those tags represents
    the content they’re marking up, which in this case is the entire HTML document
    itself. Here, you can see a new fact about HTML: tags can be the content for other
    tags. We say that these tags are *nested*, or that they are *children* of other
    tags.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文档本身是通过以 `<html>` 标签开始并以其对应的结束标签 `</html>` 结束来创建的。这些标签之间的所有内容代表它们所标记的内容，在这种情况下是整个
    HTML 文档本身。在这里，你可以看到关于 HTML 的一个新事实：标签可以是其他标签的内容。我们说这些标签是“嵌套”的，或者说它们是其他标签的“子标签”。
- en: In the code, we have a `<head>` tag and a `<body>` tag nested within the `<html>`
    tag, so they are children of the `<html>` tag (and by extension, you can reverse
    that and say that the `<html>` tag is the parent of the `<``head>` tag).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们有一个 `<head>` 标签和一个 `<body>` 标签嵌套在 `<html>` 标签内，因此它们是 `<html>` 标签的子标签（并且由此可以反过来，可以说
    `<html>` 标签是 `<head>` 标签的父标签）。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: From now on, I’m not going to list the closing tag unless there is an explicit
    reason to do so. You should assume there is a closing tag, as there is here for
    `</head>` and `</body>`, unless otherwise stated.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，除非有明确的原因，否则我不会列出结束标签。你应该假设存在一个结束标签，就像这里的 `</head>` 和 `</body>` 一样，除非另有说明。
- en: 'The `<head>` tag defines one of two sections of an HTML document: the head.
    This section contains content that isn’t displayed on the screen. It’s more like
    information the browser can use in various ways. For example, when we get to CSS,
    you’ll see that it is often put in the head of the document. The same can be true
    of JavaScript code. There are other tags you might see inside the head, such as
    `<title>`, which provides the title you’ll see at the top of your browser, or
    `<meta>`, which provides various pieces of metadata to the browser about the page
    (for example, the icon you normally see when you look at a website you’ve bookmarked
    can be defined here). However, none of that is required, hence I haven’t shown
    it here. Technically, the head itself isn’t required either, but it’s good practice
    to always include it, even if you put nothing in it.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`<head>` 标签定义了 HTML 文档的两个部分之一：头部。这个部分包含不显示在屏幕上的内容。它更像是浏览器可以用各种方式使用的信息。例如，当我们学习
    CSS 时，你会看到它通常被放在文档的头部。JavaScript 代码也是如此。你可能会在头部看到其他标签，例如 `<title>`，它提供了你将在浏览器顶部看到的标题，或者
    `<meta>`，它向浏览器提供了有关页面的一些元数据（例如，当你查看你已收藏的网站时通常看到的图标可以在这里定义）。然而，这些都并非必需，因此我没有在这里展示。从技术上讲，头部本身也不是必需的，但始终包含它是良好的实践，即使你什么也不放进去。'
- en: The `<body>` tag defines the main portion of the document – the part that contains
    the content that will be displayed on the screen. And – you guessed it – that
    section of the document is called the body! The simplest content you can put there
    is just plain text. You don’t need to mark it up in any special way; the browser
    will simply display it as-is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`<body>` 标签定义了文档的主要部分——包含将在屏幕上显示的内容的部分。而且——你猜对了——文档的这个部分就叫做主体！你可以放在那里的最简单的内容就是纯文本。你不需要以任何特殊的方式标记它；浏览器会直接以原样显示它。'
- en: 'But where the power starts to come in is when you start to use other HTML tags
    in the body. Let’s look at a more advanced example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但真正的威力开始显现，是在你开始在正文中使用其他HTML标签的时候。让我们来看一个更高级的例子：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is a lot more going on here, but let’s take it from the top, bit by bit,
    and introduce a bunch of new tags and concepts in the process. Don’t worry – it’s
    not as bad as it looks!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情还有很多，但让我们从最基本的部分开始，一步一步地来，在这个过程中介绍一些新的标签和概念。别担心——实际情况并没有看起来那么糟糕！
- en: The head
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头部
- en: We start with a `<html>` tag, as before, followed by a `<head>` tag to define
    the document’s head. Inside the head, we have a `<title>` tag that defines the
    title of the document (typically seen in the header of your browser and is usually
    also the text of a bookmark you create for the site). The `<style>` tag is where
    we put CSS, which tells the browser details about how we want our content to be
    displayed – we’ll skip that for now, though.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从之前的 `<html>` 标签开始，然后是一个 `<head>` 标签来定义文档的头部。在头部内部，我们有一个 `<title>` 标签，它定义了文档的标题（通常在浏览器标题栏中看到，也是你为该网站创建书签时的文本）。`<style>`
    标签是我们放置CSS的地方，它告诉浏览器我们希望内容如何显示——但现在我们会跳过这一点。
- en: The head of an HTML document contains metadata about the document – content
    that is not visible in a browser (aside from the title, which is typically displayed
    in the title bar of the browser window). This content can affect what’s displayed,
    though, maybe by importing JavaScript, which results in content being created,
    or that CSS I mentioned, but we’ll get to that in just a bit. You will sometimes
    find literal `<meta>` tags in the head, as you saw in the example in [*Chapter
    1*](B18315_01.xhtml#_idTextAnchor015), to define the character set the document
    uses, the viewport (essentially, this is the browser window) sizing that should
    be used, and more. But the key point is that none of this is content that’s meant
    to be explicitly displayed. That’s what the body of the document is for.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文档的头部包含有关文档的元数据——在浏览器中不可见的内容（除了标题，通常在浏览器窗口的标题栏中显示）。然而，这些内容可能会影响显示效果，比如通过导入JavaScript来创建内容，或者我提到的CSS，但我们会稍后再讨论这一点。你有时会在头部找到实际的
    `<meta>` 标签，就像你在[*第一章*](B18315_01.xhtml#_idTextAnchor015)中看到的例子一样，来定义文档使用的字符集、视口（基本上就是浏览器窗口）的大小以及更多。但关键点是，这些都不是旨在明确显示的内容。这就是文档主体的作用。
- en: The body
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主体
- en: 'After the closing `</head>` tag, we have our opening `<body>` tag; this is
    where we can start displaying content. This content begins with a `<h1>` tag,
    which is used to mark up text as a heading. There are several `<h>` tags, `<h1>`
    through `<h6>`. Think of these as you would when writing an outline of a book:
    `<h1>` tags are your top-level subjects, `<h2>` tags are sub-sections under an
    `<h1>` tag, and so on as the numbers increase. Visually, by default, a `<h1>`
    tag is larger than a `<h2>` tag, and the text gets smaller as the number increases.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `</head>` 标签之后，我们有了开头的 `<body>` 标签；这是我们开始显示内容的地方。这个内容从 `<h1>` 标签开始，它用于标记文本作为标题。有几个
    `<h>` 标签，从 `<h1>` 到 `<h6>`。你可以把这些想象成写一本书的大纲：`<h1>` 标签是你的顶级主题，`<h2>` 标签是 `<h1>`
    标签下的子部分，以此类推，数字越大，文本越小。
- en: Below the heading is a `<hr>` tag, and this is one of those rare self-closing
    ones. This tag draws a line, or horizontal rule, below the heading.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题下方是 `<hr>` 标签，这是一个罕见的自闭合标签。这个标签在标题下方画一条线，或者说是水平线。
- en: 'After that comes a `<p>` tag, which stands for paragraph. The text in it will
    be displayed until it’s too wide for the browser window, at which point it will
    flow down onto another line, and so on. Any content that comes after the closing
    `</p>` tag will automatically start on a new line below the paragraph. This is
    a common paradigm when building a web page: we’re largely concerned with defining
    horizontal sections like this, and `<p>` is just one way of doing that.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个`<p>`标签，代表段落。其中的文本将一直显示，直到它太宽以至于浏览器窗口无法显示，此时它将流到下一行，依此类推。任何在`</p>`标签关闭之后的内容都将自动在新的一行下面开始。这在构建网页时是一个常见的范式：我们主要关注定义像这样的水平部分，而`<p>`只是实现这一点的众多方式之一。
- en: The `<div>` tag that comes next is another way to create a horizontal section,
    and it is probably the most common. The difference between `<p>` and `<div>` is
    one of semantics. The term *semantics* here refers to the meaning of the tags,
    which defines the purpose and role of the content within them. The `<p>` tag is
    intended to denote “this is a paragraph, a block of text,” whereas `<div>` does
    not have any inherent meaning like that. But, in practice, they function the same
    and provide the same visual result, so in many cases, it won’t matter which you
    use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`<div>`标签是创建水平部分的另一种方式，这可能是最常见的方式。`<p>`和`<div>`之间的区别在于语义。这里的术语*语义*指的是标签的含义，它定义了标签内内容的用途和角色。`<p>`标签的目的是表示“这是一个段落，一段文本”，而`<div>`则没有这样的固有含义。但在实践中，它们的功能相同，并提供相同的视觉结果，所以在很多情况下，使用哪个并不重要。
- en: Tag attributes
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签属性
- en: 'Differences aside, this `<div>` tag provides an example of something new: `id`.
    This gives a name to the tag that we can use in our code later to do things with
    that tag (or *element*, as we tend to call pairs of tags and all their content
    when we talk about them on a web page).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '不论差异如何，这个`<div>`标签提供了一个新事物的例子：`id`。这给标签赋予了一个名称，我们可以在代码中稍后使用这个名称来对该标签（或*元素*，当我们谈论网页上的成对标签及其所有内容时，我们倾向于这样称呼）进行操作。 '
- en: Attributes are always in the form of `name=value`. So, here, `id` is the name
    of the attribute, and `nav` is the value given to it. Note that in programming
    in general, when we have a string of characters that isn’t a number, we literally
    call it a string and almost always enclose it in quotation marks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 属性总是以`name=value`的形式存在。因此，在这里，`id`是属性的名称，而`nav`是赋予它的值。请注意，在编程的一般情况下，当我们有一个不是数字的字符序列时，我们实际上称之为字符串，并且几乎总是用引号括起来。
- en: Back to the markup
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回到标记
- en: Going back to the markup, the `<div>` tag here defines our navigation section,
    hence the `id` value. Nested inside that `<div>` is another common tag that’s
    used to produce a bulleted list of items, namely `<ul>`. This stands for `<ol>`,
    which produces a list where each item in the list is numbered automatically. Every
    item in either kind of list gets put into a `<li>`, or list item, tag.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 回到标记，这里的`<div>`标签定义了我们的导航部分，因此有`id`值。嵌套在这个`<div>`内部的是另一个常用的标签，用于生成项目的项目符号列表，即`<ul>`。这代表`<ol>`，它生成一个列表，列表中的每个项目都会自动编号。列表中的任何一种类型的每个项目都将放入一个`<li>`，或列表项，标签中。
- en: After we close the `<li>` and `<div>` tags appropriately, we come across another
    `<div>` tag, this one defining an area we call `characterBio`. This is where we’ll
    show the biographical information of the selected character. The idea of this
    page would be that the user can click a character and see their bio. However,
    note that it’s not complete like it is here, and that’s by design. We’ll build
    on it later to add that interactivity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当地关闭`<li>`和`<div>`标签之后，我们遇到了另一个`<div>`标签，这个标签定义了一个我们称之为`characterBio`的区域。这就是我们将展示所选角色的传记信息的地方。这个页面的想法是用户可以点击一个角色并查看他们的传记。然而，请注意，它并不像这里这样完整，这是有意为之。我们将在稍后在此基础上添加交互性。
- en: Inside the `characterBio` `<div>` tag, we have a `<h2>` tag to show the character’s
    name a little bigger than regular text, but not as big as the main `<h1>` header
    at the top. And then we have another `<p>` tag where the character’s bio text
    is.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`characterBio` `<div>`标签内部，我们有一个`<h2>`标签，用来显示比普通文本稍大的角色名字，但并不像顶部的主`<h1>`标题那样大。然后我们还有一个`<p>`标签，其中包含角色的生物文本。
- en: Finally, we close the `<body>` and `<html>` tags, and we have a complete web
    page!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们关闭`<body>`和`<html>`标签，我们就有一个完整的网页了！
- en: 'Upon opening that file in your web browser of choice, you should see what’s
    shown in *Figure 2**.1*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在您选择的网页浏览器中打开该文件后，您应该看到*图2*.1中所示的内容：
- en: '![Figure 2.1: The result of our HTML (yes, I’m a big fan of this show!)](img/B18315_02_1.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：我们HTML的结果（是的，我是个大粉丝！）](img/B18315_02_1.jpg)'
- en: 'Figure 2.1: The result of our HTML (yes, I’m a big fan of this show!)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：我们HTML的结果（是的，我是个大粉丝！）
- en: Okay, I made a promise earlier that we’d come back to the Hypertext part of
    HTML, so let me fulfill that promise right now!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我之前承诺过我们会回到HTML的超级文本部分，现在让我履行这个承诺吧！
- en: What about that Hypertext part?!
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那个超文本部分怎么样？！
- en: 'The term **Hypertext** in HTML refers to the ability of one HTML document to
    link to another, or to a resource it depends on. It’s these links that form the
    web. These links can be created in several ways, and they largely boil down to
    some new tags:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: HTML中的术语**超文本**指的是一个HTML文档能够链接到另一个文档或它所依赖的资源的能力。正是这些链接构成了网络。这些链接可以通过几种方式创建，并且它们在很大程度上归结为一些新的标签：
- en: '`<a>`: This tag creates an explicit link to another page. With it, you might
    write the following:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<a>`：这个标签创建了一个指向另一个页面的显式链接。有了它，你可以写出以下内容：'
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As with most tags, you have an opening and closing tag pair, with some content
    in the middle. In this case, the content is the text the user will see on the
    screen and be able to click. The `href` attribute (short for HTML reference) provides
    the URL to navigate to when clicked.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与大多数标签一样，你有一个打开标签和关闭标签对，中间有一些内容。在这种情况下，内容是用户将在屏幕上看到的文本，并且可以点击的文本。`href`属性（简称HTML引用）提供了点击时导航到的URL。
- en: '`<img>`: This is how images are shown on a page (well, the simplest way at
    least):'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<img>`：这是在页面上显示图片的方式（至少是最简单的方式）：'
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This tag is a bit of a curiosity because there is no closing `</img>` tag, nor
    do you need to self-close it (and in fact, some browsers won’t display the image
    correctly if you do). Regardless, so long as the image file, `company_logo.png`,
    is in the same location as the HTML document, it will be shown when the page is
    rendered – that is, shown on the screen. Alternatively, you can specify a complete
    URL in the `src` attribute (short for “source”), which allows you to display images
    from other locations.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个标签有点好奇，因为没有关闭的`</img>`标签，而且你也不需要自己关闭它（实际上，如果你这样做，一些浏览器可能无法正确显示图片）。无论如何，只要图片文件`company_logo.png`与HTML文档位于同一位置，当页面渲染时就会显示出来——也就是说，显示在屏幕上。或者，你可以在`src`属性（简称“源”）中指定一个完整的URL，这允许你从其他位置显示图片。
- en: '`<script>` and `<link>`: These allow you to link to JavaScript files and CSS
    files, respectively (technically, `<link>` allows you to link to other types of
    files as well, but CSS files are usually what it’s used for):'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<script>`和`<link>`：这些允许你链接到JavaScript文件和CSS文件，分别（技术上，`<link>`允许你链接到其他类型的文件，但CSS文件通常是它的用途）：'
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the case of the `<script>` tag, you will always have a closing `</script>`
    tag with no content between it and the opening tag. The `type` attribute specifies
    the language, though in this day and age, it’ll virtually never be anything but
    `text/javascript`.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`<script>`标签的情况下，你将始终有一个关闭的`</script>`标签，其中没有内容介于它和打开标签之间。`type`属性指定了语言，尽管在这个时代，它几乎永远不会是除了`text/javascript`之外的其他内容。
- en: For the `<link>` tag, `rel` defines the relationship between the HTML document
    it’s in and the file being linked to, and like the `type` attribute of the `<script>`
    tag, while it supports other values, it’ll almost always be `stylesheet`. The
    `type` attribute will also pretty much always be `text/css` these days, and you
    already know what `href` is all about.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`<link>`标签，`rel`定义了HTML文档与其所链接的文件之间的关系，并且像`<script>`标签的`type`属性一样，尽管它支持其他值，但它几乎总是`stylesheet`。这些天，`type`属性也几乎总是`text/css`，你已经知道`href`是什么了。
- en: Note that unlike `<script>`, a `<link>` tag will always be self-closing, as
    shown here. As with the `<img>` tag, you can specify either a file that lives
    alongside the HTML document, as shown here, or you can specify a complete URL
    to link to a file somewhere else, be it a whole other server or even a resource
    you don’t control yourself.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，与`<script>`不同，`<link>`标签将始终是自闭合的，如下所示。与`<img>`标签一样，你可以指定一个与HTML文档位于同一位置的文件，如下所示，或者你可以指定一个完整的URL来链接到其他地方的文件，无论是整个其他服务器，甚至是你自己无法控制的资源。
- en: When you link to a JavaScript or CSS file like this, we say that the file is
    being *imported*, and we call these files *external* scripts or *external* stylesheets.
    We can compare this to stylesheets defined in a `<style>` block, which is internal
    since it’s embedded directly in an HTML document. The same is true for `<script>`
    blocks for JavaScript.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你像这样链接到JavaScript或CSS文件时，我们说该文件正在被**导入**，我们称这些文件为**外部**脚本或**外部**样式表。我们可以将它们与定义在`<style>`块中的样式表进行比较，这是内部的，因为它直接嵌入到HTML文档中。对于JavaScript的`<script>`块也是如此。
- en: While there are other ways to link to other HTML documents and resources, these
    are by far the most common.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有其他方式链接到其他HTML文档和资源，但这些无疑是最常见的。
- en: At this point, you’ve heard me mention CSS a few times, so let’s jump over to
    that topic and see what it’s all about!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经听我提到了CSS几次，那么让我们跳转到这个主题，看看它究竟是什么！
- en: Dissecting CSS
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS剖析
- en: 'I won’t lie to you: **CSS**, which stands for **Cascading Style Sheets**, can
    be… difficult. It’s not that the basic concepts underlying it are difficult –
    they are fairly simple – but there is *a lot* to it, and it can sometimes trip
    up very experienced developers. However, as with everything we’ve been discussing,
    if you take it little by little and don’t try and learn everything, it’s something
    you can handle!'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会对你撒谎：**CSS**，即**层叠样式表**，可能会有些困难。并不是它背后的基本概念很难——它们相当简单——但是内容很多，有时即使是经验丰富的开发者也会遇到困难。然而，就像我们一直在讨论的每一件事一样，如果你一点一点地学习，不试图一次性学习所有内容，那么这是你可以处理的！
- en: In the beginning, CSS was fairly simple to understand. If HTML roughly represents
    the structure of your house – the walls, the studs in them, the roof, the foundation,
    and so on – then CSS is the painter that comes in later and makes it pretty! For
    every element in your HTML document, you could tell the browser what styles to
    apply to it with CSS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，CSS相对简单易懂。如果HTML大致代表了你的房屋结构——墙壁、墙体内的梁、屋顶、地基等等——那么CSS就像是后来到来的画家，让它变得漂亮！对于你的HTML文档中的每个元素，你都可以使用CSS告诉浏览器应用哪些样式。
- en: 'So, let’s say you have this bit of HTML in the body of your document:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的文档体中有以下HTML代码：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let’s say I want to make the great Jedi master’s name red, his relatives’
    names green, and his friend’s names blue. I could do that by writing the following
    CSS inside of a `<style>` tag in the head of the document:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我想将伟大的绝地大师的名字设置为红色，他亲戚的名字设置为绿色，他朋友的名字设置为蓝色。我可以通过在文档的`<style>`标签内编写以下CSS来实现：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This small bit of CSS demonstrates most of the core concepts you need to internalize,
    starting with the idea of selectors. Simply put, every bit of CSS you write will
    apply to one or more elements on the page, and which one it applies to is determined
    by a selector. Here, I’m showing the three most common – a tag selector, an ID
    selector, and a class selector:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小段CSS展示了你需要内化的大多数核心概念，从选择器的概念开始。简单来说，你写的每一行CSS都将应用于页面上的一个或多个元素，而它将应用于哪个元素则由选择器决定。在这里，我展示了三种最常见的选择器——标签选择器、ID选择器和类选择器：
- en: 'A tag selector applies to all elements, or tags, of a given type. Here, by
    writing `h1 { color: red; }`, I’m saying that I want all `h1` tags on the page
    to be colored red.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '标签选择器适用于特定类型的所有元素或标签。在这里，通过编写`h1 { color: red; }`，我表示我想让页面上的所有`h1`标签都被设置为红色。'
- en: 'An ID selector, as shown in `#relatives { color: green; }`, says that the element
    with an ID of `relatives` should be colored green. Since the `id` attribute identifies
    an element with a specific name, you can only ever have one element on a page
    with a given ID (if you happen to reuse an ID, then the element that appears last
    as you read the HTML is the one that will have that ID, so as you can imagine,
    this can be the source of some insidious bugs if you get it wrong).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个ID选择器，如`#relatives { color: green; }`所示，表示具有ID为`relatives`的元素应该被设置为绿色。由于`id`属性用于标识具有特定名称的元素，因此在一个页面上只能有一个具有给定ID的元素（如果你不小心重复使用了ID，那么在阅读HTML时最后出现的元素将拥有该ID，所以你可以想象，如果出错，这可能是某些隐蔽错误的来源）。'
- en: 'The class selector – for example, `.friends { color: blue; }` – says that any
    element with a `class` attribute value of friends will be colored blue. You can
    apply this to as many elements as you want.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类选择器——例如，`.friends { color: blue; }`——表示任何具有`class`属性值为`friends`的元素将被设置为蓝色。你可以将其应用于任意多个元素。'
- en: Each of these three lines of code defines what we call a `color` to make the
    text. The selector for a given class is the text that comes before the opening
    brace. What type of selector it is, in these three cases, is determined by what
    character we start with. If we start with a hash (`#`), that means it’s an ID
    selector. If we start with a period (`.`), that means it’s a class selector. If
    it’s simply the name of an HTML tag with no special character at the start, then
    it’s a tag selector.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行代码中的每一行都定义了我们所说的`color`来使文本着色。给定类的选择器是开大括号前的文本。在这三个案例中，它是什么类型的选择器取决于我们开始的字符。如果我们以哈希(`#`)开头，这意味着它是一个ID选择器。如果我们以点(`.`)开头，这意味着它是一个类选择器。如果它只是HTML标签的名称，开头没有特殊字符，那么它就是一个标签选择器。
- en: But how is the style defined? We do that by setting style properties to a desired
    value, where color is one of a large set of possible attributes. There are attributes
    related to typography (`font-size`, `font-family`, and `font-weight`), some related
    to putting things in the background of a page (`background-color` and `background-image`),
    some for putting borders around things (`border-color`, `border-radius`, and `border-style`),
    properties for setting the size of elements (`width` and `height`), properties
    for changing the geometry of an element (`transform`), properties for hiding and
    showing elements (`display` and `visibility`), and properties for changing the
    position of an element from where it would normally render (`left`, `top`, `position`,
    and `z-index`). This is far from an exhaustive list. I just did a very quick count
    and, at present, it looks like there are over 200 different style properties available.
    Yikes!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但样式是如何定义的呢？我们通过将样式属性设置为期望的值来定义样式，其中颜色是大量可能属性之一。有一些属性与排版相关（`font-size`、`font-family`和`font-weight`），一些与在页面背景中放置内容相关（`background-color`和`background-image`），一些用于在事物周围放置边框（`border-color`、`border-radius`和`border-style`），用于设置元素大小的属性（`width`和`height`），用于更改元素几何形状的属性（`transform`），用于隐藏和显示元素的属性（`display`和`visibility`），以及用于更改元素位置的属性，从它通常渲染的位置（`left`、`top`、`position`和`z-index`）。这还远非详尽的列表。我只是快速数了一下，目前看起来有超过200种不同的样式属性可用。哇！
- en: 'When we talk about CSS, the *Stylesheet* part is fairly self-evident, and you
    just saw it: those three style classes and their corresponding selectors make
    up a Stylesheet. But what about the *Cascading* part? Well, that comes into play
    when you have multiple styles for a given style property that could apply to a
    given element. This can happen if you link to multiple stylesheets (because you
    can do that regardless of whether you also have your own styles in a `<style>`
    tag or not), or if multiple style classes match. For example, imagine if I changed
    the `h1` style class selector to a `p` selector. In this case, which class – and
    by extension, color – would apply? Would the text be red because of the match
    to the `<p>` tag, or would it be blue because of the class name match?'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论CSS时，*样式表*部分是相当显而易见的，您刚刚也看到了：这三个样式类及其相应的选择器组成了一个样式表。但*级联*部分又是什么呢？好吧，当您对一个给定元素的应用样式属性有多个样式时，它就派上用场了。这可能发生在您链接到多个样式表（因为无论您是否在`<style>`标签中也有自己的样式，您都可以这样做）或者多个样式类匹配的情况下。例如，假设我将`h1`样式类选择器更改为`p`选择器。在这种情况下，哪个类——以及由此延伸的颜色——将适用？文本会因为与`<p>`标签的匹配而变成红色，还是因为类名匹配而变成蓝色？
- en: 'The answer is determined by a cascading algorithm, where an algorithm is a
    procedure, implemented as a bit of code, that solves a specific problem or performs
    a specific task. The cascading rules this algorithm uses can get quite complex
    in practice, but in a nutshell, the following occurs:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 答案由一个级联算法决定，其中算法是一种作为代码片段实现的程序，用于解决特定问题或执行特定任务。这个算法使用的级联规则在实践中可能相当复杂，但简而言之，以下情况发生：
- en: A list of any selectors that could apply to the element is produced.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个可能应用于该元素的任何选择器的列表。
- en: These selectors are sorted into their order of importance, which largely means
    that those defined after others take precedence, though other factors can play
    into it as well.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些选择器按照其重要性的顺序排序，这基本上意味着那些在其他人之后定义的选择器具有优先权，尽管其他因素也可能产生影响。
- en: A selector is chosen based on `<p>` tags, but then there is one that is applied
    based on the `id` value, because the `id` value is unique in the document it is
    considered more specific, so it will override the value that would be applied
    based on an element being a `<``p>` tag.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器是基于 `<p>` 标签选择的，但还有一个是基于 `id` 值应用的，因为 `id` 值在文档中是唯一的，所以它被认为更具体，因此它将覆盖基于元素是
    `<p>` 标签而应用的值。
- en: A final decision based on the order of appearance of a style definition is made,
    which is largely the same as the decision based on importance but is a bit more
    straightforward.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据样式定义出现的顺序做出最终决定，这基本上与基于重要性的决定相同，但稍微直接一些。
- en: This covers the very basics of CSS, but as I said earlier, CSS can be difficult
    because there is a lot to it. So, surely there must be more than what I’ve said
    already, right? There is, and I’ll touch on at least some of it for you next.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了 CSS 的基础知识，但如我之前所说，CSS 可能很难，因为它有很多内容。所以，肯定比我说的还要多，对吧？确实如此，我会在接下来的内容中至少触及一些。
- en: Other CSS capabilities
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他 CSS 功能
- en: 'CSS can do a lot more than just change colors:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 可以做的不仅仅是改变颜色：
- en: There are properties for defining the layout of a page, for example. With these,
    you can divide a page into a grid, and then define in which squares of that grid
    various elements should live.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些属性可以用来定义页面的布局，例如。使用这些属性，你可以将页面划分为一个网格，然后定义各种元素应该位于该网格的哪些方块中。
- en: You can also use CSS to make the page “reflow” as the browser window’s size
    changes. This allows you to have a page layout that is optimized for smaller mobile
    device screens, as well as larger desktop screens, all without writing any code.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用 CSS 来使页面在浏览器窗口大小变化时“重排”。这允许你拥有一个针对较小移动设备屏幕以及较大桌面屏幕优化的页面布局，而无需编写任何代码。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: CSS isn’t generally considered code – it’s more like HTML in that it’s metadata.
    However, considering how powerful CSS is today and how complex it can get, I think
    we’re solidly in a gray area between code and not code at this point.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 通常不被认为是代码——它更像是 HTML，因为它是一种元数据。然而，考虑到 CSS 今天的强大功能和其可能变得多么复杂，我认为我们现在正处于代码和非代码之间的灰色地带。
- en: CSS also offers properties that can even allow you to animate elements on the
    page in various ways. You can make a page interactive with CSS alone, without
    writing any code (or at least what is *clearly* code). You can make an element
    grow when the user hovers over it, rotate when clicked, and so on.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 还提供了可以让你以各种方式在页面上动画化元素的属性。你可以使用 CSS 单独使页面交互式，而无需编写任何代码（或者至少是*明显*的代码）。你可以使元素在用户悬停时增长，在点击时旋转，等等。
- en: 'In addition to defining your styles in a `<style>` block, usually in the `<head>`
    area of an HTML document, you can also define CSS *inline* – that is, on a given
    element itself:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了在 `<style>` 块中定义你的样式，通常在 HTML 文档的 `<head>` 区域，你还可以在给定的元素本身上定义 CSS *内联* ——也就是说，在该元素上：
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `style` attribute is available on most elements, and it allows you to apply
    styles on that specific element only. Going back to the idea of cascading, this
    type of style will (nearly) always take precedence over any defined in a `<style>`
    block or linked to in an external stylesheet.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`style` 属性在大多数元素上都是可用的，它允许你仅对该特定元素应用样式。回到层叠的概念，这种类型的样式将（几乎）总是优先于在 `<style>`
    块中定义或在外部样式表中链接的任何样式。'
- en: Except for inline styles, which are common, the rest of these are more advanced
    topics, and since the goal here is only to give you the basic idea of what CSS
    is, I’m not going to go into them. But I wanted you to at least be aware they
    exist. I wasn’t kidding when I said that CSS can be difficult! There is a great
    deal to it, and it has become immensely powerful. But what’s described in the
    previous section are the core concepts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的内联样式之外，其余的都是更高级的主题，而且由于这里的目的是只给你一个 CSS 的基本概念，我不会深入探讨它们。但我希望你知道它们存在。我说 CSS
    可能很难时，并不是在开玩笑！CSS 有很多内容，它已经变得非常强大。但前一部分描述的是核心概念。
- en: 'Now that we’ve looked at HTML and CSS, let’s dive into the true, *unequivocal*
    area of programming: JavaScript!'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 HTML 和 CSS，让我们深入到真正的、*明确无误*的编程领域：JavaScript！
- en: Dissecting JavaScript
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆解 JavaScript
- en: If you think of HTML as the blueprint for a house, and you think of CSS as the
    decorations for the house, you can think of JavaScript as the thing that makes
    the garage door open when you press a button, or the ceiling fan and light turn
    on when you flick a switch.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把 HTML 视为房子的蓝图，把 CSS 视为房子的装饰，那么你可以把 JavaScript 视为当你按下按钮时使车库门打开的东西，或者当你拉动开关时天花板风扇和灯光亮起的东西。
- en: HTML and CSS are what we call *declarative* languages, meaning you write what
    you want to happen, and the browser does it. For example, if you write `<hr>`,
    the browser knows you want there to be a line on the screen. If you write `color:red`
    in a stylesheet, it knows that you want the element on which the selector for
    that class applies to be red.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 和 CSS 是我们所说的 *声明性* 语言，这意味着你写下你想要发生的事情，浏览器就会去实现。例如，如果你写下 `<hr>`，浏览器就会知道你想要在屏幕上有一条线。如果你在样式表中写下
    `color:red`，它就会知道你想要应用该类选择器的元素变成红色。
- en: 'By contrast, JavaScript is what we call an *imperative* language. This means
    that you must tell the computer exactly what to do at each step of the way. You
    can’t simply declare your intent as with HTML and CSS – you have to be specific
    and detailed about what the browser, and hence the computer, must do. Most people
    will tend to say that JavaScript is actual programming, whereas HTML and CSS aren’t.
    Whether that’s true or not is a bit debatable, but the nature of JavaScript isn’t:
    you have to write instructions for the computer to follow, and it will do no more
    and no less than you tell it to.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，JavaScript 是我们所说的 *命令性* 语言。这意味着你必须告诉计算机在每一步要做什么。你不能像 HTML 和 CSS 那样简单地声明你的意图——你必须具体详细地说明浏览器（以及计算机）必须做什么。大多数人可能会倾向于说
    JavaScript 是真正的编程，而 HTML 和 CSS 不是。这到底是不是真的有点值得商榷，但 JavaScript 的本质是不变的：你必须为计算机编写指令，它会按照你的指示去做，不会多做也不会少做。
- en: Demonstrating JavaScript
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展示 JavaScript
- en: 'By way of example, let’s add a line to the code we looked at earlier, right
    after the last `<``div>` tag:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，让我们在我们之前查看的代码中添加一行，就在最后一个 `<div>` 标签之后：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code shows a couple of things. First, there’s a new HTML tag: `<button>`.
    As its name suggests, it allows us to add buttons to our page, things a user can
    click to do something. The `type` attribute allows us to select one of three types
    of buttons: `button`, `reset`, or `submit`. The latter two are used in the context
    of a form, which is another HTML element that represents a collection of input
    fields, for example, to fill out your personal information when creating an account
    on a website. However, the basic `button` type is a more generic type that doesn’t
    have to be associated with a form, as is the case here.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了几个方面。首先，有一个新的 HTML 标签：`<button>`。正如其名所示，它允许我们在页面上添加按钮，用户可以点击它们来执行某些操作。`type`
    属性允许我们选择三种按钮类型之一：`button`、`reset` 或 `submit`。后两种在表单的上下文中使用，表单是另一个 HTML 元素，代表一系列输入字段，例如，在网站上创建账户时填写个人信息。然而，基本的
    `button` 类型是一种更通用的类型，它不必与表单相关联，就像这里的情况一样。
- en: 'The preceding code also shows us a new concept: *event handlers*. Event handlers
    are bits of JavaScript that are executed in response to some event, something
    that happens on a page. That might be the user clicking a button, as is the case
    here, or maybe we want some code to execute when the page first loads, which can
    also be done with an event handler. Here, the specific event we want to handle
    is called “click,” and because event handlers execute in response to an event,
    we say that they happen “on” execution of that event, hence why `onClick` is how
    we specify this event handler.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码还向我们展示了一个新概念：*事件处理器*。事件处理器是响应某些事件执行的 JavaScript 代码片段，这是页面上发生的事情。这可能是在这里用户点击按钮，或者我们可能想要在页面首次加载时执行某些代码，这也可以通过事件处理器来实现。在这里，我们想要处理的具体事件被称为“click”，由于事件处理器是响应事件执行的，所以我们说它们是在该事件执行时发生的，这就是为什么我们用
    `onClick` 来指定这个事件处理器。
- en: 'An event handler can either be inline or external to an element. When it’s
    external, it would live inside a `<script>` block somewhere on the page (or perhaps
    in an external JavaScript file that we import). Here, though, it’s inline. The
    value of the `onClick` attribute is simply the JavaScript we want to execute when
    the click event occurs. Let’s look at that code specifically:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器可以是内联的，也可以是元素外部的。当它是外部的时候，它可能位于页面上的某个 `<script>` 块中（或者可能是一个我们导入的外部 JavaScript
    文件）。然而，在这里它是内联的。`onClick` 属性的值仅仅是当点击事件发生时我们想要执行的 JavaScript 代码。让我们具体看看那段代码：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This shows a couple of key concepts in JavaScript, starting with objects. An
    object is simply a collection of data that you treat as a single unit. For example,
    think of yourself: you have a first name, a last name, an age, a phone number,
    and so on. If we stored all that information in the computer’s memory, we could,
    in our code, refer to that collection of information as `BookReader`. If we want
    to get the first name only out of that collection, we might write `BookReader.firstName`.
    The dot represents how we tell JavaScript that we want a single piece of information
    – a `BookReader`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了JavaScript中的几个关键概念，首先是对象。对象简单地说就是一组被视为单一单元的数据。例如，想想你自己：你有一个名字，一个姓氏，年龄，电话号码等等。如果我们把所有这些信息都存储在计算机的内存中，我们可以在我们的代码中把这一组信息称为`BookReader`。如果我们只想从这一组信息中获取名字，我们可能会写`BookReader.firstName`。点号代表我们告诉JavaScript我们想要一个单一的信息——一个`BookReader`。
- en: In the preceding code, `document` is one such collection of information. As
    it happens, this is one that the browser creates for us to represent the HTML
    document itself, all the things that go into it, and all the information about
    it. We can do a lot with this object. For example, we can ask it questions about
    our document. We can do this by calling **methods** on it. A method is a JavaScript
    function that is attached to an object. But I hear you asking, “What’s a function?”
    Let’s talk about that now because it’s a great question!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`document`就是这样一组信息。碰巧的是，这是浏览器为我们创建的，用来表示HTML文档本身，以及所有放入其中的东西，以及关于它的所有信息。我们可以用这个对象做很多事情。例如，我们可以向它提出关于我们文档的问题。我们可以通过调用**方法**来实现这一点。方法是一个附加到对象上的JavaScript函数。但是，我听到你在问，“什么是函数？”让我们现在就讨论这个问题，因为它是一个很好的问题！
- en: Understanding functions
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解函数
- en: But what is a **function**, you ask? Well, a function is just a bit of JavaScript
    that we give a name to. We do this so that we can execute that JavaScript, perhaps
    many times, *calling* it by its name.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能会问：“什么是**函数**？”嗯，函数就是一段我们给它起名字的JavaScript代码。我们这样做是为了能够执行那段JavaScript代码，可能很多次，通过它的名字来*调用*它。
- en: 'Any time you call a JavaScript function, it has the following form:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你调用JavaScript函数时，它都有以下形式：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function name is the name we assign to that JavaScript code, and arguments,
    which are optional, are any pieces of information the function needs to do its
    job. When they are present, we say they are *passed* to the function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名是我们分配给那段JavaScript代码的名字，参数是可选的，是函数完成其工作所需的信息片段。当它们存在时，我们说它们被*传递*给函数。
- en: 'Functions can be their own, separate things. An example of this is if you write
    the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以是它们自己的独立事物。一个例子是如果你写下以下内容：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the `alert()` function exists within the browser automatically, and it’s
    just kind of floating out there on its own.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`alert()`函数在浏览器中自动存在，它就像独自漂浮在那里一样。
- en: However, functions can also be *attached* to objects, which is just a fancy
    way of saying that a given property of an object is a reference to a function.
    In our code, `getElementsByTagName()` is one such function, so we say it’s a method
    of the object it’s attached to. Note that when we are referring to the name of
    a function in text like this, it’s common to include an empty set of parenthesis,
    which is the convention I’ll be using throughout this book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，函数也可以被*附加*到对象上，这只是一个说法，意思是对象的某个特定属性是一个指向函数的引用。在我们的代码中，`getElementsByTagName()`就是这样一种函数，所以我们说它是附加到它所附加的对象上的方法。请注意，当我们像这样在文本中提到函数的名字时，通常会在括号中包含一个空集合，这是我在整本书中会使用的惯例。
- en: This method allows us to ask the `document` object to get us a list of all the
    `<h1>` tags in the HTML document, which is why `'h1'` is passed as an argument
    to the method. Here, `'h1'` must be enclosed in quotation marks – single quotes,
    in this case (which in most cases are interchangeable) – because it’s what’s known
    as a `1234`, though, we wouldn’t need the single quotes because that wouldn’t
    be a string, it would be a number, and numbers don’t need to be quoted.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法允许我们要求`document`对象给我们一个HTML文档中所有`<h1>`标签的列表，这就是为什么将`'h1'`作为参数传递给方法的原因。在这里，`'h1'`必须用引号括起来——在这种情况下是单引号（在大多数情况下可以互换使用）——因为它是一个所谓的`1234`，尽管我们不需要单引号，因为那不会是一个字符串，而是一个数字，数字不需要被引号括起来。
- en: The `getElementsByTagName()` method returns a value, just like a function can
    do. What it returns can be many different things, but in this case, it’s what’s
    known as an **array**. An array is simply a list of values. Those values might
    be strings, numbers, or objects (or even functions, but that’s a more advanced
    topic). An array allows us to get values from it by an *index*, which is the position
    in the array.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`getElementsByTagName()`方法返回一个值，就像函数可以做到的那样。它返回的值可以是许多不同的事物，但在这个例子中，它返回的是所谓的**数组**。数组简单地说就是一系列值。这些值可能是字符串、数字或对象（甚至可以是函数，但这是一个更高级的话题）。数组允许我们通过一个*索引*来获取它的值，即数组中的位置。'
- en: In talking about arrays, though, I’ve glossed over another concept that may
    in some ways be the most important in JavaScript, and programming in general,
    and that’s **variables**. Let’s talk about that now so that you can better understand
    what an array is.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在谈论数组时，我略过了另一个可能在某些方面是JavaScript（以及编程的一般）中最重要的概念，那就是**变量**。现在让我们来谈谈这个，这样你就能更好地理解数组是什么。
- en: Understanding variables
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解变量
- en: In the simplest terms, variables are named things that point to somewhere in
    the computer’s memory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，变量是命名的东西，它们指向计算机内存中的某个位置。
- en: 'For example, say we had a list of names: Frank, Traci, Andrew, and Ashley.
    We can put them in an array, just like the kind returned by `getElementsByTagName()`.
    This allows us to access each name by using its index: Frank at position 0 (because
    arrays always start counting with 0, not 1, as you might expect), Traci at 1,
    Andrew at 2, and Ashley at 3.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个名字列表：Frank、Traci、Andrew和Ashley。我们可以把它们放在一个数组中，就像`getElementsByTagName()`返回的那种类型。这允许我们通过使用它的索引来访问每个名字：Frank在位置0（因为数组总是从0开始计数，而不是像你预期的1），Traci在位置1，Andrew在位置2，Ashley在位置3。
- en: 'What does the code look like for doing all that? It’s pretty simple:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 那么做所有这些的代码是什么样的呢？其实很简单：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we’re creating a variable named `myArray`. And where is the memory that
    it points to that I said a variable essentially is? Well, frankly, that’s not
    our problem! The computer will take care of that for us. All we need to know is
    that when we want to access this data, we’ll use `myArray`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`myArray`的变量。那么它指向的那个内存，就是我所说的变量本质上是什么？坦白说，那不是我们的问题！计算机将为我们处理这个问题。我们只需要知道，当我们想要访问这些数据时，我们会使用`myArray`。
- en: The word `var` before `myArray` is called a `var` stands for variable. What
    we’re saying here is, “Hey, JavaScript, I’m declaring a variable named `myArray`
    here.” It will then find some memory for us, and make sure that `myArray` points
    to it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`myArray`之前的单词`var`被称为`var`，代表变量。我们在这里说的是，“嘿，JavaScript，我在这里声明了一个名为`myArray`的变量。”然后它会为我们找到一些内存，并确保`myArray`指向它。
- en: 'Declaring a variable means to introduce it to the computer, but there is a
    related concept called *definition*, or *defining* a variable. The definition
    of a variable is optional; you can declare a variable without defining it (which
    is to say without giving it a starting value) and then give it a value later.
    But it’s common to see both declaration and definition done at the same time,
    as is the case here. The equals sign does that: it’s saying, “Hey, computer, the
    value of `myArray` equals this.”'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个变量意味着向计算机介绍它，但还有一个相关的概念叫做*定义*，或者*定义*一个变量。变量的定义是可选的；你可以声明一个变量而不定义它（也就是说不给它一个起始值），然后稍后给它一个值。但通常我们会同时看到声明和定义，就像这里的情况一样。等号就是这样做的：它说，“嘿，计算机，`myArray`的值等于这个。”
- en: Also, note that putting a semicolon at the end of a line of JavaScript is optional,
    but it’s a good habit to get into. That way, we can clearly see when a statement,
    which is one instruction to the computer, ends, and where the next begins (and
    there are also some very subtle but thankfully very rare situations where not
    putting it in can cause a problem, so rare though it is it’s better to avoid that
    possibility entirely through good habits).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在JavaScript代码行末尾放置分号是可选的，但养成这个习惯是个好习惯。这样，我们可以清楚地看到一条语句（即对计算机的一个指令）在哪里结束，以及下一条语句从哪里开始（而且也有一些非常微妙但幸运的是非常罕见的情况，如果不放置分号可能会引起问题，尽管这种情况很少，但通过良好的习惯完全避免这种可能性是更好的）。
- en: 'The value we give is an array of data, which we denote by enclosing the values
    we want in the array in square brackets. If we were just defining a string as
    another example, then they wouldn’t be needed, and the same would be true for
    numbers or objects (objects use braces in place of the brackets, but that’s a
    little more advanced, so let’s forget that for now). For example, here’s an example
    of a string:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给出的值是一个数据数组，我们通过将我们想要放入数组中的值用方括号括起来来表示。如果我们只是定义一个字符串作为另一个例子，那么它们就不需要了，对于数字或对象也是如此（对象使用大括号代替括号，但这更高级，所以我们现在先不考虑它）。例如，这里有一个字符串的例子：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s an example of a number:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个数字的例子：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, it’s the same basic format: the `var` keyword, followed by
    a name for the variable, and then (optionally) an equals sign and the initial
    value to put into the variable.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它有相同的基本格式：`var`关键字，后面跟着变量的名称，然后（可选地）一个等号和要放入变量的初始值。
- en: 'Going back to our array, once the array is declared and defined like this,
    we can access the names by writing the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的数组，一旦数组被声明和定义成这样，我们可以通过写下以下内容来访问名称：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will get the value from the array at index 2, which will be `Andrew` because
    again, arrays start at 0.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从数组中索引2的位置获取值，这将是一个`Andrew`，因为，再次强调，数组从0开始。
- en: Now that you have the foundation, let’s see it all in action in the event handler
    code from earlier.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了基础，让我们看看之前的事件处理器代码中的所有内容是如何运作的。
- en: Understanding the event handler better
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好地理解事件处理器
- en: 'With that knowledge, let’s go back to that event handler code from earlier:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个知识，让我们回到之前的事件处理器代码：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, what we have here is a call to the `getElementsByTagName()` method of the
    `document` object, asking it for all the `<h1>` tags on the page. This method
    returns an array, which we can then access the elements of using parenthesis.
    Since we know we’re only going to get one tag in this array because we only have
    one `<h1>` tag on the page, the index will always be 0\. The result of this is
    a reference to that tag, which we can then access the properties of. Properties
    can be read *or* written (in most cases), and in this case, we’re writing to one:
    `style`. This corresponds to the stylesheet currently applied to this tag, which
    at the start makes it red. However, we want to change the color to yellow so that
    we can set the value of the `color` attribute.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们调用的是`document`对象的`getElementsByTagName()`方法，要求它返回页面上的所有`<h1>`标签。这个方法返回一个数组，我们可以通过括号来访问数组的元素。因为我们知道在这个数组中我们只会得到一个标签，因为我们页面上只有一个`<h1>`标签，所以索引总是0。这个结果是对那个标签的引用，然后我们可以访问它的属性。属性可以是读取的*或者*写入的（在大多数情况下），在这种情况下，我们正在写入一个：`style`。这对应于应用于该标签的样式表，一开始使它变成红色。然而，我们想要将颜色改为黄色，以便我们可以设置`color`属性的值。
- en: The reason you can write `myH1Tag.style.color` is because a property of an object
    can point to other objects. This is called *nesting*, and you can nest as deeply
    as you need to. We call this nesting of objects a *hierarchy*. Here, `myH1Tag`
    is an object. In this case, the `style` attribute points to another object. Finally,
    `color` is a property of that nested object. You will sometimes see long chains
    of XXX.YYY… code in JavaScript as you drill down through a hierarchy of nested
    objects. But no matter how deeply the hierarchy goes, each XXX.YYY you see simply
    means “the YYY property of object XXX.”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以写`myH1Tag.style.color`的原因是因为一个对象的属性可以指向其他对象。这被称为*嵌套*，你可以嵌套到你需要的深度。我们称这种对象的嵌套为*层次结构*。在这里，`myH1Tag`是一个对象。在这种情况下，`style`属性指向另一个对象。最后，`color`是那个嵌套对象的属性。你有时会在JavaScript中看到长链的XXX.YYY…代码，当你钻入嵌套对象的层次结构时。但不管层次结构有多深，你看到的每个XXX.YYY只是意味着“对象XXX的YYY属性。”
- en: 'Sometimes, a single line of code like that event handler can be difficult to
    understand because, in effect, several steps are being performed, and it can often
    be difficult to follow each of them, especially early on when you haven’t been
    reading JavaScript code for a long time. It may make more sense to rewrite the
    code by breaking the individual steps into individual lines, like so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，像那样的事件处理器这样的单行代码可能很难理解，因为实际上正在执行多个步骤，而且往往很难跟踪每一个步骤，尤其是在你很久没有阅读JavaScript代码的情况下。可能通过将单个步骤分解成单独的行来重写代码会更有意义，如下所示：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, you can more clearly see the three discrete steps the code is performing:
    get the list of `<h1>` tags and declare a variable named `tagsArray` to point
    to it (which is defined with the array returned by the method call), then get
    the first element of that array and create a variable named `myH1Tag` to reference
    it, and finally set its `color` style attribute to yellow.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以更清楚地看到代码正在执行的三步离散操作：获取 `<h1>` 标签的列表，并声明一个名为 `tagsArray` 的变量来指向它（这是通过方法调用返回的数组定义的），然后获取该数组的第一个元素，并创建一个名为
    `myH1Tag` 的变量来引用它，最后将其 `color` 样式属性设置为黄色。
- en: 'I know that’s a lot of information to take in, especially if you have never
    done any kind of programming before. But here’s the good news: you’ve just been
    introduced to a good chunk of the basic concepts behind JavaScript and programming
    in general! You’ll learn a bit more as you progress through this book, but that’s
    a good start for now.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这需要吸收很多信息，尤其是如果你之前从未做过任何编程的话。但是，好消息是：你已经接触到了 JavaScript 和编程背后的许多基本概念！随着你通过这本书的进展，你将学到更多，但这对现在来说是一个很好的开始。
- en: At this point, we need to talk about another topic that is closely related to
    JavaScript, as well as HTML and CSS, and that’s the DOM.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要讨论另一个与 JavaScript、HTML 和 CSS 都密切相关的话题，那就是 DOM。
- en: Creating the DOM
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 DOM
- en: The **DOM**, which stands for **Document Object Model**, is the concrete result
    of the browser *parsing* an HTML document. This is what we call it when something
    – the browser, in this case – reads some data – the HTML file, in this case –
    and processes it in some way. It’s a collection of objects stored in the computer’s
    memory that represents that document.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOM**，即**文档对象模型**，是浏览器解析 HTML 文档的具象结果。当我们说某个东西——在这个例子中是浏览器——读取一些数据——在这个例子中是
    HTML 文件——并以某种方式处理它时，我们就是这样称呼的。它是一组存储在计算机内存中的对象集合，代表该文档。'
- en: 'Let’s consider the following HTML document:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下 HTML 文档：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the browser parses that file, it produces a DOM, as shown in *Figure 2**.2*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器解析该文件时，它会生成一个 DOM，如图 *图 2.2* 所示：
- en: '![Figure 2.2: A graphical representation of the DOM](img/B18315_02_2.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2：DOM 的图形表示](img/B18315_02_2.jpg)'
- en: 'Figure 2.2: A graphical representation of the DOM'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：DOM 的图形表示
- en: What you’re looking at is a `<html>` box was at the bottom, that is conceptually
    like the trunk of a tree. Everything that “grows” from it is a branch, and then
    any box that doesn’t have anything growing from it is like a leaf (which we call
    a *node* in tree-speak). So, you can see a branch from `<html>` that leads to
    `<head>` and `<body>` because they are the direct children of `<html>`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你所看到的是一个位于底部的 `<html>` 框，在概念上就像一棵树的树干。从它“生长”出来的每一件事都是一根树枝，然后任何没有东西生长出来的框就像一片叶子（在树语中我们称之为
    *节点*）。所以，你可以看到从 `<html>` 出发的一根树枝通向 `<head>` 和 `<body>`，因为它们是 `<html>` 的直接子元素。
- en: You’ll also notice that there is a box in the diagram that says `#text:` in
    it, which is a child of `<html>` too; you’ll notice several more like that throughout.
    Those represent text content in the HTML document that isn’t contained within
    a tag.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到图中有一个写着 `#text:` 的框，它是 `<html>` 的子元素；你会在整个图中看到更多这样的框。这些代表 HTML 文档中不包含在任何标签内的文本内容。
- en: To understand that, take a look at the source HTML code. See how lines are indented?
    Well, the spaces that cause that indentation become an element in the DOM tree
    too, and that’s what those `#text:` boxes are. To the browser, those spaces are
    content that is just as valid as anything within a tag, even though it may not
    be displayed on the page. As a general rule, any whitespace in an HTML document
    won’t be rendered on the screen, at least more than a single space character (put
    another way, multiple space characters collapse into a single space character).
    There are, naturally, ways that you can make multiple spaces be displayed, but
    things such as indentation are *usually* not going to be by default.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，看看源 HTML 代码。看到哪些行是缩进的吗？嗯，造成这种缩进的空格也成为 DOM 树中的一个元素，这就是那些 `#text:` 框的内容。对浏览器来说，这些空格是和标签内任何内容一样有效的内容，即使它们可能不会在页面上显示。一般来说，HTML
    文档中的任何空白都不会在屏幕上渲染，至少不会超过一个空格字符（换句话说，多个空格字符会合并成一个空格字符）。当然，有方法可以使多个空格显示出来，但像缩进这样的东西通常默认是不会显示的。
- en: That aside, the basic idea is that every tag, and its content, becomes elements,
    or nodes, in the DOM tree, and a more complex bit of HTML will yield a more complex
    tree structure. But it’s this tree that allows CSS and JavaScript to do their
    thing, not to mention the browser itself. When you need to get a reference to
    a DOM node to do something with it in JavaScript, the browser consults this tree
    to find it for you. When you need to specify a CSS selector to apply a style class
    to, the browser uses the tree to do its work. Later, you’ll learn that the DOM
    can be changed with JavaScript (as well as CSS) after it is initially rendered,
    and when that happens, the browser will update the tree accordingly (maybe adding
    new branches or nodes, or removing others, depending on what the change is). The
    DOM makes all that possible.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，基本想法是每个标签及其内容都成为DOM树中的元素或节点，更复杂的HTML将产生更复杂的树结构。但正是这棵树允许CSS和JavaScript做它们的事情，更不用说浏览器本身了。当你需要通过JavaScript获取DOM节点的引用来对其进行操作时，浏览器会咨询这棵树来为你找到它。当你需要指定一个CSS选择器来应用样式类时，浏览器会使用这棵树来完成其工作。稍后，你会了解到DOM可以在最初渲染后通过JavaScript（以及CSS）进行更改，当这种情况发生时，浏览器将相应地更新树（可能添加新的分支或节点，或者删除其他节点，具体取决于更改的内容）。DOM使所有这些成为可能。
- en: As a web developer, you don’t generally deal with the DOM directly in the sense
    that you won’t see a diagram like the previous one, at least not entirely like
    that. But it’s always there, omnipresent, allowing the browser – and by extension
    HTML, CSS, JavaScript, and ultimately *you*! – to do their thing. So, it’s important
    to understand what it is and how to conceptualize it in your mind.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名网页开发者，你通常不会直接处理DOM，在这个意义上，你不会看到像之前那样的图表，至少不是完全那样。但它始终存在，无处不在，允许浏览器——以及通过扩展HTML、CSS、JavaScript，最终是你！——做它们的事情。因此，了解它是什么以及如何在你的脑海中构思它是很重要的。
- en: Now that you’ve had a chance to meet HTML, CSS, JavaScript, and the DOM, let’s
    talk about what happens when a user enters an address into the address bar of
    a browser and presses *Enter* since that’s a key concept to understand. And there’s
    more to it than what first meets the eye!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有机会了解HTML、CSS、JavaScript和DOM，让我们谈谈当用户在浏览器的地址栏中输入一个地址并按下 *Enter* 键时会发生什么，因为这是理解的关键概念。而且其中还有更多内容超出了表面现象！
- en: Understanding the client-server model
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解客户端-服务器模型
- en: The first thing that happens when you, as the user, enter an address into the
    browser’s address box and press *Enter*, is that a request is made to a **Domain
    Name Server** (**DNS**) by the browser. A DNS server is a special type of computer
    that is maintained by entities such as **Internet Service Providers** (**ISPs**)
    or major corporations. The sole job of a DNS server is to act as a phonebook,
    mapping human-friendly URLs such as google.com to IP addresses (for example, 192.158.1.232).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你作为用户在浏览器的地址框中输入一个地址并按下 *Enter* 键时，首先发生的事情是浏览器向 **域名服务器** (**DNS**) 发出请求。DNS服务器是由诸如
    **互联网服务提供商** (**ISPs**) 或大公司等实体维护的特殊类型的计算机。DNS服务器的唯一任务是充当电话簿，将人类友好的URL（如google.com）映射到IP地址（例如，192.158.1.232）。
- en: 'An **Internet Protocol** (**IP**) address is a unique address that every machine
    that connects to a network is given. It’s like the phone number of your cell phone:
    if someone knows it, they can connect to you. But you wouldn’t want to remember
    that 192.158.1.232 is the address – the phone number, if you will – for google.com,
    for example. So, instead, the DNS servers provide that mapping to make things
    more friendly for us humans.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '一个 **互联网协议** (**IP**) 地址是每个连接到网络的机器所分配的唯一地址。它就像你手机的电话号码：如果有人知道它，他们就可以连接到你。但你不会想要记住192.158.1.232是google.com的地址——如果你愿意，那就是电话号码。因此，相反，DNS服务器提供这种映射，使我们人类更方便。 '
- en: Once the DNS server responds with the IP address, the browser is then able to
    connect to the server that the IP address corresponds to and requests the HTML
    document specified in the URL. If none is specified (as in google.com), then a
    default document is returned.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦DNS服务器响应了IP地址，浏览器就能够连接到与该IP地址对应的服务器，并请求URL中指定的HTML文档。如果没有指定（如google.com），则返回默认文档。
- en: The browser then reads that HTML file and parses it, creating the DOM from it.
    It then makes separate requests for each of the resources referenced by the HTML
    document, so things such as images referenced in `<img>` tags, external stylesheets
    referenced in `<link>` tags, or external JavaScript files referenced in `<script>`
    tags. In other words, it asks the server for all the things needed to make that
    web page work and display properly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器随后读取那个HTML文件并解析它，从中创建DOM。然后，它为HTML文档中引用的每个资源单独发出请求，例如在`<img>`标签中引用的图像、在`<link>`标签中引用的外部样式表，或在`<script>`标签中引用的外部JavaScript文件。换句话说，它向服务器请求所有使该网页正常工作并正确显示所需的东西。
- en: Once all those resources are retrieved, the browser renders the content to the
    screen, and you have yourself a web page to look at!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些资源都被检索到，浏览器就会将内容渲染到屏幕上，你就可以看到一个可以查看的网页了！
- en: Now, especially with JavaScipt in the mix, that might not be the end of it.
    As the user takes various actions on your web page, such as clicking buttons or
    scrolling, JavaScript code can be executed in response to those actions, and that
    code might make changes to the DOM – and hence what you see on the screen – or
    it might make requests to the server. These requests might be to get some data
    that is then displayed on the page, or it may be a request for a whole new HTML
    document, which will then replace the content currently shown. In these cases,
    we call it *navigating* from one page to another.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尤其是在JavaScript的混合使用中，这可能并不是结束。当用户在网页上执行各种操作时，例如点击按钮或滚动，JavaScript代码可以对这些操作做出响应，并且这些代码可能会对DOM——以及你在屏幕上看到的内容——进行更改，或者它可能会向服务器发出请求。这些请求可能是获取随后在页面上显示的数据，或者可能是一个请求整个新的HTML文档，这将替换当前显示的内容。在这些情况下，我们称之为*导航*从一个页面到另一个页面。
- en: I’ve mentioned this server thing a few times now, and you know it’s a computer
    that responds to your requests, but there is more to it than that. So, let’s jump
    into that a little bit, shall we?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了几次服务器这件事，你知道它是一台响应你请求的计算机，但还有更多。那么，让我们稍微深入一点，好吗？
- en: Understanding the server (the backend)
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务器（后端）
- en: As I mentioned earlier, the client is considered the frontend of the equation;
    the **backend** is where we get into the idea of *servers*. The word server has
    two meanings – one physical and one not.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，客户被认为是等式的**前端**；**后端**是我们对*服务器*这一概念的理解。服务器这个词有两个含义——一个是物理的，另一个不是。
- en: When looking at things from a networking-centric perspective, a server is a
    physical computer, separate from the one a client is running on. They communicate
    over the network.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当从网络中心的角度来看待事物时，服务器是一台物理计算机，与客户端运行的计算机分开。它们通过网络进行通信。
- en: However, a server is also some form of software running on a physical computer,
    and it’s that software that answers a client’s requests. In other words, when
    we say something like a “web server,” it could mean the physical machine that
    a client connects to so that it can view a web page, it could mean the software
    running on a physical computer that responds to the request for the web page,
    or it could mean the combination of the two.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，服务器也是一种在物理计算机上运行的软件形式，正是这种软件回答了客户端的请求。换句话说，当我们说“网页服务器”时，这可能意味着客户端连接的物理机器，以便它可以查看网页，这可能意味着在物理计算机上运行的软件，它响应网页的请求，或者它可能意味着两者的结合。
- en: Because a server is, in some context at least, some kind of software, that also
    means that a client and a server could be running on the same physical machine,
    as you’ll see in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因为服务器在某种情况下至少是一种软件，这也意味着客户端和服务器可以运行在同一个物理机器上，正如你将在下一节中看到的。
- en: This server software comes in all different shapes, types, and sizes, including
    what programming language is used to create it. Things such as **Java**, **Python**,
    **.NET**, **Node**, and **PHP** are common languages to write server software
    in. Each has its pluses and minuses. Java, Python, and .NET are very robust languages
    that provide a ton of premade code that you can use to save you from writing it
    yourself. This is true for Node and PHP too, but Node is a platform that allows
    you to use JavaScript on the server, and PHP is its own language.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种服务器软件有各种不同的形状、类型和大小，包括用于创建它的编程语言。**Java**、**Python**、**.NET**、**Node**和**PHP**是编写服务器软件的常见语言。每种语言都有其优点和缺点。Java、Python和.NET是非常健壮的语言，提供了大量的预编代码，你可以使用这些代码来节省你自己编写代码的时间。Node和PHP也是如此，但Node是一个允许你在服务器上使用JavaScript的平台，而PHP是一种语言。
- en: Whatever language you use, whatever platform you build on, you’ll need to provide
    code that handles a given type of request. To demonstrate this, I’d like to write
    a very simple server using Node. I think that this is the best choice to show
    you since we looked at JavaScript a little bit earlier, so it probably won’t seem
    as alien as the others might.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么语言，无论你在什么平台上构建，你都需要提供处理给定类型请求的代码。为了演示这一点，我想使用Node编写一个非常简单的服务器。我认为这是展示给你看的最合适的选择，因为我们之前稍微了解了一些JavaScript，所以它可能不会像其他人那样陌生。
- en: Getting started with Node
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node入门
- en: 'To get started, you need to install Node itself. Fortunately, this is very
    easy! Head over to [nodejs.org](http://nodejs.org) in your favorite browser, where
    you’ll see a page similar to what’s shown in *Figure 2**.3*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你需要安装Node本身。幸运的是，这非常简单！在你的浏览器中转到[nodejs.org](http://nodejs.org)，你会看到一个类似于*图2.3*所示的页面：
- en: '![Figure 2.3: The Node.js (or just plain Node) home page](img/B18315_02_3.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：Node.js（或仅Node）的主页](img/B18315_02_3.jpg)'
- en: 'Figure 2.3: The Node.js (or just plain Node) home page'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Node.js（或仅Node）的主页
- en: From here, click the big green button that says **Download Node.js (LTS)**.
    This will download an installer, which you can then run to install Node.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，点击写着**下载Node.js (LTS)**的大绿色按钮。这将下载一个安装程序，然后你可以运行它来安装Node。
- en: Note that alternatively, you can download the latest version via the link below
    that is in the sentence that begins “Want new features sooner?” The difference
    is that the button gives you the LTS – Long Term Support – version, which typically
    means it’s more stable since newer features that may not be fully ready for use
    are present. For our purposes here though, it shouldn’t make a difference, though
    it’s worth noting that I do tend to have the newest version installed on my machine.
    So, if you do happen to run into any problems with code not working as expected,
    and you installed the LTS version, try the latest version instead and see if it
    works.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你也可以通过以下链接下载最新版本，该链接位于以“想要更快地获得新功能？”开头的句子中。区别在于，按钮为你提供的是LTS（长期支持）版本，这通常意味着它更稳定，因为其中包含的新功能可能尚未完全准备好使用。然而，对于我们在这里的目的来说，这不应该有任何区别，尽管值得注意的是，我确实倾向于在我的机器上安装最新版本。所以，如果你遇到代码无法按预期工作的问题，并且你安装了LTS版本，请尝试使用最新版本，看看是否可以工作。
- en: 'Once the installer completes, open a command prompt and enter this command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序完成后，打开命令提示符并输入以下命令：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should be greeted with the following output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下输出：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The numbers may be different – that’s what it was when I wrote this – but it
    should match whatever the web page says. Assuming you get a number like this,
    though, it means that **Node** is installed and ready to go.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可能不同——这是我写的时候的情况——但它应该与网页上说的相匹配。然而，如果你得到这样的数字，这意味着**Node**已安装并准备好使用。
- en: Creating a project with NPM
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NPM创建项目
- en: To start creating a server, we’ll use a tool that goes hand-in-hand with Node
    called **NPM**. This stands for **Node Package Manager** and is a tool for managing
    packages, which are collections of pre-existing code that we can use in our code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建服务器，我们将使用与Node配合使用的工具，即**NPM**。这代表**Node包管理器**，是一个用于管理包的工具，这些包是我们可以在我们的代码中使用的现有代码集合。
- en: 'The first step to creating a server is to create a directory to house our project
    code, maybe call it `simple-server`, navigate to it, and enter this command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务器的第一步是创建一个目录来存放我们的项目代码，也许可以叫它`simple-server`，导航到它，并输入以下命令：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This command tells NPM that you want to start, or *initialize*, a new project.
    You will be greeted with a series of questions. For our purposes here, simply
    press *Enter* for each one until it finally asks you if this is okay. Press *Enter*
    one more time for yes, and then look at the contents of the directory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉NPM你想要开始，或*初始化*，一个新的项目。你将遇到一系列问题。对于我们在这里的目的来说，只需简单地按*Enter*键回答每一个问题，直到它最终询问你是否确定。再按一次*Enter*键确认，然后查看目录的内容。
- en: 'You should find a single `package.json` file. This file contains all the metadata
    about your project that NPM, and by extension Node, needs to work with your project.
    At this point, its contents should be something like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该找到一个单独的`package.json`文件。此文件包含NPM（以及通过扩展Node）与你的项目一起工作所需的所有元数据。到目前为止，其内容应该是这样的：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Don’t be worried too much if there are minor differences, but it should mostly
    look like this. As you can see, the metadata here was taken from the answers to
    those questions, or more specifically, the default values that NPM offered you.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一些小的差异，不必过于担心，但它应该大致看起来像这样。正如你所看到的，这里的元数据是从那些问题的答案中提取的，或者更具体地说，是从NPM为你提供的默认值中提取的。
- en: Writing the server
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写服务器
- en: 'At this point, you have a project ready to go, but you don’t have any code
    yet. Let’s remedy that! To do so, create a file in the same directory as `package.json`
    named `index.js` and put the following code into it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经准备好了一个可以启动的项目，但还没有任何代码。让我们来解决这个问题！为此，在`package.json`所在的目录中创建一个名为`index.js`的文件，并将以下代码放入其中：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once you save that file, at the command prompt, enter this command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 保存该文件后，在命令提示符中，输入以下命令：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You won’t see anything at this point, but so long as you didn’t see any sort
    of error, then the server is running. To test it, go to your web browser, enter
    [http://localhost](http://localhost) in the address bar, and hit *Enter*. Once
    you do, you should see a greeting stating **Hello from your first** **Node server!**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你不会看到任何东西，但只要你没有看到任何错误，那么服务器正在运行。要测试它，请打开你的网页浏览器，在地址栏中输入[http://localhost](http://localhost)，然后按*Enter*。一旦你这样做，你应该会看到一个表示**来自你的第一个**
    **Node服务器**！的问候。
- en: You’ve just created a server!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了一个服务器！
- en: To explain the code a little bit… first, we need to use a package that Node
    provides out of the box – the `http` package. The `require()` function tells JavaScript
    to make that package available to our code. It’s just a function call, which means
    it returns something to us, and in this case, it’s a reference to that package,
    which we then store in the `http` variable. Note that rather than `var`, here,
    I’m using `const` unless you *know* you’ll need to change the value stored in
    the variable later. You’ll avoid a lot of nasty bugs if you follow this advice,
    trust me! When you know that you’ll need to change the value later, you can use
    `var` and `let` as being equivalent. They aren’t, but explaining the difference
    would require getting into some other topics that are better skipped at this early
    stage.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微解释一下代码……首先，我们需要使用Node提供的内置包——`http`包。`require()`函数告诉JavaScript使该包对我们的代码可用。这只是一个函数调用，这意味着它会返回一些东西给我们，在这种情况下，它是对该包的引用，然后我们将其存储在`http`变量中。请注意，在这里，我使用`const`而不是`var`，除非你*知道*你以后需要更改该变量中存储的值。如果你遵循这个建议，你会避免很多讨厌的bug，相信我！当你知道你以后需要更改值时，你可以使用`var`和`let`，它们是等效的。它们并不相同，但解释它们之间的差异需要涉及到一些其他的话题，这些话题在这个早期阶段最好跳过。
- en: 'After the `http` package is imported, we can call its `createServer()` method,
    which, as its name implies, creates a server for us. Here, you can see another
    key thing about JavaScript: functions are first-class citizens, meaning they can
    be treated as values, just like strings and numbers can be. This means that we
    can pass them as arguments to other functions, and that’s exactly what’s done
    here.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`http`包之后，我们可以调用它的`createServer()`方法，正如其名称所暗示的，它为我们创建了一个服务器。在这里，你可以看到JavaScript的另一个关键特性：函数是一等公民，这意味着它们可以被当作值来处理，就像字符串和数字一样。这意味着我们可以将它们作为参数传递给其他函数，这正是这里所做的事情。
- en: The argument to `createServer()` is a function that will be executed whenever
    a request comes into the server. This function can do whatever is needed to service
    the request. In this case, we’re just responding with a simple greeting. To do
    that, we have to call the `end()` method of the `inResponse` object, which will
    be passed to our function when a request comes in. This is the response the server
    is generating for the client, so by calling `end()`, we can simultaneously tell
    the server “This is the end of the response,” and also “Here’s the content to
    return to the client.”
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`createServer()`的参数是一个函数，每当有请求进入服务器时都会执行。这个函数可以完成任何需要的服务请求。在这种情况下，我们只是用一个简单的问候来响应。为了做到这一点，我们必须调用`inResponse`对象的`end()`方法，当请求进入时，这个方法会被传递给我们的函数。这是服务器为客户端生成的响应，所以通过调用`end()`，我们可以同时告诉服务器“这是响应的结束”，并且“这是要返回给客户端的内容”。'
- en: The last thing we need to do is start the server, and that’s done by calling
    its `listen()` method. We have to tell it what port to listen on, which is `80`
    in this case. Here, a port is a network construct that represents a program running
    on a physical server machine. You can have multiple pieces of software running
    on a single physical server, all listening for requests. However, to know which
    one the client should talk to, each piece of software must be assigned a port
    to listen on, and the client must then specify the port to connect to.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的就是启动服务器，这通过调用其`listen()`方法来完成。我们必须告诉它要监听哪个端口，在这种情况下是`80`。在这里，端口是一个网络结构，代表在物理服务器机器上运行的程序。你可以在单个物理服务器上运行多个软件程序，所有这些程序都在监听请求。然而，为了知道客户端应该与哪个程序通信，每个软件程序都必须分配一个监听端口，然后客户端必须指定要连接的端口。
- en: 'Note that when you enter `http://localhost` in your browser, you aren’t specifying
    the port. This works because, by default, websites always use port 80\. The browser
    is, in essence, attaching `:80` t[o the end of the UR](http://localhost:80/)L
    for you, which you should append to the end of the URL (so http://localhost:80)
    and try it just to prove it works: you should still see the greeting. I should
    also point out that **localhost** is a special name that always means “the machine
    I’m running on.”'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你将`http://localhost`输入到你的浏览器中时，你并没有指定端口。这是因为，默认情况下，网站总是使用端口80。本质上，浏览器在URL的末尾为你附加了`:80`（[http://localhost:80/](http://localhost:80/)），你应该将其附加到URL的末尾（所以是http://localhost:80），并尝试一下以证明它工作：你应该仍然看到问候语。我还应该指出，**localhost**是一个特殊的名称，它始终意味着“我正在运行的机器。”
- en: I hope you agree that, surprisingly, little code is needed to create a working
    – albeit very simple – server with Node. It’s one of the reasons Node is such
    a popular option for server-side development, in addition to the fact that for
    full-stack developers, it means they’re using the same language on both the client-side
    and server-side, which tends to make life a bit easier.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你们能同意，出人意料的是，使用 Node 创建一个工作着的——尽管非常简单——服务器所需的代码量很少。这也是 Node 成为服务器端开发如此受欢迎的选择之一的原因，除此之外，对于全栈开发者来说，这意味着他们可以在客户端和服务器端使用相同的语言，这通常会使得生活变得容易一些。
- en: Now that you’ve seen some code for both frontend and backend development, let’s
    talk a bit about what those words mean, and how they can branch into job titles
    you might encounter in the real world.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了前端和后端开发的一些代码，让我们谈谈这些词的含义，以及它们如何扩展到你在现实世界中可能遇到的职位名称。
- en: Defining web developer types and job titles
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义网络开发者的类型和职位名称
- en: When you think of the three types of web developers that I mentioned in [*Chapter
    1*](B18315_01.xhtml#_idTextAnchor015), you’ll begin to get a good feel for the
    types of work each does. Here, I want to talk primarily about the full-stack role,
    but let’s touch on the other two a bit more here first.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到我在[*第一章*](B18315_01.xhtml#_idTextAnchor015)中提到的三种类型的网络开发者时，你将开始对每个人所做的工作类型有一个很好的感觉。在这里，我想主要谈谈全栈角色，但首先让我们简要地谈谈其他两个。
- en: Frontend developers
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端开发者
- en: Frontend developers focus primarily on what you see on the screen. Their concerns
    are things such as user interface design (how the screen is laid out and what
    everything looks like), user experience (how the user interacts with a website,
    ensuring that it works well for users), and frontend technologies such as HTML,
    CSS, and JavaScipt that we’ve been looking at.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发者主要关注屏幕上显示的内容。他们的关注点包括用户界面设计（屏幕布局和一切看起来如何）、用户体验（用户如何与网站互动，确保它对用户来说工作良好），以及我们所关注的HTML、CSS和JavaScript等前端技术。
- en: They perform tasks such as interpreting wireframes and turning them into functional
    web pages. They are also concerned with performance and how search engines can
    or can’t find a website efficiently.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 他们执行的任务包括将线框图解释并转化为功能性的网页。他们还关注性能以及搜索引擎能否高效地找到网站。
- en: Modern frontend developers will frequently use various frameworks to get their
    job done. Names such as Angular, React, and Vue, things we’ll look at in more
    detail later, come to mind. The goal of these frameworks is to enhance the three
    core pillar technologies of HTML, CSS, and JavaScript and, to some extent, make
    it so you don’t have to write them directly. The goal is to allow developers to
    produce more with less code, or in some cases code that is more robust and easier
    to understand. As I mentioned previously, we’ll get into all that later.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现代前端开发者经常会使用各种框架来完成他们的工作。例如 Angular、React 和 Vue，这些我们将在稍后更详细地探讨。这些框架的目标是增强 HTML、CSS
    和 JavaScript 这三个核心支柱技术，并在一定程度上使您不必直接编写它们。目标是让开发者用更少的代码产生更多的成果，或者在某些情况下编写更健壮、更容易理解的代码。正如我之前提到的，我们将在稍后详细讨论这些内容。
- en: Backend developers
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端开发者
- en: Backend developers, by contrast, don’t worry too much about what’s on the screen
    in a user’s browser. Instead, their main concern is what happens on the server
    side of the equation. The bread-and-butter of backend developers are things such
    as databases and data modeling, security, providing APIs for the frontend to call
    on, and implementing the core logic of an application.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，后端开发者不必太担心用户浏览器上的屏幕内容。相反，他们的主要关注点是等式中的服务器端发生的事情。后端开发者的核心工作是诸如数据库和数据建模、安全性、为前端提供
    API 以及实现应用程序的核心逻辑。
- en: Backend developers use a whole different set of technologies, where things such
    as Python, Java, and PGP come into play. However, one option – Node – allows them
    to write JavaScipt on the server just like on the client, so there can be some
    overlap.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 后端开发者使用一套完全不同的技术，其中涉及到像 Python、Java 和 PGP 这样的技术。然而，有一个选项——Node——允许他们在服务器上编写
    JavaScript，就像在客户端一样，因此可能会有一些重叠。
- en: Modern backend developers often use frameworks as well, though here, we often
    see names such as Django and Spring Boot.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现代后端开发者通常也会使用框架，尽管在这里，我们经常看到 Django 和 Spring Boot 这样的名字。
- en: Full-stack developers
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全栈开发者
- en: The full-stack developer, on the other hand, is skilled in both frontend and
    backend development methodologies and technologies. They must be a jack-of-all-trades,
    not specializing in either frontend or backend.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，全栈开发者既擅长前端开发方法和技术，也擅长后端开发方法和技术。他们必须是一个多面手，既不专注于前端也不专注于后端。
- en: Full-stack developers are intimately concerned with integration – that is, building
    the bridge between frontend and backend – and making sure data flows correctly
    between them. They know how all the pieces fit together because, well, *they built
    all* *of them*!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈开发者与集成密切相关——也就是说，构建前端和后端之间的桥梁，并确保数据在这两者之间正确流动。因为他们知道所有部件是如何组合在一起的，因为，嗯，*他们构建了所有这些部件*！
- en: Being a full-stack developer means learning a lot more, but it also means you
    carry greater value for a prospective employer. To be sure, there are some environments
    where specialists are required, be they frontend specialists or backend specialists.
    But full-stack developers tend to be a larger chunk of web developer positions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 成为全栈开发者意味着需要学习更多，但也意味着你对潜在雇主具有更大的价值。当然，有些环境需要专家，无论是前端专家还是后端专家。但全栈开发者往往是更多网络开发职位的一部分。
- en: It can be difficult to have a mental picture of an entire system that covers
    both the frontend and backend, but at the same time, it can often be easier to
    perform your duties in other ways. That’s because when you understand how all
    the pieces interact, you will see problems a bit easier than if you have a somewhat
    myopic view of things, as a specialist may.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要在脑海中形成一个涵盖前端和后端的整个系统的图像可能很困难，但与此同时，以其他方式履行你的职责可能更容易。这是因为当你理解所有部件如何相互作用时，你将比一个专家有更全面的视角，更容易看到问题。
- en: Ultimately, there is no right answer in terms of the work world. Some people
    frankly prefer frontend and dislike backend work, and some people are the exact
    opposite. And then, some of us love the challenge of doing both. You’ll have to
    make up your mind about which is right for you as you progress.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在职场中，没有绝对的正确答案。有些人坦率地更喜欢前端而不喜欢后端工作，有些人则正好相反。然后，我们中的一些人喜欢同时做两者的挑战。随着你的进步，你必须自己决定哪条路适合你。
- en: However, regardless of which way you decide to go, let’s talk about some of
    the job titles you may encounter, how they map to these categories, and what they
    mean.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论你决定走哪条路，让我们谈谈你可能遇到的某些职位名称，它们如何映射到这些类别，以及它们的意义。
- en: Understanding job titles
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解职位名称
- en: While you definitely could see a job posting for a “web developer,” at this
    point, I hope you’re coming to realize that *title* is a little ambiguous and
    certainly incomplete. Does it mean someone focused on frontend development? Or
    does it mean someone doing more server-side development? And, to make matters
    worse, a given title might not even mean quite the same thing at one company versus
    another!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你确实可能会看到“Web开发者”的职位启事，但在这个时候，我希望你开始意识到*头衔*有些含糊不清，并且肯定是不完整的。它是否意味着专注于前端开发的人？或者它是否意味着从事更多后端开发的人？而且，更糟糕的是，同一个头衔在不同的公司之间可能甚至意味着完全不同的事情！
- en: 'In the interest of trying to make some sense of this, let’s look at a list
    of common job titles you might find in a job posting and try to at least roughly
    define what they’re likely to mean at most places:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了试图弄清楚这一点，让我们看看在招聘启事中可能会找到的一些常见职位名称列表，并尝试至少大致定义它们在大多数地方可能意味着什么：
- en: '*Programmer/computer programmer*: This is a generic title that some companies
    will use to indicate they need someone who can program in various languages –
    or perhaps in one specific language (Java programmer, as an example title). Often,
    this title will mean this is not a web development position, but that is far from
    a rule. Still, it often means someone who is working on things such as embedded
    systems or perhaps the defense industry.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*程序员/计算机程序员*：这是一个通用头衔，一些公司可能会用它来表示他们需要能够用各种语言编程的人——或者可能是在一种特定的语言（例如Java程序员）中。通常，这个头衔意味着这不是一个Web开发职位，但这远非规则。尽管如此，它通常意味着一个人正在从事嵌入式系统或可能国防工业等方面的工作。'
- en: '*Engineer/software engineer*: This is another generic title that, for the most
    part, means the same as programmer, but generally connotates a somewhat higher-level
    position. While a job listing that says programmer may tend to indicate a more
    entry-level position, something with engineer in its name probably denotes a position
    requiring previous experience. These titles also tend to mean non-web development.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*工程师/软件工程师*：这是另一个通用头衔，在大多数情况下意味着与程序员相同，但通常暗示着更高的职位。虽然提到程序员的职位列表可能倾向于表明这是一个更基础的职位，但带有工程师字样的职位可能表示需要以前的经验。这些头衔也倾向于意味着非Web开发。'
- en: '*Senior software engineer/senior software developer*: Once you have some experience,
    higher-level development positions are, again, less likely to be for web development.
    At the senior level, you will be expected to take on bigger challenges and be
    able to work more independently.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高级软件工程师/高级软件开发者*：一旦你有一些经验，更高层次的开发职位再次不太可能是针对Web开发的。在高级水平上，你将需要承担更大的挑战，并能够更独立地工作。'
- en: '*Lead developer/team lead/technical lead*: Once you have suitable experience
    and demonstrated knowledge, you will often find yourself moving into a “lead”
    position. In such a role, you’ll be expected to be a guiding hand in terms of
    technical direction, often acting as a mentor to more junior team members. You’ll
    still be coding of course, but a good chunk of your time will go into writing
    documents to direct the work of others. These titles don’t say anything about
    whether they are web development-related or not; they apply pretty equally to
    either branch of the software development tree.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发主管/团队主管/技术主管*：一旦你有合适的经验和证明的知识，你通常会发现自己进入了一个“主管”职位。在这个角色中，你将需要在技术方向上起到指导作用，通常作为更年轻团队成员的导师。当然，你仍然会编码，但你的大部分时间将用于编写文档来指导他人的工作。这些头衔并没有说明它们是否与Web开发相关；它们在软件开发树的两个分支上应用得相当平等。'
- en: '*Principal software engineer*: Any job title with “principal” in its name tends
    to denote someone who has been around for a good, long time and is viewed as a
    guiding hand. You’ll probably be involved in multiple projects simultaneously,
    acting as a force multiplier for others and being involved in more strategic conversations
    about what should or shouldn’t be developed to aid the business.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*首席软件工程师*：任何带有“首席”字样的职位名称通常意味着这个人已经在这个行业里待了很长时间，并被视为一个指导者。你可能会同时参与多个项目，作为他人的力量倍增器，并参与更多关于应该或不应该开发什么以帮助业务的战略讨论。'
- en: '*Test engineer/QA engineer*: These are different roles from any of the ones
    mentioned previously, but they’re related. These types of jobs focus more on building
    tests, which actually for the most part still means writing code, but specifically
    code that tests other code. For example, does the `addNumbers()` function return
    5 when I pass it 2 and 3? You can write code that calls the function and confirms
    the value it returns, thereby testing that function. To be clear, *all* developers
    do this, but there is a class of people who do it all the time, and in more depth.
    Related to this are QA engineers, and they are the very necessary people who make
    life difficult for us developers! They’re the ones that try to enter ABC into
    a field that’s only supposed to take numbers and see if the system blows up. Some
    developers move into these types of jobs later, or vice versa, so there’s a clear
    relationship there.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试工程师/质量保证工程师*：这些角色与之前提到的任何角色都不同，但它们是相关的。这类工作更侧重于构建测试，实际上大部分还是意味着编写代码，但具体是编写测试其他代码的代码。例如，当传入2和3时，`addNumbers()`函数是否返回5？你可以编写调用该函数并确认其返回值的代码，从而测试该函数。为了明确，*所有*开发者都会这样做，但有一类人一直在做，并且做得更深入。与此相关的是质量保证工程师，他们是那些让我们开发者感到头疼的必要人物！他们会尝试将ABC输入只应接受数字的字段中，看看系统是否会崩溃。一些开发者后来会转向这类工作，反之亦然，所以这里有一个明显的关系。'
- en: '*Web developer/web designer*: Ah, yes, this one you know! Sometimes, a job
    posting will just list this as the title, which is difficult because while it
    tells you that you’ll be doing web development, it doesn’t say whether it’s frontend,
    backend, or full-stack. In my experience, I’d say it usually does mean full-stack,
    but that’s not a guarantee.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网页开发者/网页设计师*：啊，是的，这个你应该知道！有时候，一个职位发布可能会只列出这个头衔，这很困难，因为它告诉你你将从事网页开发，但并没有说明是前端、后端还是全栈。根据我的经验，我可以说它通常意味着全栈，但这并不是绝对的保证。'
- en: '*Frontend developer*: Sometimes, employers will be specific and say frontend
    development, so now you know exactly what you’ll be doing: writing a lot of HTML,
    CSS, and JavaScript!'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*前端开发者*：有时候，雇主会具体说明是前端开发，这样你就知道你将做什么了：写大量的HTML、CSS和JavaScript！'
- en: '*Backend developer*: Again, a backend position tells you it’s web development,
    and tells you you’ll be working on server code, but exactly what technologies
    you’ll be using isn’t specified, which frankly means you’ll probably wind up using
    more than one.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后端开发者*：同样，后端职位告诉你它是网页开发，并且告诉你你将从事服务器代码的开发，但具体你会使用哪些技术并没有说明，这实际上意味着你可能需要使用不止一种技术。'
- en: '*Full-stack developer*: Finally, there’s the good old full-stack title, which
    means you’ll be expected to know a bit about everything. I should emphasize that
    in most cases, you won’t be expected to be an expert at everything right from
    the start. But you *will* be expected to be able to learn as you go, which is
    equal parts exciting and scary!'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全栈开发者*：最后，我们来说说那个古老的“全栈”头衔，这意味着你将需要了解一些关于所有事情的知识。我必须强调，在大多数情况下，你不需要一开始就成为所有领域的专家。但你会被期望能够边学边进步，这既是令人兴奋的，也是令人恐惧的！'
- en: '*System analyst/computer systems analyst*: Like test and QA titles, any title
    with “analyst” in it is a different thing but is related. An analyst is primarily
    focused on talking to the stakeholders and determining their needs. It’s easy
    enough for a factory owner to say “I need this assembly line to be more efficient,”
    but what does that mean, how do you achieve it, and how do you translate that
    into the blueprints for a software solution? That’s where analysts come in. They
    get into the details of the business processes involved, really understand them,
    and translate that into a software approach, whether that means web-based software
    or not. They don’t define how the software will be written in detail, generally,
    but they’ll define the overall flow of a system and how the pieces fit together.
    Developers will sometimes become analysts as time goes on, and probably sometimes
    the other way around too.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统分析师/计算机系统分析师*：就像测试和质量保证的头衔一样，任何带有“分析师”字样的头衔都是另一回事，但它们是相关的。分析师主要专注于与利益相关者交谈，确定他们的需求。工厂主说“我需要这条装配线更有效率”很容易，但那是什么意思，如何实现，如何将其转化为软件解决方案的蓝图？这就是分析师的用武之地。他们深入了解涉及的业务流程，真正理解它们，并将其转化为软件方法，无论这意味着基于网络的软件与否。他们通常不会详细定义软件将如何编写，但他们将定义系统的整体流程以及各个部分如何组合在一起。随着时间的推移，开发者有时会变成分析师，也可能反过来。'
- en: '*Architect/systems architect/enterprise architect/software architect/principal
    architect*: Titles with the word “architect” in them are people who are focused
    more on the structure of large-scale software systems. They’ll define what the
    parts of a system are, how they will interact, choose technologies to implement
    them, and draw up documents that define it all in a way that software developers
    can use to build what they’ve designed. Therefore, architect positions are a natural
    progression for developers after a certain period, so long as they have the necessary
    aptitude for it. If you’re thinking there is a lot of overlap between analysts
    and architects, that’s largely true. The key difference is that the analyst is
    looking at things from more of a business perspective while the architect is looking
    at it from a technical perspective. Analysts and architects work hand-in-hand.
    so come up with a blueprint for what developers will develop. Architects will
    sometimes code as well, though that tends to happen less and less as you move
    through the ranks.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*架构师/系统架构师/企业架构师/软件架构师/首席架构师*：包含“架构师”一词的职位是指那些更专注于大型软件系统结构的人。他们将定义系统的各个部分，它们将如何交互，选择实现它们的技术，并绘制出软件开发者可以用来构建他们所设计内容的文档。因此，架构师职位是开发者经过一段时间后的自然发展路径，只要他们具备必要的才能。如果你认为分析师和架构师之间存在很多重叠，这在很大程度上是正确的。关键的区别在于，分析师更多地从业务角度看待事物，而架构师则从技术角度看待。分析师和架构师是紧密合作的。因此，他们会为开发者制定蓝图，以便开发者可以开发出他们所设计的内容。架构师有时也会编码，但随着职位的提升，这种情况越来越少。'
- en: '*Technical manager/engineering manager*: The final category I’ll talk about
    is the management levels that tend to come before the executive level. Here, I’m
    talking about technical managers, sometimes called engineering managers. As the
    name implies, these are management positions, in which you’ll tend to do almost
    no actual development yourself, web or otherwise. More of your time will be spent
    on HR matters, meetings to discuss direction, and implementing that direction
    with your team. While these are management positions, you’ll still be expected
    to have your finger on the pulse of technology, which means having had a lot of
    experience to draw on. To be sure, technical managers will often still get their
    hands dirty with actual development, or development-adjacent tasks, but that’s
    no longer their primary focus day-to-day.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*技术经理/工程经理*：我将要讨论的最后一类是通常位于执行层之前的管理层级。在这里，我指的是技术经理，有时也被称为工程经理。正如其名所示，这些是管理职位，你将几乎不会亲自进行实际开发，无论是网页开发还是其他类型的开发。你将花费更多的时间在人力资源管理事务上，参加讨论方向的会议，以及与团队一起实施这些方向。虽然这些是管理职位，但你仍需对技术保持敏感，这意味着你需要有丰富的经验可以借鉴。当然，技术经理有时仍会参与实际开发或与之相关的任务，但这不再是他们日常工作的主要焦点。'
- en: Again, I need to stress that none of these titles are concretely defined anywhere,
    nor are they the only titles you might encounter. Ask 100 different people what
    a technical manager is, for example, and while you probably won’t get 100 different
    answers, you’ll get more than one! Note that this is a rough guide that is based
    on my many years of experience and online research as I wrote this, so it should
    provide you with a decent idea not only of the job titles you might see but also
    what they mean, how they relate to one another, and what your career progression
    through them might look like.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些头衔在任何一个地方都没有明确的定义，它们也不是你可能会遇到的唯一头衔。例如，问100个人什么是技术经理，你可能不会得到100个不同的答案，但你可能会得到不止一个！请注意，这是一个基于我多年经验和在线研究的大致指南，因此它不仅应该能给你提供一个可能看到的职位头衔的概览，还能告诉你它们的意义，它们之间的关系，以及你通过这些职位进行职业发展的可能路径。
- en: I’d also like to point out that moving up through the ranks from programmer
    to manager isn’t a given! You have to be honest with yourself at each step of
    the journey and decide what’s most important to you. I had a manager some years
    back who willingly took a pay cut so that they could go back to being “just” a
    programmer because they enjoyed that aspect of their job but didn’t like the management
    side. And that’s fine! Not everyone will want to be a manager, an architect, or
    even a lead. Whatever title you have, not hating your everyday job is more important
    than any title or even the money that may come with one versus another.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想指出，从程序员到经理的晋升并不是理所当然的！你在旅途中每个步骤都必须对自己诚实，并决定对你来说什么最重要。几年前，我有一个经理自愿减薪，以便他们可以回到“仅仅”是程序员的身份，因为他们喜欢这份工作的这一方面，但不喜欢管理方面。那很好！并不是每个人都想成为经理、架构师或甚至是一个领导。无论你有什么头衔，不喜欢日常的工作比任何头衔甚至可能随之而来的金钱都更重要。
- en: Now, let’s touch on one final topic, which is the roadmap we’ll be building
    up as we go through this book. We have a few more squares to uncover, Vanna White
    style!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们触及一个最后的主题，那就是我们在阅读这本书的过程中将构建的路线图。我们还有几个方框要揭露，就像Vanna White一样！
- en: Reviewing the roadmap
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检视路线图
- en: 'With this chapter concluded, we can now uncover a few more squares of our web
    developer roadmap:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束后，我们现在可以揭示我们网络开发者路线图上的更多几个方框：
- en: '![Figure 2.4: The roadmap, with a few more boxes filled in](img/B18315_02_4.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：路线图，填入了一些更多的方框](img/B18315_02_4.jpg)'
- en: 'Figure 2.4: The roadmap, with a few more boxes filled in'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：路线图，填入了一些更多的方框
- en: In addition to **Logical Thinking**, we’ve revealed the **Frontend** and **Backend**
    boxes, along with their children, **HTML**, **CSS**, **JavaScript**, **Node**,
    and **NPM**. We’ve also revealed **Full-Stack**, which branches off both the **Frontend**
    and **Backend** boxes. We’re well on our way to web developer bingo!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**逻辑思维**，我们还揭示了**前端**和**后端**方框，以及它们的子项**HTML**、**CSS**、**JavaScript**、**Node**和**NPM**。我们还揭示了**全栈**，它从**前端**和**后端**方框分支出来。我们正朝着网络开发者宾果游戏大步前进！
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground! We dug deeper into frontend development
    in the form of HTML, CSS, and JavaScript – the foundations of the web – providing
    some foundational knowledge about each. You also gained an understanding of how
    pages link to other pages and resources, and you got a feel for how a web browser
    loads and renders a page, including what the DOM is all about. Then, you got a
    look at the backend, saw a simple Node example, and discovered how it interacts
    with the frontend.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们覆盖了很多内容！我们深入探讨了前端开发，包括HTML、CSS和JavaScript——网络的基石，为每个提供了基础性知识。你还了解了页面如何链接到其他页面和资源，以及你感受到了网页浏览器如何加载和渲染页面，包括DOM是什么。然后，你看到了后端，看到了一个简单的Node示例，并发现了它如何与前端交互。
- en: After that, we talked a bit more about what a web developer is and how that
    definition ties into the frontend and backend discussions that came before. Finally,
    we talked more about what it means to be full-stack, and the benefits it can bring
    to your career.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们谈了更多关于网络开发者是什么以及这个定义如何与前一章中讨论的前端和后端联系起来。最后，我们更多地讨论了全栈意味着什么以及它能为你的职业生涯带来的好处。
- en: In the next chapter, we’ll look at some more of the other things that might
    be considered “foundational” knowledge for a web developer, building on what you’ve
    seen in this chapter as we continue to build that technical foundation you’ll
    need to succeed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些可能被认为是网络开发者“基础”知识的其他事物，在继续构建你需要成功的技术基础的同时，我们将在此基础上建立你在本章中看到的内容。
