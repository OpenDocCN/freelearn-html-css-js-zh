- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Adding Cucumber Tests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Cucumber测试
- en: 'Up until now, you have seen two types of automated tests: Vitest unit tests
    and Playwright end-to-end tests. This chapter adds a third type of test: **Cucumber**
    ([https://cucumber.io](https://cucumber.io)).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了两种类型的自动化测试：Vitest单元测试和Playwright端到端测试。本章添加了第三种测试类型：**Cucumber**（[https://cucumber.io](https://cucumber.io)）。
- en: Just like Playwright, Cucumber has its own test runner, which is typically set
    up to drive your application in the same way as Playwright does. The difference
    is that Cucumber tests are not written in JavaScript code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Playwright一样，Cucumber也有自己的测试运行器，通常设置为以与Playwright相同的方式驱动应用程序。区别在于Cucumber测试不是用JavaScript代码编写的。
- en: Cucumber tests are contained within *feature files* that contain tests formatted
    in a special syntax known as **Gherkin**. These tests, known as **features** and
    organized into scenarios, read like plain English. That has a couple of advantages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber测试包含在*特性文件*中，这些文件包含以特殊语法格式化的测试，这种语法称为**Gherkin**。这些测试，被称为**特性**，并组织成场景，读起来就像普通的英语。这有几个优点。
- en: First, they can be written and understood by the whole team, not just developers.
    That means you can extend test-first practices outside of the development team.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它们可以被整个团队编写和理解，而不仅仅是开发者。这意味着你可以在开发团队之外扩展测试驱动实践。
- en: Second, the absence of code encourages you to write tests that focus on user
    behavior rather than the technical details of the software. That, in turn, encourages
    you to build the right thing for your users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，代码的缺失鼓励你编写专注于用户行为的测试，而不是软件的技术细节。这反过来又鼓励你为用户构建正确的东西。
- en: 'How does Cucumber turn features into executable code? Well, take a look at
    an example line (or, step) from a feature file:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber如何将特性转换为可执行代码？好吧，看看特性文件中的一个示例行（或步骤）：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Cucumber takes this step and looks for a matching JavaScript-defined step definition.
    The step definition, in this case, looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 黄瓜（Cucumber）执行这一步并寻找一个匹配的JavaScript定义的步骤定义。在这个例子中，步骤定义看起来是这样的：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the step definition has an associated code block. Once Cucumber
    finds a matching step definition, it executes that code block, supplying any parsed
    arguments. In this case, the `url` parameter will be provided as the `/birthdays`
    string. Cucumber also supports other data types, such as `int` and `bigdecimal`
    ([https://github.com/cucumber/cucumber-expressions#parameter-types](https://github.com/cucumber/cucumber-expressions#parameter-types)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意步骤定义有一个相关的代码块。一旦Cucumber找到一个匹配的步骤定义，它就会执行这个代码块，并传递任何解析后的参数。在这种情况下，`url`参数将以`/birthdays`字符串的形式提供。Cucumber还支持其他数据类型，例如`int`和`bigdecimal`（[https://github.com/cucumber/cucumber-expressions#parameter-types](https://github.com/cucumber/cucumber-expressions#parameter-types)）。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下关键主题：
- en: Creating the feature file
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建特性文件
- en: Setting up a Playwright world object
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Playwright世界对象
- en: Implementing step definitions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现步骤定义
- en: By the end of the chapter, you’ll be confident in adding Cucumber tests to your
    application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将自信地为你的应用程序添加Cucumber测试。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter13/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter13/Start).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在网上找到，地址为[https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter13/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter13/Start)。
- en: Creating the feature file
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建特性文件
- en: We begin with writing an example Cucumber feature file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个示例Cucumber特性文件。
- en: The Gherkin syntax that’s used to write features is characterized by the three
    words *Given*, *When*, and *Then*. These are analogous to the *Arrange*, *Act*,
    and *Assert* sections of all good unit tests, so they should feel familiar.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用于编写特性的Gherkin语法以三个词*Given*、*When*和*Then*为特征。这些与所有良好单元测试的*安排*、*行动*和*断言*部分相对应，因此应该感觉熟悉。
- en: 'Let’s jump right in with our feature file and see what happens when we execute
    the test:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接从特性文件开始，看看执行测试时会发生什么：
- en: 'Start by adding a new directory, `features`, with a new `features/birthdays.feature`
    file with the following content. It describes a user scenario in which the *Birthdays*
    application already supports editing a birthday. Here it is:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加一个新的目录`features`，并在其中创建一个名为`features/birthdays.feature`的新文件，内容如下。它描述了一个用户场景，其中*生日*应用程序已经支持编辑生日。如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Install Cucumber using the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装Cucumber：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, go ahead and run the test with `npx @cucumber/cucumber`. You should see
    an output that starts like this:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `npx @cucumber/cucumber` 运行测试。你应该会看到一个输出，开始如下：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Just as all good test runners should, Cucumber is telling us the next task:
    defining the step definition. But before we get there, we need to pull in the
    Playwright APIs.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所有好的测试运行器应该做的那样，Cucumber 正在告诉我们下一个任务：定义步骤定义。但在我们到达那里之前，我们需要引入 Playwright API。
- en: Setting up a Playwright world object
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Playwright 世界对象
- en: How does Cucumber execute your test? Just like with the Playwright tests, we
    need a running application server and a running browser to drive the **user interface**
    (**UI**). In this section, we’ll write all the code that gets the environment
    ready for test execution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber 如何执行你的测试？就像 Playwright 测试一样，我们需要一个运行中的应用服务器和一个运行的浏览器来驱动 **用户界面**（**UI**）。在本节中，我们将编写所有准备测试执行的代码。
- en: Cucumber.js uses the concept of a `this` variable in each step. We also get
    access to it in special `Before` and `After` hooks, which are run before and after
    each scenario.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber.js 使用每个步骤中的 `this` 变量的概念。我们也在特殊的 `Before` 和 `After` 钩子中获得了对它的访问，这些钩子在每次场景前后运行。
- en: The world object should contain functions (and state) that allow you to drive
    the UI. Since you’ve already learned and used the Playwright API for locating
    objects on a page, it would be marvelous if we could use that same API. It turns
    out we can indeed do this. We can also use the same `expect` API we’re used to
    as well, and we’ll do that in the next section when we begin writing step definitions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 世界对象应包含允许你驱动 UI 的函数（和状态）。由于你已经学习和使用了 Playwright API 来定位页面上的对象，如果我们能够使用相同的 API
    那将是极好的。实际上，我们确实可以这样做。我们还可以使用我们熟悉的相同 `expect` API，我们将在下一节开始编写步骤定义时这样做。
- en: 'Here’s what we’ll do: we’ll build a world class named `PlaywrightWorld` that
    has the following functions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们要做的是：我们将构建一个名为 `PlaywrightWorld` 的世界级类，它具有以下功能：
- en: '`launchServer` and `killServer` for starting and stopping the server'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launchServer` 和 `killServer` 用于启动和停止服务器'
- en: '`launchBrowser` and `closeBrowser` for opening and closing a headless web browser,
    and for exposing the Playwright page and `request` APIs on our world object'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launchBrowser` 和 `closeBrowser` 用于打开和关闭无头网络浏览器，并在我们的世界对象上公开 Playwright 页面和
    `request` API'
- en: Then, we’ll use the `Before` and `After` hooks to start and stop both the server
    and browser.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `Before` 和 `After` 钩子来启动和停止服务器和浏览器。
- en: 'One final note before we begin: our code files will use the `mjs` extension
    rather than `js`, to signify to `Cucumber.js` that these files use ECMAScript
    Module syntax.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前的一个注意事项：我们的代码文件将使用 `mjs` 扩展名而不是 `js`，以向 `Cucumber.js` 表明这些文件使用 ECMAScript
    模块语法。
- en: 'Let’s begin:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Start by creating a new file, `features/support/world.mjs`, with the following
    import definitions. We’ll add more later, but these are enough to get us started
    with launching the server:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新文件，`features/support/world.mjs`，包含以下导入定义。我们稍后会添加更多，但这些都是启动服务器所需的：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, define the `removeAnsiColorCodes` function. This is important for execution
    environments (Windows, primarily) that will return color codes in the `stdout`
    stream data:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义 `removeAnsiColorCodes` 函数。这对于会返回 `stdout` 流数据中颜色代码的执行环境（主要是 Windows）来说很重要：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We’re ready to define the `PlaywrightWorld` class, starting with a single method,
    `launchServer`. That method ends with a call to `setWorldConstructor` that makes
    this the designated world class:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备好定义 `PlaywrightWorld` 类，从单个方法 `launchServer` 开始。该方法以调用 `setWorldConstructor`
    结尾，使其成为指定的世界类：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code in our `launchServer` function is very crude, but it does the job.
    It reads the Playwright configuration file and pulls out the value of `config.webServer.command`,
    which on my project is this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `launchServer` 函数中的代码非常简陋，但它完成了工作。它读取 Playwright 配置文件，并提取 `config.webServer.command`
    的值，在我的项目中是这样的：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Launching the web server using Playwright config
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Playwright 配置启动网络服务器
- en: Because this is a shell command, we must use the `detached` and `shell` properties
    when calling Node’s `childProcess.spawn` function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个 shell 命令，所以当我们调用 Node 的 `childProcess.spawn` 函数时，必须使用 `detached` 和 `shell`
    属性。
- en: Setting `env` means that any environment variables that Cucumber receives are
    also passed to this new shell. Once the server is started, we read the `stdout`
    data stream until we see a line that contains an HTTP URL. This is the URL of
    our running web server, so we parse that value and return it as the argument to
    `resolve`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`env`意味着Cucumber接收到的任何环境变量也会传递给这个新的shell。一旦服务器启动，我们就读取`stdout`数据流，直到我们看到包含HTTP
    URL的行。这是运行中Web服务器的URL，因此我们解析该值并将其作为`resolve`的参数返回。
- en: The use of the `Promise` object means that the thread will wait until the value
    is retrieved, and then set the world’s `baseUrl` property to this value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Promise`对象意味着线程将等待直到检索到值，然后将世界的`baseUrl`属性设置为该值。
- en: 'Add the following error handling logic, which simply logs out any non-empty
    messages that appear on the `stderr` data stream:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下错误处理逻辑，它简单地记录出出现在`stderr`数据流上的任何非空消息：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let’s move on to `killServer`, starting by adding a new package, `tree-kill-promise`,
    that will allow us to easily shut down the server process:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续到`killServer`，首先添加一个新的包，`tree-kill-promise`，这将使我们能够轻松关闭服务器进程：
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then add that as an import at the top of the same world file:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将它作为导入添加到同一个世界文件顶部：
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the `killServer` method, shown here:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`killServer`方法，如下所示：
- en: '[PRE12]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s time to launch the browser. Start by bringing in the following Playwright
    `import` statements at the top of the file:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候启动浏览器了。首先在文件顶部引入以下Playwright `import`语句：
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then define the `launchBrowser` and `closeBrowser` functions, as shown in the
    following code. The crucial piece is that we then end up with the `request` and
    `page` objects, which are the exact same objects we have in our Playwright end-to-end
    tests:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后定义`launchBrowser`和`closeBrowser`函数，如下面的代码所示。关键部分是我们最终得到了`request`和`page`对象，这些对象与我们的Playwright端到端测试中的对象完全相同：
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the world object complete, it’s time for the hooks. Add a new file named
    `features/support/hooks.mjs` and give it the following content:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了完整的世界对象，现在是时候添加钩子了。添加一个名为`features/support/hooks.mjs`的新文件，并给它以下内容：
- en: '[PRE15]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That’s all the setup complete. The only remaining thing is the step definitions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的设置都完成了。唯一剩下的事情是步骤定义。
- en: Implementing the step definitions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现步骤定义
- en: The final piece of the puzzle is the `Given`, `When`, and `Then` functions for
    matching feature steps with their implementations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是匹配功能步骤与其实现的`Given`、`When`和`Then`函数。
- en: Checking your work as you go along
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行过程中检查你的工作
- en: In this section we will speed through the definition, but make sure you verify
    each step is working by running Cucumber (with the `npx @cucumber/cucumber` command)
    after you’ve implemented each function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速浏览定义，但请确保在实现每个函数后通过运行Cucumber（使用`npx @cucumber/cucumber`命令）来验证每个步骤是否正常工作。
- en: Let’s do it!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'Create another new directory, `features/support`, and create a file named `features/support/steps.mjs`,
    which starts with the following imports:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个新目录，`features/support`，并创建一个名为`features/support/steps.mjs`的文件，它以以下导入开始：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then implement the first `Given` step from our feature file. This one calls
    into the API using the `this.request.post` function from Playwright. Note the
    use of `failOnStatusCode`, which makes sure that Cucumber fails the test if we
    don’t get a `200 OK` response back:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后实现我们的功能文件中的第一个`Given`步骤。这个步骤使用Playwright的`this.request.post`函数调用API。注意`failOnStatusCode`的使用，它确保如果未收到`200
    OK`响应，Cucumber将失败测试：
- en: '[PRE17]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we’re on to the `When` steps. There are two of these; arguably, one could
    have been `Given`, but I think they work nicely as a group, given that they are
    both user actions. The first one simply calls `this.page.goto`, which you’ve also
    seen before:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们进入`When`步骤。这里有两大步骤；可以说，其中之一可以是`Given`，但我认为它们作为一个组工作得很好，因为它们都是用户操作。第一个步骤简单地调用`this.page.goto`，你之前也见过：
- en: '[PRE18]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the remaining steps, we will use our own `BirthdayListPage` page model
    object that we defined in [*Chapter 7*](B19611_07.xhtml#_idTextAnchor093), *Tidying
    up Test Suites*. Start by importing that at the top of the file:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于剩余的步骤，我们将使用我们在[*第7章*](B19611_07.xhtml#_idTextAnchor093)中定义的自己的`BirthdayListPage`页面模型对象，*整理测试套件*。首先在文件顶部导入它：
- en: '[PRE19]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then implement the next `When` step definition, which uses our battled-tested
    `beginEditingFor`, `dateOfBirthField`, and `saveButton` functions:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后实现下一个`When`步骤定义，它使用我们经过考验的`beginEditingFor`、`dateOfBirthField`和`saveButton`函数：
- en: '[PRE20]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It’s time for the `Then` step definitions. These are the ones that have expectations.
    To begin, add an `import` statement for `expect` at the top of the file:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候编写 `Then` 步骤定义了。这些是包含期望的步骤定义。首先，在文件顶部添加一个 `import` 语句用于 `expect`：
- en: '[PRE21]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the first `Then` clause, shown in the following code block. This
    checks that the new birthday is shown on the page:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下代码块中的第一个 `Then` 子句。这会检查新生日是否显示在页面上：
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Complete the step definitions with the final `Then` clause:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最后的 `Then` 子句完成步骤定义：
- en: '[PRE23]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running the tests now, you should see all of them passing:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行测试，你应该会看到所有测试都通过：
- en: '[PRE24]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You’ve now seen how to write a feature file using the Gherkin syntax, and how
    to write step definitions that use the same Playwright API that you’ve been using
    for your end-to-end-tests. You’ve also seen that the standard `expect` syntax
    can be used to write assertions that is used across all three types of tests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了如何使用 Gherkin 语法编写功能文件，以及如何编写使用与您用于端到端测试相同的 Playwright API 的步骤定义。你还看到了标准
    `expect` 语法可以用于编写适用于所有三种测试类型的断言。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered how to use the Cucumber test runner to execute Gherkin
    feature files. Gherkin’s plain-English syntax makes this an important technique
    for bringing automated testing to the wider product development team.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用 Cucumber 测试运行器执行 Gherkin 功能文件。Gherkin 的纯英文语法使得这项技术对于将自动化测试引入更广泛的产品开发团队变得非常重要。
- en: The feature files are backed by step definitions. These step definitions are
    implemented using the `Given`, `When`, and `Then` functions, which map Gherkin
    step descriptions to JavaScript code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 功能文件由步骤定义支持。这些步骤定义是通过使用 `Given`、`When` 和 `Then` 函数实现的，这些函数将 Gherkin 步骤描述映射到
    JavaScript 代码。
- en: You’ve seen how step definitions can re-use the existing Playwright API code
    to manage browser interactions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用步骤定义重复使用现有的 Playwright API 代码来管理浏览器交互。
- en: This completes our look at automated testing techniques. In *Part 3*, we’ll
    look at how to write unit tests for SvelteKit-specific features, starting with
    a chapter on strategies for testing authentication.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对自动化测试技术的探讨。在 *第3部分* 中，我们将探讨如何为 SvelteKit 特定功能编写单元测试，从测试认证的策略章节开始。
- en: 'Part 3: Testing SvelteKit Features'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：测试 SvelteKit 功能
- en: This part takes a glance at some specific features that require careful testing.
    These chapters aren’t sequential as in the previous parts. Instead, they are discussions
    on how you might approach your testing. The code samples included focus only on
    the novel pieces that haven’t been covered in previous chapters. You can always
    refer to the online repository for complete implementations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分简要介绍了需要仔细测试的一些特定功能。这些章节的顺序与前面部分不同。相反，它们是关于你如何进行测试的讨论。包含的代码示例仅关注前面章节中没有涉及的新颖部分。你始终可以参考在线存储库以获取完整的实现。
- en: 'This part has the following chapters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 14*](B19611_14.xhtml#_idTextAnchor156), *Testing Authentication*'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19611_14.xhtml#_idTextAnchor156)，*测试认证*'
- en: '[*Chapter 15*](B19611_15.xhtml#_idTextAnchor168), *Test-Driving Svelte Stores*'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19611_15.xhtml#_idTextAnchor168)，*测试 Svelte 存储*'
- en: '[*Chapter 16*](B19611_16.xhtml#_idTextAnchor175), *Test-Driving Service Workers*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B19611_16.xhtml#_idTextAnchor175)，*测试服务工作者*'
