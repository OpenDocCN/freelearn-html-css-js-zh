- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Interacting with the File System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文件系统交互
- en: Before Node.js, JavaScript was predominantly used in the browser. Node.js brought
    JavaScript to the server and enabled us to interact with the operating system
    through JavaScript. Today, Node.js is one of the most popular technologies for
    building server-side applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 之前，JavaScript 主要用于浏览器。Node.js 将 JavaScript 带到服务器，并使我们能够通过 JavaScript
    与操作系统交互。今天，Node.js 是构建服务器端应用最受欢迎的技术之一。
- en: 'Node.js interacts with the operating system at a fundamental level: **input
    and output** ( **I/O** ). This chapter will explore the core APIs provided by
    Node.js that allow us to interact with standard I/O, the file system, and the
    network stack.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 在基本层面上与操作系统交互：**输入和输出** ( **I/O** )。本章将探讨 Node.js 提供的核心 API，这些 API 允许我们与标准
    I/O、文件系统和网络堆栈交互。
- en: This chapter will show you how to read and write files both synchronously and
    asynchronously. Node.js was built to handle asynchronous code and enable a non-blocking
    model. Understanding how to read and write asynchronous code is fundamental learning,
    and it will show how to leverage the capabilities of Node.js.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何同步和异步地读取和写入文件。Node.js 是为了处理异步代码并启用非阻塞模型而构建的。了解如何读取和写入异步代码是基本的学习，它将展示如何利用
    Node.js 的功能。
- en: We will also learn about the core modules provided by Node.js. We’ll be focusing
    on the **File System** module, which enables you to interact with the file system
    and files. Newer versions of Node.js have added **Promise** variants of many file
    system APIs, which will also be touched upon in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将了解 Node.js 提供的核心模块。我们将重点关注 **文件系统** 模块，它允许您与文件系统及文件交互。Node.js 的新版本添加了许多文件系统
    API 的 **Promise** 变体，这些内容也将在本章中涉及。
- en: 'This chapter will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Interacting with the file system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文件系统交互
- en: Working with files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件操作
- en: Fetching metadata
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取元数据
- en: Watching files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视文件
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have a recent version of Node.js 22 installed,
    a **Terminal** or shell, and an editor of your choice. The code for this chapter
    is available on GitHub at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    in the **Chapter02** directory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已安装了最新版本的 Node.js 22，一个 **终端** 或 shell，以及您选择的编辑器。本章的代码可在 GitHub 的 [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    中的 **Chapter02** 目录找到。
- en: This chapter will use the CommonJS syntax; refer to [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
    for more information on CommonJS and ECMAScript modules.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用 CommonJS 语法；有关 CommonJS 和 ECMAScript 模块的信息，请参阅 [*第 5 章*](B19212_05.xhtml#_idTextAnchor139)。
- en: Interacting with the file system
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文件系统交互
- en: '**Standard in** ( **stdin** ) refers to an input stream that a program can
    use to read input from a command shell or Terminal. Similarly, **standard out**
    ( **stdout** ) refers to the stream that is used to write the output. **Standard
    error** ( **stderr** ) is a separate stream to **stdout** that is typically reserved
    for outputting errors and diagnostic data.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准输入** ( **stdin** ) 指的是程序可以用来从命令行或终端读取输入的输入流。同样，**标准输出** ( **stdout** )
    指的是用于写入输出的流。**标准错误** ( **stderr** ) 是与 **stdout** 分离的流，通常用于输出错误和诊断数据。'
- en: In this recipe, we’re going to learn how to handle input with **stdin** , write
    output to **stdout** , and log errors to **stderr** .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何处理 **stdin** 的输入，将输出写入 **stdout**，并将错误记录到 **stderr**。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, let’s first create a single file named **greeting.js** . The
    program will ask for user input via **stdin** , return a greeting via **stdout**
    , and log an error to **stderr** when invalid input is provided. Let’s create
    a directory to work in, too:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们首先创建一个名为 **greeting.js** 的单个文件。程序将通过 **stdin** 请求用户输入，通过 **stdout**
    返回问候语，当提供无效输入时将错误记录到 **stderr**。同时，我们也创建一个工作目录：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we’ve set up our directory and file, we’re ready to move on to the
    recipe steps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了目录和文件，我们可以继续进行食谱步骤。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we’re going to create a program that can read from **stdin**
    and write to **stdout** and **stderr** :'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个程序，可以从 **stdin** 读取并写入 **stdout** 和 **stderr**：
- en: 'First, we need to tell the program to listen for user input. This can be done
    by adding the following lines to **greeting.js** :'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要告诉程序监听用户输入。这可以通过向 **greeting.js** 添加以下行来实现：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can run the file using the following command. Observe that the application
    does not exit because it is continuing to listen for **process.stdin** data events:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行文件。注意，应用程序没有退出，因为它正在继续监听 **process.stdin** 数据事件：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Exit the program using *Ctrl* + *C* .
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *C* 退出程序。
- en: 'We can now tell the program what it should do each time it detects a data event.
    Add the following lines below the **// processing on each data** **event** comment:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以告诉程序每次检测到数据事件时应该做什么。在 **// processing on each data event** 注释下方添加以下行：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can now type input to your program. When you press *Enter* , it will return
    a greeting and your name in uppercase:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以向程序输入。当你按下 *Enter* 时，它将返回一个问候语和你的大写名字：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now add a check for whether the input string is empty and log to **stderr**
    if it is. Change your file to the following:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以添加一个检查输入字符串是否为空的检查，并在它是空的情况下向 **stderr** 记录。将你的文件更改为以下内容：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the program again and hit *Enter* with no input:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行程序并输入没有输入的 *Enter*：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ve now created a program that can read from **stdin** and write to **stdout**
    and **stderr** .
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了一个可以从 **stdin** 读取并写入 **stdout** 和 **stderr** 的程序。
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The **process.stdin** , **process.stdout** , and **process.stderr** properties
    are all properties on the process object. A global process object provides information
    and control of the Node.js process. For each of the I/O channels (standard in,
    standard out, standard error), they emit data events for every chunk of data received.
    In this recipe, we were running the program in interactive mode where each data
    chunk was determined by the newline character when you hit *Enter* in your shell.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**process.stdin**、**process.stdout** 和 **process.stderr** 属性都是进程对象上的属性。全局进程对象提供了对
    Node.js 进程的信息和控制。对于每个 I/O 通道（标准输入、标准输出、标准错误），它们在接收到每个数据块时都会发出数据事件。在本配方中，我们以交互模式运行程序，其中每个数据块由你在
    shell 中按下 *Enter* 时的换行符确定。'
- en: The **process.stdin.on('data', (data) => {...});** instance is what listens
    for these data events. Each data event returns a **Buffer** object. The **Buffer**
    object (typically named **data** ) returns a binary representation of the input.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: The **process.stdin.on('data', (data) => {...});** 实例是监听这些数据事件的。每个数据事件返回一个 **Buffer**
    对象。该 **Buffer** 对象（通常命名为 **data**）返回输入的二进制表示。
- en: The **const name = data.toString()** instance is what turns the **Buffer** object
    into a string. The **trim()** function removes all whitespace characters – including
    spaces, tabs, and newline characters – from the beginning and end of a string.
    The whitespace characters include spaces, tabs, and newline characters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**const name = data.toString()** 实例是将 **Buffer** 对象转换为字符串。**trim()** 函数会从字符串的开始和结束处移除所有空白字符——包括空格、制表符和换行符。空白字符包括空格、制表符和换行符。'
- en: We write to **stdout** and **stderr** using the respective properties on the
    process object ( **process.stdout.write** , **process.stderr.write** ).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用进程对象上的相应属性（**process.stdout.write**，**process.stderr.write**）向 **stdout**
    和 **stderr** 写入。
- en: 'During the recipe, we also used *Ctrl* + *C* to exit the program in the shell.
    *Ctrl* + *C* sends **SIGINT** , or signal interrupt, to the Node.js process. For
    more information about signal events, refer to the Node.js Process API documentation:
    [https://nodejs.org/api/process.html#process_signal_events](https://nodejs.org/api/process.html#process_signal_events)
    .'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方过程中，我们还使用了 *Ctrl* + *C* 来在 shell 中退出程序。*Ctrl* + *C* 向 Node.js 进程发送 **SIGINT**，或信号中断。有关信号事件的更多信息，请参阅
    Node.js 进程 API 文档：[https://nodejs.org/api/process.html#process_signal_events](https://nodejs.org/api/process.html#process_signal_events)。
- en: Important note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**Console APIs** : Under the hood, **console.log** and **console.err** are
    using **process.stdout** and **process.stderr** . Console methods are higher-level
    APIs and include automatic formatting. It’s typical to use console methods for
    convenience and lower-level process methods when you require more control over
    the stream.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制台 API**：在底层，**console.log** 和 **console.err** 使用 **process.stdout** 和 **process.stderr**。控制台方法是高级
    API，包括自动格式化。通常，当需要更多对流的控制时，会使用控制台方法来提高便利性，并使用低级进程方法。'
- en: There’s more…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: As of Node.js 17.0.0, Node.js provides an Experimental Readline Promises API,
    which is used for reading a file line by line. The Promises API variant of this
    allows you to use **async** / **await** instead of callbacks, providing a more
    modern and cleaner approach to handling asynchronous operations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Node.js 17.0.0 版本，Node.js 提供了一个实验性的 Readline Promises API，用于逐行读取文件。此 Promises
    API 变体允许您使用 **async** / **await** 而不是回调，提供了一种更现代、更简洁的处理异步操作的方法。
- en: 'Here is an example of how the Promises API variant can be used to create a
    similar program to the **greeting.js** file created in the main recipe:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用 Promises API 变体创建一个类似于主菜谱中创建的 **greeting.js** 文件的示例程序：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This Node.js script utilizes the **node:readline/promises** module, which provides
    the **Promise** variant of the Readline API. It defines an asynchronous function,
    **greet()** , which prompts the user for their name in the console and then greets
    them with a personalized message – similar to the main recipe program. Using the
    Readline Promises API allows us to use the **async** / **await** syntax for cleaner
    asynchronous code flow. We’ll cover more about the **async** / **await** syntax
    in later recipes and chapters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Node.js 脚本使用了 **node:readline/promises** 模块，该模块提供了 Readline API 的 **Promise**
    变体。它定义了一个异步函数 **greet()**，该函数在控制台中提示用户输入他们的名字，然后用个性化的消息问候他们——类似于主菜谱程序。使用 Readline
    Promises API 允许我们使用 **async** / **await** 语法来编写更干净的异步代码流。我们将在后面的菜谱和章节中介绍更多关于 **async**
    / **await** 语法的知识。
- en: See also
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Decoupling I/O* recipe in [*Chapter 3*](B19212_03.xhtml#_idTextAnchor068)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B19212_03.xhtml#_idTextAnchor068) 的 *解耦 I/O* 菜谱
- en: Working with files
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: Node.js provides several core modules, including the **fs** module. **fs** stands
    for File System, and this module provides the APIs to interact with the file system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 提供了多个核心模块，包括 **fs** 模块。**fs** 代表文件系统，此模块提供了与文件系统交互的 API。
- en: In this recipe, and throughout the book, we will make use of the **node:** prefix
    when importing core modules.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱和整本书中，我们将使用 **node:** 前缀来导入核心模块。
- en: In this recipe, we’ll learn how to read, write, and edit files using the synchronous
    functions available in the **fs** module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何使用 **fs** 模块中提供的同步函数来读取、写入和编辑文件。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let’s start by preparing a directory and files for this recipe:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为这个菜谱准备一个目录和文件：
- en: 'Create another directory for this recipe:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此菜谱创建另一个目录：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And now, let’s create a file to read. Run the following in your shell to create
    a file containing some simple text:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个用于读取的文件。在您的 shell 中运行以下命令以创建包含一些简单文本的文件：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ll also need a file for our program—create a file named **readWriteSync.js**
    :'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为我们的程序创建一个文件——创建一个名为 **readWriteSync.js** 的文件：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **touch** utility is a command-line utility included in Unix-based operating
    systems that is used to update the access and modification date of a file or directory
    to the current time. However, when **touch** is run with no additional arguments
    on a non-existent file, it will create an empty file with that name. The **touch**
    utility is a typical way of creating an empty file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**touch** 工具是 Unix 类操作系统中的一个命令行工具，用于将文件或目录的访问和修改日期更新为当前时间。然而，当 **touch** 在没有额外参数的情况下运行在不存在文件上时，它将创建一个空文件，并使用该名称。**touch**
    工具是创建空文件的典型方法。'
- en: How to do it…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we’ll synchronously read the file named **hello.txt** , manipulate
    the contents of the file, and then update the file using synchronous functions
    provided by the **fs** module:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将使用 **fs** 模块提供的同步函数同步地读取名为 **hello.txt** 的文件，操作文件内容，然后使用同步函数更新文件：
- en: 'We’ll start by requiring the **fs** and **path** built-in modules. Add the
    following lines to **readWriteSync.js** :'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先引入 **fs** 和 **path** 内置模块。将以下行添加到 **readWriteSync.js** 中：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let’s create a variable to store the file path of the **hello.txt** file
    that we created earlier:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个变量来存储我们之前创建的 **hello.txt** 文件的文件路径：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now synchronously read the file contents using the **readFileSync()**
    function provided by the **fs** module. We’ll also print the file contents to
    **stdout** using **console.log()** :'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 **fs** 模块提供的 **readFileSync()** 函数同步地读取文件内容。我们还将使用 **console.log()**
    将文件内容打印到 **stdout**：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can edit the content of the file – we will convert the lowercase text
    into uppercase:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以编辑文件的内容了——我们将把小写文本转换为大写：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To update the file, we can use the **writeFileSync()** function. We’ll also
    add a **log** statement afterward indicating that the file has been updated:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新文件，我们可以使用 **writeFileSync()** 函数。之后，我们还会添加一个 **log** 语句来指示文件已被更新：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run your program with the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行您的程序：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To verify the contents were updated, you can open or use **cat** in your Terminal
    to show the contents of **hello.txt** :'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证内容是否已更新，您可以在终端中使用 **cat** 命令来显示 **hello.txt** 的内容：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You now have a program that, when run, will read the contents of **hello.txt**
    , convert the text content into uppercase, and update the file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个程序，当运行时，将读取 **hello.txt** 的内容，将文本内容转换为大写，并更新文件。
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As is commonplace, the first two lines of the file require the necessary core
    modules for the program.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如同常见情况，文件的前两行需要程序所需的必要核心模块。
- en: The **const fs = require('node:fs');** line will import the core Node.js File
    System module. The API documentation for the Node.js File System module is available
    at [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html) . The **fs**
    module provides APIs to interact with the file system using Node.js. Similarly,
    the core **path** module provides APIs for working with file and directory paths.
    The **path** module API documentation is available at [https://nodejs.org/api/path.html](https://nodejs.org/api/path.html)
    .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**const fs = require(''node:fs'');** 这一行将导入 Node.js 核心文件系统模块。Node.js 文件系统模块的
    API 文档可在 [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html) 找到。**fs**
    模块提供了使用 Node.js 与文件系统交互的 API。同样，核心 **path** 模块提供了用于处理文件和目录路径的 API。**path** 模块
    API 文档可在 [https://nodejs.org/api/path.html](https://nodejs.org/api/path.html)
    找到。'
- en: Next, we defined a variable to store the file path of **hello.txt** using the
    **path.join()** and **process.cwd()** functions. The **path.join()** function
    joins the path sections provided as parameters with the separator for the specific
    platform (for example, **/** on Unix and **\** on Windows environments).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 **path.join()** 和 **process.cwd()** 函数定义了一个变量来存储 **hello.txt** 的文件路径。**path.join()**
    函数将提供的路径部分与特定平台的分隔符（例如，Unix 环境中的 **/** 和 Windows 环境中的 **\**）连接起来。
- en: The **process.cwd()** function is a function on the global process object that
    returns the current directory of the Node.js process. This program is expecting
    the **hello.txt** file to be in the same directory as the program.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**process.cwd()** 函数是全局 process 对象上的一个函数，它返回 Node.js 进程的当前目录。此程序期望 **hello.txt**
    文件与程序位于同一目录。'
- en: Next, we read the file using the **fs.readFileSync()** function. We pass this
    function the file path to read and the encoding, UTF-8. The encoding parameter
    is optional—when the parameter is omitted, the function will default to returning
    a **Buffer** object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 **fs.readFileSync()** 函数读取文件。我们将要读取的文件路径和编码 UTF-8 传递给此函数。编码参数是可选的——当省略此参数时，函数将默认返回一个
    **Buffer** 对象。
- en: To perform manipulation of the file contents, we used the **toUpperCase()**
    function available on string objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对文件内容进行操作，我们使用了字符串对象上可用的 **toUpperCase()** 函数。
- en: Finally, we updated the file using the **fs.writeFileSync()** function. We passed
    the **fs.writeFileSync()** function two parameters. The first parameter was the
    path to the file we wished to update, and the second parameter was the updated
    file contents.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 **fs.writeFileSync()** 函数更新了文件。我们向 **fs.writeFileSync()** 函数传递了两个参数。第一个参数是我们希望更新的文件的路径，第二个参数是更新后的文件内容。
- en: Important note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Both the **readFileSync()** and **writeFileSync()** APIs are synchronous, which
    means that they will block/delay concurrent operations until the file read or
    write is completed. To avoid blocking, you’ll want to use the asynchronous versions
    of these functions, covered in the *There’s more…* section of the current recipe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**readFileSync()** 和 **writeFileSync()** API 都是同步的，这意味着它们将在文件读取或写入完成后才会阻塞/延迟并发操作。为了避免阻塞，您将想要使用这些函数的异步版本，这在本食谱的
    *还有更多…* 部分中进行了介绍。'
- en: There’s more…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Throughout this recipe, we were operating on our files synchronously. However,
    Node.js was developed with a focus on enabling the non-blocking I/O model; therefore,
    in many (if not most) cases, you’ll want your operations to be asynchronous.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，我们都是同步地对文件进行操作的。然而，Node.js 的开发重点是使非阻塞 I/O 模型成为可能；因此，在许多（如果不是大多数）情况下，您会希望操作是异步的。
- en: Today, there are three notable ways to handle asynchronous code in Node.js—callbacks,
    Promises, and **async** / **await** syntax. The earliest versions of Node.js only
    supported the callback pattern. Promises were added to the JavaScript specification
    with ECMAScript 2015, known as ES6, and subsequently, support for Promises was
    added to Node.js. Following the addition of **Promise** support, **async** / **await**
    syntax support was also added to Node.js.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，在 Node.js 中处理异步代码有三种显著的方法——回调、Promises 和 **async** / **await** 语法。Node.js
    的最早版本只支持回调模式。Promises 是随着 ECMAScript 2015（也称为 ES6）的 JavaScript 规范一起添加的，随后 Node.js
    也添加了对 Promises 的支持。在添加 **Promise** 支持之后，Node.js 也添加了对 **async** / **await** 语法的支持。
- en: All currently supported versions of Node.js now support callbacks, Promises,
    and **async** / **await** syntax – you may find any of these used in modern Node.js
    development. Let’s explore how we can work with files asynchronously using these
    techniques.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有当前支持的 Node.js 版本现在都支持回调、Promises 和 **async** / **await** 语法 - 你可能会在现代 Node.js
    开发中看到这些中的任何一个。让我们探索如何使用这些技术异步处理文件。
- en: Working with files asynchronously
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步处理文件
- en: Asynchronous programming can enable some tasks or processing to continue while
    other operations are happening.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程可以在其他操作进行时使某些任务或处理继续进行。
- en: 'The program from the *Working with files* recipe was written using the synchronous
    functions available in the **fs** module:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 *与文件一起工作* 食谱的程序是使用 **fs** 模块中可用的同步函数编写的：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This means that the program was blocked waiting for the **readFileSync()** and
    **writeFileSync()** operations to complete. This program can be rewritten to make
    use of asynchronous APIs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着程序被阻塞，等待 **readFileSync()** 和 **writeFileSync()** 操作完成。这个程序可以被重写以利用异步API。
- en: The asynchronous version of **readFileSync()** is **readFile()** . The general
    convention is that synchronous APIs will have the term “sync” appended to their
    name. The asynchronous function requires a callback function to be passed to it.
    The callback function contains the code that we want to be executed when the asynchronous
    task completes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**readFileSync()** 的异步版本是 **readFile()**。一般规则是，同步API的名称将附加“sync”后缀。异步函数需要一个回调函数传递给它。回调函数包含我们希望在异步任务完成时执行的代码。'
- en: 'The following steps will implement the same behavior as the program from the
    *Working with files* recipe but using asynchronous methods:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将实现与 *与文件一起工作* 食谱中的程序相同的行为，但使用异步方法：
- en: 'The **readFileSync()** function in this recipe could be changed to use the
    asynchronous function with the following:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本食谱中，**readFileSync()** 函数可以被更改为使用以下异步函数：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Observe that all the processing that is reliant on the file read needs to take
    place inside the callback function.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，所有依赖于文件读取的处理都需要在回调函数内部进行。
- en: 'The **writeFileSync()** function can also be replaced with the **writeFile()**
    asynchronous function:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**writeFileSync()** 函数也可以替换为 **writeFile()** 异步函数：'
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that we now have an asynchronous function that calls another asynchronous
    function. It’s not recommended to have too many nested callbacks as it can negatively
    impact the readability of the code. Consider the following to see how having too
    many nested callbacks impedes the readability of the code, which is sometimes
    referred to as “ callback hell”:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们现在有一个异步函数调用了另一个异步函数。不建议有太多的嵌套回调，因为它可能会对代码的可读性产生负面影响。考虑以下内容，看看过多的嵌套回调是如何阻碍代码的可读性的，这有时被称为“回调地狱”：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Some approaches can be taken to avoid too many nested callbacks. One approach
    would be to split callbacks into explicitly named functions. For example, our
    file could be rewritten so that the **writeFile()** call is contained within its
    own named function, **updateFile()** :'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以采取一些方法来避免过多的嵌套回调。一种方法是将回调函数拆分为显式命名的函数。例如，我们可以将文件重写，使得 **writeFile()** 调用包含在其自己的命名函数
    **updateFile()** 中：
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Another approach would be to use Promises, which we’ll cover in the *Using the
    fs Promises API* section of this chapter. But as the earliest versions of Node.js
    did not support Promises, the use of callbacks is still prevalent in many **npm**
    modules and existing applications.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种方法是使用 Promises，我们将在本章的 *使用 fs Promises API* 部分中介绍。但是，由于 Node.js 的最早版本不支持
    Promises，回调的使用在许多 **npm** 模块和现有应用程序中仍然很普遍。
- en: 'To demonstrate that this code is asynchronous, we can use the **setInterval()**
    function to print a string to the screen while the program is running. The **setInterval()**
    function enables you to schedule a function to happen after a specified delay
    in milliseconds. Add the following line to the end of your program:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示此代码是异步的，我们可以使用**setInterval()**函数在程序运行时将字符串打印到屏幕上。**setInterval()**函数允许你安排在指定的毫秒延迟后执行一个函数。将以下行添加到程序末尾：
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Observe that the string continues to be printed every millisecond, even in between
    when the file is being read and rewritten. This shows that the file reading and
    writing have been implemented in a non-blocking manner because operations are
    still completing while the file is being handled.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到字符串每毫秒都会继续打印，即使在文件正在读取和重写之间。这表明文件读取和写入是以非阻塞方式实现的，因为操作仍在处理文件时完成。
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Using **unref()** on **setInterval()** means this timer will not keep the Node.js
    event loop active. This means that if it is the only active event in the event
    loop, Node.js may exit. This is useful for timers for which you want to execute
    an action in the future but do not want to keep the Node.js process running solely.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在**setInterval()**中使用**unref()**意味着这个计时器不会保持Node.js事件循环活跃。这意味着如果它是事件循环中唯一的活跃事件，Node.js可能会退出。这对于你希望在将来执行某个操作但不想仅为了保持Node.js进程运行而使用计时器的情况非常有用。
- en: 'To demonstrate this further, you could add a delay between the reading and
    writing of the file. To do this, wrap the **updateFile()** function in a **setTimeout()**
    function. The **setTimeout()** function allows you to pass it a function and a
    delay in milliseconds:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步演示这一点，你可以在文件的读取和写入之间添加一个延迟。为此，将**updateFile()**函数包裹在**setTimeout()**函数中。**setTimeout()**函数允许你传递一个函数和一个毫秒延迟：
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, the output from our program should have more asterisks printed between
    the file read and write, as this is where we added the 10-millisecond delay:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们程序的输出应该在文件读取和写入之间打印出更多的星号，因为这是我们添加了10毫秒延迟的地方：
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can now see that we have converted the program from the *Working with files*
    recipe to handle the file operations asynchronously using the callback syntax.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到，我们已经将程序从“与文件一起工作”食谱转换为使用回调语法异步处理文件操作。
- en: Using the fs Promises API
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用fs Promises API
- en: 'The **fs** Promises API was released in Node.js v10.0.0. The API provides File
    System functions that return **Promise** objects rather than callbacks. Not all
    the original **fs** module APIs have equivalent **Promise** -based APIs, as only
    a subset of the original APIs were converted to provide **Promise** APIs. Refer
    to the Node.js API documentation for a full list of **fs** functions provided
    via the **fs** Promises API: [https://nodejs.org/docs/latest/api/fs.html#promises-api](https://nodejs.org/docs/latest/api/fs.html#promises-api)
    .'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**fs** Promises API在Node.js v10.0.0版本中发布。该API提供了返回**Promise**对象而不是回调的文件系统函数。并非所有原始**fs**模块API都有等效的基于**Promise**的API，因为只有原始API的一个子集被转换为提供**Promise**
    API。请参阅Node.js API文档以获取通过**fs** Promises API提供的**fs**函数的完整列表：[https://nodejs.org/docs/latest/api/fs.html#promises-api](https://nodejs.org/docs/latest/api/fs.html#promises-api)
    .'
- en: 'A **Promise** is an object that is used to represent the completion of an asynchronous
    function. The naming is based on the general definition of the term “promise”—an
    agreement to do something or that something will happen. A **Promise** object
    is always in one of the three following states:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**Promise**是一个用于表示异步函数完成的对象。命名基于该术语“promise”的一般定义——即做某事或某事将要发生的协议。一个**Promise**对象始终处于以下三种状态之一：'
- en: Pending
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待定
- en: Fulfilled
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已完成
- en: Rejected
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已拒绝
- en: A **Promise** will initially be in the pending state and will remain pending
    until it becomes either fulfilled—when the task has completed successfully—or
    rejected—when the task has failed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**Promise**最初处于待定状态，并且将保持待定状态，直到它变为已完成——当任务成功完成时——或已拒绝——当任务失败时。'
- en: 'The following steps will implement the same behavior as the program from the
    recipe again but using **fs** Promises API methods:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将再次实现与食谱中程序相同的行为，但使用**fs** Promise API方法：
- en: 'To use the API, you’ll first need to import it:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用该API，你首先需要导入它：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It is then possible to read the file using the **readFile()** function:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，可以使用**readFile()**函数读取文件：
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can also combine the **fs** Promises API with the use of the **async**
    / **await** syntax:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以将**fs** Promises API与**async** / **await**语法结合使用：
- en: '[PRE28]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Two notable aspects of this implementation are the use of the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本实现有两个值得注意的方面，包括以下内容的使用：
- en: '**async function run() {...}** : Defines an asynchronous function named **run()**
    . Asynchronous functions enable the use of the **await** keyword for handling
    promises in a more synchronous-looking manner.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async function run() {...}** : 定义了一个名为 **run()** 的异步函数。异步函数允许使用 **await**
    关键字以更同步的方式处理承诺。'
- en: '**await fs.readFile(filepath, ''utf8'')** : Uses the **await** keyword to asynchronously
    read the contents of the file specified.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**await fs.readFile(filepath, ''utf8'')** : 使用 **await** 关键字异步读取指定文件的文件内容。'
- en: Now, we’ve learned how we can interact with files using the **fs** Promises
    API.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学会了如何使用 **fs** Promises API 与文件进行交互。
- en: Important note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Owing to using CommonJS in this chapter, it was necessary to wrap the **async**
    / **await** example in a function as **await** must only be called from within
    an asynchronous function with CommonJS. From [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
    onward, we’ll cover ECMAScript modules, where this wrapper function would be unnecessary
    due to **top-level await** being supported with ECMAScript modules.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章使用了 CommonJS，因此有必要将 **async** / **await** 示例包装在一个函数中，因为 **await** 只能在 CommonJS
    的异步函数内部调用。从 [*第 5 章*](B19212_05.xhtml#_idTextAnchor139) 开始，我们将介绍 ECMAScript 模块，由于
    ECMAScript 模块支持 **顶层 await**，因此不需要这个包装函数。
- en: See also
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Fetching metadata* recipe in this chapter
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *获取元数据* 食谱
- en: The *Watching files* recipe in this chapter
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *监视文件* 食谱
- en: '[*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 5 章*](B19212_05.xhtml#_idTextAnchor139)'
- en: Fetching metadata
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取元数据
- en: The **fs** module generally provides APIs that are modeled around **Portable
    Operating System Interface** ( **POSIX** ) functions. The **fs** module includes
    APIs that facilitate the reading of directories and file metadata.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**fs** 模块通常提供基于 **Portable Operating System Interface** ( **POSIX** ) 函数的 API。**fs**
    模块包括便于读取目录和文件元数据的 API。'
- en: In this recipe, we will create a small program that returns information about
    a file, using functions provided by the **fs** module.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个小程序，使用 **fs** 模块提供的函数返回有关文件的信息。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Get started by creating a directory to work in:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始创建一个工作目录：
- en: '[PRE29]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We’ll also need to create a file to read and a file for our program:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建一个用于读取的文件和一个用于程序的文件：
- en: '[PRE30]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Using the files created in the *Getting ready* section, we will create a program
    that gives information about the file we pass to it as a parameter:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *准备工作* 部分中创建的文件，我们将创建一个程序，该程序提供有关作为参数传递给它的文件的信息：
- en: 'As in the previous recipes, we first need to import the necessary core modules.
    For this recipe, we just need to import the **fs** module:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的食谱一样，我们首先需要导入必要的核心模块。对于这个食谱，我们只需要导入 **fs** 模块：
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we need the program to be able to read the filename as a command-line
    argument. To read the file argument, we can use **process.argv[2]** . Add the
    following line to your program:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要程序能够读取文件名作为命令行参数。为了读取文件参数，我们可以使用 **process.argv[2]**。将以下行添加到你的程序中：
- en: '[PRE32]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we will create our **printMetadata** function:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的 **printMetadata** 函数：
- en: '[PRE33]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add a call to the **printMetadata** function:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 **printMetadata** 函数的调用：
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can now run the program, passing it the **./file.txt** argument. Run your
    program with the following:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以运行程序，传递给它 **./file.txt** 参数。使用以下命令运行你的程序：
- en: '[PRE35]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Expect to see output like the following:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期看到以下输出：
- en: '[PRE36]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can try adding some random text to **file.txt** , saving the file, and then
    rerunning your program; observe that the **size** and **mtime** values have been
    updated.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以尝试向 **file.txt** 添加一些随机文本，保存文件，然后重新运行你的程序；观察到的 **size** 和 **mtime** 值已更新。
- en: 'Now, let’s see what happens when we pass a non-existent file to the program:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们向程序传递一个不存在的文件时会发生什么：
- en: '[PRE37]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The program throws an exception.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序抛出了异常。
- en: 'We should catch this exception and output a message to the user saying the
    file path provided does not exist. To do this, change the **printMetadata** function
    to this:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该捕获这个异常，并向用户输出一条消息，说明提供的文件路径不存在。为此，将 **printMetadata** 函数更改为以下内容：
- en: '[PRE38]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the program again with a non-existent file:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行程序，使用一个不存在的文件：
- en: '[PRE39]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This time, you should see that the program handled the error rather than throwing
    an exception.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你应该看到程序处理了错误而不是抛出异常。
- en: How it works…
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The **process.argv** property is a property on the global process object that
    returns an array containing the arguments that were passed to the Node.js process.
    The first element of the **process.argv** array, **process.argv[0]** , is the
    path of the **node** binary that is running. The second element is the path of
    the file we’re executing – in this case, **metadata.js** . In the recipe, we passed
    the filename as the third command-line argument and, therefore, referenced it
    with **process.argv[2]** .
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**process.argv** 属性是全局进程对象的一个属性，它返回一个包含传递给 Node.js 进程的参数的数组。**process.argv**
    数组的第一个元素 **process.argv[0]** 是正在运行的 **node** 二进制文件的路径。第二个元素是我们正在执行的文件路径——在本例中，是
    **metadata.js** 。在配方中，我们将文件名作为第三个命令行参数传递，因此用 **process.argv[2]** 来引用它。'
- en: 'Next, we created a **printMetadata()** function that called **statSync(file)**
    . The **statSync()** function is a synchronous function that returns information
    about the file path that is passed to it. The file path passed can be either a
    file or a directory. The information returned is in the form of a **stats** object.
    The following table lists the information returned on the **stats** object:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个名为 **printMetadata()** 的函数，该函数调用了 **statSync(file)** 。**statSync()**
    是一个同步函数，它返回传递给它的文件路径的信息。传递给该函数的文件路径可以是文件或目录。返回的信息以 **stats** 对象的形式呈现。以下表格列出了在
    **stats** 对象上返回的信息：
- en: '![Table 2.1 – Table listing properties returned on the stats object](img/B19212_02_01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![表 2.1 – 列出在 stats 对象上返回的属性的表格](img/B19212_02_01.jpg)'
- en: Table 2.1 – Table listing properties returned on the stats object
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – 列出在 stats 对象上返回的属性的表格
- en: Important note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this recipe, we used only the synchronous File System APIs. For most of the
    **fs** APIs, there are both synchronous and asynchronous versions of each function.
    Refer to the *Working with files asynchronously* section of the *Working with
    files* recipe for more information about using asynchronous File System APIs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们只使用了同步的文件系统 API。对于大多数 **fs** API，每个函数都有同步和异步版本。有关使用异步文件系统 API 的更多信息，请参阅
    *Working with files* 配方的 *Working with files asynchronously* 部分。
- en: In the final steps of this recipe, we edited our **printMetadata** function
    to account for invalid file paths. We did this by wrapping the **statSync** function
    in a **try** / **catch** statement.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方的最后几个步骤中，我们编辑了我们的 **printMetadata** 函数，以处理无效的文件路径。我们通过将 **statSync** 函数包裹在
    **try** / **catch** 语句中来做到这一点。
- en: There’s more…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Next, we’ll look at how we can check file access and modify file permissions
    and how to examine a **symbolic** **link** ( **symlink** ).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何检查文件访问权限、修改文件权限以及如何检查一个 **符号链接**（**symlink**）。
- en: Checking file access
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查文件访问
- en: It is recommended that if you’re attempting to read, write, or edit a file,
    you follow the approach of handling the error if the file is not found, as we
    did in the recipe.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试读取、写入或编辑文件，建议您遵循我们在配方中使用的处理文件未找到错误的方法。
- en: 'However, if you simply wanted to check the existence of a file, you could use
    the **fs.access()** or **fs.accessSync()** APIs. Specifically, the **fs.access()**
    function tests the user’s permissions for accessing the file or directory passed
    to it. The function also allows an optional argument of **mode** to be passed
    to it, where you can request the function to do a specific access check using
    Node.js file access constants. A list of Node.js file access constants is available
    in the Node.js **fs** module API documentation: [https://nodejs.org/api/fs.html#fs_file_access_constants](https://nodejs.org/api/fs.html#fs_file_access_constants)
    . These enable you to check whether the Node.js process can read, write, or execute
    the file path provided.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您只想检查文件的存在，可以使用 **fs.access()** 或 **fs.accessSync()** API。具体来说，**fs.access()**
    函数测试用户访问传递给它的文件或目录的权限。该函数还允许传递一个可选的 **mode** 参数，您可以使用 Node.js 文件访问常量请求函数执行特定的访问检查。Node.js
    文件访问常量的列表可在 Node.js **fs** 模块 API 文档中找到：[https://nodejs.org/api/fs.html#fs_file_access_constants](https://nodejs.org/api/fs.html#fs_file_access_constants)
    。这些使您能够检查 Node.js 进程是否可以读取、写入或执行提供的文件路径。
- en: Important note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There is a legacy API that is now deprecated, called **fs.exists()** . It is
    not recommended you use this function. The reason for deprecation was that the
    method’s interface was found to be error-prone and could lead to accidental race
    conditions. The **fs.access()** or **fs.stat()** APIs should be used instead.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已弃用的旧版API，称为 **fs.exists()**。不建议您使用此函数。弃用此函数的原因是该方法的接口被发现存在错误，可能导致意外的竞争条件。应使用
    **fs.access()** 或 **fs.stat()** API。
- en: Modifying file permissions
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改文件权限
- en: The Node.js **fs** module provides APIs that can be used to alter the permissions
    on a given file. As with many of the other **fs** functions, there is both an
    asynchronous API, **chmod()** , and an equivalent synchronous API, **chmodSync()**
    . Both functions take a file path and **mode** as the first and second arguments,
    respectively. The **chmod()** function accepts a third parameter, which is the
    callback function to be executed upon completion.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js **fs** 模块提供了可以用来更改给定文件权限的API。与其他许多 **fs** 函数一样，存在异步API **chmod()** 和等效的同步API
    **chmodSync()**。两个函数分别接受文件路径和 **mode** 作为前两个参数。**chmod()** 函数接受第三个参数，即完成时要执行的回调函数。
- en: Important note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **chmod** command is used to change access permissions of file system objects
    on Unix and similar operating systems. If you’re unfamiliar with Unix file permissions,
    it is recommended you refer to the Unix manual pages ( [https://linux.die.net/man/1/chmod](https://linux.die.net/man/1/chmod)
    ).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**chmod** 命令用于更改Unix和类似操作系统上的文件系统对象的访问权限。如果您不熟悉Unix文件权限，建议您参考Unix手册页（[https://linux.die.net/man/1/chmod](https://linux.die.net/man/1/chmod)）。'
- en: 'The **mode** argument can be either in the form of a numeric bitmask using
    a series of constants provided by the **fs** module or a sequence of three octal
    digits. The constants that can be used to create a bitmask to define user permissions
    are defined in the Node.js API documentation: [https://nodejs.org/api/fs.html#fs_file_modes](https://nodejs.org/api/fs.html#fs_file_modes)
    .'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**mode** 参数可以是使用 **fs** 模块提供的系列常量构成的数字掩码形式，或者是一个由三个八进制数字组成的序列。用于创建定义用户权限的掩码的常量在Node.js
    API文档中定义：[https://nodejs.org/api/fs.html#fs_file_modes](https://nodejs.org/api/fs.html#fs_file_modes)。'
- en: 'Imagine that you have a file that currently has the following permissions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个文件，当前具有以下权限：
- en: Owner readable and writeable
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有者可读和可写
- en: Group readable
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 群组可读
- en: Readable only by all other users (sometimes referred to as world readable)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能由所有其他用户读取（有时被称为世界可读）
- en: 'If we wanted to additionally grant write access to those in the same group,
    we could use the following Node.js code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想额外授予同一组用户的写访问权限，可以使用以下Node.js代码：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, this code is quite verbose. Adding a complex series or permissions
    would require passing many constants to create a numeric bitmask. Alternatively,
    we can pass the **chmodSync()** function an octal representation of file permissions,
    as is commonplace when using the Unix **chmod** command on the command line.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此代码相当冗长。添加复杂的权限序列需要传递许多常量以创建数字掩码。或者，我们可以向 **chmodSync()** 函数传递文件权限的八进制表示，这在使用Unix命令行上的
    **chmod** 命令时很常见。
- en: 'We’re going to change the permissions using the equivalent of **chmod 664**
    from the command line, but via Node.js:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用命令行上的 **chmod 664** 的等效方式来更改权限，但通过Node.js实现：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Important note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Refer to [https://mason.gmu.edu/~montecin/UNIXpermiss.htm](https://mason.gmu.edu/~montecin/UNIXpermiss.htm)
    for more detailed information on how Unix permissions work.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[https://mason.gmu.edu/~montecin/UNIXpermiss.htm](https://mason.gmu.edu/~montecin/UNIXpermiss.htm)获取更多关于Unix权限如何工作的详细信息。
- en: '**Windows file permissions** : The Windows operating system does not have as
    refined file permissions as on Unix—it is only possible to denote a file as writeable
    or non-writeable.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows文件权限**：Windows操作系统上的文件权限不如Unix那样精细——只能表示文件为可写或不可写。'
- en: Inspecting symbolic links
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查符号链接
- en: A symlink is a special file that stores a reference to another file or directory.
    When the **stat()** or **statSync()** function from the *Fetching metadata* recipe
    is run on a symbolic link, the method will return information about the file the
    symbolic link is referencing rather than the symbolic link itself.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接是一个特殊的文件，它存储了对另一个文件或目录的引用。当在 *获取元数据* 菜单中的 **stat()** 或 **statSync()** 函数上运行符号链接时，该方法将返回符号链接所引用的文件的信息，而不是符号链接本身。
- en: 'The Node.js **fs** module does, however, provide methods named **lstat()**
    and **lstatSync()** that inspect the symbolic link itself. The following steps
    will demonstrate how you can use these methods to inspect a symbolic link that
    we will create:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Node.js **fs** 模块确实提供了名为 **lstat()** 和 **lstatSync()** 的方法，这些方法可以检查符号链接本身。以下步骤将演示您如何使用这些方法来检查我们将创建的符号链接：
- en: 'To create a symbolic link, you can use the following command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建符号链接，可以使用以下命令：
- en: '[PRE42]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, you can use the Node.js **Read-Eval-Print Loop** ( **REPL** ) to test the
    **lstatSync()** function. The Node.js REPL is an interactive shell we can pass
    statements to, and it will evaluate them and return the result to the user.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你可以使用 Node.js 的 **Read-Eval-Print Loop** ( **REPL** ) 来测试 **lstatSync()**
    函数。Node.js REPL 是一个交互式外壳，我们可以向其中传递语句，它将评估它们并将结果返回给用户。
- en: 'To enter the Node.js REPL, type **node** in your shell:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进入 Node.js REPL，请在您的壳中输入 **node**：
- en: '[PRE43]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can then type commands such as the following:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以输入以下命令：
- en: '[PRE44]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, you can try out the **lstatSync** command:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以尝试使用 **lstatSync** 命令：
- en: '[PRE45]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that we did not need to explicitly import the Node.js **fs** module. The
    REPL automatically loads the core (built-in) Node.js modules so that they are
    available to be used. The REPL is a useful tool for testing out commands without
    having to create files.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要显式导入 Node.js **fs** 模块。REPL 自动加载核心（内置）Node.js 模块，以便它们可供使用。REPL 是一个有用的工具，可以在不创建文件的情况下测试命令。
- en: See also
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Watching files* recipe in this chapter
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *监视文件* 示例
- en: Watching files
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视文件
- en: Node.js’s **fs** module provides functionality that enables you to watch files
    and track when files or directories are created, updated, or deleted.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的 **fs** 模块提供了功能，使您能够监视文件并跟踪文件或目录何时被创建、更新或删除。
- en: In this recipe, we’ll create a small program named **watch.js** that watches
    for changes in a file using the **watchFile()** API and then prints a message
    when a change has occurred.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个名为 **watch.js** 的小程序，它使用 **watchFile()** API 监视文件中的更改，并在发生更改时打印一条消息。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we’ll want to work inside a new directory. Create and change
    into a directory called **file-watching** :'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们希望在新的目录内工作。创建并切换到名为 **file-watching** 的目录：
- en: '[PRE46]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We need to also create a file that we can watch:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建一个我们可以监视的文件：
- en: '[PRE47]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a **watch.js** file:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **watch.js** 文件：
- en: '[PRE48]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we have created our directory and file, we can move on to the recipe.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的目录和文件，我们可以继续到食谱。
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We’re going to create a program that watches for changes in a given file –
    in this case, the **file.txt** file we created earlier. We will be using the **fs**
    module and, specifically, the **watchFile()** method to achieve this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个程序来监视给定文件中的更改——在这个例子中，是我们在前面创建的 **file.txt** 文件。我们将使用 **fs** 模块，特别是 **watchFile()**
    方法来实现这一点：
- en: 'To get started, import the required core Node.js modules:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，导入所需的 Node.js 核心模块：
- en: '[PRE49]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also need the program to access a file we created:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要程序访问我们创建的文件：
- en: '[PRE50]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we call the **fs.watchFile()** function:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们调用 **fs.watchFile()** 函数：
- en: '[PRE51]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, you can run the program in your shell with the following command:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令在您的壳中运行程序：
- en: '[PRE52]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In your editor, open **file.txt** and make some edits, saving between each
    one. You will notice that each time you save, a log entry appears in the Terminal
    where you’re running **watch.js** :'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开 **file.txt** 并进行一些编辑，每次编辑后保存。您会注意到每次保存时，在您运行 **watch.js** 的终端中都会出现一条日志条目：
- en: '[PRE53]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: While we’re here, we can make the timestamp more readable. To do this, we’re
    going to make use of the **Intl.DateTimeFormat** object. It is a built-in JavaScript
    utility to manipulate dates and times.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在这里时，我们可以使时间戳更易读。为此，我们将使用 **Intl.DateTimeFormat** 对象。这是一个内置的 JavaScript 工具，用于操作日期和时间。
- en: 'Add and change the following lines to format the date using **Intl.DateTimeFormat**
    :'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加并更改以下行以使用 **Intl.DateTimeFormat** 格式化日期：
- en: '[PRE54]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Rerun the program and make further edits to **file.txt** —observe that the
    time is now in a more readable format for your time zone:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行程序并对 **file.txt** 进行进一步编辑——注意现在时间以您时区更易读的格式显示：
- en: '[PRE55]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works…
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the recipe, we used the **watchFile()** function to watch for changes on
    a given file. The function accepts three arguments—a filename, an optional list
    of options, and a listener function. The **options** object can include the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了 **watchFile()** 函数来监视给定文件上的更改。该函数接受三个参数——一个文件名、一个可选的选项列表和一个监听函数。**options**
    对象可以包括以下内容：
- en: '**BigInt** : The **BigInt** object is a JavaScript object that allows you to
    represent larger numbers more reliably. This defaults to **false** ; when set
    to **true** , the numeric values returned from the object of **Stats** would be
    specified as **BigInt** .'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BigInt**：**BigInt**对象是一个JavaScript对象，允许你更可靠地表示更大的数字。默认值为**false**；当设置为**true**时，从**Stats**对象返回的数值将指定为**BigInt**。'
- en: '**persistent** : This value indicates whether the Node.js process should continue
    to run while files are still being watched. It defaults to **true** .'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**persistent**：此值表示Node.js进程是否应在文件仍在监视时继续运行。它默认设置为**true**。'
- en: '**interval** : The **interval** value controls how often the file should be
    polled for changes, measured in milliseconds. The default value is 5,007 milliseconds
    when no interval is supplied.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**interval**：**interval**值控制文件应该多久轮询一次以检查更改，以毫秒为单位。当未提供间隔时，默认值为5,007毫秒。'
- en: The listener function supplied to the **watchFile()** function will execute
    every time a change is detected. The listener function’s arguments, current and
    previous are both **Stats** objects, representing the current and previous state
    of the file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给**watchFile()**函数的监听函数会在检测到更改时执行。监听函数的参数current和previous都是**Stats**对象，代表文件的当前状态和之前状态。
- en: Our listener function passed to **watchFile()** is executed each time a change
    has been detected in the file being watched. Every time our **updated** function
    returns **true** , it logs the updated message to **stdout** .
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给**watchFile()**的监听函数会在被监视的文件检测到更改时执行。每次我们的**updated**函数返回**true**时，它都会将更新消息记录到**stdout**。
- en: The Node.js **fs** module provides another function, **watch()** , which watches
    for changes in files but can also watch for directories. This function differs
    from **watchFile()** as it utilizes the operating system’s underlying file system
    notification implementation rather than polling for changes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的**fs**模块提供了一个名为**watch()**的另一个函数，该函数可以监视文件的变化，也可以监视目录。这个函数与**watchFile()**不同，因为它利用操作系统的底层文件系统通知实现，而不是轮询更改。
- en: 'Although faster and more reliable than the **watchFile()** API, the Watch API
    is not consistent across various platforms. This is because the Watch API is dependent
    on the underlying operating system’s method of notifying file system changes.
    The Node.js API documentation goes into more detail about the limitations of the
    Watch API across different platforms: [https://nodejs.org/docs/latest/api/fs.html#fs_availability](https://nodejs.org/docs/latest/api/fs.html#fs_availability)
    .'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然比**watchFile()** API更快、更可靠，但Watch API在不同平台之间并不一致。这是因为Watch API依赖于底层操作系统通知文件系统更改的方法。Node.js
    API文档详细介绍了Watch API在不同平台上的限制：[https://nodejs.org/docs/latest/api/fs.html#fs_availability](https://nodejs.org/docs/latest/api/fs.html#fs_availability)。
- en: 'The **watch()** function similarly accepts three parameters—the filename, an
    array of options, and a listener function. The options that can be passed via
    the **options** parameter are as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**watch()**函数类似地接受三个参数——文件名、选项数组和一个监听函数。可以通过**options**参数传递的选项如下：'
- en: '**persistent** : The **persistent** option is a Boolean that indicates whether
    the Node.js process should continue to run while files are still being watched.
    By default, the **persistent** option is set to **true** .'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**persistent**：**persistent**选项是一个布尔值，表示Node.js进程是否应在文件仍在监视时继续运行。默认情况下，**persistent**选项设置为**true**。'
- en: '**recursive** : The **recursive** option is another Boolean that allows the
    user to specify whether changes in subdirectories should be watched – by default,
    this value is set to **false** . The **recursive** option is only supported on
    macOS and Windows operating systems.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**recursive**：**recursive**选项是另一个布尔值，允许用户指定是否应该监视子目录中的更改——默认值设置为**false**。**recursive**选项仅在macOS和Windows操作系统上受支持。'
- en: '**encoding** : The **encoding** option is used to specify which character encoding
    should be used for the filename specified—the default is **utf8** .'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**encoding**：**encoding**选项用于指定应使用哪种字符编码来指定文件名——默认为**utf8**。'
- en: '**Signal** : An **AbortSignal** object that can be used to cancel file watching.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Signal**：一个**AbortSignal**对象，可以用来取消文件监视。'
- en: 'The listener function that is passed to the **watch()** API is slightly different
    from the listener function passed to the **watchFile()** API. The arguments to
    the listener function are **eventType** and **trigger** , where **eventType**
    is either **change** or **rename** and **trigger** is the file that triggered
    an event. The following code represents a similar task to what we implemented
    in our recipe but using the Watch API:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给**watch()** API的监听函数与传递给**watchFile()** API的监听函数略有不同。监听函数的参数是**eventType**和**trigger**，其中**eventType**是**change**或**rename**，而**trigger**是触发事件的文件。以下代码表示与我们在食谱中实现的任务类似，但使用的是监视API：
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The final steps of the recipe cover usage of the comprehensive **Intl.DateTimeFormat**
    utility for manipulating dates and times. Refer to *MDN Web Docs* for a list of
    available formats and APIs on **Intl.DateTimeFormat** : [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat)
    .'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱的最后几步涵盖了使用综合的**Intl.DateTimeFormat**实用工具来操作日期和时间。有关可用格式和API的列表，请参阅*MDN Web文档*：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat)。
- en: Important note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **moment.js** library was once a go-to library for date manipulation and
    formatting in JavaScript. However, with the advancement of modern JavaScript,
    built-in functionalities such as **Intl.DateTimeFormat** offers similar capabilities
    natively. Additionally, **moment.js** has been put into maintenance mode by its
    maintainers, meaning no new features will be added. Coupled with concerns about
    its bundle size, many developers are finding **moment.js** no longer necessary
    for their projects and are instead using built-in functionalities or more modern
    alternative libraries.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**moment.js**库曾经是JavaScript中日期操作和格式化的首选库。然而，随着现代JavaScript的发展，内置功能如**Intl.DateTimeFormat**提供了类似的原生功能。此外，**moment.js**的维护者已经将其置于维护模式，这意味着不会添加新功能。考虑到其包大小的问题，许多开发者发现**moment.js**对于他们的项目来说不再是必需的，而是使用内置功能或更现代的替代库。'
- en: There’s more…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The **nodemon** utility is a popular **npm** module utility for Node.js that
    automatically restarts your application when it detects code change. Instead of
    manually stopping and starting the server after each code change, **nodemon**
    handles it automatically.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**nodemon**实用工具是Node.js中一个流行的**npm**模块实用工具，当它检测到代码更改时会自动重启您的应用程序。您无需在每次代码更改后手动停止和启动服务器，**nodemon**会自动处理。'
- en: 'Typical installation and usage of **nodemon** are as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**nodemon**的典型安装和使用方法如下：'
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'More recent versions of Node.js (later than v18.11.0) have a built-in watch-mode
    capability. To enable watch mode, you supply the **--watch** command-line process
    flag:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 更新版本的Node.js（晚于v18.11.0）具有内置的监视模式功能。要启用监视模式，您需要提供**--watch**命令行进程标志：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: While in watch mode, modifications to the observed files trigger a Node.js process
    restart. By default, the built-in watch mode will monitor the main entry file
    and any modules that are required or imported.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在监视模式下，对观察文件的修改将触发Node.js进程的重启。默认情况下，内置的监视模式将监视主入口文件以及任何所需的或导入的模块。
- en: 'It is also possible to specify the exact files you wish to watch with the **--watch-path**
    command-line process flag:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用**--watch-path**命令行进程标志指定要监视的确切文件：
- en: '[PRE59]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'More information can be found in the Node.js API documentation: [https://nodejs.org/dist/latest-v22.x/docs/api/cli.html#--watch](https://nodejs.org/dist/latest-v22.x/docs/api/cli.html#--watch)
    .'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在Node.js API文档中找到：[https://nodejs.org/dist/latest-v22.x/docs/api/cli.html#--watch](https://nodejs.org/dist/latest-v22.x/docs/api/cli.html#--watch)。
- en: See also
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adopting new JavaScript syntax in Node.js 22* recipe in [*Chapter 1*](B19212_01.xhtml#_idTextAnchor019)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第一章*](B19212_01.xhtml#_idTextAnchor019)中，关于*在Node.js 22中采用新JavaScript语法的食谱*。
