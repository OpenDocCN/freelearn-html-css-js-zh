- en: Chapter 6. Automated Web Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 自动化 Web 测试
- en: 'Having finished discussing the substantive techniques for testing Backbone.js
    applications, we will now look into various means of automating our test infrastructure.
    The ability to programmatically run our test collection enables new and exciting
    use cases beyond a single developer manually running a test driver page during
    development. In this chapter we will explore the following automation and development
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了测试 Backbone.js 应用程序的实际技术之后，我们现在将探讨自动化测试基础设施的各种方法。能够以编程方式运行我们的测试集合，使得在开发过程中单个开发者手动运行测试驱动器页面的单一用例之外，出现了新的和令人兴奋的用例。在本章中，我们将探讨以下自动化和开发主题：
- en: Surveying scenarios and motivations for automating our test infrastructure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查自动化测试基础设施的场景和动机
- en: Investigating different approaches for programmatically running a Backbone.js
    application test suite
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查以编程方式运行 Backbone.js 应用程序测试套件的多种方法
- en: Introducing PhantomJS and adapter tools for frontend testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍用于前端测试的 PhantomJS 和适配器工具
- en: Integrating our existing test infrastructure into the PhantomJS environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们现有的测试基础设施集成到 PhantomJS 环境中
- en: Concluding our discussion on the principles and practices of Backbone.js application
    testing with suggestions and resources for the next steps after finishing this
    book
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完成本书后，总结我们对 Backbone.js 应用程序测试原则和实践的讨论，并提供下一步的建议和资源
- en: The world of testing beyond humans and browsers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越人类和浏览器的测试世界
- en: Up to this point, our test development workflow has comprised writing test suites,
    adding them to a test driver page, and firing up the test page in a web browser
    on a development computer. However, test infrastructures can be used in far more
    scenarios than just manually running web reports. Examining the ensuing use cases,
    we will see how automatically running our test collection in arbitrary environments
    (for example, from a command line or build script, and possibly without a web
    browser) has enormous potential for the application development process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的测试开发工作流程包括编写测试套件，将它们添加到测试驱动器页面，并在开发计算机上的网络浏览器中启动测试页面。然而，测试基础设施可以用于比手动运行网络报告更多的场景。通过检查以下用例，我们将看到自动在任意环境中运行我们的测试集合（例如，从命令行或构建脚本，可能无需网络浏览器）在应用程序开发过程中具有巨大的潜力。
- en: Continuous integration
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: In collaborative software development, problems can arise when engineers develop
    code separately that they later merge into a common code base. Unforeseen interactions
    between the changes can cause integration errors, breaking the overall application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在协作软件开发中，当工程师分别开发代码，稍后将其合并到公共代码库中时，可能会出现问题。更改之间的意外交互可能导致集成错误，破坏整体应用程序。
- en: One mitigation approach for such errors is continuous integration, which relies
    extensively on automated testing. Continuous integration aggregates and tests
    application code to detect integration errors early and automatically. For an
    in-depth introduction on the topic, see *Continuous Integration* by *Martin Fowler*
    at [http://martinfowler.com/articles/continuousIntegration.html](http://martinfowler.com/articles/continuousIntegration.html).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类错误的一种缓解方法是持续集成，它大量依赖于自动化测试。持续集成将应用程序代码聚合并测试，以早期和自动地检测集成错误。关于这个主题的深入介绍，请参阅*马丁·福勒*的*《持续集成》*，可在[http://martinfowler.com/articles/continuousIntegration.html](http://martinfowler.com/articles/continuousIntegration.html)找到。
- en: The process of continuous integration is typically implemented using a dedicated
    server that incrementally gathers code changes, creates a clean application environment,
    runs build commands, and acts on the command outputs. For instance, let's say
    we have a Node.js application stored on GitHub. A continuous integration server
    could download code changes from GitHub, create a new build directory for the
    application, install package dependencies (for example, `npm install`), and run
    the tests (for example, `npm test`). If any of the tests fail, the server will
    notify the developer(s) responsible for the changes. Some prevalent continuous
    integration servers include Jenkins ([http://jenkins-ci.org/](http://jenkins-ci.org/))
    and Travis ([https://travis-ci.org/](https://travis-ci.org/)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成的过程通常是通过一个专用的服务器来实现的，该服务器逐步收集代码更改，创建一个干净的应用程序环境，运行构建命令，并对命令输出采取行动。例如，假设我们有一个存储在GitHub上的Node.js应用程序。一个持续集成服务器可以从GitHub下载代码更改，为应用程序创建一个新的构建目录，安装包依赖项（例如，`npm
    install`），并运行测试（例如，`npm test`）。如果任何测试失败，服务器将通知负责这些更改的开发者。一些流行的持续集成服务器包括Jenkins
    ([http://jenkins-ci.org/](http://jenkins-ci.org/)) 和Travis ([https://travis-ci.org/](https://travis-ci.org/))。
- en: Continuous deployment
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续部署
- en: A continuous deployment server is an enhancement of a continuous integration
    server that additionally deploys code to a live application environment (for example,
    production) if all the tests pass. It relies on automated tests to validate the
    entire application, so that code changes can be pushed out as fast as possible
    while retaining at least some semblance of quality assurance. The article *Why
    Continuous Deployment?* by *Eric Ries* at [http://www.startuplessonslearned.com/2009/06/why-continuous-deployment.html](http://www.startuplessonslearned.com/2009/06/why-continuous-deployment.html)
    is a good starting point for the motivations and practices behind continuous deployment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署服务器是持续集成服务器的增强版本，如果所有测试都通过，它还会将代码部署到实际的应用程序环境（例如，生产环境）。它依赖于自动化测试来验证整个应用程序，以便代码更改可以尽可能快地推出，同时至少保留一些质量保证的表象。《为什么持续部署？》这篇文章由*埃里克·莱斯*撰写，可在[http://www.startuplessonslearned.com/2009/06/why-continuous-deployment.html](http://www.startuplessonslearned.com/2009/06/why-continuous-deployment.html)找到，是了解持续部署背后的动机和实践的好起点。
- en: Other scenarios
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他场景
- en: Test automation enables many other useful applications. For example, development
    utilities called **watchers** or **guards** check code periodically for modifications
    and perform further actions when the files change. Watchers are regularly used
    on a development machine to automatically run tests and display alerts when code
    changes have broken one or more tests, so that developers can discover errors
    quickly and effortlessly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化使得许多其他有用的应用成为可能。例如，称为**监视器**或**守卫**的开发工具定期检查代码的修改，并在文件更改时执行进一步的操作。监视器通常在开发机器上使用，以自动运行测试并在代码更改导致一个或多个测试失败时显示警报，这样开发者可以快速且轻松地发现错误。
- en: '**Cross-browser testing** is another area made easier through automation. While
    a programmer can manually run a test collection on many different target browsers,
    this is often time consuming, error prone, and boring. Fortunately, there are
    testing tools that can programmatically run tests on a number of arbitrary web
    browsers without human interaction.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨浏览器测试**是自动化使工作变得更简单的另一个领域。虽然程序员可以手动在不同的目标浏览器上运行测试集合，但这通常既耗时又容易出错，而且很无聊。幸运的是，有一些测试工具可以在不进行人工交互的情况下，在多个任意浏览器上自动运行测试。'
- en: Automating browser environments
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化浏览器环境
- en: 'Having introduced some motivating use cases, we now turn to the nuts and bolts
    of automating our test infrastructure. We will cover the following techniques
    for programmatically driving our Backbone.js tests:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了一些激励性的用例之后，我们现在转向自动化测试基础设施的细节。我们将介绍以下用于程序化驱动Backbone.js测试的技术：
- en: Remote controlling tests in a real web browser
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在真实浏览器中远程控制测试
- en: Running tests in a browser simulation library
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器模拟库中运行测试
- en: Executing tests in a headless web browser environment
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无头浏览器环境中执行测试
- en: Combining the first three approaches
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合前三种方法
- en: Remote controlled web browsers
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程控制浏览器
- en: The most comprehensive automation technique is to remotely control a web browser.
    Remote control means that a program does what a human can do using a *real* web
    browser—opening the browser to a given page, clicking on links, filling in inputs,
    and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最全面的自动化技术是远程控制网络浏览器。远程控制意味着程序可以执行人类使用真实网络浏览器所能做的操作——打开浏览器到指定页面、点击链接、填写输入等。
- en: One of the most popular remote control frameworks is **Selenium** ([http://docs.seleniumhq.org/](http://docs.seleniumhq.org/)).
    Selenium provides many **web drivers**, which are programmatic adapters that hook
    into a real web browser and trigger actions through the normal user interface.
    Selenium supports a diverse array of environments, providing web drivers on different
    operating systems for various browsers, including Chrome, Safari, Firefox, and
    Internet Explorer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的远程控制框架之一是 **Selenium** ([http://docs.seleniumhq.org/](http://docs.seleniumhq.org/))。Selenium
    提供了许多 **web drivers**，这些是程序适配器，可以连接到真实浏览器并触发通过正常用户界面的操作。Selenium 支持多种环境，为各种浏览器提供不同操作系统的
    web drivers，包括 Chrome、Safari、Firefox 和 Internet Explorer。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Selenium project encompasses more features and functionality than just browser
    remote control. Notably, Selenium can use other test execution approaches, including
    headless web tools such as PhantomJS. See the Selenium projects page ([http://docs.seleniumhq.org/projects/](http://docs.seleniumhq.org/projects/))
    and the web driver list ([http://docs.seleniumhq.org/projects/webdriver/](http://docs.seleniumhq.org/projects/webdriver/))
    for starting points and additional information.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 项目包含的功能和功能远不止浏览器远程控制。值得注意的是，Selenium 可以使用其他测试执行方法，包括无头网络工具如 PhantomJS。有关起点和更多信息，请参阅
    Selenium 项目页面 ([http://docs.seleniumhq.org/projects/](http://docs.seleniumhq.org/projects/))
    和 web driver 列表 ([http://docs.seleniumhq.org/projects/webdriver/](http://docs.seleniumhq.org/projects/webdriver/))。
- en: 'Automating our test infrastructure with a remote control tool such as Selenium
    involves two basic steps: open and run the test driver page and then, infer whether
    or not the tests have passed. As an example, we could write a Selenium script
    that opens a browser window to the Notes application test driver page `notes/test/test.html`
    in the code samples. The Selenium script could then scrape the report page HTML
    to check for a telltale string such as `failures: 0` in the DOM and terminate
    the script with an appropriate success/failure exit code.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '使用像 Selenium 这样的远程控制工具自动化我们的测试基础设施涉及两个基本步骤：打开并运行测试驱动程序页面，然后推断测试是否通过。例如，我们可以在代码示例中编写一个
    Selenium 脚本，打开浏览器窗口到笔记应用程序测试驱动程序页面 `notes/test/test.html`。然后，Selenium 脚本可以抓取报告页面
    HTML 以检查 DOM 中的明显字符串，如 `failures: 0`，并使用适当的成功/失败退出代码终止脚本。'
- en: Thus, remote-controlled tools such as Selenium are quite powerful because they
    can do anything a real browser can do, just automatically. And, with a cross-platform
    compatible tool such as Selenium, we can run tests on nearly all modern browser/operating
    system combinations from a single script.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像 Selenium 这样的远程控制工具非常强大，因为它们可以自动执行任何真实浏览器可以执行的操作。而且，使用像 Selenium 这样的跨平台兼容工具，我们可以从单个脚本中运行几乎所有现代浏览器/操作系统组合的测试。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Hosted test automation providers**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**托管测试自动化提供商**'
- en: Capitalizing on Selenium's broad test environment support, vendors now offer
    services that allow users to upload a Selenium test script, designate a desired
    array of operating system/browser configurations, and have the service run and
    return test reports. One such vendor is Sauce Labs ([https://saucelabs.com/](https://saucelabs.com/)),
    which runs user scripts on virtual machines with various Selenium-supported test
    environments. Hosted services such as these are often the quickest way to get
    broad browser compatibility coverage with minimum developer effort.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Selenium 广泛的测试环境支持，供应商现在提供允许用户上传 Selenium 测试脚本、指定所需的操作系统/浏览器配置数组，并让服务运行并返回测试报告的服务。这样的供应商之一是
    Sauce Labs ([https://saucelabs.com/](https://saucelabs.com/))，它使用各种 Selenium 支持的测试环境在虚拟机上运行用户脚本。此类托管服务通常是获得广泛浏览器兼容性覆盖的最快方式，且开发者工作量最小。
- en: The remote controlled approach does have a few downsides, the first of which
    is that the test tools can be relatively slow. Scripts can take seconds or even
    minutes to hook into a target browser and run a test driver page. Additionally,
    these frameworks require a real web browser and a desktop windowing system. This
    can be an issue for build/continuous integrations that are headless, meaning they
    have no graphical user interface or window environment installed by default.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 远程控制方法确实有一些缺点，其中第一个是测试工具可能相对较慢。脚本可能需要几秒钟甚至几分钟才能连接到目标浏览器并运行测试驱动页面。此外，这些框架需要真实网络浏览器和桌面窗口化系统。这对于无头构建/持续集成来说可能是一个问题，这意味着它们默认没有安装图形用户界面或窗口环境。
- en: Simulated browser environments
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟的浏览器环境
- en: An alternative automation approach is to replace the web browser with a test-friendly
    simulation of the browser environment and state. Typically, browser simulation
    libraries provide implementations of the JavaScript API within a browser such
    as DOM objects (for example, `window` and `document`), CSS selectors, and JSON
    interfaces.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种自动化方法是使用测试友好的浏览器环境和状态的模拟来替换网络浏览器。通常，浏览器模拟库在浏览器内部提供JavaScript API的实现，例如DOM对象（例如，`window`和`document`）、CSS选择器和JSON接口。
- en: '**JSDom** ([https://github.com/tmpvar/jsdom](https://github.com/tmpvar/jsdom))
    is a prevalent simulation library that provides a fairly complete browser environment.
    JSDom is written in JavaScript and packaged as a Node.js module. Because Node.js
    can be easily scripted, JSDom offers us a good starting point for integrating
    and running Backbone.js tests from the command line.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSDom** ([https://github.com/tmpvar/jsdom](https://github.com/tmpvar/jsdom))
    是一个流行的模拟库，它提供了一个相当完整的浏览器环境。JSDom是用JavaScript编写的，并打包为Node.js模块。由于Node.js可以轻松脚本化，JSDom为我们提供了一个从命令行集成和运行Backbone.js测试的良好起点。'
- en: Test automation is such a common use case that several test-friendly libraries
    have been written around JSDom. One such library is Zombie.js ([http://zombie.labnotes.org/](http://zombie.labnotes.org/)),
    which provides convenient browser abstractions and integration with various test
    frameworks, including Mocha. Using a library such as Zombie.js, we could write
    a Node.js script that creates a fake browser simulation, navigates to our Backbone.js
    test driver page, and scrapes the test result HTML to check if any tests failed.
    For a more in-depth treatment of testing JavaScript web applications with Zombie.js
    and Mocha, see *Using Node.js for UI Testing* by *Pedro Teixeira* ([http://www.packtpub.com/testing-nodejs-web-uis/book](http://www.packtpub.com/testing-nodejs-web-uis/book)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化是一个如此常见的用例，以至于围绕JSDom编写了几个测试友好的库。其中一个这样的库是Zombie.js ([http://zombie.labnotes.org/](http://zombie.labnotes.org/))，它提供了方便的浏览器抽象和与各种测试框架的集成，包括Mocha。使用Zombie.js这样的库，我们可以编写一个Node.js脚本，创建一个模拟的浏览器模拟，导航到我们的Backbone.js测试驱动页面，并抓取测试结果的HTML以检查是否有测试失败。有关使用Zombie.js和Mocha测试JavaScript网络应用的更深入介绍，请参阅Pedro
    Teixeira的《Using Node.js for UI Testing》([http://www.packtpub.com/testing-nodejs-web-uis/book](http://www.packtpub.com/testing-nodejs-web-uis/book))。
- en: Browser simulation libraries are fast because they run simulation code in the
    same underlying JavaScript engine as the test code without external dependencies
    (for example, on a real web browser executable). Simulation libraries are often
    quite extensible, as the simulation JavaScript code runs in the same process as
    the application and the tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器模拟库之所以运行速度快，是因为它们在与测试代码相同的底层JavaScript引擎中运行模拟代码，而不需要外部依赖（例如，在真实的网络浏览器可执行文件中）。由于模拟JavaScript代码与应用程序和测试在同一进程中运行，因此模拟库通常非常易于扩展。
- en: However, simulations suffer from a few key drawbacks. One primary issue is that
    simulations can deviate from the true environment in a real web browser. Complicated
    browser interactions such as heavily chained event triggers or complex DOM manipulations
    can potentially break the simulation or behave differently than a real browser.
    Additionally, a browser simulation library provides only a single browser environment
    implementation and thus cannot test the quirks and differences across various
    real web browsers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模拟存在一些关键缺点。一个主要问题是模拟可能会偏离真实网络浏览器的真实环境。复杂的浏览器交互，如高度链式的事件触发或复杂的DOM操作，可能会破坏模拟或与真实浏览器表现不同。此外，浏览器模拟库只提供单一浏览器环境实现，因此无法测试各种真实浏览器之间的怪癖和差异。
- en: Headless web browsers
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无头网络浏览器
- en: Between remote controlled browsers and simulation libraries are headless web
    browsers. A headless browser takes a real web browser and gets rid of the user
    interface, leaving only the JavaScript engine and environment. What remains is
    a command line tool that can navigate to web pages, execute JavaScript within
    the browser environment, and communicate through non-graphical interfaces such
    as alerts and console logging.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程控制浏览器和模拟库之间是无头网络浏览器。无头浏览器取一个真实的网络浏览器，去掉用户界面，只留下 JavaScript 引擎和环境。剩下的就是一个可以导航到网页、在浏览器环境中执行
    JavaScript 以及通过非图形界面（如警报和控制台日志）进行通信的命令行工具。
- en: One of the most popular headless toolkits is PhantomJS ([http://phantomjs.org/](http://phantomjs.org/)),
    which is based on the **WebKit** open source browser ([http://www.webkit.org/](http://www.webkit.org/))
    that powers browsers such as Safari. PhantomJS enhances WebKit with scripting
    support and a JavaScript API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的无头工具包之一是 PhantomJS ([http://phantomjs.org/](http://phantomjs.org/))，它基于为
    Safari 等浏览器提供动力的 **WebKit** 开源浏览器 ([http://www.webkit.org/](http://www.webkit.org/))。PhantomJS
    通过脚本支持和 JavaScript API 丰富了 WebKit。
- en: Integrating Backbone.js application tests with a headless browser is analogous
    to configuring a remote-controlled browser. Conveniently, PhantomJS ships with
    native support for a wide array of test infrastructures and offers third-party
    adapters for many others. See [https://github.com/ariya/phantomjs/wiki/Headless-Testing](https://github.com/ariya/phantomjs/wiki/Headless-Testing)
    for more test support details.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Backbone.js 应用程序测试与无头浏览器集成类似于配置远程控制浏览器。方便的是，PhantomJS 内置了对广泛测试基础设施的原生支持，并为许多其他测试提供了第三方适配器。有关更多测试支持细节，请参阅[https://github.com/ariya/phantomjs/wiki/Headless-Testing](https://github.com/ariya/phantomjs/wiki/Headless-Testing)。
- en: 'Headless web tools have a mix of some of the best features of the previous
    automation approaches, including the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无头网络工具结合了之前自动化方法的一些最佳特性，包括以下内容：
- en: Headless JavaScript engines are often faster than remote control frameworks
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头 JavaScript 引擎通常比远程控制框架更快
- en: The browser environment is *real*, which avoids some of the API and correctness
    issues potentially found in browser simulations
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器环境是**真实**的，这避免了在浏览器模拟中可能发现的某些 API 和正确性问题
- en: Headless frameworks are usually easy to install and can be run on servers without
    a windowing environment
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头框架通常易于安装，可以在没有窗口环境的服务器上运行
- en: At the same time, headless browsers incur some performance penalties from starting
    up and running the browser engine. They also forgo cross-browser capabilities,
    because headless tools are tied to a specific web browser engine implementation.
    Considering the overall advantages and disadvantages, headless frameworks provide
    a good compromise between the many mutually exclusive automation features.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，无头浏览器在启动和运行浏览器引擎时会带来一些性能损失。它们也放弃了跨浏览器功能，因为无头工具绑定到特定的网络浏览器引擎实现。考虑到整体优缺点，无头框架在许多相互排斥的自动化功能之间提供了一个良好的折衷方案。
- en: Multiple environment aggregators
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多环境聚合器
- en: 'Capitalizing on the benefits of various approaches, many frameworks aggregate
    different automation schemes into a single package. For example, the following
    test frameworks can programmatically drive tests in major web browsers *and* PhantomJS:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 利用各种方法的好处，许多框架将不同的自动化方案聚合到一个单一包中。例如，以下测试框架可以编程驱动主要网络浏览器和 PhantomJS 的测试：
- en: '**Testem** ([https://github.com/airportyh/testem](https://github.com/airportyh/testem))'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Testem** ([https://github.com/airportyh/testem](https://github.com/airportyh/testem))'
- en: '**Karma** ([http://karma-runner.github.io/](http://karma-runner.github.io/))'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**因果律** ([http://karma-runner.github.io/](http://karma-runner.github.io/))'
- en: Aggregation frameworks are desirable because they allow a single test collection
    to be reused in different automation environments, although some tools are more
    difficult to set up and maintain than a single automation tool.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合框架是可取的，因为它们允许单个测试集合在不同的自动化环境中重复使用，尽管一些工具的设置和维护比单个自动化工具更困难。
- en: Headless testing with PhantomJS
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PhantomJS 进行无头测试
- en: As a concrete automation example, we will adapt our existing Backbone.js test
    infrastructure to use PhantomJS. PhantomJS offers an amenable set of features
    and capabilities for Backbone.js testing—it is fast, relatively easy to set up,
    and provides a real (headless) browser. As a practical matter, larger Backbone.js
    applications often require a real browser engine to function properly, particularly
    applications that exercise the murkier and more complicated parts of the browser
    environment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具体的自动化示例，我们将调整现有的 Backbone.js 测试基础设施以使用 PhantomJS。PhantomJS 为 Backbone.js
    测试提供了一套易于使用的特性和功能——它运行速度快，相对容易设置，并提供了一个真实的（无头）浏览器。从实际的角度来看，较大的 Backbone.js 应用程序通常需要一个真实的浏览器引擎才能正常工作，尤其是那些测试浏览器环境中的模糊和复杂部分的程序。
- en: Installing PhantomJS and the supporting tools
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 PhantomJS 和支持工具
- en: To get up and running with PhantomJS, let's start by installing the toolkit
    as per the instructions at [http://phantomjs.org/download.html](http://phantomjs.org/download.html).
    Note that the installation procedures are operating system dependent, with packages
    for Windows, Mac OS X, and Linux. Alternatively, PhantomJS can be installed directly
    with NPM using the `phantomjs` Node.js wrapper ([https://github.com/Obvious/phantomjs](https://github.com/Obvious/phantomjs)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 PhantomJS 启动，请按照 [http://phantomjs.org/download.html](http://phantomjs.org/download.html)
    上的说明安装工具包。请注意，安装过程取决于操作系统，有适用于 Windows、Mac OS X 和 Linux 的软件包。或者，可以直接使用 NPM 通过
    `phantomjs` Node.js 包装器安装 PhantomJS ([https://github.com/Obvious/phantomjs](https://github.com/Obvious/phantomjs))。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We provide command line examples in this section from a UNIX-like operating
    system such as Linux and Mac OS X. At the same time, PhantomJS and Node.js have
    first class support on Windows, so the ensuing examples should be mostly analogous
    to what will work on Windows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中提供了来自类似 UNIX 的操作系统（如 Linux 和 Mac OS X）的命令行示例。同时，PhantomJS 和 Node.js 在
    Windows 上也有第一级支持，因此接下来的示例应该与 Windows 上可以运行的内容大致相似。
- en: 'Once installation is complete, you can verify that the PhantomJS binary is
    available:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以验证 PhantomJS 二进制文件是否可用：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With PhantomJS in place, we next turn to the Mocha-PhantomJS bridge library.
    Mocha-PhantomJS uses PhantomJS to run a Mocha test driver page and transform the
    test results into formatted command line output. The library throws proper errors
    on test failures, making it quite useful for scripting. See the online documentation
    at [http://metaskills.net/mocha-phantomjs/](http://metaskills.net/mocha-phantomjs/)
    for additional capabilities and details.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PhantomJS 安装完成后，我们接下来转向 Mocha-PhantomJS 桥接库。Mocha-PhantomJS 使用 PhantomJS 运行
    Mocha 测试驱动页面，并将测试结果转换为格式化的命令行输出。该库在测试失败时抛出适当的错误，这使得它对于脚本编写非常有用。有关附加功能和详细信息的在线文档请参阅
    [http://metaskills.net/mocha-phantomjs/](http://metaskills.net/mocha-phantomjs/)。
- en: 'To install Mocha-PhantomJS, you need the Node.js framework, which can be obtained
    by following the instructions at [http://nodejs.org/download/](http://nodejs.org/download/).
    A modern Node.js installation includes the NPM package manager tool used for Mocha-PhantomJS.
    We can confirm that Node.js and the package manager are correctly installed with
    the following commands:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Mocha-PhantomJS，您需要 Node.js 框架，可以通过查阅 [http://nodejs.org/download/](http://nodejs.org/download/)
    上的说明来获取。现代 Node.js 安装包括用于 Mocha-PhantomJS 的 NPM 包管理器工具。我们可以使用以下命令来确认 Node.js 和包管理器已正确安装：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, install Mocha-PhantomJS with the global NPM flag (`-g`) to make the `mocha-phantomjs`
    binary available anywhere in a shell:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用全局 NPM 标志（`-g`）安装 Mocha-PhantomJS，以便在 shell 的任何位置都可以使用 `mocha-phantomjs`
    二进制文件：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After NPM finishes the installation, check whether Mocha-PhantomJS is available
    with the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NPM 完成安装后，使用以下命令检查 Mocha-PhantomJS 是否可用：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running Backbone.js tests with PhantomJS
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PhantomJS 运行 Backbone.js 测试
- en: 'With the necessary tools installed, we can now adapt our Backbone.js test infrastructure
    to run against PhantomJS. Mocha-PhantomJS provides a replacement proxy object,
    `mochaPhantomJS`, to control Mocha tests and reports. We just need to replace
    the real `mocha` object where `mocha.run()` is normally called in the test driver
    web page. Inserting the following code snippet into the test driver page will
    allow Mocha to run *both* in a real browser and with PhantomJS:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了必要的工具后，我们现在可以将 Backbone.js 测试基础设施调整以运行 PhantomJS。Mocha-PhantomJS 提供了一个替换代理对象
    `mochaPhantomJS`，用于控制 Mocha 测试和报告。我们只需在测试驱动网页中替换通常调用 `mocha.run()` 的真实 `mocha`
    对象。将以下代码片段插入测试驱动页面将允许 Mocha 在真实浏览器和 PhantomJS 中同时运行：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we have modified the test driver page with the `(window.mochaPhantomJS
    || mocha).run()` function call, we can execute the page tests with Mocha-PhantomJS.
    For example, if we modify the Notes application test driver file `chapters/05/test/test.html`
    from the previous chapter with the `mochaPhantomJS` change, we can run the file
    and generate the following command line report:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们修改了测试驱动页面中的 `(window.mochaPhantomJS || mocha).run()` 函数调用，我们就可以使用 Mocha-PhantomJS
    执行页面测试。例如，如果我们修改了上一章中的 Notes 应用程序测试驱动文件 `chapters/05/test/test.html` 中的 `mochaPhantomJS`
    变更，我们就可以运行该文件并生成以下命令行报告：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Reviewing this report, we can see that all of our tests passed, and that the
    PhantomJS test run was quite fast, clocking in at 39 milliseconds. With these
    modest test driver web page changes, we can run nearly any test web page from
    the command line or a build script using PhantomJS.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 审查这份报告，我们可以看到所有测试都通过了，并且 PhantomJS 测试运行相当快，耗时 39 毫秒。通过这些微小的测试驱动网页更改，我们可以从命令行或构建脚本中使用
    PhantomJS 运行几乎任何测试网页。
- en: Automating tests in the code samples
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代码示例中自动化测试
- en: Putting these suggested principles into practice, nearly all of the test code
    samples presented in this book are scripted to run from the command line under
    PhantomJS. If you review the downloadable code samples repository, you will notice
    that all of the chapter and application test pages actually use the `(window.mochaPhantomJS
    || mocha).run()` function call instead of a raw `mocha.run()` statement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些建议的原则付诸实践，本书中展示的大多数测试代码示例都被脚本化为在 PhantomJS 下从命令行运行。如果您审查可下载的代码示例仓库，您会注意到所有章节和应用程序测试页面实际上都使用了
    `(window.mochaPhantomJS || mocha).run()` 函数调用，而不是原始的 `mocha.run()` 语句。
- en: 'The integration of PhantomJS into the code samples provides a practical starting
    point for some of the automated testing use cases that we discussed earlier in
    this chapter. Specifically, the examples implement the following automation scenarios:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将 PhantomJS 集成到代码示例中为我们在本章前面讨论的一些自动化测试用例提供了一个实用的起点。具体来说，以下示例实现了以下自动化场景：
- en: '**Command line tests**: The code samples contain a Node.js NPM `package.json`
    file with script commands that can run chapter and application test driver pages
    with PhantomJS.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行测试**：代码示例包含一个 Node.js NPM `package.json` 文件，其中包含可以运行章节和应用程序测试驱动页面的脚本命令，使用
    PhantomJS。'
- en: '**Continuous integration server**: The GitHub repository for the code samples
    ([https://github.com/ryan-roemer/backbone-testing/](https://github.com/ryan-roemer/backbone-testing/))
    uses the Travis continuous integration server for automated failure alerts. Travis
    is configured to run all of the example tests with PhantomJS on every code change.
    Travis is a particularly good choice for a test infrastructure such as the one
    presented in this book because its build environment already contains PhantomJS
    and it is quite amenable to Node.js and NPM modules such as Mocha-PhantomJS. To
    see all of this in action, you can navigate a browser to [https://travis-ci.org/ryan-roemer/backbone-testing](https://travis-ci.org/ryan-roemer/backbone-testing)
    at any time to check out the live build status for all of the code we have discussed
    in this book. (Hopefully you will find that all of our tests are passing!)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成服务器**：代码示例的 GitHub 仓库（[https://github.com/ryan-roemer/backbone-testing/](https://github.com/ryan-roemer/backbone-testing/））使用
    Travis 持续集成服务器进行自动化的失败警报。Travis 被配置为在每次代码更改时使用 PhantomJS 运行所有示例测试。对于本书中展示的测试基础设施，Travis
    是一个特别好的选择，因为它的构建环境已经包含了 PhantomJS，并且对 Node.js 和 NPM 模块（如 Mocha-PhantomJS）非常友好。要查看所有这些功能在实际中的运行情况，您可以在任何时间通过浏览器导航到
    [https://travis-ci.org/ryan-roemer/backbone-testing](https://travis-ci.org/ryan-roemer/backbone-testing)
    来检查我们在这本书中讨论的所有代码的实时构建状态。（希望您会发现我们的所有测试都通过了！）'
- en: Parting thoughts, next steps, and future ideas
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离别时的思考，下一步行动和未来想法
- en: We are now at the end of our journey through the fundamentals of testing Backbone.js
    applications with Mocha, Chai, and Sinon.JS. We have explored the background,
    configuration, and use of each of these test frameworks and tried out a number
    of complementary tools and helpers. We have reviewed Backbone.js application development,
    specific component testing goals, and written test collections around a full Backbone.js
    application. So, what comes next?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了使用 Mocha、Chai 和 Sinon.JS 测试 Backbone.js 应用程序基础知识的旅程。我们探讨了每个测试框架的背景、配置和使用，并尝试了多种互补的工具和助手。我们回顾了
    Backbone.js 应用程序开发、特定组件测试目标，并在一个完整的 Backbone.js 应用程序周围编写了测试集合。那么，接下来是什么？
- en: 'Our first suggestion is to review the online documentation for the various
    testing technologies. The official APIs and guides for all of the frameworks we
    use in the book are quite good and can provide starting points for more complicated
    test scenarios that may arise in real-world Backbone.js application development.
    As a refresher, the documentation sites for our core test stack include the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一建议是回顾各种测试技术的在线文档。书中使用的所有框架的官方API和指南都相当不错，可以为实际中可能出现的更复杂的测试场景提供起点。作为一个复习，我们核心测试堆栈的文档网站包括以下内容：
- en: '**Mocha**: [http://visionmedia.github.io/mocha/](http://visionmedia.github.io/mocha/)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mocha**：[http://visionmedia.github.io/mocha/](http://visionmedia.github.io/mocha/)'
- en: '**Chai**: [http://chaijs.com/](http://chaijs.com/)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chai**：[http://chaijs.com/](http://chaijs.com/)'
- en: '**Sinon.JS**: [http://sinonjs.org/](http://sinonjs.org/)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sinon.JS**：[http://sinonjs.org/](http://sinonjs.org/)'
- en: After the framework documentation, you can review the article, blog, and book
    suggestions that we have provided throughout this book. In particular, the references
    in [Chapter 2](ch02.html "Chapter 2. Creating a Backbone.js Application Test Plan"),
    *Creating a Backbone.js Application Test Plan* on general test methodology and
    Backbone.js testing are great resources for those seeking a broader background
    in the software development and testing techniques appropriate for larger-scale
    Backbone.js applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架文档之后，您可以回顾本书中提供的文章、博客和书籍建议。特别是，[第2章](ch02.html "第2章。创建Backbone.js应用程序测试计划")中关于一般测试方法和Backbone.js测试的*创建Backbone.js应用程序测试计划*参考，对于寻求更广泛背景的软件开发和测试技术的读者来说是非常好的资源。
- en: 'Finally, we suggest that you download and install the book code samples. These
    samples are essentially the practical application of the principles we have covered
    in this book, with useful applications, tests, and files put together in a single
    package. Additionally, they provide examples of more testing and automation techniques
    for you to explore on your own, including the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们建议您下载并安装本书的代码示例。这些示例基本上是我们在这本书中讨论的原理的实际应用，将有用的应用程序、测试和文件组合成一个单一包。此外，它们还提供了更多测试和自动化技术的示例，供您自行探索，包括以下内容：
- en: '**Style checking**: JavaScript style checkers automatically analyze source
    files to find language or convention errors. Checkers are invaluable during software
    development, often finding programming errors early on and in places that tests
    can miss. Additionally, style checkers can enforce consistent coding styles for
    all members of a team working on a single application. The code samples use JSHint
    ([http://www.jshint.com/](http://www.jshint.com/)) to check all of the application
    and test examples that we have discussed in this book. You can inspect the `package.json`
    file in the code samples to see our JSHint usage in the script commands `style`,
    `style-server`, and `style-client`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样式检查**：JavaScript样式检查器会自动分析源文件以查找语言或约定错误。在软件开发过程中，检查器非常有价值，通常能早期发现编程错误，并在测试可能遗漏的地方。此外，样式检查器可以强制执行单个应用程序团队成员的一致编码风格。代码示例使用JSHint（[http://www.jshint.com/](http://www.jshint.com/））来检查本书中讨论的所有应用程序和测试示例。您可以在代码示例中的`package.json`文件中查看我们的JSHint使用情况，包括脚本命令中的`style`、`style-server`和`style-client`。'
- en: '**Code coverage**: Code coverage is a technique to quantify how much of an
    application is actually exercised by tests. Coverage tools run behind the scenes
    during tests, recording which application code lines are executed, and provide
    a report that measures the lines covered in each application file. The code samples
    provide a test driver page for the Notes application at `notes/test/coverage.html`
    that uses **Blanket.js** ([http://blanketjs.org/](http://blanketjs.org/)) to provide
    a coverage report. You can run the Notes test and the coverage report online at
    [http://backbone-testing.com/notes/test/coverage.html](http://backbone-testing.com/notes/test/coverage.html).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码覆盖率**：代码覆盖率是一种量化应用程序实际被测试覆盖程度的技术。覆盖率工具在测试过程中在幕后运行，记录哪些应用程序代码行被执行，并提供一个报告，测量每个应用程序文件中覆盖的行数。代码示例为Notes应用程序提供了一个测试驱动页面，位于`notes/test/coverage.html`，使用**Blanket.js**（[http://blanketjs.org/](http://blanketjs.org/））提供覆盖率报告。您可以在[http://backbone-testing.com/notes/test/coverage.html](http://backbone-testing.com/notes/test/coverage.html)在线运行Notes测试和覆盖率报告。'
- en: The rest is left up to you. While we are at the end of the road for this book,
    the world of testing will keep pushing forward in new and interesting ways. We
    bid you good luck in your continued learning and discovery of more testing tools,
    methods, and topics for Backbone.js application development.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的部分就留给你了。虽然我们已到达这本书的终点，但测试的世界将继续以新的和有趣的方式不断前进。我们祝愿你在继续学习和探索更多 Backbone.js
    应用程序开发的测试工具、方法和主题时好运。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to remove manual browser interaction from
    the test process with an introduction to test automation approaches and use cases.
    We have investigated different tools to drive our tests from the command line
    and worked through a concrete test automation implementation using PhantomJS to
    drive our Backbone.js application tests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过介绍测试自动化方法和用例，从测试过程中移除手动浏览器交互。我们调查了不同的工具来从命令行驱动我们的测试，并通过使用 PhantomJS
    驱动我们的 Backbone.js 应用程序测试，完成了一个具体的测试自动化实现。
- en: Also, we left with a few final thoughts on the principles that we have developed
    throughout the course of this book and where to turn next. Hopefully, you now
    have the fundamentals and direction to create your own Backbone.js test infrastructures,
    apply good test-driven application development practices, and tackle your frontend
    tests with confidence.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还留下了一些关于我们在本书过程中发展出的原则以及下一步该何去何从的最终思考。希望你现在有了创建自己的 Backbone.js 测试基础设施、应用良好的测试驱动开发实践以及自信地应对前端测试的基础和方向。
