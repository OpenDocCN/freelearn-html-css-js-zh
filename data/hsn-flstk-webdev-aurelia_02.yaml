- en: Styling the User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面样式化
- en: 'We now have our running Aurelia application and know all the basic principles
    of JavaScript programming. Our Hello World! message appears on screen, but don''t
    you think it is a little simple and static? In this chapter, we will explore how
    to add style to our application using modern tools such as SASS and LESS. Also,
    we will talk about the most important styling libraries used nowadays such as
    Bootstrap, Semantic UI, and Material Design. Finally, with all this previous learning,
    let''s make our application look cool, awesome, and attractive by configuring
    our project to use the Aurelia-Materialize plugin. Some of the tools we are going
    to use for this purpose are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个正在运行的爱瑞利亚（Aurelia）应用程序，并且了解了 JavaScript 编程的所有基本原理。我们的“Hello World！”消息出现在屏幕上，但你难道不觉得它有点简单和静态吗？在这一章中，我们将探讨如何使用现代工具如
    SASS 和 LESS 为我们的应用程序添加样式。我们还将讨论目前使用的一些最重要的样式库，如 Bootstrap、Semantic UI 和 Material
    Design。最后，利用我们之前的学习，让我们通过配置项目以使用 Aurelia-Materialize 插件，使我们的应用程序看起来酷炫、神奇且吸引人。我们将为此目的使用的一些工具包括：
- en: 'CSS preprocessors: SASS, LESS'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 预处理器：SASS，LESS
- en: 'Task automation tools: Gulp'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务自动化工具：Gulp
- en: 'CSS libraries: Bootstrap, Material Design, Semantic UI'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 库：Bootstrap，Material Design，Semantic UI
- en: Sounds exciting? We know yes, first we need to start talking about CSS, have
    you heard about it before? Don't worry, we will explain it in a brief but consistent
    way. Just CSS is not so awesome, so we will introduce you to some tools to make
    your style sheets awesome! Tools such SASS and LESS are very useful to these purposes,
    but we need to run some commands each time we need to use it, so we will also
    talk about task automation tools. No more manual repetitive commands! Finally,
    we don't need to reinvent the wheel. We have CSS libraries with different design
    templates, each one oriented to different concepts and purposes. Last, but not
    least, we will practice configuring our previously created application with all
    these awesome tools to make our development process more friendly and interesting. We
    are sure you will find this chapter really interesting and useful, so let's start!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很激动人心吗？我们知道是的，首先我们需要开始谈论 CSS，你之前听说过吗？不用担心，我们将以简明而一致的方式解释它。只是 CSS 并不那么神奇，所以我们将向你介绍一些工具，让你的样式表变得神奇！工具如
    SASS 和 LESS 对于这些目的非常有用，但每次我们需要使用它时，都需要运行一些命令，所以我们还将讨论任务自动化工具。不再需要手动重复命令！最后，我们不需要重新发明轮子。我们有
    CSS 库，包含不同的设计模板，每个模板都针对不同的概念和目的。最后但同样重要的是，我们将练习使用所有这些神奇的工具来配置我们之前创建的应用程序，使我们的开发过程更加友好和有趣。我们相信你一定会觉得这一章非常有趣和有用，所以让我们开始吧！
- en: Talking about CSS
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谈论 CSS
- en: Basically, CSS is a language structure that describes the style of some HTML
    file (can also be used for XML), defining how it should be displayed. This structure
    allows developers to manage the behavior on one or multiple web pages; any change
    performed on some CSS element will be reflected in all HTML elements linked to
    it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，CSS 是一种描述某些 HTML 文件（也可以用于 XML）样式的语言结构，定义了它应该如何显示。这种结构允许开发者管理一个或多个网页上的行为；对某些
    CSS 元素所做的任何更改都将反映在所有与之链接的 HTML 元素上。
- en: How does it work?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: 'CSS is based on rules. These rules are defined on `.css` files, called **style
    sheet**. Style sheets can be composed of one or more rules, applied to one HTML
    or XML document; the rule has two parts: selector and declaration:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 基于规则。这些规则定义在 `.css` 文件上，称为 **样式表**。样式表可以由一个或多个规则组成，应用于一个 HTML 或 XML 文档；规则有两个部分：选择器和声明：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `h4` element is the selector, and `{ color : red }` is the declaration.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`h4` 元素是选择器，`{ color : red }` 是声明。'
- en: The selector works as a link between the document and the style, specifying
    the elements that will be affected by that declaration. The statement is the part
    of the rule that states what the effect will be. In the previous example, selector
    `h4` indicates that all elements `h4` will be affected by the declaration stating
    that the color property will have the network value (red) for all elements `h4`
    of the document or documents that are linked to that style sheet.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器充当文档和样式之间的链接，指定将受到该声明影响的元素。语句是规则的一部分，说明了效果将是什么。在之前的例子中，选择器 `h4` 指示所有 `h4`
    元素都将受到声明的影响，该声明指出颜色属性将具有网络值（红色）对于文档或链接到该样式表的文档中的所有 `h4` 元素。
- en: We have three ways to link our style sheet with the HTML file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种方式将我们的样式表与 HTML 文件链接。
- en: 'The first option is to use the `<link>` element, on the `<head>` section of
    the HTML file. We just need to specify the absolute or relative path/URL of our
    style sheet to import into our web page:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用`<link>`元素，在HTML文件的`<head>`部分。我们只需要指定我们的样式表的绝对或相对路径/URL，以便将其导入我们的网页：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we can use the `<style>` element of the HTML file, generally in the `<head>`
    section too. It will be loaded when our file is called by the application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用HTML文件的`<style>`元素，通常也在`<head>`部分。它将在我们的文件被应用程序调用时加载：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, we can style the HTML directly using the `style` flag:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以直接使用`style`标志来样式化HTML：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ready to add some cool style to our application? This is just the beginning!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 准备给我们的应用程序添加一些酷炫的样式了吗？这仅仅是开始！
- en: Exploring SASS and LESS
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SASS和LESS
- en: We were reviewing some of the most basic CSS concepts, just to refresh our knowledge
    about the syntax and elements that compose a style sheet. In the real world, a
    style sheet could have more than 20 classes belonging to one HTML page; in extreme
    cases, these classes could be one hundred or more. In these cases, maybe you will
    find CSS syntax very primitive, not auto-explanatory, and incomplete in some cases.
    It's hard to implement inheritance on big systems and over time, it could become
    hard to maintain.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在复习一些最基础的CSS概念，只是为了刷新我们对构成样式表的语法和元素的认知。在现实世界中，一个样式表可能包含超过20个属于一个HTML页面的类；在极端情况下，这些类可能有一百个或更多。在这些情况下，你可能觉得CSS语法非常原始，不是自动解释的，在某些情况下还不完整。在大系统中实现继承很困难，而且随着时间的推移，维护起来也可能变得很困难。
- en: You can apply different approaches in order to write better CSS code, you can
    define different classes for each web page and then import them on one single
    CSS file, or maybe you could define parent classes and apply inheritance to child
    elements, but, in both cases, you will need to deal with maintainability problems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采用不同的方法来编写更好的CSS代码，你可以为每个网页定义不同的类，然后在一个单独的CSS文件中导入它们，或者你可能可以定义父类并将继承应用于子元素，但在两种情况下，你都需要处理可维护性问题。
- en: It's just for the reason that in order to write better CSS code, reuse code
    in an effective way, and add some extra approaches to make it more dynamic and
    understandable to any developer, CSS preprocessors become a very used tool for
    any developer, increasing their productivity and drastically reducing the amount
    of code in our style sheets.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为为了编写更好的CSS代码，有效地重用代码，并添加一些额外的方法使其更具动态性和对任何开发者都更容易理解，CSS预处理器成为任何开发者非常常用的工具，提高了他们的生产力，并极大地减少了我们样式表中的代码量。
- en: As we can expect, each CSS preprocessor has its own syntax, not too different
    and not hard to learn. All of them support classic CSS; the extra features will
    be explained as we move on using the two most used tools nowadays—SASS and LESS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，每个CSS预处理器都有自己的语法，不太不同，也不难学习。它们都支持经典CSS；额外功能将在我们继续使用目前最常用的两个工具——SASS和LESS时进行解释。
- en: Variables
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: Imagine that you are coding the web page for your company; you define the style
    sheet, and, of course, you have a font standard color for all titles, body text,
    and so on. You are writing your CSS classes and notes that you need to repeat
    the same color value on more than one class definition. Okay, it’s not so hard
    to copy and paste the same value across my entire file. You finally present that
    web page to your UX designer and oh, surprise! That red doesn’t have to be so
    deep. You need to correct to the new color code. What does that mean? You will
    need to dive into your style sheet and manually change each color value for the
    new one.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在为公司编写网页代码；你定义样式表，当然，你有一个字体标准颜色用于所有标题、正文等。你正在编写你的CSS类和注释，你需要重复相同的颜色值在多个类定义中。好吧，复制和粘贴整个文件中的相同值并不那么困难。你最终将那个网页展示给用户体验设计师，哦，惊喜！那个红色不需要那么深。你需要更正为新颜色代码。这意味着什么？你需要深入到你的样式表中，手动更改每个颜色值为新值。
- en: 'Like other programming languages, with CSS preprocessors, we can define variables
    to reuse them across our style sheet, avoid repeating the same value, and save
    time when we need to adjust or change that same value. Let’s look at an example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他编程语言一样，使用CSS预处理器，我们可以定义变量，以便在样式表中重复使用它们，避免重复相同的值，并在我们需要调整或更改该值时节省时间。让我们看一个例子：
- en: 'SASS syntax:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SASS语法：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, LESS syntax:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，LESS语法：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: They're pretty similar right? Let's explore other features!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它们非常相似，对吧？让我们探索其他功能！
- en: Nesting
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套
- en: 'Nesting elements in pure CSS are a bad deal. They are not friendly, are hard
    to read, and make us write and repeat a lot of code. Using a CSS preprocessor,
    you will provide a more friendly reading to any developer; the code auto explains
    what the CSS is doing and how the classes inherit from others. Look at the magic:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯 CSS 中嵌套元素是一个糟糕的交易。它们不友好，难以阅读，并让我们写很多重复的代码。使用 CSS 预处理器，你将为任何开发者提供更友好的阅读体验；代码自动解释
    CSS 正在做什么以及类是如何继承的。看看这个魔法：
- en: 'Using the SASS syntax:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SASS 语法：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the same in LESS:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LESS 中使用相同的方法：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One thing you need to know is that the browser does not directly interpret
    the SASS or LESS syntax. Do you need to convert your code to normal CSS syntax,
    how could you perform it? In the case of SASS, just type the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道的一件事是，浏览器不会直接解释 SASS 或 LESS 语法。你需要将你的代码转换为正常的 CSS 语法，那么该如何操作呢？在 SASS 的情况下，只需输入以下命令：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'They both export the same CSS output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都导出了相同的 CSS 输出：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, CSS preprocessors provide us a more friendly readability and
    quick understanding of what the code is doing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，CSS 预处理器为我们提供了更友好的可读性和快速理解代码正在做什么的能力。
- en: Extends
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'Sometimes, you define various classes that share a common definition. With
    the `@extend` feature, you can define a common class and make others extend from
    it instead of copying the same code in each one:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你定义了具有共同定义的各种类。使用 `@extend` 特性，你可以定义一个公共类，并让其他类从它扩展，而不是在每个类中复制相同的代码：
- en: 'SASS example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SASS 示例：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'LESS:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'LESS:'
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'CSS output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 输出：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If/else statements
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果/否则语句
- en: Oh, please, this is a really awesome feature! With this feature, you will be
    able to control the aspect of your page in a reactive way, based on determined
    conditions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，请，这真是一个非常酷的特性！有了这个特性，你将能够根据确定的条件以响应式的方式控制你页面的外观。
- en: 'SASS example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SASS 示例：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In LESS, the things are not similar. You need to use CSS guards:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LESS 中，情况并不相同。你需要使用 CSS 守卫：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These are not all the preprocessor features, but at this moment, they're enough
    to start working on our FIFA World Cup application!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是所有预处理器功能，但在这个时候，它们已经足够我们开始我们的 FIFA 世界杯应用程序的开发工作了！
- en: Automating tasks with Gulp
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gulp 自动化任务
- en: In the previous section, we learned how to use a CSS preprocessor and how to
    compile this SASS/LESS code into pure CSS to be interpreted by the browser. Note
    that each time you make a change, you will need to recompile the entire file,
    which means that you will need to type the same command and do the same task one,
    two, and several times. Yes, it's really boring. Fortunately, we have task automation
    tools. What does that mean? Some other tool will do the dirty job for us.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用 CSS 预处理器以及如何将 SASS/LESS 代码编译成纯 CSS 以供浏览器解释。请注意，每次你进行更改时，你都需要重新编译整个文件，这意味着你需要输入相同的命令并执行相同的工作一次、两次以及多次。是的，这真的很无聊。幸运的是，我们有任务自动化工具。这意味着什么？其他工具会为我们做这些脏活。
- en: Understanding Gulp
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Gulp
- en: 'Gulp is an open source JavaScript-based task runner, which uses code-over-configuration
    approach to define its tasks. These could be the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 是一个基于 JavaScript 的开源任务运行器，它使用代码覆盖配置的方法来定义其任务。这些可能包括以下内容：
- en: Bundling and minifying libraries and style sheets
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包和压缩库和样式表
- en: Refreshing your browser when you save a file
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存文件时刷新浏览器
- en: Quickly running unit tests
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速运行单元测试
- en: Running code analysis
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行代码分析
- en: LESS/SASS to CSS compilation
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LESS/SASS 到 CSS 编译
- en: Copying modified files to an output directory
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将修改后的文件复制到输出目录
- en: This tool uses the stream module of Node.js; first of all, we need to define
    what a stream is. It can be defined as a tool that allows data reading on one
    file and takes it to another place through pipes methods. The principal feature
    of Gulp.js is that it does not write files/folders into the hard drive, like other
    automation tools. That's a good feature, because we can configure several tasks,
    and it won't impact our computer performance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具使用了 Node.js 的流模块；首先，我们需要定义什么是流。它可以被定义为一个允许在一个文件上读取数据并通过管道方法将其传输到另一个地方的工具。Gulp.js
    的主要特性是它不会像其他自动化工具那样将文件/文件夹写入硬盘，这是一个很好的特性，因为我们可以配置多个任务，而不会影响我们的计算机性能。
- en: How does Gulp.js work?
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gulp.js 是如何工作的？
- en: As we said before, Gulp does not write anything on the hard drive. So, all operations
    are performed at the filesystem level. It observes the file preconfigured to check
    for any change (read) and after some edition, it will rewrite the compiled content
    linked with another file, or execute some preconfigured command.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，Gulp不会在硬盘上写入任何内容。因此，所有操作都是在文件系统级别执行的。它观察预先配置的文件以检查任何更改（读取），在编辑之后，它将重写与另一个文件链接的编译内容，或者执行一些预配置的命令。
- en: '![](img/359d4fd5-2e1c-4812-a4db-fe9c1731a2df.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/359d4fd5-2e1c-4812-a4db-fe9c1731a2df.png)'
- en: Installing Gulp
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Gulp
- en: 'Gulp is available on Windows, Linux, and macOS. The installation process is
    very similar in any of these operating systems, and the only difference is that
    you need to run the installation command as administrator on UNIX-based platforms.
    You need to have already installed Node and NPM on your PC. To install, type the
    next command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp在Windows、Linux和macOS上可用。在任何这些操作系统上的安装过程都非常相似，唯一的区别是在基于UNIX的平台你需要以管理员身份运行安装命令。你需要在你的PC上已经安装了Node和NPM。要安装，请输入以下命令：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s wait some minutes after the installation process finishes and then verify
    that all its okay:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在安装过程完成后等待几分钟，然后验证一切是否正常：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's all! We now have Gulp installed and ready to automate tasks!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！我们现在已经安装了Gulp并准备好自动化任务了！
- en: 'First of all, you need to ensure that your web project is already configured
    to import `npm` modules; if no `package.json` file exists, you must create one
    with the `npm init` command. To start working with Gulp, just type the following
    command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要确保你的Web项目已经配置好导入`npm`模块；如果不存在`package.json`文件，你必须使用`npm init`命令创建一个。要开始使用Gulp，只需输入以下命令：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will install gulp node module locally on your project. Remember that the
    `--save-dev` flag lets `npm` update its `package.json` file in the `devDependencies`
    section to be resolved only on development time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的项目本地安装gulp节点模块。记住，`--save-dev`标志让`npm`更新其`package.json`文件中的`devDependencies`部分，以便仅在开发时解析。
- en: 'The next step is to create the `gulpfile`. This file will act as manifest to
    define the tasks we want to execute. All of them should be defined in this file;
    let''s go through an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建`gulpfile`。此文件将作为清单来定义我们想要执行的任务。所有这些都应该定义在这个文件中；让我们通过一个示例来了解：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`require` is a node function to add a reference to a module. Since we are referencing
    the gulp module, we are able to use this task automation method.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`是一个Node函数，用于添加对模块的引用。由于我们正在引用gulp模块，因此我们可以使用这种任务自动化方法。'
- en: Now, when we run the `gulp hello-world` command from the command line, the task
    automation tool will search on the `gulpfile` the task matching by name and execute
    it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们从命令行运行`gulp hello-world`命令时，任务自动化工具将在`gulpfile`中搜索与名称匹配的任务并执行它。
- en: 'Gulp provides three primary task methods:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp提供了三个主要任务方法：
- en: '`gulp.task`: To define a new task with a name, array dependencies, and the
    function to execute'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gulp.task`：用于定义一个带有名称、数组依赖项和执行函数的新任务'
- en: '`gulp.src`: It sets the folder where the source files are located'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gulp.src`：它设置源文件所在的文件夹'
- en: '`gulp.dest`: It sets the destination folder where build files will be placed'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gulp.dest`：它设置构建文件将被放置的目标文件夹'
- en: Gulp can be configured to execute any task, such as image transformation, JavaScript
    files transpiling, concatenation, and case processing. Let's see some more advanced
    examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp可以被配置来执行任何任务，例如图像转换、JavaScript文件转译、连接和大小写处理。让我们看看一些更高级的示例。
- en: JavaScript task
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript任务
- en: 'We will configure an automated task to transform our created SCSS files into
    CSS. This code can be implemented in any web project (with gulp dependencies preconfigured,
    of course):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置一个自动任务，将我们创建的SCSS文件转换为CSS。此代码可以在任何带有gulp依赖项预配置的Web项目中实现（当然）：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`gulp-sass` is a customized plugin for gulp to work with SASS files.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`gulp-sass`是Gulp的一个用于处理SASS文件的定制插件。'
- en: 'After importing the `npm` modules into our project, let''s reference them into
    our `gulpfile`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`npm`模块导入我们的项目后，让我们在`gulpfile`中引用它们：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we need to create a new task. Let''s call it `process-styles`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个新的任务。让我们称它为`process-styles`：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we use the `pipe()` method to call any extra plugins between the `.src()`
    and the `.dest()` sections. The code is so self-explanatory, we are just passing
    the route where the `gulp` `task` will find the files to be converted, then configuring
    a fault behavior if some error is raised and if everything is okay, we just specify
    the route of our generated files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `pipe()` 方法在 `.src()` 和 `.dest()` 部分之间调用任何额外的插件。代码非常直观，我们只是传递 `gulp`
    `task` 将要查找的文件转换的路由，然后配置一个错误行为，如果发生错误，以及如果一切正常，我们只需指定我们生成的文件的路由。
- en: Automating tasks
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化任务
- en: 'At this point, we have some task compressed into a single file. All this compression
    will be performed when we run the `gulp` command. We can group the preconfigured
    task to be run into one single command. Suppose we have three tasks already defined:
    `process-styles`, `other-task`, and `some-other-task`. Now we just need to define
    all these tasks into a single new task:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将一些任务压缩到一个单独的文件中。所有这些压缩将在我们运行 `gulp` 命令时执行。我们可以将预配置的任务组合成一个单独的命令。假设我们已经有三个定义好的任务：`process-styles`、`other-task`
    和 `some-other-task`。现在我们只需将这些任务定义到一个新的任务中：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Save and press *Enter* the `gulp run` command line to execute all the tasks
    defined.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并按 *Enter* 键，在命令行中输入 `gulp run` 命令来执行所有定义的任务。
- en: 'That''s great, but we still need to enter commands manually. Rumpelstiltskin,
    that was not part of the deal! Don''t worry, we have one last surprise for you—`gulp.watch()`.
    With this method, you could monitor your source files and execute some task when
    a change is detected. Let''s configure `watch` task into our `gulpfile`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那很好，但我们仍然需要手动输入命令。鲁佩尔施蒂尔金，这并不在协议中！别担心，我们为你准备了一个最后的惊喜——`gulp.watch()`。使用这个方法，你可以监视你的源文件，并在检测到变化时执行一些任务。让我们将
    `watch` 任务配置到我们的 `gulpfile` 中：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, rather than running `gulp` `watch` task manually, let''s configure
    a default task:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，而不是手动运行 `gulp` `watch` 任务，让我们配置一个默认任务：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Save, and then just run the command `gulp` into your terminal. You will note
    that a `gulp` observer is always looking if any change is performed in the files
    preconfigured! Of course, it includes all your `.scss` files! Now you can change
    and add new styles and view it automatically reflected in your browser, without
    the need to execute some command by yourself. If you want to terminate this watch
    process, just type *Ctrl* + *C* to abort monitoring and return to the command
    line. Now you really have a strong task automation tool configured and ready for
    use! The Aurelia CLI preconfigures `gulp` `task` activities for you, but it's
    very important to know how it works behind the scenes; also, you are able to modify
    this configuration and add custom behavior if you consider it needed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，只需在终端中运行 `gulp` 命令。你会注意到一个 `gulp` 监视器总是在检查预配置的文件是否发生了任何变化！当然，它包括所有你的 `.scss`
    文件！现在你可以更改和添加新的样式，并且可以自动在浏览器中看到反映，无需你自己执行任何命令。如果你想终止这个监视过程，只需按 *Ctrl* + *C* 来中止监视并返回到命令行。现在你真的有一个强大的任务自动化工具配置好了，并且准备使用！Aurelia
    CLI 预配置了 `gulp` `task` 活动，但了解其背后的工作原理非常重要；此外，如果你认为需要，你还可以修改此配置并添加自定义行为。
- en: Exploring CSS frameworks
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 CSS 框架
- en: 'We are ready to start writing our first HTML elements and add style to the
    application. There are common elements that can be repeated in more than one application:
    tables, grids, input tags, select, and so on. We can define our own, but you should
    keep in mind that all of these elements need to be standardized, and defining
    it from zero can become a difficult task. Today, we have many HTML libraries and
    templates to start developing our view layer and add custom behavior to satisfy
    our own needs. Let''s explore the three most used HTML, JS, and CSS libraries.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好开始编写我们的第一个 HTML 元素，并为应用程序添加样式。有一些常见元素可以在多个应用程序中重复使用：表格、网格、输入标签、选择等。我们可以定义自己的，但你应该记住，所有这些元素都需要标准化，并且从头开始定义可能是一项艰巨的任务。今天，我们有许多
    HTML 库和模板来开始开发我们的视图层，并添加自定义行为以满足我们的需求。让我们探索最常用的 HTML、JS 和 CSS 库。
- en: Bootstrap
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap
- en: Bootstrap is one of the most popular and complete frontend libraries. It is
    composed of HTML templates, predefined CSS classes, and JavaScript files to add
    a more dynamic behavior to each component. Created by Mark Otto and Jacob Thornton
    at Twitter and then released as open source project in August 2011, Bootstrap
    was one of the first libraries providing custom elements and a grid system to
    design responsive webs. What does responsive mean? Responsive web design is about
    creating websites that automatically adjust themselves to look good on all devices,
    from small phones to large desktops.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap是最受欢迎和最完整的前端库之一。它由HTML模板、预定义的CSS类和JavaScript文件组成，为每个组件添加更动态的行为。由Twitter的Mark
    Otto和Jacob Thornton创建，并于2011年8月作为开源项目发布，Bootstrap是第一个提供自定义元素和网格系统的库之一，用于设计响应式网页。响应式是什么意思？响应式网页设计是关于创建能够自动调整以在各种设备上看起来都很好的网站，从小型手机到大型桌面。
- en: 'The grid is the most important aspect of this framework. It defines the bases
    in which the layout is created. Bootstrap implements five tiers or scales based
    on the screen width. Customize the size of your columns on extra small, small,
    medium, large, or extra large devices, however you see fit. For grids that are
    the same from the smallest of devices to the largest, use the `.col` and `.col-*`
    classes. Specify a numbered class when you need a particularly sized column; otherwise,
    feel free to stick to `.col`. Let''s look at an example for a small screen:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 网格是这个框架最重要的方面。它定义了布局创建的基础。Bootstrap根据屏幕宽度实现了五个层级或比例。根据您的需要，在超小、小、中、大或超大设备上自定义列的大小。对于从小型设备到大型设备都相同的网格，请使用`.col`和`.col-*`类。当您需要一个特定大小的列时，指定一个编号类；否则，请随意坚持使用`.col`。让我们看看一个小屏幕的例子：
- en: '![](img/3c39b813-4edf-47ef-8f74-ea9262c064ba.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c39b813-4edf-47ef-8f74-ea9262c064ba.png)'
- en: 'Here, keep the following in mind:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，请记住以下几点：
- en: '`.col-sm-1` will fit 1/12 of the screen width'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.col-sm-1`将适合屏幕宽度的1/12'
- en: '`.col-sm-2` will fit 1/6 of the screen width'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.col-sm-2`将适合屏幕宽度的1/6'
- en: '`.col-sm-4` will fit 1/3 of the screen width'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.col-sm-4`将适合屏幕宽度的1/3'
- en: '`.col-sm-6` will fit 1/2 of the screen width'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.col-sm-6`将适合屏幕宽度的1/2'
- en: '`.col-sm-12` will fit the entire screen width'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.col-sm-12`将适合整个屏幕宽度'
- en: 'In the same way, Bootstrap includes a vast variety of preconfigured classes
    to simplify the alignment of our HTML elements, making our web application look
    ordered and attractive. Another thing we really like about bootstrap is the high
    customization level. We can transform all their components, adding custom behavior
    or style, and it will not generate any conflict with the existing library. An
    advanced design with some elements customized could look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Bootstrap包括大量预配置的类来简化我们HTML元素的排列，使我们的Web应用看起来有序且吸引人。我们真正喜欢Bootstrap的另一件事是其高度的可定制性。我们可以转换所有组件，添加自定义行为或样式，而不会与现有库产生任何冲突。一些元素定制的先进设计可能看起来像这样：
- en: '![](img/b41b1682-e420-4fec-8eda-054a0965ba2e.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b41b1682-e420-4fec-8eda-054a0965ba2e.png)'
- en: Doesn't care the purpose, Bootstrap is created to provide a highly customizable
    solution for any business need you might have. Let's explore more libraries!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不关心目的，Bootstrap是为了提供针对任何可能业务需求的高度可定制解决方案而创建的。让我们探索更多库！
- en: Material Design
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料设计
- en: Powered by Google, Material Design is more than just a CSS/JS library. It's
    a complete philosophy design, based on shapes, shadows, and transitions. Material
    Design is based on three main principles.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由谷歌提供支持，材料设计不仅仅是CSS/JS库。它是一个基于形状、阴影和转化的完整设计哲学。材料设计基于三个主要原则。
- en: Material is the metaphor
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料是隐喻
- en: Consider all the space around you as a motion system. You can touch it, you
    can feel it, and see how it can change their aspect when you interact. Plain surfaces,
    paper, and colors are common in our daily lifestyle, and Material uses these attributes
    to create an intuitive and familiar interface to the final user, providing a big
    superset of animations without breaking the rules of physics.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将你周围的所有空间视为一个运动系统。你可以触摸它，你可以感受它，并观察当你互动时它如何改变它们的方面。平面表面、纸张和颜色在我们的日常生活中很常见，Material使用这些属性为最终用户创建一个直观且熟悉的界面，提供一大套动画而不违反物理规则。
- en: Bold, graphic, and intentional
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粗体、图形和有意为之
- en: Pleasing to the eyes, Material Design is not intrusive or aggressive. It implements
    a hierarchy meaning based on colors, scales, and white spaces, inviting the user
    to interact with the web interface.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 令人愉悦的视觉体验，Material Design 不会侵扰或具有侵略性。它通过颜色、比例和空白空间实现基于意义的层次结构，邀请用户与网页界面互动。
- en: Motion provides meaning
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画赋予意义
- en: Motion respects and reinforces the user as the prime mover. Primary user actions
    are inflection points that initiate motion, transforming the whole design. Action
    and reaction rules, serving to focus attention and maintain continuity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 动画尊重并强化了用户作为主要推动者的地位。主要用户操作是引发运动的转折点，从而改变整个设计。动作和反应规则，有助于集中注意力和保持连续性。
- en: 'As we said before, Material is not a library, but many libraries are based
    on Material, and one of the most used nowadays is Materialize. This library provides
    all features like others, such as grid systems, prebuilt components, and custom
    behavior, with the difference that all of it is created by following Material
    Design principles. Let''s look at an example of web pages developed using Materialize:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，Material 不是一个库，但许多库都是基于 Material 的，而目前最常用的之一是 Materialize。这个库提供了与其他库相同的功能，例如网格系统、预构建组件和自定义行为，不同之处在于所有这些都是在遵循
    Material Design 原则的基础上创建的。让我们看看使用 Materialize 开发的网页示例：
- en: '![](img/d034b647-eb59-4846-8399-b1e2832724d6.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d034b647-eb59-4846-8399-b1e2832724d6.png)'
- en: As you can see, the Material interface is simple, clean, and self-explanatory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Material 接口简单、干净、一目了然。
- en: Semantic UI
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Semantic UI
- en: The new guy in the neighborhood, Semantic comes with tons of unique new features
    based on modals, accordion elements, 3D transformations, even ratings, and so
    on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 邻居中新来的家伙，Semantic 带来了基于模式、手风琴元素、3D 变换、评分等功能的大量独特新特性。
- en: '"Semantic empowers designers and developers by creating a shared vocabulary
    for UI."'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '"Semantic 通过创建 UI 的共享词汇来赋予设计师和开发者力量。"'
- en: '- Semantic UI Team'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '- Semantic UI 团队'
- en: Why *Semantic*? It's because it provides class names that sound really natural
    in common English language instead of random class names, and, of course, it describes
    what the CSS classes are doing to the HTML element.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择 *Semantic*？因为它提供了听起来非常自然的类名，而不是随机的类名，当然，它还描述了 CSS 类对 HTML 元素所执行的操作。
- en: 'Let''s see how the implementation differs from other frontend libraries; on
    Bootstrap, the names of CSS classes are very friendly for humans to read:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现与其他前端库的不同；在 Bootstrap 中，CSS 类的名称对人类阅读非常友好：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the Semantic UI library, classes use human words. That''s very friendly!
    Coding is more like writing regular text:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Semantic UI 库，类使用人类语言。这非常友好！编码更像是在写常规文本：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Semantic UI comes with a lot of themes, and they are easy to configure. For
    example, the following screenshot shows a web page developed using Semantic UI:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Semantic UI 提供了许多主题，并且它们很容易配置。例如，以下截图显示了使用 Semantic UI 开发的网页：
- en: '![](img/7d4eabda-922a-4cf1-ace2-5b7d9001100c.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d4eabda-922a-4cf1-ace2-5b7d9001100c.png)'
- en: You can read more about this awesome library at [https://semantic-ui.com](https://semantic-ui.com).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://semantic-ui.com](https://semantic-ui.com) 上了解更多关于这个出色库的信息。
- en: All the mentioned libraries are mobile-first based. What does that mean? Let's
    keep exploring!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所提到的库都是基于移动优先的。这意味着什么？让我们继续探索！
- en: The mobile-first approach
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动优先方法
- en: Mobile-first is a relatively new way to design web pages, facilitating the responsiveness
    starting always by the small screen devices, such as mobile phones or tablets.
    When you start designing, you must have a close idea of where your product will
    be displayed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 移动优先是一种相对较新的网页设计方式，它通过始终从小型屏幕设备（如手机或平板电脑）开始，促进响应式设计。当你开始设计时，你必须对产品将在哪里显示有一个清晰的想法。
- en: Now, it's time to choose a frontend library to start creating our first project
    components. In our opinion, Material Design can give a more natural feel to the
    final user and looks great on mobile devices (Android UI is based on Material).
    Bootstrap can be a good option too, still looking like a common web page on small
    screens. The same goes for Semantic UI, but this one has transitions and animations
    that we will really miss. So, let's start configuring our project with Materialize
    library.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候选择一个前端库来开始创建我们的第一个项目组件了。在我们看来，Material Design 可以给最终用户带来更自然的感觉，在移动设备上看起来也很棒（Android
    UI 基于 Material）。Bootstrap 也是一个不错的选择，在小屏幕上仍然看起来像普通的网页。对于 Semantic UI 也是如此，但这个库有过渡和动画，我们将会非常怀念。所以，让我们开始使用
    Materialize 库配置我们的项目。
- en: Configuring our project with Aurelia-Materialize
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Aurelia-Materialize 配置我们的项目
- en: As we said in the last section, Material Design is not a library. However, many
    libraries are based on Material philosophy, so we will choose Materialize CSS.
    Their components look very natural, and the best part is that Aurelia has its
    own implementation of this library called Aurelia-Materialize, which will facilitate
    us a lot in the development process and integration.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，Material Design 不是一个库。然而，许多库都是基于 Material 理念的，因此我们将选择 Materialize
    CSS。它们的组件看起来非常自然，最好的部分是 Aurelia 有自己的这个库的实现，称为 Aurelia-Materialize，这将极大地便利我们在开发过程和集成中的工作。
- en: 'Let''s open our created FIFA World Cup application and set the Terminal into
    the root folder; then we need to install some dependencies. Execute the following
    commands in the next order:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们创建的 FIFA 世界杯应用程序，并将终端设置在根目录；然后我们需要安装一些依赖项。按照以下顺序执行以下命令：
- en: '`$ au install jquery`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ au install jquery`'
- en: '`$ au install tslib`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ au install tslib`'
- en: '`$ au install materialize-amd`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ au install materialize-amd`'
- en: '`$ au install aurelia-materialize-bridge`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ au install aurelia-materialize-bridge`'
- en: 'In our `index.html` file, lets include the Material Design icons to be imported
    into our project:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `index.html` 文件中，让我们包含要导入到我们项目中的 Material Design 图标：
- en: '`<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">`'
- en: 'Next, in our `main.js` file, we need to configure our new plugin:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的 `main.js` 文件中，我们需要配置我们的新插件：
- en: '`aurelia.use.plugin(''aurelia-materialize-bridge'', b => b.useAll().preventWavesAttach());`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia.use.plugin(''aurelia-materialize-bridge'', b => b.useAll().preventWavesAttach());`'
- en: 'The `b => b.useAll()` script allows us to load all Aurelia-materialize components
    into our project. If you only need a few of them, you can specify each one in
    the next way:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`b => b.useAll()` 脚本允许我们将所有 Aurelia-materialize 组件加载到我们的项目中。如果您只需要其中的一些，您可以按照以下方式指定每个组件：'
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we need to add our generated `.css` to the `index.html` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将生成的 `.css` 文件添加到 `index.html` 文件中：
- en: '`<link rel="stylesheet" href="styles/css/materialize.min.css">`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`<link rel="stylesheet" href="styles/css/materialize.min.css">`'
- en: Since we have the Aurelia CLI installed from the previous chapter, we are using
    this feature to get the new dependencies. Make sure you have at least the `0.32.0`
    version.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一章中已经安装了 Aurelia CLI，我们正在使用这个功能来获取新的依赖项。请确保您至少有 `0.32.0` 版本。
- en: You are done! We are finally ready to start developing our generated, configured,
    and running web application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您已完成！我们终于准备好开始开发我们的生成、配置和运行中的 Web 应用程序了。
- en: 'At this point, your application folder should contain the following (or similar)
    project structure:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的应用程序文件夹应包含以下（或类似）的项目结构：
- en: '![](img/e1e7d1c0-1af4-4b9d-a632-5d157486c63a.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1e7d1c0-1af4-4b9d-a632-5d157486c63a.png)'
- en: 'If you are using an earlier version of `Aurelia-CLI` (`0.33.1`), please read
    the following recommendations:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 `Aurelia-CLI` 的早期版本（`0.33.1`），请阅读以下建议：
- en: Add  `node_modules/jquery/dist/jquery.js` to the `prepend` section of the `vendor-bundle.js`
    configuration in the `aurelia.json` file and remove `jquery` from dependencies
    section.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `aurelia.json` 文件的 `vendor-bundle.js` 配置的 `prepend` 部分添加 `node_modules/jquery/dist/jquery.js`，并从依赖项部分移除
    `jquery`。
- en: Add  `node_modules/materialize-amd/dist/js/materialize.amd.js`at the end of
    `prepend` section of the `vendor-bundle.js` configuration in the `aurelia.json` and remove
    the `materialize-amd` configuration from dependencies section.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `aurelia.json` 文件的 `vendor-bundle.js` 配置的 `prepend` 部分的末尾添加 `node_modules/materialize-amd/dist/js/materialize.amd.js`，并从依赖项部分移除
    `materialize-amd` 配置。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to style our Aurelia application using CSS.
    Also, we explored the two most popular CSS preprocessors—LESS and SASS. We saw
    how these preprocessors help us develop more powerful style sheets using variables
    and extensions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 CSS 来样式化我们的 Aurelia 应用程序。我们还探讨了两个最流行的 CSS 预处理器——LESS 和 SASS。我们看到了这些预处理器如何帮助我们使用变量和扩展来开发更强大的样式表。
- en: We explored how to automate tasks using Gulp. Gulp is used by the Aurelia CLI
    to execute all the tasks related to it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何使用 Gulp 自动化任务。Aurelia CLI 使用 Gulp 来执行所有与之相关的任务。
- en: Lastly, we went through different CSS Frameworks and explored and configured
    Google's Material Design Framework. We used Material Design to create our example
    application and take advantage of the most common UI elements.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了不同的 CSS 框架，并配置了 Google 的 Material Design 框架。我们使用 Material Design 创建了示例应用程序，并利用了最常见的
    UI 元素。
- en: In the next chapter, we will see how to apply testing in our code by adopting
    Test-Driven-Development in our development process. Keep reading!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何通过在我们的开发过程中采用测试驱动开发（Test-Driven-Development）来在我们的代码中应用测试。继续阅读！
