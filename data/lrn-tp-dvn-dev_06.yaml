- en: Making Types That Can Slot into Any Other Type
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可以插入任何其他类型的类型
- en: 'In the previous chapter, we saw how to express types for values that have the
    potential to be one of several different things at runtime. At certain times in
    the last chapter, and throughout the book so far, we came up against types that
    Reason marked as *to be filled in later*. In this chapter, we will cover these
    types more in more detail, specifically the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何表达具有在运行时可能成为几种不同事物之一的潜在值的类型。在上一章的某些时候，以及到目前为止整本书中，我们遇到了Reason标记为*稍后填充*的类型。在本章中，我们将更详细地介绍这些类型，特别是以下主题：
- en: Reason's generic type inference
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reason的泛型类型推断
- en: What are type parameters?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类型参数？
- en: Common parameterized types such as lists, options, and arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的参数化类型，如列表、选项和数组
- en: Adding parameters to sum and product types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向求和和乘积类型添加参数
- en: Type inference restrictions on parameterized mutable types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化可变类型的类型推断限制
- en: Type inference and generic types
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断和泛型类型
- en: 'Let''s look at a few interesting examples of Reason''s type inference and how
    it decides what types need to be *filled in later*, as illustrated in the following
    snippet:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Reason的类型推断的一些有趣示例以及它是如何决定需要稍后*填充*哪些类型的，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These examples all have something in common: the compiler doesn''t have quite
    enough information to infer their *concrete* types. Instead, it infers what it
    can about their general shape but leaves some parts as *generic*. We can observe
    the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子都有一个共同点：编译器并没有足够的信息来推断它们的*具体*类型。相反，它推断出它们的一般形状，但将一些部分留为*泛型*。我们可以观察到以下内容：
- en: In (1), the type is inferred as `'a => ('a, 'a, 'a)`.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在（1）中，类型被推断为 `'a => ('a, 'a, 'a)'。
- en: In (2), the type is inferred as ``'a => [> `wrap('a)]``.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在（2）中，类型被推断为 ``'a => [> `wrap('a)]``。
- en: 'In (3), the type is inferred as `''a => {. x: ''a}`.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在（3）中，类型被推断为`''a => {. x: ''a}`。'
- en: In (4), the type is inferred as `'a => unit`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在（4）中，类型被推断为 `'a => unit'。
- en: In each of these cases, the compiler infers some of the types as `'a`, or in
    other words, *I don't know yet*. Let's look at the first case, the `triple` function,
    to try to understand why.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，编译器推断出一些类型为 `'a'，换句话说，*我还不知道*。让我们看看第一个案例，`triple`函数，以尝试理解原因。
- en: 'In `triple`, the function parameter is `x` and the function body is `(x, x,
    x)`. Given these two facts, the compiler tries to infer (that is, narrow down)
    the type of `triple` by working its way up from each part of the function parameter
    and body. Let''s look at what we can infer from each part of `triple`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在`triple`中，函数参数是`x`，函数主体是`(x, x, x)`。考虑到这两个事实，编译器试图通过从函数参数和主体的每一部分向上工作来推断（即缩小）`triple`的类型。让我们看看我们可以从`triple`的每一部分推断出什么：
- en: 'From the `x` parameter: Nothing, so we mark its type as (a generic type) `''a`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`x`参数：没有，因此我们将其类型标记为（一个泛型类型）`'a`。
- en: 'From the body, `(x, x, x)`: We already marked the type of `x` as `''a`, so
    we mark the type of the body as `(''a, ''a, ''a)`, that is, a tuple type consisting
    of three elements all of the same type'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主体`(x, x, x)`：我们已经将`x`的类型标记为`'a`，因此我们将主体的类型标记为`('a, 'a, 'a)`，即由三个相同类型的元素组成的元组类型
- en: 'From the overall function: We marked the parameter as type `''a`, and the body
    as type `(''a, ''a, ''a)`, so we infer the function as a whole to have type `''a
    => (''a, ''a, ''a)`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从整体函数：我们将参数标记为类型`'a'，并将主体标记为类型`('a, 'a, 'a)`，因此我们推断整个函数的类型为`'a => ('a, 'a, 'a)`。
- en: Notice that, if anything, this seems like a process of elimination, or a process
    of solving a Sudoku puzzle. We narrow down the types as much as we can based on
    what we know until we can't narrow them down any further. This is the same inference
    and unification process we're familiar with from previous chapters where we encountered
    various type errors, but with generic types we see a new dimension to the type
    system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这似乎更像是一个排除过程，或者解决数独谜题的过程。我们尽可能多地根据我们所知道的信息缩小类型，直到我们不能再缩小为止。这正是我们从之前的章节中熟悉的推断和统一过程，但在泛型类型中，我们看到类型系统的新维度。
- en: Reason's type inference process is a famous one, known as **Hindley-Milner (H-M)**
    type inference*;* it's a mathematics-specific way of examining any given expression
    to try to deduce the most general type that will fit the expression. We won't
    delve into the theory here, but we will cover the practicalities of working with
    H-M type inference.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 的类型推断过程是著名的，称为 **Hindley-Milner (H-M**) 类型推断*；* 它是一种数学特定的方法，用于检查任何给定的表达式，以尝试推断最适合该表达式的最一般类型。我们不会深入理论，但我们将涵盖使用
    H-M 类型推断的实际操作。
- en: By examining the type inference process for `triple`, we can see how the inference
    works for `wrap`, `makeObj`, and `greet`. The key point to understand is that
    each of these functions has a body expression that doesn't use any specific property
    of its input parameter; instead, the body composes the input parameter inside
    a larger expression that uses the value in a generic way that doesn't expose any
    information about the type itself. For example, imagine being given some object
    (you don't know what) and immediately putting it inside a box; you still don't
    know what the object is, you just know you now have a box that contains some object.
    This is how generic type inference works for structural types.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查 `triple` 的类型推断过程，我们可以看到 `wrap`、`makeObj` 和 `greet` 的推断是如何工作的。理解的关键点是这些函数中的每一个都有一个不使用其输入参数任何特定属性的体表达式；相反，体表达式在一个更大的表达式中组合输入参数，以通用的方式使用值，而不暴露任何关于类型本身的信息。例如，想象一下被给了一个某些对象（你不知道是什么），然后立即把它放在一个盒子里；你仍然不知道这个对象是什么，你只是知道你现在有一个包含某个对象的盒子。这就是结构化类型通用类型推断的工作方式。
- en: The special case of interpolation
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊情况插值
- en: Out of the functions we've mentioned, `greet` is a bit special because type
    inference doesn't work in quite the same way as it does for the others. For the
    first three functions, inference arrives at a generic type because the parameters
    are used in structurally-typed expressions. For `greet` though, the `x` parameter
     is interpolated into a string; however, strings aren't structurally typed! What's
    going on is that string interpolation is a special escape hatch provided by the
    BuckleScript compiler that allows you to turn any value into a string, but only
    when targeting JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提到的函数中，`greet` 稍微特殊，因为类型推断并不完全像其他函数那样工作。对于前三个函数，由于参数在结构化类型表达式中使用，推断达到了一个通用类型。然而，对于
    `greet`，`x` 参数被插入到一个字符串中；然而，字符串并不是结构化类型！正在发生的事情是，字符串插值是 BuckleScript 编译器提供的一个特殊逃生门，允许你将任何值转换为字符串，但仅当针对
    JavaScript 时。
- en: The key point here is turning any value into a string. We can think of this
    behavior as a function, `'a => string`. Since we then print the string with `print_endline`,
    the final result type is `unit`; so the overall type is `'a => unit`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键点是任何值转换为字符串。我们可以将这种行为视为一个函数，`'a => string`。由于我们随后使用 `print_endline` 打印字符串，最终的结果类型是
    `unit`；因此，整体类型是 `'a => unit`。
- en: Type parameters
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型参数
- en: We've seen that type checking goes through an algorithmic process of working
    out the most general possible type of any given expression, and when the expression
    is structurally typed, such as `let pair(x) = (x, x)`, it can infer types that
    are parameterized (such as `'a => ('a, 'a)`) because it doesn't know, or doesn't
    need to know, exactly what they are.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到类型检查通过一个算法过程来确定任何给定表达式的最一般类型，当表达式是结构化类型，例如 `let pair(x) = (x, x)`，它可以推断出参数化类型（例如
    `'a => ('a, 'a)`)，因为它不知道，或者不需要知道它们的确切内容。
- en: A **type parameter** is an as-yet-unknown type that will be specified later
    in use. Reason supports type parameters on all types, including nominal types.
    This gives record and variant types a new dimension (literally) of data modeling
    power. Let's now explore a few of the most basic but also important parameterized
    data types in Reason.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型参数** 是一个尚未指定的类型，将在稍后使用时指定。Reason 支持在所有类型上使用类型参数，包括命名类型。这为记录和变体类型提供了新的数据建模维度（字面上）。现在让我们探索一些最基本但也很重要的参数化数据类型。'
- en: The list – modeling more than one
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表——建模多个
- en: 'We''ve already seen how to model a list of person records in [Chapter 5](d3723975-7a3c-4369-84fe-272b67870234.xhtml),
    *Putting Alternative Values in Types,* but that data structure was limited to
    holding only values of person records. Ideally, we want a data structure that
    can hold values of *any* type, so that we don''t have to re-implement the type
    and its operations for every possible element type. We can accomplish this by
    parameterizing the list type by the element type, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第5章](d3723975-7a3c-4369-84fe-272b67870234.xhtml)中看到了如何建模人员记录的列表，*在类型中放置替代值*，但那个数据结构仅限于存储人员记录的值。理想情况下，我们希望有一个可以存储任何类型值的结构，这样我们就不必为每个可能的元素类型重新实现类型及其操作。我们可以通过将列表类型参数化为元素类型来实现这一点，如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous example shows how to generically hold objects of any given type,
    as well as do something specific with them. It is explained as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了如何泛型地持有任何给定类型的对象，以及如何对它们进行特定操作。解释如下：
- en: Here, we parameterize a nominal type (a variant type to be precise), `list`,
    with an explicit type parameter, `'a` (pronounced 'alpha'). Here we have only
    one, but types can have multiple type parameters. The syntax for declaring type
    parameters is `type typeName('param1, 'param2, ..., 'paramN)`. Note that type
    parameters must always start with the tick (`'`) character to distinguish them
    from regular types. Type parameters are also known as type variables.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用显式类型参数`'a`（发音为'alpha'）对命名类型（确切地说，是一个变体类型）`list`进行参数化。这里我们只有一个，但类型可以有多个类型参数。声明类型参数的语法是`type
    typeName('param1, 'param2, ..., 'paramN)`。请注意，类型参数必须始终以撇号（`'`）字符开头，以区分常规类型。类型参数也被称为类型变量。
- en: We construct a list made up of `person` records we defined in a previous module.
    The compiler can infer its type to be `list(Ch04_RecordLiterals.person)`, because
    we slotted in the person type at the exact places where we declared the type parameter, `'a`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构建一个由我们在之前模块中定义的`person`记录组成的列表。编译器可以推断其类型为`list(Ch04_RecordLiterals.person)`，因为我们正好在声明类型参数`'a`的地方插入了人员类型。
- en: We define how to greet a single person. This operation doesn't make use of type
    parameters in any way, but it is a building block for a later operation that does.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了如何问候一个单独的人。这个操作在某种程度上没有使用类型参数，但它是一个构建后续操作的基础。
- en: Inside `greetAll`, we have an interesting pattern match on `people`. With the
    `Cons(person, people)` and `Empty` branches, the compiler infers that `people`
    has type `list('a)`, and with `greetOne(person)`, it infers that `'a = person`;
    overall the function has the type `list(person) => unit`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`greetAll`内部，我们对`people`进行了一个有趣的模式匹配。通过`Cons(person, people)`和`Empty`分支，编译器推断出`people`的类型为`list('a)`，通过`greetOne(person)`，它推断出`'a
    = person`；总体上，该函数的类型为`list(person) => unit`。
- en: When we reach the end of the list, we don't want to do anything else, so we
    just return `()`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们到达列表的末尾时，我们不想做任何事情，所以我们只返回`()`。
- en: 'Now that we''ve seen how to build and operate on a polymorphic data type, let''s
    look at Reason''s built-in implementation of the `list` type. The built-in implementation
    works in much the same way as the one mentioned earlier, except Reason provides
    some nice syntactic sugar to make it easier to work with lists. Let''s take a
    look at the following snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何构建和操作多态数据类型，让我们看看Reason内置的`list`类型的实现。内置实现的工作方式与前面提到的类似，但Reason提供了一些语法糖，使得与列表一起工作更加容易。让我们看看下面的代码片段：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First of all, notice that we got rid of the type declaration, since the Reason
    `list('a)` type is already built in and accessible from every module. To be precise,
    it's defined in the `Pervasives` module, whose contents are by default accessible
    from every module.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，我们已经去掉了类型声明，因为Reason的`list('a)`类型已经内置并且可以从每个模块中访问。更准确地说，它在`Pervasives`模块中定义，其内容默认可以从每个模块中访问。
- en: We use the list construction syntactic sugar, which is `[elem1, elem2, ... elemN]`,
    to construct a list that is essentially like our previous one `Cons(elem1, Cons(elem2,
    ... Cons(elemN, Empty) ... ))`. The brackets-and-commas syntax is flatter and
    easier to understand.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用列表构造的语法糖，即`[elem1, elem2, ... elemN]`，来构造一个本质上类似于我们之前的列表`Cons(elem1, Cons(elem2,
    ... Cons(elemN, Empty) ... ))`。括号和逗号语法更简洁，更容易理解。
- en: Pattern matching on a list now looks like `[elem, ...restElems]` to bind to
    the first element and the list of remaining elements. The `...` is called the
    **spread operator** and is designed to look like JavaScript's array spread feature,
    which works similarly.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表上进行模式匹配现在看起来像`[elem, ...restElems]`，以绑定第一个元素和剩余元素列表。`...`被称为**扩展运算符**，它被设计成类似于JavaScript的数组扩展功能，其工作方式类似。
- en: We reuse the `greetOne` function we already defined since it doesn't depend
    on the specific list type—it just greets a single person.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重用了已经定义的`greetOne`函数，因为它不依赖于特定的列表类型——它只是问候一个人。
- en: The empty list pattern now looks like `[]` instead of `Empty`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空列表模式现在看起来像`[]`而不是`Empty`。
- en: Notice how succinct the list syntax is overall. It's designed for everyday use
    because lists are one of the most important data types in Reason, and in functional
    programming in general.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意列表语法的简洁性。它是为日常使用设计的，因为列表是Reason中最重要的一种数据类型，在函数式编程中也是如此。
- en: The option – modeling either none or one
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项 - 模拟无或一个
- en: 'In a similar way to `list(''a)`, the `Pervasives` module also provides a data
    type, `option(''a)`. This time let''s look at its real definition, because there''s
    no syntactic sugar for it, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与`list('a')`类似，`Pervasives`模块也提供了一个数据类型，`option('a')`。这次让我们看看它的实际定义，因为它没有语法糖，如下所示：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In some ways, this is a simpler data type than the list. Its real utility comes
    from the meaning we give to the variant cases:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，这比列表是一个更简单的数据类型。它的真正效用来自于我们对变体情况赋予的意义：
- en: '`Some(''a)`: Represents a value that is present and that is known'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Some(''a'')`: 表示一个存在且已知的值'
- en: '`None`: Represents a value that is absent and is unknown'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`: 表示一个不存在且未知的值'
- en: In Reason, and some other languages, there is no concept of a null value, so
    this option type is used to represent that a value is present or absent. Whenever
    we'd use null, we can use options instead, with the benefit that optionality(the
    property that some value may be present or not) is captured in the type system,
    instead of behind the scenes. Because the `option` type is a variant, the compiler
    helps us to handle possible missing values through exhaustivity checking. There's
    no danger of forgetting to handle a null value and crashing at runtime.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reason和一些其他语言中，没有null值的概念，所以这种选项类型用来表示一个值是存在还是不存在。当我们使用null时，我们可以使用选项，其好处是可选性（某个值可能存在或不存在）被捕获在类型系统中，而不是在幕后。由于`option`类型是一个变体，编译器帮助我们通过穷尽性检查来处理可能缺失的值。没有忘记处理null值并在运行时崩溃的风险。
- en: 'Present and absent may still be somewhat vague concepts, so the following code
    is a more concrete example where we try to find a matching value in a list:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 存在和不存在可能仍然是一些模糊的概念，所以下面的代码是一个更具体的例子，其中我们尝试在列表中找到一个匹配的值：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we define how to find an item in a list and safely handle
    the case of a missing item:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了如何在列表中查找一个项目，并安全地处理缺失项的情况：
- en: We pass in a list to search (called `haystack`) and a tester function (called
    `needle`) that tells us if we've found the value we're looking for. Since `haystack`
    is a list, we can pattern match on it.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们传递一个列表去搜索（称为`haystack`）和一个测试函数（称为`needle`），该函数告诉我们是否找到了我们正在寻找的值。由于`haystack`是一个列表，我们可以在它上面进行模式匹配。
- en: The first pattern looks at the first element of the list to see if it's the
    one we want, as determined by `needle`. We don't want to bind the rest of the
    elements, so we prefix the `_items` name with an underscore to tell Reason to
    ignore it. Notice that we're using the `when` clause here, as introduced in [Chapter
    5](d3723975-7a3c-4369-84fe-272b67870234.xhtml), *Putting Alternative Values in
    Types*. This is equivalent to using an `if` expression inside the body of the
    branch, but is slightly more succinct. If the first element matches the needle,
    we put it inside a `Some` constructor and evaluate it.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个模式检查列表的第一个元素是否是我们想要的，这是由`needle`决定的。我们不想绑定其余的元素，所以我们在`_items`名称前加上下划线来告诉Reason忽略它。注意，我们在这里使用的是`when`子句，正如在[第五章](d3723975-7a3c-4369-84fe-272b67870234.xhtml)中介绍的，*在类型中放置替代值*。这相当于在分支体中使用`if`表达式，但更简洁。如果第一个元素与针匹配，我们将其放入`Some`构造函数中并对其进行评估。
- en: In the second pattern, we match against the remaining list of items after ignoring
    the first item, and recursively try to find the element we want in that. But this
    branch is only reached if the first branch doesn't match, meaning that the element
    wasn't the first item in the list. The branch itself evaluates to the result of
    `tryFind`, meaning either `Some(person)` or `None`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二种模式中，我们匹配忽略第一个项目后的剩余项目列表，并递归地尝试在该列表中找到我们想要的元素。但只有当第一个分支不匹配时，才会到达这个分支，这意味着元素不是列表中的第一个项目。这个分支本身评估为
    `tryFind` 的结果，意味着 `Some(person)` 或 `None`。
- en: 'In the final branch, we must handle the other possible state of the `haystack`
    list: being empty. If it is, we either started with an empty list or ended up
    with one by recursion. In either case, we didn''t find the element we wanted in
    the list, so we return `None`, which in this case means not found*.*'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最终分支中，我们必须处理 `haystack` 列表的另一种可能状态：为空。如果是这样，我们可能开始时就是一个空列表，或者通过递归最终变成了一个空列表。在任何情况下，我们都没有在列表中找到我们想要的元素，所以我们返回
    `None`，在这种情况下意味着未找到*。
- en: Here, we describe how to greet a person who may or may not be there. The compiler
    forces handling both `Some(person)` and `None` cases—we can't forget to handle
    a missing value.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们描述了如何问候可能或可能不在那里的人。编译器强制处理 `Some(person)` 和 `None` 两种情况——我们不能忘记处理缺失的值。
- en: We define two different `needle` functions, which test whether a given person's
    record has the ID 1 or 4.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了两个不同的 `needle` 函数，它们测试给定的人的记录是否有 ID 1 或 4。
- en: 'Here''s the payoff: we can optionally greet a person, but only if we found
    the person with the given ID in our `people` list. We can run the following output
    script to see what happens:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是回报：我们可以选择性地问候一个人，但仅在我们找到了具有给定 ID 的人在我们的 `people` 列表中。我们可以运行以下输出脚本来查看会发生什么：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As expected, we find and greet the person (`Bob`) with `ID 1`, but not the one
    with `ID 4` because there is no such person.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们找到了并问候了 `ID 1` 的 (`Bob`) 人，但没有问候 `ID 4` 的人，因为没有这样的人。
- en: In the output JavaScript, BuckleScript again converts the tail-recursive `tryFind`
    function into a simple imperative loop.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出 JavaScript 中，BuckleScript 再次将尾递归的 `tryFind` 函数转换为一个简单的命令式循环。
- en: 'Here, we see two sides of using the `option` type: we may need to represent
    the presence or absence of a value during the normal course of our operation,
    and if we use a variant type such as `option`, we get the benefit of its exhaustivity
    checking.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到使用 `option` 类型的两个方面：我们可能需要在操作过程中表示值的出现或缺失，如果我们使用像 `option` 这样的变体类型，我们就能得到其详尽性检查的好处。
- en: Mutable parameterized types – ref and array
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变参数化类型 – ref 和 array
- en: Reason also provides two important parameterized types that allow their values
    to be mutated in place. This mutability brings efficiency gains for certain types
    of algorithms, but generally needs to be used carefully because, as we'll see,
    it may be a source of bugs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 还提供了两种重要的参数化类型，允许它们的值在原地被修改。这种可变性为某些类型的算法带来了效率提升，但通常需要谨慎使用，因为，正如我们将看到的，它可能是一个错误来源。
- en: Managing a reference to a value
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对值的引用
- en: 'We''ve already seen an example of mutability, in the *Mutable record fields*
    section of [Chapter 4](ba37505a-f222-4238-a13c-259160ca582d.xhtml), *Grouping
    Values Together in Types*. Sometimes, we need to manage just one or two mutable
    values, and we might not want to go through the ceremony of declaring a new record
    type with mutable fields. For these situations, we can take advantage of the built-in
    `ref` type. The `ref` type essentially gives us a box, a ref, that lets us swap
    values in and out. The values themselves need not be mutable, just the box itself:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第 4 章的 *Mutable record fields* 部分，*Grouping Values Together in Types* 中看到了一个可变性的例子。有时，我们只需要管理一个或两个可变值，我们可能不想通过声明一个新的具有可变字段的记录类型来进行仪式。在这些情况下，我们可以利用内置的
    `ref` 类型。`ref` 类型本质上给我们一个盒子，一个 ref，它让我们可以交换值。值本身不需要是可变的，只需要盒子本身：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The previous code listing shows the complete API of the `ref` type, explained
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例显示了 `ref` 类型的完整 API，解释如下：
- en: It's implemented as a record type with just a single mutable record field, but
    this field is parameterized by a type parameter, `'a`, letting us reuse it for
    any type.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它被实现为一个只有一个可变记录字段的记录类型，但这个字段由类型参数 `'a'` 参数化，让我们可以为其任何类型重用它。
- en: 'We can use the `ref` function to box a value of any type and put it inside
    a ref: `let count = ref(0);`.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `ref` 函数将任何类型的值装箱，并将其放入一个 ref 中：`let count = ref(0);`。
- en: The assignment operator `(:=)` is implemented as a function and can be used
    in the infix position: `count := 1;`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 赋值运算符 `(:=)` 实现为一个函数，并且可以用作中缀位置：`count := 1;`。
- en: 'The dereference operator, `(^)`, is also implemented as a function, but Reason
    allows us to use it in postfix position: `let countVal = count^;`.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消引用运算符 `(^)` 也实现为一个函数，但 Reason 允许我们在后缀位置使用它：`let countVal = count^;`。
- en: '`incr` and `decr` are convenience functions for incrementing and decrementing
    integers, as we often need to update counts.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`incr` 和 `decr` 是用于增加和减少整数的便利函数，因为我们经常需要更新计数。'
- en: The huge benefit of using the `ref` type to manage mutation is that mutability
    is captured at the type level. We can tell from looking at any type signature
    that contains `ref(something)` that something of the `something` type is changing.
    By contrast, when we're using a mutable record field directly, we have no type-level
    indication of mutability, just the record definition itself.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ref` 类型来管理突变的好处是可变性在类型级别上被捕获。我们可以从查看任何包含 `ref(something)` 的类型签名中看出，`something`
    类型的某个东西正在改变。相比之下，当我们直接使用可变记录字段时，我们没有可变性的类型级别指示，只有记录定义本身。
- en: 'Let''s look at an example of using a `ref`: redefining the `tryGreet` function
    to use a more imperative style of walking through its input list and trying to
    find the required item. We''ll need three refs: the remaining portion of the haystack
    list, whether we should stop searching or not, and an optional found item. As
    long as we haven''t found the item yet, we''ll keep searching, but as soon as
    we find it, we''ll return it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `ref` 的一个示例：重新定义 `tryGreet` 函数以使用更命令式的风格遍历其输入列表并尝试找到所需的项目。我们需要三个 `ref`：列表的剩余部分、是否应该停止搜索，以及一个可选的找到的项目。只要我们还没有找到项目，我们就会继续搜索，但一旦找到，我们就会返回它：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the previous example, we use Reason''s imperative features (mutation and
    looping), explained as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用了 Reason 的命令式特性（突变和循环），如下所述：
- en: We continuously loop until we explicitly say we should stop. Notice that an
    imperative `while` loop looks exactly as we might expect from other imperative
    languages such as JavaScript.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们会持续循环，直到我们明确表示应该停止。注意，命令式的 `while` 循环看起来就像我们从其他命令式语言（如 JavaScript）中期望的那样。
- en: Pattern matching on the input `haystack list` is still the most convenient way
    to walk through it item by item, so we keep doing that here.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入 `haystack list` 上的模式匹配仍然是遍历它的最方便的方式，所以我们在这里继续这样做。
- en: If we find the item we're looking for, we need to make sure that we set the
    stop indicator to `true`, and also set the found item so we can return it later.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们找到了我们正在寻找的项目，我们需要确保我们将停止指示符设置为 `true`，并且设置找到的项目，以便我们稍后可以返回它。
- en: If we haven't found it yet but the list isn't empty, set the current haystack
    to be the remainder of the list.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们还没有找到它，但列表不为空，将当前 `haystack` 设置为列表的剩余部分。
- en: If the list is empty, we obviously haven't found the item, so we need to stop.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果列表为空，显然我们没有找到项目，因此我们需要停止。
- en: Whatever we've found (or haven't) so far, we finally need to dereference and
    return it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论我们迄今为止找到了什么（或者没有找到什么），我们最终都需要取消引用并返回它。
- en: The first thing to notice about this imperative version is that it's more verbose.
    Keeping track of the mutable state involves some ceremony at the code level. It's
    not that imperative style in Reason is especially cumbersome; it would look much
    the same in any imperative language. It's just that functional style with recursion
    is, in general, more succinct because the recursive call effectively keeps track
    of the current state so we don't have to.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令式版本首先要注意的是它更冗长。跟踪可变状态在代码层面上涉及一些仪式。这并不是说 Reason 的命令式风格特别繁琐；在任何命令式语言中看起来都差不多。只是函数式风格，特别是递归风格，通常更简洁，因为递归调用实际上跟踪了当前状态，所以我们不需要。
- en: 'The second thing to note is that we''ve preserved the same function signature
    (`(''a => bool, list(''a)) => option(''a)`) for this implementation, just without
    recursion. If we needed to, we could swap out this implementation for the recursive
    one, and our client code wouldn''t need a recompilation to use it. This is a property
    of many static type systems: if we preserve type signatures, we can freely swap
    out implementations. Reason''s type system in particular uses signatures to decide
    whether entire modules are compatible. This helps us pinpoint compatibility issues
    early, at build time, rather than find an incompatibility when running the code.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要注意的是，我们保留了相同的函数签名（`('a => bool, list('a)) => option('a)`）来实现这个版本，只是没有使用递归。如果我们需要，我们可以用递归实现替换这个实现，而我们的客户端代码不需要重新编译就可以使用它。这是许多静态类型系统的特性：如果我们保留类型签名，我们可以自由地替换实现。特别是
    Reason 的类型系统使用签名来决定整个模块是否兼容。这有助于我们在构建时早期定位兼容性问题，而不是在运行代码时发现不兼容性。
- en: Managing an array of values
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理值数组
- en: 'Sometimes, we need to efficiently manage and change many values of the same
    type. Reason provides the `array` type to help with this. We can think of an array
    as a single contiguous line of boxes of the same size, each of which can hold
    a value of the same type. Formally, it''s a polymorphic type, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要高效地管理和更改相同类型的大量值。Reason 提供了 `array` 类型来帮助处理这个问题。我们可以将数组想象成一条由相同大小的盒子组成的连续线，每个盒子都可以存储相同类型的值。形式上，它是一个多态类型，如下所示：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `array` data structure is characteristically similar to what you might
    have seen in other languages, in which:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`array` 数据结构在特征上与其他语言中可能看到的结构相似，其中：'
- en: It allows random access to its elements
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许随机访问其元素。
- en: It doesn't allow recursive traversal of elements like `list` does with the spread
    (`[item, ...items]`) operation
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不允许像 `list` 使用展开操作（`[item, ...items]`）那样递归遍历元素。
- en: 'However, it does allow basic pattern matching on its elements. The following
    is an example of its use:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它确实允许对其元素进行基本的模式匹配。以下是其使用的一个示例：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the previous example, we see the following simple use of arrays:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到以下简单的数组使用：
- en: We can create an empty array, as well as arrays with one or more elements. The
    array delimiters are `[|` and `|]` and are used to distinguish them from lists
    which are more frequently used in Reason.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个空数组，以及包含一个或多个元素的数组。数组分隔符是 `[|` 和 `|]`，并且用于区分它们与在 Reason 中更频繁使用的列表。
- en: We can assign to any valid index in the array (assigning to an out-of-bounds
    index will cause a runtime exception).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以分配到数组中的任何有效索引（分配到越界索引会导致运行时异常）。
- en: We can read the value at any valid index (reading from an out-of-bounds index
    will also cause a runtime exception).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以读取任何有效索引处的值（从越界索引读取也会导致运行时异常）。
- en: For arrays, the concept of indexing is important, as we can see here. Index-based
    random access is constant-time, but in return we have to take care to access only
    valid indexes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，索引的概念很重要，正如我们在这里所看到的。基于索引的随机访问是常数时间的，但作为交换，我们必须注意只访问有效的索引。
- en: 'To get a better sense of how arrays are useful, let''s try to implement a tic-tac-toe
    board using an array and a couple of functions that update and check the board,
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解数组的有用性，让我们尝试使用一个数组和几个更新和检查棋盘的函数来实现井字棋棋盘，如下所示：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is an interesting example of designing an array so we can pattern match
    it literally, explained as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个设计数组的有趣示例，以便我们可以对其进行字面意义上的模式匹配，如下所述：
- en: We can create a new game board by creating a new array filled with `Empty` slots,
    using the `Array.make` library function. This function gives us an array of the
    required length and is filled with a single value in all the indexes.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个新的数组并使用 `Array.make` 库函数填充 `Empty` 槽来创建一个新的游戏棋盘。这个函数为我们提供了一个所需长度的数组，并且所有索引都填充了单个值。
- en: Since we accept a one-indexed board coordinate, we convert it to a zero-indexed
    array index by simply subtracting one.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们接受一个一维的棋盘坐标，我们只需简单地减去一将其转换为零索引的数组索引。
- en: We can pattern match against the exact structure of the array. In this case,
    our nine-element array can look exactly like a tic-tac-toe board if we break it
    up into three rows purely for presentation.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以针对数组的精确结构进行模式匹配。在这种情况下，我们的九元素数组如果将其分成三行纯粹是为了展示，可以看起来就像一个井字棋棋盘。
- en: We can use `or` patterns to capture all the cases in which player X wins.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `or` 模式来捕获玩家 X 获胜的所有情况。
- en: Return `true` for all of them.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有这些返回 `true`。
- en: Otherwise, we return `false`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们返回`false`。
- en: In this case, the fact that we can easily set any position on the board when
    a player makes a move suits the random-access capability of an array. Setting
    random positions in a list would be an inefficient operation by comparison because
    the only way to do that is to traverse each element of the list and then perform
    several list-breaking and joining operations until we create the final output
    list.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当玩家移动时，我们可以轻松地设置棋盘上的任何位置，这符合数组的随机访问能力。相比之下，在列表中设置随机位置将是一个低效的操作，因为唯一的方法是遍历列表的每个元素，然后执行多次列表拆分和连接操作，直到创建最终的输出列表。
- en: In general, an array is very useful when we need to perform frequent updates
    over multiple elements. Common scenarios are pixel buffers and manually managed
    memory regions. Fortunately, Reason makes these scenarios relatively easy to implement.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们需要对多个元素进行频繁更新时，数组非常有用。常见场景是像素缓冲区和手动管理的内存区域。幸运的是，Reason使这些场景相对容易实现。
- en: Mutation and type inference restrictions
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变异和类型推断限制
- en: 'In general, the compiler happily infers all sorts of types for us, but it does
    have some limitations. Sometimes, we need to give it a little nudge to help it
    get to the correct inference result, for example. The main case we need to be
    aware of is called **value restriction.** Value restriction basically means that
    mutable values can''t be generic, the compiler must know their types fully. The
    following is an example error you will get if you uncomment the code in the file
    `src/Ch06/Ch06_ValueRestrictionError.re`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器会为我们推断各种类型，但它确实有一些限制。有时，我们需要给它一点提示，以帮助它得到正确的推断结果，例如。我们需要注意的主要情况被称为**值限制**。值限制基本上意味着可变值不能是泛型的，编译器必须完全知道它们的类型。以下是在文件`src/Ch06/Ch06_ValueRestrictionError.re`中取消注释代码时你会得到的错误示例：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice the inferred type for `optionArr: array(option(''_a))`. The underscore
    prefix in front of the type variable name is the compiler''s way of saying that
    it ran into the value restriction. A type variable named `''_a` is called a **weak
    type variable** (in the sense that its actual type might change later).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '注意`optionArr: array(option(''_a''))`的类型推断。类型变量名前的下划线前缀是编译器表示遇到了值限制的方式。名为`''_a''`的类型变量被称为**弱类型变量**（在这个意义上，它的实际类型可能会以后改变）。'
- en: Having a type that might change after it's inferred at compilation is a bad
    idea. For example, let's think about what would happen if the compiler inferred
    the type as `array(option('a))`. Later in the code, we could set that index to
    `Some(1)`, then later still we could set it to `Some(false)`. This would defeat
    the type system entirely and leave us uncertain of what the exact type is at any
    point in the code. The compiler designers decided to prevent this from happening.
    This is just one of the type soundness decisions that they've made over the years
    to prevent runtime type errors from creeping into programs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类型在编译时推断后可能会改变，这是一个坏主意。例如，让我们考虑如果编译器推断类型为`array(option('a'))`会发生什么。在代码的后续部分，我们可以将该索引设置为`Some(1)`，然后稍后将其设置为`Some(false)`。这将完全破坏类型系统，并使我们无法在任何代码点确定确切的类型。编译器设计者决定防止这种情况发生。这只是他们多年来为防止运行时类型错误渗入程序而做出的类型安全性决策之一。
- en: 'As a valid code, we could precise the type using `array(option(string))`, as
    you can see in the alternative code file (`src/Ch06/Ch06_ValueRestrictionErrorFixed.re`)
    which compiles correctly. It''s code is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为有效代码，我们可以使用`array(option(string))`精确类型，正如你在替代代码文件（`src/Ch06/Ch06_ValueRestrictionErrorFixed.re`）中看到的那样，该文件可以正确编译。其代码如下：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s look at another value restriction error. Again, uncomment the code in
    the file `src/Ch06/Ch06_ValueRestrictionOtherError.re`, and you will get a compilation
    error as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个值限制错误。再次，取消注释文件`src/Ch06/Ch06_ValueRestrictionOtherError.re`中的代码，你将得到以下编译错误：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This one is slightly trickier as there's no obvious mutation. The `pairAll`
    function is supposed to convert a list of items into a list of pairs (2-tuples)
    of those items. The problem is that the `pair` function is generic; the compiler
    can't figure out if it might be mutating anything. If we'd had a monomorphic (that
    is, not generic) function instead, such as `let pair(x) = (x + 1, x - 1);`, then
    the compiler would be able to figure out that the inputs and outputs are just
    `int` and there's no mutation involved.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题稍微有点棘手，因为没有明显的突变。`pairAll` 函数的目的是将项目列表转换为这些项目的对（二元组）列表。问题是 `pair` 函数是通用的；编译器无法确定它是否可能会修改任何内容。如果我们有一个单态（即非通用）函数，比如
    `let pair(x) = (x + 1, x - 1);`，那么编译器就能确定输入和输出只是 `int`，并且没有涉及任何突变。
- en: 'However, there is another way to solve this particular error; remember that
    it''s called the *value* restriction. In other words, only values are restricted
    like this. If we expand `pairAll` into an explicit function, then the error goes
    away, shown as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种解决这个特定错误的方法；记住，它被称为*值限制*。换句话说，只有值受到这种限制。如果我们将 `pairAll` 扩展为一个显式的函数，那么错误就会消失，如下所示：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our fixed code can be found in `src/Ch06/Ch06_ValueRestrictionErrorFixed.re`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们固定的代码可以在 `src/Ch06/Ch06_ValueRestrictionErrorFixed.re` 中找到。
- en: This funny solution convinces the compiler that yes, this is really a function,
    so the value restriction doesn't apply.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有趣的方法让编译器相信，是的，这确实是一个函数，因此值限制不适用。
- en: Forcing a difference with phantom types
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制与幻影类型的不同
- en: Because we can declare types that can slot in *any* type parameters, that includes
    type parameters that the types don't actually use. These are called phantom type
    parameters, or more informally **phantom types.**
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们可以声明可以插入任何类型参数的类型，包括类型实际上没有使用的类型参数。这些被称为幻影类型参数，或者更非正式地称为**幻影类型**。
- en: A common use case for phantom types is in a kind of type-safe **builder pattern.**
    (The builder pattern is a piece of code that helps us to construct an object according
    to specific rules.) For example, we might want to construct syntactically valid
    SQL statements. One way to do that is to have a validator function that takes
    an input SQL statement and decides whether it follows SQL syntax rules or not
    at runtime. This function might try to parse the input statement and build an
    expression tree. If the tree can be built, the statement is valid. Otherwise,
    it's invalid.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 幻影类型的一个常见用途是在一种类型安全的**构建器模式**中。（构建器模式是一段代码，帮助我们根据特定规则构建对象。）例如，我们可能想要构建语法上有效的
    SQL 语句。做到这一点的一种方法是有这样一个验证函数，它接受一个输入 SQL 语句，并在运行时决定它是否遵循 SQL 语法规则。这个函数可能会尝试解析输入语句并构建一个表达式树。如果树可以构建，则语句有效。否则，它无效。
- en: Another way to approach this is to provide a set of functions that statically
    enforce that only syntactically valid statements can be created. The magic part
    of this is that we can tell the compiler exactly what the type parameter should
    be when it's not actually used in the type body. There's nothing in the type definition
    to contradict what we say, so the compiler must accept it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是提供一组函数，这些函数静态地强制只创建语法上有效的语句。这个方法的神奇之处在于，我们可以在类型体实际上没有使用类型参数时，告诉编译器类型参数应该是什么。类型定义中没有与我们的说法相矛盾的内容，因此编译器必须接受它。
- en: 'The following is a simplified example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简化的示例：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the sake of simplicity, we''re dealing with only the `select` and `from`
    clauses in this SQL builder module, explained as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们在这个 SQL 构建模块中只处理 `select` 和 `from` 子句，具体解释如下：
- en: We alias a couple of types to serve as documentation.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将几个类型别名为文档用途。
- en: This is the type with the phantom type parameter; to the module consumer, it
    looks like a normal parameterized type. Internally, it doesn't contain, or otherwise
    use, any values of its parameter type.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类型具有幻影类型参数；对于模块消费者来说，它看起来像是一个正常的参数化类型。内部，它不包含或以其他方式使用其参数类型的任何值。
- en: 'This function is the entry point into the build: it takes a column list and
    returns a partially constructed SQL statement. We can''t do anything with this
    returned value except feed it into the next function, `from`. Notice that the
    type parameters are literally the types of polymorphic variants named appropriately;
    they just act as tags.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数是构建的入口点：它接受一个列列表，并返回一个部分构建的 SQL 语句。我们无法对这个返回值做任何事情，除了将其输入到下一个函数 `from` 中。注意，类型参数实际上是适当命名的多态变体的类型；它们只是作为标签。
- en: 'The implementations of `select` and `from` are very simple: they just build
    normal strings in the form of syntactically valid SQL statements. The most interesting
    thing about them is that their types are enforced to take parameters such that
    they can only be called in a particular order: `select`, `from`, `print`.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`select` 和 `from` 的实现非常简单：它们只是构建形式为语法有效 SQL 语句的正常字符串。最有趣的是，它们的类型被强制接受参数，这样它们就只能以特定的顺序调用：`select`，`from`，`print`。'
- en: The `print` function is strikingly simple in that it just returns the built
    string. We can examine that and then pass it into an SQL engine to run.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`print` 函数非常简单，它只是返回构建的字符串。我们可以检查它，然后将其传递给 SQL 引擎运行。'
- en: We build a syntactically valid SQL statement by calling the functions in the
    right order, enforced by the type system, and we then output them to the terminal.
    Note that the `|>` operator is called **pipe-forward**, and it's used to feed
    the output of one function as the input of the next one. We'll cover common operators
    in the next chapter.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过按正确的顺序调用函数，并由类型系统强制执行，构建一个语法有效的 SQL 语句，然后将它们输出到终端。请注意，`|>` 操作符被称为 **pipe-forward**，它用于将一个函数的输出作为下一个函数的输入。我们将在下一章中介绍常见的操作符。
- en: 'The following code is the error we would have gotten if we''d tried to print
    an invalid SQL statement:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是如果我们尝试打印一个无效的 SQL 语句时可能会得到的错误：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This type error is saying that the `print` function expects a complete `ok`
    SQL statement, but has received only a `select` clause. The type parameters, working
    together with the module's functions, ensure that the SQL is constructed in the
    right way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型错误表示 `print` 函数期望一个完整的 `ok` SQL 语句，但只收到了一个 `select` 子句。类型参数与模块的函数一起工作，确保
    SQL 以正确的方式构建。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into Reason's parameterized types, learning about
    type parameters and how they expand types to become generic, some common parameterized
    types that we use in Reason, the compiler's restrictions on using parameterized
    types and mutation together, and how to force the same underlying type to look
    different to the compiler using phantom type parameters.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 Reason 的参数化类型，学习了类型参数以及它们如何扩展类型以成为泛型，我们在 Reason 中使用的常见参数化类型，编译器对使用参数化类型和突变的同时的限制，以及如何使用幻影类型参数强制相同的底层类型对编译器看起来不同。
- en: We also saw some instances of passing in functions as arguments to other functions,
    for example, `tryFind` and `List.map`. In the next chapter, we'll thoroughly cover
    functions and how Reason lets us treat them as first-class objects that we can
    pass around to allow our code to behave flexibly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了一些将函数作为参数传递给其他函数的例子，例如 `tryFind` 和 `List.map`。在下一章中，我们将彻底介绍函数以及 Reason
    如何让我们将它们作为一等对象处理，这样我们就可以在代码中传递它们，使代码的行为更加灵活。
