- en: Managing States with Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redux 管理状态
- en: Remember that, previously, we said that it is not good to have application states
    in multiple places, because it makes debugging much harder. Therefore, we moved
    states from the input components to the form components. But now that we have
    two forms, we once again have states in two places. Therefore, we need to move
    the states up again. The most ideal case is where our application has only one
    state store.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，之前我们说过，将应用程序状态放在多个地方是不好的，因为它会使调试变得非常困难。因此，我们将状态从输入组件移动到表单组件。但现在我们有两个表单，我们再次有两个地方有状态。因此，我们需要再次将状态向上移动。最理想的情况是，我们的应用程序只有一个状态存储。
- en: However, if we keep moving states up, and passing the relevant state properties
    down as props, it can be quite un-performant. Let's say a component is nested
    20 layers deep; for it to consume the state it needs, the state needs to have
    passed through 19 components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们继续将状态向上移动，并将相关的状态属性作为 props 传递下去，这可能会非常低效。假设一个组件嵌套了 20 层；为了消耗它所需的状态，状态需要通过
    19 个组件。
- en: Furthermore, let's say the same heavily nested component needs to change the
    state; it will have to call its `onChange` prop, prompting its parent to call
    its `onChange` prop, and so on, and so on. Having to call 20 `onChange` functions
    for every state change is ineffective.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设同一个深度嵌套的组件需要改变状态；它将不得不调用它的 `onChange` prop，提示其父组件调用其 `onChange` prop，等等。每次状态更改都需要调用
    20 个 `onChange` 函数是无效的。
- en: Luckily, people have faced the same issues before and have come up with **state
    management** libraries that address them. In this chapter, we will use the most
    popular state management library, **Redux**, to organize our state in a centralized
    manner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，人们之前已经面临过相同的问题，并提出了解决这些问题的 *state management* 库。在本章中，我们将使用最受欢迎的状态管理库，**Redux**，以集中化的方式组织我们的状态。
- en: 'By following this chapter, you will learn the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，你将学习以下内容：
- en: Different concepts in Redux, such as state **store**, **reducers**, **actions**
    and **dispatchers**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 中的不同概念，如状态 **store**、**reducers**、**actions** 和 **dispatchers**
- en: How to lift state up
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何提升状态
- en: State management tools
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态管理工具
- en: There are many state management libraries out there, with the two most popular
    being Redux and MobX.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有许多状态管理库，其中最受欢迎的是 Redux 和 MobX。
- en: Redux
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux
- en: In Redux, you keep the state of your application inside an object literal that
    belongs to a *store*. When the state needs to be changed, an *action* describing
    what has happened should be emitted.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redux 中，你将应用程序的状态保存在一个属于 *store* 的对象字面量中。当状态需要改变时，应该发出一个描述发生了什么的 *action*。
- en: 'Then, you''d define a set of *reducer* functions, each responding to different
    types of actions. The purpose of a reducer is to generate a new state object that’ll
    replace the last one:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会定义一组 *reducer* 函数，每个函数响应不同类型的动作。reducer 的目的是生成一个新的状态对象，将替换上一个状态对象：
- en: '![](img/84d96930-a7fa-486c-ac96-09b341d1e6a9.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84d96930-a7fa-486c-ac96-09b341d1e6a9.jpg)'
- en: This way, updating the state no longer requires calling 20 different `onChange`
    functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，更新状态不再需要调用 20 个不同的 `onChange` 函数。
- en: However, you'd still need to pass the state via the props of many components.
    There’s a way to mitigate this through the use of *selectors*; but more on that
    later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你仍然需要通过许多组件的 props 传递状态。有一种方法可以通过使用 *selectors* 来减轻这种情况；但关于这一点我们稍后再谈。
- en: MobX
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MobX
- en: 'Mobx incorporates functional reactive programming principles, and uses *observables*
    as its stores:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Mobx 集成了函数式响应式编程原则，并使用 *observables* 作为其存储：
- en: '![](img/3fc86d4c-d080-4f6d-a3f6-da156381b4fd.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fc86d4c-d080-4f6d-a3f6-da156381b4fd.jpg)'
- en: You can tag entities (for example, objects and arrays) as observables using
    the `@observable` decorator. You can also tag some functions with the `@computed`
    decorator to make it into a *derivation* or *reaction*. The `@computed` functions
    will be re-run each time the `@observable` store has changed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `@observable` 装饰器将实体（例如，对象和数组）标记为可观察的。你还可以使用 `@computed` 装饰器将一些函数标记为 *derivation*
    或 *reaction*。`@computed` 函数将在 `@observable` 存储每次更改时重新运行。
- en: Decorators are a proposed addition to ECMAScript, currently tracked at [github.com/tc39/proposal-decorators](https://github.com/tc39/proposal-decorators).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是 ECMAScript 的一个提议性添加，目前由 [github.com/tc39/proposal-decorators](https://github.com/tc39/proposal-decorators)
    跟踪。
- en: A derivation is a value that can be derived solely from the state. For example,
    we can make our `LoginPage` component a derivation of the state. When the state
    contains a token property, the user is already logged in and the `LoginPage` can
    display a message saying "You’re already logged in". When the state does not contain
    the token property, `LoginPage` will render the `LoginForm` component. What the
    `LoginPage` displays can be wholly derived from the value of the token property
    inside the state object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 派生值是从状态中唯一可以导出的值。例如，我们可以将我们的 `LoginPage` 组件作为状态的派生值。当状态包含令牌属性时，用户已经登录，`LoginPage`
    可以显示一条消息说“您已经登录”。当状态不包含令牌属性时，`LoginPage` 将渲染 `LoginForm` 组件。`LoginPage` 显示的内容可以完全从状态对象中令牌属性的值中导出。
- en: Reactions are events that are triggered whenever the state changes. For instance,
    if the stale state property of a news feed application changes to `true`, you
    may want to query the API to get fresh data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 反应是在状态更改时触发的事件。例如，如果一个新闻源应用的过时状态属性变为 `true`，你可能想查询 API 获取新鲜数据。
- en: Lastly, state changes are triggered by *actions*, which are events that mutate
    the state. In MobX, actions are simply JavaScript statements that update the state
    in some way.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，状态更改是由 *动作* 触发的，动作是改变状态的事件。在 MobX 中，动作只是以某种方式更新状态的 JavaScript 语句。
- en: Redux versus MobX
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux 与 MobX 的比较
- en: First and foremost, we must be clear that both Redux and MobX work well with
    React.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须明确，Redux 和 MobX 都与 React 工作得很好。
- en: Redux has a much bigger community, its developer tools are much more mature,
    and there is more support when integrating with other tools.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 拥有更大的社区，其开发者工具更加成熟，与其他工具集成时支持更多。
- en: Converting to Redux
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换到 Redux
- en: 'Let’s start by installing Redux:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装 Redux 开始：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There’s also an official React binding that provides the `connect` method that
    helps you connect a component to the store:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个官方的 React 绑定，它提供了 `connect` 方法，可以帮助你将组件连接到存储：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may also want to install the Redux DevTools ([https://github.com/reduxjs/redux-devtools](https://github.com/reduxjs/redux-devtools))
    as it'll make debugging with Redux much easier.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想安装 Redux DevTools ([https://github.com/reduxjs/redux-devtools](https://github.com/reduxjs/redux-devtools))，因为它会使使用
    Redux 调试变得更加容易。
- en: Creating the store
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储
- en: 'As mentioned previously, the entire state of the application is stored as a
    single object inside a construct called the *store*. The store is central to a
    Redux application, so let’s create it. Inside `src/index.jsx`, add the following
    lines:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应用程序的整个状态都存储在称为 *store* 的结构中的单个对象中。存储是 Redux 应用程序的核心，所以让我们创建它。在 `src/index.jsx`
    中添加以下行：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `createStore` method accepts three parameters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`createStore` 方法接受三个参数：'
- en: '`reducer` *function*: A function that takes in the current state and an action,
    and uses them to generate a new state.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reducer` *函数*：一个函数，它接受当前状态和一个动作，并使用它们生成一个新的状态。'
- en: '`initialState` *any*: The initial state. The `initialState` can be of any data
    type, but we will use an object literal here.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialState` *任何类型*：初始状态。`initialState` 可以是任何数据类型，但在这里我们将使用对象字面量。'
- en: '`enhancer` *function*: A function that takes in the current store, and modifies
    it to create a new, "enhanced" store. You may wish to use enhancers to implement
    middleware:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enhancer` *函数*：一个函数，它接受当前存储，并修改它以创建一个新的、"增强"的存储。你可能希望使用增强器来实现中间件：'
- en: '![](img/5ae39ed1-b9bf-4342-9214-19ec75bbac2c.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ae39ed1-b9bf-4342-9214-19ec75bbac2c.jpg)'
- en: At the moment, we’ll just focus on creating a store with a state, so we’re using
    a dummy reducer, which simply returns the state.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需关注创建一个带有状态的存储，所以我们使用一个虚拟的 reducer，它简单地返回状态。
- en: 'The store object has many methods, the most important of which are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 存储对象有许多方法，其中最重要的是：
- en: '`getState`: Gets the current state of the store'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState`: 获取存储的当前状态'
- en: '`dispatch`: Dispatches an action to the store'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch`: 向存储派发一个动作'
- en: '`subscribe`: Subscribe functions to run whenever the store’s state changes'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe`: 订阅函数，在存储的状态更改时运行'
- en: We will be using these three methods to implement our Redux integration.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这三种方法来实现我们的 Redux 集成。
- en: Lifting the state up
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升状态
- en: So let’s work on lifting the state up. Currently, we are holding the state in
    our two form elements. So let’s migrate those *local* states into the *central*
    state we’re keeping inside our Redux store.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们着手提升状态。目前，我们正在我们的两个表单元素中持有状态。所以，让我们将这些 *本地* 状态迁移到我们保持在我们 Redux 存储中的 *中心*
    状态。
- en: 'Remove the constructor methods inside the `LoginForm` and `RegistrationForm`
    components (these were only used to initialize the states), and update our `initialState`
    object to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从`LoginForm`和`RegistrationForm`组件中移除构造函数方法（这些方法仅用于初始化状态），并将我们的`initialState`对象更新如下：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we need to make this central state available to the components. We do
    this by passing the states down to the form components via the `Route` component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使这个中心状态对组件可用。我们通过将状态通过`Route`组件传递给表单组件来实现这一点：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are using `store.getState()` to get the current state of the store, and we
    are passing in only the relevant parts into the component.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`store.getState()`来获取存储的当前状态，并且我们只将相关部分传递到组件中。
- en: Note that we are using the render prop of `Route` instead of the component.
    The render prop is useful when you want to pass in in-scope variables without
    causing the component to unmount and re-mount.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用`Route`的渲染属性而不是组件。当你想要传入作用域变量而不导致组件卸载和重新挂载时，渲染属性非常有用。
- en: 'Then, we need to make sure that `ReactDOM.render` is called whenever the state
    changes, so the UI is a deterministic representation of our state. We do this
    by wrapping the `ReactDOM.render` call in a function, and invoking it each time
    the state changes by providing it as the argument to `store.subscribe`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要确保每当状态改变时调用`ReactDOM.render`，这样UI就成为了我们状态的确定性表示。我们通过将`ReactDOM.render`调用包装在一个函数中，并通过将状态变化时提供它作为`store.subscribe`的参数来调用它来实现这一点：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lastly, inside the `LoginForm` and `RegistrationForm` components, change every
    instance of `this.state` to `this.props`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`LoginForm`和`RegistrationForm`组件内部，将每个`this.state`实例更改为`this.props`。
- en: The UI is now a deterministic representation of our state.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 界面现在是我们状态的确定性表示。
- en: Save and run `yarn run serve` to serve this new version of our application.
    You’ll notice that when you type in the input box, the value of the input box
    doesn't change. This is because we haven’t dispatched an action that'll alter
    our state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行`yarn run serve`以启动我们应用程序的新版本。你会注意到，当你输入输入框时，输入框的值没有改变。这是因为我们没有派发一个会改变我们状态的动作。
- en: Try changing the value of `initialState.loginForm.email.value` and re-serve
    the application. You'll see that it is reflected in the form.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改`initialState.loginForm.email.value`的值，并重新启动应用程序。你会看到它在表单中得到了反映。
- en: Dispatching actions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 派发动作
- en: Now we have integrated with React to make our UI a deterministic representation
    of our state. However, as demonstrated when you tried typing in the input box,
    there’s no way for us to update the state. Let's change that now.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经集成了React，使我们的UI成为我们状态的确定性表示。然而，正如你在尝试在输入框中输入时所展示的，我们没有方法来更新状态。现在让我们来改变这一点。
- en: Just to recap, the way you change a state in Redux is by dispatching an action,
    and defining reducers that react to those actions and update the state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了回顾一下，你在Redux中改变状态的方式是通过派发一个动作，并定义响应这些动作并更新状态的reducer。
- en: 'Let’s start with a scenario where we are updating the state; for instance,
    when we type in the input box in one of the forms. At the moment, we are using
    the `handleInputChange` method to update the local state:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更新状态的场景开始；例如，当我们在一个表单的输入框中输入时。目前，我们正在使用`handleInputChange`方法来更新本地状态：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead, we want to update this event handler to dispatch an action.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们希望更新这个事件处理器来派发一个动作。
- en: 'An action is simply an object that describes the event that has occurred. It
    should be as concise as possible. After creating an action, you call the `dispatch`
    method on the store to dispatch the action. For instance, the action to dispatch
    after an input value changed in our `RegistrationForm` component would look like
    this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动作只是一个描述已发生事件的简单对象。它应该尽可能简洁。创建动作后，你需要在存储上调用`dispatch`方法来派发动作。例如，在`RegistrationForm`组件中输入值更改后派发的动作可能看起来像这样：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we removed the validation logic. This is because it does not describe
    the event that has occurred (the input value changed). This validation logic belongs
    in the reducer, which we will implement now.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们移除了验证逻辑。这是因为它没有描述已发生的事件（输入值已更改）。这个验证逻辑属于reducer，我们现在将实现它。
- en: Updating the state with the Reducer
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Reducer更新状态
- en: 'Update the dummy reducer function to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将虚拟reducer函数更新如下：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have migrated the validation logic here, and we are returning a new instance
    of the state. Because our state object has many layers, simply using `Object.assign`
    or the ES6 spread syntax would not be sufficient. Therefore, we are using an NPM
    package called `deepmerge` to perform the merge of our old and new states. So,
    make sure we are adding that package to our project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将验证逻辑迁移到这里，并且我们正在返回状态的新实例。由于我们的状态对象有很多层，仅仅使用 `Object.assign` 或 ES6 扩展语法是不够的。因此，我们正在使用一个名为
    `deepmerge` 的 NPM 包来执行旧状态和新状态的合并。所以，请确保我们将该包添加到我们的项目中：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Convert the rest of the `RegistrationForm` component to use Redux (that is,
    change the `handleRegistration` method), and then do the same for the `LoginForm`
    component.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `RegistrationForm` 组件的其余部分转换为使用 Redux（即，更改 `handleRegistration` 方法），然后对 `LoginForm`
    组件做同样的处理。
- en: Then, serve your application again, and it should work the same way as before.
    But always run `yarn run test:e2e` to make sure!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次运行你的应用程序，它应该和之前一样工作。但请始终运行 `yarn run test:e2e` 以确保无误！
- en: Connecting with React Redux
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Redux 连接
- en: So far, we’ve used `createStore` to create a new store, `store.getState` to
    get the state of the store, `store.dispatch` to dispatch actions that get processed
    by the reducer to alter the state, and finally `subscribe` to re-run our `render`
    function whenever the state changed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了 `createStore` 来创建一个新的 store，`store.getState` 来获取 store 的状态，`store.dispatch`
    来分发由 reducer 处理的动作以改变状态，最后使用 `subscribe` 来在状态改变时重新运行我们的 `render` 函数。
- en: 'We had to do all that by hand, but there’s a better alternative that simplifies
    this as well as adds many performance optimizations that prevents unnecessary
    re-renders. React Redux is the official binding of Redux for React. It provides
    a `connect` function that will replace the role of `store.subscribe`, reads from
    the Redux store’s state, and passes the relevant parts as props to the presentational
    components (for example, `Input` and `Button`). Let’s install it now:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不手动做所有这些，但有一个更好的替代方案，它简化了这一切，并添加了许多性能优化，以防止不必要的重新渲染。React Redux 是 Redux
    对 React 的官方绑定。它提供了一个 `connect` 函数，将取代 `store.subscribe` 的角色，从 Redux store 的状态中读取，并将相关的部分作为
    props 传递给展示组件（例如，`Input` 和 `Button`）。现在让我们安装它：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It works with React Redux like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 React Redux 的工作方式如下：
- en: You wrap the root component of the application with the `<Provider>` component.
    This makes the Redux store available to every component within the app.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将应用程序的根组件包裹在 `<Provider>` 组件中。这使得 Redux store 对应用中的每个组件都可用。
- en: Within each container component that needs to read from the state, you use the
    `connect` function to connect the component to the Redux store.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要从状态中读取的每个容器组件中，你使用 `connect` 函数将组件连接到 Redux store。
- en: Wrapping with the Provider component
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Provider 组件包裹
- en: First, remove the `store.subscribe` call from `src/index.jsx`. We no longer
    need this as `connect` will take care of subscribing to changes to the state.
    This also means we no longer need to wrap our `ReactDOM.render` call inside a
    function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从 `src/index.jsx` 中移除 `store.subscribe` 调用。由于 `connect` 将负责订阅状态的变化，我们不再需要这个。这也意味着我们不再需要在
    `ReactDOM.render` 调用内部包裹一个函数。
- en: Next, since we will be calling `connect` within each component, there’s no need
    to pass the store and the state properties as props. Therefore, in our `<Route>`
    components, switch back to using the component prop instead of `render`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于我们将在每个组件中调用 `connect`，因此不需要将 store 和 state 属性作为 props 传递。因此，在我们的 `<Route>`
    组件中，切换回使用 component prop 而不是 `render`。
- en: 'Most importantly, wrap our entire application with the `<Provider>` component,
    passing the store as its only prop:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，将我们的整个应用程序包裹在 `<Provider>` 组件中，将 store 作为其唯一的 prop 传递：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the store is available to all components within the app. To access the
    store’s state and to dispatch actions to the store, we’d need to use `connect`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，store 对应用中的所有组件都是可用的。要访问 store 的状态并向 store 分发动作，我们需要使用 `connect`。
- en: Connecting to the Redux store
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到 Redux store
- en: Now that we are not passing down the store and the state to the form components,
    we need to use `connect` to re-connect the component to the store.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在不再将 store 和 state 传递给表单组件，我们需要使用 `connect` 来重新连接组件到 store。
- en: 'The `connect` function has the following signature:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` 函数具有以下签名：'
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All arguments are optional, and are described next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数都是可选的，将在下面进行描述。
- en: mapStateToProps
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mapStateToProps
- en: If `mapStateToProps` is a function, then the component will subscribe to changes
    in the store’s state. When a change occurs, the `mapStateToProps` function will
    be invoked, and is passed the store’s entire updated state. The function should
    extract the parts of the state that are relevant to this component, and return
    them as an object literal. This object literal will then be merged with the props
    passed to the component and be available in its methods through `this.props`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `mapStateToProps` 是一个函数，那么组件将订阅存储状态的改变。当发生改变时，`mapStateToProps` 函数将被调用，并且传递存储的整个更新状态。该函数应该提取与该组件相关的状态部分，并将它们作为对象字面量返回。这个对象字面量然后将与传递给组件的属性合并，并通过
    `this.props` 在其方法中可用。
- en: 'For our `LoginForm` component, we only care about the `loginForm` property
    inside the state, and so replace our current export statement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `LoginForm` 组件，我们只关心状态中的 `loginForm` 属性，因此替换我们当前的导出语句：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如下：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Do the same for `RegistrationForm`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `RegistrationForm` 也做同样的处理。
- en: If a component does not need to read the state from the store, but needs to
    interact with the store in other ways (for example, dispatching an event), then
    you can use `null` or `undefined` for the `mapStateToProps` argument. The component
    would then no longer react to state changes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件不需要从存储中读取状态，但需要以其他方式与存储交互（例如，分发一个事件），那么你可以为 `mapStateToProps` 参数使用 `null`
    或 `undefined`。那么组件将不再对状态变化做出反应。
- en: The `connect` function itself returns a function that you can then use to wrap
    your component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` 函数本身返回一个函数，然后你可以使用这个函数来包装你的组件。'
- en: mapDispatchToProps
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`mapDispatchToProps`'
- en: While `mapStateToProps` allows a component to subscribe to a store's state changes,
    `mapDispatchToProps` allows a component to dispatch actions to the store.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `mapStateToProps` 允许组件订阅存储的状态变化，但 `mapDispatchToProps` 允许组件向存储分发动作。
- en: It is called with a reference to the store’s dispatch method, and should return
    an object where each key maps to a function that calls the dispatch method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过引用存储的 dispatch 方法被调用，并且应该返回一个对象，其中每个键映射到一个调用 dispatch 方法的函数。
- en: 'For instance, our `mapDispatchToProps` function may look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的 `mapDispatchToProps` 函数可能看起来像这样：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `handleInputChange` key will get merged into the component's props, and
    be available in the component’s methods as `this.props.handleInputChange`. And
    thus, we can update the `onChange` prop on our Input components to `onChange={this.props.handleInputChange}`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleInputChange` 键将被合并到组件的属性中，并在组件的方法中作为 `this.props.handleInputChange`
    可用。因此，我们可以将 Input 组件上的 `onChange` 属性更新为 `onChange={this.props.handleInputChange}`。'
- en: Decoupling Redux from components
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦 Redux 与组件
- en: 'You may be thinking, "This looks extremely convoluted, why can''t I just pass
    the dispatch as the props and call `this.props.dispatch()` in my event handlers?
    Similar to what we did before?” Like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“这看起来非常复杂，为什么我不能直接将 dispatch 作为属性传递，并在事件处理程序中调用 `this.props.dispatch()`？就像我们之前做的那样？”如下所示：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Whilst that is certainly possible, it couples our component to Redux. Outside
    Redux, the concept of a dispatch method does not exist. Therefore, using `dispatch`
    within our component’s methods effectively ties the component to the Redux environment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是可能的，但这将我们的组件耦合到 Redux。在 Redux 之外，不存在 dispatch 方法的概念。因此，在我们的组件方法中使用 `dispatch`
    有效地将组件绑定到 Redux 环境。
- en: By using the `mapDispatchToProps` function, we are decoupling the component
    from Redux. Now, `this.props.handleInputChange` is just a function we’ve passed
    down to the component. If we later decide not to use Redux, or we want to re-use
    the component in a non-Redux environment, we can simply pass down a different
    function, without changing the component code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `mapDispatchToProps` 函数，我们解耦了组件与 Redux。现在，`this.props.handleInputChange`
    只是我们传递给组件的函数。如果我们后来决定不使用 Redux，或者我们想在非 Redux 环境中重用该组件，我们只需传递一个不同的函数，而无需更改组件代码。
- en: 'Similarly, we can pull the dispatch call from the `handleLogin` event handler
    into `mapDispatchToProps`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将 `handleLogin` 事件处理程序中的 dispatch 调用拉入 `mapDispatchToProps`：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To connect the dots, pass `mapStateToProps` and `mapDispatchToProps` into `connect`.
    This returns with a function that you can use to wrap the `LoginForm` component:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接这些点，将 `mapStateToProps` 和 `mapDispatchToProps` 传递给 `connect`。这将返回一个函数，你可以用它来包装
    `LoginForm` 组件：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the original component (`LoginForm`) is not mutated. Instead, a newly-wrapped
    component is created and exported.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，原始组件（`LoginForm`）没有被修改。相反，创建了一个新的包装组件并导出。
- en: 'Then use `handleSuccess` in the `handleLogin` event handler:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`handleLogin`事件处理器中使用`handleSuccess`：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Repeat the same steps for `RegistrationForm`. As always, run the tests to ensure
    there are no typos or mistakes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`RegistrationForm`重复相同的步骤。一如既往，运行测试以确保没有错别字或错误。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have migrated our code to use Redux to manage our state.
    Having a single state store makes things much easier to manage and maintain.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经将代码迁移到使用Redux来管理我们的状态。拥有一个单一的状态存储使得事情的管理和维护变得更加容易。
- en: We have now finished our mini-tour of the front-end world. In the next chapter,
    we will look at how to use **Docker** to containerize our applications and make
    each service more independent and self-contained.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了前端世界的迷你之旅。在下一章中，我们将探讨如何使用**Docker**来容器化我们的应用程序，并使每个服务更加独立和自包含。
