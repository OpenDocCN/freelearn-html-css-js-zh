- en: Chapter 14. Deploying and Scaling the SPA
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章。部署和扩展 SPA
- en: Having built the core functionality of the application, now it's time to move
    the SPA into a production-like environment that is accessible from the Internet.
    For this, we will be using **Platform as a Service** (**PaaS**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了应用程序的核心功能之后，现在是将 SPA 移入一个类似生产环境，并且可以从互联网访问的环境中。为此，我们将使用 **平台即服务**（**PaaS**）。
- en: PaaS is a type of a cloud-based service that allows developers to launch applications
    on managed infrastructure. Before PaaS, developers or operations engineers had
    to perform a lot of setup and maintenance tasks, such as provisioning hardware,
    installing operating software, and insuring uptime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: PaaS 是一种基于云的服务，允许开发者在其管理的环境中启动应用程序。在 PaaS 之前，开发人员或运维工程师必须执行许多设置和维护任务，例如提供硬件、安装操作系统软件和确保正常运行时间。
- en: There are a number of PaaS providers, but I have chosen Heroku. One reason for
    this is that you can stand up an application for free on a sandbox, which will
    allow you to experiment on the app and scale up when you're ready. Deploying an
    app to Heroku is also quite easy, as, you'll see, Heroku uses Git to deploy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 PaaS 提供商，但我选择了 Heroku。一个原因是你可以免费在沙盒中启动一个应用程序，这将允许你在准备好时对应用程序进行实验和扩展。将应用程序部署到
    Heroku 也相当简单，因为，正如你将看到的，Heroku 使用 Git 进行部署。
- en: We will also set up a production database in the cloud. We will use MongoLab,
    which also has a free sandbox tier with enough memory to get started.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在云中设置一个生产数据库。我们将使用 MongoLab，它还提供了一个带有足够内存的免费沙盒层，可以开始使用。
- en: 'We''ll finish this chapter by briefly discussing the following concerns for
    scaling your application:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要讨论以下扩展应用程序的关注点来结束本章：
- en: Packaging the application with the Grunt task runner
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Grunt 任务运行器打包应用程序
- en: Setting up a production database online
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线设置生产数据库
- en: Moving the SPA into the cloud
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 SPA 移入云中
- en: Considerations for scaling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展时的考虑
- en: Packaging for deployment
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署打包
- en: Our application is still quite small and not complicated, but we will begin
    by setting up an automated process for packaging our application up for deployment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序仍然相当小且不复杂，但我们将首先设置一个自动化流程来打包我们的应用程序以便部署。
- en: Setting up Grunt for deployment
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Grunt 以进行部署
- en: We will use the Grunt JavaScript task runner to set up some automated tasks
    to package up our files for deployment. There's not a lot for us to do here, but
    you'll get a sense of what can be done and be able to explore the rich selection
    of Grunt plugins to further customize your automated tasks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Grunt JavaScript 任务运行器设置一些自动化任务来打包我们的文件以便部署。这里我们不需要做很多事情，但你将了解可以做什么，并能够探索丰富的
    Grunt 插件来进一步自定义你的自动化任务。
- en: Installing Grunt
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Grunt
- en: 'If you haven''t already, install the grunt CLI using NPM:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装，请使用 NPM 安装 grunt CLI：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For Grunt to run correctly, you''ll need two files in your project root directory.
    The first one is a `package.json` file to declare dependencies. You already have
    one in your root directory. The next file you need is `Gruntfile.js`, where you
    will load grunt modules and configure the tasks that Grunt can run. Go ahead and
    create this file in your root directory and add the following code to it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Grunt 正确运行，你需要在项目根目录中放置两个文件。第一个文件是一个 `package.json` 文件，用于声明依赖项。你已经在根目录中有一个了。下一个你需要的是
    `Gruntfile.js` 文件，你将在其中加载 grunt 模块并配置 Grunt 可以运行的任务。请创建这个文件在你的根目录中，并添加以下代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the framework for `Gruntfile`. We export a function that expects to
    receive a reference to the grunt object as its argument. Inside that function,
    we call the `grunt.initConfig()` function, passing it a configuration object.
    Currently, that configuration object has a single property, that is, a reference
    to the `package.json` file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Gruntfile` 的框架。我们导出一个函数，该函数期望接收一个对 grunt 对象的引用作为其参数。在这个函数内部，我们调用 `grunt.initConfig()`
    函数，并传递一个配置对象。目前，这个配置对象只有一个属性，即对 `package.json` 文件的引用。
- en: The power of Grunt comes from employing any number of the thousands of plugins
    made available by its active community. At the time of writing this book, there
    were over 5,000 Grunt plugins listed at [http://gruntjs.com/plugins](http://gruntjs.com/plugins).
    If there's some automated task you want to run, chances are that somebody's already
    created a plugin to support it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 的强大之处在于可以利用其活跃社区提供的成千上万的插件。在撰写本书时，[http://gruntjs.com/plugins](http://gruntjs.com/plugins)
    上列出了超过 5,000 个 Grunt 插件。如果你想要运行某个自动化任务，很可能已经有某人创建了一个插件来支持它。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Grunt plugins, which are officially maintained, are always named `grunt-contrib-X`.
    You can generally trust the quality of these plugins, although there are many
    great unofficially maintained plugins.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 官方维护的 Grunt 插件通常命名为 `grunt-contrib-X`。你可以一般地信任这些插件的质量，尽管有许多优秀的非官方维护插件。
- en: Installing Grunt plugins
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Grunt 插件
- en: 'A nice feature of Grunt is that plugins are installed using NPM. Let''s install
    a few useful plugins that we will use:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 的一个不错的特点是插件使用 NPM 安装。让我们安装一些我们将要使用的有用插件：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We installed Grunt plugins for `clean`, `uglify`, `htmlmin`, and `copy` tasks.
    Clean will clean files out of a directory. Uglify minimizes JavaScript files.
    `Htmlmin` minifies HTML files. The `Copy` task copies files. The `--save-dev`
    flag will add these modules to your `package.json` file as d`evdependecies`. You
    need these packages only in your development environment, not in your production
    environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `clean`、`uglify`、`htmlmin` 和 `copy` 任务安装了 Grunt 插件。Clean 会清理目录中的文件。Uglify
    最小化 JavaScript 文件。`Htmlmin` 最小化 HTML 文件。`Copy` 任务复制文件。`--save-dev` 标志会将这些模块添加到你的
    `package.json` 文件中作为 `devdependencies`。你只需要在开发环境中使用这些包，而不是在生产环境中。
- en: Before we go any further, let's create a `dist` folder in the root of our project.
    This is where our production-ready assets will be found.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们在我们的项目根目录中创建一个 `dist` 文件夹。我们的生产就绪资产将在这里找到。
- en: Configuring the Gruntfile
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 `Gruntfile`
- en: 'Now, we need to modify our `Gruntfile` to load the plugins:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改我们的 `Gruntfile` 以加载插件：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we use a call to `grunt.loadNPMTasks()` for each Grunt plugin we want
    to load, passing it the name of the module to be loaded.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为每个要加载的 Grunt 插件调用 `grunt.loadNPMTasks()`，并传递要加载的模块名称。
- en: 'Next, we need to configure each of our tasks inside our `Gruntfile`. Note that
    every plugin will have its own configuration properties. Consult the documentation
    for each plugin you use to see how it is configured. Open up your `Gruntfile.js`
    and make the following edits:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的 `Gruntfile` 中配置每个任务。请注意，每个插件都将有自己的配置属性。请查阅你使用的每个插件的文档，以了解其配置方式。打开你的
    `Gruntfile.js` 并进行以下编辑：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first change we made was adding a number of task configuration properties
    inside the `grunt.InitConfig()` function. Each of these properties decorates the
    grunt object when grunt is run and tells the various tasks how to execute.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一个更改是在 `grunt.InitConfig()` 函数内部添加了一些任务配置属性。当运行 grunt 时，这些属性会装饰 grunt 对象，并告诉各种任务如何执行。
- en: The first task configuration is for clean. This task is configured to delete
    all the files and folders in the `dist` folder. The clean configuration takes
    an array of paths; the syntax of the path definition is pretty standard for the
    `grunt-contrib` plugins. For more information on Grunt's URL globbing, refer to
    [http://gruntjs.com/configuring-tasks#globbing-patterns](http://gruntjs.com/configuring-tasks#globbing-patterns).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务配置是为 `clean`。此任务配置为删除 `dist` 文件夹中的所有文件和文件夹。clean 配置接受路径数组；路径定义的语法对于 `grunt-contrib`
    插件来说相当标准。有关 Grunt 的 URL 谓词的信息，请参阅 [http://gruntjs.com/configuring-tasks#globbing-patterns](http://gruntjs.com/configuring-tasks#globbing-patterns)。
- en: The other task configurations are similar, but take objects, and can include
    some options, a target, and lists of files to operate on. For configuration options
    for grunt plugins, find the plugin you're interested in at [http://gruntjs.com/plugins](http://gruntjs.com/plugins)
    and click on the name of the plugin to get the documentation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其他任务配置类似，但接受对象，可以包括一些选项、一个目标和要操作文件的列表。有关 grunt 插件的配置选项，请访问 [http://gruntjs.com/plugins](http://gruntjs.com/plugins)，点击插件名称以获取文档。
- en: The next section after the configuration is where we load each plugin that will
    be used by this `Gruntfile`. We do this by passing the name of the plugin as an
    argument to the `grunt.loadNPMTasks()` function. Grunt will look for these plugins
    in our `node_modules` folder. If we were to use custom tasks, such as the one
    we wrote ourselves, we could load them using calls to `grunt.loadTasks()`, passing
    in a path.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 配置之后，下一节是加载此 `Gruntfile` 将要使用的每个插件的地方。我们通过将插件名称作为参数传递给 `grunt.loadNPMTasks()`
    函数来完成此操作。Grunt 将在我们的 `node_modules` 文件夹中查找这些插件。如果我们想使用自定义任务，例如我们自己编写的任务，我们可以通过传递路径的调用
    `grunt.loadTasks()` 来加载它们。
- en: The last thing we did was to register a task. We did this by calling `grunt.registerTask()`.
    This took two arguments. The first is a string, the name of the task. In our case,
    this is the default task. Grunt requires that all `Gruntfiles` register a default
    task. The next argument is an array of strings containing the name of any tasks
    and targets required to run as part of this task.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后做的事情是注册一个任务。我们通过调用 `grunt.registerTask()` 来完成这个操作。这需要两个参数。第一个是一个字符串，即任务的名称。在我们的例子中，这是默认任务。Grunt
    要求所有 `Gruntfiles` 都必须注册一个默认任务。下一个参数是一个字符串数组，包含作为此任务一部分运行所需的任何任务和目标的名称。
- en: Right now, we are just running tasks without listing any individual targets.
    If we had targets we wished to run on the tasks, the syntax would be `task:target`.
    For example, if we defined a test target for our `uglify` task, we would register
    it in our array as `['uglify:test']`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只是在运行任务而没有列出任何单独的目标。如果我们想在任务上运行目标，语法将是 `task:target`。例如，如果我们为我们的 `uglify`
    任务定义了一个测试目标，我们将在数组中注册它为 `['uglify:test']`。
- en: Running Grunt
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 Grunt
- en: Running grunt couldn't be simpler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `grunt` 简单得不能再简单了。
- en: 'First, ensure that the grunt CLI is installed, as shown in the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保已经安装了 grunt CLI，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From the directory where your `Gruntfile` lives, simply run grunt followed
    by the name of the task you wish to run. To run the default task, you can omit
    the `taskname`. Now, let''s try running grunt:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从存放你的 `Gruntfile` 的目录中，只需运行 `grunt` 后跟你要运行的任务的名称。要运行默认任务，你可以省略 `taskname`。现在，让我们尝试运行
    `grunt`：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you look in your `dist` folder now, you'll notice it's no longer empty. Grunt
    has cleaned it, moved a bunch of files in, and minified some things. Note that
    the first time you run this with an empty `dist` folder, the clean task will report
    0 paths cleaned. When you run this subsequently, you should see the number of
    files in the `dist` folder actually being cleaned.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在查看你的 `dist` 文件夹，你会注意到它不再为空。Grunt 已经清理了它，移动了一些文件，并对一些内容进行了压缩。请注意，第一次你在空的
    `dist` 文件夹中运行此操作时，清理任务会报告 0 个路径被清理。当你随后再次运行时，你应该会看到 `dist` 文件夹中实际被清理的文件数量。
- en: Another thing you might notice is that each task is running a target. Copy is
    running main, `uglify` is running `my_target`. By default, if no target is specified,
    Grunt will run the first-defined target.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，每个任务都在运行一个目标。复制正在运行 `main`，`uglify` 正在运行 `my_target`。默认情况下，如果没有指定目标，Grunt
    将运行第一个定义的目标。
- en: 'If you open up your `dist/public/javascripts/giftapp.js` file, you should see
    that it has been minified:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开你的 `dist/public/javascripts/giftapp.js` 文件，你应该会看到它已经被压缩：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Code minification makes our files smaller and somewhat harder to read. It can
    improve the files' performance on the web significantly. For a more significant
    performance improvement, we might have to look into concatenating script files
    and use tools such as the Closure compiler to make them even more efficient.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码压缩使我们的文件更小，并且稍微难以阅读。它可以显著提高文件在网页上的性能。为了获得更显著的性能提升，我们可能需要考虑将脚本文件连接起来，并使用像 Closure
    compiler 这样的工具使它们更加高效。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no need to minify server-side JavaScript code. The main reason for
    minification is reduced data transfer with a client.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要压缩服务器端 JavaScript 代码。压缩的主要原因是为了减少与客户端的数据传输。
- en: Setting up our config for production
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的生产配置
- en: One issue we're going to run into when moving our application into a production
    environment is that there will be a difference between our development and our
    production environment. Right now, all our database references point to our local
    MongoDB database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将应用程序迁移到生产环境时，我们将遇到一个问题，那就是我们的开发和生产环境之间会有所不同。目前，我们所有的数据库引用都指向我们的本地 MongoDB
    数据库。
- en: We're going to use Git to push our files to production later on, and we also
    don't want to store configuration variables in Git repositories. We also don't
    want to store `node_modules` in Git or push them to production environment since
    they can be fetched on the fly using our `package.json` file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Git 将我们的文件推送到生产环境，我们也不想在 Git 仓库中存储配置变量。我们也不想在 Git 中存储 `node_modules` 或将其推送到生产环境，因为它们可以通过我们的
    `package.json` 文件即时获取。
- en: Create a .gitignore file
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 .gitignore 文件
- en: 'In the root of your project, create a file called `.gitignore`. This file contains
    a list of files and paths that we don''t want Git to store or track:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目根目录中创建一个名为 `.gitignore` 的文件。此文件包含一个列表，其中包含我们不希望 Git 存储或跟踪的文件和路径：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Line by line we just list the files and folders we want Git to ignore. The first
    is `node_modules`. Again, there's no reason to store these. I then want to ignore
    anything in my `config` folder, which contains sensitive information.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一行一行地列出我们希望 Git 忽略的文件和文件夹。第一个是 `node_modules`。再次强调，没有理由存储这些文件。接下来，我想忽略 `config`
    文件夹中的任何内容，其中包含敏感信息。
- en: In here, I ignore `.idea`. You may or may not have this folder. This is a folder
    created by my development environment to store project information. I'm using
    `JetBrains` IDE for JavaScript called Webstorm. Whatever you're using, you'll
    want to exclude your IDE files, if any. Finally, I explicitly exclude `dist/config`,
    which will be a copy of `config`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我忽略了 `.idea` 文件夹。你可能没有这个文件夹。这是一个由我的开发环境创建的文件夹，用于存储项目信息。我使用的是 `JetBrains`
    的 JavaScript IDE Webstorm。无论你使用什么，你都会想要排除你的 IDE 文件，如果有的话。最后，我明确排除了 `dist/config`，它将是
    `config` 的一个副本。
- en: Create an environment-based configuration module
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基于环境的配置模块
- en: What we want is for the configuration to be handled dynamically. If you're in
    the development environment, use our configuration for your local machine. If
    you're in the production environment, you would want to use appropriate configuration
    variables for that environment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望配置能够动态处理。如果你在开发环境中，使用你本地机器的配置。如果你在生产环境中，你将想要使用该环境的适当配置变量。
- en: The safest way to do that in the production environment setting up environment
    variables that can be read in the application. We will set them up when we set
    up our deployment environment, but we can set the stage now.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境设置中，最安全的方法是在应用程序中设置可读的环境变量。我们将在设置部署环境时设置它们，但现在我们可以设置阶段。
- en: 'In your root `giftapp` folder, create a new file called `appconfig.js`, using
    the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的根 `giftapp` 文件夹中，创建一个名为 `appconfig.js` 的新文件，使用以下代码：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We first check to see whether there is a `NODE_ENV` environment variable and
    whether it is set to *production*. If it is, we will have to grab our database
    and our Facebook and Twitter authorization information from environment variables.
    We will set up our environment variables later on when we set up our deployment
    environment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否存在 `NODE_ENV` 环境变量以及它是否设置为 *production*。如果是，我们将不得不从环境变量中获取我们的数据库以及 Facebook
    和 Twitter 的授权信息。我们将在设置部署环境时设置环境变量。
- en: If our test fails, we assume we're in our development environment and then manually
    set our database. We grab our `authorization.js` file out of the `config` directory
    and use that to set up our Twitter and Facebook authorization variables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的测试失败，我们假设我们处于开发环境，然后手动设置我们的数据库。我们从 `config` 目录中获取 `authorization.js` 文件并使用它来设置
    Twitter 和 Facebook 的授权变量。
- en: Using the new config file
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用新的配置文件
- en: 'Now, we need to employ our configuration file. Open up your main `app.js` file
    and make a couple of edits:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使用我们的配置文件。打开你的主 `app.js` 文件并进行一些编辑：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we load our `appconfig.js` file and assign it to the variable `appconfig`.
    Remember, our `appconfig` module exports a function. We need to invoke that function
    to run the code and get access to the dynamically set properties. So, we invoke
    `appconnfig()` and assign the returned object to the variable `config`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载我们的 `appconfig.js` 文件并将其分配给变量 `appconfig`。记住，我们的 `appconfig` 模块导出一个函数。我们需要调用这个函数来运行代码并访问动态设置的属性。因此，我们调用
    `appconnfig()` 并将返回的对象分配给变量 `config`。
- en: Finally, we use `config.db` in the call to `monk()` to create the database object.
    You should now be able to start up your database and server, and there should
    be no difference in the functionalities.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在调用 `monk()` 时使用 `config.db` 来创建数据库对象。你现在应该能够启动你的数据库和服务器，并且功能上应该没有差异。
- en: 'Next, we need to use the `appconfig` in our passport `OAuth` strategies. Let''s
    start with `passport`/`facebook.js`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的 passport `OAuth` 策略中使用 `appconfig`。让我们从 `passport`/`facebook.js`
    开始：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once again, we require `appconfig.js` from the root of our application. We then
    invoke the returned function and assign it to the variable `auth`. We should require
    no additional changes, and restarting our server should show that our changes
    have worked.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从我们应用程序的根目录中引入 `appconfig.js`。然后我们调用返回的函数并将其分配给变量 `auth`。我们不应该需要额外的更改，重启我们的服务器应该会显示我们的更改已经生效。
- en: 'Finally, let''s do the same thing to our `passport/twitter.js` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们对 `passport/twitter.js` 文件做同样的事情：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we've made exactly the same change to the Twitter authorization
    strategy file. Once again, give it a test and it should work exactly the same
    way.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们对 Twitter 授权策略文件进行了完全相同的修改。再次测试，它应该会以完全相同的方式工作。
- en: Setting up a cloud database
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置云数据库
- en: Our SPA will soon live in the cloud, and it needs to be connected to a database.
    Moving our application to the cloud requires our database also to be accessible
    from the Web. Having a database running on your local machine isn't going to cut
    it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单页应用（SPA）很快就会在云端运行，并且需要连接到一个数据库。将我们的应用迁移到云端需要我们的数据库也能从网络上访问。在本地机器上运行数据库是行不通的。
- en: There are a number of cloud-based database services, but I have found that MongoLab
    is one of the easiest to set up, use, and maintain. They offer a free sandbox
    database, which is perfect for development and experimentation. For production-level
    applications, you'd want to look into a higher subscription rate.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有众多基于云的数据库服务，但我发现 MongoLab 是最容易设置、使用和维护的之一。他们提供免费的沙盒数据库，非常适合开发和实验。对于生产级应用，你可能需要考虑更高的订阅率。
- en: The PaaS we will use to deploy our application, Heroku, plays really well with
    MongoLab, and even offers Mongolab as a one-click add-on. We will set things up
    manually for now so you can learn how things work a little better.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于部署应用的 PaaS 平台 Heroku 与 MongoLab 配合得非常好，甚至提供一键添加 Mongolab 的服务。现在我们先手动设置，这样你可以更好地了解事情是如何运作的。
- en: Creating a MongoLab account
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 MongoLab 账户
- en: 'The first thing you need to do is to set up your account on MongoLab. This
    couldn''t be simpler. Go to [https://mongolab.com/signup/](https://mongolab.com/signup/)
    and fill in the form. After you''ve signed up, you''ll be taken to a dashboard
    that looks like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是在 MongoLab 上设置你的账户。这非常简单。访问 [https://mongolab.com/signup/](https://mongolab.com/signup/)
    并填写表格。注册后，你将被带到如下所示的仪表板：
- en: '![Creating a MongoLab account](img/image_14_001.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![创建 MongoLab 账户](img/image_14_001.jpg)'
- en: Currently, I have two databases provisioned in my account. If you've just signed
    up, you won't see anything here. It's from this dashboard that you can set up
    and manage databases and your account.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在我的账户中，我配置了两个数据库。如果你刚刚注册，这里将不会显示任何内容。你可以从这个仪表板设置和管理数据库以及您的账户。
- en: Creating a database
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库
- en: 'Right now, you have an account on MongoLab, but you don''t have a database.
    We need to create a new database. Fortunately, MongoLab makes this super easy
    for us. On your dashboard, click on the button that says **Create New**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经在 MongoLab 上有一个账户，但没有数据库。我们需要创建一个新的数据库。幸运的是，MongoLab 让我们做这件事变得非常简单。在您的仪表板上，点击标记为
    **创建新** 的按钮：
- en: '![Creating a database](img/image_14_002.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据库](img/image_14_002.jpg)'
- en: On the Create a new subscription page, there are a lot of different choices
    for setting up a new deployment. We want to set up a sandbox deployment, which
    is free and will give you 500 MB of storage. I chose Amazon Web Services for storage
    in the US East region, and **Single-node** | **Sandbox**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新订阅页面，有许多不同的选择来设置新的部署。我们想要设置一个沙盒部署，它是免费的，并且会给你 500 MB 的存储空间。我选择了美国东部地区的亚马逊云服务，并选择了
    **单节点** | **沙盒**。
- en: Scroll down to the bottom of the page, name your database and click on the button
    marked Create new MongoDB deployment. I named mine `giftapp`. Voila! You are now
    the proud owner of a shiny and new cloud-based MongoDB deployment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到页面底部，命名您的数据库，然后点击标记为“创建新的 MongoDB 部署”的按钮。我命名为 `giftapp`。哇！你现在已经是这个闪亮的新云基础
    MongoDB 部署的骄傲所有者了。
- en: Setting up a user to access the database
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置用户访问数据库
- en: 'We can''t connect to the database from our application yet. To do so, you''ll
    need to set up a username and password for the database access. From your dashboard,
    click on the name of your new database, and on the next screen, click on the **Users**
    tab:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还没有从我们的应用连接到数据库。要做到这一点，你需要为数据库访问设置用户名和密码。从您的仪表板，点击您的新数据库名称，然后在下一个屏幕上点击
    **用户** 选项卡：
- en: '![Setting up a user to access the database](img/image_14_003.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![设置用户访问数据库](img/image_14_003.jpg)'
- en: 'From here, make note of the standard MongoDB URI, which will include the username
    and password you''re about to set up. Click on **Add database user**:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，记下标准的 MongoDB URI，它将包括你即将设置的用户名和密码。点击 **添加数据库用户**：
- en: '![Setting up a user to access the database](img/image_14_004.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![设置用户访问数据库](img/image_14_004.jpg)'
- en: You'll get the preceding pop-up window. Fill it out; do not check read-only.
    Now, you have a database and a user who can access the data. Make a note of the
    URI; you will have to use this to access this database. If you want to test it
    out, you can plug it into your `appconfig` file in place of your local database.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到前面的弹出窗口。填写它；不要勾选只读。现在，你有一个可以访问数据的数据库和用户。记下 URI；你将需要使用它来访问这个数据库。如果你想测试它，你可以将其插入到你的
    `appconfig` 文件中，以替换你的本地数据库。
- en: Deploying the application to Heroku
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Heroku
- en: Now, we have most of the pieces in place for web deployment. We will deploy
    our app to Heroku, a PaaS that supports Node.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为 Web 部署准备好了大部分组件。我们将把我们的应用程序部署到支持 Node 的 PaaS 平台 Heroku。
- en: Getting ready to use Heroku
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备使用 Heroku
- en: There are just a few steps that are required to deploy your application to Heroku.
    You'll have to install Git, set up a Heroku account, create a new project on Heroku,
    and then it will be ready for deploying.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的应用程序部署到 Heroku 需要几个简单的步骤。你需要安装 Git、设置 Heroku 账户、在 Heroku 上创建一个新的项目，然后它就准备好部署了。
- en: Setting up Git
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 Git
- en: Deployment to Heroku is done using Git, so you will need to have it installed.
    If you don't already have Git installed, go to [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
    and follow the instructions for your operating system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到 Heroku 使用 Git 完成，因此你需要安装它。如果你还没有安装 Git，请访问 [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
    并按照你操作系统的说明进行操作。
- en: 'After you have Git installed, you need to initialize a Gitrepository in your
    `giftapp` folder. From the root, in your command line, type the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Git 之后，你需要在 `giftapp` 文件夹中初始化一个 Git 仓库。从根目录开始，在你的命令行中输入以下命令：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After you have initialized Git, you''ll want to add all your files and commit
    them to your repo:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 Git 之后，你想要添加所有文件并将它们提交到你的仓库中：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's it for now.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就到这里了。
- en: Signing up for a Heroku account
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册 Heroku 账户
- en: 'The next thing you need to do is to sign up for a Heroku account, if you don''t
    already have one. Like MongoLab, this is simple. Go to [https://signup.heroku.com/login](https://signup.heroku.com/login)
    and fill out the form shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步你需要做的是注册一个 Heroku 账户，如果你还没有的话。就像 MongoLab 一样，这个过程很简单。访问 [https://signup.heroku.com/login](https://signup.heroku.com/login)
    并填写以下截图所示的表单：
- en: '![Signing up for a Heroku account](img/image_14_005.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![注册 Heroku 账户](img/image_14_005.jpg)'
- en: Now you're all set with a free Heroku account.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了一个免费的 Heroku 账户。
- en: Installing the HerokuToolbelt
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 HerokuToolbelt
- en: Heroku provides a CLI app for managing apps called HerokuToolbelt. You'll need
    to install this to deploy your application to Heroku. To install for your operating
    system, go to [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/) and
    follow the instructions for your operating system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 提供了一个名为 HerokuToolbelt 的 CLI 应用程序来管理应用程序。你需要安装这个工具来将你的应用程序部署到 Heroku。要为你的操作系统安装，请访问
    [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/) 并按照你操作系统的说明进行操作。
- en: 'Once installed, you can log in to Heroku from your command line:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以从命令行登录 Heroku：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, you're good to go.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始了。
- en: Setting up the Heroku project
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Heroku 项目
- en: 'Now we need to actually set up your `giftapp` project to be deployed to Heroku.
    In your terminal, make sure you are in the root directory of your `giftapp` project:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实际设置你的 `giftapp` 项目以便部署到 Heroku。在你的终端中，确保你位于 `giftapp` 项目的根目录：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The create command has created a Heroku app for us. In this case, the app will
    be accessed at [https://guarded-lake-23534.herokuapp.com/](https://guarded-lake-23534.herokuapp.com/).
    Navigating to that URL now won't be very exciting, since we haven't actually deployed
    anything yet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命令为我们创建了一个 Heroku 应用程序。在这种情况下，应用程序将通过 [https://guarded-lake-23534.herokuapp.com/](https://guarded-lake-23534.herokuapp.com/)
    访问。现在导航到该 URL 不会很有趣，因为我们还没有实际部署任何内容。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Heroku generates a random app name for you. You can pass an app name you would
    like as part of the call to create, and, as long as it's unique, your app will
    live there. You can also point a custom domain to your Heroku app, but only if
    you have a paid account-refer to the Heroku documentation for more information.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 为你生成一个随机的应用程序名称。你可以在创建调用中传递你想要的应用程序名称，只要它是唯一的，你的应用程序就会在那里运行。你也可以将自定义域名指向你的
    Heroku 应用程序，但前提是你有一个付费账户——请参考 Heroku 文档获取更多信息。
- en: The second thing the create command has done is to create a remote Git repository
    for us. This is how we will get our files deployed. There are a couple more steps
    we need to perform in order to deploy our app.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命令所做的第二件事是为我们创建了一个远程Git仓库。这就是我们将如何部署我们的文件。我们还需要执行几个额外的步骤来部署我们的应用。
- en: Deploying to Heroku
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到Heroku
- en: Now that most of the setup work is done, it's time to take the final steps to
    move our application online.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大部分设置工作已经完成，是时候采取最后一步将我们的应用上线了。
- en: Defining a Procfile
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义Procfile
- en: We need a **Procfile** to tell Heroku what to run when we deploy. A Procfile
    is a file that tells the dynos at Heroku which commands to run. For Heroku to
    read this file, you must name the file Procfile (without any extension) and include
    it in the top-level directory of your project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个**Procfile**来告诉Heroku在部署时运行什么。Procfile是一个文件，它告诉Heroku的dynos运行哪些命令。为了使Heroku能够读取此文件，你必须将文件命名为Procfile（不带任何扩展名），并将其包含在项目的顶级目录中。
- en: 'Create a file called `Procfile` in the root of your `giftapp` project and add
    the following line to it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`giftapp`项目根目录下创建一个名为`Procfile`的文件，并向其中添加以下行：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This tells Heroku to run the www script out of our `dist` directory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Heroku在`dist`目录中运行www脚本。
- en: App environment variables
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用环境变量
- en: If you remember, our application is expected to use a number of environment
    variables to operate correctly. To set these up, log into your Heroku account
    and navigate to your dashboard at [https://dashboard.heroku.com/login](https://dashboard.heroku.com/login).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们的应用程序需要使用一些环境变量才能正确运行。为了设置这些变量，登录到你的Heroku账户并导航到你的仪表板[https://dashboard.heroku.com/login](https://dashboard.heroku.com/login)。
- en: 'Click on the name of your app to access its dashboard. Click on the settings
    tab, which will then reveal the `config` variables. This is where we will add
    all of the environment variables we need, as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 点击你的应用名称以访问其仪表板。点击设置标签，然后会显示`config`变量。这就是我们将添加所有需要的环境变量的地方，如下面的截图所示：
- en: '![App environment variables](img/image_14_006.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![应用环境变量](img/image_14_006.jpg)'
- en: You can see I've added variables for **NODE_ENV**, **PORT**, and **facebookClientID**.
    You'll do the same and add one for each of the environment variables used in your
    `appconfig.js` file, including DB.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我已经添加了**NODE_ENV**、**PORT**和**facebookClientID**的变量。你将做同样的事情，并为`appconfig.js`文件中使用的每个环境变量添加一个，包括DB。
- en: Make sure to adjust your Facebook and Twitter callback IDs to use your new Heroku
    domain. If you're confused about what it is, scroll down to the bottom of the
    settings page and it will be revealed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 确保调整你的Facebook和Twitter回调ID以使用你的新Heroku域名。如果你对此感到困惑，请滚动到设置页面的底部，它将会显示出来。
- en: Another step I'll leave you to do is to authorize your Heroku domain for your
    Facebook and Twitter apps. Just go into your app settings and add the new domain.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我将留给你做的另一个步骤是授权你的Heroku域名为你的Facebook和Twitter应用。只需进入你的应用设置并添加新域名。
- en: Deploying
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署
- en: 'Deploying is very easy, now that everything is completely ready. We will use
    a simple Gitpush. First let''s make sure that our `dist` files are ready to go
    and everything is committed to `git` properly by running the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，部署变得非常简单。我们将使用简单的Gitpush。首先，让我们确保我们的`dist`文件已经准备好，并且通过运行以下代码确保所有内容都已正确提交到`git`：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Great, everything is checked in. If you want a sanity check, you can always
    try `git status`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，一切都已经检查完毕。如果你想进行一次理智的检查，你可以始终尝试`git status`。
- en: 'Now let''s push everything we just committed to Heroku:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们刚刚提交的内容推送到Heroku：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And we're live! I omitted a significant portion of the output of the push. It's
    a very long output. If you go through what's here, you can see what **HerokuToolbelt**
    will do when we push it. You can see our application starting. You can see that
    the deployment was a success.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经上线了！我省略了推送输出的很大一部分。它非常长。如果你查看这里的内容，你可以看到当我们将它推送到Heroku时**HerokuToolbelt**会做什么。你可以看到我们的应用正在启动。你可以看到部署是成功的。
- en: Scaling the SPA
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展SPA
- en: I want to conclude with a few ideas about scaling the application. Scaling an
    application is a bit of a black art, but you do want to be prepared should you
    build out an application and it gets very popular very fast.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我想以一些关于扩展应用的想法来结束。扩展应用是一种有点神秘的艺术，但如果你构建的应用变得非常受欢迎，你确实需要做好准备。
- en: One of the really nice things about using PaaS tools is that they simplify scaling
    significantly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PaaS工具的好处之一是它们显著简化了扩展过程。
- en: Scaling the database
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展数据库
- en: There are a number of options and considerations for scaling the database. You
    can see this just by looking at the different packages offered by MongoLab. MongoDB
    itself supports sharding and replication, as it was built for scaling.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库扩展方面有许多选项和考虑因素。您只需看看MongoLab提供的不同套餐就可以看到这一点。MongoDB本身支持分片和复制，因为它是为了扩展而构建的。
- en: Concerns about scaling include the size of the database - how much storage,
    and performance - usually a factor of RAM or using dedicated clusters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的担忧包括数据库的大小——存储量有多少，以及性能——通常是一个RAM的因素或使用专用集群。
- en: MongoLab and other providers offer numerous combinations of high-storage and
    high-performance plans along with several steps, allowing you to incrementally
    increase your scaling without missing a beat, or installing or configuring a new
    hardware.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: MongoLab和其他提供商提供多种高存储和高性能计划的组合，以及几个步骤，允许您逐步增加扩展，而不会错过任何一步，或安装或配置新的硬件。
- en: It's important to understand its usage, which only comes over time with an application,
    and how that's going to affect the storage. If your application is growing and
    making many hits on your database, you'll want to think about its performance.
    As your database fills up, you'll want to manage its storage.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 理解其使用情况很重要，这只有在应用程序运行一段时间后才会显现出来，以及这将如何影响存储。如果您的应用程序正在增长并对数据库进行大量访问，您将想要考虑其性能。随着数据库的填充，您将想要管理其存储。
- en: Scaling the server
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器扩展
- en: Heroku makes it extremely easy to scale your app to exactly the right size that
    you need; it's one of the things they built their business around. On Heroku,
    apps are run inside dynos. Think of a dyno as a lightweight container that runs
    your app.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku使您能够非常容易地将应用程序扩展到所需的确切大小；这是他们建立业务的一部分。在Heroku上，应用程序在dynos中运行。将dyno想象为一个运行您的应用程序的轻量级容器。
- en: Heroku has a number of different dynos running at different performance levels,
    and you can add and remove them, even at different levels of performance, from
    the command line or from your dashboard.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku拥有多个不同性能级别的不同dynos运行，您可以从命令行或仪表板中添加和删除它们，甚至可以在不同的性能级别上进行操作。
- en: Heroku also offers a number of add-ons, for a fee of course, for doing things
    such as performance monitoring.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku还提供了一些付费的附加功能，例如性能监控。
- en: Not to be a sales pitch for Heroku, other PaaS providers offer similar options.
    Amazon Web Services is a popular choice for Node.js. There are others, such as
    Modulus and Digital Ocean. If you're deploying a real-world commercial app, it
    pays to shop around to find the right solution for you.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不想为Heroku做推销，其他PaaS提供商也提供类似的选择。Amazon Web Services是Node.js的一个流行选择。还有其他选择，例如Modulus和Digital
    Ocean。如果您正在部署一个现实世界的商业应用程序，寻找适合您的正确解决方案是值得的。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began this chapter by using Grunt to package up our app into a dist folder.
    We used Grunt plugins, installed using NPM, to do things such as minify our code.
    We spent a little time exploring the Grunt plugin ecosystem, which is quite vast
    and well supported.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章开始时使用Grunt将我们的应用程序打包到dist文件夹中。我们使用了通过NPM安装的Grunt插件，例如压缩我们的代码。我们花了一些时间探索Grunt插件生态系统，这是一个相当庞大且得到良好支持的生态系统。
- en: We then prepared to deploy our app to the web by setting up a cloud-based database.
    We created an account on MongoLab, and then created a new database. We then added
    a user to the database so that we could access it from our application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后准备将我们的应用程序部署到网络上，通过设置基于云的数据库来完成。我们在MongoLab上创建了一个账户，然后创建了一个新的数据库。接着，我们向数据库中添加了一个用户，以便我们能够从应用程序中访问它。
- en: We then set up an account on Heroku, and prepared our application for deployment.
    We installed the HerokuToolbelt, which allowed us to create a new Heroku application
    deployment. We accessed our application through the Heroku dashboard and added
    our environment variables. Finally, we pushed our project to Heroku using Git.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后在Heroku上设置了一个账户，并准备将我们的应用程序部署出去。我们安装了HerokuToolbelt，这使我们能够创建一个新的Heroku应用程序部署。我们通过Heroku仪表板访问我们的应用程序并添加了环境变量。最后，我们使用Git将我们的项目推送到Heroku。
- en: We wrapped up by briefly touching on topics such as scaling the database and
    the server. Using PaaS and a web-based database management system, we are well
    set up for when our application becomes as popular as Facebook.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地涉及了诸如数据库和服务器扩展等主题。使用PaaS和基于网络的数据库管理系统，我们为当我们的应用程序像Facebook一样受欢迎时做好了准备。
- en: Thanks for reading all the way through the book. If you have followed all of
    the instructions, you have a cloud-deployed, tested, SPA written in JavaScript.
    You now have all the skills to build an application front-to-back, database-to-presentation
    tier, in modern JavaScript. You should have a firm grasp of SPA architecture,
    modular code, and separation of concerns, and should have worked with every aspect
    of the MEAN stack. Congratulations, and good work!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您阅读完整本书。如果您已经遵循了所有指示，您现在拥有了一个使用JavaScript编写的云部署、测试过的单页应用（SPA）。您现在拥有了从头到尾构建应用、从数据库到展示层的所有技能，使用的是现代JavaScript。您应该对SPA架构、模块化代码和关注点分离有牢固的理解，并且应该与MEAN堆栈的各个方面都进行过合作。恭喜您，做得很好！
