- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Dealing with Security
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理安全问题
- en: Throughout this book, we’ve learned how we can use Node.js to build applications.
    As with all software, you must take certain precautions to ensure the application
    you’re building is secure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们学习了如何使用 Node.js 来构建应用程序。就像所有软件一样，你必须采取某些预防措施来确保你构建的应用程序是安全的。
- en: First, you should ensure that you’ve adopted any Node.js releases that contain
    security fixes. For this reason, where possible, you should aim to be on the latest
    release of a given Node.js release line.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该确保你已经采用了包含安全修复的任何 Node.js 版本。因此，在可能的情况下，你应该目标是给定 Node.js 版本线的最新版本。
- en: This chapter will cover some of the key aspects of Node.js web application security.
    The later recipes demonstrate some of the common attacks on web applications,
    including **cross-site scripting** ( **XSS** ) and **cross-site request forgery**
    ( **CSRF** ) attacks. They will showcase how to prevent and mitigate the risk
    of some of these attacks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖 Node.js 网络应用程序安全的一些关键方面。后面的菜谱将展示一些常见的网络应用程序攻击，包括 **跨站脚本**（ **XSS** ）和
    **跨站请求伪造**（ **CSRF** ）攻击。它们将展示如何防止和减轻这些攻击的风险。
- en: 'This chapter will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下菜谱：
- en: Detecting dependency vulnerabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测依赖项漏洞
- en: Authentication with Fastify
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Fastify 进行身份验证
- en: Hardening headers with Helmet
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Helmet 强化头部
- en: Anticipating malicious input
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测恶意输入
- en: Preventing JSON pollution
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止 JSON 污染
- en: Guarding against XSS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止 XSS
- en: Preventing CSRF
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止 CSRF
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You should have Node.js installed, preferably the latest version of Node.js
    22, and access to an editor and browser of your choice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该安装了 Node.js，最好是 Node.js 22 的最新版本，并且可以使用你选择的编辑器和浏览器。
- en: Throughout the recipes, we’ll be installing modules from the **npm** registry
    – therefore, an internet connection will be required.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个菜谱中，我们将从 **npm** 注册表中安装模块——因此，需要互联网连接。
- en: The code for the recipes in this chapter is available in this book’s GitHub
    repository at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    , in the *Chapter* *09* directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章菜谱的代码可在本书的 GitHub 仓库中找到，网址为 [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)，在
    *第 09 章* 目录下。
- en: Detecting dependency vulnerabilities
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测依赖项漏洞
- en: Throughout this book, we’ve leveraged modules from the **npm** registry to form
    a foundation for the applications we build. We’ve learned how the vast module
    ecosystem enables us to focus on application logic and not have to reinvent common
    technical solutions repeatedly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们利用了 **npm** 注册表中的模块来为我们构建的应用程序打下基础。我们学习了如何庞大的模块生态系统使我们能够专注于应用程序逻辑，而不必反复重新发明常见的解决方案。
- en: This ecosystem is key to Node.js’s success. However, it does lead to large,
    nested dependency trees within our applications. Not only must we be concerned
    with the security of the application code that we write ourselves, but we must
    also consider the security of the code included in the modules in our dependency
    tree. Even the most mature and popular modules and frameworks may contain security
    vulnerabilities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生态系统是 Node.js 成功的关键。然而，它确实会导致我们的应用程序中出现大型、嵌套的依赖树。我们不仅必须关注我们自己编写的应用程序代码的安全性，还必须考虑我们依赖树中包含的代码的安全性。即使是成熟且流行的模块和框架也可能包含安全漏洞。
- en: In this recipe, we’ll demonstrate how to detect vulnerabilities in a project’s
    dependency tree.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将演示如何检测项目依赖树中的漏洞。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we’ll create a directory named **audit-deps** where we can
    install some Node.js modules:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将创建一个名为 **audit-deps** 的目录，以便我们可以安装一些 Node.js 模块：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We don’t need to add any further code as we’ll be focusing on learning how to
    audit the dependencies using the terminal.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要添加任何额外的代码，因为我们将专注于学习如何使用终端审计依赖项。
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we’ll install some modules from the **npm** registry and scan
    them for vulnerabilities:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将从 **npm** 注册表中安装一些模块，并对它们进行漏洞扫描：
- en: 'First, let’s install an old version of the **express** module. We’ve intentionally
    chosen an old version with known vulnerabilities to demonstrate how to audit our
    dependencies. This version of Express.js is not recommended for use in production
    applications:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们安装一个旧版本的 **express** 模块。我们故意选择了一个已知存在漏洞的旧版本来演示如何审计我们的依赖项。这个版本的 Express.js
    不建议在生产应用程序中使用：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Observe that the **npm** output detects eight known vulnerabilities in this
    version of Express.js.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 **npm** 输出检测到 Express.js 此版本中的八个已知漏洞。
- en: 'As the output suggests, run the **$ npm audit** command for more details:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如输出所示，运行 **$ npm audit** 命令以获取更多详细信息：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Observe the output of the **$ npm audit** command, as shown in the following
    screenshot. The output lists the individual vulnerabilities, along with further
    information:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察以下截图所示的 **$ npm audit** 命令的输出。输出列出了个别漏洞，以及更多信息：
- en: '![Figure 9.1 – npm audit output for express@4.16.0](img/B19212_09_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – express@4.16.0 的 npm audit 输出](img/B19212_09_01.jpg)'
- en: Figure 9.1 – npm audit output for express@4.16.0
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – express@4.16.0 的 npm audit 输出
- en: 'We can follow the GitHub links specified in the console output to navigate
    to the advisory for the particular vulnerability. This will open a web page detailing
    an overview of the vulnerability and remediation actions:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以按照控制台输出中指定的 GitHub 链接导航到特定漏洞的咨询页面。这将打开一个网页，详细说明漏洞概述和修复措施：
- en: '![Figure 9.2 – Example npm vulnerability advisory](img/B19212_09_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 示例 npm 漏洞咨询](img/B19212_09_02.jpg)'
- en: Figure 9.2 – Example npm vulnerability advisory
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 示例 npm 漏洞咨询
- en: 'We can try to automatically fix the vulnerabilities by using the **$ npm audit
    fix** command. This will attempt to update any dependencies to fixed versions:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 **$ npm audit fix** 命令尝试自动修复漏洞。这将尝试将任何依赖项更新到修复版本：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, when we rerun the **$ npm audit** command, we’ll get the following output,
    indicating that there are no longer any known vulnerabilities being detected in
    our module dependency tree:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行 **$ npm audit** 命令时，我们将得到以下输出，表明在我们的模块依赖项树中不再检测到任何已知漏洞：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that, we’ve learned how to use **$ npm audit** to scan for vulnerabilities
    in our dependencies.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何使用 **$ npm audit** 来扫描依赖项中的漏洞。
- en: How it works…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The **$ npm audit** command has been available since **npm** version 6. The
    command submits a report of the dependencies in our application and compares it
    with a database of known vulnerabilities. The **$ npm audit** command will audit
    direct, development, bundled, and optional dependencies. However, it does not
    audit peer dependencies. The command requires both a **package.json** file and
    a **package-lock.json** file to be present; otherwise, it will fail. The audit
    automatically runs when a package is installed with the **$ npm** **install**
    command.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ npm audit** 命令自 **npm** 版本 6 起就已经可用。该命令会提交我们应用程序中依赖项的报告，并将其与已知漏洞数据库进行比较。**$
    npm audit** 命令将对直接、开发、捆绑和可选依赖项进行审计。然而，它不会审计 peer 依赖项。该命令需要同时存在 **package.json**
    文件和 **package-lock.json** 文件；否则，它将失败。当使用 **$ npm install** 命令安装包时，审计将自动运行。'
- en: Many organizations consider **$ npm audit** to be a precautionary measure to
    protect their applications against known security vulnerabilities. For this reason,
    it is common to add the **$ npm audit** command to your **continuous integration**
    ( **CI** ) testing. The **$ npm audit** command reports an error code of **1**
    when a vulnerability is found; this error code can be leveraged to indicate a
    failed test.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织认为 **$ npm audit** 是一种预防措施，用于保护他们的应用程序免受已知安全漏洞的侵害。因此，将 **$ npm audit** 命令添加到您的
    **持续集成** ( **CI** ) 测试中是很常见的。当发现漏洞时，**$ npm audit** 命令会报告错误代码 **1**；这个错误代码可以用来表示测试失败。
- en: In this recipe, we used the **$ npm audit fix** command to automatically update
    our dependencies to fixed versions. This command will only upgrade dependencies
    to later minor or patch versions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了 **$ npm audit fix** 命令来自动将我们的依赖项更新到修复版本。此命令只会将依赖项升级到较新的次要或补丁版本。
- en: 'Should a vulnerability only be fixed in a new major version, **npm** will output
    a warning indicating the fix is available via **npm audit fix --force** , as shown
    in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果漏洞仅在新的大版本中修复，**npm** 将输出警告，表明修复可通过 **npm audit fix --force** 获取，如下面的截图所示：
- en: '![Figure 9.3 – npm audit output showing breaking change resolution](img/B19212_09_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 显示破坏性变更解决的 npm audit 输出](img/B19212_09_03.jpg)'
- en: Figure 9.3 – npm audit output showing breaking change resolution
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 显示破坏性变更解决的 npm audit 输出
- en: Fixes that require updates to a new major release will not be automatically
    fixed by the **$ npm audit fix** command as you may need to update your application
    code to accommodate the breaking change in the dependency. It is possible to override
    this behavior and force **npm** to update all dependencies, even if they include
    breaking changes, using the **$ npm audit fix --force** command. However, in the
    case of a breaking change, it would be prudent to review the individual module
    vulnerabilities and manually update the modules one at a time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更新到新主要版本的修复将不会由 **$ npm audit fix** 命令自动修复，因为您可能需要更新应用程序代码以适应依赖项中的破坏性更改。您可以通过使用
    **$ npm audit fix --force** 命令来覆盖此行为并强制 **npm** 更新所有依赖项，即使它们包含破坏性更改。然而，在破坏性更改的情况下，审查单个模块漏洞并逐个手动更新模块可能是明智的。
- en: In some cases, a patched version of a dependency may not be available. In this
    case, **npm** will inform you that a manual review is required. During this manual
    review, it’s worthwhile trying to determine whether your application is susceptible
    to the vulnerability. Some vulnerabilities will only apply to the use of certain
    APIs, so if you’re not using those APIs in your application, you may be able to
    discount the specific vulnerability. If the vulnerability applies to your application
    and there’s no patched version of the dependency available, you should consider
    patching it within your application’s **node_modules** , if possible. A common
    approach to achieve this is using the **patch-package** ( [https://www.npmjs.com/package/patch-package](https://www.npmjs.com/package/patch-package)
    ) module from **npm** .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能没有可用的依赖项修补版本。在这种情况下，**npm** 将通知您需要进行手动审查。在手动审查期间，尝试确定您的应用程序是否容易受到漏洞的影响是值得的。某些漏洞可能仅适用于某些API的使用，因此如果您在应用程序中没有使用这些API，您可能可以排除特定的漏洞。如果漏洞适用于您的应用程序且没有可用的依赖项修补版本，您应考虑在可能的情况下，在您的应用程序的
    **node_modules** 中修补它。实现这一点的常见方法是从 **npm** 使用 **patch-package** ([https://www.npmjs.com/package/patch-package](https://www.npmjs.com/package/patch-package))
    模块。
- en: Important note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In general, it’s worthwhile keeping your application’s dependencies as up-to-date
    as possible to ensure you have the latest available bugs and security fixes. Tools
    such as **Dependabot** ( [https://dependabot.com/](https://dependabot.com/) )
    can help keep your dependencies up to date by automating updates on GitHub.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，保持您应用程序的依赖项尽可能最新是值得的，以确保您拥有最新的可用错误和安全修复。例如，**Dependabot** ([https://dependabot.com/](https://dependabot.com/))
    等工具可以通过在 GitHub 上自动化更新来帮助保持您的依赖项最新。
- en: Note that **npm audit** works by comparing your dependency tree against a database
    of known vulnerabilities. Having **npm audit** return no known vulnerabilities
    doesn’t mean your dependencies aren’t vulnerable – there could, and likely are,
    unreported or unknown vulnerabilities in your tree. There are also commercial
    services that provide module dependency vulnerability auditing services. Some
    of these, such as **Snyk** ( [https://snyk.io/](https://snyk.io/) ), maintain
    their own weakness and vulnerability databases, which may contain a different
    set of known issues to audit your dependencies against.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**npm audit** 通过将您的依赖项树与已知漏洞数据库进行比较来工作。**npm audit** 返回没有已知漏洞并不意味着您的依赖项没有漏洞——您的树中可能存在未报告或未知的漏洞。还有提供模块依赖项漏洞审计服务的商业服务。其中一些，如
    **Snyk** ([https://snyk.io/](https://snyk.io/))，维护自己的弱点与漏洞数据库，这些数据库可能包含不同的已知问题集，以审计您的依赖项。
- en: 'There are additional options available when using **npm audit** so that you
    can tailor it to your needs:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **npm audit** 时还有其他选项可供选择，以便您可以根据自己的需求进行定制：
- en: '**--audit-level <level>** : Allows you to specify the minimum vulnerability
    level that **npm audit** should report on. The levels include **info** , **low**
    , **moderate** , **high** , and **critical** .'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--audit-level <level>** : 允许您指定 **npm audit** 应报告的最小漏洞级别。这些级别包括 **info**、**low**、**moderate**、**high**
    和 **critical**。'
- en: '**--dry-run** : Simulates the action of fixing vulnerabilities without applying
    any changes.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--dry-run** : 模拟修复漏洞的操作，而不应用任何更改。'
- en: '**--force** : Forces vulnerable dependencies to be updated, bypassing certain
    checks such as peer dependency compatibility. This option should be used with
    caution as it can lead to dependency conflicts or introduce breaking changes within
    your project.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--force** : 强制更新有漏洞的依赖项，绕过某些检查，例如依赖项兼容性检查。此选项应谨慎使用，因为它可能导致依赖项冲突或在你项目中引入破坏性更改。'
- en: '**--json** : Outputs the audit results in JSON format.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--json** : 以 JSON 格式输出审计结果。'
- en: '**--package-lock-only** : Restricts the audit to project dependencies defined
    in the **package-lock.json** or **npm-shrinkwrap.json** files, without requiring
    an actual install.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--package-lock-only** : 将审计限制在 **package-lock.json** 或 **npm-shrinkwrap.json**
    文件中定义的项目依赖项，而不需要实际安装。'
- en: '**--no-package-lock** : Ignores the project’s **package-lock.json** or **npm-shrinkwrap.json**
    files during the audit. This can be useful when you want to audit the state of
    the **node_modules** directory.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--no-package-lock** : 在审计过程中忽略项目的 **package-lock.json** 或 **npm-shrinkwrap.json**
    文件。当您想审计 **node_modules** 目录的状态时，这可能很有用。'
- en: '**--omit** and **--include** : Allow you to configure which types of dependencies
    (development, optional, or peer dependencies) to exclude or include in the audit
    process, respectively.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--omit** 和 **--include** : 允许您配置在审计过程中要排除或包含的依赖类型（开发、可选或同行依赖）。'
- en: There’s more...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In addition to using **npm audit** , you can leverage GitHub’s Dependabot to
    enhance your project’s security and keep your dependencies up to date. Dependabot
    automates the process of checking for vulnerabilities and creating pull requests
    to update your dependencies. It continuously monitors your project’s dependencies
    and alerts you if it detects any vulnerabilities. Dependabot can automatically
    open pull requests to update outdated dependencies to their latest versions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 **npm audit** 之外，您还可以利用 GitHub 的 Dependabot 来增强您项目的安全性并保持依赖项更新。Dependabot
    自动化检查漏洞并创建拉取请求以更新您的依赖项。它持续监控您的项目依赖项，并在检测到任何漏洞时提醒您。Dependabot 可以自动打开拉取请求以更新过时的依赖项到最新版本。
- en: By integrating Dependabot with your GitHub repository, you can ensure that your
    project stays current with the latest security patches and updates, reducing the
    risk of potential vulnerabilities. Please refer to [https://docs.github.com/en/code-security/dependabot](https://docs.github.com/en/code-security/dependabot)
    for GitHub guidelines on enabling and using Dependabot.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 Dependabot 集成到您的 GitHub 仓库中，您可以确保您的项目与最新的安全补丁和更新保持同步，从而降低潜在漏洞的风险。请参阅 [https://docs.github.com/en/code-security/dependabot](https://docs.github.com/en/code-security/dependabot)
    了解 GitHub 关于启用和使用 Dependabot 的指南。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The **npm** documentation for **npm** **audit** : [https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities](https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm** 的 **npm audit** 文档：[https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities](https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities)'
- en: The *Consuming Node.js modules* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 5 章*](B19212_05.xhtml#_idTextAnchor139) 中的 *使用 Node.js 模块* 食谱'
- en: Authentication with Fastify
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Fastify 进行身份验证
- en: Many web applications require a login system. Often, users of a website have
    different privileges, and to determine which resources they can access, they must
    first be identified through authentication.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络应用程序都需要登录系统。通常，网站的用户有不同的权限，为了确定他们可以访问哪些资源，他们必须首先通过身份验证进行识别。
- en: This is typically achieved by setting up a session, which is a temporary information
    exchange between a user and a device. Sessions enable the server to store user-specific
    information, which can be used to manage access and maintain the user’s state
    across multiple requests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是通过设置会话来实现的，会话是用户和设备之间的临时信息交换。会话使服务器能够存储特定于用户的信息，这些信息可用于管理访问并在多个请求之间维护用户的状态。
- en: In this recipe, we’ll implement an authentication layer for a Fastify server.
    Please refer to [*Chapter 6*](B19212_06.xhtml#_idTextAnchor178) for more information
    on Fastify.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将为 Fastify 服务器实现一个身份验证层。请参阅 [*第 6 章*](B19212_06.xhtml#_idTextAnchor178)
    以获取有关 Fastify 的更多信息。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let’s start by creating a Fastify server:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个 Fastify 服务器开始：
- en: 'Create a project directory named **fastify-auth** to work in and initialize
    the project with **npm** . We’ll also create some files and subdirectories that
    we’ll use later in this recipe:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **fastify-auth** 的项目目录以进行工作，并使用 **npm** 初始化项目。我们还将创建一些文件和子目录，我们将在本食谱的后续部分中使用它们：
- en: '[PRE5]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ll also need to install several modules:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要安装几个模块：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code to the **server.js** file. This will configure an initial
    Fastify server that we’ll extend:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 **server.js** 文件中。这将配置一个初始的 Fastify 服务器，我们将对其进行扩展：
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following to **routes/index.js** to create a base router that will
    handle an HTTP **GET** request on **/** :'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 **routes/index.js** 中以创建一个基础路由器，该路由器将处理 **/** 上的 HTTP **GET** 请求：
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following to **views/index.ejs** to create an **Embedded JavaScript**
    ( **EJS** ) template. For now, this will just be a simple welcome page template:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 **views/index.ejs** 中以创建一个 **嵌入式 JavaScript**（**EJS**）模板。目前，这只是一个简单的欢迎页面模板：
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Start the server with the following command and navigate to **http://localhost:3000**
    in your browser:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动服务器，并在浏览器中导航到 **http://localhost:3000**：
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should expect to see a web page titled **Authenticating with Fastify** .
    Stop the server using *Ctrl* + *C* .
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到一个标题为 **Authenticating with Fastify** 的网页。使用 *Ctrl* + *C* 停止服务器。
- en: Now that we have a simple Fastify server, we can start implementing the authentication
    layer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的 Fastify 服务器，我们可以开始实现身份验证层。
- en: How to do it…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we’ll add a login system to our Fastify server using the **@fastify/cookie**
    and **@** **fastify/session** modules:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 **@fastify/cookie** 和 **@fastify/session** 模块将登录系统添加到我们的 Fastify
    服务器中：
- en: 'Start by installing the modules:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装模块：
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’ll create a separate router to handle authentication, as well as an EJS
    template that will contain our HTML login form. Let’s create those files now:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个单独的路由器来处理身份验证，以及一个包含我们的 HTML 登录表单的 EJS 模板。现在让我们创建这些文件：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let’s create our HTML login form using an EJS template. The HTML form
    will have two fields: **username** and **password** . This template will expect
    to be passed a value named **fail** . When the fail value is **true** , the **Login
    Failed.** message will be rendered. Add the following code to **views/login.ejs**
    :'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 EJS 模板创建我们的 HTML 登录表单。HTML 表单将有两个字段：**用户名** 和 **密码**。此模板期望传递一个名为 **fail**
    的值。当 fail 值为 **true** 时，将渲染 **登录失败** 的消息。将以下代码添加到 **views/login.ejs**：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we need to build our authentication router. We’ll do this in the **routes/auth.js**
    file. The authentication router will contain route handlers for the **/login**
    and **/logout** endpoints. The **/login** endpoint will require both an HTTP **GET**
    and an HTTP **POST** handler. The HTTP **POST** handler for the **/login** endpoint
    will receive and parse the form data (username and password) to validate the user
    credentials. Add the following to **routes/auth.js** to create the authentication
    router:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要构建我们的身份验证路由器。我们将在 **routes/auth.js** 文件中完成此操作。身份验证路由器将包含 **/login** 和
    **/logout** 端点的路由处理程序。**/login** 端点的 HTTP **POST** 处理程序将接收并解析表单数据（用户名和密码）以验证用户凭据。将以下内容添加到
    **routes/auth.js** 中以创建身份验证路由器：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we need to update our **routes/index.js** file so that we can pass the
    user data from the session to the EJS template:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的 **routes/index.js** 文件，以便我们可以将用户数据从会话传递到 EJS 模板：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, add the imports for **@fastify/cookie** and **@fastify/session** alongside
    the other imports in the **server.js** file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 **@fastify/cookie** 和 **@fastify/session** 的导入添加到 **server.js** 文件中的其他导入旁边：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Import the **auth** router:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 **auth** 路由器：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Register the plugins with the following configuration:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下配置注册插件：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Register **authRoutes** :'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册 **authRoutes**：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Start the server with the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动服务器：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Navigate to **http://localhost:3000** in your browser. Expect to see the following
    web page:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到 **http://localhost:3000**。预期会看到以下网页：
- en: '![Figure 9.4 – Web page depicting “Authentication with Fastify”](img/B19212_09_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 描述“使用 Fastify 进行身份验证”的网页](img/B19212_09_04.jpg)'
- en: Figure 9.4 – Web page depicting “Authentication with Fastify”
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 描述“使用 Fastify 进行身份验证”的网页
- en: Click **Login** ; you’ll be directed to the HTML login form. Supply a random
    username and password and click **Login** . Since this doesn’t match our hardcoded
    values, we expect to see the **Login** **Failed.** message.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **登录**；您将被导向 HTML 登录表单。提供一个随机的用户名和密码，然后点击 **登录**。由于这不符合我们的硬编码值，我们预计会看到 **登录失败**
    的消息。
- en: Let’s try the hardcoded values. Supply a username of **beth** and a password
    of **badpassword** and click **Login** . The login process should be successful.
    You will redirect back to the **/** endpoint, where there will be a **Hello**
    **beth!** message.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试硬编码的值。提供一个用户名 **beth** 和密码 **badpassword**，然后点击 **登录**。登录过程应该是成功的。您将被重定向回
    **/** 端点，在那里将显示 **Hello** **beth!** 消息。
- en: Finally, let’s try and log out. Click the **Logout** link. This should redirect
    you back to the same endpoint, but the **Hello beth!** message will be removed
    as the session has ended.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们尝试注销。点击 **注销** 链接。这应该将您重定向回相同的端点，但 **Hello beth!** 消息将被移除，因为会话已经结束。
- en: This recipe introduced the **@fastify/cookie** and **@fastify/session** modules
    and how we can use them to build a simple login functionality. Now, let’s see
    how it all works.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方介绍了 **@fastify/cookie** 和 **@fastify/session** 模块，以及我们如何使用它们来构建简单的登录功能。现在，让我们看看它是如何工作的。
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we built a login system using the **@fastify/cookie** and **@**
    **fastify/session** modules.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用 **@fastify/cookie** 和 **@fastify/session** 模块构建了一个登录系统。
- en: First, we imported and registered the **@fastify/session** plugin in the Fastify
    application (in the **server.js** file). This plugin injects a session object
    into every request object. Before the user is authenticated, the session value
    will be an empty object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 Fastify 应用程序中（在 **server.js** 文件中）导入并注册了 **@fastify/session** 插件。这个插件将一个会话对象注入到每个请求对象中。在用户认证之前，会话值将是一个空对象。
- en: 'When registering the **@fastify/session** plugin, we provided the following
    configuration options:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册 **@fastify/session** 插件时，我们提供了以下配置选项：
- en: '**Secret** : Used to sign the session ID cookie, ensuring its integrity and
    preventing tampering. It must be at least 32 characters long for security.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥**：用于签名会话 ID 糖果，确保其完整性并防止篡改。出于安全考虑，它必须至少有 32 个字符长。'
- en: '**Cookie.httpOnly** : Configures the session cookie. Note that **httpOnly:
    true** makes the cookie inaccessible to client-side JavaScript, enhancing security.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cookie.httpOnly**：配置会话糖果。请注意，**httpOnly: true** 使得糖果对客户端 JavaScript 不可访问，增强了安全性。'
- en: '**SaveUninitialized** : Prevents saving unmodified sessions to the store, reducing
    storage usage and improving performance.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SaveUninitialized**：防止将未修改的会话保存到存储中，减少存储使用并提高性能。'
- en: '**Resave** : Prevents resaving unchanged sessions, reducing unnecessary write
    operations to the session store.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Resave**：防止重新保存未更改的会话，减少对会话存储的无需要写操作。'
- en: The full list of configuration options is available in the **@fastify/session**
    API documentation at [https://github.com/fastify/session?tab=readme-ov-file#api](https://github.com/fastify/session?tab=readme-ov-file#api)
    .
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的配置选项列表可在 **@fastify/session** API 文档中找到，网址为 [https://github.com/fastify/session?tab=readme-ov-file#api](https://github.com/fastify/session?tab=readme-ov-file#api)。
- en: In this recipe’s demo application, the login hyperlink on the web page redirects
    the user to the **/auth/login** endpoint. The route handler for this endpoint
    was declared in a separate authentication router ( **routes/auth.js** ). This
    route renders the **views/login.ejs** template, which contains the HTML login
    form.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方的演示应用程序中，网页上的登录超链接将用户重定向到 **/auth/login** 端点。这个端点的路由处理器是在一个单独的认证路由器（**routes/auth.js**）中声明的。这个路由渲染包含
    HTML 登录表单的 **views/login.ejs** 模板。
- en: When the user enters their username and password in the form and clicks **Submit**
    , the browser encodes the values and sets them as the request body. Our HTML form
    had its method set to HTTP **POST** ( **method="post"** ), which instructs the
    browser to send an HTTP **POST** request when the form is submitted. The **action**
    attribute in our HTML form was set to **login** , which instructs the browser
    that the HTTP **POST** request should be sent to the **/** **auth/login** endpoint.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在表单中输入用户名和密码并点击 **提交** 时，浏览器将值编码并设置为请求体。我们的 HTML 表单将方法设置为 HTTP **POST**（**method="post"**），这指示浏览器在表单提交时发送
    HTTP **POST** 请求。我们的 HTML 表单中的 **action** 属性设置为 **login**，这指示浏览器将 HTTP **POST**
    请求发送到 **/** **auth/login** 端点。
- en: In **routes/auth.js** , we registered a handler for HTTP **POST** requests to
    the **/login** endpoint. This handler extracts the username and password from
    the request body and checks whether they match any user in our hardcoded array
    of users. If the credentials are valid, it saves the user information in the session
    and renders the **index.ejs** template with the user data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **routes/auth.js** 中，我们为 **/login** 端点的 HTTP **POST** 请求注册了一个处理器。这个处理器从请求体中提取用户名和密码，并检查它们是否与我们的硬编码用户数组中的任何用户匹配。如果凭证有效，它将在会话中保存用户信息，并使用用户数据渲染
    **index.ejs** 模板。
- en: 'If the username and password don’t match, our HTTP **POST** **/auth/login**
    route handler renders the **views/login.ejs** template with the **{ fail : true
    }** value. This instructs the **views/login.ejs** template to render the **Login**
    **Failed.** message.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '如果用户名和密码不匹配，我们的HTTP **POST** **/auth/login**路由处理程序将渲染带有**{ fail : true }**值的**views/login.ejs**模板。这指示**views/login.ejs**模板渲染**登录失败**消息。'
- en: Important note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don’t store passwords in plain text in production applications! You’d typically
    validate the supplied username and password against credentials stored in a secure
    database, with the password being stored in a hashed form. Refer to the *There’s
    more…* section of this recipe on hashing with **bcrypt** .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产应用程序中以纯文本形式存储密码！你通常会验证提供的用户名和密码与存储在安全数据库中的凭据相匹配，密码以散列形式存储。请参阅此食谱中关于使用**bcrypt**散列的**There’s
    more…**部分。
- en: When the authentication process is successful, we set the **req.session.user**
    value to the supplied username and redirect the authenticated user back to the
    **/** endpoint. At this point, the **@fastify/session** middleware creates a session
    identifier and sets the **Set-Cookie** HTTP header on the request. The **Set-Cookie**
    header is set to the session key name and session identifier.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当认证过程成功时，我们将**req.session.user**的值设置为提供的用户名，并将认证用户重定向回**/**端点。在此阶段，**@fastify/session**中间件创建一个会话标识符，并在请求上设置**Set-Cookie**
    HTTP头。**Set-Cookie**头设置为会话键名和会话标识符。
- en: The **@fastify/session** plugin defaults to using an in-process storage mechanism
    to store the session tokens. However, these tokens are not expired, which means
    our process will continue to be populated with more and more tokens. This could
    eventually result in degraded performance or crash our process. Again, in production,
    you’d typically use a session store. The **@fastify/session** plugin is based
    on the **express-session** list of compatible session stores at [https://github.com/expressjs/session#compatible-session-stores](https://github.com/expressjs/session#compatible-session-stores)
    .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**@fastify/session**插件默认使用进程内存储机制来存储会话令牌。然而，这些令牌不会过期，这意味着我们的进程将继续被越来越多的令牌填充。这最终可能导致性能下降或使我们的进程崩溃。再次强调，在生产环境中，你通常会使用会话存储。**@fastify/session**插件基于**express-session**兼容的会话存储列表，请参阅[https://github.com/expressjs/session#compatible-session-stores](https://github.com/expressjs/session#compatible-session-stores)。'
- en: When the request is redirected to **/** , it now has the **Set-Cookie** HTTP
    header set. The **@fastify/session** middleware recognizes the session key name
    and extracts the session identifier. From this identifier, **@fastify/session**
    can query session storage for any associated state. In this case, the state is
    the user object that we assign to the **req.session** object in **auth.js** .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求被重定向到**/**时，它现在已设置了**Set-Cookie** HTTP头。**@fastify/session**中间件识别会话键名并提取会话标识符。从这个标识符中，**@fastify/session**可以查询会话存储以获取任何关联的状态。在这种情况下，状态是我们将分配给**req.session**对象的用户对象，在**auth.js**中完成。
- en: The **req.session.user** value is passed through to the updated **views/index.ejs**
    template. This template contains logic such that when a **req.session.user** value
    is present, it will render the **Hello beth!** string. The logic in the template
    also switches between showing the **Login** or **Logout** link, depending on whether
    the user is authenticated.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**req.session.user**的值传递给更新的**views/index.ejs**模板。此模板包含逻辑，当存在**req.session.user**值时，它将渲染**Hello
    beth!**字符串。模板中的逻辑还会根据用户是否认证来在显示**登录**或**注销**链接之间切换。'
- en: Clicking **Logout** sends an HTTP **GET** request to the **/auth/logout** endpoint.
    This endpoint sets **req.session** to **null** , which ends the session and removes
    session data from the session store. Our browser may continue to store and send
    the invalid session cookie until it expires, but with no valid match in the session
    store, the server will ignore the session and consider the user unauthenticated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**注销**会向**/auth/logout**端点发送HTTP **GET**请求。此端点将**req.session**设置为**null**，结束会话并从会话存储中删除会话数据。我们的浏览器可能会继续存储并发送无效的会话cookie，直到它过期，但由于会话存储中没有有效的匹配项，服务器将忽略会话并认为用户未认证。
- en: There’s more…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The following sections will cover secure session cookies and a simple example
    of how to hash a password.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将涵盖安全的会话cookie以及如何散列密码的简单示例。
- en: Secure session cookies
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全的会话cookie
- en: Session cookies can be marked with a **Secure** attribute. The **Secure** attribute
    forces the browser to not use HTTP to send cookies back to the server. This is
    to avoid **man-in-the-middle** ( **MITM** ) attacks. In production applications,
    HTTPS and secure cookies should be used. But in development, it’s easier to use
    HTTP.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 会话cookie可以被标记为**Secure**属性。**Secure**属性强制浏览器不使用HTTP将cookie发送回服务器。这是为了避免**中间人攻击**（**MITM**）。在生产应用中，应使用HTTPS和安全的cookie。但在开发中，使用HTTP更容易。
- en: It’s typical for a production environment to apply SSL encryption at the load
    balancer layer. A load balancer is a technology in an application architecture
    that’s responsible for boosting the efficiency of the application by distributing
    a set of tasks over a set of resources – for example, distributing login requests
    to servers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，通常在负载均衡器层应用SSL加密。负载均衡器是应用架构中的一个技术，它通过将一系列任务分配到一系列资源来提高应用的效率——例如，将登录请求分配到服务器。
- en: We can configure our Fastify server to communicate with a load balancer over
    HTTP but still support **Secure** cookies using the appropriate cookie settings.
    In production, the **Secure** option for cookies should be set to true.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置我们的Fastify服务器通过HTTP与负载均衡器通信，但仍然使用适当的cookie设置支持**Secure**cookie。在生产中，cookie的**Secure**选项应设置为true。
- en: Hashing with bcrypt
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用bcrypt进行哈希
- en: Passwords should never be stored in plain text and should instead be stored
    in a hashed form. Passwords are transformed into a hashed form using a **hashing
    function** . Hashing functions use an algorithm to transform a value into unrecognizable
    data. The transformation is one-way, meaning it’s unlikely to be possible to determine
    the value from the hash. A website will validate a user’s password input by applying
    the hashing function to the supplied password and comparing it to the stored hash.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 密码绝不应该以明文形式存储，而应该以哈希形式存储。密码通过**哈希函数**转换为哈希形式。哈希函数使用算法将值转换为不可识别的数据。这种转换是单向的，意味着从哈希中确定原始值是不太可能的。网站将通过将提供的密码应用于哈希函数并与存储的哈希值进行比较来验证用户的密码输入。
- en: Hashing is typically combined with a technique called **salting** . Salting
    is where a unique value, referred to as the *salt* , is appended to the password
    before the hash is generated. This helps to protect against brute-force attacks
    and makes it more difficult to crack the password.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希通常与一种称为**盐化**的技术结合使用。盐化是指在生成哈希之前将一个唯一的值（称为盐）附加到密码上。这有助于防止暴力攻击，并使破解密码更加困难。
- en: '**bcrypt** ( [https://www.npmjs.com/package/bcrypt](https://www.npmjs.com/package/bcrypt)
    ) is a popular module that’s used to hash passwords in Node.js. The following
    example demonstrates how to generate a hash with a salt using the **bcrypt** module:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**bcrypt**（[https://www.npmjs.com/package/bcrypt](https://www.npmjs.com/package/bcrypt)）是一个流行的模块，用于在Node.js中哈希密码。以下示例演示了如何使用**bcrypt**模块生成带有盐的哈希：'
- en: 'First, create and initialize a directory named **hashing-with-bcrypt** :'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建并初始化一个名为**hashing-with-bcrypt**的目录：
- en: '[PRE21]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, install the **bcrypt** module:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装**bcrypt**模块：
- en: '[PRE22]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our program will expect the password to be supplied as an argument. Add the
    following to **hash.js** to extract the argument value:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序将期望密码作为参数提供。将以下内容添加到**hash.js**中，以提取参数值：
- en: '[PRE23]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, in **hash.js** , import the **bcrypt** module:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**hash.js**中导入**bcrypt**模块：
- en: '[PRE24]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we must define the number of salt rounds. Here, **bcrypt** will generate
    a salt using the specified number of rounds. The higher the number of rounds,
    the more secure the hash will be. However, it will also take longer to generate
    and validate the hash in your application. In this example, we’ll set the number
    of salt rounds to **10** :'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须定义盐的轮数。在这里，**bcrypt**将使用指定的轮数生成盐。轮数越多，哈希越安全。然而，它也会使你的应用生成和验证哈希的时间更长。在这个例子中，我们将盐的轮数设置为**10**：
- en: '[PRE25]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we need to call the **bcrypt** module’s **hash()** method. We supply
    this method with the plain text password, the number of salt rounds, and the callback
    function to be executed once the hash has been generated. Our callback will output
    the hashed form of the password using **conosle.log()** . Add the following to
    **hash.js** :'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要调用**bcrypt**模块的**hash()**方法。我们向此方法提供纯文本密码、盐的轮数以及一旦生成哈希就执行的回调函数。我们的回调将使用**conosle.log()**输出密码的哈希形式。将以下内容添加到**hash.js**中：
- en: '[PRE26]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a real application, you’d expect to include your logic to persist the hash
    to a database within the callback function.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实际应用中，你会在回调函数中包含你的逻辑，以便将哈希值持久化到数据库中。
- en: 'Run the program with the following command. You should expect a unique hash
    to be generated:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序。你应该期望生成一个唯一的哈希值：
- en: '[PRE27]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Each time this script is run, a new unique hash will be generated.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次运行此脚本时，都会生成一个新的唯一哈希值。
- en: 'Next, let’s learn how we can validate the password. We’ll create a program
    that expects both the password and the hash as arguments. The program will compare
    the password and hash using the **bcrypt.compare()** method:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何验证密码。我们将创建一个程序，该程序期望密码和哈希值作为参数。程序将使用 **bcrypt.compare()** 方法比较密码和哈希值：
- en: '[PRE28]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that **res** will be **true** when the password and hash match and **false**
    when they don’t.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，当密码和哈希值匹配时，**res** 将为 **true**，不匹配时为 **false**。
- en: 'Run the **validate-password.js** program. The first argument should be the
    same password you supplied to the **hash.js** program. The second argument should
    be the hash that your **hash.js** program created:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 **validate-password.js** 程序。第一个参数应该是你提供给 **hash.js** 程序的相同密码。第二个参数应该是 **hash.js**
    程序创建的哈希值：
- en: '[PRE29]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the argument values should be wrapped in single quotes to ensure the
    literal values are preserved.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，参数值应该用单引号括起来，以确保保留字面值。
- en: This demonstrates how we can use the **bcrypt** module to create a hash, as
    well as how to validate a value against an existing hash.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了我们可以如何使用 **bcrypt** 模块来创建哈希值，以及如何验证一个值与现有哈希值是否匹配。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing authentication with hooks* recipe in [*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B19212_06.xhtml#_idTextAnchor178) 的 *使用钩子实现身份验证* 菜谱中
- en: The *Guarding against cross-site scripting* recipe in this chapter
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *防止跨站脚本攻击* 菜谱
- en: The *Preventing cross-site request forgery* recipe in this chapter
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *防止跨站请求伪造* 菜谱
- en: Hardening headers with Helmet
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helmet 加固头部
- en: Express.js is a lightweight web framework, so certain measures that are typically
    taken to better secure applications are not implemented by the core framework.
    One of the precautionary measures we can take is to set certain security-related
    HTTP headers on requests. Sometimes, this is referred to as *hardening* the headers
    of our HTTP requests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js 是一个轻量级 Web 框架，因此通常为了更好地保护应用程序而采取的一些措施并没有在核心框架中实现。我们可以采取的一项预防措施是在请求上设置某些与安全相关的
    HTTP 头部。有时，这被称为 *加固* 我们 HTTP 请求的头部。
- en: The **Helmet** module ( [https://github.com/helmetjs/helmet](https://github.com/helmetjs/helmet)
    ) provides a middleware to set security-related headers on our HTTP requests,
    saving time on manual configuration. Helmet sets HTTP headers to reasonable and
    secure defaults, which can then be extended or customized as needed. In this recipe,
    we’ll learn how to use the Helmet module.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**Helmet** 模块（[https://github.com/helmetjs/helmet](https://github.com/helmetjs/helmet)）提供了一个中间件，用于在我们的
    HTTP 请求上设置与安全相关的头部，从而节省手动配置的时间。Helmet 将 HTTP 头部设置为合理的默认安全值，然后可以根据需要扩展或自定义。在这个菜谱中，我们将学习如何使用
    Helmet 模块。'
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We’ll be extending an Express.js application so that it can use the Helmet
    module. So, first, we must create a basic Express.js server:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展一个 Express.js 应用程序，使其能够使用 Helmet 模块。因此，首先，我们必须创建一个基本的 Express.js 服务器：
- en: 'Create a directory named **express-helmet** and initialize the project with
    **npm** . We’ll also install the **express** module:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **express-helmet** 的目录，并使用 **npm** 初始化项目。我们还将安装 **express** 模块：
- en: '[PRE30]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a file named **server.js** :'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **server.js** 的文件：
- en: '[PRE31]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code to **server.js** :'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 **server.js** 中：
- en: '[PRE32]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that we’ve created our base Express.js application, we’re ready to move
    on to the steps to complete this recipe.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个基本的 Express.js 应用程序，我们可以继续进行完成这个菜谱的步骤。
- en: How to do it…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we’re going to learn how to use the Helmet module to harden
    the HTTP headers of our Express.js application:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 Helmet 模块来加固我们的 Express.js 应用程序的 HTTP 头部：
- en: 'First, start the Express.js web server:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，启动 Express.js 网络服务器：
- en: '[PRE33]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let’s inspect the headers that our Express.js application returns. We
    can do this using the *cURL* tool. In a second terminal window, enter the following
    command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们的 Express.js 应用程序返回的头部信息。我们可以使用 *cURL* 工具来完成此操作。在第二个终端窗口中，输入以下命令：
- en: '[PRE34]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see a response similar to the following that lists the HTTP headers
    returned on the request:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到一个类似以下响应，列出了请求返回的 HTTP 头部信息：
- en: '[PRE35]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note the **X-Powered-By:** **Express** header.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意**X-Powered-By:** **Express**头信息。
- en: 'Now, let’s start hardening these headers with the **helmet** module. Install
    the **helmet** module with the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用**helmet**模块开始强化这些头信息。使用以下命令安装**helmet**模块：
- en: '[PRE36]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We need to import the **helmet** middleware in the **app.js** file. Do this
    by adding the following line just below the **express** import:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在**app.js**文件中导入**helmet**中间件。通过在**express**导入下方添加以下行来完成此操作：
- en: '[PRE37]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we need to instruct the Express.js application to use the **helmet**
    middleware. Below the **const app = express();** line, add the following:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要指导Express.js应用程序使用**helmet**中间件。在**const app = express();**行下方，添加以下内容：
- en: '[PRE38]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, restart the server:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重新启动服务器：
- en: '[PRE39]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Send the *cURL* request again:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次发送*cURL*请求：
- en: '[PRE40]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At this point, we can see that many additional headers are returned on the
    request:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以看到请求返回了许多额外的头信息：
- en: '[PRE41]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that the **X-Powered-By** header has been removed.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，**X-Powered-By** 头信息已被移除。
- en: With that, we’ve added the **helmet** middleware to our Express.js server and
    observed the changes it makes to the HTTP headers returned from our request.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经将**helmet**中间件添加到我们的Express.js服务器中，并观察到了它对我们请求返回的HTTP头信息所做的更改。
- en: How it works…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The **helmet** module configures some of the HTTP headers on our requests based
    on its security defaults. In this recipe, we applied the **helmet** middleware
    to our Express.js server.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**helmet**模块根据其安全默认值配置我们请求的一些HTTP头信息。在本例中，我们将**helmet**中间件应用于我们的Express.js服务器。'
- en: 'The **helmet** module removes the **X-Powered-By: Express** header so that
    discovering the server is Express-based becomes more difficult. The reason that
    we’ve obfuscated this is to protect against attackers trying to exploit Express.js-oriented
    security vulnerabilities, slowing them down in determining the type of server
    being used in the application.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**helmet**模块移除了**X-Powered-By: Express**头信息，这使得发现服务器是基于Express变得更加困难。我们这样做的原因是为了保护攻击者尝试利用Express.js相关的安全漏洞，减缓他们确定应用程序中使用的服务器类型的速度。'
- en: 'At this point, **helmet** injects the following headers into our request, along
    with the appropriate defaults:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，**helmet**将以下头信息注入到我们的请求中，包括适当的默认值：
- en: '| **Header** | **Description** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **Header** | **描述** |'
- en: '| **Content-Security-Policy** | Helps mitigate against XSS attacks by allowing
    a policy to be defined that can control which resources the user agent is allowed
    to load |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **Content-Security-Policy** | 通过允许定义一个策略来控制用户代理可以加载哪些资源，从而帮助减轻XSS攻击 |'
- en: '| **Cross-Origin-Opener-Policy** | Ensures that a top-level document can only
    interact with documents from the same origin |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **Cross-Origin-Opener-Policy** | 确保顶层文档只能与同一源文档进行交互 |'
- en: '| **Cross-Origin-Resource-Policy** | Restricts resources so that they can only
    be accessed by same-origin documents |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **Cross-Origin-Resource-Policy** | 限制资源，使其只能由同一源文档访问 |'
- en: '| **Origin-Agent-Cluster** | Ensures a document is isolated in a separate agent
    cluster to prevent data leaks between different origins |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **Origin-Agent-Cluster** | 确保文档在单独的代理集群中隔离，以防止不同源之间的数据泄露 |'
- en: '| **Referrer-Policy** | Controls how much referrer information is included
    with requests sent from a site |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **Referrer-Policy** | 控制从网站发送的请求中包含的引用信息量 |'
- en: '| **Strict-Transport-Security** | Instructs browsers to only allow the website
    to be accessed using HTTPS |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **Strict-Transport-Security** | 指示浏览器仅允许使用HTTPS访问网站 |'
- en: '| **X-Content-Type-Options** | Indicates that the MIME types configured in
    the **Content-Type** headers must be adhered to |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **X-Content-Type-Options** | 指示配置在**Content-Type**头信息中的MIME类型必须遵守 |'
- en: '| **X-DNS-Prefetch-Control** | Controls DNS prefetching |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **X-DNS-Prefetch-Control** | 控制DNS预取 |'
- en: '| **X-Download-Options** | Disables the option to open a file on download |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **X-Download-Options** | 禁用在下载时打开文件选项 |'
- en: '| **X-Frame-Options** | Indicates whether a browser can render a page in a
    **<frame>** , **<iframe>** , **<embed>** , or **<object>** HTML element |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **X-Frame-Options** | 指示浏览器是否可以在**<frame>**、**<iframe>**、**<embed>**或**<object>**
    HTML元素中渲染页面 |'
- en: '| **X-Permitted-Cross-Domain-Policies** | Instructs the browser on how to handle
    requests over a cross-domain |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **X-Permitted-Cross-Domain-Policies** | 指示浏览器如何处理跨域请求 |'
- en: '| **X-XSS-Protection** | Instructs the browser to stop page loading when a
    reflected XSS attack is detected |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **X-XSS-Protection** | 指示浏览器在检测到反射型XSS攻击时停止页面加载 |'
- en: 'Table 9.1: HTTP headers injected by Helmet and their use'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1：Helmet注入的HTTP头信息及其用途
- en: 'The **helmet** module sets the injected HTTP headers to sensible secure defaults.
    However, they can be customized. For example, you could manually set the value
    of **Referrer-Policy** to the **no-referrer** header using the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**头盔**模块将注入的HTTP头设置为合理的默认安全值。然而，它们可以被自定义。例如，你可以使用以下代码手动设置**Referrer-Policy**的值为**no-referrer**头：'
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Additional HTTP headers can also be set using the **helmet** module. For more
    information, please refer to the Helmet documentation ( [https://helmetjs.github.io/](https://helmetjs.github.io/)
    ).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用**头盔**模块设置额外的HTTP头。有关更多信息，请参阅头盔文档（[https://helmetjs.github.io/](https://helmetjs.github.io/)）。
- en: 'Some other popular web frameworks can also integrate the **helmet** middleware
    via the following modules:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他流行的Web框架也可以通过以下模块集成**头盔**中间件：
- en: '**Koa.js** : [https://www.npmjs.com/package/koa-helmet](https://www.npmjs.com/package/koa-helmet)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Koa.js** : [https://www.npmjs.com/package/koa-helmet](https://www.npmjs.com/package/koa-helmet)'
- en: '**Fastify** : [https://www.npmjs.com/package/@fastify/helmet](https://www.npmjs.com/package/@fastify/helmet)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fastify** : [https://www.npmjs.com/package/@fastify/helmet](https://www.npmjs.com/package/@fastify/helmet)'
- en: There’s more…
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The **helmet** middleware simply modifies the response headers to appropriate
    defaults. To demonstrate what **helmet** is doing under the covers, we can try
    injecting the same HTTP headers using the Node.js core **http** module:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**头盔**中间件只是将响应头修改为适当的默认值。为了演示**头盔**在幕后做了什么，我们可以尝试使用Node.js核心**http**模块注入相同的HTTP头：'
- en: 'Create a folder called **http-app** and create a **server.js** file:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**http-app**的文件夹，并创建一个**server.js**文件：
- en: '[PRE43]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the following code to the **server.js** file:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到**server.js**文件中：
- en: '[PRE44]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Start the server:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器：
- en: '[PRE45]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Rerun the *cURL* command and observe that the headers have been injected:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行*cURL*命令并观察头部是否已注入：
- en: '[PRE46]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: These steps demonstrate how to manually inject HTTP security headers using the
    Node.js core **http** module, replicating the functionality provided by the **helmet**
    middleware. This example illustrates how **helmet** enhances security by setting
    various HTTP headers that mitigate common vulnerabilities.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤演示了如何使用Node.js核心**http**模块手动注入HTTP安全头，复制**头盔**中间件提供的功能。此示例说明了**头盔**如何通过设置各种HTTP头减轻常见漏洞来增强安全性。
- en: See also
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Guarding against cross-site scripting* recipe in this chapter
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*防御跨站脚本*菜谱
- en: The *Preventing cross-site request forgery* recipe in this chapter
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*预防跨站请求伪造*菜谱
- en: Anticipating malicious input
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防恶意输入
- en: One of the easiest groups of vulnerabilities that hackers exploit is injection
    attacks, with SQL injection attacks being particularly common. SQL injection attacks
    are where an attacker injects malicious SQL into an application to delete, distort,
    or expose data stored in the database.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客利用的最容易的一组漏洞是注入攻击，其中SQL注入攻击尤为常见。SQL注入攻击是指攻击者将恶意SQL注入到应用程序中，以删除、扭曲或暴露存储在数据库中的数据。
- en: If an application accepts input in any form, you need to take necessary precautions
    to ensure that malicious inputs cannot exploit your application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序以任何形式接受输入，你需要采取必要的预防措施，以确保恶意输入不能利用你的应用程序。
- en: Parameter pollution is a type of injection attack where the HTTP parameters
    of a web application’s HTTP endpoints are injected with specific malicious input.
    HTTP parameter pollution can be used to expose internal data or even cause a **denial
    of service** ( **DoS** ) attack, where an attacker tries to interrupt a resource
    and render it inaccessible to the resource’s intended users.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 参数污染是一种注入攻击，其中Web应用程序的HTTP端点的HTTP参数被注入了特定的恶意输入。HTTP参数污染可以用来暴露内部数据，甚至导致**拒绝服务**（**DoS**）攻击，攻击者试图中断资源，使其对预期用户不可访问。
- en: In this recipe, we’ll look at how we can protect an HTTP server against parameter
    pollution attacks. Parameter pollution attacks are where malicious input is injected
    into URL parameters.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何保护HTTP服务器免受参数污染攻击。参数污染攻击是指恶意输入被注入到URL参数中。
- en: Getting ready
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we’ll learn how to protect an Express.js server against an
    HTTP parameter pollution attack. But first, we must create this Express.js server:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何保护Express.js服务器免受HTTP参数污染攻击。但首先，我们必须创建这个Express.js服务器：
- en: 'Create a new directory named **express-input** for this recipe and initialize
    the project with **npm** :'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此菜谱创建一个名为**express-input**的新目录，并使用**npm**初始化项目：
- en: '[PRE47]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we need to install the Express.js module:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装Express.js模块：
- en: '[PRE48]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a file named **server.js** :'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**server.js**的文件：
- en: '[PRE49]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add the following code to **server.js** . This will create an Express.js server
    that is susceptible to an HTTP parameter pollution attack:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到**server.js**中。这将创建一个易受HTTP参数污染攻击的Express.js服务器：
- en: '[PRE50]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that the **asyncWork()** function is for demonstrational purposes only.
    In a real application, you could expect some asynchronous tasks to happen, such
    as a query to be made to a database or external service.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，**asyncWork()**函数仅用于演示目的。在实际应用中，你可能会期望一些异步任务发生，例如对数据库或外部服务的查询。
- en: Now that we’ve created a vulnerable server, we’re ready to start this recipe,
    where we’ll demonstrate how to exploit this vulnerability and learn how to mitigate
    it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个有漏洞的服务器，我们准备开始这个菜谱，我们将演示如何利用这个漏洞并学习如何减轻它。
- en: How to do it…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'So far, we’ve created an Express.js server that responds to the **/** request
    and handles a single parameter, **msg** . The Express.js server returns the **msg**
    value we pass it but in uppercase form:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个Express.js服务器，它可以响应**/**请求并处理单个参数**msg**。Express.js服务器返回我们传递给它的**msg**值，但以大写形式：
- en: 'First, start the server:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，启动服务器：
- en: '[PRE51]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In a second terminal window, we should test that the server is working as expected
    by sending a request:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个终端窗口中，我们应该通过发送请求来测试服务器是否按预期工作：
- en: '[PRE52]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s see what happens when we pass the **msg** parameter twice:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看当我们两次传递**msg**参数时会发生什么：
- en: '[PRE53]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, if we go back to our first terminal window, we’ll see that the server
    has crashed with the following error:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们回到第一个终端窗口，我们会看到服务器因以下错误而崩溃：
- en: '[PRE54]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So, it’s possible to cause the server to crash just by sending duplicate parameters.
    This makes it fairly easy for a perpetrator to launch an effective DoS attack.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，仅通过发送重复参数就可以导致服务器崩溃。这使得攻击者发起有效的DoS攻击变得相对容易。
- en: 'The error message states **.toUpperCase is not a function** . The **toUpperCase()**
    function is available on **String.prototype** . This means that the value we call
    this function on is not of the **String.prototype** type, resulting in **TypeError**
    . This happened because the multiple **msg** values have been transformed into
    an array. To protect against this, we should add some logic so that we always
    take the last value of **msg** when multiple values are specified. Let’s add this
    logic to a copy of **server.js** , which we’ll name **fixed-server.js** :'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误信息指出**.toUpperCase is not a function**。**toUpperCase()**函数在**String.prototype**上可用。这意味着我们调用此函数的值不是**String.prototype**类型，导致**TypeError**。这是因为在多个**msg**值被转换成了一个数组。为了防止这种情况，我们应该添加一些逻辑，确保在指定多个值时始终取**msg**的最后一个值。让我们将这个逻辑添加到**server.js**的一个副本中，我们将它命名为**fixed-server.js**：
- en: '[PRE55]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, add the following two lines to our **asyncWork()** callback function within
    the HTTP **GET** request handler. The first line extracts the value of **req.query.msg**
    to a variable named **msg** . The second line will use the **array.pop()** method
    to override the value of **msg** with the final element of **Array** :'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下两行添加到HTTP **GET**请求处理程序中的**asyncWork()**回调函数内。第一行将**req.query.msg**的值提取到名为**msg**的变量中。第二行将使用**array.pop()**方法用数组的最后一个元素覆盖**msg**的值：
- en: '[PRE56]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, the following line needs to be updated so that it references the **msg**
    variable:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要更新以下行，以便它引用**msg**变量：
- en: '[PRE57]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Start the fixed server:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动修复后的服务器：
- en: '[PRE58]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, let’s retry our request, where we pass the **msg** parameter twice:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重试我们的请求，其中我们两次传递**msg**参数：
- en: '[PRE59]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Our logic to always set the **msg** variable to the last value is working. Observe
    that the server no longer crashes.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将**msg**变量始终设置为最后一个值的逻辑正在起作用。注意，服务器不再崩溃。
- en: With that, we’ve learned how URL parameters can be exploited to cause DoS attacks
    and how we can add logic to our code to guard against these attacks.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经了解了如何利用URL参数来造成DoS攻击，以及我们如何在我们的代码中添加逻辑来防范这些攻击。
- en: How it works…
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Injection attacks are made possible when inputs aren’t sanitized appropriately.
    In this recipe, we wrongly assumed that the **msg** parameter would only ever
    be a string.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入没有适当清理时，就会发生注入攻击。在这个菜谱中，我们错误地假设**msg**参数将始终是一个字符串。
- en: Many Node.js web frameworks support duplicate parameters in URLs, despite there
    being no specification on how these should be handled.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Node.js网络框架支持URL中的重复参数，尽管没有规定如何处理这些参数。
- en: Express.js depends on the **qs** module for URL parameter handling. The **qs**
    module’s approach to handling multiple parameters of the same name is to convert
    the duplicate names into an array. As demonstrated in this recipe, this conversion
    results in code breakages and unexpected behavior.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js依赖于**qs**模块来处理URL参数。**qs**模块处理同名多个参数的方法是将重复的名称转换为数组。正如本配方中所示，这种转换会导致代码中断和意外行为。
- en: In this recipe, our server crashed because it was trying to call the **toUpperCase()**
    function on an **Array** global object, which doesn’t exist on that type. This
    means that attackers have a very easily exploitable method of disabling servers
    by supplying malformed/malicious input. Other than enabling DoS-style attacks,
    not sanitizing and validating input parameters can lead to XSS attacks. XSS attacks
    will be covered in more detail in the *Guarding against XSS attacks* recipe of
    this chapter.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们的服务器崩溃是因为它试图在一个不存在的**Array**全局对象上调用**toUpperCase()**函数，该类型上不存在这种类型。这意味着攻击者有一个非常容易利用的方法，通过提供格式错误/恶意输入来禁用服务器。除了启用DoS风格的攻击之外，不清理和验证输入参数可能导致XSS攻击。XSS攻击将在本章的*防范XSS攻击*配方中更详细地介绍。
- en: There’s more…
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Node.js **Buffer** objects can be exploited by attackers if used incorrectly
    in application code. **Buffer** objects represent a fixed-length series of bytes
    and are a subclass of JavaScript’s **Uint8Array()** class. In many cases, you’ll
    be interacting with **Buffer** objects via higher-level APIs, such as using **fs.readFile()**
    to read files. However, in cases where you need to interact with binary data directly,
    you may use **Buffer** objects since they provide low-level fine-grained APIs
    for data manipulation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序代码中使用不当，Node.js的**Buffer**对象可能会被攻击者利用。**Buffer**对象代表一系列固定长度的字节，并且是JavaScript的**Uint8Array()**类的子类。在许多情况下，您将通过高级API与**Buffer**对象交互，例如使用**fs.readFile()**读取文件。然而，在需要直接与二进制数据交互的情况下，您可以使用**Buffer**对象，因为它们提供了用于数据操作的低级细粒度API。
- en: In past years, a lot of attention was brought to the unsafe uses of Node.js’s
    **Buffer** constructor. Earlier concerns about using the **Buffer** constructor
    were regarding it not zero-filling new **Buffer** instances, leading to the risk
    of sensitive data being exposed via memory.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，人们对Node.js的**Buffer**构造函数的不安全使用给予了大量关注。早期对使用**Buffer**构造函数的担忧是它不会为零填充新的**Buffer**实例，这可能导致通过内存暴露敏感数据的风险。
- en: Important note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: All of the following examples were created via the Node.js REPL. The Node.js
    REPL can be started by entering **$ node** in your terminal window.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的以下示例都是通过Node.js REPL创建的。您可以通过在终端窗口中输入**$ node**来启动Node.js REPL。
- en: 'In Node.js 6, calling **new Buffer(int)** would create a new **Buffer** object
    but not override any existing memory:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js 6中，调用**new Buffer(int)**将创建一个新的**Buffer**对象，但不会覆盖任何现有内存：
- en: '[PRE60]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The security implications of this were recognized. By not overwriting the data
    when we initialize a new **Buffer** object, we could accidentally expose some
    of the previous memory. In the worst cases, this could expose sensitive data.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的安全影响已被认识到。在初始化一个新的**Buffer**对象时，如果没有覆盖数据，我们可能会意外地暴露一些之前的内存。在最坏的情况下，这可能会暴露敏感数据。
- en: 'However, in versions of Node.js later than version 8, calling **Buffer(int)**
    will result in a zero-filled **Buffer** object of **int** size:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Node.js 8之后的版本中，调用**Buffer(int)**将导致一个大小为**int**的零填充**Buffer**对象：
- en: '[PRE61]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Calling **new Buffer(int)** is still deprecated and as of Node.js 22, using
    this constructor will emit a deprecation warning:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 调用**new Buffer(int)**仍然被弃用，并且从Node.js 22开始，使用此构造函数将发出弃用警告：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is because there are still security risks associated with using the new
    **Buffer(int)** constructor. Let’s demonstrate that risk now.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为使用新的**Buffer(int)**构造函数仍然存在安全风险。现在让我们展示这个风险。
- en: 'Imagine that our application accepted some user input in JSON form and we created
    a **new Buffer()** object from one of the values:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们的应用程序接受了一些用户以JSON形式输入的数据，并从其中一个值创建了一个**new Buffer()**对象：
- en: '[PRE63]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can see that this works as expected (ignoring the deprecation warning).
    Calling **Buffer(string)** creates a new **Buffer** object containing the string
    value. Now, let’s see what happens if we set **msg** to a number rather than a
    string:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这正如预期的那样工作（忽略弃用警告）。调用**Buffer(string)**创建一个包含字符串值的新的**Buffer**对象。现在，让我们看看如果我们将**msg**设置为数字而不是字符串会发生什么：
- en: '[PRE64]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This has created a **Buffer** object of size **10** . So, an attacker could
    pass any value via the **msg** property, and a **Buffer** object of that size
    would be created. A simple DoS attack could be launched by the attacker by supplying
    large integer values on each request.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经创建了一个大小为 **10** 的 **Buffer** 对象。因此，攻击者可以通过 **msg** 属性传递任何值，并创建一个同样大小的 **Buffer**
    对象。攻击者可以通过在每个请求中提供大整数值来发起简单的 DoS 攻击。
- en: 'The deprecation warning recommends using **Buffer.from(req.body.string)** instead.
    Upon passing the **Buffer.from()** method, a number will throw an exception:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 弃用警告建议使用 **Buffer.from(req.body.string)** 代替。在传递给 **Buffer.from()** 方法时，一个数字将抛出异常：
- en: '[PRE65]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This helps protect our code from unexpected input. To create a new **Buffer**
    object of a given size, you should use the **Buffer.alloc(int)** method:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于保护我们的代码免受意外输入的影响。要创建一个给定大小的新的 **Buffer** 对象，您应该使用 **Buffer.alloc(int)**
    方法：
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'There is also a **Buffer.allocUnsafe()** constructor. The **Buffer.allocUnsafe()**
    constructor provides similar behavior to that seen in Node.js versions before
    Node.js 7, where the memory wasn’t entirely zero-filled on initialization:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 **Buffer.allocUnsafe()** 构造函数。**Buffer.allocUnsafe()** 构造函数提供了与 Node.js
    7 之前版本中类似的行为，其中初始化时内存并未完全填充为零：
- en: '[PRE67]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: For the reasons mentioned earlier, use the **Buffer.allocUnsafe()** constructor
    with caution.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面提到的原因，请谨慎使用 **Buffer.allocUnsafe()** 构造函数。
- en: See also
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Preventing JSON pollution* recipe in this chapter
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *防止 JSON 污染* 菜谱
- en: The *Guarding against cross-site scripting* in this chapter
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *防止跨站脚本攻击*
- en: The *Preventing cross-site request forgery* in this chapter
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *防止跨站请求伪造*
- en: Preventing JSON pollution
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止 JSON 污染
- en: The JavaScript language allows all **Object** attributes to be altered. In a
    JSON pollution attack, an attacker leverages this ability to override built-in
    attributes and functions with malicious code.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 语言允许所有 **Object** 属性被修改。在 JSON 污染攻击中，攻击者利用这种能力用恶意代码覆盖内置属性和函数。
- en: Applications that accept JSON as user input are the most susceptible to these
    attacks. In the most severe cases, it’s possible to crash a server by just supplying
    additional values in JSON input. This can make the server vulnerable to DoS attacks
    via JSON pollution.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接受 JSON 作为用户输入的应用程序最容易受到这些攻击。在最严重的情况下，仅通过在 JSON 输入中提供额外的值就可能导致服务器崩溃。这会使服务器容易受到通过
    JSON 污染的 DoS 攻击。
- en: The key to preventing JSON pollution attacks is to validate all JSON input.
    This can be done manually or by defining a schema for your JSON to validate against.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 防止 JSON 污染攻击的关键是验证所有 JSON 输入。这可以手动完成，也可以通过为您的 JSON 定义一个架构来验证。
- en: In this recipe, we’re going to demonstrate a JSON pollution attack and learn
    how to protect against these attacks by validating our JSON input. Specifically,
    we’ll be using **Another JSON Schema Validator** ( **Ajv** ) to validate our JSON
    input.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将演示一个 JSON 污染攻击，并学习如何通过验证我们的 JSON 输入来保护我们免受这些攻击：具体来说，我们将使用 **Another
    JSON Schema Validator** ( **Ajv** ) 来验证我们的 JSON 输入。
- en: Getting ready
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To prepare for this recipe, we must create a server that’s susceptible to a
    JSON pollution attack. The server will accept **msg** and **name** as the body
    payload and respond with a message built with these values:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个菜谱，我们必须创建一个容易受到 JSON 污染攻击的服务器。该服务器将接受 **msg** 和 **name** 作为正文负载，并使用这些值构建消息进行响应：
- en: 'First, let’s create a new directory named **json-pollution** to work in and
    initialize it with **npm** :'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的名为 **json-pollution** 的目录来工作，并使用 **npm** 初始化它：
- en: '[PRE68]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, create a file named **server.js** :'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为 **server.js** 的文件：
- en: '[PRE69]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add the following code to **server.js** :'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 **server.js** 中：
- en: '[PRE70]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now that we’ve created our vulnerable server, we’re ready to start this recipe.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个易受攻击的服务器，我们可以开始这个菜谱了。
- en: How to do it…
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we’re going to demonstrate a JSON pollution attack and learn
    how to use a JSON schema to protect our applications from these attacks:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将演示一个 JSON 污染攻击，并学习如何使用 JSON 架构来保护我们的应用程序免受这些攻击：
- en: 'Start the server with the following command:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动服务器：
- en: '[PRE71]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, we’ll send an HTTP **POST** request to **http://localhost:3000** using
    *cURL* . We’ll supply the **curl** command with the **-X** argument to specify
    the HTTP request method and the **-d** argument to supply the data. In a second
    terminal window, send the following **cURL** request:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 *cURL* 向 **http://localhost:3000** 发送 HTTP **POST** 请求。我们将向 **curl**
    命令提供 **-X** 参数来指定 HTTP 请求方法，以及 **-d** 参数来提供数据。在第二个终端窗口中，发送以下 **cURL** 请求：
- en: '[PRE72]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As expected, the server responds with a greeting.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期，服务器以问候语作为响应。
- en: 'Now, let’s try altering the payload so that it sends an additional JSON property
    named **hasOwnProperty** :'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试修改有效载荷，使其发送一个名为 **hasOwnProperty** 的额外 JSON 属性：
- en: '[PRE73]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note the empty reply from the server.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意来自服务器的空回复。
- en: 'Check the terminal window where you’re running the server. You should see that
    it’s crashed with the following error:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您运行服务器的终端窗口。您应该看到它崩溃并显示以下错误：
- en: '[PRE74]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Our server has crashed because the **hasOwnProperty()** function has been overridden
    by the **hasOwnProperty** value in the JSON input. We can protect against this
    by validating our JSON input using the Ajv module. So, install the Ajv module
    from **npm** :'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 JSON 输入中的 **hasOwnProperty()** 函数被 **hasOwnProperty** 值覆盖，我们的服务器崩溃了。我们可以通过使用
    Ajv 模块验证我们的 JSON 输入来防止这种情况。因此，从 **npm** 安装 Ajv 模块：
- en: '[PRE75]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we’ll copy our **server.js** file to a new file named **fixed-server.js**
    :'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的 **server.js** 文件复制到一个名为 **fixed-server.js** 的新文件中：
- en: '[PRE76]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Add the following code to **fixed-server.js** to import the **ajv** module
    and define a JSON schema for our JSON input. Note that this code should be added
    just below the **STATUS_CODES** destructuring:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 **fixed-server.js** 中以导入 **ajv** 模块并定义 JSON 输入的 JSON 模式。注意，此代码应添加在
    **STATUS_CODES** 解构下方：
- en: '[PRE77]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The greeting function needs to be altered to validate the JSON input against
    the schema:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 欢迎函数需要修改以验证 JSON 输入与模式：
- en: '[PRE78]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, we’ve added a conditional statement that calls the **validate()** method
    within our **greeting()** function, which validates the schema.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们添加了一个条件语句，该语句在 **greeting()** 函数内调用 **validate()** 方法，该方法验证模式。
- en: 'Start the fixed server:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动固定的服务器：
- en: '[PRE79]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Retry the same request in an attempt to override the **hasOwnProperty()** method.
    Observe that it receives no response and no longer crashes the server:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新尝试相同的请求以尝试覆盖 **hasOwnProperty()** 方法。观察它没有收到响应，并且服务器不再崩溃：
- en: '[PRE80]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: With that, we’ve protected our server against a JSON pollution attack by validating
    the input against a JSON schema.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们通过验证输入与 JSON 模式来保护我们的服务器免受 JSON 污染攻击。
- en: How it works…
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we demonstrated a JSON pollution attack. To do this, we created
    a simple Express.js server that had one route handler for HTTP **POST** requests
    at **http://localhost:3000** . For each request, our **greeting()** function is
    called. The **greeting()** function parses the request data as JSON and then aggregates
    the **msg** and **name** values that were supplied as request parameters. The
    aggregated string is returned as the response to the request.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们演示了 JSON 污染攻击。为此，我们创建了一个简单的 Express.js 服务器，该服务器在 **http://localhost:3000**
    上有一个处理 HTTP **POST** 请求的路由处理程序。对于每个请求，我们的 **greeting()** 函数会被调用。**greeting()**
    函数将请求数据解析为 JSON，然后聚合作为请求参数提供的 **msg** 和 **name** 值。聚合后的字符串作为对请求的响应返回。
- en: In our **server.js** file, we were using the **Object.prototype.hasOwnProperty()**
    method, which is a built-in method available on all objects. However, it was possible
    to override the **Object.prototype.hasOwnProperty()** method by passing a **hasOwnProperty**
    property in our JSON input. Because we set the **hasOwnProperty** value to **0**
    in our JSON input, the server crashed when our code attempted to call **data.hasOwnProperty()**
    – because that value had been overridden to **0** , rather than a function.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 **server.js** 文件中，我们使用了 **Object.prototype.hasOwnProperty()** 方法，这是一个在所有对象上可用的内置方法。然而，通过在我们的
    JSON 输入中传递一个 **hasOwnProperty** 属性，我们可以覆盖 **Object.prototype.hasOwnProperty()**
    方法。由于我们在 JSON 输入中将 **hasOwnProperty** 值设置为 **0**，当我们的代码尝试调用 **data.hasOwnProperty()**
    时，服务器崩溃了——因为该值已被覆盖为 **0**，而不是一个函数。
- en: When a public-facing application accepts JSON input, it’s necessary to take
    steps in the application against JSON pollution attacks. One of the ways we covered
    for protecting applications from these attacks is by using a JSON Schema validator.
    It validated that the properties and values of our JSON input match those we expect.
    In this recipe, we used Ajv to define a schema to accomplish this. Ajv uses the
    **JSON Schema** ( [https://json-schema.org/](https://json-schema.org/) ) format
    to define object schemas.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个面向公众的应用程序接受 JSON 输入时，有必要在应用程序中采取措施来防范 JSON 污染攻击。我们介绍的一种保护应用程序免受这些攻击的方法是使用
    JSON Schema 验证器。它验证我们的 JSON 输入属性和值是否与我们预期的相匹配。在这个菜谱中，我们使用了 Ajv 来定义一个模式以实现这一点。Ajv
    使用 **JSON Schema** ( [https://json-schema.org/](https://json-schema.org/) ) 格式来定义对象模式。
- en: 'Our schema required the JSON input to have a **msg** property and allow an
    optional **name** property. It also specified that both inputs must be of the
    **string** type. The **additionalProperties: false** configuration disallowed
    additional properties, causing the validation to fail when we supplied **hasOwnProperty**
    in the JSON input, making it impossible to override the **Object.prototype.hasOwnProperty**
    method.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的架构要求 JSON 输入必须包含 **msg** 属性，并允许可选的 **name** 属性。它还指定了两个输入都必须是 **string**
    类型。**additionalProperties: false** 配置禁止了额外的属性，导致我们在 JSON 输入中提供 **hasOwnProperty**
    时验证失败，这使得无法覆盖 **Object.prototype.hasOwnProperty** 方法。'
- en: See also
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考也
- en: The *Anticipating malicious input* recipe in this chapter
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *预测恶意输入* 示例
- en: The *Guarding against cross-site scripting* recipe in this chapter
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *防范跨站脚本* 示例
- en: The *Preventing cross-site request forgery* recipe in this chapter
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *防止跨站请求伪造* 示例
- en: Guarding against cross-site scripting
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防范跨站脚本
- en: XSS attacks are client-side injection attacks where malicious scripts are injected
    into websites. XSS vulnerabilities are very dangerous as they can compromise trusted
    websites.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 攻击是客户端注入攻击，恶意脚本被注入到网站中。XSS 漏洞非常危险，因为它们可以危害受信任的网站。
- en: In this recipe, we’re going to demonstrate an XSS vulnerability and learn how
    we can protect against them. We’ll be using the **he** ( [https://www.npmjs.com/package/he](https://www.npmjs.com/package/he)
    ) **npm** module to do so.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将演示一个 XSS 漏洞，并学习我们如何保护自己。我们将使用 **he** ( [https://www.npmjs.com/package/he](https://www.npmjs.com/package/he)
    ) **npm** 模块来完成此操作。
- en: Getting ready
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we’ll create an Express.js server that’s vulnerable to an XSS
    attack. To do so, we must create the vulnerable Express.js server:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个易受 XSS 攻击的 Express.js 服务器。为此，我们必须创建一个易受攻击的 Express.js 服务器：
- en: 'First, let’s create a directory named **express-xss** to work in:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 **express-xss** 的目录来工作：
- en: '[PRE81]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, we need to install **express** :'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要安装 **express**：
- en: '[PRE82]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create a file where you’ll store the Express.js server:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件，用于存储 Express.js 服务器：
- en: '[PRE83]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Add the following to **server.js** . This will create a server that renders
    a simple HTML web page that’s susceptible to an XSS attack:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 **server.js** 中。这将创建一个服务器，渲染一个简单的 HTML 网页，该网页易受 XSS 攻击：
- en: '[PRE84]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now, we’re ready to move on to this recipe.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备进入这个示例。
- en: How to do it…
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we’ll learn how to exploit and mitigate XSS attacks:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何利用和缓解 XSS 攻击：
- en: 'First, start the server with the following command:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令启动服务器：
- en: '[PRE85]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The server is emulating a service status web page. The web page accepts three
    parameters: **previous** , **token** , and **lang** . It’s common practice to
    have parameters such as these injected into URLs in real-world web applications.
    Navigate to **http://localhost:3000/?previous=/&token=TOKEN&lang=en** ; expect
    to see the following output:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器正在模拟一个服务状态网页。该网页接受三个参数：**previous**、**token** 和 **lang**。在现实世界的 Web 应用程序中，将这些参数注入到
    URL 中是一种常见做法。导航到 **http://localhost:3000/?previous=/&token=TOKEN&lang=en**；预期将看到以下输出：
- en: '![Figure 9.5 – Demonstrative service status web page showing “All systems are
    running.”](img/B19212_09_05.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 展示“所有系统正常运行”的演示服务状态网页](img/B19212_09_05.jpg)'
- en: Figure 9.5 – Demonstrative service status web page showing “All systems are
    running.”
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 展示“所有系统正常运行”的演示服务状态网页
- en: 'Now, we can craft an XSS attack. We will craft a URL that will inject parameters
    to change the service status message to **All systems are down!** . We’re aiming
    to inject the following JavaScript via the URL parameters:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以构建一个 XSS 攻击。我们将构建一个 URL，通过 URL 参数注入参数以将服务状态消息更改为 **所有系统已关闭**！我们的目标是通过
    URL 参数注入以下 JavaScript：
- en: '[PRE86]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can inject this script using the following HTTP request:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下 HTTP 请求注入此脚本：
- en: '[PRE87]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, the web page will show **All systems are down!** . So, visitors to our
    legitimate service status page will see a malicious message. These attacks typically
    send the malicious URL to an unsuspecting consumer of the website:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，网页将显示 **所有系统已关闭**！因此，访问我们合法的服务状态页面的访客将看到一条恶意消息。这些攻击通常会将恶意 URL 发送到对网站一无所知的消费者：
- en: '![Figure 9.6 – Demonstrative service status web page showing “All systems are
    down!”](img/B19212_09_06.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 展示“所有系统已关闭！”的演示服务状态网页](img/B19212_09_06.jpg)'
- en: Figure 9.6 – Demonstrative service status web page showing “All systems are
    down!”
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 展示“所有系统已关闭！”的演示服务状态网页
- en: 'We can see the code that’s been injected by using the **View Page Source**
    interface in your browser. If you’re on macOS, you should be able to use the *Command*
    + *Option* + *U* shortcut to open the **View Page** **Source** interface:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用浏览器中的 **查看页面源代码** 界面来查看已注入的代码。如果您使用的是 macOS，您应该能够使用 *Command* + *Option*
    + *U* 快捷键打开 **查看页面源代码** 界面：
- en: '![Figure 9.7 – View Page Source showing the injected JavaScript](img/B19212_09_07.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 显示注入 JavaScript 的页面源代码](img/B19212_09_07.jpg)'
- en: Figure 9.7 – View Page Source showing the injected JavaScript
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 显示注入 JavaScript 的页面源代码
- en: 'To fix the application, we need to escape/sanitize the input. Copy the **server.js**
    file to a file named **fixed-server.js** :'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复应用程序，我们需要对输入进行转义/清理。将 **server.js** 文件复制到一个名为 **fixed-server.js** 的文件中：
- en: '[PRE88]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'To escape or sanitize the input, we’ll use a module named **he** . Install
    **he** from the **npm** registry:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要转义或清理输入，我们将使用一个名为 **he** 的模块。从 **npm** 注册表安装 **he**：
- en: '[PRE89]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We need to add the import for **he** to **fixed-server.js** . Add the following
    line of code below the **express** module import:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 **fixed-server.js** 中添加对 **he** 的导入。在 **express** 模块导入下方添加以下代码行：
- en: '[PRE90]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then, we can set the **href** value using **he** . Alter the route handler
    as follows:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 **he** 设置 **href** 值。按如下方式修改路由处理程序：
- en: '[PRE91]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Start the fixed server:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动修复后的服务器：
- en: '[PRE92]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Attempt to access the malicious URL again:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试访问恶意 URL：
- en: '[PRE93]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Observe that this time, we get the expected **All systems are running.** output.
    Our injection attack no longer works:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，这次我们得到了预期的 **所有系统正常运行** 输出。我们的注入攻击不再有效：
- en: '![Figure 9.8 – Demonstrative service status web page showing “All systems are
    running.”](img/B19212_09_08.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 显示“所有系统正常运行”的服务状态网页](img/B19212_09_08.jpg)'
- en: Figure 9.8 – Demonstrative service status web page showing “All systems are
    running.”
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 显示“所有系统正常运行”的服务状态网页
- en: With that, we’ve learned how to use the **he** module to prevent an XSS attack.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就学会了如何使用 **he** 模块来防止 XSS 攻击。
- en: How it works…
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'XSS attacks are client-side injection attacks where malicious scripts are injected
    into trusted websites. The general flow of an XSS attack is as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 攻击是客户端注入攻击，恶意脚本被注入到受信任的网站中。XSS 攻击的一般流程如下：
- en: Malicious input enters the application – typically via a web request.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意输入进入应用程序——通常是通过网络请求。
- en: The input is rendered as dynamic content on the web page because the input hasn’t
    been sanitized appropriately.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入被渲染为网页上的动态内容，因为输入没有被适当清理。
- en: The two main types of XSS attacks are persistent XSS and reflected XSS. With
    persistent XSS attacks, malicious data is injected into a persistence layer of
    the system. For example, it could be injected into a field within a database.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 攻击主要有两种类型：持久型 XSS 和反射型 XSS。持久型 XSS 攻击中，恶意数据被注入到系统的持久层中。例如，它可能被注入到数据库中的一个字段中。
- en: Reflected XSS attacks are reliant on a single interaction with the server –
    for example, sending a single HTTP request. The attack demonstrated in this recipe
    was a reflected XSS attack sent over an HTTP request containing malicious input.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 反射型 XSS 攻击依赖于与服务器的一次单独交互——例如，发送单个 HTTP 请求。本食谱中演示的攻击是通过包含恶意输入的 HTTP 请求发送的反射型
    XSS 攻击。
- en: 'The exploit in this recipe was due to the way the **href** value was formulated
    for the **Back** link. We started the injection process by assigning the **%22%3E%3Cscri**
    value, which, when decoded, is equal to **"><scri** . This value closes an HTML
    anchor tag and starts an HTML script element that’s ready to inject our script.
    The remaining values are set to inject the following code into the web page:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的漏洞是由于为 **Back** 链接的 **href** 值制定的格式。我们通过分配 **%22%3E%3Cscri** 值开始注入过程，解码后等于
    **"><scri**。此值关闭 HTML 锚标签并开始一个准备注入我们的脚本的 HTML 脚本元素。其余值设置为将以下代码注入网页：
- en: '[PRE94]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note that the attack wouldn’t have worked with a single parameter as many modern
    browsers have built-in XSS auditors to prevent the obvious injection of **<**
    **script>** tags.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果只有一个参数，攻击将不会成功，因为许多现代浏览器都内置了 XSS 检查器来防止明显的 **<script>** 标签注入。
- en: Important note
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can use Node.js’s **decodeURI()** method to decode encoded URIs. For example,
    **$ node -p "decodeURI('%22%3E%3Cscri')"** would output **"><scri** .
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Node.js 的 **decodeURI()** 方法解码已编码的 URI。例如，**$ node -p "decodeURI('%22%3E%3Cscri')"**
    将输出 **"><scri**。
- en: We fixed this vulnerability using the **he** module. We use the **he** module’s
    **encode()** function to do so. This function accepts text that’s expected to
    be HTML or XML input and returns it in escaped form. This is how we sanitize the
    input and stop the **<script>** tag from being injected into the web page.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**he**模块修复了这个漏洞。我们使用**he**模块的**encode()**函数来这样做。这个函数接受预期为HTML或XML输入的文本，并以转义形式返回它。这就是我们清理输入并阻止**<script>**标签被注入到网页中的方法。
- en: All input to our server should be validated and sanitized before use. This includes
    indirect inputs to data stores as these may be used to conduct persistent XSS
    attacks.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器所有输入在使用之前都应该被验证和清理。这包括对数据存储的间接输入，因为这些可能被用来执行持久性XSS攻击。
- en: There’s more…
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some other types of XSS attacks that we can still use to harm our
    server. Let’s demonstrate these attacks and learn how we can help prevent them.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些其他类型的XSS攻击，我们可以用来损害我们的服务器。让我们演示这些攻击并学习如何帮助我们预防它们。
- en: Protocol-handler XSS
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议处理器XSS
- en: The fixed server from this recipe is still vulnerable to some other types of
    XSS. In this scenario, we’ll pretend that the status value is privileged information
    that the attacker shouldn’t be able to read.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱中的修复服务器仍然容易受到某些其他类型XSS的攻击。在这种情况下，我们将假设状态值是攻击者不应该能够读取的特权信息。
- en: The flow of this attack is to create a malicious data collection server that
    injects a script into the web page that obtains the information and then forwards
    it to the data collection server.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击的流程是创建一个恶意的数据收集服务器，它将脚本注入到网页中，获取信息然后转发到数据收集服务器。
- en: 'To demonstrate this, we need to create a data collection server:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们需要创建一个数据收集服务器：
- en: 'While still in the **express-xss** directory, create a file named **colletion-server.js**
    :'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**express-xss**目录下，创建一个名为**colletion-server.js**的文件：
- en: '[PRE95]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Then, add the following code to **collection-server.js** :'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下代码添加到**collection-server.js**中：
- en: '[PRE96]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, we can start the data collection server:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以启动数据收集服务器：
- en: '[PRE97]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In a second terminal window, restart the **fixed-server.js** file:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个终端窗口中，重新启动**fixed-server.js**文件：
- en: '[PRE98]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In your browser window, visit the following URL:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器窗口中，访问以下URL：
- en: '[PRE99]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The web page should look the same as before, still showing the **All systems
    are running.** message. However, the XSS injection has updated the **href** value
    of the **Back** hyperlink so that it directs us to the following:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网页应该看起来和之前一样，仍然显示**所有系统正在运行**的消息。然而，XSS注入已经更新了**返回**超链接的**href**值，使其指向以下内容：
- en: '[PRE100]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The link starts with **javascript:** , which is a protocol handler that allows
    JavaScript execution as a URI. When this link is clicked, an HTML image element
    ( **<img>** ) is created with the **src** value set to the address of our data
    collection server. The **btoa()** function Base64 encodes the value of the status.
    Here, **,0** is appended to the end to cause the expression to evaluate to **false**
    – ensuring that the image isn’t rendered.
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 链接以**javascript:**开头，这是一个允许JavaScript作为URI执行的协议处理器。当点击这个链接时，会创建一个HTML图像元素（**<img>**），其**src**值设置为我们的数据收集服务器地址。**btoa()**函数将状态值Base64编码。在这里，**,0**被附加到末尾，导致表达式评估为**false**
    - 确保图像不被渲染。
- en: 'Click the **Back** link and check the data collection server. You’ll see that
    the status has been received, as follows:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**返回**链接并检查数据收集服务器。你会看到状态已经被接收，如下所示：
- en: '[PRE101]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: To highlight the dangers of these attacks, imagine that this was real privileged
    data, such as credentials or tokens. By just sending a malicious link to a user
    and having them click on it, we could obtain their sensitive data via our collection
    server.
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了强调这些攻击的危险性，想象一下这如果是真实的特权数据，比如凭证或令牌。仅仅通过发送一个恶意链接给用户并让他们点击它，我们就可以通过我们的收集服务器获取他们的敏感数据。
- en: 'The server is still vulnerable because we can still inject values into the
    **href** attribute. The safest way to avoid this is by not allowing input to determine
    the value of the **href** attribute:'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器仍然容易受到攻击，因为我们仍然可以注入值到**href**属性中。避免这种情况最安全的方法是不允许输入确定**href**属性的值：
- en: 'Let’s copy **fixed-server.js** to a new file and fix it:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将**fixed-server.js**复制到一个新文件并修复它：
- en: '[PRE102]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We’ll fix this vulnerability by installing the **escape-html** module:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过安装**escape-html**模块来修复这个漏洞：
- en: '[PRE103]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Import the **escape-html** module in **fixed-server.js** by replacing the **he**
    module import with the following line:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过替换**he**模块导入以下行，在**fixed-server.js**中导入**escape-html**模块：
- en: '[PRE104]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then, change the **href** assignment to the following:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 **href** 赋值更改为以下内容：
- en: '[PRE105]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, start **protocol-safe-server.js** :'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，启动 **protocol-safe-server.js** :'
- en: '[PRE106]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'With the data collection server still running, revisit the malicious URL and
    click **Back** :'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在数据收集服务器仍在运行的情况下，重新访问恶意URL并点击 **后退** :'
- en: '[PRE107]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: You’ll observe that the request fails, and the data collection server doesn’t
    receive the privileged data. This is because the link to our malicious server
    has been sanitized.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 你会观察到请求失败，数据收集服务器没有接收到特权数据。这是因为指向我们恶意服务器的链接已经被清理。
- en: Important note
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This chapter covered HTML encoding and modules that can be used to help escape
    HTML. Similarly, for escaping JavaScript, the **jsesc** module ( [https://www.npmjs.com/package/jsesc](https://www.npmjs.com/package/jsesc)
    ) could be used. However, embedding input into JavaScript is generally considered
    high risk, so you should evaluate your reasons for doing so.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了HTML编码和可用于帮助转义HTML的模块。同样，对于转义JavaScript，可以使用**jsesc**模块（[https://www.npmjs.com/package/jsesc](https://www.npmjs.com/package/jsesc)）。然而，将输入嵌入到JavaScript中通常被认为风险很高，因此你应该评估你这样做的原因。
- en: Parameter validation
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数验证
- en: The browser can only show a portion of a very long URL in the address bar. This
    means that for very long URLs with many parameters, you may not see what’s appended
    to the end of the URL. This makes it more challenging to identify malicious URLs.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器只能在地址栏中显示非常长URL的一部分。这意味着对于具有许多参数的非常长URL，你可能看不到附加到URL末尾的内容。这使得识别恶意URL更具挑战性。
- en: 'If your application’s typical usage doesn’t involve very long URLs, then it
    would be prudent to add some constraints to what URLs your application will accept.
    Let’s do that now:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序的典型使用不涉及非常长的URL，那么为你的应用程序将接受的URL添加一些约束将是明智的。让我们现在就做这件事：
- en: 'Copy the **server.js** file to a new file named **constraints-server.js** :'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **server.js** 文件复制到名为 **constraints-server.js** 的新文件中：
- en: '[PRE108]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Define a **validateParameters()** function that validates the URL parameters
    in the **constraints-server.js** file:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **constraints-server.js** 文件中定义一个 **validateParameters()** 函数，用于验证URL参数：
- en: '[PRE109]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, we need to make a call to the **validateParameters()** function in our
    request handler. Change the request handler to the following:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的请求处理器中调用 **validateParameters()** 函数。将请求处理器更改为以下内容：
- en: '[PRE110]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Start **constraints-server.js** :'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '启动 **constraints-server.js** :'
- en: '[PRE111]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Test by navigating to the following URLs, all of which should fail validation
    checks:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到以下URL进行测试，所有这些URL都应该失败验证检查：
- en: '**http://localhost:3000/?previous=sixteencharacter&token=sixteencharacter**'
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http://localhost:3000/?previous=sixteencharacter&token=sixteencharacter**'
- en: '**http://localhost:3000/?previous=sixteencharacter&token=sixteencharacter&lang=en&extra=value**'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http://localhost:3000/?previous=sixteencharacter&token=sixteencharacter&lang=en&extra=value**'
- en: '**http://localhost:3000/?previous=characters&token=sixteencharacter&lang=abc**'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http://localhost:3000/?previous=characters&token=sixteencharacter&lang=abc**'
- en: 'The following URL should work as it satisfies all of the constraints:'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下URL应该可以正常工作，因为它满足了所有约束条件：
- en: '**http://localhost:3000/?previous=sixteencharacter&token=sixteencharacter&lang=en**'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http://localhost:3000/?previous=sixteencharacter&token=sixteencharacter&lang=en**'
- en: Any user input should be escaped and validated where possible to help prevent
    XSS injection attacks.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 应尽可能对用户输入进行转义和验证，以帮助防止XSS注入攻击。
- en: See also
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The *Anticipating malicious input* recipe in this chapter
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *预测恶意输入* 菜谱
- en: The *Preventing JSON pollution* recipe in this chapter
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *防止JSON污染* 菜谱
- en: The *Preventing cross-site request forgery* in this chapter
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *防止跨站请求伪造*
- en: Preventing cross-site request forgery
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止跨站请求伪造
- en: CSRF is an attack where a malicious web application causes a user’s web browser
    to execute an action on another trusted web application where the user is logged
    in.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF是一种攻击，恶意网络应用程序导致用户的网络浏览器在用户已登录的另一个受信任的网络应用程序上执行操作。
- en: In this recipe, we’re going to learn how to secure an Express.js server against
    CSRF attacks.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何保护Express.js服务器免受CSRF攻击。
- en: Important note
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Browser security has improved significantly in recent years. It’s very difficult
    to replicate a CSRF attack on any modern browser. However, as there are still
    many users on older browsers, it’s important to understand how these attacks work
    and how to protect against them. In this recipe, we’ll replicate a CSRF attack
    on the same domain. Please refer to the *Developers: Get Ready for New SameSite=None;
    Secure Cookie Settings* ( [https://blog.chromium.org/2019/10/developers-get-ready-for-new.html](https://blog.chromium.org/2019/10/developers-get-ready-for-new.html)
    ) Chromium blog, which covers some of the updates that have been made to Google
    Chrome to prevent CSRF attacks.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，浏览器安全得到了显著提高。在任何一个现代浏览器上复制 CSRF 攻击变得非常困难。然而，由于仍然有许多用户在使用旧版浏览器，了解这些攻击的工作原理以及如何保护自己是非常重要的。在这个配方中，我们将在同一域上复制
    CSRF 攻击。请参考 *开发者：为新的 SameSite=None; Secure Cookie 设置做好准备*（[https://blog.chromium.org/2019/10/developers-get-ready-for-new.html](https://blog.chromium.org/2019/10/developers-get-ready-for-new.html)）Chromium
    博客，该博客涵盖了 Google Chrome 为防止 CSRF 攻击所做的更新。
- en: Getting ready
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow these steps:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Start by creating a directory named **express-csrf** for this recipe and initializing
    the project with **npm** :'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先为这个配方创建一个名为 **express-csrf** 的目录，并使用 **npm** 初始化项目：
- en: '[PRE112]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Create a file named **server.js** . This will contain our server, which is
    vulnerable to CSRF attacks:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **server.js** 的文件。这将包含我们的服务器，该服务器容易受到 CSRF 攻击：
- en: '[PRE113]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In **server.js** , import the required modules and register the **express-session**
    middleware:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **server.js** 中，导入所需的模块并注册 **express-session** 中间件：
- en: '[PRE114]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Next, in **server.js** , we need to define the routes for our server:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 **server.js** 中，我们需要为我们的服务器定义路由：
- en: '[PRE115]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Then, add the following to **server.js** to start the server:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下内容添加到 **server.js** 中以启动服务器：
- en: '[PRE116]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Now, we’re ready to start this recipe.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始这个配方。
- en: How to do it…
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: First, we’ll create a malicious web page that can replicate a CSRF attack. After
    that, we’ll learn how to protect our Express.js server against these attacks.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个可以复制 CSRF 攻击的恶意网页。之后，我们将学习如何保护我们的 Express.js 服务器免受这些攻击。
- en: 'Your steps should be formatted like so:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 你的步骤应该格式如下：
- en: 'Start the server:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器：
- en: '[PRE117]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Navigate to **http://localhost:3000** in your browser and expect to see the
    following HTML login form. Enter **beth** as the username and **badpassword**
    as the password. Then, click **Submit** :'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中导航到 **http://localhost:3000** 并预期会看到以下 HTML 登录表单。将 **beth** 作为用户名，将 **badpassword**
    作为密码输入。然后，点击 **提交**：
- en: '![Figure 9.9 – Social Media Account – Login](img/B19212_09_09.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 社交媒体账户 – 登录](img/B19212_09_09.jpg)'
- en: Figure 9.9 – Social Media Account – Login
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 社交媒体账户 – 登录
- en: 'Once logged in, you should be taken to the **Settings** page of the demo social
    media profile. Notice that there’s a single field to update your email. Try updating
    the email to something else. You should see that the update is reflected after
    clicking **Update** :'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，你应该会被带到演示社交媒体资料的 **设置** 页面。注意，这里有一个字段可以更新你的电子邮件。尝试将电子邮件更新为其他内容。你应该会看到在点击
    **更新** 后更新被反映出来：
- en: '![Figure 9.10 – Social Media Account – Settings](img/B19212_09_10.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 社交媒体账户 – 设置](img/B19212_09_10.jpg)'
- en: Figure 9.10 – Social Media Account – Settings
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 社交媒体账户 – 设置
- en: 'Now, we’re going to create our malicious web page. Create a file named **csrf-server.js**
    . This is where we’ll build our malicious web page:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的恶意网页。创建一个名为 **csrf-server.js** 的文件。这是我们构建恶意网页的地方：
- en: '[PRE118]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Add the following code to create the malicious web page:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以创建恶意网页：
- en: '[PRE119]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'In a second terminal window, start the **csrf-server.js** server:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个终端窗口中，启动 **csrf-server.js** 服务器：
- en: '[PRE120]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Important note
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In a real CSRF attack, we’d expect the attack to come from a different domain
    to the vulnerable server. However, due to advances in web browser security, many
    CSRF attacks are prevented by the browser. For this recipe, we’ll demonstrate
    the attack on the same domain. Note that CSRF attacks are still possible today,
    particularly as many users may be using older browsers that don’t have the latest
    security features to protect against CSRF attacks.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实的 CSRF 攻击中，我们预计攻击会来自与易受攻击的服务器不同的域。然而，由于网络浏览器安全性的进步，许多 CSRF 攻击被浏览器阻止。对于这个配方，我们将演示在同一域上的攻击。请注意，CSRF
    攻击至今仍然可能发生，尤其是许多用户可能在使用没有最新安全特性来保护 CSRF 攻击的旧版浏览器。
- en: 'Navigate to **http://localhost:3001** in your browser. Expect to see the following
    output showing a single button:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中导航到 **http://localhost:3001**。预期会看到以下输出显示一个单按钮：
- en: '![Figure 9.11 – Malicious CSRF web page showing a suspicious “Click this to
    win!” button](img/B19212_09_11.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11 – 显示可疑“点击这个来赢！”按钮的恶意CSRF网页](img/B19212_09_11.jpg)'
- en: Figure 9.11 – Malicious CSRF web page showing a suspicious “Click this to win!”
    button
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 显示可疑“点击这个来赢！”按钮的恶意CSRF网页
- en: Click the **Click this to win!** button. By clicking the button, an HTTP **POST**
    request is sent to **http://localhost:3000/update** , with a body containing the
    **attacker@example.com** email. By clicking this button, the HTTP **POST** request
    has been sent to the real website’s server, leveraging the cookie stored in the
    browser.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**点击这个来赢！**按钮。通过点击按钮，发送了一个包含**attacker@example.com**电子邮件的HTTP **POST**请求到**http://localhost:3000/update**。通过点击这个按钮，HTTP
    **POST**请求已经发送到真实网站的服务器，利用浏览器中存储的cookie。
- en: 'Go back to the social media profile page and refresh it. We’ll see that the
    attacker has managed to update the email address:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回社交媒体个人资料页面并刷新它。我们会看到攻击者已经成功更新了电子邮件地址：
- en: '![Figure 9.12 – The Social Media Account – Settings page showing that the email
    has been updated to attacker@example.com](img/B19212_09_12.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 显示电子邮件已更新为attacker@example.com的社交媒体账户 – 设置页面](img/B19212_09_12.jpg)'
- en: Figure 9.12 – The Social Media Account – Settings page showing that the email
    has been updated to attacker@example.com
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 显示电子邮件已更新为attacker@example.com的社交媒体账户 – 设置页面
- en: 'Now, let’s fix the server so that it isn’t susceptible to CSRF attacks. First,
    copy the **server.js** file to a file named **fixed-server.js** :'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修复服务器，使其不受CSRF攻击的影响。首先，将**server.js**文件复制到名为**fixed-server.js**的文件中：
- en: '[PRE121]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'To fix the server, we need to add some additional configuration to the **express-session**
    middleware. Change the **express-session** configuration to the following:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复服务器，我们需要向**express-session**中间件添加一些额外的配置。将**express-session**配置更改为以下内容：
- en: '[PRE122]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Note the addition of the **{ cookie : { sameSite : true }}** configuration.'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '注意添加了**{ cookie : { sameSite : true }}**配置。'
- en: 'Now, having stopped the original server, start **fixed-server.js** :'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，停止原始服务器后，启动**fixed-server.js**：
- en: '[PRE123]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Return to **http://localhost:3000** and log in again with the same credentials
    as before. Then, in a second browser tab, visit **http://127.0.0.1:3001** ( **csrf-server.js**
    should still be running) and click the button again. Note that you must navigate
    using **http://127.0.0.1:3001** rather than **http://localhost:3001** ; otherwise,
    the request will be considered as coming from the same domain.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回**http://localhost:3000**并使用之前的凭据重新登录。然后在第二个浏览器标签页中，访问**http://127.0.0.1:3001**（**csrf-server.js**应该仍在运行）并再次点击按钮。注意，你必须使用**http://127.0.0.1:3001**而不是**http://localhost:3001**进行导航；否则，请求将被视为来自同一域名。
- en: 'You’ll find that this time, clicking the button will not update the email on
    the **Social Media Account - Settings** page. If we open **Chrome DevTools** |
    **Console** , we’ll even see a **403 (Forbidden)** error, confirming that our
    change has prevented the attack:'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会发现这次，点击按钮不会在**社交媒体账户 - 设置**页面更新电子邮件。如果我们打开**Chrome DevTools** | **Console**，我们甚至能看到一个**403
    (禁止)**错误，确认我们的更改阻止了攻击：
- en: '![Figure 9.13 – The Chrome DevTools window showing 403 (Forbidden) on our CSRF
    request](img/B19212_09_13.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – Chrome DevTools窗口显示我们的CSRF请求上的403（禁止）](img/B19212_09_13.jpg)'
- en: Figure 9.13 – The Chrome DevTools window showing 403 (Forbidden) on our CSRF
    request
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – Chrome DevTools窗口显示我们的CSRF请求上的403（禁止）
- en: This recipe has demonstrated a simple CSRF attack and the associated risks.
    We mitigated the vulnerability by supplying additional configuration using the
    **express-session** middleware.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了简单的CSRF攻击及其相关风险。我们通过使用**express-session**中间件提供额外的配置来减轻了漏洞。
- en: How it works…
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we demonstrated a simple CSRF attack. The attacker crafted a
    malicious site to leverage a cookie from a social media website to update a user’s
    email to their own. This is a dangerous vulnerability as once an attacker has
    updated the email to their own, they can end up with control over the account.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们展示了简单的CSRF攻击。攻击者构建了一个恶意网站，利用社交媒体网站上的cookie来更新用户的电子邮件地址。这是一个危险的漏洞，因为一旦攻击者将电子邮件更新为自己的，他们最终可能会控制账户。
- en: 'To mitigate this vulnerability, we passed the **express-session** middleware
    the **{ cookie : { sameSite : true }}** configuration. The **SameSite** attribute
    of the cookie header can be set to the following three values:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '为了减轻这种漏洞，我们向**express-session**中间件传递了**{ cookie : { sameSite : true }}**配置。cookie头部的**SameSite**属性可以设置为以下三个值：'
- en: '**none** : The cookie can be shared and sent in all contexts, including cross-origin
    requests'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**none**：cookie 可以在所有上下文中共享和发送，包括跨源请求'
- en: '**lax** : This allows the cookie to be shared with HTTP **GET** requests initiated
    by third-party websites, but only when it results in top-level navigation'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lax**：这允许 cookie 与由第三方网站发起的 HTTP **GET** 请求共享，但仅当它导致顶级导航时'
- en: '**strict** : Cookies can only be sent through a request in a first-party context
    – if the cookie matches the current site URL'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**strict**：cookie 只能通过第一方上下文中的请求发送 – 如果 cookie 与当前站点 URL 匹配'
- en: 'Setting the **{ sameSite : true }** configuration option in the **express-session**
    middleware configuration equates to setting the **Set-Cookie : SameSite** attribute
    to **strict** mode.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '在 **express-session** 中间件配置中将 **{ sameSite : true }** 配置选项设置为等同于将 **Set-Cookie
    : SameSite** 属性设置为 **strict** 模式。'
- en: 'Inspecting the header of the request in this recipe would show a **Set-Cookie**
    header similar to the following:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中检查请求头将显示类似于以下内容的 **Set-Cookie** 头部：
- en: '[PRE124]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: There’s more…
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some older browsers don’t support the **Set-Cookie SameSite** header attribute.
    A strategy for dealing with these cases is to generate an anti-CSRF token. These
    anti-CSRF tokens are stored in the user session, which means the attacker would
    need access to the session itself to carry out the attack.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 一些旧版浏览器不支持 **Set-Cookie SameSite** 头部属性。处理这些情况的一种策略是生成反 CSRF 令牌。这些反 CSRF 令牌存储在用户会话中，这意味着攻击者需要访问会话本身才能执行攻击。
- en: 'We can use a module named **csurf** to help implement anti-CSRF tokens:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用名为 **csurf** 的模块来帮助实现反 CSRF 令牌：
- en: 'Still in the **express-csrf** directory, copy **fixed-server.js** to a new
    file named **csurf-server.js** :'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 **express-csrf** 目录中，将 **fixed-server.js** 复制到名为 **csurf-server.js** 的新文件中：
- en: '[PRE125]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Install the **csurf** module:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 **csurf** 模块：
- en: '[PRE126]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Next, we need to import and initialize the **csurf** module in the **csruf-server.js**
    file. Add the following lines below the **express-session** import:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 **csruf-server.js** 文件中导入和初始化 **csurf** 模块。在 **express-session** 导入下方添加以下行：
- en: '[PRE127]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Then, we need to alter the HTTP **GET** request handler so that it uses the
    **csrf** middleware. We can achieve this by supplying it as the second parameter
    to the **get()** method of the **/account** route handler:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要修改 HTTP **GET** 请求处理器，使其使用 **csrf** 中间件。我们可以通过将其作为 **/account** 路由处理器
    **get()** 方法的第二个参数来做到这一点：
- en: '[PRE128]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In the HTML template, we generate and inject **csrfToken** using the **req.csrfToken()**
    method of the request object. We inject the token into the HTML template as a
    hidden field named **_csrf** . The **csrf** middleware looks for a token with
    that name.
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 HTML 模板中，我们使用请求对象的 **req.csrfToken()** 方法生成和注入 **csrfToken**。我们将令牌注入到名为 **_csrf**
    的隐藏字段中。**csrf** 中间件会寻找具有该名称的令牌。
- en: 'We also need to update the **post()** method of our **/update** route handler
    so that it can use the **csrf** middleware:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要更新 **/update** 路由处理器的 **post()** 方法，以便它可以使用 **csrf** 中间件：
- en: '[PRE129]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Upon an HTTP **POST** request, the **csrf** middleware will check the body of
    a request for the token stored in the **_csrf** field. The middleware then validates
    the supplied token with the token stored in the user’s session.
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 HTTP **POST** 请求期间，**csrf** 中间件将检查请求体中存储在 **_csrf** 字段中的令牌。然后，中间件将提供的令牌与用户会话中存储的令牌进行验证。
- en: 'Start the server:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器：
- en: '[PRE130]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Navigate to **http://localhost:3000** and log in with the same username and
    password that we used in this recipe. Click on **View Page Source** on the **Social
    Media Account - Settings** page. You should see the following HTML showing the
    hidden **_csrf** field:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **http://localhost:3000** 并使用与我们在本食谱中使用的相同用户名和密码登录。在 **社交媒体账户 - 设置** 页面上点击
    **查看页面源代码**。你应该会看到以下 HTML 显示隐藏的 **_csrf** 字段：
- en: '[PRE131]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: You should be able to update the email as before.
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该能够像以前一样更新电子邮件。
- en: The **csurf** middleware helps mitigate the risk of CSRF attacks in older browsers
    that don’t support the **Set-Cookie:SameSite** attribute. However, our servers
    could still be vulnerable to more complex CSRF attacks, even when using the **csurf**
    middleware. The attacker could use XSS to obtain the CSRF token, and then craft
    a CSRF attack using the **_csrf** token. However, this is best-effort mitigation
    in the absence of support for the **Set-Cookie:SameSite** attribute.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**csurf** 中间件有助于减轻旧版浏览器中 CSRF 攻击的风险，这些浏览器不支持 **Set-Cookie:SameSite** 属性。然而，即使使用
    **csurf** 中间件，我们的服务器仍然可能容易受到更复杂的 CSRF 攻击。攻击者可以使用 XSS 获取 CSRF 令牌，然后使用 **_csrf**
    令牌构建 CSRF 攻击。但是，在没有支持 **Set-Cookie:SameSite** 属性的情况下，这是一种尽力而为的缓解措施。'
- en: Slowing an attacker down by making the attack they have to create more complex
    is an effective way of reducing risk. Many attackers will try to exploit many
    websites at a time – if they experience a website that takes significantly longer
    to exploit, in the interest of time, they will often just move on to another website.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使攻击者必须创建更复杂的攻击来减缓他们的速度是一种有效的降低风险的方法。许多攻击者会尝试同时利用多个网站——如果他们遇到一个需要显著更长的时间来利用的网站，出于时间的考虑，他们通常会转到另一个网站。
- en: See also
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Authentication with Fastify* recipe in this chapter
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用Fastify进行身份验证*配方
- en: The *Hardening headers with Helmet* recipe in this chapter
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用Helmet强化头部信息*配方
- en: The *Anticipating malicious input* recipe in this chapter
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*预测恶意输入*配方
- en: The *Preventing JSON pollution* recipe in this chapter
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*预防JSON污染*配方
- en: The *Guarding against cross-site scripting* recipe in this chapter
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*防范跨站脚本攻击*配方
- en: The *Diagnosing issues with Chrome DevTools* recipe in [*Chapter 12*](B19212_12.xhtml#_idTextAnchor388)
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19212_12.xhtml#_idTextAnchor388)中的*使用Chrome DevTools诊断问题*配方'
