- en: Chapter 7. Working with Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 与数据库一起工作
- en: Database queries are also written directly with Opa. Opa currently (Opa 1.1.1)
    supports the NoSQL databases MongoDB and CouchDB as well as the SQL database Postgres.
    Postgres is still a work in progress and more databases are planned for future
    releases. Opa provides many unique advanced operators and automates the database
    queries for maximal productivity. In this chapter, we will talk briefly about
    how to work with MongoDB.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库查询也可以直接用Opa编写。Opa目前（Opa 1.1.1）支持NoSQL数据库MongoDB和CouchDB以及SQL数据库Postgres。Postgres仍在开发中，未来版本计划支持更多数据库。Opa提供了许多独特的先进操作符，并自动执行数据库查询以实现最大生产力。在本章中，我们将简要介绍如何与MongoDB一起工作。
- en: A quick start to MongoDB
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB快速入门
- en: 'First, we need to download ([http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)),
    install, and run ([http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/))
    the MongoDB server. After MongoDB has been installed properly, let''s get started
    with a simple example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要下载([http://www.mongodb.org/downloads](http://www.mongodb.org/downloads))，安装，并运行([http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/))
    MongoDB服务器。在MongoDB正确安装后，让我们从一个简单的例子开始：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the first line of the preceding code, we define a `/counter` database path
    that holds an integer. A database path describes a position in the database, and
    we can read, write, update, and delete the data through a database path. Note
    that the data type of the path cannot be omitted.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的第一行中，我们定义了一个包含整数的`/counter`数据库路径。数据库路径描述了数据库中的位置，我们可以通过数据库路径读取、写入、更新和删除数据。请注意，路径的数据类型不能省略。
- en: 'The preceding database is unnamed; we can give a name to the database, for
    example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上述数据库是无名的；我们可以给数据库起一个名字，例如：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this way, we should read data from the path `/testdb/counter`. Now, let''s
    compile and run the code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们应该从路径`/testdb/counter`读取数据。现在，让我们编译并运行代码：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the application starts, it will try to launch the MongoDB server if the
    server is not already running, and it will store data on the default location
    `~/.opa/mongo/data`. If the server is already running, the application will try
    to connect to the server. However, we can also use the options `--db-local` and
    `--db-remote` to let the program connect to specific databases as we want:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，如果服务器尚未运行，它将尝试启动MongoDB服务器，并将数据存储在默认位置`~/.opa/mongo/data`。如果服务器已经运行，应用程序将尝试连接到服务器。然而，我们也可以使用`--db-local`和`--db-remote`选项让程序连接到我们想要的特定数据库：
- en: '`--db-local:dbname [/path/to/db]`: This uses a local database stored at the
    specified location in the file-system'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--db-local:dbname [/path/to/db]`: 这使用在文件系统中指定位置的本地数据库'
- en: '`--db-remote:dbname [username:password@]hostname[:port]`: This uses a remote
    database accessible at a given remote location'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--db-remote:dbname [username:password@]hostname[:port]`: 这使用在给定远程位置可访问的远程数据库'
- en: 'For example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Database manipulation
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库操作
- en: 'We can manipulate data through database paths. The following piece of code
    declares a `testdb` database and defines several paths:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过数据库路径来操作数据。以下代码段声明了一个`testdb`数据库并定义了几个路径：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Type student that we defined ourselves. In addition to this type, our example
    covers the datatypes that are most frequently used in databases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了自己的学生类型。除了这个类型，我们的例子还涵盖了在数据库中最常使用的数据类型。
- en: 'Each database path has a default value. Whenever we attempt to read a value
    that does not exist (either because it was never initialized or it has been removed),
    the default value is returned. The following list shows the default values for
    different types:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库路径都有一个默认值。每次我们尝试读取一个不存在的值（无论是由于它从未初始化还是已经被删除），都会返回默认值。以下列表显示了不同类型的默认值：
- en: The default value for an integer (int) is 0
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数（int）的默认值是0
- en: The default value for a floating-point number (float) is 0.0
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数（float）的默认值是0.0
- en: The default value for a string is ""
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的默认值是""
- en: The default value for a record is the record of default values
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录的默认值是默认值记录
- en: The default value for a sum type is the value that best resembles the empty
    case (for example, {none} for option, {nil} for list, and so on)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类型的默认值是最好地类似于空情况的值（例如，选项的{none}，列表的{nil}等）
- en: 'We can define an application-specific default value by assigning a value when
    we declare a path, for example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在声明路径时分配一个值来定义一个特定应用程序的默认值，例如：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To read data from the database, just use a database path, for example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据库中读取数据，只需使用数据库路径，例如：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can prefix the path with a question mark (`?`) then give the path a value
    that is one of two options, whereby `{some: x}` indicates that the value of that
    path is `x`, and `{none}` indicates that the path has not been written to yet,
    for instance:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以在路径前加上问号（`?`），然后给路径赋予两个选项之一，其中`{some: x}`表示该路径的值是`x`，而`{none}`表示该路径尚未写入，例如：'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example prints **unknown** if the path `/testdb/basic/i` has not
    been written to yet or has been removed, otherwise it prints the value of the
    path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例如果路径`/testdb/basic/i`尚未写入或已被删除，则打印**unknown**，否则打印该路径的值。
- en: 'To write or update the database path, use a operator `=`. We can also use `<-`
    to assign the value, it''s the same as `=`. For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入或更新数据库路径，使用操作符`=`。我们还可以使用`<-`来赋值，它与`=`相同。例如：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To delete data held at a path, use the `Db.remove(@path)` function, where `@path`
    is a reference to a path. We can get a path reference by adding an `@` sign before
    the path, for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除存储在路径中的数据，使用`Db.remove(@path)`函数，其中`@path`是路径的引用。我们可以通过在路径前添加`@`符号来获取路径引用，例如：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Records
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录
- en: 'With records, we can do complete reads and updates in the same manner as for
    basic types:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记录，我们可以像基本类型一样进行完整的读取和更新：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Sometimes, we need to enforce that the record should be modified only as a
    whole. This is known as **full modification**. If a record is declared as being
    subject to full modification, we must update all fields at once when performing
    modifications. We add the `full` keyword after a database path in order to indicate
    that this path is subject to full modification. If a given path has not been declared
    for full modification, we can cross record boundaries and access or update only
    chosen fields by including them in the path. Consider the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要强制记录只能整体修改。这被称为**完全修改**。如果一个记录被声明为可以完全修改，那么在执行修改时必须一次性更新所有字段。我们通过在数据库路径后添加`full`关键字来表示该路径可以完全修改。如果给定的路径没有声明为完全修改，我们可以跨越记录边界，通过在路径中包含它们来访问或更新所选字段。考虑以下示例：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We declared `/stu2` for full modification by adding the `/stu2 full` statement.
    Therefore, the compiler reported an error for the last line (`/testdb/stu2/name
    = "Li"`) of the preceding code, in which we tried modifying a single field of
    the record, namely the `name` field.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加`/stu2 full`语句声明了`/stu2`以进行完全修改。因此，编译器报告了前一段代码中最后一行（`/testdb/stu2/name
    = "Li"`）的错误，其中我们尝试修改记录的单个字段，即`name`字段。
- en: Lists
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'As mentioned in the *Lists* section of [Chapter 2](ch02.html "Chapter 2. Basic
    Syntax"), *Basic Syntax*, lists in Opa are just recursive records. We can manipulate
    lists in the same manner as records. However, as the datatype list is used frequently,
    Opa provides shortcuts that are specific to lists:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[第2章](ch02.html "第2章。基本语法")的*列表*部分所述，*基本语法*，Opa中的列表只是递归记录。我们可以以与记录相同的方式操作列表。然而，由于列表数据类型使用频率很高，Opa提供了针对列表的特定快捷方式：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sets and maps
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合和映射
- en: 'We can update sets and maps in the same way as lists, however, the way we access
    the elements is different. We can fetch a single value from a given set or map
    by referencing it by its primary key, for example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像更新列表一样更新集合和映射，然而，访问元素的方式是不同的。我们可以通过引用其主键从给定的集合或映射中获取单个值，例如：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Furthermore, we can query a set of values by adding the query condition inside
    the square bracket, for example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在方括号内添加查询条件来查询一组值，例如：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will look at queries in more detail in the following section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地探讨查询。
- en: Querying data
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询数据
- en: 'As we mentioned in the previous section, database sets and maps are two types
    of collections that allows the organization of multiple instances of data in the
    database. We can query a set of values using the following operators:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，数据库集合和映射是两种允许在数据库中组织多个数据实例的集合类型。我们可以使用以下运算符查询一组值：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Furthermore, we can specify some querying options as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以指定一些查询选项如下：
- en: '`skip n`: Here `expr` should be an expression of type `int` and it skip the
    first *n* results.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip n`：这里`expr`应该是一个类型为`int`的表达式，并且它将跳过前*n*个结果。'
- en: '`limit n`: Here `expr` should be an expression of type `int`, returns a maximum
    of *n* results.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit n`：这里`expr`应该是一个类型为`int`的表达式，返回最多*n*个结果。'
- en: '`order fld (, fld)+`: Here `fld` specifies an order. `fld` can be a single
    identifier or a list of identifiers specifying the fields on which the ordering
    should be based. Identifiers can optionally be prefixed with `+` or `-` to specify
    the ascending or descending order. Finally, it is possible to choose the order
    dynamically with `<ident>=<expr>`, where `<expr>` should be of type `{up}` or
    `{down}`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order fld (, fld)+`: 这里 `fld` 指定了一个排序。`fld` 可以是一个单独的标识符或一个标识符列表，指定了排序应基于的字段。标识符可以可选地以
    `+` 或 `-` 前缀来指定升序或降序。最后，可以使用 `<ident>=<expr>` 来动态选择排序，其中 `<expr>` 应该是 `{up}` 或
    `{down}` 类型。'
- en: 'The following piece of code gets the next 50 results for students whose age
    is above 20 and below 45, and they will be ordered by age (ascending) first and
    then ordered by `id` (descending):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段获取了年龄在20岁以上和45岁以下的学生接下来的50个结果，并且将它们按年龄（升序）排序，然后按 `id`（降序）排序：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can create even more complicated query conditions by combining query expressions
    together. The query operation returns a `dbset`. A `dbset` is a collection that
    holds the query result. Therefore, we can iterate over the `dbset`. Consider the
    following code fragment. It queries all students whose name is `Li` and prints
    them out:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组合查询表达式来创建更复杂的查询条件。查询操作返回一个 `dbset`。`dbset` 是一个包含查询结果的集合。因此，我们可以遍历 `dbset`。考虑以下代码片段。它查询所有名为
    `Li` 的学生，并将它们打印出来：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we toured the basic techniques of working with databases. We
    first gave a very simple example. Then, we discussed how to manipulate data, including
    retrieving data from databases, writing or updating data, and removing data. We
    covered both basic types and complex types such as record, list, map, and set.
    Finally, we talked about how to query data from sets and maps.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了与数据库一起工作的基本技术。我们首先给出了一个非常简单的例子。然后，我们讨论了如何操作数据，包括从数据库中检索数据、写入或更新数据以及删除数据。我们涵盖了基本类型和复杂类型，如记录、列表、映射和集合。最后，我们讨论了如何从集合和映射中查询数据。
