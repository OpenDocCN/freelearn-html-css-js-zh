- en: Managing Version History with Git
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Git管理版本历史。
- en: In this book, starting from [Chapter 4](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml),
    *Setting Up Development Tools*, we're going to be building a very simple user
    directory, which we've randomly named **hobnob**. We need a way for us to keep
    a versioned history of our code, so that if we've made some mistakes along the
    way, we can simply revert back to the last known good version and start again
    from there. This is known as **version control** (**VC**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，从[第4章](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml)“设置开发工具”开始，我们将构建一个非常简单的用户目录，我们随机命名为**hobnob**。我们需要一种方法来保存我们代码的版本历史，这样如果我们沿途犯了一些错误，我们可以简单地回滚到最后已知的好版本，并从这里重新开始。这被称为**版本控制**（**VC**）。
- en: The simplest way to implement version control is to copy the entire codebase
    into date-stamped directories; however, this is tedious and may take up a lot
    of disk space. Instead, we can use a **Version Control System** (**VCS**) that'll
    manage these versions for us. We simply have to instruct the VCS when to create
    a snapshot of our code, and it will keep that version.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实现版本控制的最简单方法是将整个代码库复制到带日期的目录中；然而，这很繁琐，可能会占用大量磁盘空间。相反，我们可以使用一种**版本控制系统**（**VCS**）来为我们管理这些版本。我们只需指示VCS何时创建代码的快照，它就会保留该版本。
- en: There have been many implementations of VCS, starting in 1972 with**Source Code
    Control System **(**SCCS**), which was superseded by** Revision Control System **(**RCS**,
    released in 1982), **Concurrent Versions System** (**CVS**, released in 1990),
    and **Apache ****Subversion** (**SVN**, released in 2000). Nowadays, we mainly
    use **Git** (released in 2005), a type of VCS known as **Distributed VCS **(**DVCS**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从1972年开始，出现了许多版本控制系统（VCS）的实现，最初是**源代码控制系统**（**SCCS**），后来被**修订控制系统**（**RCS**，于1982年发布）取代，然后是**并发版本系统**（**CVS**，于1990年发布），以及**Apache
    Subversion**（**SVN**，于2000年发布）。如今，我们主要使用**Git**（于2005年发布），这是一种称为**分布式版本控制系统**（**DVCS**）的VCS。
- en: 'Git was created by Linus Torvalds, who''s also the creator of the Linux kernel.
    It is used to track changes in the development of the Linux kernel, as well as
    the tens of millions of repositories currently on GitHub. In this chapter, we
    will guide you through setting up and configuring Git, as well as explaining basic
    Git concepts, such as:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Git是由Linux内核的创造者林纳斯·托瓦兹（Linus Torvalds）创建的。它用于跟踪Linux内核的开发变化，以及目前在GitHub上数千万个仓库。在本章中，我们将指导您设置和配置Git，并解释基本Git概念，例如：
- en: Different states in Git
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git的不同状态。
- en: Basic Git operations such as **staging**, **committing**, **merging**/**rebasing**,
    **pushing**, and ****pulling****
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的Git操作，如**暂存**、**提交**、**合并/变基**、**推送**和**拉取**。
- en: Implementing a parallel development workflow using a branching model proposed
    by Vincent Driessen, commonly known as ****Git flow****
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vincent Driessen提出的分支模型实现并行开发工作流程，通常称为**Git flow**。
- en: Setting up a **GitHub** account to host our code remotely
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置**GitHub**账户以远程托管我们的代码。
- en: Understanding the workflow when working with others
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解与他人协作时的工作流程。
- en: Setting up Git
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Git。
- en: First, we must install Git.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须安装Git。
- en: Most installation instructions depend on your hardware architecture and operating
    system. It would be impractical for us to outline instructions for all of them.
    So, for this book, we'll assume you're running Ubuntu 16.04 / 18.04 on a 64-bit
    machine, using a user with `sudo` privileges.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数安装说明取决于您的硬件架构和操作系统。为我们所有这些列出说明是不切实际的。因此，对于本书，我们假设您正在64位机器上运行Ubuntu 16.04/18.04，使用具有`sudo`权限的用户。
- en: We will provide URL links to the documentation whenever possible, so that you
    can find installation instructions specific to your machine. However, due to the
    dynamic nature of the internet, URL addresses change and pages may get moved.
    If the link we provide appears to be dead, simply search for the instructions
    using a search engine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在可能的情况下提供URL链接到文档，这样您就可以找到针对您机器的特定安装说明。然而，由于互联网的动态性，URL地址会发生变化，页面可能会被移动。如果提供的链接看起来是无效的，只需使用搜索引擎搜索说明。
- en: 'Git is available for macOS, Windows, and Linux. You can find download instructions
    for Git at [https://git-scm.com/downloads](https://git-scm.com/downloads). Since
    we are using Ubuntu, the `git` package will be available from our distribution''s
    package manager, **Advanced Packaging Tool** (**APT**). We should run `sudo apt
    update` to ensure that the list of repositories available to APT is up to date,
    before installing the `git` package:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Git 可用于 macOS、Windows 和 Linux。您可以在[https://git-scm.com/downloads](https://git-scm.com/downloads)找到
    Git 的下载说明。由于我们使用 Ubuntu，`git` 软件包将从我们的发行版的软件包管理器 **高级包装工具**（APT）提供。在安装 `git` 软件包之前，我们应该运行
    `sudo apt update` 以确保 APT 可用的仓库列表是最新的：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Git is now available as the `git` **command-line interface** (**CLI**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Git 现在作为 `git` **命令行界面**（CLI）提供。
- en: Creating a new repository
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的仓库
- en: 'Next, create a directory, named `hobnob`, to house our project. Then, navigate
    inside and run `git init`. This will allow Git to start tracking changes to our
    project; a project tracked by Git is also known as a **repository**:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `hobnob` 的目录来存放我们的项目。然后，进入该目录并运行 `git init`。这将允许 Git 开始跟踪我们项目的更改；由
    Git 跟踪的项目也称为 **仓库**：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we introduce new Git commands, I encourage you to read their full documentation,
    which you can find at [https://git-scm.com/docs](https://git-scm.com/docs).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们介绍新的 Git 命令，我鼓励您阅读它们的完整文档，您可以在[https://git-scm.com/docs](https://git-scm.com/docs)找到。
- en: Running `git init` creates a `.git` directory, which holds all version-control-related
    information about the project. When we interact with Git using its CLI, all it's
    doing is manipulating the content of this `.git` directory. We usually don't have
    to care about the contents of the `.git` directory, as we can interact with Git
    purely through the CLI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `git init` 创建一个 `.git` 目录，该目录包含关于项目所有版本控制相关的信息。当我们使用 CLI 与 Git 交互时，它所做的只是操作这个
    `.git` 目录的内容。我们通常不需要关心 `.git` 目录的内容，因为我们可以通过 CLI 纯粹地与 Git 交互。
- en: Because Git keeps all files under the `.git` directory, deleting the `.git`
    directory will delete the repository, including any history.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Git 将所有文件都保存在 `.git` 目录下，删除 `.git` 目录将删除仓库，包括任何历史记录。
- en: Configuring Git
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Git
- en: 'We can configure Git using the `git config` command. This command will manipulate
    the `.git/config` file on our behalf. In fact, if we print the content of the
    `.git/config` file, you''ll see that it is similar to the output of the `git config`
    command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `git config` 命令来配置 Git。此命令将代表我们操作 `.git/config` 文件。实际上，如果我们打印 `.git/config`
    文件的内容，您会看到它与 `git config` 命令的输出类似：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Feel free to examine the `.git` directory using a tool such as `tree`. First,
    install `tree` by running `sudo apt install tree`. Then, run `tree ~/projects/hobnob/.git`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用像 `tree` 这样的工具随意检查 `.git` 目录。首先，通过运行 `sudo apt install tree` 来安装 `tree`。然后，运行
    `tree ~/projects/hobnob/.git`。
- en: 'To configure Git, we must first understand that there are three scopes, or
    levels, of configurations, each with a corresponding configuration file stored
    at different locations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Git，我们首先需要了解存在三个配置范围或级别，每个级别都有一个相应的配置文件，存储在不同的位置：
- en: '**Local**: Applies only to the current repository; the configuration file is
    stored at `<repository-root>/.git/config`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地**：仅适用于当前仓库；配置文件存储在 `<repository-root>/.git/config`。'
- en: '**Global**: Applies to all repositories under the user''s home directory; the
    configuration file is stored at `$HOME/.config/git/config` and/or at `$HOME/.gitconfig`,
    with the latter being only available in newer versions of Git. `$HOME/.gitconfig`
    will override `$HOME/.config/git/config`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局**：适用于用户主目录下的所有仓库；配置文件存储在 `$HOME/.config/git/config` 和/或 `$HOME/.gitconfig`，后者仅在新版本的
    Git 中可用。`$HOME/.gitconfig` 将覆盖 `$HOME/.config/git/config`。'
- en: '**System**: Applies to all repositories in your machine; the configuration
    file stored at `/etc/gitconfig`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统**：适用于您机器上的所有仓库；配置文件存储在 `/etc/gitconfig`。'
- en: The local configuration settings will override the global settings, which, in
    turn, override the system settings.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本地配置设置将覆盖全局设置，而全局设置又覆盖系统设置。
- en: Configuring a user
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置用户
- en: When we ask Git to take a snapshot of our code (also called **committing**),
    Git will record several pieces of information, such as the time and author of
    the commit. The information about the author is saved as Git configurations, which
    saves us from having to re-type them each time we commit.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要求 Git 对我们的代码进行快照（也称为 **提交**）时，Git 将记录一些信息，例如提交的时间作者。关于作者的信息被保存为 Git 配置，这样我们每次提交时就不必重新输入它们。
- en: 'By default, adding/updating the configuration would write to the local config
    file. However, since you are going to be the only person using your user account
    on your machine, it''s better to set the user settings in the global configuration
    file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，添加/更新配置将写入本地配置文件。然而，由于你将是唯一使用你机器上用户账户的人，因此最好在全局配置文件中设置用户设置：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will cause future commits to be, by default, identified as `"Daniel Li"`
    whose email address is `"dan@danyll.com"`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致未来的提交默认被标识为“Daniel Li”，其电子邮件地址为`"dan@danyll.com"`。
- en: If you have a GitHub account (if not, we will create one later), you should
    use the same email address for Git. When you push your commits, GitHub will automatically
    associate your commits to your account.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个GitHub账户（如果没有，我们稍后会创建一个），你应该为Git使用相同的电子邮件地址。当你推送提交时，GitHub会自动将你的提交关联到你的账户。
- en: We have now successfully set up Git and configured our user.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功设置了Git并配置了我们的用户。
- en: For the remainder of this chapter, we will use dummy files to illustrate how
    Git works and the workflow we will follow. Everything you do for the rest of this
    chapter should be viewed as an educational exercise, and can be discarded afterward.
    At the beginning of the next chapter, we will start our project again from scratch,
    and you will use the things you learned in this chapter to keep your code base's
    history organized!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余部分，我们将使用虚拟文件来展示Git的工作原理以及我们将遵循的工作流程。本章剩余部分你所做的所有操作都应被视为一个教育练习，之后可以丢弃。在下一章的开始，我们将从头开始我们的项目，并使用本章学到的知识来保持代码库的历史有序！
- en: Learning the basics
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基础知识
- en: The primary purpose of Git is to keep a history of changes, or revisions. To
    illustrate this, let's create a simple file and commit it to the history of the
    repository.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Git的主要目的是保持更改的历史记录或版本。为了说明这一点，让我们创建一个简单的文件并将其提交到仓库的历史记录中。
- en: Committing to history
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交到历史记录
- en: 'First, let''s confirm our repository''s Git history by running `git log`, which
    shows a history of past commits:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过运行`git log`来确认我们的仓库Git历史记录，它显示了过去提交的历史：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The error correctly informs us that there are currently no commits. Now, let''s
    create a short `README.md` file, which represents the first change we want to
    commit:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息正确地通知我们目前没有提交。现在，让我们创建一个简短的`README.md`文件，它代表我们想要提交的第一个更改：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ve created our first file and thus made our first change. We can now run
    `git status`, which will output information about the current state of our repository.
    We should see our `README.md` file being picked up by Git:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了第一个文件，因此做出了第一个更改。现在我们可以运行`git status`，它将输出有关我们仓库当前状态的信息。我们应该看到Git已经抓取了我们的`README.md`文件：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output tells us that we are on the default `master` branch (more on branching
    later), and that this is our *initial commit—*we have not committed anything to
    the repository yet. It then says we have untracked files. To understand what that
    means, we must understand the different states that a file can be in with Git.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们我们位于默认的`master`分支（稍后关于分支的更多内容），这是我们**初始提交**——我们还没有将任何内容提交到仓库。然后它说我们有未跟踪的文件。要理解这意味着什么，我们必须了解文件在Git中可能处于的不同状态。
- en: So far, we have used `git log` and `git status`, but there are many more CLI
    commands; to see a full list, run `git help`. To get details about a particular
    command, run `git help [command]`; for example, `git help status`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了`git log`和`git status`，但还有许多更多的CLI命令；要查看完整列表，请运行`git help`。要获取特定命令的详细信息，请运行`git
    help [command]`；例如，`git help status`。
- en: Understanding file states in Git
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Git中的文件状态
- en: In Git, every file can be in one of two generic states: **tracked** and **untracked**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Git中，每个文件都可以处于两种通用状态之一：**跟踪**和**未跟踪**。
- en: 'Initially, all files exists in the **workspace** (also known as **working tree** or **working
    directory**) and are in the **untracked** state. These untracked files are not
    part of the repository, and Git won''t pick up changes made to them. When we run `git
    status`, Git sees that there are files in our workspace that are untracked (not
    part of the repository) and asks whether we want to add them to the repository. When
    we commit a new file to the repository using `git add` and `git commit`, it transitions
    from untracked to tracked:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，所有文件都存在于**工作区**（也称为**工作树**或**工作目录**）中，并且处于**未跟踪**状态。这些未跟踪的文件不是仓库的一部分，Git不会抓取对它们的更改。当我们运行`git
    status`时，Git会看到我们的工作区中有未跟踪的文件（不属于仓库），并询问我们是否要将它们添加到仓库中。当我们使用`git add`和`git commit`将新文件提交到仓库时，它将从未跟踪状态转换为跟踪状态：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`README.md` is now part of the repository and is in the tracked state.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`README.md`现在是存储库的一部分，并且处于跟踪状态。'
- en: We are passing in `"Initial commit"` as a comment that describes the commit.
    Every commit should have an accompanying message that describes what changes were
    made. It should be informative and specific; for example, `"Fixed rounding error
    bug in calculateScore"` is a better commit message than `"fixed bugs"`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递`"Initial commit"`作为注释来描述提交。每个提交都应该有一个伴随的消息来描述所做的更改。它应该是信息性和具体的；例如，`"Fixed
    rounding error bug in calculateScore"`比`"fixed bugs"`更好的提交信息。
- en: However, since our commit does little other than initializing the repository,
    this message will suffice.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们的提交除了初始化存储库之外几乎没有做其他事情，所以这个消息就足够了。
- en: 'We can confirm this by looking at the Git commit history of the repository
    with the `git log` command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看存储库的Git提交历史来确认这一点，使用`git log`命令：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The three tracked states
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪的三个状态
- en: To be more precise, the tracked state can be further subdivided into three substates: **modified**, **staged**,
    and **committed**. Our `README.md` file is in the committed state.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，跟踪状态可以进一步细分为三个子状态：**修改的**、**暂存的**和**已提交的**。我们的`README.md`文件处于已提交状态。
- en: 'Git will pay attention to all the tracked files; if we modify any of them (which
    includes deletions and renames), they will change their state from committed to modified:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Git会关注所有跟踪的文件；如果我们修改了其中任何一个（包括删除和重命名），它们的状态将从已提交变为修改的：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Modified files, alongside any untracked files, will be listed when we run `git
    status`. Modified files can be committed in the same manner as untracked files:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`git status`时，修改的文件以及任何未跟踪的文件都会被列出。修改的文件可以像未跟踪的文件一样提交：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You might be wondering why we had to run `git add` before we ran `git commit`.
    `git add` places the untracked or modified file into what is known as the **staging
    area**, which is also known as the **index** or **cache**. When a file is placed
    into the staging area, it is in the staged state. When we commit, only changes
    in the staging area are added to the repository; changes that remain in the workspace
    are not committed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们运行`git commit`之前必须运行`git add`。`git add`将未跟踪或修改的文件放入称为**暂存区**的地方，这也被称为**索引**或**缓存**。当文件放入暂存区时，它处于暂存状态。当我们提交时，只有暂存区中的更改会被添加到存储库中；而留在工作区中的更改则不会被提交。
- en: Staging our changes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂存我们的更改
- en: By having a staging area, we can `git add` multiple related changes and `git
    commit` them all at the same time—as a single commit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有暂存区，我们可以`git add`多个相关的更改，并一次性将它们`git commit`——作为一个单独的提交。
- en: 'Here, the staging area acts as a temporary environment to collect these related
    changes. For example, if we add a new feature into our application, we should
    also document this in our `README.md`. These changes are related to each other
    and should be committed together:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，暂存区充当一个临时环境，用于收集这些相关的更改。例如，如果我们向我们的应用程序添加一个新特性，我们也应该在`README.md`中记录这一点。这些更改相互关联，应该一起提交：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Quick recap
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾
- en: 'Let''s quickly summarize what we''ve learned so far:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速总结一下到目前为止我们已经学到的内容：
- en: '**Workspace/working directory**: All the files and directories currently in
    our filesystem'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作区/工作目录**：当前在文件系统中的所有文件和目录'
- en: '**Index/staging area/cache**: All the modifications you want to commit'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引/暂存区/缓存**：您想要提交的所有修改'
- en: '**Repository** (the `.git` directory): Hosts a history of all your committed
    and tracked files'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储库**（`.git`目录）：存储所有已提交和跟踪的文件的历史记录'
- en: '![](img/7f257635-9091-41eb-b69f-c3f88d3d1eae.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f257635-9091-41eb-b69f-c3f88d3d1eae.jpg)'
- en: Branching and merging
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支和合并
- en: 'So far, we have been adding changes sequentially to the repository, resulting
    in a history with a linear structure. But what if you, or your team, want to work
    on different features/multiple tasks at the same time? If we continue with our
    current workflow, the Git commit history is going to look disjointed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是按顺序将更改添加到存储库中，从而产生了一个具有线性结构的记录。但如果你或你的团队想要同时处理不同的特性/多个任务，会怎样呢？如果我们继续使用当前的流程，Git提交历史将看起来是断开的：
- en: '![](img/235bffc5-cf78-426d-ab48-c4dcc59cf28f.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/235bffc5-cf78-426d-ab48-c4dcc59cf28f.jpg)'
- en: Here, we have commits relating to bug fixes interleaved between commits relating
    to features. This is not ideal. Git **branches** were created to deal with this
    issue.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一些与错误修复相关的提交穿插在有关特性的提交之间。这不是理想的。Git **分支**是为了处理这个问题而创建的。
- en: Git branches
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git分支
- en: As we've briefly mentioned, the default branch is called `master`, and we've
    been adding commits to this branch up to this point.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们简要提到的，默认分支被称为`master`，并且我们一直在这个分支上添加提交，直到现在。
- en: Now, when we develop a new feature or fix a particular bug, rather than adding
    those commits directory to `master`, we can instead create a branch from a certain
    commit from `master`. Any new commits to these bug fix and/or feature branches
    will be grouped together in a separate branch in the history tree, which does
    not affect the `master` branch. If and when the fix or feature is complete, we
    can merge this branch back into `master`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们开发一个新功能或修复特定错误时，我们不再直接将这些提交添加到`master`分支，而是可以从`master`分支的某个提交创建一个分支。对这些错误修复和/或功能分支的任何新提交都将单独在历史树中的另一个分支中分组，这不会影响`master`分支。如果和当修复或功能完成时，我们可以将这个分支合并回`master`。
- en: The end result is the same, but the Git history is now much easier to read and
    understand. Furthermore, branches allow you to write and commit experimental code
    in an isolated part of the repository, so your changes, which may introduce new
    bugs and regressions, won't affect others until they have been tested and peer-reviewed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是一样的，但现在 Git 历史记录要容易阅读和理解得多。此外，分支允许您在仓库的隔离部分编写和提交实验性代码，因此您的更改，可能会引入新的错误和回归，在经过测试和同行评审之前不会影响其他人。
- en: Branching models
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支模型
- en: The workflow we described is an example of a **branching model**, which is just
    a term that describes how you structure your branches. As you can imagine, there
    are many branching models, and most are more complex than the one we've outlined.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所描述的工作流程是一个**分支模型**的例子，这个术语只是描述了您如何构建分支的方式。正如您所想象的那样，存在许多分支模型，并且大多数都比我们概述的模型复杂。
- en: For this book, we will follow a branching model put forward by Vincent Driessen
    in his article *A successful Git branching* *mode**l*, but you're free to explore
    other models and use the one that makes sense to you. The most important thing
    is that you and your team stick to the model consistently, so everyone on the
    team knows what is expected of them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们将遵循 Vincent Driessen 在他的文章 *A successful Git branching* *mode**l* 中提出的分支模型，但您可以自由探索其他模型并使用对您有意义的模型。最重要的是，您和您的团队要始终如一地坚持这个模型，这样团队中的每个人都知道对他们有什么期望。
- en: You may have heard Driessen's model described as *Git Flow*, but `gitflow` ([https://github.com/nvie/gitflow](https://github.com/nvie/gitflow))
    is actually a set of Git extensions that provides higher-level operations that
    follow Driessen's model.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经听说过 Driessen 的模型被描述为 *Git Flow*，但 `gitflow` ([https://github.com/nvie/gitflow](https://github.com/nvie/gitflow))
    实际上是一组 Git 扩展，它提供了一套遵循 Driessen 模型的高级操作。
- en: You can find the original post where Driessen proposed this model at [http://nvie.com/posts/a-successful-git-branching-model/](http://nvie.com/posts/a-successful-git-branching-model/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Driessen 提出此模型的原始帖子中找到[http://nvie.com/posts/a-successful-git-branching-model/](http://nvie.com/posts/a-successful-git-branching-model/)。
- en: The Driessen model
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Driessen 模型
- en: 'Driessen provided a detailed diagram of how his model works:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Driessen 提供了一个详细图解说明他的模型是如何工作的：
- en: '![](img/132cf42f-d48c-4d5f-98bf-59f33c203c56.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/132cf42f-d48c-4d5f-98bf-59f33c203c56.png)'
- en: 'In Driessen''s model, there are two permanent branches:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Driessen 的模型中，有两个永久分支：
- en: '`dev` (or `develop`, or `development`): The main branch that developers work
    on.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`（或`develop`，或`development`）：开发者工作的主要分支。'
- en: '`master`: Only production-ready code can be committed to this branch. Here,
    production-ready means the code has been tested and approved by the stakeholders.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`master`：只有经过测试和利益相关者批准的生产就绪代码可以提交到这个分支。这里的“生产就绪”意味着代码已经过测试并获得批准。'
- en: 'There are also other non-permanent branches:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些非永久分支：
- en: '**Feature branches**: Branching from the `dev` branch, feature branches are
    used for developing new features, or fixing non-critical bugs. Feature branches
    will eventually be merged back into the `dev` branch.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能分支**：从`dev`分支进行分支，功能分支用于开发新功能或修复非关键错误。功能分支最终将被合并回`dev`分支。'
- en: '**Release branches**: Once enough features or bug fixes havebeen implemented
    and merged into the `dev` branch, a release branch can be created from the `dev`
    branch to undergo more scrutiny before being released. For instance, the application
    can be deployed onto a staging server to be UI and manually tested. Any bugs uncovered
    during this process would then be fixed and committed directly to the release
    branch. Once the release branch is "free" of bugs, it can then be merged into
    the `master` branch and released into production. These fixes should also be merged
    back into the `dev` branch and any other release branches.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布分支**：一旦足够的功能或错误修复已实现并合并到 `dev` 分支，就可以从 `dev` 分支创建发布分支，在发布之前进行更多审查。例如，可以将应用程序部署到预发布服务器进行
    UI 和手动测试。在此过程中发现的任何错误都会被修复并直接提交到发布分支。一旦发布分支“无错误”，就可以将其合并到 `master` 分支并发布到生产环境中。这些修复也应该合并回
    `dev` 分支和任何其他发布分支。'
- en: '**Hotfix (or patch) branches**: Hotfixes are issues (not always bugs) that
    are in production which must be fixed as soon as possible, before the next planned
    release. In these cases, the developer would create a branch from `master`, make
    the required changes, and merge directly back into `master`. These hotfix branches
    should also be merged back into the `dev` branch and any other release branches.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热修复（或补丁）分支**：热修复是生产中必须尽快修复的问题（不一定是错误），在下一个计划发布之前必须解决。在这种情况下，开发者会从 `master`
    分支创建一个分支，进行必要的更改，然后直接合并回 `master`。这些热修复分支也应该合并回 `dev` 分支和任何其他发布分支。'
- en: Creating a development branch
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建开发分支
- en: 'To implement the Driessen Model, we must first create the `dev` branch from
    the master branch. To check which branch we are currently on, we can run `git
    branch --list` or simply `git branch`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 Driessen 模型，我们首先必须从主分支创建 `dev` 分支。要检查我们当前所在的分支，我们可以运行 `git branch --list`
    或简单地运行 `git branch`：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This returns a list of all branches, with an asterisk (`*`) next to the currently
    active branch, which is currently `master`. To create a new `dev` branch from
    the current branch, we can run `git branch dev`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有分支的列表，当前活动分支旁边有一个星号（`*`），当前是 `master`。要从一个当前分支创建新的 `dev` 分支，我们可以运行 `git
    branch dev`。
- en: 'However, we are instead going to run `git checkout -b dev master`, which creates
    a new branch andmakes it active at the same time:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将运行 `git checkout -b dev master`，这会创建一个新的分支并将其同时设置为活动分支：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating feature branches
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建功能分支
- en: 'Any new features should be developed by branching off `dev`. Be sure to name
    the feature branch so that it clearly indicates the feature being worked on. For
    example, if you''re working on the social login feature, name your branch `social-login`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何新功能都应该从 `dev` 分支分支开发。确保将功能分支命名为清楚地表明正在工作的功能。例如，如果您正在处理社交登录功能，请将您的分支命名为 `social-login`：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If that feature has sub-features, you may create sub-branches from the main
    feature branch. For example, the `social-login` branch may include `facebook-login`
    and `twitter-login` sub-branches.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该功能有子功能，您可以从主功能分支创建子分支。例如，`social-login` 分支可能包括 `facebook-login` 和 `twitter-login`
    子分支。
- en: Naming sub-branches
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子分支命名
- en: 'There are multiple valid ways to name these sub-branches, but the most popular
    convention uses **grouping tokens**, with various **delimiters**. For example,
    our Facebook and Twitter login sub-branches can be grouped under the `social-login` grouping
    token, with a period (`.`) as a delimiter, and a **sub-token** such as `facebook`
    or `twitter`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 命名这些子分支有多种有效的方法，但最流行的约定使用 **分组令牌**，以及各种 **分隔符**。例如，我们的 Facebook 和 Twitter 登录子分支可以分组在
    `social-login` 分组令牌下，使用点（`.`）作为分隔符，以及一个 **子令牌**，如 `facebook` 或 `twitter`：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can use almost anything as a delimiter; the comma (`,`), hash (`#`), and
    greater-than sign (`>`) are all valid delimiters. However, there are several rules
    outlined under the `git-check-ref-format` part of the documentation that give
    valid reference names. For example, the following characters are unavailable:
    space, tilde (`~`), caret (`^`), colon (`:`), question mark (`?`), asterisk (`*`),
    and open bracket (`[`).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用几乎任何东西作为分隔符；逗号（`,`）、井号（`#`）和大于号（`>`）都是有效的分隔符。然而，文档的 `git-check-ref-format`
    部分中概述了几个规则，给出了有效的引用名称。例如，以下字符不可用：空格、波浪号（`~`）、 caret（`^`）、冒号（`:`）、问号（`?`）、星号（`*`）和开方括号（`[`）。
- en: See all the rules by visiting the documentation for `git-check-ref-format` at [https://git-scm.com/docs/git-check-ref-format](https://git-scm.com/docs/git-check-ref-format).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 想要查看所有规则，请访问 `git-check-ref-format` 的文档，网址为 [https://git-scm.com/docs/git-check-ref-format](https://git-scm.com/docs/git-check-ref-format)。
- en: 'Most conventions I have encountered use a forward slash (`/`) as the delimiter,
    and so we do the same here. However, this poses a problem because branches are
    stored as text files under `.git/refs/heads`. If we create a sub-branch called `social-login/facebook`,
    then it''d need to be created at `.git/refs/heads/social-login/facebook`, but
    this is impossible in our case because the `social-login` name is already used
    for the file, and thus cannot act as a directory at the same time:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的大多数约定都使用正斜杠 (`/`) 作为分隔符，所以我们在这里也这样做。然而，这会带来一个问题，因为分支存储在 `.git/refs/heads`
    下的文本文件中。如果我们创建一个名为 `social-login/facebook` 的子分支，那么它需要创建在 `.git/refs/heads/social-login/facebook`，但在我们这个例子中这是不可能的，因为
    `social-login` 名称已经被用作文件名，因此不能同时作为目录：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Therefore, when we create a new feature branch, we need to provide a *default*
    sub-token, such as `main`. With that in mind, let''s delete our current feature
    branches and create them again with the `main` sub-token:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们创建一个新的功能分支时，我们需要提供一个 *默认* 子令牌，例如 `main`。考虑到这一点，让我们删除我们当前的特性分支，并使用 `main`
    子令牌重新创建它们：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are now on the `social-login/main` feature branch, and can start developing
    our social login feature.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在位于 `social-login/main` 特性分支上，可以开始开发我们的社交登录功能。
- en: We won't actually be writing any code; we will simply be adding text to a file
    to mimic new features being added. This allows us to focus on Git and not be bogged
    down by implementation details.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不会编写任何代码；我们只是将文本添加到文件中，以模拟新功能的添加。这使我们能够专注于 Git，而不会被实现细节所困扰。
- en: 'First, let''s create that file and commit it to the `social-login/main` branch:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建该文件并将其提交到 `social-login/main` 分支：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are using `git add -A` here to add all changes to the staging area.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `git add -A` 来将所有更改添加到暂存区。
- en: 'Now, we are going to create a sub-feature branch and develop our Facebook login
    feature:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个子特性分支并开发我们的 Facebook 登录功能：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, do the same for the Twitter login feature, making sure to branch from
    the main feature branch:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为 Twitter 登录功能做同样的事情，确保从主功能分支进行分支：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We now have two sub-feature branches, one main feature branch, one `dev` branch,
    and our original `master` branch:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个子特性分支，一个主特性分支，一个 `dev` 分支，以及我们的原始 `master` 分支：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Even if you're working on your own, it's useful to create branches, because
    it helps you organize your code and be able to switch between working on different
    features very quickly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你是在独立工作，创建分支也是有用的，因为它可以帮助你组织代码，并能快速地在不同的特性之间切换。
- en: Also note that there is no "right" way to name branches, only wrong ones. For
    instance, you may choose to use an additional grouping for your branches, such
    as `feature/social-login/facebook`. If you are using issue-tracking tools such
    as JIRA, you may also wish to add the issue ID into the branch, such as `fix/HB-593/wrong-status-code`.
    What *is* important is to choose a flexible scheme and be consistent with it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，没有“正确”的方式来命名分支，只有错误的方式。例如，你可能会选择为你的分支使用额外的分组，例如 `feature/social-login/facebook`。如果你使用像
    JIRA 这样的问题跟踪工具，你也可能希望将问题 ID 添加到分支中，例如 `fix/HB-593/wrong-status-code`。重要的是要选择一个灵活的方案，并保持一致性。
- en: Merging branches
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并分支
- en: We have developed our Facebook and Twitter login features on two separate sub-feature
    branches; how can we get these changes back onto the `master` branch? Following
    the Driessen Model, we must merge the two sub-feature branches onto the main feature
    branch, then merge the feature branch into the `dev` branch, and then create a
    release branch off `dev` and merge that release branch into `master`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在两个单独的特性子分支上开发了 Facebook 和 Twitter 登录功能；我们如何将这些更改放回 `master` 分支上？按照 Driessen
    模型，我们必须将两个子特性分支合并到主特性分支上，然后将特性分支合并到 `dev` 分支上，最后从 `dev` 分支创建一个发布分支并将其合并到 `master`
    分支上。
- en: 'To get started, let''s merge the `social-login/facebook` branch into the `social-login/main`
    branch using `git merge`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们使用 `git merge` 将 `social-login/facebook` 分支合并到 `social-login/main` 分支：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Git will attempt to automatically merge the changes from the `social-login/facebook`
    branch into the `social-login/main` branch. Now, our branch structure looks like
    this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Git 将尝试自动将 `social-login/facebook` 分支的更改合并到 `social-login/main` 分支。现在，我们的分支结构看起来是这样的：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we need to do the same for our Twitter login sub-feature. However, when
    we attempt the merge, it fails due to a **merge conflict**:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的Twitter登录子功能做同样的事情。然而，当我们尝试合并时，由于**合并冲突**而失败：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A merge conflict occurs when the changes from the two branches being merged
    overlap each other; Git doesn''t know which version is the most appropriate version
    to move forward with, and so it does not automatically merge them. Instead, it
    adds special Git markup into the file where the merge conflict occurs and expects
    you to manually resolve them:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个正在合并的分支的更改重叠时，会发生合并冲突；Git不知道哪个版本是最合适的版本来继续前进，因此它不会自动合并它们。相反，它在发生合并冲突的文件中添加特殊的Git标记，并期望你手动解决它们：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The part between `<<<<<<< HEAD` and `=======` is the version on our current
    branch, which is `social-login/main`; the part between `=======` and `>>>>>>>
    social-login/twitter` is the version on the `social-login/twitter` branch.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<<<<<< HEAD`和`=======`之间的部分是我们当前分支的版本，即`social-login/main`；`=======`和`>>>>>>>
    social-login/twitter`之间的部分是`social-login/twitter`分支的版本。'
- en: 'We must resolve this merge conflict before the merge is complete. To do that,
    we simply need to edit the file to the version we want, and remove the Git-specific
    sequences. In our example, we want to add the text for `twitter` after `facebook`,
    so we would edit the file to become the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并完成之前，我们必须解决这个合并冲突。为此，我们只需编辑文件到我们想要的版本，并移除Git特定的序列。在我们的例子中，我们想在`facebook`之后添加`twitter`的文本，因此我们会编辑文件使其变为以下内容：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now the conflict is resolved, we need to complete the merge by adding `social-login.txt`
    to the staging area and committing it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在冲突已解决，我们需要通过将`social-login.txt`添加到暂存区域并提交来完成合并：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, if we look again at our Git history, we can see that we''ve implemented
    the Facebook and Twitter login features on two separate branches, and then merged
    them together in a separate commit (the one with the hash `37eb1b9`):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次查看我们的Git历史，我们可以看到我们已经实现了Facebook和Twitter登录功能，并在两个单独的分支上实现了它们，然后在一个单独的提交（带有哈希`37eb1b9`）中合并了它们：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Examining more realistic examples
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查更实际的例子
- en: 'The example we went through previously is very simple and a bit contrived.
    In a more realistic working environment, the `dev` branch will be very active:
    there will be many feature/bug fix branches that stem from `dev` and ultimately
    merge back into it. To illustrate how that can cause issues, and to show you how
    those issues can be mitigated, we''re going back to the `dev` branch to create
    another feature branch; let''s call it `user-schema/main`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的例子非常简单，有点人为。在一个更现实的开发环境中，`dev`分支将会非常活跃：会有许多从`dev`分支衍生出来的功能/错误修复分支，最终合并回它。为了说明这可能会引起的问题，并展示如何缓解这些问题，我们将回到`dev`分支来创建另一个功能分支；让我们称它为`user-schema/main`：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s add a file, `user-schema.js`, which represents the entirety of
    our user schema feature:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个文件，`user-schema.js`，它代表了我们用户模式功能的全部：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can merge this feature branch back into `dev`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这个功能分支合并回`dev`：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our Git history tree now looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的Git历史树看起来是这样的：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you''re finding it hard to visualize the history, try using a Git client
    that visualizes the branches for you. For Mac and Windows, there''s a free client
    by Atlassian called Sourcetree. If you''re on Linux, you may want to try GitKraken.
    We will use GitKraken to illustrate the Git branch structure from here on. For
    example, the preceding figure looks like this on GitKraken:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现可视化历史很难，尝试使用一个为你可视化分支的Git客户端。对于Mac和Windows，有一个由Atlassian提供的免费客户端，名为Sourcetree。如果你使用Linux，你可能想尝试GitKraken。我们将从现在开始使用GitKraken来展示Git分支结构。例如，前面的图在GitKraken上看起来是这样的：
- en: '![](img/4b497310-12f5-46b5-a431-97d19ad1bd14.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b497310-12f5-46b5-a431-97d19ad1bd14.png)'
- en: 'Now, we could merge our `social-login/main` branch back into `dev`, which will
    produce the following branch structure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的`social-login/main`分支合并回`dev`，这将产生以下分支结构：
- en: '![](img/f47cfd37-fdf3-49da-bc5f-3d74af8af0ae.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f47cfd37-fdf3-49da-bc5f-3d74af8af0ae.png)'
- en: 'However, we should not do this because:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不应该这样做，因为：
- en: '**Breaking changes**: The implementation of the social login feature may depend
    on the user''s schema being of a certain shape. Therefore, blindly merging the `social-login/main`
    branch may result in the platform breaking. The `dev` branch is the one that others
    will develop new features from, and so it should be kept bug-free at all times.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏性更改**：社交登录功能的实现可能取决于用户的模式具有特定的形状。因此，盲目合并`social-login/main`分支可能会导致平台崩溃。`dev`分支是其他人将开发新功能的地方，因此它应该始终保持无错误。'
- en: '**Complicated Git history**: The history tree is already quite hard to read,
    and we''ve only implemented two features!'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的Git历史**：历史树已经很难阅读，而我们只实现了两个功能！'
- en: Keeping the dev Branch Bug-Free
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持dev分支无错误
- en: 'The first issue can be tackled by merging the `dev` branch into `social-login/main`,
    testing that everything works as normal, and then merging it back into `dev`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题可以通过将`dev`分支合并到`social-login/main`，测试一切是否正常工作，然后将其合并回`dev`来解决：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This way, any bugs that arise due to the incompatibility of the branches will
    remain on the feature branch, and not on `dev`. This gives us a chance to fix
    these bugs before merging back into `dev`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，由于分支不兼容而产生的任何错误将保留在功能分支上，而不是在`dev`分支上。这给了我们在将它们合并回`dev`之前修复这些错误的机会。
- en: 'While this solved one issue, it exacerbated the other. Our Git history now
    looks like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这解决了一个问题，但它加剧了另一个问题。我们的Git历史现在看起来是这样的：
- en: '![](img/e3ab9b8e-5f91-4f51-9381-a2f2861264f0.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3ab9b8e-5f91-4f51-9381-a2f2861264f0.png)'
- en: Merging the main branch first is not as important for sub-feature branches,
    because feature branches are not expected to be bug-free at all times. I'd leave
    it up to the developer responsible for the feature branch to decide how they'd
    want to work on their feature branch.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于子功能分支来说，首先合并主分支并不那么重要，因为功能分支并不总是期望没有错误。我会让负责功能分支的开发者决定他们如何想要在他们的功能分支上工作。
- en: Keeping our history clean
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持我们的历史清洁
- en: 'The reason our Git history looks so complicated is because `git merge` creates
    a separate commit for the merge. This is good because it doesn''t alter the history
    of any of the branches; in other words, it is non-destructive:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Git历史看起来如此复杂的原因是`git merge`为合并创建了一个单独的提交。这是好的，因为它不会改变任何分支的历史；换句话说，它是非破坏性的：
- en: '![](img/d10e089b-1475-4693-8bbf-f6feb8675036.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d10e089b-1475-4693-8bbf-f6feb8675036.jpg)'
- en: To prevent the complicated history tree we have here, Git provides an alternative
    command, `rebase`, that allows us to merge changes, as well as keep our history
    clean.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们这里复杂的分支树，Git提供了一个替代命令`rebase`，它允许我们合并更改，同时保持我们的历史清洁。
- en: Keeping our history clean with git rebase
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用git rebase保持我们的历史清洁
- en: 'With `git rebase`, instead of creating a new commit for the merge, it will
    try to place the changes on the feature branch as if they were made directly after
    the last commit on the main branch:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`git rebase`，而不是为合并创建一个新的提交，它将尝试将更改放置在功能分支上，就像它们是在主分支上的最后一个提交之后直接做出的：
- en: '![](img/8d805d1e-7e97-48ab-809f-a92a84d35133.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d805d1e-7e97-48ab-809f-a92a84d35133.jpg)'
- en: 'To see how we can work with `rebase`, let''s repeat everything we''ve done
    so far, but using `rebase` instead of `merge`. Create a new directory and open
    your Terminal, then copy and paste the following commands (which will replicate
    everything we''ve done so far):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们如何使用`rebase`，让我们重复到目前为止所做的一切，但使用`rebase`而不是`merge`。创建一个新的目录，然后在终端中打开，然后复制并粘贴以下命令（这些命令将复制我们到目前为止所做的一切）：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our Git history tree now looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Git历史树现在看起来是这样的：
- en: '![](img/34816a4d-4702-4f40-8887-863ad082ffdf.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34816a4d-4702-4f40-8887-863ad082ffdf.png)'
- en: 'First, we can merge `social-login/facebook` into `social-login/main`. As no
    changes have been made on `social-login/main` since the branching occurred, it
    makes no difference whether we use `git merge` or `git rebase`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将`social-login/facebook`合并到`social-login/main`。由于自分支创建以来`social-login/main`上没有进行任何更改，因此使用`git
    merge`或`git rebase`没有区别：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After our merge, there is now a change on the `social-login/main` branch since
    `social-login/twitter` branched out from it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的合并之后，`social-login/main`分支上现在有一个更改，因为`social-login/twitter`是从它分支出来的：
- en: '![](img/881a5e1d-00f3-474b-ad25-b14496273442.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/881a5e1d-00f3-474b-ad25-b14496273442.png)'
- en: 'Here''s where `rebase` is useful:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`rebase`有用的地方：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There''s still going to be a merge conflict, and you should resolve it the
    same way as before. But this time, use `git rebase --continue` instead of `git
    commit`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可能会出现合并冲突，你应该像以前一样解决它。但这次，使用`git rebase --continue`而不是`git commit`：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The difference is, this time, the `git` history for the social login feature
    is linear, as if the changes on the `social-login/twitter` branch were made straight
    after those on the `social-login/main` branch:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，这次，社交登录功能的`git`历史是线性的，就像`social-login/twitter`分支上的更改是在`social-login/main`分支上的更改之后直接进行的：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we need to fast-forward the `social-login/main` branch to follow the
    `social-login/twitter` branch:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`social-login/main`分支快进到跟随`social-login/twitter`分支：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This should produce a much cleaner branch structure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生一个更加干净的分支结构：
- en: '![](img/499b21c5-8fe4-45f0-944f-6c5793fabf89.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/499b21c5-8fe4-45f0-944f-6c5793fabf89.png)'
- en: 'Lastly, we can `rebase` our `social-login/main` branch onto the `dev` branch:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将`social-login/main`分支重置到`dev`分支上：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we have a completely linear commit history on the `social-login/main`
    branch, even though they all originated from different branches:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`social-login/main`分支上有一个完全线性的提交历史，尽管它们都源自不同的分支：
- en: '![](img/dd8b2921-edb7-4f3b-9e4c-a2965336c125.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd8b2921-edb7-4f3b-9e4c-a2965336c125.png)'
- en: 'The last thing to do is to forward the `dev` branch to where the `social-login/main`
    branch is:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将`dev`分支转发到`social-login/main`分支所在的位置：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using merge and rebase together
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用合并和重置结合
- en: I might have given the impression that `git rebase` is cleaner, and thus better,
    than `git merge`. This is not the case; there are pros and cons for each method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能给人留下了这样的印象，即`git rebase`比`git merge`更干净，因此更好。事实并非如此；每种方法都有其优缺点。
- en: '`git rebase` rewrites, or alters, the existing history of the repository by
    trying to replicate changes on the sub-branch at the end of the main branch. This
    makes the history look cleaner and more linear, but loses the context of when
    and where changes are integrated together – we lose the information that `social-login/twitter`
    was originally branched off from `social-login/main`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`git rebase`通过尝试在主分支的末尾复制子分支的更改来重写或更改存储库的现有历史。这使得历史看起来更干净、更线性，但失去了更改集成的时间和地点的上下文——我们失去了`social-login/twitter`最初是从`social-login/main`分支分叉出来的信息。'
- en: So, I'd advise using `git rebase` for feature/bug-fix branches. This allows
    you to commit small and often, making **work-in-progress (WIP) commits**, without
    having to care too much about cleanliness. After your feature is complete, you
    can then clean up your commit history using `git rebase`, before merging into
    the permanent branches.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我建议对于功能/错误修复分支使用`git rebase`。这允许你频繁地提交小的更改，进行**工作进度（WIP）提交**，而不必过于关心整洁性。在功能完成之后，你可以使用`git
    rebase`清理你的提交历史，然后再合并到永久分支中。
- en: On the other hand, when integrating changes from a feature branch into the `dev` branch,
    or from the `dev` branch into `master`, use `git merge` because it provides context
    as to where and when those features were added. Furthermore, we should add a `--no-ff`
    flag to `git merge`, which ensures the merge will *always* create a new commit,
    even when fast-forwarding is possible.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当将功能分支的更改集成到`dev`分支中，或者从`dev`分支集成到`master`分支时，使用`git merge`，因为它提供了关于这些功能何时何地被添加的上下文。此外，我们应该在`git
    merge`中添加`--no-ff`标志，这确保合并将**始终**创建一个新的提交，即使可能进行快速前进。
- en: '![](img/48001ea6-1778-4bf5-84ef-fee80690c1f6.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48001ea6-1778-4bf5-84ef-fee80690c1f6.jpg)'
- en: 'By combining both `git merge` and `git rebase`, it is possible to end up with
    a nice Git history:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合使用`git merge`和`git rebase`，可以得到一个很好的Git历史：
- en: '![](img/666d284e-c689-475d-a5b6-98291aaf6985.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/666d284e-c689-475d-a5b6-98291aaf6985.png)'
- en: 'We can even delete some branches to make the history even cleaner:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以删除一些分支，使历史更加干净：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The branch structure is now much simpler to comprehend:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 分支结构现在更容易理解：
- en: '![](img/5862a7ab-fcf5-4dfc-a3b0-003db63b30d0.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5862a7ab-fcf5-4dfc-a3b0-003db63b30d0.png)'
- en: Releasing code
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布代码
- en: We now have a sizable chunk of features that we can release. We should create
    a release branch from `dev`. This release branch should be named after the version
    of the release, prefixed by `release/`, such as `release/0.1.0`. The code to be
    released should then be deployed to a staging server, where automated UI testing,
    manual testing, and acceptance testing should be conducted (more on these later).
    Any bug fixes should be committed on the release branch and merged back into the
    `dev` branch. When the release branch is ready, it can then be merged into `master`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一块相当大的功能块可以发布。我们应该从`dev`分支创建一个发布分支。这个发布分支应该以发布版本命名，前面加上`release/`前缀，例如`release/0.1.0`。要发布的代码应部署到预发布服务器上，在那里应进行自动化的UI测试、手动测试和验收测试（稍后详细介绍）。任何错误修复都应提交到发布分支并合并回`dev`分支。当发布分支准备就绪后，它可以合并到`master`分支。
- en: No new features should be added to the release branch except bug fixes and hotfixes.
    Any new features, non-critical bug fixes, or bug fixes that are unrelated to the
    release should be committed to a bug-fix branch.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了错误修复和热修复之外，不应在发布分支中添加新功能。任何新功能、非关键错误修复或与发布无关的错误修复都应提交到错误修复分支。
- en: So, the first question is how do we name/version our releases? For this project,
    we'll use **semantic versioning**, or **semver**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个问题是我们的发布如何命名/版本化？对于这个项目，我们将使用**语义版本化**，或**semver**。
- en: Semantic versioning
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义版本化
- en: 'In semver, everything is versioned with three digits, `MAJOR.MINOR.PATCH`,
    which start at `0.1.0` and are incremented as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 semver 中，所有内容都使用三个数字进行版本控制，`MAJOR.MINOR.PATCH`，起始版本为`0.1.0`，按照以下方式递增：
- en: '**Patch**: After a backward-compatible hotfix'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补丁版本更新**：在向后兼容的热修复之后'
- en: '**Minor**: After a backward-compatible set of features/bug fixes have been
    implemented'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小版本更新**：在实现了一组向后兼容的功能/错误修复之后'
- en: '**Major**: After a backward-incompatible change'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主版本更新**：在向后不兼容的更改之后'
- en: We will be following semantic versioning for our releases.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的发布遵循语义版本化。
- en: As with naming feature branches, there are no "right" ways to name release branches.
    For example, you can suffix the release version with a brief description of what
    is included in this release, such as `release/0.1.0-social-login` or `release/0.1.0__social-login`.
    Again, the most important thing is to have a rule and be consistent with it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与命名功能分支一样，发布分支的命名也没有“正确”的方式。例如，你可以在发布版本后加上对本次发布包含内容的简要描述，如`release/0.1.0-social-login`或`release/0.1.0__social-login`。再次强调，最重要的是制定一个规则并保持一致性。
- en: Creating a release branch
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建发布分支
- en: 'Now, let''s create our release branch and name it `release/0.1.0`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的发布分支并将其命名为`release/0.1.0`：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If this was a real scenario, we''d deploy the branch onto a staging server
    for it to be more thoroughly tested. For now, let''s assume we have found a bug:
    the text for `facebook` and `twitter` inside `social-login.txt` should be capitalized
    to `Facebook` and `Twitter`. So, let''s make that fix and commit it directly on
    the release branch:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个真实场景，我们会将分支部署到预发布服务器上进行更彻底的测试。现在，让我们假设我们找到了一个错误：`social-login.txt`中`facebook`和`twitter`的文本应该大写为`Facebook`和`Twitter`。所以，让我们修复这个错误并直接在发布分支上提交：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we would test the revised code again, and assuming there are no more bugs,
    we can merge it into `master`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次测试修改后的代码，假设没有发现更多错误，我们可以将其合并到`master`分支：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we merge, it will ask us for a commit message; we can just stick with
    the default message, `Merge branch ''release/0.1.0''`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们合并时，它会要求我们输入提交信息；我们可以直接使用默认信息，`Merge branch 'release/0.1.0'`：
- en: '![](img/125a779d-fcaf-4d62-ab10-71152381fc3c.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/125a779d-fcaf-4d62-ab10-71152381fc3c.png)'
- en: 'Lastly, we should remember to apply the bug fixes we made on the release branch
    back into `dev`; if we have any other active release branches, we should apply
    it to those as well:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该记得将发布分支上所做的错误修复应用到`dev`分支；如果我们有任何其他活动的发布分支，我们也应该将其应用到这些分支上：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We end up with a Git branch structure similar to this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到的 Git 分支结构类似于以下这样：
- en: '![](img/2c3309c6-df1a-4ce6-a8cf-1b899eb350ce.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c3309c6-df1a-4ce6-a8cf-1b899eb350ce.png)'
- en: Tagging releases
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记发布
- en: Lastly, we should tag our release. **Tags**, in Git, are markers that highlight
    certain points in the commit history as being important. Releases are important,
    so the convention is to represent releases as tags on the `master` branch.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该标记我们的发布。在 Git 中，**标签**是标记某些提交历史点为重要的标记。发布很重要，因此惯例是在`master`分支上表示发布为标签。
- en: There are two types of tags: **lightweight** and **annotated** tags. A lightweight
    tag is simply a pointer to a particular commit. Annotated tags are, on the other
    hand, full objects in the Git database, similar to a commit. Annotated tags contain
    information about the tagger, the date, and an optional message. We should use
    annotated tags to tag releases.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的标签：**轻量级**和**注解**标签。轻量级标签只是指向特定提交的指针。另一方面，注解标签是 Git 数据库中的完整对象，类似于提交。注解标签包含有关标记者、日期和可选消息的信息。我们应该使用注解标签来标记发布。
- en: The Git Manual (accessible when you run `git tag --help`) states *"*Annotated
    tags are meant for release while lightweight tags are meant for private or temporary
    object labels."
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Git 手册（当你运行 `git tag --help` 时可访问）指出：“*注解标签旨在用于发布，而轻量级标签旨在用于私有或临时对象标签。”
- en: 'Check out the `master` branch and add an annotated tag by running `git tag`
    with the `-a` flag. The name of the tag should be the semver version, and you
    should also add a message describing the release:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 检出 `master` 分支，并运行带有 `-a` 标志的 `git tag` 命令来添加一个注解标签。标签的名称应该是 semver 版本，你还应该添加一个描述发布的消息：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Hotfixes
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热修复
- en: The last thing we need to cover for our Git workflow is how to deal with bugs
    we discover in production (on our `master` branch). Although our code should have
    already been thoroughly tested before being added to `master`, subtle bugs are
    bound to slip through, and we must fix them quickly. This is call a **hotfix**.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要覆盖的最后一个关于 Git 工作流程的内容是如何处理在生产环境中（在我们的 `master` 分支上）发现的错误。尽管我们的代码在添加到 `master`
    之前应该已经经过了彻底的测试，但细微的错误难免会漏网，我们必须迅速修复它们。这被称为**热修复**。
- en: 'Working on a hotfix branch is very similar to working on a release branch;
    the only difference is that we are branching off `master` instead of `dev`. Like
    with release branches, we''d make the changes, test it, deploy it onto a staging
    environment, and perform more testing, before merging it back into `master`, `dev`,
    and any current release branches:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在热修复分支上工作与在发布分支上工作非常相似；唯一的区别是我们是从 `master` 而不是 `dev` 分支进行分支。就像发布分支一样，我们会进行更改，测试，将更改部署到预发布环境中，并进行更多测试，然后再将其合并回
    `master`，`dev` 和任何当前发布分支：
- en: '![](img/5ded1335-7fee-4fa1-aa3d-459e093b9a07.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ded1335-7fee-4fa1-aa3d-459e093b9a07.jpg)'
- en: 'So, first we make the fix:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先我们进行修复：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, we merge it into `master`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将其合并到 `master`：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As we have added something new to master, it essentially becomes a new release
    and therefore we need to increase the version number and tag this new commit.
    Since this is a bug fix and adds no new features to the platform, we should increase
    the patch version to `0.1.1`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `master` 上添加了新内容，它本质上成为了一个新的发布版本，因此我们需要增加版本号并标记这个新的提交。由于这是一个错误修复，并没有向平台添加新功能，我们应该将补丁版本增加到
    `0.1.1`：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lastly, don''t forget to merge the hotfix changes back into `dev` and, if relevant,
    other release branches:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了将热修复更改合并回 `dev` 分支，如果相关的话，还可以合并到其他发布分支：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Our Git history tree now looks like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Git 历史树现在看起来像这样：
- en: '![](img/21e31e8d-d5a3-440c-9234-2a40ed2c4bd5.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21e31e8d-d5a3-440c-9234-2a40ed2c4bd5.png)'
- en: You can clearly distinguish the two permanent branches, `master` and `dev`,
    as everything seems to revolve around them. However, it's also clear that adding
    a hotfix makes the Git history more complicated than before, and so hotfixes should
    only be made when absolutely necessary.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地区分两个永久分支，`master` 和 `dev`，因为似乎所有事情都围绕着它们。然而，也很清楚，添加热修复会使 Git 历史比以前更复杂，因此只有在绝对必要时才应进行热修复。
- en: Working with others
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与他人协作
- en: So far, we've outlined how to manage our Git repository when developing by ourselves;
    however, more often than not, you'll work as part of a team. In those instances,
    your team must work in a way that allows your colleagues to get the updates you
    have done, as well as update others on their own changes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经概述了在独自开发时如何管理我们的 Git 仓库；然而，更常见的情况是，你将作为团队的一部分工作。在这些情况下，你的团队必须以一种方式工作，使得你的同事能够获取你已完成的所有更新，同时也能更新他们自己的更改。
- en: 'Fortunately, Git is a *distributed* VCS, which means any local repository can
    act as the remote repository for someone else. This means your colleagues can **pull** your
    changes onto their machine, and you can pull their changes onto yours:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Git 是一个**分布式**版本控制系统，这意味着任何本地仓库都可以作为其他人的远程仓库。这意味着你的同事可以将你的更改拉到他们的机器上，你也可以将他们的更改拉到你的机器上：
- en: '![](img/5d48350d-651b-48e7-8701-aed7f7e1181d.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d48350d-651b-48e7-8701-aed7f7e1181d.png)'
- en: However, this would mean you'd have to pull from everybody's machine regularly
    to get all the latest changes. Furthermore, where there are merge conflicts, one
    person might resolve them differently to another.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着您需要定期从每个人的机器上拉取，以获取所有最新的更改。此外，当存在合并冲突时，一个人可能以不同的方式解决它们。
- en: So while it is technically possible to follow this distributed workflow, most
    teams elect a single repository that they consider to be the central one.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然从技术上讲可以遵循这个分布式工作流程，但大多数团队会选择一个他们认为的中央仓库。
- en: 'By convention, this remote repository is called `origin`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，这个远程仓库被称为`origin`：
- en: '![](img/201c4432-d7b1-491e-8290-6d5df17faa1c.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/201c4432-d7b1-491e-8290-6d5df17faa1c.jpg)'
- en: When you want to update your local repository with changes made by your colleagues,
    you *pull* from the `origin` repository. When you have changes that you think
    are ready to be incorporated, you push them into `origin`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想将同事所做的更改更新到您的本地仓库时，您从`origin`仓库中*拉取*。当您认为更改已经准备好可以合并时，您将它们推送到`origin`。
- en: Creating a remote repository
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建远程仓库
- en: There are many ways to host a remote repository. You can set up your own server,
    or you can use a hosted service such as Bitbucket or GitHub. We are going to use
    GitHub as it is the most popular, and is free for public repositories.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 存储远程仓库有许多方式。您可以设置自己的服务器，或者可以使用像Bitbucket或GitHub这样的托管服务。我们将使用GitHub，因为它是最受欢迎的，并且公共仓库免费。
- en: If you'd like to keep your repository private, you can either pay for a personal
    plan from GitHub, which is currently set at $7 per month; or you can use BitBucket,
    which is free for both public and private repositories (although other limits
    apply).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想保持您的仓库私有，您可以选择从GitHub购买个人计划，目前每月价格为7美元；或者您可以使用Bitbucket，它对公共和私有仓库都是免费的（尽管适用其他限制）。
- en: Go to [https://github.com/](https://github.com/) and click on the Sign Up button
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://github.com/](https://github.com/)并点击“注册”按钮
- en: Fill in your details to create an account
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写您的详细信息以创建账户
- en: Once logged in, click on the New Repository button or go to [https://github.com/new](https://github.com/new)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，点击“新建仓库”按钮或前往[https://github.com/new](https://github.com/new)
- en: 'Fill in the details about the repository, but do *not* check the Initialize
    this repository with a README box or add a license:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写有关仓库的详细信息，但不要勾选“使用README初始化此仓库”或添加许可证：
- en: '![](img/828c152c-7255-4b3e-b2ca-53f007cf6238.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/828c152c-7255-4b3e-b2ca-53f007cf6238.png)'
- en: 'After you press Create repository, GitHub should show a Quick setup tooltip.
    This indicates that we have now successfully created our repository:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您点击创建仓库后，GitHub 应该会显示一个快速设置提示。这表明我们已经成功创建了我们的仓库：
- en: '![](img/e0038e9c-ec93-4099-a58c-30a4b9d2bcde.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e0038e9c-ec93-4099-a58c-30a4b9d2bcde.png)'
- en: Pulling and pushing
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉取和推送
- en: 'Next, we need to update our local repository so it knows the address of the
    remote repository:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的本地仓库，使其知道远程仓库的地址：
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Don't use `https://github.com/d4nyll/hobnob.git`; create your own remote repository
    instead.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`https://github.com/d4nyll/hobnob.git`；而是创建自己的远程仓库。
- en: 'If you get a `fatal: Authentication failed for https://github.com/d4nyll/hobnob.git/`
    error, check that your GitHub username and password are entered properly. If you
    use two-factor authentication (2FA) on your GitHub account, you need to use an
    SSH key to push to the remote repository.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您收到`fatal: Authentication failed for https://github.com/d4nyll/hobnob.git/`错误，请检查您的GitHub用户名和密码是否输入正确。如果您在GitHub账户上使用了两步验证（2FA），则需要使用SSH密钥来推送远程仓库。'
- en: The `-u` tag sets the upstream repository to be `origin`. Without it, we would
    have to specify which remote repository we want to push to or pull from every
    time we run `git push` and `git pull`; using the `-u` tag here will save us a
    lot of time in the future. Subsequent pushes and pulls can omit the `-u` tag.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u`标签将上游仓库设置为`origin`。如果没有它，每次运行`git push`和`git pull`时，我们都需要指定我们想要推送或拉取的远程仓库；使用`-u`标签将节省我们未来的很多时间。后续的推送和拉取可以省略`-u`标签。'
- en: 'By default, `git push` doesn''t push tags to remote repositories. So, we''d
    have to push tags manually. The syntax for pushing tags is similar to that of
    pushing branches:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`git push`不会将标签推送到远程仓库。因此，我们不得不手动推送标签。推送标签的语法与推送分支的语法类似：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Alternatively, if you want to push all tags, you can run the following command
    instead:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想推送所有标签，可以运行以下命令代替：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Cloning a repository
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆仓库
- en: 'Our code is now publicly available on GitHub. Our colleagues and/or collaborators
    can now download the code using the `git clone` command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目代码现在在GitHub上是公开可用的。我们的同事和/或合作者现在可以使用`git clone`命令下载代码：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will create a new directory inside the directory where the `git clone`
    command was run, and copy the contents of the remote repository into it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在运行`git clone`命令的目录内创建一个新的目录，并将远程仓库的内容复制到其中。
- en: 'Your collaborators can then work on this local copy of the repository, commit
    changes, and add new branches. Once they are ready to make their changes available
    to others, they can pull from the remote repository, resolve merge conflicts,
    and then push their changes back to `origin`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你的合作者可以随后在这个仓库的本地副本上工作，提交更改，并添加新的分支。一旦他们准备好将他们的更改提供给他人，他们可以从远程仓库拉取，解决合并冲突，然后将他们的更改推回到`origin`：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Conducting peer review through pull requests
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过拉取请求进行同行评审
- en: Most of the time, it's fine to allow anyone to push to and pull from the repository.
    However, for more important projects, you may wish to prevent new or junior developers
    from pushing to important branches such as `dev` and `master`. In those instances,
    the owner of the repository may restrict push rights to only a small selection
    of trusted developers.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，允许任何人向仓库推送或从仓库拉取是没问题的。然而，对于更重要的项目，你可能希望阻止新或初级开发者向重要的分支，如`dev`和`master`，进行推送。在这些情况下，仓库的所有者可能会限制推送权限，仅允许一小部分受信任的开发者。
- en: For non-trusted developers, in order to make a change to `dev` or `master`,
    they must create a new branch (such as a feature or bug-fix branch), push to that
    branch, and create a **pull request** (**PR**). This PR is a formal request for
    their branch to be merged back to `dev` or `master`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不受信任的开发者来说，为了对`dev`或`master`进行更改，他们必须创建一个新的分支（例如功能或错误修复分支），将该分支推送到该分支，并创建一个**拉取请求**（**PR**）。这个PR是一个将他们的分支合并回`dev`或`master`的正式请求。
- en: Pull requests are a feature of platforms such as GitHub and BitBucket, and not
    of Git itself.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求是GitHub和BitBucket等平台的一个功能，而不是Git本身的功能。
- en: 'After receiving a pull request, the owner or maintainer will review your work
    and provide feedback. On GitHub, this is done through comments. The contributor
    will then work with the maintainers and make changes to the code until both are
    happy with the changes. At this point, the maintainer will accept your pull request
    and merge it into the intended branch:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接收拉取请求后，所有者或维护者将审查你的工作并提供反馈。在GitHub上，这是通过评论来完成的。贡献者随后将与维护者合作，对代码进行更改，直到双方都对更改满意。此时，维护者将接受你的拉取请求并将其合并到目标分支：
- en: '![](img/dccd81d3-74fb-4ba8-afea-c142101a1d61.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dccd81d3-74fb-4ba8-afea-c142101a1d61.png)'
- en: Conversely, if the maintainers do not feel the changes are in line with the
    goals of the project, they can reject them.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果维护者认为更改不符合项目的目标，他们可以拒绝这些更改。
- en: 'Implementing pull requests in your development process has several benefits:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的开发流程中实施拉取请求有几个好处：
- en: You can notify your peers that a feature/bug fix has been completed.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通知你的同事一个功能/错误修复已经完成。
- en: It is a formal process where all comments and discussions are logged.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个正式的过程，其中所有评论和讨论都被记录下来。
- en: You can invite reviewers to peer-review the changes you've made. This allows
    them to help spot obvious errors, as well as to provide feedback on your code.
    This not only ensures the code quality of the source code is high, it also helps
    the developer learn from other people's experience.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以邀请审阅者对所做的更改进行同行评审。这允许他们帮助发现明显的错误，并提供关于你代码的反馈。这不仅确保了源代码的代码质量高，还有助于开发者从他人的经验中学习。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we outlined how to manage your project's version history using
    Git. We started by understanding the different states in Git and practicing some
    basic Git commands, and using them to commit, branch, and merge our changes. We
    then set up a remote repository on GitHub, which allowed us to share our code
    and collaborate with others.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了如何使用Git管理你项目的版本历史。我们首先理解Git中的不同状态，并练习一些基本的Git命令，然后使用它们来提交、分支和合并我们的更改。然后我们在GitHub上设置了一个远程仓库，这使得我们可以共享我们的代码并与他人协作。
- en: The workflow and conventions used here are opinionated, and you may come across
    different patterns in your workplace. There is no right way to use Git, only wrong
    ways, and the rules we used here are not perfect. For example, in the Driessen
    model, once a feature is merged into `dev`, it will be hard to extract it. Therefore,
    we have to be careful not to merge in features that are not meant for the current
    release. Therefore, the most important takeaway from this chapter is to establish
    a set of conventions with your team, and stick to it consistently.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的流程和约定是具有主观性的，你可能在你的工作场所遇到不同的模式。使用 Git 没有正确的方式，只有错误的方式，我们在这里使用的规则并不完美。例如，在
    Driessen 模型中，一旦一个特性被合并到 `dev`，就很难将其提取出来。因此，我们必须小心不要合并那些不适合当前发布的特性。因此，本章最重要的收获是与你的团队建立一套约定，并始终如一地坚持它。
- en: In the next chapter, we will start writing our first lines of code, setting
    up our development environments and tools, and integrating with JavaScript-specific
    tools, such as `npm`, `yarn`, Babel, and `nodemon`. For the rest of this book,
    as you work through the exercises and build the application, we expect you to
    use the workflow outlined here to keep a version history of your code.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始编写我们的第一行代码，设置我们的开发环境和工具，并集成 JavaScript 特定的工具，如 `npm`、`yarn`、Babel
    和 `nodemon`。在本书的剩余部分，当你完成练习并构建应用程序时，我们期望你使用这里概述的流程来保持代码的版本历史。
