- en: Node Fundamentals – Part 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node基础知识-第3部分
- en: We start adding support for all the other commands inside of the notes application.
    We'll take a look at how we can create our `read` command. The `read` command
    will be responsible for fetching the body of an individual note. It will fetch
    all the notes and print them to the screen. Now, aside from all of that, we'll
    be looking at debugging broken apps, and we'll look at some new ES6 features.
    You'll learn how to use the built-in Node `debugger`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始为笔记应用程序中的所有其他命令添加支持。我们将看看如何创建我们的`read`命令。`read`命令将负责获取单个笔记的正文。它将获取所有笔记并将它们打印到屏幕上。除此之外，我们还将研究如何调试损坏的应用程序，并了解一些新的ES6功能。您将学习如何使用内置的Node`debugger`。
- en: Then, you will learn a little bit more about how we can configure yargs for
    the command-line interface applications. We'll learn how to set up the commands,
    their descriptions, and the arguments. We'll be able to set various properties
    on the arguments, for example, whether or not they're required, and others.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将学习更多关于如何配置yargs以用于命令行界面应用程序。我们将学习如何设置命令、它们的描述和参数。我们将能够在参数上设置各种属性，例如它们是否是必需的等等。
- en: Removing a note
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除笔记
- en: In this section, you will write the code for removing a note when someone uses
    that `remove` command, and they pass in the title of the note they want to remove.
    In the previous chapter, we already created some utility functions that help us
    with fetching and saving notes, so the code should actually be pretty simple.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，当有人使用`remove`命令并传入他们想要移除的笔记的标题时，您将编写删除笔记的代码。在上一章中，我们已经创建了一些实用函数来帮助我们获取和保存笔记，所以代码实际上应该非常简单。
- en: Using the removeNote function
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`removeNote`函数
- en: The first step in the process is to fill out the `removeNote` function, which
    we defined in the previous chapters, and this will be your challenge. Let's remove
    `console.log` from the `removeNote` function in the `notes.js` file. You only
    need to write three lines of code to get this done.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的第一步是填写我们在之前章节中定义的`removeNote`函数，这将是您的挑战。让我们从`notes.js`文件的`removeNote`函数中删除`console.log`。您只需要编写三行代码就可以完成这项任务。
- en: Now, the first line will fetch the notes, then the job will be to filter out
    the notes, removing the one with title of argument. That means we want to go through
    all of the notes in the notes array, and if any of them have a title that matches
    the title we want to remove, we want to get rid of them. And this can be done
    using the `notes.filter` function we used earlier. All we have to do is switch
    the equality statement in the `duplicateNotes` function from equals to not equals,
    and this code will do just that.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一行将获取笔记，然后工作将是过滤掉笔记，删除参数标题的笔记。这意味着我们想要遍历笔记数组中的所有笔记，如果它们中的任何一个标题与我们想要删除的标题匹配，我们就想要摆脱它们。这可以使用我们之前使用的`notes.filter`函数来完成。我们只需要在`duplicateNotes`函数中的等式语句中切换为不等式，这段代码就可以做到这一点。
- en: 'It will go through the notes array. Every time it finds a note that doesn''t
    match the title it will keep it, which is what we want, and if it does find the
    title it will return `false` and remove it from the array. And then we will add
    the third line, which is to save the new notes array:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它将遍历笔记数组。每当它找到一个与标题不匹配的笔记时，它将保留它，这是我们想要的，如果它找到标题，它将返回`false`并将其从数组中删除。然后我们将添加第三行，即保存新的笔记数组：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code lines are the only three lines you need to fill out. Don't
    worry about returning anything from `removeNote` or filling out anything inside
    of `app.js`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行是您需要填写的唯一三行。不要担心从`removeNote`返回任何内容或填写`app.js`中的任何内容。
- en: 'The first thing we will do for the `fetchNotes` line is to create a variable
    called `notes`, just like we did in `addNote` in the previous chapter, and we''ll
    set it equal to the return result from `fetchNotes`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`fetchNotes`行的第一件事是创建一个名为`notes`的变量，就像我们在上一章的`addNote`中所做的一样，并将其设置为从`fetchNotes`返回的结果：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point our notes variable stores an array of all of the notes. The next
    thing we need to do is filter our notes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的笔记变量存储了所有笔记的数组。我们需要做的下一件事是过滤我们的笔记。
- en: 'If there is a note that has this title, we want to remove it. This will be
    done by creating a new variable, and I''ll call this one `filteredNotes`. Here
    we''ll set `filteredNotes` equal to the result that will come back from `notes.filter`,
    which we already used up previously:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个具有这个标题的笔记，我们想要删除它。这将通过创建一个新变量来完成，我将称其为`filteredNotes`。在这里，我们将`filteredNotes`设置为将从`notes.filter`返回的结果，这是我们之前已经使用过的：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We know that `notes.filter` takes a function as its one and only argument, and
    that function gets called with the individual item in the array. In this case
    it would be a `note`. And we can do this all on one line using the ES6 arrow syntax.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`notes.filter`接受一个函数作为它唯一的参数，并且该函数被调用时会用数组中的单个项目。在这种情况下，它将是一个`note`。我们可以使用ES6箭头语法在一行上完成所有这些。
- en: If we have only one statement, we don't need to open and close curly braces.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只有一条语句，我们不需要打开和关闭大括号。
- en: 'That means right here we can return `true` if `note.title` does not equal the
    title that''s passed into the function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在这里，如果`note.title`不等于传入函数的标题，我们可以返回`true`：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will populate `filteredNotes` with all of the notes whose titles do not
    match the one passed in. If the title does match the title passed in, it will
    not be added to `filteredNotes` because of our filter function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用所有标题与传入标题不匹配的所有笔记填充`filteredNotes`。如果标题与传入的标题匹配，它将不会被添加到`filteredNotes`中，因为我们的过滤函数。
- en: 'The last thing to do is to call `saveNotes`. Right here, we''ll call `saveNotes`
    passing in the new notes array which we have under the `filteredNotes` variable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的是调用`saveNotes`。在这里，我们将调用`saveNotes`，传入我们在`filteredNotes`变量下拥有的新笔记数组：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we were to pass in notes, it wouldn't work as expected; we're filtering the
    notes out but we're not actually saving those notes, so it will not get removed
    from the JSON. We need to pass `filteredNotes` as shown in the preceding code.
    And we can test these by saving the file and trying to remove one of our notes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传入笔记，它不会按预期工作；我们正在过滤掉笔记，但实际上并没有保存这些笔记，因此它不会从JSON中删除。我们需要像前面的代码中所示那样传递`filteredNotes`。我们可以通过保存文件并尝试删除我们的笔记来测试这些。
- en: I'll try to remove `secret2` from the `notes-data.json` file. That means all
    we need to do is run the command, which we called `remove`, that is specified
    over in `app.js`, (refer to the following code image, and then it will call our
    function).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我将尝试从`notes-data.json`文件中删除`secret2`。这意味着我们需要做的就是运行我们在`app.js`中指定的命令`remove`（参考下面的代码图像，然后它将调用我们的函数）。
- en: 'I''ll run Node with `app.js`, and we''ll pass in the `remove` command. The
    only argument we need to provide for remove is the title; there''s no need to
    provide the body. I''ll set this equal to `secret2`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`app.js`运行Node，并传入`remove`命令。我们需要为remove提供的唯一参数是标题；无需提供正文。我将把这个设置为`secret2`：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/f7a91df7-d4f6-4f3d-9e94-4e38735a7722.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7a91df7-d4f6-4f3d-9e94-4e38735a7722.png)'
- en: As shown in the screenshot, if I hit *enter* you can see we don't get any output.
    Although we do have the command remove printing, there is no message saying whether
    or not a note was removed, but we'll add that later in the section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如屏幕截图所示，如果我按*enter*，你会看到我们没有得到任何输出。虽然我们有删除打印命令，但没有消息表明是否删除了笔记，但我们稍后会在本节中添加。
- en: 'For now, we can check the data. And right here you can see `secret2` is nowhere
    in sight:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查数据。在这里你可以看到`secret2`不见了：
- en: '![](img/f0092e4b-009f-460a-9c51-7a4021d9a960.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0092e4b-009f-460a-9c51-7a4021d9a960.png)'
- en: This means our remove method is indeed working as expected. It removed the note
    whose title matched and it kept all the notes whose title was not equal to `secret2`,
    exactly what we wanted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的remove方法确实按预期工作。它删除了标题匹配的笔记，并保留了所有标题不等于`secret2`的笔记，这正是我们想要的。
- en: Printing a message of removing notes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印删除笔记的消息
- en: Now, the next thing we'll do is print a message depending on whether or not
    a note was actually removed. That means `app.js`, which calls the `removeNote`
    function, will need to know whether or not a note was removed. And how do we figure
    that out? How can we possibly return that given the information we have in `notes.js
    removeNotes` function?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要做的下一件事是根据是否实际删除了笔记来打印消息。这意味着调用`removeNote`函数的`app.js`需要知道是否删除了笔记。我们如何弄清楚呢？在`notes.js
    removeNotes`函数中，我们如何可能返回那个信息？
- en: Well, we can, because we have two really important pieces of information. We
    have the length of the original notes array and we have the length of the new
    notes array. If they're equal then we can assume that no note was removed. If
    they are not equal, we'll assume that a note was removed. And that is exactly
    what we'll do.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做，因为我们有两个非常重要的信息。我们有原始笔记数组的长度和新笔记数组的长度。如果它们相等，那么我们可以假设没有笔记被删除。如果它们不相等，我们将假设已经删除了一个笔记。这正是我们要做的。
- en: 'If the `removeNote` function returns `true`, that means a note was removed;
    if it returns `false`, that means a note was not removed. In the `removeNotes`
    function we can add return, as shown in the following code. We''ll check if `notes.length`
    does not equal `filteredNotes.length`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`removeNote`函数返回`true`，那意味着已删除一个笔记；如果返回`false`，那意味着没有删除笔记。在`removeNotes`函数中，我们可以添加返回，如下面的代码所示。我们将检查`notes.length`是否不等于`filteredNotes.length`：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If they're not equal it will return `true`, which is what we want because a
    note was removed. If they're equal it will return `false`, which is great.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们不相等，它将返回`true`，这是我们想要的，因为已经删除了一个笔记。如果它们相等，它将返回`false`，这很好。
- en: 'Now, inside of `app.js` we can add a few lines in the `removeNote`, `else if`
    block to make the output for this command a little nicer. The first thing to do
    is to store that Boolean. I''ll make a variable called `noteRemoved` and we''ll
    set that equal to the return, result as shown in the following code, which will
    either be `true` or `false`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`app.js`中，我们可以在`removeNote`的`else if`块中添加几行代码，以使此命令的输出更加友好。要做的第一件事是存储布尔值。我将创建一个名为`noteRemoved`的变量，并将其设置为返回的结果，如下面的代码所示，它将是`true`或`false`：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On the next line, we can create our message, and I'll do this all on one line
    using the ternary operator. Now, the ternary operator lets you specify a condition.
    In our case, we'll use a var message and it will be set equal to the condition
    `noteRemoved`, which will be `true` if a note was removed and `false` if it wasn't.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们可以创建我们的消息，我将使用三元运算符在一行上完成所有这些。现在，三元运算符允许您指定条件。在我们的情况下，我们将使用一个变量消息，并将其设置为条件`noteRemoved`，如果删除了一个笔记，则为`true`，如果没有，则为`false`。
- en: Now, the ternary operator can be a little confusing, but it's really useful
    inside JavaScript and Node.js. The format for the ternary operator is first we
    add the condition, question mark, the truthy expression to run, colon, and then
    the falsy expression to run.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，三元运算符可能有点令人困惑，但在JavaScript和Node.js中非常有用。三元运算符的格式是首先添加条件，问号，要运行的真值表达式，冒号，然后是要运行的假值表达式。
- en: 'After the condition, we''ll put a space with a question mark and a space; this
    is the statement that will run if it''s true. If the `noteRemoved` condition passes,
    what we want to do is set message equal to `Note was removed`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件之后，我们将放一个空格，然后是一个问号和一个空格；这是如果条件为真时将运行的语句。如果`noteRemoved`条件通过，我们要做的是将消息设置为`Note
    was removed`：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if `noteRemoved` is `false`, we can specify that condition right after
    the colon in the previous statement. Here, if there is no note removed we''ll
    use the text `Note not found`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`noteRemoved`是`false`，我们可以在前一个语句的冒号后面指定该条件。在这里，如果没有笔记被删除，我们将使用文本`Note not
    found`：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now with this in place, we can test out our message. The last thing to do is
    print the message to the screen using `console.log` passing in message:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个，我们可以测试一下我们的消息。最后要做的就是使用`console.log`将消息打印到屏幕上：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This lets us avoid `if` statements that make our `else-if` clause to remove
    unnecessarily complex.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们避免了使我们的`else-if`子句变得不必要复杂的`if`语句。
- en: 'Back inside of Atom we can rerun the last command, and in this case no note
    will get removed because we already deleted it. And when I run it, you can see
    that `Note not found` prints to the screen:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Atom中，我们可以重新运行上一个命令，在这种情况下，没有笔记会被删除，因为我们已经删除了它。当我运行它时，你可以看到`Note not found`打印到屏幕上：
- en: '![](img/9ded0f16-d917-485a-9c5f-1c8231fe080a.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ded0f16-d917-485a-9c5f-1c8231fe080a.png)'
- en: 'Now I''ll remove a note that does exist; in `notes-data.json` I have a note
    with a title of secret as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将删除一个确实存在的笔记；在`notes-data.json`中，我有一个标题为secret的笔记，如下所示：
- en: '![](img/9b9cded3-60d0-4eb4-a6ae-8b826e562995.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b9cded3-60d0-4eb4-a6ae-8b826e562995.png)'
- en: 'Let''s rerun the command removing the `2` from the title in Terminal. When
    I run this command, you can see `Note was removed` prints to the screen:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新运行在终端中删除标题中的`2`的命令。当我运行这个命令时，你可以看到`Note was removed`打印到屏幕上：
- en: '![](img/eb707253-3796-471f-a3a8-4b233cbf0a26.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb707253-3796-471f-a3a8-4b233cbf0a26.png)'
- en: That is it for this section; we now have our `remove` command in place.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本节的全部内容；我们现在已经有了我们的`remove`命令。
- en: Reading note
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读笔记
- en: 'In this section, you will be responsible for filling out the rest of the `read`
    command. Now, the `read` command does have an else-if block to find in `app.js`
    where we call `getNote`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将负责填写`read`命令的其余部分。现在，`read`命令确实有一个else-if块，在`app.js`中找到我们调用`getNote`的地方：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`getNote` is defined over inside `notes.js`, even though currently it just
    prints out some dummy text:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNote`在`notes.js`中定义，尽管目前它只是打印一些虚拟文本：'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What you'll need to do in this section is wire up both of these functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您需要连接这两个函数。
- en: First up, you will need to do something with the return value from `getNote`.
    Our `getNote` function will return the note object if it finds it. If it doesn't,
    it will return undefined just like we do for `addNote` discussed in the section
    *Adding and saving note*, in the previous chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要对`getNote`的返回值做一些处理。如果我们的`getNote`函数找到了笔记对象，它将返回该笔记对象。如果没有找到，它将返回undefined，就像我们在上一章节*添加和保存笔记*中讨论的`addNote`一样。
- en: 'After you store that value, you''ll do some printing using `console.log`, similar
    to what we have here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 存储了该值之后，您将使用`console.log`进行一些打印，类似于我们这里所做的：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Obviously, `Note created` will be something like `Note read` and `Note title
    taken` will be something like `Note not found`, but the general flow is going
    to be exactly the same. Now, once you have that wired up inside of `app.js`, you
    can move on to `notes.js`, filling out the function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`Note created`将类似于`Note read`，`Note title taken`将类似于`Note not found`，但是一般的流程将完全相同。现在，一旦您在`app.js`中连接了这一切，您可以继续填写函数的`notes.js`。
- en: Now, the function inside of `notes.js` isn't going to be that complex. All you
    need to do is fetch the notes, like we've done in previous methods, then you're
    going to use `notes.filter`, which we explored to only return notes whose title
    matches the title passed in as the argument. Now, in our case this is either going
    to be zero notes, which means the note is not found, or it's going to be one note,
    which means we've found the note that the person wants to return.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`notes.js`中的函数不会太复杂。您需要做的只是获取笔记，就像我们在以前的方法中所做的那样，然后您将使用`notes.filter`，我们探索了只返回标题与作为参数传入的标题匹配的笔记。现在，在我们的情况下，这要么是零个笔记，这意味着找不到笔记，要么是一个笔记，这意味着我们找到了人们想要返回的笔记。
- en: Next, we do need to return that note. It's important to remember the return
    value from `notes.filter` is always going to be an array, even if that array only
    has one item. What you're going to need to do is return the first item in the
    array. If that item doesn't exist that's fine, it'll return undefined, as we want.
    If it does exist, great, that means we found the note. This method only requires
    three lines of code, one for fetching, one for filtering, and the return statement.
    Now, once you have all that done we'll test it out.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们确实需要返回那个笔记。重要的是要记住，`notes.filter`的返回值始终是一个数组，即使该数组只有一个项目。您需要做的是返回数组中的第一个项目。如果该项目不存在，那没关系，它将返回undefined，这正是我们想要的。如果存在，那很好，这意味着我们找到了笔记。这个方法只需要三行代码，一个用于获取，一个用于过滤，一个用于返回语句。现在，一旦您完成了所有这些，我们将对其进行测试。
- en: Using the getNote function
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用getNote函数
- en: 'Let''s work on this method. Now, the first thing I''ll do is fill out, inside
    of `app.js`, a variable called note which is going to store the return value from
    `getNote`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来处理这个方法。现在，我要做的第一件事是在`app.js`中填写一个名为note的变量，它将存储从`getNote`返回的值：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, this could be an individual note object or it could be undefined. In the
    next line, I can use an `if` statement to print the message if it exists, or if
    it does not exist. I''ll use `if` note, and I am going to attach an `else` clause:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可能是一个单独的笔记对象，也可能是undefined。在下一行，我可以使用`if`语句来打印消息，如果它存在，或者如果它不存在。我将使用`if`
    note，并且我将附加一个`else`子句：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This `else` clause will be responsible for printing an error if the note is
    not found. Let''s get started with that first since it''s pretty simple, `console.log`,
    `Note not found`, as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`else`子句将负责在找不到笔记时打印错误。让我们先从这个开始，因为它非常简单，`console.log`，`Note not found`，如下所示：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have our `else` clause filled out we can fill out the if statement.
    For this, I''ll print a little message, `console.log (''Note found'')` will get
    the job done. Then we can move on to printing the actual note details, and we
    already have that code in place. We are going to add the hyphenated spacer, then
    we have our note title and our note body as shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经填写了`else`子句，我们可以填写`if`语句。对于这一点，我将打印一条小消息，`console.log ('Note found')`就可以了。然后我们可以继续打印实际的笔记详情，我们已经有了这段代码。我们将添加连字符间隔，然后有我们的笔记标题和笔记正文，如下所示：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we're done with the inside of `app.js`, we can move into the `notes.js`
    file and fill out the `getNote` method because currently it doesn't do anything
    with the title that gets passed in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`app.js`的内部，我们可以进入`notes.js`文件，并填写`getNote`方法，因为目前它没有对传入的标题做任何处理。
- en: 'Inside notes, what you needed to do was fill out those three lines. The first
    one is going to be responsible for fetching the notes. We already have did that
    before with the `fetchNotes` function in the previous section:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在notes中，你需要做的是填写这三行。第一行将负责获取笔记。我们在上一节中已经用`fetchNotes`函数做过了：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have our notes in place we, can call `notes.filter`, returning
    all of the notes. I''ll make a variable called `filteredNotes`, setting it equal
    to `notes.filter`. Now, we know that the filter method takes a function, I''ll
    define an arrow function (`=>`) just like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了笔记，我们可以调用`notes.filter`，返回所有的笔记。我将创建一个名为`filteredNotes`的变量，将其设置为`notes.filter`。现在，我们知道filter方法需要一个函数，我将定义一个箭头函数（`=>`）就像这样：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside the arrow function (`=>`), we''ll get the individual note passed in,
    and we''ll return `true` when the note title, the title of the note we found in
    our JSON file, equals, using triple equals, title:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数（`=>`）中，我们将传入的单个笔记，并在笔记标题，也就是我们在JSON文件中找到的笔记标题，等于标题时返回`true`：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will return `true` when the note title matches and false if it doesn''t.
    Alternatively, we can use arrow functions, and we only have one line, as shown
    following, where we return something; we can cut out our condition, remove the
    curly braces, and simply paste that condition right here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当笔记标题匹配时，这将返回`true`，如果不匹配则返回false。或者，我们可以使用箭头函数，我们只有一行代码，如下所示，我们返回了一些东西；我们可以剪切掉我们的条件，删除大括号，然后简单地将该条件粘贴到这里：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This has the exact same functionality, only it's a lot shorter and easier to
    look at.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有完全相同的功能，只是更短，更容易查看。
- en: 'Now that we have all of the data, all we need to do is return something, and
    we''ll return the first item in the `filteredNotes` array. Next, we''ll grab the
    first item, which is the index of zero, and then we just need to return it using
    the `return` keyword:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了所有的数据，我们只需要返回一些东西，我们将返回`filteredNotes`数组中的第一个项目。接下来，我们将获取第一个项目，也就是索引为零的项目，然后我们只需要使用`return`关键字返回它：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, there is a chance that `filteredNotes`, the first item, doesn't exist,
    and that's fine, it's going to return undefined, in which case our else clause
    will run, printing `Note not found`. If there is a note, great, that's the note
    we want to print, and over in `app.js` we do just that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有可能`filteredNotes`，第一个项目不存在，没关系，它将返回undefined，在这种情况下，我们的else子句将运行，打印`找不到笔记`。如果有笔记，太好了，那就是我们想要打印的笔记，在`app.js`中我们就是这样做的。
- en: Running the getNote function
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行`getNote`函数
- en: 'Now that we have this in place we can test out this brand new functionality
    inside of Terminal by running our app using `node app.js`. I''ll use the `read`
    command, and I''ll pass in a title equal to some string that I know does not exist
    inside of a title in the `notes-data.json` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经准备就绪，我们可以通过在终端中运行我们的应用程序`node app.js`来测试这个全新的功能。我将使用`read`命令，并传入一个标题等于我知道在`notes-data.json`文件中不存在的字符串：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When I run the command, we get `Note not found`, as shown here, and this is
    exactly what we want:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行命令时，我们得到了`找不到笔记`，如图所示，这正是我们想要的：
- en: '![](img/c71ca8b7-a372-46c2-b51c-7dd28adba3ae.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c71ca8b7-a372-46c2-b51c-7dd28adba3ae.png)'
- en: Now, if I do try to fetch a note where the title does exist, I would expect
    that note to come back.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我尝试获取一个标题存在的笔记，我期望那个笔记会返回。
- en: 'In the data file I have a note with a title of `to buy`; let''s try to fetch
    that one. I''ll use the up arrow key to populate the previous command and replace
    the title with `to space`, buy, and hit *enter*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据文件中，我有一个标题为`购买`的笔记；让我们尝试获取它。我将使用上箭头键填充上一个命令，并将标题替换为`to space`，购买，并按*enter*：
- en: '![](img/d887e87f-d094-424d-ba57-b3b072bd79c4.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d887e87f-d094-424d-ba57-b3b072bd79c4.png)'
- en: As shown in the previous code, you can see `Note found` prints to the screen,
    which is fantastic. Following `Note found` we have our spacers and following that
    we have the title, which is `to buy`, and the body, which is `food`, exactly as
    it appears inside of the data file. With this in place, we are done with the `read`
    command.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，您可以看到`找到笔记`打印到屏幕上，这太棒了。在`找到笔记`之后，我们有我们的间隔符，然后是标题`购买`和正文`食物`，正如它出现在数据文件中一样。有了这个，我们就完成了`read`命令。
- en: The DRY principle
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DRY原则
- en: 'Now, there is one more thing I want to tackle before we wrap up this section.
    Inside `app.js` we now have the same code in two places. We have the space or
    title body in the `add` command as well as in the `read` command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们结束本节之前，我还想解决一件事。在`app.js`中，我们现在在两个地方有相同的代码。我们在`add`命令以及`read`命令中都有空格或标题正文：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you find yourself copying and pasting code, it's probably best to break
    that out into a function that both locations call. This is the **DRY principle**,
    which stands for **Don't Repeat Yourself**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现自己在复制和粘贴代码时，最好将其拆分成一个函数，两个位置都调用该函数。这就是**DRY原则**，它代表**不要重复自己**。
- en: Using the logNote function
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用logNote函数
- en: In our case, we are repeating ourselves. It would be best to break this out
    into a function that we can call from both places. In order to do this, all we're
    going to do is make a function in `notes.js` called `logNote`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们在重复自己。最好将其拆分成一个函数，我们可以从两个地方调用它。为了做到这一点，我们要做的就是在`notes.js`中创建一个名为`logNote`的函数。
- en: 'Now, in `notes.js`, down following the `removeNote` function, we can make that
    brand new function a variable called `logNote`. This is going to be a function
    that takes one argument. This argument will be the note object because we want
    to print both the title and the body. As shown here, we''ll expect the note to
    get passed in:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`notes.js`中，在`removeNote`函数下面，我们可以将这个全新的函数命名为`logNote`。这将是一个带有一个参数的函数。这个参数将是笔记对象，因为我们想要打印标题和正文。如下所示，我们期望传入笔记：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, filling out the `logNote` function is going to be really simple, especially
    when you''re solving a DRY issue, because you can simply take the code that''s
    repeated, cut it out, and paste it right inside the `logNote` function. In this
    case the variable names line up already, so there is no need to change anything:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，填写`logNote`函数将会非常简单，特别是当你解决DRY问题时，因为你可以简单地将重复的代码剪切出来，然后粘贴到`logNote`函数中。在这种情况下，变量名已经对齐，所以不需要更改任何内容：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have the `logNote` function in place, we can change things over
    in `app.js`. In `app.js`, where we have removed the `console.log` statements we
    can call `notes.logNote`, passing in the note object just like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`logNote`函数，我们可以在`app.js`中进行更改。在`app.js`中，我们已经删除了`console.log`语句，我们可以调用`notes.logNote`，传入笔记对象就像这样：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And we can do the same thing in case of the `add` command `if` block. I can
    remove these three `console.log` statements and call `notes.logNote`, passing
    in note:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`add`命令的`if`块中也可以做同样的事情。我可以删除这三个`console.log`语句，并调用`notes.logNote`，传入笔记：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And now that we have this in place, we can rerun our program and hopefully what
    we see is the exact same functionality.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这个，我们可以重新运行我们的程序，希望我们看到的是完全相同的功能。
- en: 'The last thing to do before we rerun the program is export the `logNote` function
    in `exports` module in `notes.js` file. `LogNote` is going to get exported and
    we''re using the ES6 syntax to do that:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新运行程序之前要做的最后一件事是在`notes.js`文件的`exports`模块中导出`logNote`函数。`LogNote`将被导出，我们使用ES6语法来做到这一点：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this in place, I can now rerun the previous command from Terminal using
    up and hit *enter*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我现在可以使用上箭头键重新运行Terminal中的上一个命令，然后按*enter*：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/a352534b-7d91-439a-9d9d-720d176e03be.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a352534b-7d91-439a-9d9d-720d176e03be.png)'
- en: 'As shown, we get `Note found` printing to the screen, with the title and the
    body just like we had before. I''m also going to test out the `add` command to
    make sure that one''s working, `node app.js add`; we will use a title of things
    to do and a body of go to post office:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，我们得到`Note found`打印到屏幕上，标题和正文就像以前一样。我还将测试`add`命令，以确保它正常工作，`node app.js add`；我们将使用一个标题`things
    to do`和一个正文`go to post office`：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, when I hit *enter,* we would expect the same log to print as it did before
    for the `add` command, and that''s exactly what we get:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我按下*enter*，我们期望打印的日志与之前的`add`命令一样，这正是我们得到的：
- en: '![](img/058d88e4-cd1f-49f5-8362-7db4eeb504db.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/058d88e4-cd1f-49f5-8362-7db4eeb504db.png)'
- en: Note created prints, we get our spacer, and then we get our title and our body.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记创建后打印，我们得到我们的间隔，然后得到我们的标题和正文。
- en: In the next section, we're going to cover one of the most important topics in
    the book; which is debugging. Knowing how to properly debug programs is going
    to save you literally hundreds of hours over your Node.js career. Debugging can
    be really painful if you don't have the right tools, but once you know how it's
    done, it really isn't that bad and it can save you a ton of time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将涵盖本书中最重要的一个主题；调试。知道如何正确地调试程序将在你的Node.js职业生涯中节省你数百个小时。如果你没有正确的工具，调试可能会非常痛苦，但一旦你知道如何做，它其实并不那么糟糕，而且可以节省你大量的时间。
- en: Debugging
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: In this section, we're going to use the built-in `debugger`, which can look
    a little complex because it's run inside of the command line. That means that
    you have to use the command-line interface, which is not always the most pleasant
    thing to look at. In the next section, though, we are going to be installing a
    third-party tool that uses Chrome DevTools in order to debug your Node app. That
    one looks great because the Chrome DevTools are fantastic.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用内置的`debugger`，这可能看起来有点复杂，因为它在命令行中运行。这意味着你必须使用命令行界面，这并不总是最令人愉快的事情。不过，在下一节中，我们将安装一个使用Chrome
    DevTools来调试你的Node应用程序的第三方工具。这个看起来很棒，因为Chrome DevTools非常出色。
- en: Executing a program in debug mode
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在调试模式下执行程序
- en: 'Before going ahead, we will learn that we do need to create a place to play
    around with debugging and that''s going to happen in a playground file, since
    the code we''re going to write is not going to be important to the `notes` app
    itself. Inside the notes app I''ll make a new file called `debugging.js`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将了解到我们确实需要创建一个调试的地方，这将在一个游乐场文件中进行，因为我们要编写的代码对`notes`应用程序本身并不重要。在notes应用程序中，我将创建一个名为`debugging.js`的新文件：
- en: '![](img/51bbbdae-8ca8-4c1b-b0b4-0daaeafc6ccc.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51bbbdae-8ca8-4c1b-b0b4-0daaeafc6ccc.png)'
- en: 'In `debugging.js` we''re going to start off with a basic example. We''re going
    to make an object called `person`, and on that object for the moment, we''re going
    to set one property name. Set it equal to your name, I''ll set mine equal to the
    string `Andrew` as shown:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`debugging.js`中，我们将从一个基本示例开始。我们将创建一个名为`person`的对象，在该对象上，我们暂时设置一个属性名。将其设置为你的名字，我将我的设置为字符串`Andrew`，如下所示：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next up we''re going to set another property, but in the next line, `person.age`.
    I''ll set mine equal to my age, `25`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将设置另一个属性，但在下一行，`person.age`。我将我的设置为我的年龄，`25`：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we''re going to add another statement that changes the name, `person.name`
    equals something like `Mike`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将添加另一个语句来更改名称，`person.name`等于`Mike`之类的东西：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we''re going to `console.log` the `person` object, the code is going
    to look like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`console.log`打印`person`对象，代码将如下所示：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we actually already have a form of debugging in this example, we have a
    `console.log` statement.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实际上在这个例子中我们已经有了一种调试的形式，我们有一个`console.log`语句。
- en: As you're going through the Node application development process, you may or
    may not have used `console.log` to debug your app. Maybe something's not working
    as expected and you want to figure out exactly what that variable has stored inside
    of it. For example, if you have a function that solves a math problem, maybe at
    one part in the function the equation is wrong and you're getting a different
    result.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行Node应用程序开发过程时，你可能已经使用了`console.log`来调试你的应用程序。也许有些东西不像预期的那样工作，你想准确地弄清楚那个变量里面存储了什么。例如，如果你有一个解决数学问题的函数，也许在函数的某个部分方程式是错误的，你得到了一个不同的结果。
- en: 'Using `console.log` can be a pretty great way to do that, but it''s super limited.
    We can view that by running it from Terminal, I''ll run the following command
    for this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`console.log`可能是一个非常好的方法，但它的功能非常有限。我们可以通过在终端中运行它来查看，我将运行以下命令：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When I run the file, I do get my object printed out to the screen, which is
    great, but, as you know, if you want to debug something besides the `person` object
    you have to add another `console.log` statement in order to do that.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行文件时，我确实可以在屏幕上打印出我的对象，这很好，但是，你知道，如果你想调试除了`person`对象之外的东西，你必须添加另一个`console.log`语句来做到这一点。
- en: Imagine you have something like our `app.js` file, you want to see what command
    equals, then you want to see what `argv` equals, it could take a lot of time to
    add and remove those `console.log` statements. There is a better way to debug.
    This is using the Node `debugger`. Now, before we make any changes to the project,
    we'll take a look at how the `debugger` works inside of Terminal, and as I warned
    you in the beginning of the section, the built-in Node `debugger`, while it is
    effective, is a little ugly and hard to use.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个类似我们的`app.js`文件，你想看看命令等于什么，然后你想看看`argv`等于什么，这可能需要花费很多时间来添加和删除那些`console.log`语句。有一种更好的调试方法。这就是使用Node的`debugger`。现在，在我们对项目进行任何更改之前，我们将看看`debugger`在终端内部是如何工作的，正如我在本节开头警告过你的，内置的Node`debugger`虽然有效，但有点丑陋和难以使用。
- en: 'For now, though, we are going to run the app much the same way, only this time
    we''re going to type `node inspect`. Node debug is going to run our app completely
    differently from the regular Node command. We''re running the same file in the
    playground folder, it''s called `debugging.js`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，现在，我们将以基本相同的方式运行应用程序，只是这一次我们将输入`node inspect`。Node debug将以与常规Node命令完全不同的方式运行我们的应用程序。我们在playground文件夹中运行相同的文件，它叫做`debugging.js`：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When you hit *enter,* you should see something like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下*enter*时，你应该会看到类似这样的东西：
- en: '![](img/00b9dba3-f0b8-4e20-97e1-ea166e26c153.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00b9dba3-f0b8-4e20-97e1-ea166e26c153.png)'
- en: In the output, we can ignore the first two lines. This essentially means that
    the `debugger` was set up correctly and it's able to listen to the app running
    in the background.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以忽略前两行。这基本上意味着`debugger`已经正确设置，并且能够监听后台运行的应用程序。
- en: Next, we have our very first line break in playground debugging on line one,
    and right following to it you can see line one with a little caret (`>`) next
    to it. When you first run your app in debug mode, it pauses before it executes
    the first statement. When we're paused on a line like line one, that means the
    line has not executed, so at this point in time we don't even have the `person`
    variable in place.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在playground调试中有我们的第一个换行符在第一行，紧接着它你可以看到带有一个小尖号（`>`）的第一行。当你首次以调试模式运行你的应用程序时，它会在执行第一条语句之前暂停。当我们暂停在像第一行这样的行上时，这意味着这行还没有执行，所以在这个时间点上我们甚至还没有`person`变量。
- en: Now, as you can see in the preceding code, we haven't returned to the command
    line, Node is still waiting for input, and there are a few different commands
    we can run. For example, we can run `n`, which is short for next. You can type
    `n`, hit *enter*, and this moves on to the next statement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你在前面的代码中所看到的，我们还没有返回到命令行，Node仍在等待输入，我们可以运行一些不同的命令。例如，我们可以运行`n`，它是下一个的缩写。你可以输入`n`，按下*enter*，这会移到下一个语句。
- en: 'The next statement we have, the statement on line one, was executed, so the
    `person` variable does exist. Then I can use `n` again to go to the next statement
    where we declare the `person.name` property, updating it from `Andrew` to `Mike`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有下一条语句，第一行的语句被执行了，所以`person`变量确实存在。然后我可以再次使用`n`去到下一个语句，我们在那里声明`person.name`属性，将它从`Andrew`更新为`Mike`：
- en: '![](img/fd1bc5a0-09f8-4604-9e07-fbe212aaa564.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd1bc5a0-09f8-4604-9e07-fbe212aaa564.png)'
- en: Notice, at this point, age does exist because that line has already been executed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这一点上，年龄确实存在，因为那行已经执行过了。
- en: 'Now, the `n` command goes statement by statement through your entire program.
    If you realize that you don''t want to do that through the whole program, which
    could take a lot of time, you can use `c`. The `c` command is short for **Continue**,
    and that continues to the very end of the program. In the following code, you
    can see our `console.log` statement runs the name `Mike` and the age `25`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`n`命令会逐条执行你的整个程序。如果你意识到你不想在整个程序中这样做，这可能需要花费很多时间，你可以使用`c`。`c`命令是**Continue**的缩写，它会一直执行到程序的最后。在下面的代码中，你可以看到我们的`console.log`语句运行了名字`Mike`和年龄`25`：
- en: '![](img/c1f7b76d-2a2c-4f46-a283-1bcdffed3d5e.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1f7b76d-2a2c-4f46-a283-1bcdffed3d5e.png)'
- en: This is that's a quick example of how to use the `debug` keyword.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用`debug`关键字的一个快速示例。
- en: Now, we actually didn't do any debugging, we just ran through the program since
    it is a little foreign in terms of writing these commands, such as next and continue,
    I decided to do a dry run once with no debugging. You can use *control* + *C*
    to quit the `debugger` and get returned back to Terminal.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实际上并没有进行任何调试，我们只是运行了整个程序，因为在写这些命令时有点陌生，比如下一个和继续，我决定在没有调试的情况下进行一次干运行。你可以使用*control*
    + *C*来退出`debugger`并返回到终端。
- en: I'll use `clear` to clear all the output. Now that we have a basic idea about
    how we can execute the program in `debug` mode, let's take a look at how we can
    actually do some debugging.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`clear`来清除所有输出。现在我们对如何在`debug`模式下执行程序有了一个基本的了解，让我们看看我们实际上如何进行一些调试。
- en: Working with debugging
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试
- en: 'I''ll rerun the program using the up arrow key twice to return to the Node
    `debug` command. Then, I''ll run the program, and I''ll hit next twice, `n` and
    `n`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用上箭头键两次重新运行程序，返回到Node `debug`命令。然后，我将运行程序，并连续按两次`n`，`n`：
- en: '![](img/c6e79c50-ec92-4604-aaf2-8bb7324a6c4b.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6e79c50-ec92-4604-aaf2-8bb7324a6c4b.png)'
- en: 'At this point in time, we are on line seven, that is where the line break currently
    is. From here we can do some debugging using a command called `repl`, which stands
    for **Read Evaluate Print Loop**. The `repl` command, in our case, brings you
    to an entirely separate area of the `debugger`. When you hit it you''re essentially
    in a Node console:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们在第七行，这就是当前的断点所在。从这里，我们可以使用一个叫做`repl`的命令进行一些调试，它代表**读取-求值-打印-循环**。在我们的情况下，`repl`命令会将你带到`debugger`的一个完全独立的区域。当你使用它时，你实际上是在一个Node控制台中：
- en: '![](img/4a4f8fe0-3ae5-422b-b9e0-b3ef0373a2ee.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a4f8fe0-3ae5-422b-b9e0-b3ef0373a2ee.png)'
- en: You can run any Node commands, for example, I can use `console.log` to print
    something like `test`, and test prints up right there.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行任何Node命令，例如，我可以使用`console.log`打印出`test`，然后`test`就会打印出来。
- en: 'I can make a variable `a` that is equal to `1` plus `3`, then I can reference
    `a` and I can see it''s equal to `4` as shown:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以创建一个变量`a`，它等于`1`加`3`，然后我可以引用`a`，我可以看到它等于`4`，如下所示：
- en: '![](img/89f2647e-d2a2-4db7-8a4e-477af5da153a.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89f2647e-d2a2-4db7-8a4e-477af5da153a.png)'
- en: 'More importantly, we have access to the current program as it sits, meaning
    as it was before line seven was executed. We can use this to print out `person`,
    and as shown in the following code, you can see the person''s name is `Andrew`
    because line seven hasn''t executed and the age is `25`, exactly as it appears
    in the program:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们可以访问当前程序的状态，也就是在第七行执行之前的状态。我们可以使用这个来打印出`person`，如下面的代码所示，你可以看到`person`的名字是`Andrew`，因为第七行还没有执行，年龄是`25`，正如程序中显示的那样：
- en: '![](img/73c46dbd-05b6-4ae3-8090-36dfacb44a65.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73c46dbd-05b6-4ae3-8090-36dfacb44a65.png)'
- en: 'This is where debugging gets really useful. Being able to look at the program
    paused at a certain point in time is going to make it really easy to spot errors.
    I could do anything I want, I could print out the `person` name property, and
    that prints `Andrew` to the screen, as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是调试变得非常有用的地方。能够在某个特定时间点暂停程序将使查找错误变得非常容易。我可以做任何我想做的事情，我可以打印出`person`的名字属性，并且它会在屏幕上打印出`Andrew`，如下所示：
- en: '![](img/68dc0572-b480-4158-8214-c1533e556951.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68dc0572-b480-4158-8214-c1533e556951.png)'
- en: Now, once again, we still have this problem. I have to hit next through the
    program. When you have a really long program, there could literally be hundreds
    or thousands of statements that need to run before you get to the point you care
    about. Obviously that is not ideal, so we're going to look at a better way.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还是有这个问题。我必须通过程序按下`next`。当你有一个非常长的程序时，可能需要运行数百或数千个语句，然后才能到达你关心的点。显然这不是理想的，所以我们要找到更好的方法。
- en: Let's quit `repl` using *control* + *C;* now we're back at the `debugger`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用*control* + *C*退出`repl`；现在我们回到了`debugger`。
- en: From here we are going to make a quick change to our application in `debugging.js`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将在`debugging.js`中对我们的应用程序进行快速更改。
- en: 'Let''s say we want to pause line seven between the person age property update
    and the person name property update. In order to pause, what we''re going to do
    is run the statement `debugger`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在第七行暂停，介于`person`年龄属性更新和`person`名字属性更新之间。为了暂停，我们要做的是运行语句`debugger`：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When you have a `debugger` statement exactly like previous, it tells the Node
    `debugger` to stop here, which means instead of using `n` (next) to go statement
    by statement, you can use `c` (continue), which is going to continue until either
    the program exits or it sees one of the `debugger` keywords.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个像之前一样的`debugger`语句时，它告诉Node `debugger`在这里停下，这意味着你可以使用`c`（continue）来继续，而不是使用`n`（next）逐条语句执行，它会一直执行，直到程序退出或者看到一个`debugger`关键字。
- en: 'Now, over in Terminal, we''re going to rerun the program exactly like we did
    before. This time around, instead of hitting `n` twice, we''re going to use `c`
    to continue:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在终端中，我们将重新运行程序，就像之前一样。这一次，我们不会按两次`n`，而是使用`c`来继续：
- en: '![](img/42867c70-090f-49a4-823b-47716d408af2.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42867c70-090f-49a4-823b-47716d408af2.png)'
- en: Now, when we first used `c`, it went to the end of the program, printing out
    our object. This time around it's going to continue until it finds that `debugger`
    keyword.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们第一次使用`c`时，它到达了程序的末尾，打印出了我们的对象。这一次它会继续，直到找到`debugger`关键字。
- en: 'Now, we can use `repl`, access anything we like, for example, `person.age`,
    shown in this code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`repl`，访问任何我们喜欢的东西，例如，`person.age`，如下所示：
- en: '![](img/b03b7fd5-465f-4b47-9ccb-62001d425672.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b03b7fd5-465f-4b47-9ccb-62001d425672.png)'
- en: Once we're done debugging, we can quit and continue through the program. Again,
    we can use *control* + *C* to quit `repl` and the `debugger`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成调试，我们可以退出并继续执行程序。同样，我们可以使用*control* + *C*来退出`repl`和`debugger`。
- en: All real debugging pretty much happens with the `debugger` keyword. You put
    it wherever you want on your program, you run the program in debug mode, eventually
    it gets to the `debugger` keyword and you do something. For example you explore
    some variable values, you run some functions, or you play around with a code to
    find the error. No one really uses `n` to print through the program, finding the
    line that causes the problem. That takes way too much time and it's just not realistic.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的调试基本上都是使用`debugger`关键字。你可以把它放在程序的任何地方，以调试模式运行程序，最终它会到达`debugger`关键字，然后你可以做一些事情。例如，你可以探索一些变量值，运行一些函数，或者玩弄一些代码来找到错误。没有人真的使用`n`来逐行打印程序，找到导致问题的那一行。那太费时间了，而且不现实。
- en: Using debugger inside the notes application
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在笔记应用程序中使用调试器
- en: Now that you know a little bit about the `debugger`, I want you to use it inside
    our notes application. What we will do inside `notes.js` is add the `debugger`
    statement in `logNote` function as the first line of the function. Then I will
    run the program in debug mode, passing in some arguments that will cause `logNote`
    to run; for example, reading a note, after the note gets fetched, it's going to
    call `logNote`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对`debugger`有了一点了解，我希望你在我们的笔记应用内使用它。我们将在`notes.js`内添加`debugger`语句到`logNote`函数的第一行。然后我将以调试模式运行程序，传入一些参数，这些参数将导致`logNote`运行；例如，读取一个笔记，在笔记被获取后，它将调用`logNote`。
- en: Now, once we have the `debugger` keyword in the `logNote` function and run it
    in debug mode with those arguments, the program should stop at this point. Once
    the program starts in debug mode, we'll use `c` to continue, and it'll pause.
    Next, we'll print out the note object and make sure it looks okay. Then, we can
    quit `repl` and quit the `debugger`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们在`logNote`函数中有了`debugger`关键字，并以这些参数在调试模式下运行它，程序应该在这一点停止。一旦程序以调试模式启动，我们将使用`c`来继续，它会暂停。接下来，我们将打印出笔记对象并确保它看起来没问题。然后，我们可以退出`repl`并退出`debugger`。
- en: 'Now, first we are adding the `debugger` statement right here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先我们在这里添加`debugger`语句：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can save the file, and now we can move into Terminal; there's no need to
    do anything else inside our app.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保存文件，现在我们可以进入终端；我们的应用内不需要做其他任何事情。
- en: 'Inside Terminal we''re going to run our `app.js` file, `node debug app.js`,
    because we want to run the program in debug mode. Then we can pass in our arguments,
    let''s say the `read` command, and I''ll pass in a title, `"to buy"` as shown
    here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端内，我们将运行我们的`app.js`文件，`node debug app.js`，因为我们想以调试模式运行程序。然后我们可以传入我们的参数，比如`read`命令，我将传入一个标题，`"to
    buy"`如下所示：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this case I have a note with the title `"to buy"`, as shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我有一个标题为`"to buy"`的笔记，如下所示：
- en: '![](img/8ded8b7f-6a54-4650-bf20-17b3fc935866.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ded8b7f-6a54-4650-bf20-17b3fc935866.png)'
- en: 'Now, when I run the preceding command, it''s going to pause before that first
    statement runs, this is expected:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我运行上述命令时，它会在第一条语句运行之前暂停，这是预期的：
- en: '![](img/f428f4ee-0406-45d7-a64b-7c23b5076cc5.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f428f4ee-0406-45d7-a64b-7c23b5076cc5.png)'
- en: 'I can now use `c` to continue through the program. It''s going to run as many
    statements as it takes for either the program to end or for the `debugger` keyword
    to be found, and as shown in the following code, you can see the `debugger` was
    found and our program has stopped on line `49` of `notes.js`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以使用`c`来继续程序。它会运行尽可能多的语句，直到程序结束或找到`debugger`关键字，如下面的代码所示，你可以看到`debugger`被找到，我们的程序已经停在`notes.js`的第`49`行：
- en: '![](img/bce52bf9-81cc-4761-9e11-b4338313dd2b.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bce52bf9-81cc-4761-9e11-b4338313dd2b.png)'
- en: 'This is exactly what we wanted to do. Now, from here, I''ll go into `repl`
    and print out note argument, and as shown in the following code, you can see we
    have the note with the title of `to buy` and the body `food`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要做的。现在，从这里，我将进入`repl`并打印出笔记参数，如下面的代码所示，你可以看到我们有一个标题为`to buy`和正文为`food`的笔记：
- en: '![](img/8a679110-e8c9-4d36-badb-46050c40e9d9.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a679110-e8c9-4d36-badb-46050c40e9d9.png)'
- en: Now, if there was an error in this statement, maybe the wrong thing was printing
    to the screen, this would give us a pretty good idea as to why. Whatever gets
    passed into the `note` is clearly being used inside of the `console.log` statements,
    so if there was an issue with what's printing, it's most likely an issue with
    what gets passed into the `logNote` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果这个语句出现了错误，也许屏幕上打印了错误的东西，这将给我们一个很好的想法。无论传递给`note`的是什么，显然都被用在`console.log`语句内，所以如果打印出了问题，最有可能是`logNote`函数内传递的问题。
- en: Now that we've printed the `note` variable, we can shut down `repl`, and we
    can use *control* + *C* or `quit` to quit the `debugger`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经打印了`note`变量，我们可以关闭`repl`，我们可以使用*control* + *C*或`quit`来退出`debugger`。
- en: Now we're back at the regular Terminal and we have successfully completed the
    debugging inside the Node application. In the next section, we're going to look
    at a different way to do the same thing, a way with a much nicer graphic user
    interface that I find a lot easier to navigate and use.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到了常规终端，我们已经成功完成了Node应用内的调试。在下一节中，我们将看一种不同的方法来做同样的事情，这种方法有一个更好的图形用户界面，我发现它更容易导航和使用。
- en: Listing notes
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出笔记
- en: Now that we've made some awesome progress on debugging, let's go back to the
    commands for our app, because there is only one more to fill out (we have covered
    the `add`, `read`, and `remove` commands in the [Chapter 3](49575d61-4c77-46aa-89b2-6dc4a771e7a5.xhtml),
    *Node Fundamentals - Part 2*, and this chapter, respectively). It's the `list`
    command, and it's going to be really easy, there is nothing complex going on in
    the case of the `list` command.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在调试方面取得了一些进展，让我们回到我们应用的命令，因为只剩下一个要填写的命令了（我们已经分别在[第3章](49575d61-4c77-46aa-89b2-6dc4a771e7a5.xhtml)、*Node基础知识-第2部分*和本章中涵盖了`add`、`read`和`remove`命令）。这是`list`命令，它将非常容易，`list`命令中没有复杂的情况。
- en: Using the getAll function
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`getAll`函数
- en: In order to get started, all we need to do is fill out the list notes function,
    which in this case we called `getAll`. The `getAll` function is responsible for
    returning every single note. That means it's going to return an array of objects,
    an array of all of our notes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们所需要做的就是填写`list notes`函数，这种情况下我们称之为`getAll`。`getAll`函数负责返回每一个笔记。这意味着它将返回一个对象数组，即我们所有笔记的数组。
- en: 'All we have to do that is to return `fetchNotes`, as shown here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所要做的就是返回`fetchNotes`，如下所示：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's no need to filter, there's no need to manipulate the data, we just need
    to pass the data from `fetchNotes` back through `getAll`. Now that we have this
    in place, we can fill out the functionality over inside of `app.js`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 无需过滤，也无需操作数据，我们只需要将数据从`fetchNotes`传递回`getAll`。现在我们已经做好了这一点，我们可以在`app.js`内填写功能。
- en: 'We have to create a variable where we can store the notes, I was going to call
    it notes, but I probably shouldn''t because we already have a notes variable declared.
    I''ll create another variable, called `allNotes`, setting it equal to the return
    value from `getAll`, which we know because we just filled out returns all the
    notes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建一个变量来存储便签，我本来打算称它为notes，但我可能不应该这样做，因为我们已经声明了一个notes变量。我将创建另一个变量，称为`allNotes`，将其设置为从`getAll`返回的值，我们知道这是因为我们刚刚填写了返回所有便签的内容：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now I can use `console.log` to print a little message and I'll use template
    strings so I can inject the actual number of notes that are going to be printed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以使用`console.log`打印一条小消息，我将使用模板字符串，这样我就可以注入要打印的实际便签数量。
- en: 'Inside the template strings, I''ll add `Printing`, then the number of notes
    using the `$` (dollar) sign and the curly braces, `allNotes.length`: that''s the
    length of the array followed by notes with the `s` in parenthesis to handle both
    singular and plural cases, as shown in the following code block:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板字符串中，我将添加`打印`，然后使用`$`（美元）符号和大括号，`allNotes.length`：这是数组的长度，后跟带有`s`的便签，括号中的`s`用于处理单数和复数情况，如下面的代码块所示：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So, if there were six notes, it would say printing six notes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果有六条便签，它会说打印六条便签。
- en: Now that we have this in place, we have to go about the process of actually
    printing each note, which means we need to call `logNote` once for every item
    in the `allNotes` array. To do, this we'll use `forEach`, which is an array method
    similar to filter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了这个，我们必须继续实际打印每个便签的过程，这意味着我们需要为`allNotes`数组中的每个项目调用`logNote`一次。为此，我们将使用`forEach`，这是一个类似于filter的数组方法。
- en: 'Filter lets you manipulate the array by returning `true` or `false` to keep
    items or remove items; `forEach` simply calls a callback function once for each
    item in the array. In this case we can use it using `allNotes.forEach`, passing
    in a callback function. Now, that callback function will be an arrow function
    (`=>`) in our case, and it will get called with the `note` variable just like
    filter would have. And all we''ll call is `notes.logNote`, passing in the `note`
    argument, which is right here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Filter允许您通过返回`true`或`false`来操作数组以保留项目或删除项目；`forEach`只是为数组中的每个项目调用一次回调函数。在这种情况下，我们可以使用`allNotes.forEach`，传入一个回调函数。现在，该回调函数将是一个箭头函数（`=>`），在我们的情况下，它将被调用`note`变量，就像filter一样。我们将调用`notes.logNote`，传入`note`参数，就像这里一样：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And now that we have this in place, we can actually simplify it by adding the
    `logNote` call, as shown in here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这个，我们可以通过在这里添加`logNote`调用来简化它：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is the exact same functionality, only using the expression syntax. Now
    that we have our arrow function (`=>`) in place, we are calling `notes.logNote`
    once for each item in the all notes array. Let's save the `app.js` file and test
    this out over in Terminal.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是相同的功能，只是使用了表达式语法。现在我们已经有了箭头函数（`=>`），我们正在为所有便签数组中的每个项目调用`notes.logNote`一次。让我们保存`app.js`文件并在终端中测试一下。
- en: 'In order to test out the `list` command, all I''ll use is `node app.js` with
    the command `list`. There is no need to pass in any arguments:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`list`命令，我将使用`node app.js`和`list`命令。不需要传递任何参数：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When I run this, I do get `Printing 3 note(s)` and then I get my `3 notes to
    buy`, `to buy from store`, and `things to do`, as shown in the following code
    output, which is fantastic:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这个程序时，我确实得到了`打印3条便签`，然后我得到了我的`3条购买便签`，`从商店购买`和`要做的事情`，如下面的代码输出所示，这太棒了：
- en: '![](img/ab9b2740-398f-477a-9b8b-1a8401174145.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab9b2740-398f-477a-9b8b-1a8401174145.png)'
- en: With this in place, all of our commands are now working. We can add notes, remove
    notes, read an individual note, and list all of the notes stored in our JSON file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们所有的命令现在都可以工作了。我们可以添加便签，删除便签，阅读单个便签，并列出存储在我们的JSON文件中的所有便签。
- en: Moving on to the next section, I want to clean up some of the commands. Inside
    `app.js` and `notes.js`, we have some `console.log` statements that are printing
    out a few things we no longer need.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我想清理一些命令。在`app.js`和`notes.js`中，我们有一些不再需要的`console.log`语句打印出一些东西。
- en: At the very top of `app.js`, I am going to remove the `console.log('Starting
    app.js')` statement, making the constant `fs` the first line.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`的顶部，我将删除`console.log('Starting app.js')`语句，使常量`fs`成为第一行。
- en: 'I''ll also remove the two statements: `console.log(''Command: '', command)`
    and `console.log(''Yargs'', argv)` that print the command and the `yargs` variable
    value.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '我还将删除两个语句：`console.log(''Command: '', command)`和`console.log(''Yargs'', argv)`，打印命令和`yargs`变量值。'
- en: Inside `notes.js`, I will also remove the `console.log('Stating notes.js')`
    statement at the very top of that file, since it is no longer necessary, putting
    constant `fs` at the top.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在`notes.js`中，我还将删除文件顶部的`console.log('Stating notes.js')`语句，因为它不再需要，将常量`fs`放在顶部。
- en: 'It was definitely useful when we first started exploring different files, but
    now we have everything in place, there''s no need. If I rerun the `list` command,
    this time you can see it looks a lot cleaner:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次开始探索不同的文件时，它绝对是有用的，但现在我们已经把一切都放在了一起，就没有必要了。如果我重新运行`list`命令，这次你可以看到它看起来更整洁了：
- en: '![](img/12afaa90-605a-4d34-b941-7927063c13e9.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12afaa90-605a-4d34-b941-7927063c13e9.png)'
- en: '`Printing three notes` is the very first line showing up. With this in place,
    we have done our commands.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`打印三条便签`是出现的第一行。有了这个，我们已经完成了我们的命令。'
- en: In the next section, we're going to take a slightly more in-depth look at how
    we can configure yargs. This is going to let us require certain arguments for
    our commands. So if someone tries to add a note without a title, we can warn the
    user and prevent the program from executing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将稍微深入地看一下如何配置yargs。这将让我们为我们的命令要求某些参数。因此，如果有人尝试添加一个没有标题的便签，我们可以警告用户并阻止程序执行。
- en: Advanced yargs
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级yargs
- en: 'Before we get into the advanced discussion of yargs, first, I want to pull
    up the yargs docs so that you at least know where the information about yargs
    is coming from. You can get it by Googling `npm yargs`. We''re going to go to
    the yargs package page on npm. This has the documentation for yargs, as shown
    here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论yargs的高级内容之前，首先，我想查看一下yargs文档，这样你至少知道yargs的信息是从哪里来的。你可以通过谷歌搜索`npm yargs`来获取。我们将前往npm上的yargs包页面。这里有yargs的文档，如下所示：
- en: '![](img/cfa2cc27-5a01-4c21-9ddc-2b1843466003.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfa2cc27-5a01-4c21-9ddc-2b1843466003.png)'
- en: Now there is no table of contents for the yargs docs, which makes it kind of
    difficult to navigate. It starts off with some examples that don't go in any particular
    order, and then eventually it gets into a list of all the methods you have available,
    and that's what we're looking for.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在yargs文档没有目录，这使得导航变得有点困难。它以一些没有特定顺序的示例开始，然后最终列出了你可以使用的所有方法，这就是我们要找的。
- en: 'So I''ll use *command* + *F* (*C**trl* + *F*) to search the page for methods,
    and as shown in the following screenshot, we get the methods header, which is
    the one we''re looking for:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我将使用*command* + *F*（*C**trl* + *F*）在页面上搜索方法，如下面的截图所示，我们得到了方法标题，这就是我们要找的：
- en: '![](img/0fa42d20-cec8-46da-b968-6145e2366008.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fa42d20-cec8-46da-b968-6145e2366008.png)'
- en: 'If you scroll down on the page, we start to see an alphabetical list of all
    the methods you have access to inside of yargs. We''re specifically looking for
    `.command`; this is the method we can use to configure all four of our commands:
    the `add`, `read`, `remove` and `list` notes:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在页面上滚动，你会开始看到一个字母顺序的列表，列出了你在yargs中可以访问的所有方法。我们特别寻找`.command`；这是我们可以用来配置我们的四个命令：`add`，`read`，`remove`和`list`
    notes的方法：
- en: '![](img/71cf9523-6b2b-4693-b539-b1fd414e4d7e.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71cf9523-6b2b-4693-b539-b1fd414e4d7e.png)'
- en: We're going to specify which options they require, if any, and we can also set
    up things like descriptions and help functionality.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指定它们需要哪些选项，如果有的话，我们还可以设置描述和帮助功能。
- en: Using chaining syntax on yargs
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在yargs上使用链式语法
- en: Now in order to get started, we need to make some changes inside of `app.js`.
    We're going to start with the `add` command (for more information, please refer
    to the *Adding and saving notes* section in the previous chapter).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了开始，我们需要在`app.js`中进行一些更改。我们将从`add`命令开始（有关更多信息，请参阅上一章节中的*添加和保存笔记*部分）。
- en: 'We want to add a few helpful pieces of information in `argv` function inside
    `app.js`, that will:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在`app.js`中的`argv`函数中添加一些有用的信息，将：
- en: Let yargs verify the `add` command is ran appropriately, and
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让yargs验证`add`命令是否被正确执行，并
- en: Let the user know how the `add` command is meant to be executed
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让用户知道`add`命令应该如何执行
- en: 'Now we are going to be chaining property calls, which means right before I
    access `.argv` I want to call `.command`, and then I''ll call `.argv` on the return
    value from command as shown here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进行属性调用的链式调用，这意味着在访问`.argv`之前，我想调用`.command`，然后我将在命令的返回值上调用`.argv`，如下所示：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now this chaining syntax probably looks familiar if you've used jQuery, a lot
    of different libraries are supported. Once we call `.command` on `yargs`, we're
    going to pass in three arguments.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你使用过jQuery，这种链式语法可能看起来很熟悉，支持许多不同的库。一旦我们在`yargs`上调用`.command`，我们将传入三个参数。
- en: 'The first one is the command name, exactly how the user is going to type it
    in Terminal, in our case it''s going to be `add`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是命令名称，用户在终端中输入的方式，我们的情况下是`add`：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then we''re going to pass another string in, and this is going to be a description
    of what the command does. It is going to be some sort of English readable description
    that a user can read to figure out weather that''s the command that they want
    to run:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将传入另一个字符串，这将是对命令做什么的描述。这将是一种用户可以阅读的英文可读描述，以便用户可以阅读以确定是否是他们想要运行的命令：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The next one is going to be an object. This is going to be the options object
    that lets us specify what arguments this command requires.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的是一个对象。这将是一个选项对象，让我们指定这个命令需要什么参数。
- en: Calling the .help command
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用`.help`命令
- en: 'Now before we get into the options object, let''s add one more call right after
    command. We''re going to call `.help`, which is a method, so we''re going to call
    it as a function, and we don''t need to pass in any arguments:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们进入选项对象之前，让我们在命令之后再添加一个调用。我们将调用`.help`，这是一个方法，所以我们将它作为一个函数调用，我们不需要传入任何参数：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When we add on this help call, it sets up `yargs` to return some really useful
    information when someone runs the program. For example, I can run the `node app.js`
    command with the `help` flag. The `help` flag is added because we called that
    help method, and when I run the program, you can see all of the options we have
    available:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加这个帮助调用时，它设置了`yargs`在有人运行程序时返回一些非常有用的信息。例如，我可以运行`node app.js`命令并带有`help`标志。`help`标志是因为我们调用了那个帮助方法，当我运行程序时，你可以看到我们有哪些可用的选项：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![](img/434e3ad6-3f72-41d2-aa07-ddd4ebd637e0.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/434e3ad6-3f72-41d2-aa07-ddd4ebd637e0.png)'
- en: 'As shown in the preceding output, we have one command, `add Add a new note`,
    and a `help` option for the current command, `help`. And the same thing holds
    true if we run the `node app.js add` command with `help` as shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，我们有一个命令`add Add a new note`，以及当前命令`help`的`help`选项。如果我们运行`node app.js
    add`命令并带有`help`，情况也是如此，如下所示：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this output, we can view all of the options and arguments for `add` command,
    which in this case happens to be none because we haven''t set those up:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，我们可以查看`add`命令的所有选项和参数，这种情况下是没有的，因为我们还没有设置：
- en: '![](img/f2796f89-aa32-4f6e-a12d-f9207cc314c2.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2796f89-aa32-4f6e-a12d-f9207cc314c2.png)'
- en: Adding the options object
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加选项对象
- en: 'Let''s add options and arguments back inside Atom. In order to add properties,
    we''re going to update the options object, where the key is the property name,
    whether it''s title or body, and the value is another object that lets us specify
    how that property should work, as shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Atom中重新添加选项和参数。为了添加属性，我们将更新选项对象，其中键是属性名称，无论是标题还是正文，值是另一个对象，让我们指定该属性应该如何工作，如下所示：
- en: '[PRE53]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Adding the title
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加标题
- en: 'In the case of title, we would add the title on the left-hand side, and we
    would put our options object on the right-hand side. Inside the title, we''re
    going to configure three properties `describe`, `demand`, and `alias`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题的情况下，我们将在左侧添加标题，并在右侧放置我们的选项对象。在标题中，我们将配置三个属性`describe`，`demand`和`alias`：
- en: 'The `describe` property will be set equal to a string, and this is going to
    describe what is supposed to be passed in for the title. In this case, we can
    just use `Title of note`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`属性将被设置为一个字符串，这将描述应该传递给标题的内容。在这种情况下，我们可以使用`Title of note`：'
- en: '[PRE54]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next we configure `demand`. It is going to tell yarg whether or not this argument
    is required. `demand` is `false` by default, we''ll set it to `true`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们配置`demand`。它将告诉yarg这个参数是否是必需的。`demand`默认为`false`，我们将把它设置为`true`：
- en: '[PRE55]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now if someone tries to run the add command without the title, it''s going
    to fail, and we can prove this. We can save `app.js`, and in Terminal, we can
    rerun our previous command removing the `help` flag, and when I do that, you see
    we get a warning, `Missing required argument: title` as shown here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，如果有人尝试运行add命令而没有标题，它将失败，我们可以证明这一点。我们可以保存`app.js`，在终端中，我们可以重新运行我们之前的命令，删除`help`标志，当我这样做时，你会看到一个警告，`Missing
    required argument: title`如下所示：'
- en: '![](img/e05b38db-694f-4630-86cc-911998fa1eed.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e05b38db-694f-4630-86cc-911998fa1eed.png)'
- en: Notice that in the output the title argument, is `Title of note`, which is the
    describe string we used, and it's `required` on the right side, letting you know
    that you have to provide a title when you're calling that `add` command.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在输出中，标题参数是`Title of note`，这是我们使用的描述字符串，并且在右侧是`required`，让您知道在调用`add`命令时必须提供标题。
- en: 'Along with `describe` and `demand` we are going to provide a third option,
    this is called `alias`. The `alias` lets you provide a shortcut so you don''t
    have to type `--title`; you can set the alias equal to a single character like
    `t`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`describe`和`demand`，我们还将提供第三个选项，这称为`alias`。`alias`让您提供一个快捷方式，这样您就不必输入`--title`；您可以将别名设置为单个字符，如`t`：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When you have done that, you can now run the command in Terminal using the new
    syntax.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您现在可以使用新的语法在终端中运行命令。
- en: 'Let''s run our add command, `node app.js add`, instead of `--title`. We''re
    going to use `-t`, which is the flag version, and we can set that equal to whatever
    we like, for example, `flag title` will be the title, and `--body` will get set
    equal to `body` , as shown in the following code. Note that we haven''t set up
    the body argument yet so there is no `alias`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的add命令，`node app.js add`，而不是`--title`。我们将使用`-t`，这是标志版本，我们可以将其设置为任何我们喜欢的值，例如，`flag
    title`将是标题，`--body`将被设置为`body`，如下面的代码所示。请注意，我们还没有设置body参数，所以没有`alias`：
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If I run this command, everything works as expected. The flag title shows up
    right where it should, even though we used the alias version which is the letter
    `t`, as shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我运行这个命令，一切都按预期工作。标志标题出现在应该出现的地方，即使我们使用了字母`t`的别名版本，如下所示：
- en: '![](img/8b0f18d6-ad36-4f2c-be7d-2d5c9acb91fd.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b0f18d6-ad36-4f2c-be7d-2d5c9acb91fd.png)'
- en: Adding the body
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加正文
- en: 'Now that we have our title configured, we can do the exact same thing for the
    body. We''ll specify our options object and provide those three arguments: `describe`,
    `demand`, and `alias` for `body`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了标题，我们可以为正文做完全相同的事情。我们将指定我们的选项对象并提供这三个参数：`describe`，`demand`和`alias`用于`body`：
- en: '[PRE58]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The first one is `describe` and that one''s pretty easy. `describe` is going
    to get set equal to a string, and in this case `Body of note` will get the job
    done:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`describe`，这个很容易。`describe`将被设置为一个字符串，在这种情况下，`Body of note`将完成任务：
- en: '[PRE59]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next one will be `demand`, and to add a note we are going to need a `body`.
    So we''ll set `demand` equal to `true`, just like we do up previous for `title`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`demand`，为了添加一个注释，我们需要一个`body`。所以我们将`demand`设置为`true`，就像我们之前为`title`做的那样：
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And last but not least is the `alias`. The `alias` is going to get set equal
    to a single letter, I''ll use the letter `b` for `body`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是`alias`。`alias`将被设置为一个单个字母，我将使用字母`b`代表`body`：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With this in place, we can now save `app.js` and inside Terminal, we can take
    a moment to rerun `node app.js add` with the `help` flag:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在可以保存`app.js`，在终端中，我们可以花点时间重新运行`node app.js add`，并使用`help`标志：
- en: '[PRE62]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When we run this command, we should now see the body argument showing up, and
    you can even see it shows the flag version, as shown in the following output,
    the alias `-b` (`Body of note`), and it is required:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个命令时，现在应该会看到正文参数出现，甚至可以看到它显示了标志版本，如下面的输出所示，别名`-b`（`Body of note`），并且是必需的：
- en: '![](img/5df5b7cf-c0be-4e87-84d8-ac70849a6b55.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5df5b7cf-c0be-4e87-84d8-ac70849a6b55.png)'
- en: Now I'll run `node app.js add` passing in two arguments `t`. I'll set that equal
    to `t`, and `b` setting it equal to `b`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将运行`node app.js add`，传入两个参数`t`。我将把它设置为`t`，`b`设置为`b`。
- en: 'When I run the command, everything works as expected:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行命令时，一切都按预期工作：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![](img/0dbbc4ca-fc51-4bde-97c4-e6c8fdd70afc.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dbbc4ca-fc51-4bde-97c4-e6c8fdd70afc.png)'
- en: As shown in the preceding output screenshot, a new note was created with a title
    of `t` and a body of `b`. With this in place, we've now successfully completed
    the setup for the `add` command. We have our `add` command title, a description,
    and the block that specifies the arguments for that command. Now we do have three
    more commands to `add` support for, so let's get started doing that.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出截图所示，创建了一个标题为“t”，正文为“b”的新便笺。有了这个设置，我们现在已经成功完成了`add`命令的设置。我们有我们的`add`命令标题，一个描述，以及为该命令指定参数的块。现在我们还有三个命令需要添加支持，所以让我们开始做吧。
- en: Adding support to the read and remove commands
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对读取和删除命令的支持
- en: 'On the next line, I''ll call `.command` again, passing in the command name.
    Let''s do the `list` command first because this one is really easy, no arguments
    are required. Then we''ll pass in the description for the `list` command, `List
    all notes`, as shown here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我将再次调用`.command`，传入命令名称。让我们先执行`list`命令，因为这个命令非常简单，不需要任何参数。然后我们将为`list`命令传入描述，“列出所有便笺”，如下所示：
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next up, we''ll call command again. This time we''ll do the command for `read`.
    The `read` command reads an individual note, so for the description for the `read`
    command, we''ll use something like `Read a note`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将再次调用命令。这次我们将为`read`命令执行命令。`read`命令读取一个单独的便笺，所以对于`read`命令的描述，我们将使用类似“读取便笺”的内容：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now the `read` command does require the title argument. That means we are going
    to need to provide that options object. I''ll take `title` from `add` command,
    copy it, and paste it in the `read` command options object:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`read`命令确实需要标题参数。这意味着我们需要提供该选项对象。我将从`add`命令中取出`title`，复制它，并粘贴到`read`命令的选项对象中：
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you probably just noticed, we have repeated code. The title configuration
    just got copied and pasted into multiple places. It would be pretty nice if this
    was DRY, if it was in one variable we could reference in both locations, in `add`
    and `read` commands.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能刚刚注意到，我们有重复的代码。标题配置刚刚被复制并粘贴到多个位置。如果这是DRY的话，如果它在一个变量中，我们可以在`add`和`read`命令中引用它，那将是非常好的。
- en: 'Will call command for `remove`, just following where we called the command
    for `read`. Now, the `remove` command will have a description. We''ll stick with
    something simple like `Remove a note`, and we will be providing an options object:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`read`命令的地方后面，将调用`remove`命令。现在，`remove`命令将有一个描述。我们将坚持使用一些简单的描述，比如“删除便笺”，并且我们将提供一个选项对象：
- en: '[PRE67]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now I can add the options object identical to the `read` command. However,
    in that options object, I''ll set title equal to `titleOptions`, as shown here,
    to avoid the repetition of code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以添加与`read`命令相同的选项对象。但是，在该选项对象中，我将标题设置为`titleOptions`，如下所示，以避免重复的代码。
- en: '[PRE68]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Adding the titleOption and bodyOption variables
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加`titleOption`和`bodyOption`变量
- en: 'Now I don''t have the `titleOptions` object created yet so the code would currently
    fail, but this is the general idea. We want to create the `titleOptions` object
    once and reference it in all the locations we use it, for `add`, `read` and `remove`
    command. I can take `titleOptions`, and add it for `read` as well as for `add`
    command, as shown here:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我还没有创建`titleOptions`对象，所以代码目前可能会失败，但这是一个一般的想法。我们希望创建`titleOptions`对象一次，并在我们使用它的所有位置，为`add`，`read`和`remove`命令引用它。我可以像这样为`read`和`add`命令添加`titleOptions`：
- en: '[PRE69]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, just previous the constant `argv`, I can create a constant called `titleOptions`,
    and I can set it equal to that object that we defined for `add` and `read` command
    earlier, which is `describe`, `demand`, and `alias`, as shown here:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在常量`argv`之前，我可以创建一个名为`titleOptions`的常量，并将其设置为我们之前为`add`和`read`命令定义的对象，即`describe`，`demand`和`alias`，如下所示：
- en: '[PRE70]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We now have the `titleOptions` in place, and this will work as expected. We
    have the exact same functionality we did before, but we now have the `titleOptions`
    in a separate object, which follows the DRY principle we discussed in the *Reading
    note* section.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`titleOptions`，这将按预期工作。我们拥有了之前完全相同的功能，但是现在我们将`titleOptions`放在了一个单独的对象中，这符合我们在*读取便笺*部分讨论的DRY原则。
- en: 'Now, we could also do the same thing for body. It might seem like overkill
    since we''re only using it in only one location, but if we''re sticking to the
    pattern of breaking them out into variables, I''ll do it in the case of the body
    as well. Just following the `titleOptions` constant, I can create the constant
    `bodyOptions`, setting it equal to the options object we defined in the body,
    for `add` command in the previous subsection:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也可以为正文做同样的事情。这可能看起来有点多余，因为我们只在一个地方使用它，但是如果我们坚持将它们分解成变量，我也会在正文的情况下这样做。在`titleOptions`常量之后，我可以创建一个名为`bodyOptions`的常量，将其设置为我们在前面的小节中为`add`命令定义的正文的选项对象：
- en: '[PRE71]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With this in place, we are now done. We have `add`, `read`, and `remove`, all
    with their arguments set up referencing the `titleObject` and `bodyObject` variables
    defined.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在已经完成了。我们有`add`，`read`和`remove`，所有这些都已经设置好了，引用了`titleObject`和`bodyObject`变量。
- en: Testing the remove command
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试删除命令
- en: 'Let''s test out the `remove` command in Terminal. I''ll list out my notes using
    `node app.js list`, so I can see which notes I have to remove:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端中测试`remove`命令。我将列出我的便笺，使用`node app.js list`，这样我就可以看到我需要删除哪些便笺：
- en: '[PRE72]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![](img/2bf4487f-5b7d-4d4f-a6eb-19ab2a0fd555.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bf4487f-5b7d-4d4f-a6eb-19ab2a0fd555.png)'
- en: 'I''ll `remove` the note with the title `t`, using the `node app.js remove`
    command and our flag `"t"`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`node app.js remove`命令和我们的标志“t”删除标题为“t”的便笺：
- en: '[PRE73]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '![](img/4540ae80-2c61-4d84-a2cb-30b5a8fe6232.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4540ae80-2c61-4d84-a2cb-30b5a8fe6232.png)'
- en: 'We''ll remove the note with the title `t`, and as shown previous, `Note was
    removed` prints to the screen. And if I use the up arrow key twice, I can list
    the notes out again, and you can see the note with the title `t` has indeed gone:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将删除标题为“t”的便笺，如前所示，“便笺已删除”将打印到屏幕上。如果我两次使用上箭头键，我可以再次列出便笺，你会看到标题为“t”的便笺确实已经消失了：
- en: '![](img/b79cac11-3635-4122-a919-4a842125edeb.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b79cac11-3635-4122-a919-4a842125edeb.png)'
- en: 'Let''s remove one more note using the `node app.js remove` command. This time
    we''re going to use `--title`, which is the argument name, and the note we''re
    going to `remove` has the title flag title, as shown in this code:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`node app.js remove`命令再删除一条笔记。这次我们将使用`--title`，这是参数名，我们要`remove`的笔记具有标题标志标题，如下所示：
- en: '![](img/9ccc0a26-890f-4448-935f-c49832287ed3.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ccc0a26-890f-4448-935f-c49832287ed3.png)'
- en: 'When I remove it, it says `Note was removed`, and if I rerun the `list` command,
    I can see that we have three notes left, the note was indeed removed , as shown
    here:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当我删除它时，它会显示`Note was removed`，如果我重新运行`list`命令，我可以看到我们还剩下三条笔记，笔记确实被删除了，如下所示：
- en: '![](img/9ab2a505-caa3-4651-8b78-1e9175c1d94e.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ab2a505-caa3-4651-8b78-1e9175c1d94e.png)'
- en: And that is it for the notes application.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是笔记应用程序的全部内容。
- en: Arrow functions
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: In this section, you're going to learn the ins and outs of the arrow function.
    It's an ES6 feature, and we have taken a little look at it. Inside `notes.js`
    we used it in a few basic examples to create methods such as `fetchNotes` and
    `saveNotes`, and we also passed it into a few array methods like filter, and for
    each array, we used it as the callback function that gets called once for every
    item in the array.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习箭头函数的各个方面。这是一个ES6功能，我们已经稍微了解了一下。在`notes.js`中，我们在一些基本示例中使用它来创建方法，比如`fetchNotes`和`saveNotes`，我们还将它传递给一些数组方法，比如filter，对于每个数组，我们将它用作在数组中的每个项目上调用的回调函数。
- en: Now if you try to swap out all of the functions in a program with arrow functions,
    it's most likely not going to work as expected because there are some differences
    between the two, and it's really important to know what those differences are,
    so you can make the decision to use a regular ES5 function or an ES6 arrow function.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试用箭头函数替换程序中的所有函数，很可能不会按预期工作，因为两者之间存在一些差异，了解这些差异非常重要，这样你就可以决定使用常规的ES5函数还是ES6箭头函数。
- en: Using the arrow function
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用箭头函数
- en: 'The goal in this section is to give you the knowledge to make that choice,
    and we''ll kick things off by creating a new file in the playground folder called
    `arrow-function.js`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是为您提供知识，以便做出选择，我们将通过在playground文件夹中创建一个名为`arrow-function.js`的新文件来开始：
- en: '![](img/731e0521-5df6-436a-856b-d3f92a53017c.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/731e0521-5df6-436a-856b-d3f92a53017c.png)'
- en: Inside this file, we're going to play around with a few examples, going over
    some of the subtleties to the arrow function. Before we type anything inside of
    the file, I'll start up this file with `nodemon`, so every time we make a change
    it automatically refreshes over in Terminal.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们将玩几个例子，讨论箭头函数的一些微妙之处。在文件内输入任何内容之前，我将用`nodemon`启动这个文件，这样每次我们做出更改时，它都会自动在终端中刷新。
- en: 'If you remember, `nodemon` is the utility we installed in [Chapter 2](9e56dc82-3ad8-4376-81b7-27ba482bd4e2.xhtml),
    *Node Fundamentals - Part 1.* It was a global npm module. The `nodemon` is the
    command to run, and then we just pass in the file path like we would for any other
    Node command. As we''re going into the `playground` folder, and the file itself
    is called `arrow-function.js`, we''ll run the following command:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，`nodemon`是我们在[第2章](9e56dc82-3ad8-4376-81b7-27ba482bd4e2.xhtml)中安装的实用程序，*Node基础知识-第1部分*。它是一个全局的npm模块。`nodemon`是要运行的命令，然后我们只需像对待其他Node命令一样传入文件路径。因为我们要进入`playground`文件夹，文件本身叫做`arrow-function.js`，我们将运行以下命令：
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We''ll run the file, and nothing prints to the screen, as shown in the following
    output, besides the `nodemon` logs because we have nothing in the file:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行文件，除了`nodemon`日志之外，屏幕上什么都不会打印，如下所示：
- en: '![](img/c1e3be5f-d576-45bd-a62a-b67383e2ccc7.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1e3be5f-d576-45bd-a62a-b67383e2ccc7.png)'
- en: To get started, in the `arrowfunction.js` file, we'll create a function called
    square, by making a variable called square and setting it equal to an arrow function.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，在`arrowfunction.js`文件中，我们将创建一个名为square的函数，通过创建一个名为square的变量并将其设置为箭头函数。
- en: To make our arrow function (`=>`), we'll first provide the arguments inside
    parentheses. Since we'll be squaring a number, we just need one number, and I'll
    refer to that number as `x`. If I pass in 3, I should expect 9 back, and if I
    pass in 9, I would expect 81 back.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的箭头函数(`=>`)，我们首先要在括号内提供参数。因为我们将对一个数字进行平方，所以我们只需要一个数字，我将把这个数字称为`x`。如果我传入3，我应该期望得到9，如果我传入9，我会期望得到81。
- en: 'After the arguments list, we have to put the arrow in arrow function (`=>`)
    by putting the equal sign and the greater than symbol together, creating our nice
    little arrow. From here we can provide, inside curly braces, all the statements
    we want to execute:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数列表之后，我们必须通过将等号和大于号放在一起来放置箭头函数(`=>`)，创建我们漂亮的小箭头。从这里开始，我们可以在花括号内提供我们想要执行的所有语句：
- en: '[PRE75]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we might create a variable called result, setting that equal to `x` times
    `x`, then we might return the result variable using the `return` keyword, as shown
    here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可能会创建一个名为result的变量，将其设置为`x`乘以`x`，然后我们可能会使用`return`关键字返回结果变量，如下所示：
- en: '[PRE76]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, obviously this can be done on one line, but the goal here is to illustrate
    that when you use the statement arrow function (`=>`), you can put as many lines
    as you want in between those curly braces. Let''s call a square, we''ll do that
    using `console.log` so we can print the result to the screen. I''ll call square;
    and we''ll call square with `9`, the square of `9` would be `81`, so we would
    expect `81` to print to the screen:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，显然这可以在一行上完成，但这里的目标是说明当你使用语句箭头函数(`=>`)时，你可以在这些花括号之间放置任意多的行。让我们调用一个平方，我们将使用`console.log`来做到这一点，这样我们就可以将结果打印到屏幕上。我会调用square；我们将用`9`调用square，`9`的平方将是`81`，所以我们期望`81`打印到屏幕上：
- en: '[PRE77]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'I''ll save the arrow function (`=>`) file, and in Terminal, `81` shows up just
    as we expect:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我会保存箭头函数(`=>`)文件，在终端中，`81`就像我们预期的那样显示出来：
- en: '![](img/21b9f647-5348-4b3a-83a5-ab26497ff142.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21b9f647-5348-4b3a-83a5-ab26497ff142.png)'
- en: 'Now the syntax we used in the previous example is the statement syntax for
    the arrow function (`=>`). We''ve also explored the expression syntax earlier,
    which lets you simplify your arrow functions when you return some expressions.
    In this case all we need to do is specify the expression we want to return. In
    our case that''s `x` times `x`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在之前的例子中使用的语法是箭头函数(`=>`)的语句语法。我们之前也探讨了表达式语法，它让你在返回一些表达式时简化你的箭头函数。在这种情况下，我们只需要指定我们想要返回的表达式。在我们的例子中，就是`x`乘以`x`：
- en: '[PRE78]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You don't need to explicitly add the `return` keyword. When you use an arrow
    function (`=>`) without your curly braces, it's implicitly provided for you. That
    means we can save the function as shown previous and the exact same result is
    going to print to the screen, `81` shows up.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要显式添加`return`关键字。当你使用不带大括号的箭头函数(`=>`)时，它会隐式地为你提供。这意味着我们可以保存之前显示的函数，完全相同的结果会打印到屏幕上，`81`出现。
- en: This is one of the great advantages of arrow functions when you use them in
    cases like filter or for those which we did in the `notes.js` file. It lets you
    simplify your code keeping everything on one line and making your code a lot easier
    to maintain and scan.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这是箭头函数的一个巨大优势，当你在`notes.js`文件中使用它们时。它让你简化你的代码，保持一行，使你的代码更容易维护和扫描。
- en: 'Now, there is one thing I want to note: when you have an arrow function (`=>`)
    that has just one argument, you can actually leave off the parentheses. If you
    have two or more arguments, or you have zero arguments, you are going to need
    to provide the parentheses, but if you just have one argument, you can reference
    it with no parentheses.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一件事我想指出：当你有一个只有一个参数的箭头函数(`=>`)时，你实际上可以省略括号。如果你有两个或更多的参数，或者你有零个参数，你需要提供括号，但如果你只有一个参数，你可以不用括号引用它。
- en: 'If I save the file in this state, `81` still prints to the screen; and this
    is great we have an even simpler version of our arrow function (`=>`):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我以这种状态保存文件，`81`仍然打印到屏幕上；这很好，我们有一个更简单的箭头函数(`=>`)版本：
- en: '![](img/f4e2555c-6985-440b-aa58-d124742921da.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4e2555c-6985-440b-aa58-d124742921da.png)'
- en: Now that we have a basic example down, I want to move on to a more complex example
    that's going to explore the nuances between regular functions and arrow functions.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个基本的例子，我想继续进行一个更复杂的例子，探讨常规函数和箭头函数之间的细微差别。
- en: Exploring the difference between regular and arrow functions
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索常规函数和箭头函数之间的差异
- en: 'To illustrate the difference, I''ll make a variable called `user`, which will
    be an object. On this object we''ll specify one property, name. Set name equal
    to the string, your name, in this case I''ll set it equal to the string `Andrew`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明区别，我会创建一个名为`user`的变量，它将是一个对象。在这个对象上，我们会指定一个属性，名字。将名字设置为字符串，你的名字，在这种情况下我会将其设置为字符串`Andrew`：
- en: '[PRE79]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then we can define a method on the `user` object. Right after name, with my
    comma at the end of the line, I''ll provide the method `sayHi`, setting it equal
    to an arrow function (`=>`) that doesn''t take any arguments. For the moment,
    we''ll keep the arrow function really simple:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在`user`对象上定义一个方法。在名字后面，我在行末加上逗号，我会提供方法`sayHi`，将其设置为一个不带任何参数的箭头函数(`=>`)。暂时，我们会让箭头函数非常简单：
- en: '[PRE80]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'All we''ll do inside `sayHi` is use `console.log` to print to the screen, inside
    of template strings `Hi`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sayHi`里我们要做的就是使用`console.log`打印到屏幕上，在模板字符串里是`Hi`：
- en: '[PRE81]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We''re not using template strings yet, but we will later so I''ll use them
    here. Down following the user object, we can test out `sayHi` by calling it, `user.sayHi`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有使用模板字符串，但我们以后会使用，所以我会在这里使用它们。在用户对象之后，我们可以通过调用它来测试`sayHi`，`user.sayHi`：
- en: '[PRE82]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: I'll call it then save the file, and we would expect that `Hi` prints to the
    screen because all our arrow function (`=>`) does is use `console.log` to print
    a static string. Nothing in this case will cause any problems; you'd be able to
    swap out a regular function for an arrow function (`=>`) without issue.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我会称之为然后保存文件，我们期望`Hi`打印到屏幕上，因为我们的箭头函数(`=>`)只是使用`console.log`打印一个静态字符串。在这种情况下，没有任何问题；你可以毫无问题地用箭头函数(`=>`)替换常规函数。
- en: Now the first issue that will arise when you use arrow functions is the fact
    that arrow functions do not bind a `this` keyword. So if you are using `this`
    inside your function, it's not going to work when you swap it out for an arrow
    function (`=>`). Now, `this` binding; refers to the parent binding, in our case
    there is no parent, function so this would refer to the global `this` keyword.
    Now we have our `console.log` that does not use `this`, I'll swap it out for a
    case that does.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用箭头函数时，首先会出现的问题是箭头函数不会绑定`this`关键字。所以如果你在函数内部使用`this`，当你用箭头函数(`=>`)替换它时，它不会起作用。现在，`this`绑定；指的是父绑定，在我们的例子中没有父函数，所以这将指向全局的`this`关键字。现在我们的`console.log`不使用`this`，我会用一个使用`this`的情况来替换它。
- en: 'We''ll put a period after `Hi`, and I''ll say I''m, followed by the name, which
    we would usually be able to access via `this.name`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在`Hi`后面加一个句号，然后我会说我是，接着是名字，通常我们可以通过`this.name`来访问：
- en: '[PRE83]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If I try to run this code, it is not going to work as expected; we''re going
    to get `Hi` I''m undefined printing to the screen, as shown here:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我尝试运行这段代码，它不会按预期工作；我们会得到`Hi` I'm undefined打印到屏幕上，如下所示：
- en: '![](img/eea15eba-3a6d-405a-a3a1-b431034523b1.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eea15eba-3a6d-405a-a3a1-b431034523b1.png)'
- en: In order to fix this, we'll look at an alternative syntax to arrow functions
    that's great when you're defining object literals, as we are in this case.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将看一种替代箭头函数的语法，当你定义对象字面量时非常好用，就像我们在这个例子中所做的那样。
- en: 'After `sayHi`, I''ll make a new method called `sayHiAlt` using a different
    ES6 feature. ES6 provides us a new way to make methods on objects; you provide
    the method name, `sayHiAlt`, then you go right to the parentheses skipping the
    colon. There''s also no need for the function keyword, even though it is a regular
    function it''s not an arrow function (`=>`). Then we move on to our curly braces
    as shown here:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sayHi`之后，我将使用不同的ES6特性创建一个名为`sayHiAlt`的新方法。ES6为我们提供了一种在对象上创建方法的新方式；你提供方法名`sayHiAlt`，然后直接跳过冒号到括号。虽然它是一个常规函数，但不是箭头函数(`=>`)，所以也不需要函数关键字。然后我们继续到大括号，如下所示：
- en: '[PRE84]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Inside here I can have the exact same code we have in the `sayHi` function,
    but it is going to work as expected. It''s going to print `Hi. I''m Andrew`. I''ll
    call `sayHiAlt` down following instead of the regular `sayHi` method:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我可以有与`sayHi`函数中完全相同的代码，但它将按预期工作。它将打印`Hi. I'm Andrew`。我将在下面调用`sayHiAlt`而不是常规的`sayHi`方法：
- en: '[PRE85]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And in Terminal, you can see `Hi. I''m Andrew`, prints to the screen:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，你可以看到`Hi. I'm Andrew`打印到屏幕上：
- en: '![](img/690bbd43-6d64-4e48-899b-331536c9c9ed.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](img/690bbd43-6d64-4e48-899b-331536c9c9ed.png)'
- en: The `sayHiAlt` syntax is a syntax that you can use to solve `this` problem when
    you create functions on object literals. Now that we know that the `this` keyword
    does not get bound, let's explore one other quirk that arrow functions have, it
    also does not bind the arguments array.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHiAlt`语法是一种可以解决在对象字面量上创建函数时的`this`问题的语法。现在我们知道`this`关键字不会被绑定，让我们探索箭头函数的另一个怪癖，它也不会绑定参数数组。'
- en: Exploring the arguments array
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索参数数组
- en: 'Regular functions, like `sayHiAlt`, are going to have an arguments array that''s
    accessible inside of the function:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 常规函数，比如`sayHiAlt`，将在函数内部有一个可访问的参数数组：
- en: '[PRE86]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, it''s not an actual array, it''s more like an object with array; like
    properties, but the arguments object is indeed specified in a regular function.
    If I pass in one, two, and three and save the file, we''ll get that back when
    we log out arguments:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它不是一个实际的数组，更像是一个带有数组属性的对象；但是arguments对象确实在常规函数中指定。如果我传入1、2和3并保存文件，当我们记录arguments时，我们将得到它：
- en: '[PRE87]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Inside `nodemon`, it''s taking a quick second to restart, and right here we
    have our object:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在`nodemon`中，它需要快速重启，然后我们有我们的对象：
- en: '![](img/4603b24b-4f41-4e9d-8a4d-cb511609093d.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4603b24b-4f41-4e9d-8a4d-cb511609093d.png)'
- en: We have one, two, and three, we have the index for each as the property name,
    and this works because we're using a regular function. If we were to switch to
    the arrow function (`=>`) though, it is not going to work as expected.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有1、2和3，我们为每个属性名有索引，这是因为我们使用了常规函数。但是，如果我们切换到箭头函数(`=>`)，它将不会按预期工作。
- en: 'I''ll add `console.log(arguments)` inside of my arrow function (`=>`), and
    I''ll switch from calling `sayHiAlt` back to the original method `sayHi`, as shown
    here:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在我的箭头函数(`=>`)中添加`console.log(arguments)`，并切换回调用`sayHiAlt`到原始方法`sayHi`，如下所示：
- en: '[PRE88]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'When I save the file in `arrow-function.js`, we''ll get something a lot different
    from what we had before. What we''ll actually get is the global arguments variable,
    which is the arguments variable for that wrapper function we explored:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当我保存在`arrow-function.js`文件中时，我们将得到与之前完全不同的东西。实际上我们将得到全局的arguments变量，这是我们探索的包装函数的arguments变量：
- en: '![](img/8d461c97-44a0-4def-937b-aa71b6da1349.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d461c97-44a0-4def-937b-aa71b6da1349.png)'
- en: In the previous screenshot, we have things like the require function, definition,
    our modules object, and a couple of string paths to the file and to the current
    directory. These are obviously not what we're expecting, and that is another thing
    that you have to be aware of when you're using arrow functions; you're not going
    to get the `arguments` keyword, you're not going to get the `this` binding (defined
    in `sayHi` syntax) that you'd expect.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的截图中，我们有像require函数、定义、我们的模块对象和一些字符串路径到文件和当前目录的东西。显然这不是我们期望的，这是你在使用箭头函数时必须注意的另一件事；你不会得到`arguments`关键字，你也不会得到你期望的`this`绑定（在`sayHi`语法中定义）。
- en: These problems mostly arise when you try to create methods on an object and
    use arrow functions. I would highly recommend that you switch to `sayHiAlt` syntax
    which we discussed, in those cases. You get a simplified syntax, but you also
    get the disk binding and you get your arguments variable as you'd expect.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题主要出现在你尝试在对象上创建方法并使用箭头函数时。在这种情况下，我强烈建议你切换到我们讨论的`sayHiAlt`语法。你会得到一个简化的语法，但你也会得到`this`绑定和你期望的arguments变量。
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we were able to reuse the utility functions that we already
    made in previous chapters, making the process of filling out a remove note that
    much easier. Inside `app.js`, we worked on how the `removeNote` function is executed,
    if it was executed successfully, we print a message; if it didn't, we print a
    different message.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们能够重用我们在之前章节中已经创建的实用函数，使填写删除笔记的过程变得更加容易。在`app.js`中，我们处理了`removeNote`函数的执行，如果成功执行，我们打印一条消息；如果没有，我们打印另一条消息。
- en: Next, we were able to successfully fill out the `read` command and we also created
    a really cool utility function that we can take advantage of in multiple places.
    This keeps our code DRY and prevents us from having the same code in multiple
    places inside of our application.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们成功填写了`read`命令，并创建了一个非常酷的实用函数，我们可以在多个地方利用它。这使我们的代码保持干净，并防止我们在应用程序内的多个地方重复相同的代码。
- en: Then we discussed a quick introduction to debugging. Essentially, debugging
    is a process that lets you stop the program at any point in time and play around
    with the program as it exists at that moment. That means you can play around with
    variables that exist, or functions, or anything inside of Node. We learned more
    about yargs, its configuration, setting up commands, their description, and arguments.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了一下快速调试的简介。基本上，调试是一个让你可以在任何时间点停止程序并玩弄程序的过程。这意味着你可以玩弄存在的变量、函数或者 Node 内部的任何东西。我们更多地了解了
    yargs，它的配置，设置命令，它们的描述和参数。
- en: Last, you explored a little bit more about arrow functions, how they work, when
    to use them, and when not to use them. In general, if you don't need this keyword,
    or the arguments keyword you can use an arrow function without a problem, and
    I always prefer using arrow functions over regular functions when I can.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你更多地探索了箭头函数，它们的工作原理，何时使用它们，何时不使用它们。一般来说，如果你不需要 this 关键字或者 arguments 关键字，你可以毫无问题地使用箭头函数，我总是更喜欢在可以的时候使用箭头函数而不是普通函数。
- en: In the next chapter, we will explore asynchronous programming and how we can
    fetch data from third-party APIs. We'll use both regular functions and arrow functions
    a lot more, and you'll be able to see firsthand how to choose between one over
    the other.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨异步编程以及如何从第三方 API 获取数据。我们将更多地使用普通函数和箭头函数，你将能够第一手看到如何在两者之间进行选择。
