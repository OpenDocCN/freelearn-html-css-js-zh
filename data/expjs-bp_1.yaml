- en: Chapter 1. Building a Basic Express Site
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 构建一个基本的Express网站
- en: Express is a web development framework for Node.js. Node.js is an open source,
    cross-platform runtime environment for server-side and networking applications.
    It uses Google Chrome's JavaScript engine, V8, to execute code. Node.js is single-threaded
    and event-driven. It uses non-blocking I/O to squeeze every ounce of processing
    power out of the CPU. Express builds on top of Node.js, providing all of the tools
    necessary to develop robust web applications with node.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Express是Node.js的Web开发框架。Node.js是一个开源的、跨平台的运行时环境，用于服务器端和网络应用程序。它使用Google Chrome的JavaScript引擎V8来执行代码。Node.js是单线程和事件驱动的。它使用非阻塞I/O来榨取CPU的每一分处理能力。Express建立在Node.js之上，提供了开发健壮Web应用程序所需的所有工具。
- en: 'In addition, by utilizing Express, one gains access to a host of open source
    software to help solve common pain points in development. The framework is unopinionated,
    meaning it does not guide you one way or the other in terms of implementation
    or interface. Because it is unopinionated, the developer has more control and
    can use the framework to accomplish nearly any task; however, the power Express
    offers is easily abused. In this book, you will learn how to use the framework
    in the right way by exploring the following different styles of an application:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过使用Express，你可以访问大量的开源软件来帮助解决开发中的常见痛点。该框架是中立的，这意味着它不会在实现或接口方面引导你走向一个方向或另一个方向。因为它是不偏不倚的，开发者有更多的控制权，可以使用该框架完成几乎任何任务；然而，Express提供的功能很容易被滥用。在这本书中，你将通过探索以下不同风格的应用程序来学习如何正确使用该框架：
- en: Setting up Express for a static site
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为静态网站设置Express
- en: Local user authentication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地用户身份验证
- en: OAuth with passport
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth与护照
- en: Profile pages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人资料页面
- en: Testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Setting up Express for a static site
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为静态网站设置Express
- en: 'To get our feet wet, we''ll first go over how to respond to basic HTTP requests.
    In this example, we will handle several `GET` requests, responding first with
    plaintext and then with static HTML. However, before we get started, you must
    install two essential tools: node and npm, which is the node package manager.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们熟悉环境，我们首先会讲解如何响应基本的HTTP请求。在这个例子中，我们将处理几个`GET`请求，首先以纯文本形式响应，然后以静态HTML响应。然而，在我们开始之前，你必须安装两个基本工具：node和npm，即node包管理器。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Navigate to [https://nodejs.org/download/](https://nodejs.org/download/) to
    install node and npm.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到[https://nodejs.org/download/](https://nodejs.org/download/)来安装node和npm。
- en: Saying Hello, World in Express
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Express中使用Hello, World
- en: 'For those unfamiliar with Express, we will start with a basic example—Hello
    World! We''ll start with an empty directory. As with any Node.js project, we will
    run the following code to generate our `package.json` file, which keeps track
    of metadata about the project, such as dependencies, scripts, licenses, and even
    where the code is hosted:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉Express的人来说，我们将从一个基本的例子开始——Hello World！我们将从一个空目录开始。与任何Node.js项目一样，我们将运行以下代码来生成我们的`package.json`文件，该文件跟踪有关项目元数据的信息，例如依赖项、脚本、许可证，甚至代码托管的位置：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `package.json` file keeps track of all of our dependencies so that we don't
    have versioning issues, don't have to include dependencies with our code, and
    can deploy fearlessly. You will be prompted with a few questions. Choose the defaults
    for all except the entry point, which you should set to `server.js`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件跟踪我们所有的依赖项，这样我们就不需要处理版本问题，不需要将依赖项包含在我们的代码中，并且可以无畏地部署。你将收到几个问题提示。除了入口点外，所有默认值都可以选择，你应该将其设置为`server.js`。'
- en: 'There are many generators out there that can help you generate new Express
    applications, but we''ll create the skeleton this time around. Let''s install
    Express. To install a module, we use `npm` to install the package. We use the
    `--save` flag to tell npm to add the dependency to our `package.json` file; that
    way, we don''t need to commit our dependencies to the source control. We can just
    install them based on the contents of the `package.json` file (npm makes this
    easy):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多生成器可以帮助你生成新的Express应用程序，但这次我们将自己创建框架。让我们安装Express。要安装一个模块，我们使用`npm`来安装包。我们使用`--save`标志来告诉npm将依赖项添加到我们的`package.json`文件中；这样，我们就不需要将依赖项提交到源代码控制中。我们可以根据`package.json`文件的内容安装它们（npm使这变得很容易）：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We'll be using Express v4.4.0 throughout this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用Express v4.4.0。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Warning: Express v4.x is not backwards compatible with the versions before
    it.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：Express v4.x与其之前的版本不向后兼容。
- en: 'You can create a new file `server.js` as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个新的文件`server.js`，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This file is the entry point for our application. It is here that we generate
    an application, register routes, and finally listen for incoming requests on port
    `3000`. The `require('express')` method returns a generator of applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是应用程序的入口点。在这里，我们生成应用程序，注册路由，并最终在端口 `3000` 上监听传入的请求。`require('express')` 方法返回一个应用程序生成器。
- en: We can continually create as many applications as we want; in this case, we
    only created one, which we assigned to the variable `app`. Next, we register a
    `GET` route that listens for `GET` requests on the server root, and when requested,
    sends the string `'Hello, World'` to the client. Express has methods for all of
    the HTTP verbs, so we could have also done `app.post`, `app.put`, `app.delete`,
    or even `app.all`, which responds to all HTTP verbs. Finally, we start the app
    listening on port `3000`, then log to standard out.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不断地创建尽可能多的应用程序；在这种情况下，我们只创建了一个，并将其分配给变量 `app`。接下来，我们注册一个 `GET` 路由，该路由监听服务器根目录上的
    `GET` 请求，并在请求时向客户端发送字符串 `'Hello, World'`。Express 有所有 HTTP 动词的方法，所以我们也可以做 `app.post`、`app.put`、`app.delete`
    或甚至 `app.all`，它响应所有 HTTP 动词。最后，我们启动应用程序监听端口 `3000`，然后记录到标准输出。
- en: It's finally time to start our server and make sure everything works as expected.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候启动我们的服务器并确保一切按预期工作。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can validate that everything is working by navigating to `http://localhost:3000`
    in our browser or `curl -v localhost:3000` in your terminal.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在浏览器中导航到 `http://localhost:3000` 或在终端中执行 `curl -v localhost:3000` 来验证一切是否正常工作。
- en: Jade templating
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jade 模板
- en: We are now going to extract the HTML we send to the client into a separate template.
    After all, it would be quite difficult to render full HTML pages simply by using
    `res.send`. To accomplish this, we will use a templating language frequently in
    conjunction with `Express -- jade`. There are many templating languages that you
    can use with Express. We chose Jade because it greatly simplifies writing HTML
    and was created by the same developer of the Express framework.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把发送给客户端的 HTML 提取到一个单独的模板中。毕竟，仅仅通过使用 `res.send` 来渲染完整的 HTML 页面会相当困难。为了实现这一点，我们将使用与
    `Express` 配合频繁使用的模板语言——Jade。你可以使用许多模板语言与 Express 一起使用。我们选择 Jade，因为它极大地简化了 HTML
    的编写，并且是由 Express 框架的同一开发者创建的。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After installing Jade, we''re going to have to add the following code to `server.js`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Jade 后，我们必须将以下代码添加到 `server.js` 中：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code sets the default view engine for Express—sort of like telling
    Express that in the future it should assume that, unless otherwise specified,
    templates are in the Jade templating language. Calling `app.set` sets a key value
    pair for Express internals. You can think of this sort of application like wide
    configuration. We could call `app.get` (view engine) to retrieve our set value
    at any time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码为 Express 设置了默认视图引擎——有点像告诉 Express，在未来，除非有其他指定，否则应该假设模板位于 Jade 模板语言中。调用
    `app.set` 为 Express 内部设置一个键值对。你可以将这种应用程序视为宽配置。我们可以随时调用 `app.get`（视图引擎）来检索我们设置的值。
- en: 'We also specify the folder that Express should look into to find view files.
    That means we should create a `views` directory in our application and add a file,
    `index.jade` to it. Alternatively, if you want to include many different template
    types, you could execute the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了 Express 应该查找以找到视图文件的文件夹。这意味着我们应该在我们的应用程序中创建一个 `views` 目录，并向其中添加一个文件，`index.jade`。或者，如果你想包含许多不同的模板类型，你可以执行以下操作：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we set custom template rendering based on the extension of the template
    we want to render. We use the Jade renderer for `.jade` extensions and the `ejs`
    renderer for `.html` extensions and expose both of our index files by different
    routes. This is useful if you choose one templating option and later want to switch
    to a new one in an incremental way. You can refer to the source for the most basic
    of templates.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据我们想要渲染的模板的扩展名设置自定义模板渲染。我们使用 Jade 渲染器为 `.jade` 扩展名，使用 `ejs` 渲染器为 `.html`
    扩展名，并通过不同的路由公开我们的索引文件。如果你选择了一种模板选项，后来又想以渐进的方式切换到新的选项，这很有用。你可以参考最基本模板的源代码。
- en: Local user authentication
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地用户身份验证
- en: The majority of applications require user accounts. Some applications only allow
    authentication through third parties, but not all users are interested in authenticating
    through third parties for privacy reasons, so it is important to include a local
    option. Here, we will go over best practices when implementing local user authentication
    in an Express app. We'll be using MongoDB to store our users and Mongoose as an
    ODM (Object Document Mapper). Then, we'll leverage passport to simplify the session
    handling and provide a unified view of authentication.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都需要用户账户。有些应用程序只允许通过第三方进行认证，但并非所有用户都希望因为隐私原因通过第三方进行认证，因此包含本地选项很重要。在这里，我们将讨论在
    Express 应用程序中实现本地用户认证的最佳实践。我们将使用 MongoDB 来存储我们的用户，并使用 Mongoose 作为 ODM（对象文档映射器）。然后，我们将利用
    passport 来简化会话处理并提供统一的认证视图。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载示例代码文件，以获取您购买的所有
    Packt Publishing 书籍。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: User object modeling
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户对象建模
- en: 'We will leverage passportjs to handle user authentication. Passport centralizes
    all of the authentication logic and provides convenient ways to authenticate locally
    in addition to third parties, such as Twitter, Google, Github, and so on. First,
    install passport and the local authentication strategy as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用 passportjs 来处理用户认证。Passport 集中了所有的认证逻辑，并提供方便的方式在本地进行认证，同时支持第三方认证，例如 Twitter、Google、Github
    等等。首先，按照以下步骤安装 passport 和本地认证策略：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our first pass, we will implement a local authentication strategy, which
    means that users will be able to register locally for an account. We start by
    defining a user model using Mongoose. Mongoose provides a way to define schemas
    for objects that we want to store in MongoDB and then provide a convenient way
    to map between stored records in the database and an in-memory representation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一次尝试中，我们将实现本地认证策略，这意味着用户将能够本地注册账户。我们首先使用 Mongoose 定义一个用户模型。Mongoose 提供了一种定义我们想要存储在
    MongoDB 中的对象模式的方法，并提供了一种方便的方式来在数据库中的存储记录和内存表示之间进行映射。
- en: 'Mongoose also provides convenient syntax to make many MongoDB queries and perform
    CRUD operations on models. Our user model will only have an e-mail, password,
    and timestamp for now. Before getting started, we need to install Mongoose:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 还提供了方便的语法来执行许多 MongoDB 查询，并在模型上执行 CRUD 操作。我们的用户模型目前只包含电子邮件、密码和时间戳。在开始之前，我们需要安装
    Mongoose：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we define the schema for our user in `models/user.js` as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在 `models/user.js` 文件中定义我们的用户模式，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we create a schema that describes our users. Mongoose has convenient ways
    to describe the required and unique fields as well as the type of data that each
    property should hold. Mongoose does all the validations required under the hood.
    We don't require many user fields for our first boilerplate application—e-mail,
    password, and timestamp to get us started.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个模式来描述我们的用户。Mongoose 提供了方便的方式来描述所需的唯一字段以及每个属性应持有的数据类型。Mongoose 在幕后执行所有必要的验证。对于我们的第一个样板应用程序，我们不需要许多用户字段——电子邮件、密码和时间戳足以开始。
- en: We also use Mongoose middleware to rehash a user's password if and when they
    decide to change it. Mongoose exposes several hooks to run user-defined callbacks.
    In our example, we define a callback to be invoked before Mongoose saves a model.
    That way, every time a user is saved, we'll check to see whether their password
    was changed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 Mongoose 中间件来重新散列用户的密码，如果他们决定更改密码。Mongoose 提供了几个钩子来运行用户定义的回调。在我们的示例中，我们定义了一个在
    Mongoose 保存模型之前被调用的回调。这样，每次用户被保存时，我们都会检查他们的密码是否已更改。
- en: Without this middleware, it would be possible to store a user's password in
    plaintext, which is not only a security vulnerability but would break authentication.
    Mongoose supports two kinds of middleware – serial and parallel. Parallel middleware
    can run asynchronous functions and gets an additional callback to invoke; you'll
    learn more about Mongoose middleware later in this book.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个中间件，就有可能以明文形式存储用户的密码，这不仅是一个安全漏洞，还会破坏认证。Mongoose 支持两种中间件类型——串行和并行。并行中间件可以运行异步函数，并得到一个额外的回调函数来调用；你将在本书的后面部分了解更多关于
    Mongoose 中间件的内容。
- en: 'Now, we want to add validations to make sure that our data is correct. We''ll
    use the `validator` library to accomplish this, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要添加验证以确保我们的数据是正确的。我们将使用 `validator` 库来完成这项任务，如下所示：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We added validations for e-mail and password length using a library called `validator`,
    which provides a lot of convenient validators for different types of fields. Validator
    has validations based on length, URL, int, upper case; essentially, anything you
    would want to validate (and don't forget to validate all user input!).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用名为 `validator` 的库添加了对电子邮件和密码长度的验证，该库为不同类型的字段提供了许多方便的验证器。Validator 提供基于长度、URL、整数、大写的验证；基本上，任何你想验证的内容（别忘了验证所有用户输入！）
- en: We also added a host of helper functions regarding registration, authentication,
    as well as encrypting passwords that you can find in `models/user.js`. We added
    these to the user model to help encapsulate the variety of interactions we want
    using the abstraction of a user.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一系列关于注册、认证以及加密密码的辅助函数，你可以在 `models/user.js` 文件中找到它们。我们将这些添加到用户模型中，以帮助封装我们想要使用用户抽象的各种交互。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on Mongoose, see [http://mongoosejs.com/](http://mongoosejs.com/).
    You can find more on passportjs at [http://passportjs.org/](http://passportjs.org/).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 Mongoose 的信息，请参阅 [http://mongoosejs.com/](http://mongoosejs.com/)。有关
    passportjs 的更多信息，请访问 [http://passportjs.org/](http://passportjs.org/)。
- en: 'This lays out the beginning of a design pattern called MVC—model, view, controller.
    The basic idea is that you encapsulate separate concerns in different objects:
    the model code knows about the database, storage, and querying; the controller
    code knows about routing and requests/responses; and the view code knows what
    to render for users.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这概述了名为 MVC 的设计模式的开始——模型、视图、控制器。基本思想是将不同的关注点封装在不同的对象中：模型代码了解数据库、存储和查询；控制器代码了解路由和请求/响应；视图代码知道为用户渲染什么。
- en: Introducing Express middleware
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Express 中间件
- en: Passport is authentication middleware that can be used with Express applications.
    Before diving into passport, we should go over Express middleware. Express is
    a connect framework, which means it uses the connect middleware. Connecting internally
    has a stack of functions that handle requests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 是一种可以与 Express 应用程序一起使用的认证中间件。在深入研究 Passport 之前，我们应该回顾一下 Express 中间件。Express
    是一个 connect 框架，这意味着它使用 connect 中间件。内部连接有一个处理请求的函数堆栈。
- en: When a request comes in, the first function in the stack is given the request
    and response objects along with the `next()` function. The `next()` function when
    called, delegates to the next function in the middleware stack. Additionally,
    you can specify a path for your middleware, so it is only called for certain paths.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到来时，堆栈中的第一个函数会接收到请求和响应对象以及 `next()` 函数。当调用 `next()` 函数时，它将委托给中间件堆栈中的下一个函数。此外，你可以指定中间件的路径，这样它就只为特定的路径调用。
- en: Express lets you add middleware to an application using the `app.use()` function.
    In fact, the HTTP handlers we already wrote are a special kind of middleware.
    Internally, Express has one level of middleware for the router, which delegates
    to the appropriate handler.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Express 允许你使用 `app.use()` 函数向应用程序添加中间件。实际上，我们之前编写的 HTTP 处理程序是一种特殊的中间件。内部，Express
    为路由器有一个中间件级别，它委托给适当的处理程序。
- en: Middleware is extraordinarily useful for logging, serving static files, error
    handling, and more. In fact, passport utilizes middleware for authentication.
    Before anything else happens, passport looks for a cookie in the request, finds
    metadata, and then loads the user from the database, adds it to req, user, and
    then continues down the middleware stack.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件对于日志记录、提供静态文件、错误处理等非常有用。实际上，Passport 利用中间件进行认证。在发生任何其他事情之前，Passport 会查找请求中的
    cookie，找到元数据，然后从数据库中加载用户，将其添加到 req 和 user 中，然后继续沿着中间件堆栈向下。
- en: Setting up passport
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 passport
- en: 'Before we can make full use of passport, we need to tell it how to do a few
    important things. First, we need to instruct passport how to serialize a user
    to a session. Then, we need to deserialize the user from the session information.
    Finally, we need to tell passport how to tell if a given e-mail/password combination
    represents a valid user as given in the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以充分利用 passport 之前，我们需要告诉它如何完成一些重要的事情。首先，我们需要指导 passport 如何将用户序列化到会话中。然后，我们需要从会话信息中反序列化用户。最后，我们需要告诉
    passport 如何判断给定的电子邮件/密码组合是否代表一个有效的用户，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we tell passport that when we serialize a user, we only need that user''s
    `id`. Then, when we want to deserialize a user from session data, we just look
    up the user by their ID! This is used in passport''s middleware, after the request
    is finished, we take `req.user` and serialize their ID to our persistent session.
    When we first get a request, we take the ID stored in our session, retrieve the
    record from the database, and populate the request object with a `user` property.
    All of this functionality is provided transparently by passport, as long as we
    provide definitions for these two functions as given in the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 passport 当我们序列化用户时，我们只需要该用户的 `id`。然后，当我们想要从会话数据中反序列化用户时，我们只需通过他们的 ID
    查找用户！这用于 passport 的中间件，在请求完成后，我们取 `req.user` 并将他们的 ID 序列化到我们的持久会话中。当我们第一次收到请求时，我们取存储在我们的会话中的
    ID，从数据库中检索记录，并用 `user` 属性填充请求对象。所有这些功能都由 passport 透明地提供，只要我们提供以下两个函数的定义：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We tell passport how to authenticate a user locally. We create a new `LocalStrategy()`
    function, which, when given an e-mail and password, will try to lookup a user
    by e-mail. We can do this because we required the e-mail field to be unique, so
    there should only be one user. If there is no user, we return an error. If there
    is a user, but they provided an invalid password, we still return an error. If
    there is a user and they provided the correct password, then we tell passport
    that the authentication request was a success by calling the `done` callback with
    the valid user.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉 passport 如何在本地验证用户。我们创建一个新的 `LocalStrategy()` 函数，当给定电子邮件和密码时，将尝试通过电子邮件查找用户。我们可以这样做，因为我们要求电子邮件字段必须是唯一的，所以应该只有一个用户。如果没有用户，我们返回一个错误。如果有用户，但提供了无效的密码，我们仍然返回一个错误。如果有用户并且他们提供了正确的密码，那么我们通过调用
    `done` 回调来告诉 passport 验证请求是成功的，从而告诉 passport 验证请求成功。
- en: In order to utilize passport, we need to add the middleware we talked about.
    We actually need to add a few different kinds of middleware. The great part about
    Express middleware is that it encourages developers to write small, focused modules
    so that you can bring in functionality that you want and exclude functionality
    that you don't need.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用护照，我们需要添加我们之前提到的中间件。实际上，我们需要添加几种不同的中间件。Express 中间件的好处在于它鼓励开发者编写小型、专注的模块，这样你就可以引入你想要的功能，排除你不需要的功能。
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In order to use passport, we have to enable a few things for our server. First
    we need to enable cookies and session support. To enable session support, we add
    a cookie parser. This middleware parses a cookie object into `req.cookies`. The
    session middleware lets us modify `req.session` and have that data persist across
    requests. By default, it uses cookies, but it has a variety of session stores
    that you can configure. Then, we have to add body-parsing middleware, which parses
    the body of HTTP requests into a JavaScript object `req.body`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 passport，我们必须为我们的服务器启用一些功能。首先，我们需要启用 cookies 和会话支持。为了启用会话支持，我们添加了一个 cookie
    解析器。这个中间件将 cookie 对象解析为 `req.cookies`。会话中间件允许我们修改 `req.session` 并使这些数据在请求之间持久化。默认情况下，它使用
    cookies，但它有多种会话存储方式，你可以进行配置。然后，我们必须添加 body-parsing 中间件，它将 HTTP 请求的正文解析为一个 JavaScript
    对象 `req.body`。
- en: In our use case, we need this middleware to extract the e-mail and password
    fields from `POST` requests. Finally, we add the passport middleware and session
    support.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用例中，我们需要这个中间件从 `POST` 请求中提取电子邮件和密码字段。最后，我们添加了 passport 中间件和会话支持。
- en: Registering users
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册用户
- en: 'Now, we add routes for registration, both a view with a basic form and backend
    logic to create a user. First, we will create a user controller. Up until now,
    we have thrown our routes in our `server.js` file, but this is generally bad practice.
    What we want to do is have separate controllers for each kind of route that we
    want. We have seen the model portion of MVC. Now it''s time to take a look at
    controllers. Our user controller will have all the routes that manipulate the
    user model. Let''s create a new file in a new directory, `controllers/user.js`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加了注册路由，包括一个带有基本表单的后端逻辑来创建用户。首先，我们将创建一个用户控制器。到目前为止，我们一直在将路由扔到 `server.js`
    文件中，但这通常是一个不好的做法。我们想要做的是为每种我们想要的路线都有单独的控制器。我们已经看到了 MVC 的模型部分。现在是时候看看控制器了。我们的用户控制器将包含所有操作用户模型的路线。让我们在新的目录中创建一个新文件，`controllers/user.js`：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `User` model takes care of the validations and registration logic;
    we just provide callback. Doing this helps consolidate the error handling and
    generally makes the registration logic easier to understand. If the registration
    was successful, we call `req.login`, a function added by passport, which creates
    a new session for that user and that user will be available as `req.user` on subsequent
    requests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`User` 模型负责验证和注册逻辑；我们只需提供回调。这样做有助于整合错误处理，并且通常使注册逻辑更容易理解。如果注册成功，我们调用 passport
    添加的 `req.login` 函数，为该用户创建一个新的会话，并且该用户将在后续请求中作为 `req.user` 可用。
- en: 'Finally, we register the routes. At this point, we also extract the routes
    we previously added to `server.js` to their own file. Let''s create a new file
    called `routes.js` as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们注册了路由。在这个阶段，我们还提取了之前添加到 `server.js` 的路由到它们自己的文件。让我们创建一个名为 `routes.js` 的新文件，如下所示：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we have a file dedicated to associating controller handlers with actual
    paths that users can access. This is generally good practice because now we have
    a place to come visit and see all of our defined routes. It also helps unclutter
    our `server.js` file, which should be exclusively devoted to server configuration.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个专门用于将控制器处理程序与用户可以访问的实际路径关联的文件。这通常是一个好的做法，因为现在我们有一个地方可以访问并查看我们定义的所有路由。这也帮助清理了我们的
    `server.js` 文件，该文件应该专门用于服务器配置。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For details, as well as the registration templates used, see the preceding code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息以及使用的注册模板，请参阅前面的代码。
- en: Authenticating users
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户认证
- en: 'We have already done most of the work required to authenticate users (or rather,
    passport has). Really, all we need to do is set up routes for authentication and
    a form to allow users to enter their credentials. First, we''ll add handlers to
    our user controller:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了认证用户所需的大部分工作（或者说，passport 已经完成了）。实际上，我们只需要设置认证路由和一个允许用户输入其凭据的表单。首先，我们将在用户控制器中添加处理程序：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's deconstruct what's happening in our login post. We create a handler that
    is the result of calling `passport.authenticate('local', …)`. This tells passport
    that the handler uses the local authentication strategy. So, when someone hits
    that route, passport will delegate to our LocalStrategy. If they provided a valid
    e-mail/password combination, our LocalStrategy will give passport the now authenticated
    user, and passport will redirect the user to the server root. If the e-mail/password
    combination was unsuccessful, passport will redirect the user to `/login` so they
    can try again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们的登录 post 中的发生的事情。我们创建了一个处理程序，它是调用 `passport.authenticate('local', …)`
    的结果。这告诉 passport，该处理程序使用本地认证策略。因此，当有人访问该路由时，passport 将将任务委托给我们的 LocalStrategy。如果他们提供了有效的电子邮件/密码组合，我们的
    LocalStrategy 将给 passport 提供现在认证的用户，passport 将将用户重定向到服务器根目录。如果电子邮件/密码组合不成功，passport
    将将用户重定向到 `/login`，以便他们可以再次尝试。
- en: 'Then, we will bind these callbacks to routes in `routes.js`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些回调绑定到 `routes.js` 中的路由：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, we should be able to register an account and login with those
    same credentials. (see tag 0.2 for where we are right now).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该能够使用相同的凭据注册账户并登录。（有关我们目前所在位置的详细信息，请参阅标签 0.2）。
- en: OAuth with passport
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 passport 进行 OAuth
- en: Now we will add support for logging into our application using Twitter, Google,
    and GitHub. This functionality is useful if users don't want to register a separate
    account for your application. For these users, allowing OAuth through these providers
    will increase conversions and generally make for an easier registration process
    for users.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加对使用Twitter、Google和GitHub登录我们应用程序的支持。如果用户不想为您的应用程序注册单独的账户，这个功能非常有用。对于这些用户，通过这些提供者允许OAuth将提高转化率，并且通常会让用户的注册过程更加简单。
- en: Adding OAuth to user model
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将OAuth添加到用户模型
- en: 'Before adding OAuth, we need to keep track of several additional properties
    on our user model. We keep track of these properties to make sure we can look
    up user accounts provided there is information to ensure we don''t allow duplicate
    accounts and allow users to link multiple third-party accounts by using the following
    code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加OAuth之前，我们需要在我们的用户模型上跟踪几个额外的属性。我们跟踪这些属性以确保如果有信息可以查找用户账户，我们不会允许重复的账户，并允许用户通过以下代码链接多个第三方账户：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we add a property for each provider, in which we will store a unique
    identifier that the provider gives us when they authorize with that provider.
    Next, we will store an array of tokens, so we can conveniently access a list of
    providers that are linked to this account; this is useful if you ever want to
    let a user register through one and then link to others for viral marketing or
    extra user information. Finally, we keep track of some demographic information
    about the user that the providers give to us so we can provide a better experience
    for our users.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为每个提供者添加一个属性，我们将存储提供者在授权时给我们提供的唯一标识符。接下来，我们将存储一个令牌数组，这样我们可以方便地访问与该账户链接的提供者列表；如果您想允许用户通过一个注册然后链接到其他账户进行病毒式营销或获取更多信息，这将非常有用。最后，我们跟踪一些提供者给我们提供的关于用户的统计数据，以便我们可以为用户提供更好的体验。
- en: Getting API tokens
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取API令牌
- en: Now, we need to go to the appropriate third parties and register our application
    to receive application keys and secret tokens. We will add these to our configuration.
    We will use separate tokens for development and production purposes (for obvious
    reasons!). For security reasons, we will only have our production tokens as environment
    variables on our final deploy server, not committed to version control.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要前往适当的第三方并注册我们的应用程序以接收应用程序密钥和秘密令牌。我们将把这些添加到我们的配置中。我们将为开发和生产目的使用不同的令牌（出于明显的原因！）。出于安全考虑，我们只会在最终的部署服务器上以环境变量的形式拥有我们的生产令牌，不会提交到版本控制中。
- en: 'I''ll wait while you navigate to the third-party websites and add their tokens
    to your configuration as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我会等待您导航到第三方网站，并将它们的令牌按照以下方式添加到您的配置中：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Of course, you should never commit your development keys publicly either. Be
    sure to either not commit this file or to use private source control. The best
    idea is to only have secrets live on machines ephemerally (usually as environment
    variables). You especially should not use the keys that I provided here!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也不应该将开发密钥公开提交。请确保不要提交此文件或使用私有源代码控制。最好的办法是只让秘密在机器上短暂存在（通常作为环境变量）。您尤其不应该使用我这里提供的密钥！
- en: Third-party registration and login
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方注册和登录
- en: 'Now we need to install and implement the various third-party registration strategies.
    To install third-party registration strategies run the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要安装和实现各种第三方注册策略。要安装第三方注册策略，请运行以下命令：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Most of these are extraordinarily similar, so I will only show the `TwitterStrategy`,
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大多数都非常相似，所以我只会展示`TwitterStrategy`，如下所示：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, I included one example of how we would do this. First, we pass a new TwitterStrategy
    to passport. The TwitterStrategy takes our Twitter keys and callback information
    and a callback is used to make sure we can register the user with that information.
    If the user is already registered, then it's a no-op; otherwise we save their
    information and pass along the error and/or successfully saved user to the callback.
    For the others, refer to the source.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我包括了一个示例，说明我们如何做这件事。首先，我们向passport传递一个新的TwitterStrategy。TwitterStrategy接受我们的Twitter密钥和回调信息，回调用于确保我们可以使用这些信息注册用户。如果用户已经注册，则不执行任何操作；否则，我们保存他们的信息，并将错误和/或成功保存的用户传递给回调。对于其他情况，请参阅源代码。
- en: Profile pages
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人资料页面
- en: It is finally time to add profile pages for each of our users. To do so, we're
    going to discuss more about Express routing and how to pass request-specific data
    to Jade templates. Often times when writing a server, you want to capture some
    portion of the URL to use in the controller; this could be a user id, username,
    or anything! We'll use Express's ability to capture URL parts to get the id of
    the user whose profile page was requested.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为我们的每个用户添加个人资料页面了。为了做到这一点，我们将进一步讨论Express路由以及如何将请求特定数据传递给Jade模板。在编写服务器时，通常希望捕获URL的一部分用于控制器；这可能是一个用户ID、用户名，或者任何东西！我们将使用Express捕获URL部分的能力来获取请求个人资料页面的用户ID。
- en: URL params
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL参数
- en: 'Express, like any good web framework, supports extracting data from URL parts.
    For example, you can do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Express，就像任何好的Web框架一样，支持从URL部分提取数据。例如，你可以这样做：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding example, we will print whatever comes after `/users/` in the
    request URL. This allows an easy way to specify per user routes, or routes that
    only make sense in the context of a specific user, that is, a profile page only
    makes sense when you specify a specific user. We will use this kind of routing
    to implement our profile page. For now, we want to make sure that only the logged-in
    user can see their own profile page (we can change this functionality later):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将打印出请求URL中`/users/`之后的内容。这提供了一种简单的方式来指定针对每个用户的路由，或者只在特定用户上下文中才有意义的路由，也就是说，只有当你指定了特定用户时，个人资料页面才有意义。我们将使用这种路由来实现我们的个人资料页面。目前，我们想要确保只有登录用户能看到自己的个人资料页面（我们可以在以后更改这个功能）：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we check first that the user is signed in and that the requested user's
    id is the same as the logged-in user's id. If it isn't, then we return an error.
    If it is, then we render the `users/profile.jade` template with `req.user` as
    the data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查用户是否已登录，以及请求的用户ID是否与登录用户的ID相同。如果不是，则返回错误。如果是，则使用`req.user`作为数据渲染`users/profile.jade`模板。
- en: Profile templates
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人资料模板
- en: 'We already looked at models and controllers at length, but our templates have
    been underwhelming. Finally, we''ll show how to write some basic Jade templates.
    This section will serve as a brief introduction to the Jade templating language,
    but does not try to be comprehensive. The code for Profile templates is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细地讨论了模型和控制器，但我们的模板一直很平淡。最后，我们将展示如何编写一些基本的Jade模板。本节将作为对Jade模板语言的简要介绍，但并不试图全面介绍。个人资料模板的代码如下：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notably, because in the controller we passed in the user to the view, we can
    access the variable user and it refers to the logged-in user! We can execute arbitrary
    JavaScript to render into the template by prefixing it with `=` --. In these blocks,
    we can do anything we would normally do, including string concatenation, method
    invocation, and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，因为在控制器中我们传递了用户到视图中，我们可以访问变量`user`，它指的是登录用户！我们可以通过在前面加上`=`前缀来执行任意JavaScript以渲染到模板中。在这些块中，我们可以做任何我们通常会做的事情，包括字符串连接、方法调用等等。
- en: Similarly, we can include JavaScript code that is not intended to be written
    as HTML by prefixing it with `-` like we did with the `for` loop. This basic template
    prints out the user's e-mail, the `created_at` timestamp, as well as all of the
    properties in their profile, if any.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以通过在前面加上`-`前缀，就像我们处理`for`循环那样，包含不打算作为HTML编写的JavaScript代码。这个基本模板会打印出用户的电子邮件、`created_at`时间戳，以及他们个人资料中的所有属性（如果有的话）。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a more in-depth look at Jade, please see [http://jade-lang.com/reference/](http://jade-lang.com/reference/).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解Jade，请参阅[http://jade-lang.com/reference/](http://jade-lang.com/reference/)。
- en: Testing
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Testing is essential for any application. I will not dwell on the whys, but
    instead assume that you are angry with me for skipping this topic in the previous
    sections. Testing Express applications tend to be relatively straightforward and
    painless. The general format is that we make fake requests and then make certain
    assertions about the responses.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于任何应用程序都是必不可少的。我不会过多地讨论原因，而是假设你因为我跳过了前几节中的这个话题而对我感到愤怒。测试Express应用程序通常相对简单且痛苦较少。一般格式是我们创建模拟请求，然后对响应做出某些断言。
- en: We could also implement finer-grained unit tests for more complex logic, but
    up until now almost everything we did is straightforward enough to be tested on
    a per route basis. Additionally, testing at the API level provides a more realistic
    view of how real customers will be interacting with your website and makes tests
    less brittle in the face of refactoring code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为更复杂的逻辑实现更细粒度的单元测试，但到目前为止，我们做的几乎所有事情都足够直接，可以按路由进行测试。此外，在API级别进行测试可以更真实地反映真实客户如何与您的网站互动，并使测试在面对代码重构时更加稳健。
- en: Introducing Mocha
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Mocha
- en: 'Mocha is a simple, flexible, test framework runner. First, I would suggest
    installing Mocha globally so you can easily run tests from the command line as
    follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 是一个简单、灵活的测试框架运行器。首先，我建议全局安装 Mocha，这样您就可以轻松地从命令行运行测试，如下所示：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `--save-dev` option saves `mocha` as a development dependency, meaning
    we don''t have to install Mocha on our production servers. Mocha is just a test
    runner. We also need an assertion library. There are a variety of solutions, but
    `should.js` syntax, written by the same person as Express and Mocha, gives a clean
    syntax to make assertions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`--save-dev` 选项将 `mocha` 保存为开发依赖项，这意味着我们不需要在生产服务器上安装 Mocha。Mocha 只是一个测试运行器。我们还需要一个断言库。有各种各样的解决方案，但由Express和Mocha的同一人编写的
    `should.js` 语法提供了一个干净的语法来制作断言：'
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `should.js` syntax provides BDD assertions, such as `''hello''.should.equal(''hello'')`
    and `[1,2].should.have.length(2)`. We can start with a Hello World test example
    by creating a `test` directory with a single file, `hello-world.js`, as shown
    in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`should.js` 语法提供了BDD断言，例如 `''hello''.should.equal(''hello'')` 和 `[1,2].should.have.length(2)`。我们可以通过创建一个名为
    `test` 的目录并包含一个名为 `hello-world.js` 的单个文件来开始一个Hello World测试示例，如下面的代码所示：'
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have two different tests both in the same namespace, `The World`. The first
    test is an example of a synchronous test. Mocha executes the function we give
    to it, sees that no exception gets thrown and the test passes. If, instead, we
    accept a `done` argument in our callback, as we do in the second example, Mocha
    will intelligently wait until we invoke the callback before checking the validity
    of our test. For the most part, we will use the second version, in which we must
    explicitly invoke the `done` argument to finish our test because it makes more
    sense to test Express applications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在同一命名空间 `The World` 中有两个不同的测试。第一个测试是一个同步测试的例子。Mocha 执行我们给它提供的函数，看到没有抛出异常，测试通过。如果我们接受一个
    `done` 参数作为回调，就像第二个例子中那样，Mocha 将智能地等待我们调用回调函数后再检查测试的有效性。大部分情况下，我们将使用第二种版本，我们必须显式调用
    `done` 参数来完成我们的测试，因为这样做对测试Express应用更有意义。
- en: Now, if we go back to the command line, we should be able to run Mocha (or `node_modules/.bin/mocha`
    if you didn't install it globally) and see that both of the tests we wrote pass!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们回到命令行，我们应该能够运行 Mocha（或者如果您没有全局安装，则是 `node_modules/.bin/mocha`）并看到我们编写的两个测试都通过了！
- en: Testing API endpoints
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试API端点
- en: 'Now that we have a basic understanding of how to run tests using Mocha and
    make assertions with `should` syntax, we can apply it to test local user registration.
    First, we need to introduce another `npm` module that will help us test our server
    programmatically and make assertions about what kind of responses we expect. The
    library is called `supertest`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了如何使用Mocha运行测试以及如何使用 `should` 语法进行断言，我们可以将其应用于测试本地用户注册。首先，我们需要引入另一个
    `npm` 模块，它将帮助我们以编程方式测试我们的服务器并对我们期望的响应类型进行断言。这个库叫做 `supertest`：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The library makes testing Express applications a breeze and provides chainable
    assertions. Let''s take a look at an example usage to test our create user route,
    as shown in the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库使测试Express应用变得轻而易举，并提供链式断言。让我们看看以下代码中如何测试我们的创建用户路由的示例：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'First, notice that we used two namespaces: `Users` and `registration`. Now,
    before we run any tests, we remove all users from the database. This is useful
    to ensure we know where we''re starting the tests This will delete all of your
    saved users though, so it''s useful to use a different database in the test environment.
    Node detects the environment by looking at the `NODE_ENV` environment variable.
    Typically it is test, development, staging, or production. We can do so by changing
    the database URL in our configuration file to use a different local database when
    in a test environment and then run Mocha tests with `NODE_ENV=test mocha`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意我们使用了两个命名空间：`Users` 和 `registration`。现在，在我们运行任何测试之前，我们从数据库中删除所有用户。这样做有助于确保我们知道测试的起点。这将删除您保存的所有用户，因此在使用测试环境时使用不同的数据库是有用的。Node
    通过查看 `NODE_ENV` 环境变量来检测环境。通常它是测试、开发、预发布或生产。我们可以通过更改配置文件中的数据库 URL 来使用不同的本地数据库，在测试环境中运行
    Mocha 测试，命令为 `NODE_ENV=test mocha`。
- en: Now, on to the interesting bits! Supertest exposes a chainable API to make requests
    and assertions about responses. To make a request, we use `request(app)`. From
    there, we specify the HTTP method and path. Then, we can specify a JSON body to
    send to the server; in this case, an example user registration form. On registration,
    we expect a redirect, which is a `302` response. If that assertion fails, then
    the `err` argument in our callback will be populated, and the test will fail when
    we use `done(err)`. Additionally, we validate that we were redirected to the route
    we expect, the server root `/`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看有趣的部分！Supertest 提供了一个链式 API，用于发送请求并对响应进行断言。要发送请求，我们使用 `request(app)`。从那里，我们指定
    HTTP 方法和方法路径。然后，我们可以指定要发送到服务器的 JSON 主体；在这种情况下，是一个示例用户注册表单。在注册时，我们期望发生重定向，即 `302`
    响应。如果该断言失败，那么我们回调中的 `err` 参数将被填充，并且当使用 `done(err)` 时测试将失败。此外，我们验证是否被重定向到我们期望的路由，即服务器根
    `/`。
- en: Automate builds and deploys
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化构建和部署
- en: All of this development is relatively worthless without a smooth process to
    build and deploy your application. Fortunately, the node community has written
    a variety of task runners. Among these are Grunt and Gulp, two of the most popular
    task runners. Both work seamlessly with Express and provide a set of utilities
    for us to use, including concatenating and uglifying JavaScript, compiling sass/less,
    and reloading the server on local file changes. We'll focus on Grunt, for simplicity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些开发如果没有一个顺畅的构建和部署应用程序的过程都是相对无用的。幸运的是，Node 社区编写了各种任务运行器。其中包含 Grunt 和 Gulp，它们是最受欢迎的任务运行器之一。两者都与
    Express 无缝协作，为我们提供了一系列实用工具，包括连接和压缩 JavaScript、编译 sass/less，以及在本地文件更改时重新加载服务器。我们将专注于
    Grunt，以保持简单。
- en: Introducing the Gruntfile
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Gruntfile
- en: 'Grunt itself is a simple task runner, but its extensibility and plugin architecture
    lets you install third-party scripts to run in predefined tasks. To give us an
    idea of how we might use Grunt, we''re going to write our `css` in `sass` and
    then use Grunt to compile `sass` to `css`. Through this example, we''ll explore
    the different ideas that Grunt introduces. First, you need to install `cli` globally
    to install the plugin that compiles `sass` to `css`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 本身是一个简单的任务运行器，但它的可扩展性和插件架构允许您安装第三方脚本以在预定义的任务中运行。为了让我们了解如何使用 Grunt，我们将使用
    `sass` 编写我们的 `css`，然后使用 Grunt 将 `sass` 编译为 `css`。通过这个示例，我们将探索 Grunt 引入的不同想法。首先，您需要全局安装
    `cli` 以安装编译 `sass` 为 `css` 的插件：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we need to create `Gruntfile.js`, which contains instructions for all of
    the tasks and build targets that we need. To do this perform the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建 `Gruntfile.js`，它包含了所有我们需要执行的任务和构建目标。为此，请执行以下操作：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's go over the major parts. Right at the top, we require the plugin we will
    use, `grunt-contrib-sass`. This tells `grunt` that we are going to configure a
    task called `sass`. In our definition of the task `sass`, we specify a target,
    `dist`, which is commonly used for tasks that produce production files (minified,
    concatenated, and so on).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看主要部分。在最上面，我们引入了我们将使用的插件，`grunt-contrib-sass`。这告诉 `grunt` 我们将配置一个名为 `sass`
    的任务。在我们的任务定义 `sass` 中，我们指定了一个目标，`dist`，它通常用于生成生产文件的任务（最小化、连接等）。
- en: In that task, we build our file list dynamically, telling Grunt to look in `/public/styles/`
    recursively for all `.scss` files, then compile them all to the same paths in
    `/dist/styles`. It is useful to have two parallel static directories, one for
    development and one for production, so we don't have to look at minified code
    in development. We can invoke this target by executing `grunt sass` or `grunt
    sass:dist`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个任务中，我们动态构建文件列表，告诉 Grunt 递归地在 `/public/styles/` 中查找所有 `.scss` 文件，然后将它们编译到
    `/dist/styles` 的相同路径。拥有两个并行的静态目录很有用，一个用于开发，一个用于生产，这样我们就不必在开发时查看压缩代码。我们可以通过执行 `grunt
    sass` 或 `grunt sass:dist` 来调用这个目标。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth noting that we don't explicitly concatenate the files in this task,
    but if we use `@imports` in our `main sass` file, the compiler will concatenate
    everything for us.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们在这个任务中没有明确地连接文件，但如果我们使用 `@imports` 在我们的主 `sass` 文件中，编译器会为我们连接所有内容。
- en: 'We can also configure Grunt to run our test suite. To do this, let''s add another
    plugin -- `npm install --save-dev grunt-mocha-test`. Now we have to add the following
    code to our `Gruntfile.js` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以配置 Grunt 来运行我们的测试套件。为此，让我们添加另一个插件 -- `npm install --save-dev grunt-mocha-test`。现在我们必须将以下代码添加到我们的
    `Gruntfile.js` 文件中：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the task is called `mochaTest` and we register a new task called `test`
    that simply delegates to the `mochaTest` task. This way, it is easier to remember
    how to run tests. Similarly, we could have specified a list of tasks to run if
    we passed an array of strings as the second argument to `registerTask`. This is
    a sampling of what can be accomplished with Grunt. For an example of a more robust
    Gruntfile, check out the source.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，任务被称作 `mochaTest`，我们注册了一个名为 `test` 的新任务，它简单地委托给 `mochaTest` 任务。这样，记住如何运行测试就更容易了。同样，如果我们把字符串数组作为
    `registerTask` 的第二个参数传递，我们也可以指定要运行的任务列表。这是 Grunt 可以实现的功能的样本。要查看一个更健壮的 Gruntfile
    示例，请查看源代码。
- en: Continuous integration with Travis
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Travis 的持续集成
- en: Travis CI provides free continuous integration for open source projects as well
    as paid options for closed source applications. It uses a git hook to automatically
    test your application after every push. This is useful to ensure no regression
    was introduced. Also, there could be dependency problems only revealed in CI that
    local development masks; Travis is the first line of defense for these bugs. It
    takes your source, runs npm install to install the dependencies specified in `package.json`,
    and then runs the npm test to run your test suite.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI 为开源项目提供免费的持续集成服务，同时也为闭源应用程序提供付费选项。它使用 git 钩子在每次推送后自动测试你的应用程序。这有助于确保没有引入回归。此外，可能只有
    CI 才能揭示的依赖性问题，而本地开发可能会掩盖这些问题；Travis 是这些错误的防线。它获取你的源代码，运行 `npm install` 以安装 `package.json`
    中指定的依赖项，然后运行 `npm test` 来运行你的测试套件。
- en: 'Travis accepts a configuration file called `travis.yml`. These typically look
    like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Travis 接受一个名为 `travis.yml` 的配置文件。这些通常看起来像这样：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can specify the versions of node that we want to test against as well as
    the services that we rely on (specifically MongoDB). Now we have to update our
    test command in `package.json` to run `grunt test`. Finally, we have to set up
    a webhook for the repository in question. We can do this on Travis by enabling
    the repository. Now we just have to push our changes and Travis will make sure
    all the tests pass! Travis is extremely flexible and you can use it to accomplish
    most tasks related to continuous integration, including automatically deploying
    successful builds.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定要测试的 node 版本以及我们依赖的服务（特别是 MongoDB）。现在我们必须更新 `package.json` 中的测试命令，以运行
    `grunt test`。最后，我们必须为相关的仓库设置一个 webhook。我们可以在 Travis 上通过启用仓库来完成此操作。现在我们只需推送我们的更改，Travis
    就会确保所有测试通过！Travis 非常灵活，你可以用它来完成与持续集成相关的几乎所有任务，包括自动部署成功的构建。
- en: Deploying Node.js applications
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 Node.js 应用程序
- en: One of the easiest ways to deploy Node.js applications is to utilize Heroku,
    a platform as a service provider. Heroku has its own toolbelt to create and deploy
    Heroku apps from your machine. Before getting started with Heroku, you will need
    to install its toolbelt.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 Node.js 应用程序的最简单方法之一是利用 Heroku，这是一个平台即服务提供商。Heroku 有自己的工具包，可以从你的机器上创建和部署
    Heroku 应用程序。在开始使用 Heroku 之前，你需要安装其工具包。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please go to [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/) to
    download the Heroku toolbelt.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问 [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/) 下载 Heroku 工具包。
- en: Once installed, you can log in to Heroku or register via the web UI and then
    run Heroku login. Heroku uses a special file, called the Procfile, which specifies
    exactly how to run your application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，你可以通过Web UI登录Heroku或注册，然后运行Heroku login。Heroku使用一个特殊的文件，称为Procfile，它指定了如何运行你的应用程序。
- en: 'Our Procfile looks like this:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的Procfile看起来像这样：
- en: '[PRE34]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Extraordinarily simple: in order to run the web server, just run node server.js.'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非常简单：为了运行Web服务器，只需运行node server.js。
- en: 'In order to verify that our Procfile is correct, we can run the following locally:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证我们的Procfile是否正确，我们可以在本地运行以下命令：
- en: '[PRE35]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Foreman looks at the Procfile and uses that to try to start our server. Once
    that runs successfully, we need to create a new application and then deploy our
    application to Heroku. Be sure to commit the Procfile to version control:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Foreman会查看Procfile，并使用它来尝试启动我们的服务器。一旦成功运行，我们需要创建一个新的应用程序，然后将我们的应用程序部署到Heroku。请确保将Procfile提交到版本控制：
- en: '[PRE36]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Heroku will create a new application and URL in Heroku, as well as a git remote
    repository named heroku. Pushing that remote actually triggers a deploy of your
    code.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Heroku将在Heroku上创建一个新的应用程序和URL，以及一个名为heroku的git远程仓库。推送该远程仓库实际上会触发你的代码部署。
- en: If you do all of this, unfortunately your application will not work. We don't
    have a Mongo instance for our application to talk to!
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你做了所有这些，不幸的是，你的应用程序将无法工作。我们没有为我们的应用程序提供Mongo实例进行通信！
- en: 'First we have to request MongoDB from Heroku:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须从Heroku请求MongoDB：
- en: '[PRE37]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This spins up a shared MongoDB instance and gives our application an environment
    variable named `MONOGOLAB_URI`, which we should use as our MongoDB connect URI.
    We need to change our configuration file to reflect these changes.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将启动一个共享的MongoDB实例，并给我们的应用程序一个名为`MONOGOLAB_URI`的环境变量，我们应该将其用作我们的MongoDB连接URI。我们需要更改我们的配置文件以反映这些更改。
- en: In our configuration file, in production, for our database URL, we should look
    at the environment variable `MONGOLAB_URI`. Also, be sure that Express is listening
    on `process.env.PORT || 3000`, or else you will receive strange errors and/or
    timeouts.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的配置文件中，在生产环境中，对于我们的数据库URL，我们应该查看环境变量`MONGOLAB_URI`。同时，确保Express正在监听`process.env.PORT
    || 3000`，否则你将收到奇怪的错误和/或超时。
- en: 'With all of that set up, we can commit our changes and push the changes once
    again to Heroku. Hopefully, this time it works! To view the application logs for
    debugging purposes, just use the Heroku toolbelt:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好所有这些之后，我们可以提交我们的更改，并将更改再次推送到Heroku。希望这次能成功！为了查看应用程序日志进行调试，只需使用Heroku工具包：
- en: '[PRE38]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'One last thing about deploying Express applications: sometimes applications
    crash, software isn''t perfect. We should anticipate crashes and have our application
    respond accordingly (by restarting itself). There are many server monitoring tools,
    including pm2 and forever. We use forever because of its simplicity.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于部署Express应用程序的最后一件事：有时应用程序会崩溃，软件并不完美。我们应该预料到崩溃，并让我们的应用程序相应地做出反应（通过自动重启）。有许多服务器监控工具，包括pm2和forever。我们使用forever是因为它的简单性。
- en: '[PRE39]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we update our Procfile to reflect our use of forever:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们更新我们的Procfile以反映我们对forever的使用：
- en: '[PRE40]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, forever will automatically restart our application, if it crashes for any
    strange reason. You can also set up Travis to automatically push successful builds
    to your server, but that goes beyond the deployment we will do in this book.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果应用程序因为任何奇怪的原因崩溃，forever将自动重启我们的应用程序。你还可以设置Travis以自动将成功的构建推送到你的服务器，但这超出了本书中我们将进行的部署。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got our feet wet in the world of node and using the Express
    framework. We went over everything from Hello World and MVC to testing and deployments.
    You should feel comfortable using basic Express APIs, but also feel empowered
    to own a `Node.js` application across the entire stack.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在node的世界里涉足，并使用Express框架。我们从Hello World和MVC到测试和部署都进行了介绍。你应该能够舒适地使用基本的Express
    API，同时也应该有能力掌握整个`Node.js`应用程序栈。
- en: In the following chapters, we will build on the core ideas introduced in this
    chapter in order to create rich user experiences and compelling applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将基于本章介绍的核心思想来创建丰富的用户体验和引人入胜的应用程序。
