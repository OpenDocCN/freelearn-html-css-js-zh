- en: Chapter 2. Expense Tracker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。支出跟踪器
- en: In this chapter, we will see how to build an expense tracker application. It
    will store all of our expenses for a given category. We will be able to see an
    aggregated balance of our expenses, or expenses by category. Each user will have
    a separate account to manage their expenses.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何构建支出跟踪器应用程序。它将存储给定类别的所有支出。我们将能够看到我们支出的汇总余额或按类别划分的支出。每个用户都将有一个单独的账户来管理他们的支出。
- en: 'Some of the interesting topics that we will cover are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的一些有趣的主题包括：
- en: Creating a multiuser system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多用户系统
- en: Working with monetary data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理货币数据
- en: Using the MongoDB aggregation framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MongoDB 聚合框架
- en: Different authentication strategies, such as HTTP Basic and token-based authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的身份验证策略，例如 HTTP 基本身份验证和基于令牌的身份验证
- en: Setting up the base application
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本应用程序
- en: Let's set up the base structure and files of our application. The whole source
    code for the project will be available as a bundle at [https://www.packtpub.com/](https://www.packtpub.com/).
    Therefore, we are only going to detail the most important part of setting up the
    base application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置应用程序的基本结构和文件。项目的全部源代码将以捆绑包的形式在 [https://www.packtpub.com/](https://www.packtpub.com/)
    上提供。因此，我们只将详细说明设置基本应用程序的最重要部分。
- en: Installing the dependencies
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: 'Let''s start by creating our `package.json` file in the root of the project
    and adding the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在项目根目录中创建我们的 `package.json` 文件并添加以下代码开始：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next step after defining the `package.json` file is to install the necessary
    dependencies. Run this command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `package.json` 文件后的下一步是安装必要的依赖项。运行以下命令：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After `npm` has pulled all the necessary files, you should be returned to the
    command prompt.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `npm` 拉取所有必要的文件后，你应该会返回到命令提示符。
- en: Creating the base configuration files
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本配置文件
- en: We are going to reuse a lot of code from the previous contact manager project.
    We created a file to load the necessary environment config file based on the current
    environment node is running. Add a new config file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用之前联系人管理器项目中的大量代码。我们创建了一个文件来根据当前运行的 Node 环境加载必要的环境配置文件。添加一个新的配置文件。
- en: 'Create a file called `config/environments/development.js` and add the following
    code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `config/environments/development.js` 的文件，并添加以下代码：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we are going to create the configuration file for Express and add the
    following lines of code to `config/express.js`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为 Express 创建配置文件，并将以下代码行添加到 `config/express.js` 文件中：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we are going to add a file called `config/mongoose.js` to connect
    to MongoDB, with the following content:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个名为 `config/mongoose.js` 的文件来连接到 MongoDB，内容如下：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating the main server.js file
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建主 server.js 文件
- en: 'The main entry point for our application is the `server.js` file. Create it
    in the root of the project. This file starts the web server and bootstraps all
    of the logic. Add the following lines of code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的主要入口点是 `server.js` 文件。在项目的根目录中创建它。此文件启动网络服务器并引导所有逻辑。添加以下代码行：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Setting up the user section
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户部分
- en: In the previous chapter, we also had a user section for the application. In
    this chapter, we are going to extend those functionalities by adding the register
    and change password functionalities. We are going to reuse the existing code base
    and add the new features.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们也有一个应用程序的用户部分。在本章中，我们将通过添加注册和更改密码功能来扩展这些功能。我们将重用现有的代码库并添加新功能。
- en: Describing the user model
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述用户模型
- en: 'We will create a test file specifically for the user model. This will come
    in handy for testing all its functionalities without booting up the entire application.
    Create a file called `test/integration/user.model.test.js` and add the following
    content:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个专门针对用户模型的测试文件。这将有助于在不启动整个应用程序的情况下测试其所有功能。创建一个名为 `test/integration/user.model.test.js`
    的文件，并添加以下内容：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have defined the base for our test file. Now we are going to add each test
    case one by one, before the last closing bracket:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为测试文件定义了基础。现在我们将逐个添加测试用例，在最后一个闭合括号之前：
- en: 'A user should be able to register with our system. We can test this with the
    following lines of code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户应该能够使用我们的系统进行注册。我们可以用以下代码行进行测试：
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same user cannot register twice with the same e-mail:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同一用户不能使用相同的电子邮件地址进行两次注册：
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After successful registration, a user should be able to authenticate into our
    system:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册成功后，用户应该能够对我们的系统进行身份验证：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If a user provides invalid credentials, it should not be authenticated successfully:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户提供了无效的凭据，则不应成功认证：
- en: '[PRE10]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A user should be able to change the current password:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户应该能够更改当前密码：
- en: '[PRE11]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An old password challenge must be passed in order to set a new password:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须通过旧密码挑战才能设置新密码：
- en: '[PRE12]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the preceding test suit, we have described and will test the functionality
    of our implemented methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的测试套件，我们描述并将要测试我们实现的方法的功能。
- en: Implementing the user model
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现用户模型
- en: 'The `user` model is going to use the same password helper principle as in [Chapter
    1](part0016_split_000.html#F8902-5c78d361d97340239270192b72d53e7b "Chapter 1. Contact
    Manager"), *Contact Manager*. Let''s create a file called `app/helpers/password.js`.
    The file should contain the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`user` 模型将使用与 [第 1 章](part0016_split_000.html#F8902-5c78d361d97340239270192b72d53e7b
    "第 1 章。联系人管理器") 中相同的密码辅助原则，即 *联系人管理器*。让我们创建一个名为 `app/helpers/password.js` 的文件。该文件应包含以下代码：'
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now add the `hashPassword()` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加 `hashPassword()` 函数：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have added an extra function, called `generateDerivedKey()`, in order not
    to repeat code blocks:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个额外的函数，称为 `generateDerivedKey()`，以避免重复代码块：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, add the `verify()` function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加 `verify()` 函数：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s create a user schema in the model file. Create a new file, called
    `app/models/user.js`, and add the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在模型文件中创建一个用户模式。创建一个名为 `app/models/user.js` 的新文件，并添加以下内容：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, one by one, let''s add the required methods from the test. We will start
    with the `register()` method. Append these lines of code to the user model file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐个添加测试中所需的方法。我们将从 `register()` 方法开始。将这些代码行追加到用户模型文件中：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a simple function that will save a user in MongoDB. Before saving the
    user, we want to build a hash from the given password and save that hash with
    a salt in the database, instead of a plain password string. Mongoose will also
    validate the user data before saving it, based on the User schema.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，它将在 MongoDB 中保存用户。在保存用户之前，我们希望从给定的密码中构建一个哈希值，并将该哈希值与盐一起保存在数据库中，而不是明文密码字符串。Mongoose
    还会在保存之前根据用户模式验证用户数据。
- en: 'For the `authenticate()` method, we will append the following lines of code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `authenticate()` 方法，我们将追加以下代码行：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The authentication method will find a user by e-mail. The `password` and `passwordSalt`
    fields are explicitly set to be read from the database only for this query. A
    password verification function will be called to match the existing password hash
    with the password sent to the authentication method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 认证方法将通过电子邮件查找用户。对于此查询，`password` 和 `passwordSalt` 字段被明确设置为仅从数据库中读取。将调用密码验证函数来匹配现有的密码哈希与发送给认证方法的密码。
- en: 'Finally we will add a `changePassword()` method. This method will be available
    on user instances only. Mongoose gives us the ability to use the `methods` property
    on a schema to attach new functions. Append the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个 `changePassword()` 方法。此方法仅对用户实例可用。Mongoose 允许我们在模式上使用 `methods` 属性来附加新函数。追加以下代码：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The change password functionality is built using three small steps. The first
    step is to get the user's password and salt from the database. The returned data
    is used to verify the existing password hash and salt with the old password entered
    by the user. If everything goes well, the new password is hashed using a generated
    salt and the user instance is saved into MongoDB.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更改密码功能是使用三个小步骤构建的。第一步是从数据库中获取用户的密码和盐。返回的数据用于验证用户输入的旧密码与现有的密码哈希和盐。如果一切顺利，则使用生成的盐对新的密码进行哈希处理，并将用户实例保存到
    MongoDB 中。
- en: 'Don''t forget to move the following line of code to the end of the file, in
    order to compile the user model:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将以下代码行移动到文件末尾，以便编译用户模型：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Suppose we run our user model test with the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用以下命令运行我们的用户模型测试：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We should see all of our tests passing:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到所有测试都通过：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Authenticating users
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户认证
- en: In the previous chapter, we used session-based authentication. For this chapter,
    we are going to explore a different solution—using access tokens to authenticate
    our users.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了基于会话的认证。对于本章，我们将探索不同的解决方案——使用访问令牌来认证我们的用户。
- en: Access tokens are widely used for RESTful APIs. Because we are building our
    application with the premise that it could be used not only by our Angular app
    but also by many other client applications, we need to rely on something that
    can be used to identify users with something that they have.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌在 RESTful API 中被广泛使用。因为我们构建应用程序的前提是它不仅可以用作我们的 Angular 应用，还可以用于许多其他客户端应用程序，我们需要依赖某种可以用来识别用户的东西。
- en: An access token is a string that identifies a user, or even an app, and it can
    be used to make API calls to our system. Tokens can be issued via a number of
    methods. For example, tokens can be issued easily using OAuth 2.0\.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌是一个标识用户（甚至是一个应用程序）的字符串，它可以用来对我们的系统进行 API 调用。令牌可以通过多种方式发放。例如，可以使用 OAuth 2.0
    简单地发放令牌。
- en: For this chapter, we are going to build a custom module that is responsible
    for creating tokens. This will give us the ability to easily switch to any other
    available solution.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将构建一个自定义模块，该模块负责创建令牌。这将使我们能够轻松切换到任何其他可用的解决方案。
- en: We are going to implement two strategies to authenticate our users. One of them
    will be an HTTP Basic authentication strategy, which will use a simple username
    (e-mail in our case) and password combo to authenticate a user and generate a
    token that will be used for further API calls. The second strategy is an HTTP
    Bearer authentication, which will use the access token issued by the Basic authentication
    to grant the user access to resources.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现两种策略来认证我们的用户。其中之一将是一个 HTTP Basic 认证策略，它将使用简单的用户名（在我们的情况下是电子邮件）和密码组合来认证用户，并生成一个用于后续
    API 调用的令牌。第二种策略是 HTTP Bearer 认证，它将使用 Basic 认证发放的访问令牌来授予用户访问资源的权限。
- en: Describing the authentication strategies
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述认证策略
- en: 'Before implementing any code, we should create a test that will describe the
    desired behavior regarding user authentication. Create a file called `tests/integration/authentication.test.js`
    and describe the main test cases:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现任何代码之前，我们应该创建一个测试来描述关于用户认证的期望行为。创建一个名为 `tests/integration/authentication.test.js`
    的文件，并描述主要测试用例：
- en: 'The first test case should consider a positive scenario, that is, when a user
    tries to authenticate with valid credentials. This would look like the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个测试用例应考虑一个积极场景，即当用户尝试使用有效凭据进行认证时。这看起来如下所示：
- en: '[PRE24]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If a user tries to authenticate with invalid credentials, the system should
    return a bad request message:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户尝试使用无效凭据进行认证，系统应返回一个错误请求消息：
- en: '[PRE25]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We described the basic strategy. We considered the fact that a user must send
    an e-mail as username and password via a POST call to the `/api/auth` endpoint
    and get back the user details and a valid token.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了基本策略。我们考虑了用户必须通过 POST 调用 `/api/auth` 端点发送电子邮件作为用户名和密码，并获取用户详情和有效令牌的事实。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `request` library has a special property called `auth` that will encode
    the username-and-password tuple using base64 and set the appropriate headers for
    HTTP Basic authentication.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 库有一个名为 `auth` 的特殊属性，它将使用 base64 对用户名和密码元组进行编码，并设置适当的 HTTP Basic 认证头。'
- en: As you can see, our presumption is that a valid token will be generated when
    a user successfully authenticates into our system. For this reason, we are going
    to implement the token generation functionality before continuing further.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的假设是当用户成功登录到我们的系统时，将生成一个有效的令牌。因此，在继续前进之前，我们将实现令牌生成功能。
- en: Implementing the token generation
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现令牌生成
- en: Tokens can be generated in many ways. For this chapter, we are going to use
    the built-in crypto library from Node.js. We can use the `randomBytes()` method
    to generate a random string of a given length. One thing to note is that `randomBytes()`
    will throw an error if there is not enough accumulated entropy. This means that
    if there is not enough information in the entropy source to generate a random
    number, it will throw an error.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌可以通过多种方式生成。在本章中，我们将使用 Node.js 的内置加密库。我们可以使用 `randomBytes()` 方法生成指定长度的随机字符串。需要注意的是，如果累积的熵不足，`randomBytes()`
    将抛出错误。这意味着如果熵源中信息不足，无法生成随机数，它将抛出错误。
- en: 'Let''s create a new file called `app/helpers/token.js` and add the following
    lines of code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `app/helpers/token.js` 的新文件，并添加以下代码行：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We created a helper function that will generate a random token for us. The
    function takes two arguments: the number of random bytes, which is optional, and
    a callback function.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个辅助函数，它将为我们生成一个随机令牌。该函数接受两个参数：随机字节数，这是可选的，以及一个回调函数。
- en: Persisting tokens in MongoDB
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在MongoDB中持久化令牌
- en: In order to check an access token sent by the user—that is, whether it's valid
    or not—we should store it somewhere. For this, we are going to use MongoDB as
    our storage engine for the tokens.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查用户发送的访问令牌——即它是否有效——我们应该将其存储在某个地方。为此，我们将使用MongoDB作为我们的令牌存储引擎。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that you should treat your tokens with the same responsibility as user
    passwords, because tokens will give access to the system's functionality. One
    option to consider for further security improvements is to store tokens encrypted
    in the database or even store them in a separate token storage.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你应该像对待用户密码一样对待你的令牌，因为令牌将提供对系统功能的访问。为了进一步提高安全性，可以考虑将令牌加密存储在数据库中，或者甚至将它们存储在单独的令牌存储中。
- en: 'Before anything, let''s create a test for the token model. Create a file called
    `tests/integration/token.model.js` and add the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，让我们为令牌模型创建一个测试。创建一个名为 `tests/integration/token.model.js` 的文件，并添加以下代码：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are going to add a `generate()` method to the `Token` model, which will return
    a cryptographically strong token.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向 `Token` 模型添加一个 `generate()` 方法，该方法将返回一个加密强度高的令牌。
- en: 'Create a file called `app/models/token.js`. It will hold the `Token` Mongoose
    schema and the preceding method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `app/models/token.js` 的文件。它将包含 `Token` Mongoose模式以及前面的方法：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we added an expiration date for our tokens. This could be used
    to automatically invalidate tokens after a given time. Usually, in an application,
    you don't want to have tokens without an expiration date. If there is a need for
    such tokens, another layer of authorization through API keys should be added to
    authorize the usage of the system for third-party clients.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们为我们的令牌添加了一个过期日期。这可以用来在指定时间后自动使令牌失效。通常，在应用程序中，您不希望有没有过期日期的令牌。如果需要这样的令牌，应该添加另一层通过API密钥的授权，以授权第三方客户端使用系统。
- en: Authentication using HTTP Basic
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTTP基本认证进行认证
- en: Before generating a token, we need to authenticate our users. One simple solution
    could be to use a simple username-and-password authentication and generate a token
    if the entered information is valid.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成令牌之前，我们需要对用户进行认证。一个简单的解决方案可能是使用简单的用户名和密码认证，如果输入的信息有效，则生成令牌。
- en: We can expose a route that will handle HTTP Basic authentication. This is the
    simplest technique for enforcing access control for a resource. In our case, the
    resource will be a token and it does not require cookies or identifying sessions.
    HTTP Basic authentication uses standard fields in the HTTP request header.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以公开一个处理HTTP基本认证的路由。这是强制执行资源访问控制的最简单技术。在我们的例子中，资源将是一个令牌，它不需要cookies或标识会话。HTTP基本认证使用HTTP请求头中的标准字段。
- en: This method does not add any encryption or hashing in any way; just a simple
    base64 encoding is needed. For this reason, it is typically used over HTTPS. If
    the client wants to send the server the necessary credentials for authentication,
    it can use the `Authorization` header field.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法不会以任何方式添加加密或散列；只需要简单的base64编码即可。因此，它通常在HTTPS上使用。如果客户端想要向服务器发送用于认证的必要凭证，它可以使用
    `Authorization` 头字段。
- en: 'We are going to use the `passport-http` module for the Basic authentication
    strategy. Let''s create a file called `app/config/strategies/basic.js` and add
    the following lines of code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `passport-http` 模块来实现基本认证策略。让我们创建一个名为 `app/config/strategies/basic.js`
    的文件，并添加以下代码行：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The strategy uses the `authenticate()` method to check whether the credentials
    are valid. As you can see, we are not adding any extra logic here.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略使用 `authenticate()` 方法来检查凭证是否有效。如您所见，我们在这里没有添加任何额外的逻辑。
- en: 'Next, we are going to create a controller that will handle the basic authentication.
    Create a file called `app/controllers/authentication.js` and add the following
    content:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个控制器来处理基本认证。创建一个名为 `app/controllers/authentication.js` 的文件，并添加以下内容：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Passport has an `authenticate()` method that enables us to call a given strategy.
    We are using a custom callback in order to generate and persist a token in MongoDB.
    When returning the token to the client, we only need a few things from the stored
    data, such as the value and expiration date.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 有一个 `authenticate()` 方法，使我们能够调用一个给定的策略。我们使用自定义回调来生成并持久化 MongoDB 中的令牌。当将令牌返回给客户端时，我们只需要存储数据中的少数几个东西，例如值和过期日期。
- en: Adding authentication routes
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加身份验证路由
- en: 'Create a file called `app/routes/authentication.js` and add the following lines
    of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `app/routes/authentication.js` 的文件，并添加以下代码行：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `auth` route will allow users to make a post call and authenticate using
    the basic strategy. In order to create reusable routes, we do not mount the routes
    directly to the Express app instance. Instead, we use the `Router` class to instantiate
    a new router.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth` 路由将允许用户使用基本策略进行 POST 调用并验证。为了创建可重用的路由，我们不会直接将路由挂载到 Express 应用实例上。相反，我们使用
    `Router` 类来实例化一个新的路由器。'
- en: 'In order to be able to configure what routes we are mounting on our Express
    application, we can create a file called `config/routes.js` with the following
    lines of code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够配置我们在 Express 应用程序上挂载哪些路由，我们可以创建一个名为 `config/routes.js` 的文件，包含以下代码行：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding lines of code should be straightforward. We are defining the routes'
    base path and mounting them onto our application. One thing to note is that we
    are adding a prefix to the authentication routes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行应该很简单。我们正在定义路由的基本路径并将它们挂载到我们的应用程序上。需要注意的是，我们正在向身份验证路由添加一个前缀。
- en: 'Add the following highlighted code to the main `server.js` file in order to
    initialize the routes configuration file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下高亮显示的代码添加到主 `server.js` 文件中，以初始化路由配置文件：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run our authentication test with the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行我们的身份验证测试：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This should have a similarly positive output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该有一个类似的积极输出：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Verifying users using bearer authentication
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用携带者身份验证验证用户
- en: For each request, tokens should be used to determine whether the requester has
    access to the system or not. We only used the basic strategy to issue a token
    if the user sent valid credentials. Passport has a `passport-http-bearer` module.
    Normally this is used to protect API endpoints, as in our case. The tokens are
    often issued using OAuth 2.0, but, in our case, we built a custom solution to
    issue tokens.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个请求，应使用令牌来确定请求者是否有权访问系统。我们只有在用户发送有效凭据时才使用基本策略颁发令牌。Passport 有一个 `passport-http-bearer`
    模块。通常，这用于保护 API 端点，就像在我们的案例中一样。令牌通常使用 OAuth 2.0 颁发，但，在我们的案例中，我们构建了一个自定义解决方案来颁发令牌。
- en: Also in our case, a token is a string representing an access authorization key
    issued to the client by the system. The client application, the Angular app, will
    use the access token to retrieve protected resources from the RESTful API.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，令牌是系统向客户端颁发的访问授权键的字符串表示。客户端应用程序，Angular 应用程序，将使用访问令牌从 RESTful API 获取受保护资源。
- en: 'Let''s describe a simple use case to retrieve information using an access token.
    Append the following lines of code to `tests/integration/authentication.test.js`,
    after the basic authentication test suite:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一个简单的用例，使用访问令牌检索信息。将以下代码行追加到 `tests/integration/authentication.test.js`，在基本身份验证测试套件之后：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We assume the existence of an `/auth/info` route on which, if a GET call is
    made, it will return the token's owner credential. If the token is invalid, an
    unauthorized message is sent back, with the appropriate 401 HTTP status code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设存在一个 `/auth/info` 路由，如果进行 GET 调用，它将返回令牌的所有者凭据。如果令牌无效，将返回一个带有适当 401 HTTP
    状态码的未授权消息。
- en: Bearer strategy
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 携带者策略
- en: 'Let''s create a file called `config/strategies/bearer.js`. Add the following
    piece of code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `config/strategies/bearer.js` 的文件。添加以下代码段：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code searches in the database for the given token. In order to
    retrieve the token owner, we can use the `populate()` method from Mongoose in
    combination with a normal query method, such as `findOne()`. This can be done
    because we explicitly added a reference to the User model in the Token model.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在数据库中搜索给定的令牌。为了检索令牌所有者，我们可以使用 Mongoose 的 `populate()` 方法结合一个常规查询方法，例如 `findOne()`。这是因为我们在
    Token 模型中明确添加了对 User 模型的引用。
- en: Protecting resources using tokens
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用令牌保护资源
- en: In order to protect our resources, we need to add a layer that checks the presence
    of the access token. We did the first part of the Bearer strategy. Now we only
    need to use it; for this, we can create middleware that will validate the token.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们的资源，我们需要添加一个检查访问令牌存在的层。我们已经完成了Bearer策略的第一部分。现在我们只需要使用它；为此，我们可以创建一个中间件来验证令牌。
- en: 'Create a new file called `app/middlewares/authentication.js` and add the following
    code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`app/middlewares/authentication.js`的新文件，并添加以下代码：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code is fairly simple. We just use passport's built-in `authenticate()`
    method to call the bearer strategy. We don't want to save any session on the server.
    This piece of middleware can be used on each route in combination with any other
    application logic.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码相当简单。我们只是使用passport的内置`authenticate()`方法调用Bearer策略。我们不想在服务器上保存任何会话。这个中间件可以与任何其他应用程序逻辑结合使用，应用于每个路由。
- en: 'Append the following lines of code to `app/controllers/authentication.js`.
    It will only check whether the user is present on the request object and return
    a JSON with the data:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码行追加到`app/controllers/authentication.js`。它将仅检查用户是否存在于请求对象中，并返回包含数据的JSON：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now let''s get back to our authentication route, `app/routes/authentication.js`,
    and add the following highlighted lines of code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的身份验证路由`app/routes/authentication.js`，并添加以下突出显示的代码行：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We added the authentication middleware before the execution of the logic from
    the controller in order to validate and retrieve the token's owner. Our bearer
    strategy will handle this and set the user on the request object; more precisely,
    it can be found on `req.user`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制器逻辑执行之前添加了身份验证中间件，以验证和检索令牌的所有者。我们的Bearer策略将处理这个问题，并在请求对象上设置用户；更确切地说，它可以在`req.user`上找到。
- en: 'If we run our authentication test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的身份验证测试：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following output should be printed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 应该打印以下输出：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this, we've finally added all the necessary authentication methods to grant
    users access to our system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们最终添加了所有必要的身份验证方法，以授予用户访问我们的系统。
- en: Tracking expenses
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪支出
- en: The main feature of our application is to track the user's expenses. A user
    should be able to insert expenses, be persisted in the system, and see the exact
    balance for his/her account.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的主要功能是跟踪用户的支出。用户应该能够插入支出，使其在系统中持久化，并查看其账户的确切余额。
- en: 'There should always be a clear view of what is desired to be achieved. Let''s
    take a high-level view of what we want to achieve:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 总是应该有一个清晰的视图来了解想要实现的目标。让我们从高层次的角度看看我们想要实现的目标：
- en: A user should be able to persist an expense in the system
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够在系统中持久化一笔支出
- en: A user should be able to get all their expenses
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够获取其所有的支出
- en: A user should be able to get the balance of their expenses
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够获取其支出的余额
- en: A user should be able to define a category in which to save expenses, for example,
    groceries
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够定义一个类别来保存支出，例如，杂货
- en: Monetary values
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 货币价值
- en: In our case, an expense will store the exact value of money spent. In some cases,
    working with monetary data can get tricky. Often, applications that handle monetary
    data are required to work with fractional units of the currency.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，一笔支出将存储花费的确切货币价值。在某些情况下，处理货币数据可能会变得复杂。通常，处理货币数据的应用程序需要处理货币的分数单位。
- en: We could store data in floating-point numbers. However, in JavaScript, floating-point
    arithmetic often does not conform to monetary arithmetic. In other words, values
    like one-third and one-tenth do not have an exact representation in binary floating-point
    numbers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数据存储为浮点数。然而，在JavaScript中，浮点运算通常不符合货币运算。换句话说，像三分之一和十分之一这样的值在二进制浮点数中没有确切的表示。
- en: 'MongoDB, for example, stores numeric data as either IEEE 754 standard 64-bit
    floating-point numbers, 32-bit, or 64-bit signed integers. JavaScript treats numbers
    according to specs as double-precision 64-bit format IEEE 754 values. Because
    of this, we need to pay attention to such operations:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，MongoDB将数值数据存储为IEEE 754标准64位浮点数、32位或64位有符号整数。JavaScript根据规范将数字视为双精度64位格式IEEE
    754值。因此，我们需要注意以下操作：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We won't be able to store values such as 9.99 USD, representing cents in decimal.
    Don't get me wrong; we can store them, but we are not going to get correct results
    if we use the built-in MongoDB aggregation framework or do server-side arithmetic
    (the same thing applies for the client side too in JavaScript).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将无法存储像9.99美元这样的值，它代表小数点后的美分。请别误会；我们可以存储它们，但如果使用内置的MongoDB聚合框架或进行服务器端算术（同样适用于JavaScript客户端）时，我们将无法得到正确的结果。
- en: 'Do not worry; there are a few solutions that we can use. There are two common
    approaches to storing monetary values in MongoDB:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心；我们有几种解决方案可以使用。在MongoDB中存储货币值有两种常见的方法：
- en: Exact precision is an approach that is used to multiply the monetary value by
    a power of 10.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确精度是一种将货币值乘以10的幂的方法。
- en: Arbitrary precision, on the other hand, uses two fields to represent the monetary
    value. One field stores the exact value as a non-numeric format, such as a string,
    and another field stores the floating-point approximation of the value.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，任意精度使用两个字段来表示货币值。一个字段以非数字格式（如字符串）存储精确值，另一个字段存储值的浮点近似值。
- en: For our implementation, we are going to use the exact precision model. We will
    discuss all the details as we progress with the code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实现，我们将使用精确精度模型。随着代码的进展，我们将讨论所有细节。
- en: The category model
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别模型
- en: As we discussed earlier, we want to be able to add an expense to a specific
    category. A user should also be able to invite another user to add expenses to
    a category. We are not going to detail the test cases for this feature, but you
    should consider writing tests to make sure that everything works as expected.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，我们希望能够向特定类别添加支出。用户还应该能够邀请其他用户向类别添加支出。我们不会详细说明此功能的测试用例，但你应该考虑编写测试以确保一切按预期工作。
- en: 'Let''s create a file called `app/models/category.js` and add the following
    lines of code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`app/models/category.js`的文件，并添加以下代码行：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Two important things to note here: we define the owner of the category, which
    will always be the authenticated user that creates the category, and the collaborators
    field, which holds users that can insert expenses into the category.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要事项需要注意：我们定义了类别的所有者，它始终是创建类别的认证用户，以及协作者字段，它包含可以插入类别支出的用户。
- en: 'Also, don''t forget to change the model configuration file, `config/models.js`,
    by adding the following highlighted code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了通过添加以下突出显示的代码来更改模型配置文件`config/models.js`：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Categories routes
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别路由
- en: 'To expose a simple CRUD on the category collection, we have to define routes
    for those actions. For this, we are going to create a router file, called `app/routes/categories.js`,
    and add these lines of code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在类别集合上公开简单的CRUD操作，我们必须为这些操作定义路由。为此，我们将创建一个名为`app/routes/categories.js`的路由器文件，并添加以下代码行：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Keep in mind that we actually have no implementation of the category controller
    at the moment. Let''s create a category controller with the following name: `app/controllers/category.js`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们目前实际上没有实现类别控制器。让我们创建一个名为`app/controllers/category.js`的类别控制器。
- en: Getting the category by ID
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过ID获取类别
- en: 'Add the following lines of code to `app/controllers/category.js`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码行添加到`app/controllers/category.js`中：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding code will come in handy when the `categoryId` route `param` is
    present. It will automatically get a category, as we defined it in the route file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当`categoryId`路由`param`存在时，前面的代码将非常有用。它将自动获取一个类别，正如我们在路由文件中定义的那样。
- en: Creating a category
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建类别
- en: 'To create a category, append the following lines of code to the controller
    file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个类别，将以下代码行追加到控制器文件中：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Before creating a category, we add the owner's ID, which is the current user's
    ID.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类别之前，我们添加所有者的ID，即当前用户的ID。
- en: Getting one and all categories
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取一个和所有类别
- en: We also want to get a single category and all categories. To get one category,
    we are going to use the results from getting a category by ID. To retrieve multiple
    categories, we are going to use the `find()` query method from Mongoose. We could
    easily add pagination or set limits, but we are going to presume that a user will
    not have so many categories. This could be a small improvement for our application
    later on.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望获取单个类别和所有类别。要获取一个类别，我们将使用通过ID获取类别的结果。要检索多个类别，我们将使用Mongoose的`find()`查询方法。我们可以轻松添加分页或设置限制，但我们将假设用户不会有这么多类别。这可能是我们应用程序的一个小改进。
- en: 'Append the following lines of code to the controller:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码行添加到控制器中：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Updating and deleting a category
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新和删除分类
- en: 'When we get a category by ID, we set the returned instance from Mongoose to
    the request object. Due to this, we can use that instance to change its properties
    and save it back to Mongo. Append this code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 ID 获取一个分类时，我们将 Mongoose 返回的实例设置到请求对象中。由于这个原因，我们可以使用该实例来更改其属性并将其保存回 Mongo。添加以下代码：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The same thing can be used when deleting a category; also append the following
    lines of code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 删除分类时也可以使用相同的方法；也请添加以下代码行：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With the preceding lines of code, we have finished CRUD operations on categories.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码行，我们已经完成了对分类的 CRUD 操作。
- en: Defining the expense model
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义费用模型
- en: Earlier, we discussed the fact that we cannot simply store monetary data as
    floating-point numbers in the database or use it for server-side arithmetic. The
    accepted solution for our scenario was to use exact precision to store monetary
    data. In other words, money values will be stored by multiplying the initial value
    with a number that is a power of 10.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了这样一个事实，即我们不能简单地将货币数据作为浮点数存储在数据库中或用于服务器端算术。我们场景的解决方案是使用精确精度来存储货币数据。换句话说，货币值将通过将初始值乘以
    10 的幂来存储。
- en: We are going to assume that the required maximum precision will be a tenth of
    a cent. Going with this assumption, we will multiply the initial value by 1000\.
    For example, if we have an initial value of 9.99 USD, the stored value in the
    database will be 9990.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设所需的最高精度为十分之一分。根据这个假设，我们将初始值乘以 1000。例如，如果我们有一个初始值为 9.99 美元，数据库中存储的值将是 9990。
- en: For the current implementation of the application, we are going to use USD as
    our currency for monetary values. The scale factor will be 1000 to preserve precision
    up to one-tenth of a cent. Using the exact precision model, the scale factor needs
    to be consistent for the currency across the application and anytime given it
    should be determined from the currency.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前应用程序的实现，我们将使用美元（USD）作为货币值。缩放因子将为 1000，以保留到十分之一分的精度。使用精确精度模型，缩放因子需要在应用程序中保持一致，并且任何给定时间都应该从货币中确定。
- en: 'Let''s create our expense model, `app/models/expense.js`, and add the following
    lines of code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的费用模型，`app/models/expense.js`，并添加以下代码行：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following table will give a short description of the fields in the schema:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格将简要描述模式中的字段：
- en: '| Field | Description |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `name` | Name of the expense |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 费用的名称 |'
- en: '| `amount` | The scaled amount of money |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `amount` | 货币的缩放金额 |'
- en: '| `currency` | What currency is used to represent the money |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `currency` | 用于表示货币的货币 |'
- en: '| `scaleFactor` | The scale factor used to obtain the amount |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `scaleFactor` | 用于获取金额的缩放因子 |'
- en: '| `user` | To whom the expense belongs |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `user` | 费用所属的用户 |'
- en: '| `category` | A category group that the expense belongs to |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `category` | 费用所属的分类组 |'
- en: '| `createdAt` | The date when the expense object was created |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `createdAt` | 费用对象创建的日期 |'
- en: Mongoose has an interesting feature, called `virtual attributes`. Such attributes
    are not persisted in the database but are really helpful in many scenarios. We
    are going to use a virtual attribute called `value`, which is going to represent
    the monetary value of the `amount` attribute.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 有一个有趣的功能，称为 `虚拟属性`。这些属性不会持久化到数据库中，但在许多场景中非常有用。我们将使用一个名为 `value` 的虚拟属性，它将表示
    `amount` 属性的货币价值。
- en: 'Append the following lines of code before the model compilation:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型编译之前添加以下代码行：
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Like all attributes, virtual attributes can have `getters` and `setters`. We
    are going to piggyback the setter and add our own logic, which will scale the
    value with a give factor and obtain the desired amount. Also, when getting the
    virtual `value` attribute, we are going to return the correct monetary representation,
    dividing the stored amount by the corresponding scale factor.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有属性一样，虚拟属性可以有 `getters` 和 `setters`。我们将利用 `setter` 并添加自己的逻辑，这将根据给定的因子缩放值并获取所需的金额。此外，当获取虚拟的
    `value` 属性时，我们将返回正确的货币表示形式，通过将存储的金额除以相应的缩放因子。
- en: By default, when doing a query, Mongoose will not return `virtual attributes`,
    but we have overwritten the default options for the schema to return all `virtual
    attributes` when using the `.toJSON()` and `.toObject()` methods.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当进行查询时，Mongoose 不会返回 `virtual attributes`，但我们已覆盖了模式默认选项，以便在使用 `.toJSON()`
    和 `.toObject()` 方法时返回所有 `virtual attributes`。
- en: Describing the expense module functionality
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述费用模块功能
- en: Next, we are going to write some tests for the expense module in order to define
    the required behavior of the module.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为费用模块编写一些测试用例，以定义模块所需的行为。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In order to go faster, we are only going to define a few test cases. The rest
    of the CRUD test cases are the same as in earlier implementations for different
    modules. For reference, you can check out the full code base for the test suite
    at the following link: [https://www.packtpub.com/](https://www.packtpub.com/).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快速度，我们只定义几个测试用例。其余的 CRUD 测试用例与早期实现中不同模块的相同。为了参考，您可以在以下链接查看测试套件的完整代码库：[https://www.packtpub.com/](https://www.packtpub.com/).
- en: 'Let''s create a file called `tests/integration/expense.test.js`. We are going
    to define the most important test cases:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `tests/integration/expense.test.js` 的文件。我们将定义最重要的测试用例：
- en: 'When creating an expense, a value and a category must be present. The value
    should be a number that accepts decimal values too:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建费用时，必须存在一个值和一个类别。该值应该是一个可以接受小数的数字：
- en: '[PRE54]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We should be able to get all of the user''s expenses from the database:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该能够从数据库中获取所有用户的费用：
- en: '[PRE55]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If necessary, we should get only the expenses for a given category. This will
    come in handy when we want to display expenses for a certain category:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，我们应该只获取给定类别的费用。当我们要显示特定类别的费用时，这会很有用：
- en: '[PRE56]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding code tests the creation of an expense and that the virtual value
    attribute works correctly. It also checks whether an invalid token is sent and
    that the application will treat it accordingly. Now the fun part starts with the
    `balance` functionality, which should return an aggregated value of the expenses
    for different scenarios.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码测试了费用的创建以及虚拟值属性是否正确工作。它还检查是否发送了无效的令牌，并且应用程序将相应地处理它。现在，有趣的部分开始了，即 `balance`
    功能，它应该返回不同场景下费用的聚合值。
- en: CRUD operations for expenses
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 费用的 CRUD 操作
- en: 'Next, we are going to implement the CRUD operations for expenses one by one.
    Before going any further, we are going to create a new routes file called `app/routes/expenses.js`
    and add the following lines of code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐一实现费用的 CRUD 操作。在继续之前，我们将创建一个新的路由文件名为 `app/routes/expenses.js` 并添加以下代码行：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We added a bearer authentication for each route. You could have created a single
    route to catch all the resources that need authentication, but, in this way, you
    will have fine-grained control for each route.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个路由添加了 bearer 认证。您本可以创建一个单独的路由来捕获所有需要认证的资源，但这样，您将能够对每个路由进行更精细的控制。
- en: Create expense
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建费用
- en: 'Let''s create the controller that the routes file needs—`app/controllers/expense.js`—and
    add the create expense logic:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建路由文件所需的控制器——`app/controllers/expense.js`——并添加创建费用的逻辑：
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The expense that we want to create should be for the token owner. Hence, we
    explicitly set the user property to the authenticated user's ID.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建的费用应该是令牌所有者的。因此，我们明确地将用户属性设置为认证用户的 ID。
- en: Get expense by ID
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 ID 获取费用
- en: 'The get one and update expense logic uses an expense instance to display or
    update it. Due to this, we are only going to add a single logic that retrieves
    an expense by ID. Append the following lines of code to the controller file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 获取单个费用和更新费用的逻辑使用费用实例来显示或更新它。因此，我们只添加一个通过 ID 获取费用的逻辑。将以下代码行追加到控制器文件中：
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Because we are not going to do a final operation here, we only set the expense
    to be present on the request object and call the next handler in the route pipeline.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这里我们不会进行最终操作，所以我们只设置费用在请求对象中存在，并调用路由管道中的下一个处理程序。
- en: Get one expense
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取单个费用
- en: 'We are going to extend "get expense by ID" and just respond with a JSON representation
    of the resource. Getting an expense logic should be a few lines of code appended
    to the controller file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展“通过 ID 获取费用”并仅响应资源的 JSON 表示。获取费用的逻辑应该是追加到控制器文件中的几行代码：
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Get all expenses
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取所有费用
- en: 'When getting all expenses, we need to take a different approach—one that enables
    us to filter them by a specific query. Expenses should also be returned for a
    specific category. We don''t need to implement different search logics for all
    these scenarios. Instead, we can create one that will wrap around our needs:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取所有支出时，我们需要采取不同的方法——一种能够使我们能够通过特定查询过滤它们的方法。支出还应返回特定类别的支出。我们不需要为所有这些场景实现不同的搜索逻辑。相反，我们可以创建一个将围绕我们的需求：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Before querying the database using Mongoose to retrieve the necessary data,
    we construct a query variable that will hold all our criteria. One nice thing
    to note here is that once again we used the query builder object provided by Mongoose.
    Expenses are going to be stored in a greater number in MongoDB. Hence, we add
    a `limit` and a `skip` to retrieve only a limited set of data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Mongoose查询数据库以检索必要数据之前，我们构建一个查询变量，该变量将包含所有我们的标准。这里值得注意的一个好现象是，我们再次使用了Mongoose提供的查询构建器对象。支出在MongoDB中将以更大的数量存储。因此，我们添加了`limit`和`skip`来检索有限的数据集。
- en: Expenses can be queried using a date range. Due to this reason, the `createdAt`
    property will be progressively extended to match only a set of expenses in a period.
    Expenses should also be returned in a chronological order; newly added expenses
    should be returned first.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用日期范围查询支出。由于这个原因，`createdAt`属性将逐步扩展以匹配特定时间段内的支出集合。支出还应按时间顺序返回；新添加的支出应首先返回。
- en: To have all the necessary information about each expense, we are going to populate
    the category property of an expense with the appropriate category object from
    the database.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取每个支出的所有必要信息，我们将使用数据库中的适当类别对象来填充支出的类别属性。
- en: Update expense
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新支出
- en: 'Append the following code for the update logic to the controller file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下更新逻辑的代码添加到控制器文件中：
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The update logic uses the expense instance set on the request object by the
    callback trigger for the expense ID parameter.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 更新逻辑使用回调触发器为支出ID参数设置的请求对象上的支出实例。
- en: Delete expense
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除支出
- en: 'In order to delete an expense, we just remove the expense instance from the
    database, using the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除支出，我们只需使用以下代码从数据库中删除支出实例：
- en: '[PRE63]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Getting the expense balance
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取支出余额
- en: Let's get back to the expense model and extend it with balance calculation.
    In order to get the balance in different scenarios, we are going to use the Aggregation
    framework from MongoDB. Aggregated data means computed results from operations
    on data from collections.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到支出模型，并使用余额计算来扩展它。为了在不同场景下获取余额，我们将使用MongoDB的聚合框架。聚合数据意味着从集合中的数据操作得到的计算结果。
- en: Mongo provides a complex set of operations to perform on datasets. Because we
    are using Mongoose, we have access to `Model.aggregate()`, which will help us
    create the aggregation pipelines.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo提供了一套复杂的操作来对数据集进行操作。因为我们使用Mongoose，所以我们有权访问`Model.aggregate()`，这将帮助我们创建聚合管道。
- en: Keep in mind that the data returned from aggregation is in the form of plain
    JavaScript objects, not Mongoose documents. This is due to the fact that any shape
    of document can be returned when using aggregations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，聚合返回的数据是以纯JavaScript对象的形式，而不是Mongoose文档。这是由于在使用聚合时，可以返回任何形状的文档。
- en: 'Append the following code before the expense model compilation:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译支出模型之前添加以下代码：
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The preceding static `.getBalance()` method will calculate the current balance
    in different scenarios, as described in the test case. The `.aggregate()` method
    goes through multiple stages. The first one is a match stage that will select
    all the documents for our defined query. The result from the match is sent to
    the group stage, where the documents are grouped by a specified identifier.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述静态`.getBalance()`方法将根据测试用例中描述的不同场景计算当前余额。`.aggregate()`方法会经过多个阶段。第一个阶段是匹配阶段，它将选择所有符合我们定义查询的文档。匹配的结果被发送到分组阶段，在这里，文档根据指定的标识符进行分组。
- en: In addition, pipeline stages can use operators to perform different tasks, for
    example, calculating the balance in our scenario. We are using an accumulator
    operator called `$sum` that returns a numerical value for each group.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，管道阶段可以使用运算符执行不同的任务，例如，在我们的场景中计算余额。我们使用一个累加运算符`$sum`，它为每个组返回一个数值。
- en: In the group stage, the `_id` field is mandatory, but you can specify a null
    value for it to calculate all the values for the input documents of the pipeline.
    The group operator has a limit of 100 megabytes of RAM, but you can set it to
    use the disk to write temporary files. To set this option, use Mongoose and take
    a look at the `.allowDiskUse()` method.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在分组阶段，`_id`字段是必需的，但你可以为它指定一个null值来计算管道输入文档的所有值。分组操作器的RAM限制为100兆字节，但你可以将它设置为使用磁盘来写入临时文件。要设置此选项，请使用Mongoose并查看`.allowDiskUse()`方法。
- en: 'Add the missing controller function, `app/controller/expense`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 添加缺失的控制器函数，`app/controller/expense`：
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Implementing the Angular client application
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Angular客户端应用程序
- en: We have reached the point in our project at which we will start integrating
    the AngularJS application. This chapter will take a different approach at building
    the desired application. An ideal application should be structured in a modular
    way, each module addressing a specific functionality.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们已经到达了开始集成AngularJS应用程序的阶段。本章将采用不同的方法来构建所需的应用程序。理想的应用程序应该以模块化的方式构建，每个模块处理特定的功能。
- en: You are probably already familiar with the component-based approach when building
    Angular apps. What this means is that we will create small modules that encapsulate
    specific functionalities. This enables us to add functionality incrementally;
    imagine adding vertical blocks onto the application.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建Angular应用程序时，你可能已经熟悉了基于组件的方法。这意味着我们将创建小的模块，这些模块封装了特定的功能。这使得我们可以增量地添加功能；想象一下向应用程序添加垂直块。
- en: For this to work, we need to create a main block that glues everything together,
    pulling all features and modules together. Keep your main app module thin and
    move the rest of the logic to application modules.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这生效，我们需要创建一个主要块来将所有东西粘合在一起，将所有功能和模块拉在一起。保持你的主应用程序模块轻薄，并将其余逻辑移动到应用程序模块中。
- en: One rule that I like to follow is to keep my folder structure as flat as possible.
    I always try to reduce the level of the folders so that I can locate code and
    functionality quickly. If your module grows too big, you can either split it up
    or add subfolders.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢遵循的一条规则是尽可能保持我的文件夹结构扁平。我总是试图降低文件夹的层级，以便我可以快速定位代码和功能。如果你的模块变得太大，你可以将其拆分或添加子文件夹。
- en: Bootstrapping the project
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目初始化
- en: 'Let''s get started and create a `public/package.json` file. We are going to
    use `npm` to install our dependencies for the frontend part of the project. The
    `package.json` file will have the following content:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个`public/package.json`文件。我们将使用`npm`来安装项目前端部分的依赖项。`package.json`文件将包含以下内容：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run this command to install all the dependencies:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令以安装所有依赖项：
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: After a successful installation, create a folder called `public/src`. This folder
    will hold the main Angular application. Inside this folder, we will create our
    modules folder and application files.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，创建一个名为`public/src`的文件夹。这个文件夹将包含主要的Angular应用程序。在这个文件夹内，我们将创建我们的模块文件夹和应用文件。
- en: 'Create your main app component file, called `public/src/app.component.ts`,
    and follow these steps to create the final version of the file:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的主应用程序组件文件，命名为`public/src/app.component.ts`，并按照以下步骤创建文件的最终版本：
- en: 'Add the necessary dependencies:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加必要的依赖项：
- en: '[PRE68]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Configure your routes:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置你的路由：
- en: '[PRE69]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We defined a default path that will redirect to the `expenses` view, displaying
    all the entries to the user. There is also a `Signin` and `register` route available.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了一个默认路径，该路径将重定向到`expenses`视图，显示所有条目给用户。还有一个`Signin`和`register`路由可用。
- en: 'Add the component annotation:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件注解：
- en: '[PRE70]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Define the component''s class:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义组件的类：
- en: '[PRE71]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If an unauthorized call is made, we redirect the user to the `Signin` route
    in order to authenticate itself with valid credentials.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生未经授权的调用，我们将用户重定向到`Signin`路由，以便使用有效凭据进行身份验证。
- en: Registering users
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册用户
- en: Our application should support user registration. We already have the backend
    logic for this functionality. Now, all we have to do is tie it up with our Angular
    application. To do this, we are going to create a generic module called `auth`,
    which will be used for both registering and authenticating users.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序应该支持用户注册。我们已经有这个功能的后端逻辑。现在，我们只需要将其与我们的Angular应用程序结合起来。为此，我们将创建一个名为`auth`的通用模块，该模块将用于注册和验证用户。
- en: The auth service
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证服务
- en: 'We will continue with the `auth` service, which will hold all the communication
    logic with the Node.js backend application. Create a file called `public/src/auth/services/auth.service.ts`
    and implement the entire logic of the service by following these steps:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用`auth`服务，该服务将包含与Node.js后端应用程序的所有通信逻辑。创建一个名为`public/src/auth/services/auth.service.ts`的文件，并按照以下步骤实现服务的整个逻辑：
- en: 'Import the dependencies:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入依赖项：
- en: '[PRE72]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Define the service class:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义服务类：
- en: '[PRE73]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add the `signin()` method:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`signin()`方法：
- en: '[PRE74]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Set the current user:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置当前用户：
- en: '[PRE75]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We want to expose a simple function to set the next value of the `currentUser`
    Observable.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望公开一个简单的函数来设置`currentUser`可观察对象的下一个值。
- en: 'Initialize the session:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化会话：
- en: '[PRE76]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When the application reloads, we want to retrieve the current user from the
    local storage in order to restore the session. One improvement you can add is
    to check whether the token has expired.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当应用程序重新加载时，我们希望从本地存储中检索当前用户以恢复会话。你可以添加的一个改进是检查令牌是否已过期。
- en: 'Append the helper methods:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加辅助方法：
- en: '[PRE77]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The preceding functions are simple abstractions for the `stringify` and `parse`
    JSON methods.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数是`stringify`和`parse` JSON方法的简单抽象。
- en: Register component
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄存器组件
- en: 'Create the appropriate component file, `public/src/auth/components/register.component.ts`,
    with the following lines of code in it:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 创建适当的组件文件，`public/src/auth/components/register.component.ts`，其中包含以下代码行：
- en: '[PRE78]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When the `register` method is called, we simply try to register our user using
    the `AuthService`. Error handling is not added in the preceding code. Only a simple
    log will be printed on the browser''s console. Let''s add the template:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`register`方法时，我们只是尝试使用`AuthService`注册我们的用户。前面的代码中没有添加错误处理。只会在浏览器的控制台中打印一个简单的日志。让我们添加模板：
- en: '[PRE79]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The register component is pretty straightforward. We are defining a simple register
    function that will use the auth service's `register` method. All the necessary
    fields also can be found in the `template` property.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器组件相当简单。我们正在定义一个简单的寄存器函数，该函数将使用认证服务的`register`方法。所有必要的字段也可以在`template`属性中找到。
- en: Sign-in-user component
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录用户组件
- en: In order to authenticate users, we have added some extra functionality to the
    auth service to enable us to sign in a user. Because we are not persisting the
    state of a user on the backend—in other words, our backend is stateless—we have
    to store the current state of the user on the frontend.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了认证用户，我们在认证服务中添加了一些额外的功能，使我们能够登录用户。因为我们没有在后端持久化用户的会话状态——换句话说，我们的后端是无状态的——我们必须在前端存储用户的当前状态。
- en: Remember that we created an endpoint that will issue us a token for a valid
    username-and-password tuple. We are going to use that endpoint to retrieve a token
    that will grant us access to the rest of the API endpoints.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们创建了一个端点，该端点将为我们提供一个有效的用户名和密码对的令牌。我们将使用该端点来检索一个令牌，该令牌将使我们能够访问API的其余端点。
- en: 'Our sign-in component is fairly simple and it''s really reused from the previous
    chapter, but let''s refresh our memory and take a look at it. `SigninComponent`
    is found under `public/src/auth/components/signin.component.ts`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录组件相当简单，并且确实是从上一章中复用的，但让我们刷新一下记忆并看看它。`SigninComponent`位于`public/src/auth/components/signin.component.ts`：
- en: '[PRE80]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Just as in `RegisterComponent`, we are using local variables for our fields.
    Using `AuthService`, we try to authenticate our user. We are not really focusing
    on handling errors, but, if the user successfully authenticates, we want to navigate
    to the `root` path and set the current user.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`RegisterComponent`中一样，我们为我们的字段使用局部变量。使用`AuthService`，我们尝试认证我们的用户。我们并不真正关注错误处理，但如果用户成功认证，我们希望导航到`root`路径并设置当前用户。
- en: Common functionalities
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用功能
- en: 'There are a few functionalities that we used earlier and some extra functionality
    to consider before jumping further into development. For example, we used a common
    headers definition, found under `public/src/common/headers.ts`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步开发之前，我们需要考虑一些之前使用过的功能和一些额外的功能。例如，我们使用了一个常见的头定义，位于`public/src/common/headers.ts`下：
- en: '[PRE81]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is simply a way to define constants and use them across the application
    without repeating yourself. So, basically, we imported `Headers` from Angular
    2 and created a new instance. You can easily add extra fields to this header instance
    using the `append()` method, like this for example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是一种定义常量并在整个应用程序中使用它们而不重复的方法。所以，基本上，我们导入了Angular 2中的`Headers`并创建了一个新实例。你可以很容易地使用`append()`方法向这个头实例添加额外的字段，例如：
- en: '[PRE82]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now there a few other things to consider:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在还有一些其他事情需要考虑：
- en: When asking the server for resources through the API, we should send the required
    Bearer token
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过API向服务器请求资源时，我们应该发送所需的Bearer令牌
- en: If a user makes a call and the server responds with a status code that equals
    401—unauthorized—we should redirect the user to the sign-in page
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户发出调用，并且服务器以状态码401（未经授权）响应，我们应该将用户重定向到登录页面
- en: Let's see what we can do about the preceding list.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能对前面的列表做些什么。
- en: Custom HTTP service
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义HTTP服务
- en: We did something similar in the previous chapter when we created a custom HTTP
    service to make calls to the Express backend application. But we need a few extra
    things, such as attaching the token to each call that is made through this service
    in order to identify the user.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建自定义HTTP服务以调用Express后端应用程序时，我们在上一章中做了类似的事情。但是我们需要一些额外的东西，比如将令牌附加到通过此服务发出的每个调用中，以识别用户。
- en: 'Remember that we stored our user''s token inside the browser''s `LocalStorage`.
    This should be fairly simple to retrieve and I think we can even add it inside
    the service. Let''s get started and create a new file called `public/src/auth/services/auth-http.ts`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们将在浏览器的`LocalStorage`中存储用户的令牌。这应该相当简单，我认为我们甚至可以在服务中添加它。让我们开始，创建一个名为`public/src/auth/services/auth-http.ts`的新文件：
- en: '[PRE83]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'So this is our custom `HttpAuth` service, which exposes a few public methods,
    the same as in the previous chapter. Now the changes occur in the private `request()`
    method:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们自定义的`HttpAuth`服务，它公开了一些公共方法，与上一章相同。现在变化发生在私有的`request()`方法中：
- en: '[PRE84]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Before we make a call, we attach the necessary token to the `Authorization`
    header. The token is stored in the browser's storage, so we use the `getToken()`
    method to retrieve it. If the request is unauthorized, we push it through our
    unauthorized data stream, which holds requests that failed authentication.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发出调用之前，我们将必要的令牌附加到`Authorization`头。令牌存储在浏览器的存储中，因此我们使用`getToken()`方法来检索它。如果请求未经授权，我们将它推送到我们的未经授权数据流中，该数据流包含失败的认证请求。
- en: 'The `getToken()` method has a very simple implementation:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`getToken()`方法有一个非常简单的实现：'
- en: '[PRE85]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Using a single export file
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单个导出文件
- en: 'We can add an `index.ts` file in the root of each module folder in order to
    export all public members. In the `auth` module, we can have a file called `public/src/auth/index.ts`
    with the following content:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在每个模块文件夹的根目录中添加一个`index.ts`文件，以便导出所有公共成员。在`auth`模块中，我们可以有一个名为`public/src/auth/index.ts`的文件，其内容如下：
- en: '[PRE86]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This technique will be used for each module and it's not going to be covered
    any further.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术将用于每个模块，并且不会进一步介绍。
- en: The categories module
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别模块
- en: The category module will hold all of the logic that is necessary to perform
    CRUD operations on categories and communicate with the backend through an Angular
    service.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 类别模块将包含执行类别CRUD操作和通过Angular服务与后端通信所需的所有逻辑。
- en: Category service
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别服务
- en: 'The category service is going to be fairly simple, it''s only going to manage
    the CRUD operations on categories. The following steps will describe the process
    to achieve this:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 类别服务将相对简单，它只将管理类别的CRUD操作。以下步骤将描述实现此过程的方法：
- en: Create a file called `public/app/categories/category.service.js`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`public/app/categories/category.service.js`的文件。
- en: 'Add the necessary business logic:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加必要的业务逻辑：
- en: '[PRE87]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As you can see, the service will expose all the methods needed for the CRUD
    operations. Each method will return an observable, which will emit a single response.
    We are also using our own `AuthHttp` in order to check whether a request is unauthorized
    and the user needs to sign in.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该服务将公开所有CRUD操作所需的方法。每个方法都将返回一个可观察对象，它将发出单个响应。我们还使用自己的`AuthHttp`来检查请求是否未经授权，用户需要登录。
- en: Note that, besides the returned observable, the `getAll()` method also updates
    the `categories` data stream in order to push the new values to each subscriber.
    This will come in handy when multiple subscribers use the same data source to
    display data in their own way.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了返回的可观察对象外，`getAll()`方法还更新了`categories`数据流，以便将新值推送到每个订阅者。当多个订阅者使用相同的数据源以自己的方式显示数据时，这将非常有用。
- en: The categories component
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别组件
- en: We are going to create a component that is used when we navigate to the `/categories`
    path, which we configured at the beginning of the chapter. The final version of
    `AppComponent` was used earlier in the chapter.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个组件，用于我们在本章开头配置的 `/categories` 路径。本章早些时候使用了 `AppComponent` 的最终版本。
- en: '`CategoriesComponent` will use two other components to create a new category
    and list all the available entries from the system. Let''s create a new file,
    `public/src/category/categories.component.ts`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoriesComponent` 将使用另外两个组件来创建一个新的类别并列出系统中的所有可用条目。让我们创建一个新的文件，`public/src/category/categories.component.ts`：'
- en: '[PRE88]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The previous component does not have much going on; we have no moving parts.
    We just import the two necessary components and include them in the template.
    Let's continue by implementing the other two components from this context.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的组件没有太多内容；我们没有移动部件。我们只是导入两个必要的组件并将它们包含在模板中。让我们继续实现此上下文中的其他两个组件。
- en: Create a new category
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的类别
- en: 'A user must be able to interact with our application and add new categories,
    so we are going to create a separate component for this. Let''s break it down
    into these steps:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须能够与我们的应用程序交互并添加新类别，因此我们将为此创建一个单独的组件。让我们将其分解为以下步骤：
- en: First, create the view file, called `public/src/category/components/category-create.component.ts`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `public/src/category/components/category-create.component.ts` 的视图文件。
- en: 'Import the necessary dependencies:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的依赖项：
- en: '[PRE89]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Define the component annotation, which includes the template:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义组件注解，其中包含模板：
- en: '[PRE90]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Add the component''s class:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件的类：
- en: '[PRE91]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Each time we add a new category, we want to broadcast the new item to all subscribers.
    For example, the categories list should have the new entry displayed. After we
    have successfully created the category, the form should be reset to its initial
    value.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们添加一个新的类别，我们希望向所有订阅者广播新项目。例如，类别列表应该显示新条目。在我们成功创建类别后，表单应该重置到其初始值。
- en: List all categories
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出所有类别
- en: Now that we can create categories, we should be able to list them for the user.
    In order to list the categories, we are going to use two components, one component
    to iterate over the data from the server and another to display information about
    a category.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建类别，我们应该能够为用户列出它们。为了列出类别，我们将使用两个组件，一个组件用于迭代来自服务器的数据，另一个用于显示类别的信息。
- en: The latter component will also have encapsulated the update functionality. So
    anytime the user can change information about a category and persist the changes
    on the backend.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 后者组件也将封装更新功能。因此，用户可以随时更改类别的信息，并在后端持久化更改。
- en: 'Let''s create a new component file for the categories listing, called `public/src/category/components/category-list.component.ts`,
    and follow these steps:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的组件文件用于类别列表，名为 `public/src/category/components/category-list.component.ts`，并遵循以下步骤：
- en: 'Import the necessary modules:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE92]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We imported a `CategoryComponent`, which doesn't exist at the moment, but we
    should already have an idea of how we are going to use our component.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们导入了 `CategoryComponent`，但目前它还不存在，但我们应该已经对我们的组件如何使用有一个想法。
- en: 'Define the template and component annotation:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义模板和组件注解：
- en: '[PRE93]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We are using the `ngFor` directive to render the `category` template for each
    item from the list.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在使用 `ngFor` 指令来渲染列表中每个项目的 `category` 模板。
- en: 'Declare the component''s class:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明组件的类：
- en: '[PRE94]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: When the component is initialized, we are going to retrieve all the available
    categories from the backend using our `CategoryService`. Besides fetching all
    the necessary data, we also subscribe when a new category is created. Basically,
    we subscribe to a category data stream.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件初始化时，我们将使用我们的 `CategoryService` 从后端检索所有可用的类别。除了获取所有必要的数据外，我们还订阅了创建新类别时的情况。基本上，我们订阅了类别数据流。
- en: Each time a new category is added, it is going to be pushed to the `categories`
    list and displayed to the user. In order to render the information for the user,
    we are going to have a component for a single category.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 每次添加新的类别时，它将被推送到 `categories` 列表并显示给用户。为了向用户渲染信息，我们将有一个用于单个类别的组件。
- en: When the component is destroyed, we want to unsubscribe from the data stream;
    otherwise, notifications will be pushed down the data stream.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被销毁时，我们希望取消订阅数据流；否则，通知将被推送到数据流中。
- en: The category component
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别组件
- en: 'To display information for a single category from our list, we are going to
    create a new component, called `public/src/category/components/category.component.ts`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示我们列表中单个类别的信息，我们将创建一个新的组件，称为 `public/src/category/components/category.component.ts`：
- en: '[PRE95]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This category gets input data to display information about a category. It also
    triggers an event when the **Save** button is clicked on and the form is submitted.
    We use our service to communicate with the server and persist the changes in MongoDB.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别获取输入数据以显示关于类别的信息。当点击**保存**按钮并提交表单时，它还会触发一个事件。我们使用我们的服务与服务器通信并在MongoDB中持久化更改。
- en: The expenses module
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支出模块
- en: In this module, we are going to treat functionality related to expenses. This
    is going to be the main module used by our users in the frontend application,
    because here they will add new expenses and store them in MongoDB through our
    backend API.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，我们将处理与支出相关的功能。这将是前端应用中用户使用的主要模块，因为在这里他们将添加新的支出并通过我们的后端API将它们存储在MongoDB中。
- en: Expense service
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支出服务
- en: 'The expense service will implement CRUD operations on expenses and one other
    important feature of it is getting the balance of expenses. In order to create
    the expense service, we will follow these steps:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 支出服务将实现支出上的CRUD操作，并且它的重要特性之一是获取支出的余额。为了创建支出服务，我们将遵循以下步骤：
- en: Create a file called `public/src/expense/expense.service.js`.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `public/src/expense/expense.service.js` 的文件。
- en: 'Define the main logic of the service:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义服务的主要逻辑：
- en: '[PRE96]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We just defined a list of exposed methods. We also exposed a few public properties,
    for the filter that can be updated externally, like the expense, and an Observable
    expenses data stream.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一个公开方法的列表。我们还公开了一些公共属性，以便外部更新过滤器，例如支出，以及一个可观察的支出数据流。
- en: 'Now let''s follow the methods one by one and append their actual implementation:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐个跟踪方法并附加它们的实际实现：
- en: 'Creating an expense:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建支出：
- en: '[PRE97]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Getting all expenses matching a given query criteria:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取与给定查询标准匹配的所有支出：
- en: '[PRE98]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The preceding method uses a `serializeQuery()` method, which will transform
    our criteria into `query string` parameters. We are doing this to filter our expenses
    by a given criteria. Also, rather than returning an Observable from the HTTP call,
    we update our `expenses` data stream to notify all subscribers of the newly available
    data.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述方法使用 `serializeQuery()` 方法，该方法将我们的标准转换为 `查询字符串` 参数。我们这样做是为了根据给定的标准过滤支出。而且，我们不是从HTTP调用返回一个可观察的，而是更新我们的
    `expenses` 数据流，以通知所有订阅者新可用的数据。
- en: 'Getting the balance of the expenses matching a query criteria:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取与查询标准匹配的支出余额：
- en: '[PRE99]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We use the same `serializeQuery()` function to transform our criteria into a
    `query string`.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用相同的 `serializeQuery()` 函数将我们的标准转换为 `查询字符串`。
- en: 'Updating an expense by ID with new data:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过ID使用新数据更新支出：
- en: '[PRE100]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Filter expenses
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤支出
- en: 'As a start, we are going to implement expenses filtering. We just want to have
    all the necessary blocks in order to list the expenses properly. Basically, this
    component will be a simple form with three inputs: start date, end date, and category.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开始，我们将实现支出过滤。我们只想有所有必要的块来正确列出支出。基本上，这个组件将是一个简单的表单，包含三个输入：开始日期、结束日期和类别。
- en: Using these simple criteria, we are going to filter our expenses on the backend.
    Remember, we need these in the `query` params so that the correct data is retrieved
    from the `expenses` collection.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些简单的标准，我们将在后端过滤我们的支出。记住，我们需要这些在 `query` 参数中，以便从 `expenses` 集合中检索正确的数据。
- en: This component will rely on the `CategoryService` and subscribe to the categories
    data stream. It will also push new values down the filter stream to notify each
    subscriber to filter the expenses.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件将依赖于 `CategoryService` 并订阅类别数据流。它还将向下推送新的值到过滤器流中，以通知每个订阅者过滤支出。
- en: 'Let''s follow these steps to implement our component:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循以下步骤来实现我们的组件：
- en: 'Import the modules:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入模块：
- en: '[PRE101]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Define our component''s template:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们组件的模板：
- en: '[PRE102]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Append the `ExpenseFilterComponent` class:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ExpenseFilterComponent` 类：
- en: '[PRE103]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'What will happen on initialization:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化时会发生什么：
- en: '[PRE104]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'When the component is destroyed:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件被销毁时：
- en: '[PRE105]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We have to unsubscribe from the data stream. We used a subscriptions list in
    order to hold all of them in one place and later on iterate over the subscriptions
    and dispose of them.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们必须取消订阅数据流。我们使用一个订阅列表来在一个地方保存所有这些，然后稍后遍历订阅并销毁它们。
- en: 'How we update the filter stream:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何更新过滤器流：
- en: '[PRE106]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Resetting the filter:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置过滤器：
- en: '[PRE107]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: When the component initializes, we subscribe to the `categories` data stream.
    If the user clicks on the `filter` button, we'll update the `filter` so that each
    subscriber can get the new filter criteria.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件初始化时，我们订阅 `categories` 数据流。如果用户点击 `filter` 按钮，我们将更新 `filter`，以便每个订阅者都可以获取新的过滤标准。
- en: In order to reset everything, we can use the `reset` button and get back to
    the initial state. We can then notify all subscribers that we can retrieve all
    expenses once again.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重置一切，我们可以使用 `reset` 按钮，回到初始状态。然后我们可以通知所有订阅者，我们可以再次检索所有支出。
- en: Add a new expense
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的支出
- en: Because adding expenses will be a fairly well used feature, we are going to
    add the necessary logic into the same view and controller used to list expenses.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 由于添加支出将是一个相当常用的功能，我们将把必要的逻辑添加到与列出支出相同的视图和控制台中。
- en: Remember that, in order to add a new expense, it must be included in a category.
    So we need a list of categories loaded into the component. This should be similar
    to what we did earlier in `ExpenseFilterComponent`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，为了添加新的支出，它必须包含在一个类别中。因此，我们需要将类别列表加载到组件中。这应该类似于我们在 `ExpenseFilterComponent`
    中之前所做的那样。
- en: 'Let''s go through the following steps to implement the add expense functionality:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来实现添加支出的功能：
- en: Create a new file, called `public/src/expense/components/expense-create.component.ts`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，命名为 `public/src/expense/components/expense-create.component.ts`。
- en: 'Import the necessary modules:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE108]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Append the annotation with the template:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下模板添加注释：
- en: '[PRE109]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Add the class:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下类：
- en: '[PRE110]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'On initialization, we subscribe to the categories data stream and store the
    subscription so that we can dispose of it later on:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化时，我们订阅类别数据流并将订阅存储起来，以便我们可以在以后取消订阅：
- en: '[PRE111]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Unsubscribe when the component is destroyed:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件销毁时取消订阅：
- en: '[PRE112]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: List expenses
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出支出
- en: 'To display a list of expenses, we are going to query the server for the necessary
    information and create a table with the retrieved information. For this, we are
    going to go through the following steps:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示支出列表，我们将查询服务器获取必要的信息，并创建一个包含检索信息的表格。为此，我们将执行以下步骤：
- en: Create the expenses controller file, called `public/src/expense/components/expense-list.component.ts`.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建支出控制器文件，命名为 `public/src/expense/components/expense-list.component.ts`。
- en: 'Import the service and other dependencies:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入服务和其它依赖项：
- en: '[PRE113]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Define the `expense` table in the template:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中定义 `expense` 表：
- en: '[PRE114]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Declare the `ExpenseListComponent` class:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `ExpenseListComponent` 类：
- en: '[PRE115]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Subscribe to all data streams on initialization:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化时订阅所有数据流：
- en: '[PRE116]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Dispose of subscriptions when the component is destroyed:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件销毁时取消订阅：
- en: '[PRE117]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We mostly use streams of data to display information to the user. When a new
    expense is created, we just get notified and update the list of expenses. If a
    new set of expenses is loaded, the list is updated with the new values. We also
    subscribe to the change of filter so that we can fetch data from the backend using
    that filter.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要使用数据流来向用户显示信息。当创建新的支出时，我们只是得到通知并更新支出列表。如果加载了新的支出集，列表将使用新值更新。我们还订阅了过滤器的变化，以便我们可以使用该过滤器从后端获取数据。
- en: Display balance
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示平衡
- en: We want to display an accumulated value from the expenses amount. When we filter
    the expenses, the same filter should apply to the query for the balance. For example,
    we might want to display expenses from a specific category; in such a case, the
    balance should be displayed for expenses from that category.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望显示支出的累积值。当我们过滤支出时，相同的过滤器应该应用于余额的查询。例如，我们可能想显示特定类别的支出；在这种情况下，应该显示该类别的余额。
- en: 'Because we do all the heavy lifting on the backend and the result that we get
    through the API is nicely formatted, we only have to implement a few things to
    display the balance properly:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们都在后端做所有繁重的工作，并且通过API获取的结果格式良好，所以我们只需要实现一些功能来正确显示余额：
- en: Create a new file for the component, called `public/src/expense/components/expense-balance.component.ts`.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为组件创建一个新的文件，命名为 `public/src/expense/components/expense-balance.component.ts`。
- en: 'Implement the base class:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现基类：
- en: '[PRE118]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Retrieve the balance from the backend based on a criteria:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据标准从后端检索余额：
- en: '[PRE119]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Dispose of the subscriptions:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消订阅：
- en: '[PRE120]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Expenses component
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支出组件
- en: 'Now that we have all the necessary components, we can implement our main expenses
    component, which will use all the previously implemented child components. We
    should create a new file, called `public/src/expense/components/expenses.component.ts`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有必要的组件，我们可以实现我们的主要支出组件，它将使用之前实现的所有子组件。我们应该创建一个名为 `public/src/expense/components/expenses.component.ts`
    的新文件：
- en: '[PRE121]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The component is fairly simple, but an interesting thing happens in the `ngOnInit()`
    method when we just get all the categories and set the filter to be an empty object.
    When this happens, all the rest of the components react to our actions and update
    accordingly.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件相当简单，但在我们仅获取所有类别并将过滤器设置为空对象时，`ngOnInit()` 方法中发生了一件有趣的事情。当这种情况发生时，所有其他组件都会对我们的操作做出反应并相应更新。
- en: With this, we have implemented the expenses module, which allows users to add
    expenses and see a list of all expenses. We left out some functionality, such
    as error handling, pagination, and other minor features, but you may improve this
    code as you desire.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经实现了支出模块，它允许用户添加支出并查看所有支出的列表。我们省略了一些功能，例如错误处理、分页和其他一些小功能，但你可以根据需要改进这段代码。
- en: Summary
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This brings us to the end of a rather long chapter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们结束了一个相当长的章节。
- en: We learned to manipulate monetary data with JavaScript and Node.js and how to
    store it in MongoDB. We implemented a multiuser system in which users can easily
    register and sign in at any time.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用JavaScript和Node.js操作货币数据以及如何将其存储在MongoDB中。我们实现了一个多用户系统，用户可以轻松地在任何时间注册和登录。
- en: We exposed most of our backend functionality through an API. We used a stateless
    authentication mechanism, granting access only by presenting a valid token.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过API公开了大部分后端功能。我们使用了一种无状态的认证机制，只有通过展示有效的令牌才能授予访问权限。
- en: In the next chapter, we are going to build a web page that is more public oriented,
    with different account types.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个更具公共导向的网页，包含不同的账户类型。
