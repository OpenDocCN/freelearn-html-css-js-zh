- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Asynchronous Programming Performance Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程性能模式
- en: A key strength of JavaScript runtimes is the event loop, which couples “non-blocking
    input/output” within a single-threaded execution model. This means JavaScript
    is great for high-concurrency systems as long as they are not compute-bound systems
    (i.e., they’re IO-bound).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 运行时的一个关键优势是事件循环，它将单线程执行模型中的“非阻塞输入/输出”耦合在一起。这意味着只要不是计算密集型系统（即，它们是I/O密集型），JavaScript
    就非常适合高并发系统。
- en: 'With the asynchronous and non-blocking IO, JavaScript has strong built-ins
    to orchestrate requests. In this chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步和非阻塞 I/O，JavaScript 具有强大的内置功能来编排请求。在本章中，我们将涵盖以下主题：
- en: Sequential and parallel asynchronous operation patterns in JavaScript, both
    with Promises only and with async/await
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 中的顺序和并行异步操作模式，仅使用 Promise 和使用 async/await
- en: The cancellation and timeout of fetch requests with AbortController
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AbortController 取消和超时 fetch 请求
- en: 'Advanced asynchronous operation patterns: throttling, debouncing, and batching'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级异步操作模式：节流、防抖和批处理
- en: At the end of this chapter, you’ll be able to spot and remedy situations where
    the asynchronous operation orchestration could be improved in JavaScript.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够识别并修复 JavaScript 中异步操作编排可能需要改进的情况。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件，网址为 [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
- en: Controlling sequential asynchronous operations with async/await and Promises
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 async/await 和 Promise 控制顺序异步操作
- en: Promises were introduced in ES2015 (ES6), along with other modern data structures.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 在 ES2015（ES6）中引入，以及其他现代数据结构。
- en: For those familiar with JavaScript prior to ES2015, asynchronous behavior was
    modeled with callback-based interfaces, for example, `request(url, (error, response)
    => { /* do work with response */ })`. The key issues that Promises resolved were
    the chaining of asynchronous requests and issues around managing parallel requests,
    which we’ll cover in this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 ES2015 之前熟悉 JavaScript 的人来说，异步行为是通过基于回调的接口来模拟的，例如，`request(url, (error,
    response) => { /* do work with response */ })`。Promise 解决的关键问题是异步请求的链式调用和管理并行请求的问题，我们将在本节中介绍。
- en: ES2016 included the initial specification for the async/await syntax. It built
    on top of the Promise object in order to write asynchronous code that didn’t involve
    “Promise chains,” where different Promises are processed using the `Promise().then`
    function. Promise functionality and async/await interoperate nicely. In fact,
    calling an async function returns a Promise.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ES2016 包含了 async/await 语法的基本规范。它建立在 Promise 对象之上，以便编写不涉及“Promise 链”的异步代码，其中不同的
    Promise 使用 `Promise().then` 函数进行处理。Promise 功能和 async/await 之间很好地互操作。实际上，调用一个异步函数返回一个
    Promise。
- en: We’ll start by showing how to use Promises to manage sequential asynchronous
    operations. We’ll use the Fetch API (which returns a Promise) to load `fakestoreapi.com/auth/login`.
    Given a username and password, and based on the output, we’ll load all the relevant
    carts for that user. Subsequently, we’ll load the relevant carts for that user
    using the `fakestoreapi.com/carts/user/{userId}` endpoint. This request flow is
    visualized in the following diagram.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先展示如何使用 Promise 来管理顺序异步操作。我们将使用 Fetch API（它返回一个 Promise）来加载 `fakestoreapi.com/auth/login`。给定用户名和密码，并根据输出，我们将加载该用户的所有相关购物车。随后，我们将使用
    `fakestoreapi.com/carts/user/{userId}` 端点来加载该用户的相关购物车。此请求流程在以下图中进行了可视化。
- en: '![Figure 7.1: Sequence of /auth/login and /carts/user/{userId} requests](img/B19109_07_1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：/auth/login 和 /carts/user/{userId} 请求的序列](img/B19109_07_1.jpg)'
- en: 'Figure 7.1: Sequence of /auth/login and /carts/user/{userId} requests'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：/auth/login 和 /carts/user/{userId} 请求的序列
- en: 'We’ll start by sending a POST request to the `auth/login` endpoint. We add
    `.then((res) => res.json())`, which will wait for the initial `fetch()` output
    Promise to resolve to a “response” (hence the `res` name). We then call the `.json()`
    method on the response, which again is a Promise, which resolves to the JSON-decoded
    response body:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向 `auth/login` 端点发送 POST 请求。我们添加 `.then((res) => res.json())`，这将等待初始 `fetch()`
    输出 Promise 解析为“响应”（因此命名为 `res`）。然后我们在响应上调用 `.json()` 方法，这同样是一个 Promise，它解析为 JSON
    解码后的响应体：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Promise returned from `res.json()` can be accessed in another `.then()`
    callback, in which we parse the `token` field, which is a `jwt-decode` package.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从`res.json()`返回的Promise可以在另一个`.then()`回调中访问，在这个回调中我们解析`token`字段，它是一个`jwt-decode`包。
- en: 'We extract the `sub` field from the decoded token. This is the “subject” claim,
    which tells us which user this token is about. In the case of the `fakestoreapi`
    token, `userId` is used as the “subject” claim. We can therefore use the `sub`
    claim as the user ID for which to load the carts in our following API call to
    [https://fakestoreapi.com/carts/user/](https://fakestoreapi.com/carts/user/)`{userId}`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '我们从解码的令牌中提取`sub`字段。这是“主题”声明，它告诉我们这个令牌是关于哪个用户的。在`fakestoreapi`令牌的情况下，`userId`被用作“主题”声明。因此，我们可以使用`sub`声明作为在后续API调用中加载购物车的用户ID，即[https://fakestoreapi.com/carts/user/](https://fakestoreapi.com/carts/user/)`{userId}`:'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function can then be used as follows. Note that a password shouldn’t be
    stored in the source of a production application (as it is in this example).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以按以下方式使用。注意，密码不应该存储在生产应用的源代码中（如本例所示）。
- en: When we call the `fetchAuthUserThenCartsPromiseThen` function, it makes both
    the `/auth/login` call and then the `/carts/user/{userId}` call, which means we
    receive an array with the relevant carts for the requested user (note `userId`
    = `3`, which is the correct ID for the `kevinryan` user).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`fetchAuthUserThenCartsPromiseThen`函数时，它会执行`/auth/login`调用，然后是`/carts/user/{userId}`调用，这意味着我们收到一个包含请求用户相关购物车的数组（注意`userId`
    = `3`，这是`kevinryan`用户的正确ID）。
- en: 'Note that we’re using async/await here to “flatten” the Promise output into
    `userCartsDataPromiseThen`, which we can assert on:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用async/await来“扁平化”Promise输出到`userCartsDataPromiseThen`，我们可以对其断言：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we’ve just seen in the code that calls `fetchAuthUserThenCartsPromiseThen`,
    the key benefit of async/await over `Promise().then()` chains is that the code
    is structured more similarly to synchronous code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在调用`fetchAuthUserThenCartsPromiseThen`的代码中所看到的，async/await相对于`Promise().then()`链的关键优势是代码结构更类似于同步代码。
- en: 'In synchronous code, the output of an operation can be, for example, assigned
    to a constant:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步代码中，一个操作的输出可以是，例如，分配给一个常量：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Whereas with `Promise().then()`, the output is available only in an additional
    `.``then` callback:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 而在`Promise().then()`中，输出只能在额外的`.then()`回调中访问：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What `await` allows us to do is to structure the code as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`允许我们以以下方式结构化代码：'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One way to think of it is that `await` can unfurl Promises. A Promise’s “resolved
    value”, usually only accessible in a `Promise().then()` callback is available
    directly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一种思考方式是`await`可以展开Promise。Promise的“已解决值”，通常只能在`Promise().then()`回调中访问，可以直接访问。
- en: For sequential operations, this is very useful, since it makes the code structured
    with a set of variable assignments per async operation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于顺序操作，这非常有用，因为它使得代码结构化，每个异步操作都有一个变量赋值集。
- en: The `await` operator is available at the top level of ECMAScript modules in
    modern runtime environments as part of the ES2022 specification.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`运算符在现代运行环境中的ECMAScript模块的顶层可用，作为ES2022规范的一部分。'
- en: However, in order to use `await` inside of a function, we need to mark the function
    as `async`. This usage of `await` in `async` functions has been available since
    ES2016.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了在函数内部使用`await`，我们需要将函数标记为`async`。这种在`async`函数中使用`await`的用法自ES2016以来一直可用。
- en: Code editors and IDEs such as Visual Studio Code provide a refactor from chained
    `Promise().then()` calls to async/await. In our case, we can build a `fetchAuthUserThenCartsAsyncAwait`
    function as follows.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编辑器和IDE，如Visual Studio Code，可以将链式`Promise().then()`调用重构为async/await。在我们的情况下，我们可以构建一个`fetchAuthUserThenCartsAsyncAwait`函数，如下所示。
- en: 'Instead of using `fetch().then(res => res.json())`, we’ll first use `await
    fetch()` and then `await authResponse.json()`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用`await fetch()`而不是使用`fetch().then(res => res.json())`，然后使用`await authResponse.json()`：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now have access to `authData`. We can decode `authData.token` as before
    using the `jwt-decode` package. This gives us access to the `sub` (subject) claim,
    which is the user ID:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以访问`authData`。我们可以像之前一样使用`jwt-decode`包解码`authData.token`。这使我们能够访问`sub`（主题）声明，即用户ID：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have the relevant user ID, we can call the `/carts/user/{userId}`
    endpoint to load the user’s carts:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了相关的用户ID，我们可以调用`/carts/user/{userId}`端点来加载用户的购物车：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Given the same input data as the approach using `Promise().then()`, the loaded
    carts are the same. Note, again, that passwords and credentials should not be
    stored in source code files:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 给定与使用 `Promise().then()` 的方法相同的输入数据，加载的购物车是相同的。请注意，再次强调，密码和凭证不应存储在源代码文件中：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One difference between the approaches is that with async/await, all the variables
    are defined in a single function scope, whereas the `Promise().then()` approach
    uses multiple function scopes (for each of the callbacks passed to `.then()`).
    With a single large function scope, variable names can’t clash, which makes the
    code more verbose since, for example, each `response` object needs a qualifier
    to avoid variable name clashes, for example, `authResponse` and `userCartsResponse`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法之间有一个区别是，使用 async/await 时，所有变量都在单个函数作用域中定义，而 `Promise().then()` 方法使用多个函数作用域（对于传递给
    `.then()` 的每个回调）。使用单个大函数作用域，变量名不会冲突，这使得代码更加冗长，因为例如，每个 `response` 对象都需要一个限定符来避免变量名冲突，例如
    `authResponse` 和 `userCartsResponse`。
- en: The benefit of a single larger function scope is that all the outputs of previous
    API calls are available to subsequent ones without having to explicitly set them
    as values passed as a return in the callback passed to `.then()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单个大函数作用域的好处是，前一个 API 调用的所有输出都可用于后续调用，而无需显式地将它们作为值传递给 `.then()` 中传递的回调函数。
- en: Finally, a `fetch()`-specific example, is that since there are multiple Promises
    that require handling when doing a fetch and accessing the JSON response, the
    await approach can be a bit “noisier.”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个特定的 `fetch()` 示例是，由于在执行 `fetch` 和访问 JSON 响应时需要处理多个 Promise，因此 `await` 方法可能会有些“嘈杂”。
- en: 'See the two following samples. First, with async/await, we assign a variable
    for the fetch `response` value:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下两个示例。首先，使用 async/await，我们为 `fetch` 的 `response` 值分配一个变量：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, with `.then()`, we assign only a `data` variable and use an arrow function
    to handle the `.``json()` unfurling:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `.then()`，我们只分配一个 `data` 变量，并使用箭头函数来处理 `.json()` 展开操作：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you see, our final example is a mix of `async/await` and `Promise().then()`
    so that the most “important” parts of the code are obvious. The specifics of how
    we extract the JSON output from `fetch` are not necessarily core to our logic
    so might be better expressed with `Promise().then()`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的最终示例是 `async/await` 和 `Promise().then()` 的混合，这样代码中最“重要”的部分就显而易见了。我们从
    `fetch` 中提取 JSON 输出的具体方法并不一定是我们的逻辑核心，因此可能更好地用 `Promise().then()` 来表达。
- en: In general, this slight difference in style wouldn’t occur since parts of the
    code that are “less important,” such as how we interact with the fetch API to
    process a request to JSON, tend to be abstracted – in this case, in an HTTP client
    of some kind. We would expect that the HTTP client could handle checking `response.ok`
    and accessing the response body as parsed JSON (using `response.json()`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种风格上的细微差别不会发生，因为代码中“不那么重要”的部分，例如我们如何与 fetch API 交互以处理请求到 JSON，往往会抽象化——在这种情况下，在一个某种类型的
    HTTP 客户端中。我们预计 HTTP 客户端可以处理检查 `response.ok` 和访问解析后的 JSON 响应体（使用 `response.json()`）。
- en: We’ve now seen how to implement sequential asynchronous operations using a Promise-only
    approach, an async/await-based approach, and finally, how both the async/await
    and Promise techniques can be used together to improve code readability and performance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用仅 Promise 的方法、基于 async/await 的方法以及如何结合使用 async/await 和 Promise
    技巧来提高代码的可读性和性能。
- en: Parallel asynchronous operation patterns
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行异步操作模式
- en: A common source of bad performance is running operations sequentially that could
    be completed in parallel.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 性能不佳的一个常见原因是运行那些本可以并行完成的操作顺序执行。
- en: 'For example, a naive implementation of loading a cart and then the contained
    products would be as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个简单的加载购物车及其包含的产品实现可能如下所示：
- en: '![Figure 7.2: Load cart then each of the three products contained from fakestoreapi](img/B19109_07_2.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：从 fakestoreapi 加载购物车及其包含的三个产品](img/B19109_07_2.jpg)'
- en: 'Figure 7.2: Load cart then each of the three products contained from fakestoreapi'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：从 fakestoreapi 加载购物车及其包含的三个产品
- en: 'In this case, the operation completion time is composed of the sum of the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，操作完成时间由以下各项之和组成：
- en: Request-response time for **GET /carts/{cartId}**
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /carts/{cartId}** 的请求-响应时间'
- en: Request-response time for **GET /products/1**
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /products/1** 的请求-响应时间'
- en: Request-response time for **GET /products/2**
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /products/2** 的请求-响应时间'
- en: Request-response time for **GET /products/3**
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /products/3** 的请求-响应时间'
- en: 'There is a requirement for the `/products/{productId}` calls to be done after
    the `GET /carts/{cartId}` call completes since that’s where the product IDs are
    coming from. What isn’t required is for each product call to wait for the previous
    one to complete; the calls only depend on data from the `GET /carts/{cartId}`
    call. This is an optimization opportunity. We can start all of the `GET /products/{id}`
    API calls together. We get the following sequence:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 需要 `/products/{productId}` 调用在 `GET /carts/{cartId}` 调用完成后进行，因为产品 ID 就来自那里。不需要每个产品调用等待前一个调用完成；调用只依赖于
    `GET /carts/{cartId}` 调用的数据。这是一个优化机会。我们可以同时开始所有的 `GET /products/{id}` API 调用。我们得到以下序列：
- en: '![Figure 7.3: Load cart then each of the three products contained in parallel](img/B19109_07_3.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3：并行加载购物车及其包含的三个产品](img/B19109_07_3.jpg)'
- en: 'Figure 7.3: Load cart then each of the three products contained in parallel'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：并行加载购物车及其包含的三个产品
- en: 'In this case, the operation completion time is composed of the sum of the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，操作完成时间由以下各项的总和组成：
- en: Request-response time for **GET /carts/{cartId}**
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /carts/{cartId}** 的请求-响应时间'
- en: The longest request-response time between **GET /products/1**, **GET /products/2**,
    and **GET /products/3**
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /products/1**、**GET /products/2** 和 **GET /products/3** 之间的最长请求-响应时间'
- en: This means we’re saving the request-response time of two API calls at least.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们至少节省了两次 API 调用的请求-响应时间。
- en: JavaScript is especially well suited to these workloads since its concurrency
    model is based on an event loop. While JavaScript waits for an asynchronous operation
    to complete, it can complete other synchronous operations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 特别适合这些工作负载，因为它的并发模型基于事件循环。当 JavaScript 等待异步操作完成时，它可以完成其他同步操作。
- en: In layman’s terms, triggering an asynchronous operation in JavaScript is “cheap
    and lightweight” compared to thread-based concurrency models that are common in
    popular programming languages such as Java and C++.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 用通俗易懂的话来说，在 JavaScript 中触发异步操作与在 Java 和 C++ 等流行编程语言中常见的基于线程的并发模型相比，“便宜且轻量”。
- en: There are multiple constructs in JavaScript that allow us to convert an array
    of Promises into a Promise that resolves to an array. `Promise.all` is one such
    construct.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中有多种结构允许我们将 Promise 数组转换为解析为数组的 Promise。`Promise.all` 就是其中之一。
- en: Implementing the scenario we described earlier, where we load a cart and then
    load the relevant product details, would look as follows with `Promise.all` and
    `Promise().then`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们之前描述的场景，即加载购物车然后加载相关产品详情，使用 `Promise.all` 和 `Promise().then` 将如下所示：
- en: 'First, we need to make the API call to load the cart and extract the JSON in
    the response body:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要调用 API 来加载购物车并提取响应体中的 JSON：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then need to set up the fetching of the right product URLs once the request
    to the `/carts/{cartId}` URL has loaded. The pattern used in order to execute
    our code after the fetch completes uses `.then()` on the returned promise:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了 `/carts/{cartId}` URL 的请求，我们就需要设置正确产品 URL 的获取。在获取完成后执行我们代码的模式使用返回的 promise
    上的 `.then()`：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we’ll use `Promise.all` to load all the product URLs with `fetch`. Since
    our goal is to return both the cart *and* the products, we’ll return `{ cart }`
    as the first item in the array we’re passing to `Promise.all()`. The rest of the
    array passed to `Promise.all` will be the Promises generated by calling `fetch().then((res)
    => res.json())` on each of the product URLs. In order to do this, we use the spread
    operation (`...`) on `...productUrls.map(/* mapping function */)` in the array:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `Promise.all` 来使用 `fetch` 加载所有产品 URL。由于我们的目标是返回购物车和产品，我们将 `{ cart
    }` 作为我们传递给 `Promise.all()` 的数组中的第一个项目。传递给 `Promise.all` 的数组的其余部分将是通过对每个产品 URL
    调用 `fetch().then((res) => res.json())` 生成的 Promise。为了做到这一点，我们在数组中的 `...productUrls.map(/*
    mapping function */)` 上使用展开操作符 (`...`)：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we’re going to create an object with all the cart fields and a new
    products field based on the output of the `/``products/{id}` fetches:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个对象，包含所有购物车字段和一个基于 `/products/{id}` 获取输出的新产品字段：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can test the output of the function by loading cart ID `1`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过加载购物车 ID `1` 来测试函数的输出：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The cart is as we expect – it returns three products:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车正如我们所期望的那样——它返回了三个产品：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `products` field of our response contains the correct items in positions
    at indexes 0, 1, and 2:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们响应的 `products` 字段包含正确的项目，位于索引 0、1 和 2 的位置：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ve now seen how to leverage `Promise.all` to run multiple promises in parallel
    and handle their output with one handler.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到如何利用 `Promise.all` 并行运行多个承诺，并使用一个处理程序处理它们的输出。
- en: 'You’ll have noticed the “trick” we did by passing the `{ cart }` object in
    `Promise.all` and then extracting the first item of the resolved array as the
    previous response. This is a limitation of `Promise().then()` chaining, as mentioned
    in the *Controlling sequential asynchronous operations with async/await and Promises*
    section. Each function argument to `.then()` gets its own scope:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了我们在 `Promise.all` 中传递 `{ cart }` 对象并从中提取解析数组的第一个项作为上一个响应的“技巧”。正如在 *使用
    async/await 和 Promises 控制顺序异步操作* 部分中提到的，这是 `Promise().then()` 链接的限制，每个 `.then()`
    函数参数都有自己的作用域：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'An alternative way to write this is to store the cart in the function scope:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 写这个的另一种方法是存储购物车在函数作用域中：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This works as expected. We’ve obviously removed the actual cart and product
    fetching logic from the API, but the cart that `{ id: 1 }` relates to, which we
    resolved in the initial `Promise.resolve()` function call, is cached through the
    `.``then()` calls:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '这按预期工作。显然，我们已经从 API 中移除了实际的购物车和产品获取逻辑，但与 `{ id: 1 }` 相关的购物车，我们在初始 `Promise.resolve()`
    函数调用中解析，是通过 `.then()` 调用缓存的：'
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Another way to improve our implementation without resorting to function-scoped
    variables, which can be hard to keep track of, is to convert it to use async/await.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在不使用可能难以跟踪的函数作用域变量的情况下改进我们的实现的方法是将它转换为使用 async/await。
- en: 'Our logic would be as follows. We start by loading the cart and converting
    the JSON response body:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的逻辑如下。我们首先加载购物车并将 JSON 响应体转换为：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the cart is loaded, we proceed to fetch the relevant products by generating
    URLs based on the `cart.products` contents (mainly the `productId` field). We
    also fetch these URLs using `Promise.all`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了购物车，我们就通过根据 `cart.products` 内容（主要是 `productId` 字段）生成 URL 来获取相关产品。我们也使用
    `Promise.all` 获取这些 URL：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we can return the cart and the loaded products:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以返回购物车和加载的产品：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The implementation is equivalent to our previous, strict `Promise().then()`-based
    one, as the following checks attest:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实现与我们的之前基于严格 `Promise().then()` 的实现等效，如下检查所证明：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The benefit of using async/await in this case was, again, an increase in readability.
    The syntax gets less in the way than chained `.then()` calls and we don’t have
    to resort to either returning the first response as an item in `Promise.all([{
    cart }])` or adding a function-scoped variable that we store the cart in.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用 async/await 的好处是，再次提高了可读性。语法比链式 `.then()` 调用更不阻碍，我们不必返回 `Promise.all([{
    cart }])` 中的第一个响应作为一个项，也不必添加一个存储购物车的函数作用域变量。
- en: We’ve now seen how to leverage `Promise.all` to complete asynchronous operations
    in parallel both with a `Promise().then()`-exclusive approach and with judicious
    refactors to `async/await` to simplify the code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到如何利用 `Promise.all` 来并行完成异步操作，无论是使用 `Promise().then()` 独家方法，还是通过审慎重构为
    `async/await` 以简化代码。
- en: Next, we’ll see how we can cancel and time out requests with `AbortController`
    in JavaScript.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何使用 JavaScript 中的 `AbortController` 取消和超时请求。
- en: Asynchronous cancellation and timeouts with AbortController
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AbortController 的异步取消和超时
- en: Another source of bad performance in applications in general is doing work that’s
    not necessary. In the context of a JavaScript web application, one of the types
    of “work” that can be unnecessary (and therefore a drain on performance) is having
    HTTP requests that aren’t required any more. For example, in a photo gallery system
    or any paginated system, when moving across photos, the request for the previous
    photo might not have completed before the next one is started. In this case, the
    previous request data is not necessary any more, as we’re essentially on a completely
    different page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中性能不佳的另一个原因是执行不必要的操作。在 JavaScript 网络应用程序的上下文中，可能是不必要的“工作”（因此会降低性能）之一是存在不再需要的
    HTTP 请求。例如，在一个相册系统或任何分页系统中，当浏览照片时，上一个照片的请求可能还没有完成，下一个请求就已经开始。在这种情况下，之前的请求数据不再必要，因为我们实际上已经完全在不同的页面上。
- en: In these instances, cancelling the request might be useful.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，取消请求可能是有用的。
- en: '`AbortController` is a Web/DOM API that allows us to abort web requests. It’s
    created using its constructor, `new AbortController`, and controlling a request
    (to potentially cancel it) is done with the `AbortController().signal` value,
    which is an `AbortSignal` object.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbortController` 是一个 Web/DOM API，允许我们取消网络请求。它是通过其构造函数 `new AbortController`
    创建的，控制请求（可能取消它）是通过 `AbortController().signal` 值完成的，该值是一个 `AbortSignal` 对象。'
- en: 'We instantiate the controller using the `new AbortController()` constructor
    call. If we want to make a `fetch` call cancellable, we pass `abortController.signal`
    as the `signal` option:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `new AbortController()` 构造函数调用实例化控制器。如果我们想使 `fetch` 调用可取消，我们将 `abortController.signal`
    作为 `signal` 选项传递：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we want to cancel the `fetch` request, we can then call `abortController.cancel`.
    We’ll add this as a `cancel` function on the `fetchWithCancel` returned output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想取消 `fetch` 请求，我们可以调用 `abortController.cancel`。我们将将其作为 `cancel` 函数添加到 `fetchWithCancel`
    返回的输出中：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, we need to ensure that when we see `AbortError`, we handle it. In this
    case, we’ll handle it with a `Promise().catch` handler, which, on seeing an `AbortError`,
    will return ‘`Aborted'`, and re-throw the error otherwise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保当我们看到 `AbortError` 时，我们能够处理它。在这种情况下，我们将使用 `Promise().catch` 处理器来处理它，当看到
    `AbortError` 时，将返回 `'Aborted'`，否则重新抛出错误。
- en: 'An `AbortError` error instance has a name property equal to `''AbortError''`,
    but also a message such as `DOMException [AbortError]: This operation was aborted`,
    along with its stack trace:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbortError` 错误实例有一个名称属性等于 `''AbortError''`，但还有一个如 `DOMException [AbortError]:
    This operation was aborted` 的消息，以及其堆栈跟踪：'
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given two API calls to fakestoreapi, `/products/1`, and `/products/2`, we can
    cancel one of them without affecting the other request as follows, by calling
    `fetchWithCancel` with both URLs and storing the output in two variables. Note
    that we’re not using `await` yet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 给定对 fakestoreapi 的两个 API 调用，`/products/1` 和 `/products/2`，我们可以取消其中一个而不影响另一个请求，如下所示，通过调用
    `fetchWithCancel` 并将两个 URL 存储在两个变量中。注意，我们还没有使用 `await`。
- en: 'We can then cancel the fetch for `/products/1` by using the `.cancel()` function
    we built earlier:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用我们之前构建的 `.cancel()` 函数取消对 `/products/1` 的获取：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The outcome of this is that when we await `fetchProduct1.response` and `fetchProduct2.response`,
    the output for `fetchProduct1.response` is `'Aborted'`, which means an `AbortError`
    instance was handled in `fetchWithCancel` (i.e., our cancellation succeeded).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，当我们等待 `fetchProduct1.response` 和 `fetchProduct2.response` 时，`fetchProduct1.response`
    的输出是 `'Aborted'`，这意味着在 `fetchWithCancel` 中处理了一个 `AbortError` 实例（即，我们的取消成功）。
- en: 'The output for `fetchProduct2.response` is the product object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchProduct2.response` 的输出是产品对象：'
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Manually cancelling a request is useful, but a more widespread use case is to
    time a request out when it takes more than a certain amount of time. This is useful
    to ensure a responsive user experience for customers. Different situations call
    for longer or shorter timeout delays.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 手动取消请求是有用的，但更广泛的使用场景是在请求超过一定时间后超时。这对于确保客户有响应式的用户体验很有用。不同的情况需要更长或更短的超时延迟。
- en: We can implement a `fetchWithTimeout` function using `fetch`, `AbortController`,
    and `setTimeout`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `fetch`、`AbortController` 和 `setTimeout` 实现一个 `fetchWithTimeout` 函数。
- en: 'Our function takes a URL and an optional timeout, which we’ll default to `500`
    (for 500 ms). Similar to our manual cancellation scenario (see `fetchWithCancel`),
    we’ll create an `abortController` object and pass its `signal` property as an
    option to `fetch`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能接受一个 URL 和一个可选的超时时间，我们将默认设置为 `500`（500 毫秒）。类似于我们的手动取消场景（见 `fetchWithCancel`），我们将创建一个
    `abortController` 对象，并将它的 `signal` 属性作为选项传递给 `fetch`：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to cancel the fetch after a certain amount of time, we’ll use `setTimeout`.
    The `setTimeout` handler will simply call `abortController.abort()` and we’ll
    set the timeout delay to our `timeout` variable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在一段时间后取消获取，我们将使用 `setTimeout`。`setTimeout` 处理器将简单地调用 `abortController.abort()`，我们将超时延迟设置为我们的
    `timeout` 变量：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When the request takes less time than the `fetch` request takes to complete,
    we receive the response data:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求完成所需时间少于 `fetch` 请求所需时间时，我们收到响应数据：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When a `fetch` request takes longer than the configured timeout, we receive
    an `AbortError` instance:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `fetch` 请求超过配置的超时时，我们收到一个 `AbortError` 实例：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’ve now seen how to use `AbortController` to control `fetch` cancellation
    manually and how to use it to create a “fetch with timeout” utility. We can use
    `AbortController` to cancel operations that aren’t required any more, thereby
    reducing network usage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用 `AbortController` 手动控制 `fetch` 取消以及如何用它创建一个“带超时”的实用工具。我们可以使用 `AbortController`
    来取消不再需要的操作，从而减少网络使用。
- en: Next, we’ll look at further patterns that can help optimize situations with
    high volumes of requests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨可以帮助优化高请求量情况的更多模式。
- en: Throttling, debouncing, and batching asynchronous operations
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节流、防抖和批量处理异步操作
- en: Throttling is an operation in which requests are dropped until a certain time
    is reached. For example, for a 10 ms throttle timeout, once a request is made,
    no request in the next 10 ms will be sent. If multiple requests are made between
    0 ms and 10 ms, only the last request will be sent after the 10 ms timeout expires.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 节流是一种操作，在达到一定时间之前会丢弃请求。例如，对于 10 毫秒的节流超时，一旦发起一个请求，在接下来的 10 毫秒内不会发送任何请求。如果在 0
    毫秒到 10 毫秒之间发起多个请求，只有 10 毫秒超时到期后发送的最后一个请求会被发送。
- en: In JavaScript, such a throttle function can be implemented as follows.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，这样的节流函数可以如下实现。
- en: A higher-order function, `throttle` takes in an `fn` parameter and returns an
    executable function with the same input signature as the `fn` parameter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数 `throttle` 接受一个 `fn` 参数并返回一个具有与 `fn` 参数相同输入签名的可执行函数。
- en: 'When the “throttled” `fn` function is called, we set `isThrottled = true` in
    order to be able to discard calls between the first call and a configured timeout:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当“节流”的 `fn` 函数被调用时，我们设置 `isThrottled = true` 以便能够在第一次调用和配置的超时之间丢弃调用：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We now need to ensure `fn` is not called while `isThrottled` is true. We achieve
    this by returning early from our returned “throttled” `fn` function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保在 `isThrottled` 为 `true` 时 `fn` 不会被调用。我们通过从返回的“节流”`fn` 函数中提前返回来实现这一点。
- en: 'We save the arguments with which the “throttled” `fn` function was called so
    that they can be used when the timeout expires:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存了“节流”的 `fn` 函数被调用时的参数，以便在超时到期时使用：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we configure `setTimeout` to trigger a reset of the throttled state
    and execute the last function call:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们配置 `setTimeout` 以触发节流状态的重置并执行最后的函数调用：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A simple example of this in use is the following scenario, where many messages
    could be sent in a given time. Instead, we want to throttle to 1 message every
    1 ms interval.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的一个简单例子如下场景，其中在给定时间内可能会发送许多消息。相反，我们希望以每 1 毫秒间隔发送 1 条消息。
- en: 'Our `storeMessage` function is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `storeMessage` 函数如下：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can generate a `throttledStoreMessage` function with a 1 ms timeout as follows.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以生成一个具有 1 毫秒超时的 `throttledStoreMessage` 函数如下。
- en: 'When called ten times synchronously and subsequently waiting for timers to
    complete, only the first (`''throttle-1''`) and last (`''throttle-10''`) calls
    are recorded:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当同步调用十次并随后等待计时器完成时，只有第一次（`'throttle-1'`）和最后一次（`'throttle-10'`）调用被记录：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If we reset the messages and wait for the timers to complete after our call
    with `'throttle-5'`, we finish with `['throttle-1', 'throttle-5', 'throttle-6']`,
    that is, the first call, and the calls before and after the timers are cleared.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `'throttle-5'` 的调用后重置消息并等待计时器完成，我们将以 `['throttle-1', 'throttle-5', 'throttle-6']`
    结束，即第一次调用，以及计时器清除前后的调用。
- en: 'If we clear the timers one more time after completing all our calls, `''throttle-10''`
    is also present in our messages list, meaning that call completed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在完成所有调用后再次清除计时器，`'throttle-10'` 也会出现在我们的消息列表中，这意味着调用已完成：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We’ve now seen how to throttle a function. We can now look at debouncing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何节流一个函数。现在我们可以看看防抖。
- en: A `debounce` function in JavaScript takes an `fn` parameter, which is a function.
    The goal is that the debounced `fn` function should discard all calls except the
    last call before it’s not called for a `timeout` period.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的 `debounce` 函数接受一个 `fn` 参数，它是一个函数。目标是使防抖的 `fn` 函数在经过一个 `timeout`
    期间未被调用时，丢弃所有调用，除了最后的调用。
- en: 'In order to do this, we should “delay” the function call until after a timeout
    completes. We save the `timeoutId` reference in order to cancel the call if the
    debounced `fn` function is called again. We use `setTimeout` and forward the arguments
    with which the debounced `fn` function was called:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们应该“延迟”函数调用直到超时完成之后。我们保存 `timeoutId` 引用，以便在防抖的 `fn` 函数再次被调用时取消调用。我们使用
    `setTimeout` 并传递防抖的 `fn` 函数被调用的参数：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With the current state of the `debounce` function, there would still be as
    many calls to `fn` as there are to the debounced `fn` function; they would just
    be queued for delayed execution based on the timeout. To avoid this, we can cancel
    the previous call timeout by using `clearTimeout(timeoutId)`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前`debounce`函数的状态下，对`fn`的调用次数将与对去抖动`fn`函数的调用次数一样多；它们只是根据超时时间被排队延迟执行。为了避免这种情况，我们可以使用`clearTimeout(timeoutId)`来取消之前的调用超时：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With these changes in place, if we create a `debouncedStoredMessage` function
    with a 1 ms timeout and call it 10 times, it will not execute until we wait for
    the timer to complete:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改到位后，如果我们创建一个具有1毫秒超时的`debouncedStoredMessage`函数并调用它10次，它将不会执行，直到我们等待计时器完成：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can further showcase this by waiting for timers to complete after the fifth
    call. In that case, the fifth call will trigger and, given another timeout window
    clears, the tenth call will also trigger:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过等待第五次调用后的计时器完成来进一步展示这一点。在这种情况下，第五次调用将触发，并且，如果另一个超时窗口清除，第十次调用也将触发：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ve now seen how to throttle and debounce functions, which allows us to ensure
    operations don’t trigger more than necessary.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何节流和去抖动函数，这允许我们确保操作不会触发不必要的次数。
- en: In a scenario where we have a “search as you type” or “suggest as you type”
    input (sometimes referred to as a “typeahead”), which needs to make API requests
    to get search results or suggestions, it usually makes sense to use either `debounce`,
    to wait for the user to stop typing before making a request, or to throttle the
    requests so that an API request is made every window instead of every keystroke.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个“边打字边搜索”或“边打字边建议”的输入场景中（有时被称为“预测输入”），需要通过API请求获取搜索结果或建议，通常在使用`debounce`等待用户停止打字后再发送请求，或者节流请求，以便在窗口中而不是每次按键时发送API请求。
- en: This can also be coupled with other heuristics to avoid overwhelming the API
    server with unnecessary requests. For example, it’s usual to avoid sending requests
    until a few characters have been typed since the search request is too broad with
    only 1 or 2 characters.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以与其他启发式方法结合使用，以避免因不必要的请求而使API服务器过载。例如，通常在输入几个字符之前避免发送请求，因为只有1个或2个字符的搜索请求太宽泛。
- en: We’ve seen how to protect an API by reducing the number of requests using throttling
    or debouncing. In the *Parallel asynchronous operation patterns* section, we used
    `Promise.all` to send requests in parallel. This can be another scenario where
    the target of our asynchronous operations can get overwhelmed. To avoid an overload
    scenario, it can be useful to batch our requests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过节流或去抖动减少请求数量来保护API。在*并行异步操作模式*部分，我们使用了`Promise.all`来并行发送请求。这也可以是异步操作目标可能过载的另一个场景。为了避免过载情况，批量请求可能很有用。
- en: “Batching” is a way to limit concurrency, for example, instead of sending 20
    requests at the same time (in parallel), we want to send 5 at a time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: “批量处理”是一种限制并发的方式，例如，我们不想同时发送20个请求（并行），而是一次发送5个。
- en: A `batch` function takes an array and a batch size and returns an array of arrays.
    The nested arrays have a maximum length of “batch size.”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`batch`函数接受一个数组和批量大小，并返回一个数组的数组。嵌套数组的最长长度为“批量大小”。'
- en: We start by calculating how many `batchItem` list items we’ll need in our `batches`
    array. In order to do this, we divide the input array length by the batch size
    and apply the `ceil` function to the value. In other words, we round up `inputLength`
    divided by `batchSize` to the next largest integer value.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算在`batches`数组中我们需要多少个`batchItem`列表项。为了做到这一点，我们将输入数组的长度除以批量大小，并应用`ceil`函数到该值。换句话说，我们将`inputLength`除以`batchSize`向上取整到下一个最大的整数值。
- en: 'We can then generate our `batches` array with the right size (`batchCount`,
    as computed):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用正确的尺寸（`batchCount`，如计算所得）生成我们的`batches`数组：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then go through each of the batches using `Array.prototype.map()`. The items
    in `batches` are initially undefined, but we use the index of the item (which
    we’ll call `batchNumber`). For each item in `batches`, we take the items from
    `batchNumber * batchSize` to `(batchNumber + 1) * batchSize` and they constitute
    the contents of our `batches[batchNumber]` array item:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Array.prototype.map()`遍历每个批次。`batches`中的项最初是未定义的，但我们使用项的索引（我们将称之为`batchNumber`）。对于`batches`中的每个项，我们从`batchNumber
    * batchSize`到`(batchNumber + 1) * batchSize`取项，它们构成了我们的`batches[batchNumber]`数组项的内容：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You’ll note that we’re generating the array with `Array.from` *and then* populating
    it using `Array.prototype.map()`, however, `Array.from()` supports a second parameter,
    which is a mapping function. Our code could therefore be as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们使用 `Array.from` 生成数组，然后使用 `Array.prototype.map()` 来填充它，然而，`Array.from()`
    支持第二个参数，即映射函数。因此，我们的代码可以是以下这样：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In any case, our `batch` function work for any array, for example, a 10-element
    array can be batched into chunks of 4 or 3 correctly by our function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们的 `batch` 函数适用于任何数组，例如，一个 10 个元素的数组可以通过我们的函数正确地分批为 4 或 3 个块：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding example showcased a synchronous example. For our use case – improving
    the performance of asynchronous operations, we need to handle Promises. The good
    news is that Promises can be stored in an array just as well:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了同步示例。对于我们的用例——提高异步操作的性能，我们需要处理 Promise。好消息是 Promise 可以像数组一样存储：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To get the batched output of the Promises, however, we need to write a function
    that awaits all the Promises in each batch to resolve them sequentially.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要获取 Promise 的批处理输出，我们需要编写一个函数，该函数等待每个批次中的所有 Promise 以顺序解决它们。
- en: 'This can be achieved by using a `for ... of` loop and `Promise.all`, as follows.
    We flatten out the resolved values:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 `for ... of` 循环和 `Promise.all` 来实现，如下所示。我们将解析的值展开：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In our example, the `Promise.resolve()` calls with `1`, `2`, and `3` can indeed
    be batched and resolved.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，使用 `Promise.resolve()` 调用 `1`、`2` 和 `3` 的确可以批量处理并解决。
- en: We’ve now seen how to build and use throttling, debouncing, and batching to
    improve the performance of our asynchronous operations in JavaScript.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何构建和使用节流、去抖和批处理来提高 JavaScript 中异步操作的性能。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve covered asynchronous operation orchestration patterns
    with Promises and async/await to manage sequential and parallel operations. We
    also covered advanced patterns such as request cancellation, implementing timeouts,
    the difference between throttling and debouncing, and finally, how to use batching
    in an asynchronous operation context.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 Promise 和 async/await 的异步操作编排模式，以管理顺序和并行操作。我们还介绍了高级模式，如请求取消、实现超时、节流和去抖之间的区别，以及如何在异步操作上下文中使用批处理。
- en: In order to manage sequential asynchronous operations, we can use a Promise-based
    approach with `Promise().then()`, async/await, or mix both approaches. This helps
    keep our code simple to reason about. For parallel execution, we can leverage
    `Promise.all()` with `Promise.then()` or async/await. We also have multiple approaches
    to maintaining response data across asynchronous operations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理顺序的异步操作，我们可以使用基于 Promise 的方法 `Promise().then()`、async/await，或者混合这两种方法。这有助于保持我们的代码简单，易于推理。对于并行执行，我们可以利用
    `Promise.all()` 与 `Promise.then()` 或 async/await。我们还有多种方法来维护异步操作之间的响应数据。
- en: We can leverage `AbortController` to cancel requests. We implemented a timeout
    for the `fetch` response time using `AbortController` and `setTimeout`. Stopping
    in-flight requests is a useful cleanup step that can improve performance by reducing
    unnecessary load on our API origin.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 `AbortController` 来取消请求。我们使用 `AbortController` 和 `setTimeout` 实现了对 `fetch`
    响应时间的超时处理。停止正在进行的请求是一个有用的清理步骤，可以通过减少对 API 原始服务的不必要负载来提高性能。
- en: Finally, the advanced asynchronous programming patterns allow fewer requests
    to happen via throttling and debouncing. We can also control the concurrency of
    our parallel requests using batching and resolving the batches. Again, these approaches
    can reduce unnecessary network traffic and load on the API servers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，高级异步编程模式通过节流和去抖减少请求的发生。我们还可以通过批处理和解决批次来控制并行请求的并发性。这些方法可以减少不必要的网络流量和对 API
    服务器的负载。
- en: Now that we’ve covered asynchronous programming performance patterns, with Promise,
    async/await, and advanced patterns, we can look at patterns for event-driven programming
    in JavaScript.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了异步编程性能模式，包括 Promise、async/await 和高级模式，我们可以看看 JavaScript 事件驱动编程的模式。
