- en: Testing and Debugging Your Mobile App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和调试您的移动应用程序
- en: 'In this chapter, we''ll be looking into the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下配方：
- en: Writing unit tests with Jest
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest编写单元测试
- en: Adding snapshot testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加快照测试
- en: Measuring test coverage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量测试覆盖率
- en: Using Storybook to preview components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Storybook预览组件
- en: Debugging your app with react-native-debugger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用react-native-debugger调试您的应用程序
- en: Debugging in an alternative way with Reactotron
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Reactotron进行替代方式的调试
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we saw how to develop a `React Native` (RN) mobile
    app, and along the same lines of what we did with `Node` and `React`, here let's
    complete the development process for mobile apps by looking at testing and debugging
    our app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何开发`React Native`（RN）移动应用程序，以及我们如何与`Node`和`React`一样，让我们通过查看测试和调试我们的应用程序来完成移动应用程序的开发过程。
- en: Writing unit tests with Jest
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest编写单元测试
- en: Doing unit testing for RN won't be too much of a surprise, because it happens
    that we'll be able to reuse most of what we learned before (for example, using
    `Jest` also with snapshots, or how to test `Redux`), except for some small details
    that must be taken care of, as we'll see.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 进行RN的单元测试不会太让人惊讶，因为我们将能够重用之前学到的大部分知识（例如，使用`Jest`也与快照一起使用，或者如何测试`Redux`），除了一些必须注意的小细节，我们将会看到。
- en: In this recipe, we'll look at how to set up unit tests for RN, along the lines
    of what we already did for `Node` and `React`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看看如何为RN设置单元测试，沿用我们已经为`Node`和`React`做的工作。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Whether you create the mobile app with CRAN (as we did) or with `react-native
    init`, support for `Jest` is baked in; otherwise, you''d have to install it on
    your own, as we saw in the *Unit testing your code *section of [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml),
    *Testing and Debugging Your Server*. Depending on how you create the project,
    there''s a difference in the `Jest` configuration in `package.json`; we won''t
    have to do anything, but see [https://jestjs.io/docs/en/tutorial-react-native.html#setup](https://jestjs.io/docs/en/tutorial-react-native.html#setup) for
    the alternative. We''ll have to add a few packages that we used earlier, but that''s
    about it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是使用CRAN（就像我们一样）还是使用`react-native init`创建移动应用程序，对`Jest`的支持都是内置的；否则，您将不得不自己安装它，就像我们在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)的*单元测试您的代码*部分中看到的那样，*测试和调试您的服务器*。根据您创建项目的方式，在`package.json`中的`Jest`配置会有所不同；我们不必做任何事情，但是请参阅[https://jestjs.io/docs/en/tutorial-react-native.html#setup](https://jestjs.io/docs/en/tutorial-react-native.html#setup)以获取替代方案。我们将不得不添加一些我们之前使用过的包，但仅此而已：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After doing this, we can write tests as before. Let's look at an example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以像以前一样编写测试。让我们看一个例子。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Earlier in this book, we wrote some tests for the countries and regions application,
    and since we have already rewritten that in RN, why not also rewrite the tests?
    That will allow us to verify that writing unit tests for RN isn''t that different
    from writing them for plain `React`. We had already written tests for the `<RegionsTable>`
    component; let''s check them here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早些时候，我们为国家和地区应用程序编写了一些测试，因为我们已经在RN中重写了它，为什么不也重写测试呢？这将使我们能够验证为RN编写单元测试与为普通的`React`编写单元测试并没有太大的不同。我们已经为`<RegionsTable>`组件编写了测试；让我们在这里检查一下：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The differences are really minor, and mostly it''s the same code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 差异真的很小，大部分都是相同的代码：
- en: We had to add `fakeDeviceData`, but that was only because our RN component required
    it
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不添加`fakeDeviceData`，但那只是因为我们的RN组件需要它
- en: We changed `Enzyme.render()` to `Enzyme.shallow()`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`Enzyme.render()`更改为`Enzyme.shallow()`
- en: We changed the way we use the `wrapper` object to check for included text directly,
    using ``wrapper.contains()``
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们改变了使用`wrapper`对象来直接检查包含的文本的方式，使用``wrapper.contains()``
- en: For a complete (and long!) list of all the available wrapper methods, check
    out [https://github.com/airbnb/enzyme/blob/master/docs/api/shallow.md](https://github.com/airbnb/enzyme/blob/master/docs/api/shallow.md).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有可用包装器方法的完整（而且很长！）列表，请查看[https://github.com/airbnb/enzyme/blob/master/docs/api/shallow.md](https://github.com/airbnb/enzyme/blob/master/docs/api/shallow.md)。
- en: 'We can also have a look at the `<CountrySelect>` tests, which involved simulating
    events. We can skip the tests that are practically identical to the `React` versions;
    let''s focus on the last one of our original tests:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看一下`<CountrySelect>`的测试，其中涉及模拟事件。我们可以跳过与`React`版本几乎相同的测试；让我们专注于我们原始测试中的最后一个：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The key difference between how we wrote the tests for `React` and for RN is
    in the way we `.find()` the element to click (RN uses a `Picker` component, instead
    of a group of `option` elements), and the event we simulate (`"ValueChange"` instead
    of `"change"`). Other than that, though, the code is the same as earlier.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`React`和RN编写测试的关键区别在于我们`.find()`要点击的元素的方式（RN使用`Picker`组件，而不是一组`option`元素），以及我们模拟的事件（`"ValueChange"`而不是`"change"`）。除此之外，代码与之前的代码相同。
- en: For native modules, you may have to use mocks in order to simulate the expected
    behaviors. We haven't used such modules in our code, but should you require any
    of them, use the same mocking styles we saw in [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml),
    *Testing and Debugging Your Server*, and for `React` itself in [Chapter 10](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml),
    *Testing Your Application*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原生模块，您可能需要使用模拟来模拟预期的行为。我们的代码中没有使用这样的模块，但是如果您需要其中任何一个，可以使用我们在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)的*测试和调试您的服务器*中看到的相同的模拟样式，以及对`React`本身的模拟样式在[第10章](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml)的*测试您的应用程序*中。
- en: Having gone over some of the differences in RN components testing, we are done,
    because there are no differences in the code when testing actions or reducers.
    These use the same style of functional unit testing that doesn't involve any particular
    RN features, so we have nothing more to say. In the next section, we'll look at
    our test run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在RN组件测试中已经讨论了一些差异，因为在测试操作或减速器时代码没有差异。这些使用相同的功能单元测试风格，不涉及任何特定的RN功能，所以我们没有更多可说的了。在下一节中，我们将查看我们的测试运行。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Running the tests is achieved with a single command, as before:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试与以前一样，只需一个命令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as shown in the following screenshot—note that we also ran some
    tests we had copied from the `React` chapter, without any changes, and they also
    performed perfectly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下截图所示——请注意，我们还运行了一些从`React`章节复制过来的测试，没有任何更改，它们也表现得很完美：
- en: '![](img/f2bb19d5-78b8-4f57-944f-2b23fc48df1c.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2bb19d5-78b8-4f57-944f-2b23fc48df1c.png)'
- en: All our components' tests run OK
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有组件的测试都通过了
- en: So, apart from the need to use shallow rendering, and possibly some changes
    in the way we access elements or simulate events, coding unit tests for RN is
    pretty much the same as for `React`, which is good news. We are forgetting something,
    however – what about snapshot testing? Let's move on to that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了需要使用浅渲染，并可能需要以不同的方式访问元素或模拟事件，为RN编写单元测试基本上与为`React`编写单元测试相同，这是个好消息。然而，我们忘了一件事——快照测试怎么样？让我们继续。
- en: Adding snapshot testing
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加快照测试
- en: Snapshot testing with RN is a nice surprise, because you won't have to change
    anything in the way you worked before. Let's just look at a few examples, and
    you'll be convinced.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RN进行快照测试是一个惊喜，因为你不需要改变之前的工作方式。让我们看几个例子，你就会相信。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We had already seen snapshot testing in the *Testing changes with snapshots* section
    of [Chapter 10](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml), *Testing Your Application*.
    It so happens that the very same code will work perfectly with RN apps, without
    demanding any specific changes, other than those depending on variations in the
    code. Let''s consider the following example. The `<RegionsTable>` component we
    had developed earlier has an extra prop in RN: `deviceData`. So, we can copy the
    original snapshot test code and just add the new prop, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第10章](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml)的*使用快照测试更改*部分中看到了快照测试。恰好，相同的代码在RN应用中也能完美运行，而不需要任何特定的更改，除了那些取决于代码变化的部分。让我们考虑以下示例。我们之前开发的`<RegionsTable>`组件在RN中有一个额外的prop：`deviceData`。因此，我们可以复制原始快照测试代码，然后只需添加新的prop，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you bother to compare versions, you''ll see that the only changed parts
    are the ones I highlighted in bold text, and they have to do with the different
    components, not with any RN-specific thing. If you write a snapshot test for the
    `<CountrySelect>` component, you''ll find exactly the same result: the only necessary
    changes have to do with its new props (`deviceData`, `currentCountry`), but pose
    no other difficulty.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意比较版本，你会发现唯一改变的部分是我用粗体标出的部分，它们与不同的组件有关，而不是与任何RN特定的东西有关。如果你为`<CountrySelect>`组件编写快照测试，你会发现完全相同的结果：唯一必要的更改与其新的props（`deviceData`，`currentCountry`）有关，但没有其他困难。
- en: 'For variety, let''s add snapshot testing to our `<Main>` component. We''ll
    have two interesting details here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了多样化，让我们为我们的`<Main>`组件添加快照测试。这里有两个有趣的细节：
- en: Since our component rendered itself differently in portrait or landscape mode,
    we should have two tests; and
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们的组件在纵向或横向模式下呈现不同，我们应该有两个测试；和
- en: As the component includes connected components, we must not forget to add a
    `<Provider>` component, lest the connections cannot be made.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于该组件包含连接的组件，我们不要忘记添加`<Provider>`组件，否则连接将无法建立。
- en: 'The code would be as follows; in particular, notice the varying device data,
    and the `<Provider>` inclusion:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下；特别要注意不同的设备数据和`<Provider>`的包含：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Since all our snapshot tests'' filenames end with `.snapshot.js`, we can run
    all the snapshot tests with a single command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们所有快照测试的文件名都以`.snapshot.js`结尾，我们可以用一个命令运行所有快照测试：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first time you run the tests, as before, the snapshots will be created:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行测试时，与以前一样，将创建快照：
- en: '![](img/38d8d4ed-7f20-4ddc-b976-e694a40b4e88.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38d8d4ed-7f20-4ddc-b976-e694a40b4e88.png)'
- en: As with React, the first run will create snapshots for components
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与React一样，第一次运行将为组件创建快照
- en: 'If we check the `__snapshots__` directory, we will find the three produced
    `.snap` files within. Their format is the same as with the `React` examples that
    we developed earlier. Let''s just have a look at the `<RegionsTable>` one, which
    we showed earlier:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查`__snapshots__`目录，我们会发现其中有三个生成的`.snap`文件。它们的格式与我们之前开发的`React`示例相同。让我们看一下之前展示的`<RegionsTable>`的一个：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If in the future you run the tests again and nothing has been changed, then
    the results will be three PASS green messages:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将来再次运行测试，而且没有任何更改，那么结果将是三个PASS绿色消息：
- en: '![](img/9bde6097-450b-47fa-87d8-8c1824c948cc.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bde6097-450b-47fa-87d8-8c1824c948cc.png)'
- en: Our snapshot tests were all successful
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的快照测试都成功了
- en: Everything is working fine, so we can aver that writing snapshot tests doesn't
    add any complications to RN testing, and can be carried out without difficulty.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很顺利，所以我们可以断言编写快照测试不会给RN测试增加任何复杂性，并且可以毫无困难地进行。
- en: Measuring test coverage
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量测试覆盖率
- en: In the same way we did for `Node` and `React`, back in [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml),
    *Testing and Debugging Your Server*, and [Chapter 10](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml),
    *Testing Your Application*, we would like to have a measure of the coverage of
    our tests to see how thorough we have been, and to be able to detect pieces of
    code that need more work. Fortunately, we'll be able to manage with the same tools
    that we did before, so this recipe will prove easy to implement.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)的*测试和调试您的服务器*和[第10章](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml)的*测试您的应用程序*中为`Node`和`React`做的那样，我们希望对我们的测试覆盖率进行测量，以了解我们的工作有多彻底，并能够检测到需要更多工作的代码片段。幸运的是，我们将能够使用之前使用的相同工具来管理，因此这个步骤将很容易实现。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The setup for the application done by CRAN included `Jest`, as we saw, and
    `Jest` provides us with the coverage option we need. To start, we''ll have to
    add a simple script, to run our suite of tests with a couple of extra parameters:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CRAN提供的应用程序设置包括我们之前看到的`Jest`，而`Jest`为我们提供了所需的覆盖选项。首先，我们需要添加一个简单的脚本，以便用一些额外的参数运行我们的测试套件：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's all, we don't have anything else to do; let's just see it work!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了，我们没有其他事情要做；让我们看看它是如何工作的！
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Running the tests is simple; we just have to use the new script:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试很简单；我们只需要使用新的脚本：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All of the suite will be run in the same fashion as in the previous sections
    of this chapter, but at the end, a text summary will be produced. As earlier,
    colors will be used: green for well-covered (in terms of testing) source files,
    yellow for intermediate coverage, and red for low or no coverage:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 整个套件将以与本章前几节相同的方式运行，但最后将生成一个文本摘要。与之前一样，颜色将被使用：绿色表示覆盖良好（在测试方面），黄色表示中等覆盖率，红色表示覆盖率低或没有覆盖：
- en: '![](img/c128c727-66e1-4504-8ad8-0ca091acd55f.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c128c727-66e1-4504-8ad8-0ca091acd55f.png)'
- en: Running Jest with the coverage option enabled produces the same type of result
    we saw for Node and React
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用启用覆盖选项的Jest生成了与我们在Node和React中看到的相同类型的结果
- en: 'We can also examine the HTML-produced files, which can be found at `/coverage/lcov-report`.
    Open the `index.html` file there, and you''ll get an interactive version of the
    report, as in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查生成的HTML文件，这些文件可以在`/coverage/lcov-report`中找到。在那里打开`index.html`文件，你将得到一个交互式版本的报告，就像下面的截图一样：
- en: '![](img/6786267b-dbbf-4c1d-9778-641d5de3e382.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6786267b-dbbf-4c1d-9778-641d5de3e382.png)'
- en: The produced HTML report is interactive, and lets you see what you missed in
    your tests
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的HTML报告是交互式的，可以让你看到你在测试中错过了什么
- en: 'For example, if you wondered why the `deviceHandler.component.js` file got
    such a low value (and never mind that you didn''t write a test for it; all code
    should be covered, if possible), you can click on it and see the reason. In our
    case, the `onLayoutHandler` code was (logically) never called, thus lowering the
    coverage for the file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想知道为什么`deviceHandler.component.js`文件得分如此之低（不要紧，你没有为它编写测试；所有的代码都应该被覆盖，如果可能的话），你可以点击它并查看原因。在我们的情况下，`onLayoutHandler`代码（逻辑上）从未被调用，因此降低了该文件的覆盖率：
- en: '![](img/0523cce4-3e14-46ad-a739-3307671a681b.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0523cce4-3e14-46ad-a739-3307671a681b.png)'
- en: Clicking on a file shows what lines were executed and which ones (red background)
    were missed
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 点击文件将显示哪些行被执行，哪些行（红色背景）被忽略
- en: To see some ways to disable reporting lines that aren't covered, or for cases
    you don't want to consider, look at [https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md](https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何禁用未覆盖的报告行，或者对于你不想考虑的情况，可以查看[https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md](https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md)。
- en: Using Storybook to preview components
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Storybook预览组件
- en: '`Storybook`, our `React` tool from the *Simplifying component development with
    Storybook* section of [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml),
    *Developing with React*, can also be used to help with the development of components,
    so in this recipe, let''s look at how to use it in order to simplify our work.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Storybook`，我们在[第6章](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml)的*Simplifying
    component development with Storybook*部分中介绍的`React`工具，也可以用来帮助开发组件，因此在这个教程中，让我们看看如何使用它来简化我们的工作。'
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Installing `Storybook` is simple, and similar to what we did before; the `react-native-storybook-loader` package
    will let us place our `*.story.js` files wherever we want, and find them anyway.
    The second command will take a while, installing many packages; be warned! Also,
    a `storybook` directory will be created, at the root of your directory. Install
    `Storybook` with the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`Storybook`很简单，与之前的操作类似；`react-native-storybook-loader`包将允许我们将`*.story.js`文件放在任何我们想要的地方，并且无论如何都能找到它们。第二个命令将需要一些时间，安装许多包；请注意！此外，将在你的目录根目录下创建一个`storybook`目录。使用以下命令安装`Storybook`：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `storybook/Stories` directory can be safely deleted, as we'll place our
    stories elsewhere, along with the components being demonstrated, as we did earlier
    in this book.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`storybook/Stories`目录可以安全地删除，因为我们将把我们的故事和被演示的组件放在其他地方，就像我们在本书的前面部分所做的那样。'
- en: 'Running `Storybook` within an RN app created with CRNA requires an extra step:
    providing an appropriate `App.js` file. The simplest way to achieve this is with
    a one-liner file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CRNA创建的RN应用程序中运行`Storybook`需要额外的步骤：提供一个适当的`App.js`文件。实现这一点的最简单方法是使用一行文件：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, this is a problem—how will you run your app? You could, of course,
    have two different `App.storybook.js` and `App.standard.js` files, and copy one
    or another to `App.js`, but that would quickly become boring if done manually.
    Of course, you could make do with some `npm` scripts. The following would work
    for Linux or macOS machines by using the `cp` command to copy files, but would
    require small changes for Windows devices:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个问题——你将如何运行你的应用程序？当然，你可以有两个不同的`App.storybook.js`和`App.standard.js`文件，并将其中一个复制到`App.js`，但如果手动完成，这很快就会变得无聊。当然，你可以使用一些`npm`脚本。以下命令适用于Linux或macOS设备，使用`cp`命令来复制文件，但对于Windows设备需要进行小的更改：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ll also need to add some configuration for the loader in `package.json`.
    The following makes the loader look for `*.story.js` files in the `./src` directory,
    and generates a `storyLoader.js` file with the found stories:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`package.json`中添加一些加载器的配置。以下内容使加载器在`./src`目录中查找`*.story.js`文件，并生成一个带有找到的故事的`storyLoader.js`文件：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we''ll have to modify `storybook/index.js`, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将不得不修改`storybook/index.js`，如下所示：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are now set; let's write some stories!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置好了，让我们写一些故事！
- en: Check [https://github.com/storybooks/storybook/tree/master/app/react-native](https://github.com/storybooks/storybook/tree/master/app/react-native) for
    more documentation on `Storybook` for RN, and [https://github.com/elderfo/react-native-storybook-loader](https://github.com/elderfo/react-native-storybook-loader) for
    details on the loader we are using.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://github.com/storybooks/storybook/tree/master/app/react-native](https://github.com/storybooks/storybook/tree/master/app/react-native)了解RN的`Storybook`的更多文档，以及[https://github.com/elderfo/react-native-storybook-loader](https://github.com/elderfo/react-native-storybook-loader)了解我们正在使用的加载程序的详细信息。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s write some stories. We can start with the `<RegionsTable>` component,
    which is quite simple: it doesn''t include any actions, and just displays data.
    We can write two cases: when an empty list of regions is provided, and when a
    non-empty one is given. We don''t have to think too much about the needed fake
    data, because we can reuse what we wrote for our unit tests! Consider the following
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些故事。我们可以从`<RegionsTable>`组件开始，这很简单：它不包括任何操作，只显示数据。我们可以写两种情况：当提供空的地区列表时，以及当提供非空列表时。我们不必过多考虑所需的假数据，因为我们可以重用我们为单元测试编写的内容！考虑以下代码：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Adding a decorator to center the displayed component is just for clarity: the
    necessary `<Centered>` code is simple, and needs a little of the styling we saw
    in the previous chapter:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个修饰器来使显示的组件居中只是为了清晰起见：必要的`<Centered>`代码很简单，并且需要一点我们在上一章中看到的样式：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, setting up stories for `<CountrySelect>` is more interesting, because
    we have actions. We''ll provide two to the component: one when the user clicks
    on it to select a country, and an other for the `getCountries()` callback that
    the component will use to get the list of countries:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为`<CountrySelect>`设置故事更有趣，因为我们有操作。我们将为组件提供两个操作：当用户点击它以选择一个国家时，以及用于获取国家列表的`getCountries()`回调的另一个操作：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are all set now; let's see how this works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了；让我们看看这是如何工作的。
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To view the `Storybook` app, we need to use the script we edited in the preceding
    section. Start by running the `storybook` script (it would be better to do this
    in a separate console) and then run the application itself, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`Storybook`应用程序，我们需要使用我们在前一节中编辑的脚本。首先运行`storybook`脚本（最好在单独的控制台中执行此操作），然后运行应用程序本身，如下所示：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first command produces a bit of output, allowing us to confirm that our
    script works and that all our stories were found. The following code was slightly
    edited for clarity:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令产生了一些输出，让我们确认我们的脚本是否有效，并且找到了所有的故事。以下代码略作编辑以便更清晰：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can open the browser and get a view quite similar to the one we got for
    the web apps and `React`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打开浏览器，得到一个与我们为Web应用程序和`React`获得的视图非常相似的视图：
- en: '![](img/cd5e5f68-4756-403d-b280-a662dd677a7a.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd5e5f68-4756-403d-b280-a662dd677a7a.png)'
- en: You can select stories in the sidebar, and the app will show them
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在侧边栏中选择故事，应用程序将显示它们
- en: 'If you select a story in the menu, the app will show it, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在菜单中选择一个故事，应用程序将显示它，如下所示：
- en: '![](img/bdad9c0b-3193-40df-bf36-ff2cd0983ab6.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdad9c0b-3193-40df-bf36-ff2cd0983ab6.png)'
- en: The app shows the story you picked in the browser
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序会在浏览器中显示您选择的故事
- en: 'You can also select which story to show in the app itself by pressing the hamburger
    menu at the top left of the preceding screenshot. The resulting selection menu
    is shown as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过按压前面截图左上角的汉堡菜单来选择在应用程序本身中显示哪个故事。结果选择菜单显示如下：
- en: '![](img/ca2bb2b9-4837-43d3-b0ee-28281efa21d9.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca2bb2b9-4837-43d3-b0ee-28281efa21d9.png)'
- en: The app also lets you select what story to show
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序还允许您选择要显示的故事
- en: 'Finally, you can see the actions in the browser. Let''s imagine you open the
    story for the country list with three countries:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以在浏览器中看到操作。让我们想象一下，您打开了包含三个国家的国家列表的故事：
- en: '![](img/fdcfc50d-9a8a-4ae5-a6da-dd6cd39b0352.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdcfc50d-9a8a-4ae5-a6da-dd6cd39b0352.png)'
- en: The country selector lets you interact with actions
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 国家选择器让您与操作进行交互
- en: 'If you click on Brazil, the browser will show the fired actions. First, we can
    see call:getCountries when the `getCountries()` callback is called, and then click:country when
    you click on an option:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击巴西，浏览器将显示已触发的操作。首先，我们可以看到当`getCountries()`回调被调用时，会出现call:getCountries，然后当您点击一个选项时会出现click:country。
- en: '![](img/db13f2c1-3c0b-438d-8046-6b6ffd1625ef.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db13f2c1-3c0b-438d-8046-6b6ffd1625ef.png)'
- en: As with web apps, you can interact with stories and see what actions were called
    with which parameters
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web应用程序一样，您可以与故事互动，并查看调用了哪些操作以及使用了哪些参数
- en: So, we've seen that adding stories is practically the same as for the web, and
    you get an extra tool to help in development—you should take this into account.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到，添加故事实际上与Web应用程序相同，并且您还可以获得额外的工具来帮助开发-您应该考虑这一点。
- en: Debugging your app with react-native-debugger
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用react-native-debugger调试您的应用程序
- en: Debugging a RN app is harder than working with a web app, because everything
    you want to do is done remotely; you cannot just run a fully powered debugger
    in your mobile device. There are several tools that can help you out with this,
    and in this section, we'll consider a "catch-all" tool, `react-native-debugger`,
    that includes a powerful trio of utilities, with which most (if not all) of your
    requirements should be fulfilled.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 调试RN应用程序比处理Web应用程序更难，因为您想要做的一切都是远程完成的；您不能在移动设备上运行功能齐全的调试器。有几种工具可以帮助您解决这个问题，在本节中，我们将考虑一个“万能”工具`react-native-debugger`，它包括一个强大的三合一实用程序，其中大多数（如果不是全部）您的需求应该得到满足。
- en: 'The basic tools you''ll require for thorough debugging (and we already met
    them earlier) would be the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要进行彻底调试的基本工具（我们之前已经遇到过）如下：
- en: Chrome Developer Tools, at [https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/),
    for access to the console and more
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome开发者工具，网址为[https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/)，用于访问控制台等
- en: '`React devtools` (in its standalone version) at [https://github.com/facebook/react-devtools](https://github.com/facebook/react-devtools),
    for dealing with components'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React devtools`（独立版本）网址为[https://github.com/facebook/react-devtools](https://github.com/facebook/react-devtools)，用于处理组件'
- en: The `Redux DevTools` extension, at [https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension),
    for inspecting actions and state
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Redux DevTools`扩展，网址为[https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension)，用于检查操作和状态'
- en: You could, of course, install each of them separately, and work with the trio,
    but having all of them together is undoubtedly simpler, so we'll follow that track.
    So, let's get on with debugging our code in this recipe!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以单独安装它们，并与三者一起使用，但将它们全部放在一起无疑更简单，因此我们将遵循这个方法。所以，让我们开始调试我们的代码吧！
- en: You can read about the basics of RN debugging at [http://facebook.github.io/react-native/docs/debugging](http://facebook.github.io/react-native/docs/debugging),
    and study `react-native-debugger` at [https://github.com/jhen0409/react-native-debugger](https://github.com/jhen0409/react-native-debugger).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://facebook.github.io/react-native/docs/debugging](http://facebook.github.io/react-native/docs/debugging)了解RN调试的基础知识，并在[https://github.com/jhen0409/react-native-debugger](https://github.com/jhen0409/react-native-debugger)学习`react-native-debugger`。
- en: Getting started
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: We'll have to install several packages in order to get everything to work. First,
    just get the `react-native-debugger` executable from its releases page at [https://github.com/jhen0409/react-native-debugger/releases](https://github.com/jhen0409/react-native-debugger/releases).
    Installation is just a matter of unzipping the file you downloaded; execution
    simply requires running the executable within the unzipped directory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装几个软件包才能让一切正常工作。首先，只需从[https://github.com/jhen0409/react-native-debugger/releases](https://github.com/jhen0409/react-native-debugger/releases)的发布页面获取`react-native-debugger`可执行文件。安装只需解压下载的文件；执行只需在解压后的目录中运行可执行文件。
- en: 'We''ll require a couple of packages in order to connect our app, which be get
    by running either on a simulator or on an actual device, with `react-native-debugger`.
    Let''s install these with the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装一些软件包，以便将我们的应用程序连接到`react-native-debugger`，可以通过模拟器或实际设备上运行以下命令来获取这些软件包。让我们使用以下命令安装这些软件包：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now have everything we need. Let's look at a few details on integrating the
    tools (mostly, the Redux debugger) with our app, and we'll be ready to start debugging.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了一切。让我们看一下如何将工具（主要是Redux调试器）集成到我们的应用程序中的一些细节，然后我们就可以开始调试了。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s look at how to set up our app so that we can use our debugging tools.
    To start with, we''ll require a simple change in the store creation code, adding
    a couple of lines, as shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何设置我们的应用程序，以便我们可以使用我们的调试工具。首先，我们需要在存储创建代码中进行简单更改，添加几行，如下所示：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Just for the sake of it—so that we can actually get some debugging messages
    – I added sundry `console.log()` and `console.error()` calls throughout the code.
    For consistency, I wanted to use `debug` (from [https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug)),
    as we did earlier in the book, but it won''t work, because it requires `LocalStorage`,
    and in RN you get `AsyncStorage` instead, with a different API. Just as an example,
    we''ll look at some log output from `world.actions.js`. I didn''t bother logging
    the output from successful API calls, because we''ll be getting that through `react-native-debugger`,
    as we''ll see:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅是为了让我们能够实际获得一些调试消息，我在整个代码中添加了各种`console.log()`和`console.error()`调用。为了保持一致，我想使用`debug`（来自[https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug)），就像我们在本书中之前所做的那样，但它不起作用，因为它需要`LocalStorage`，而在RN中，您将使用不同的API`AsyncStorage`。只是举个例子，我们将查看`world.actions.js`的一些日志输出。我没有打扰记录成功的API调用的输出，因为我们将通过`react-native-debugger`获得，我们将看到：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have everything in place; let's try it out.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备就绪，让我们试一试。
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, run your app with the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令运行您的应用程序：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'On your device (whether real or emulated), access the developer menu by shaking
    (on an actual device) or using command + *m* for macOS or *Ctrl* + *M* for Windows
    or Linux. At the very least, you want to enable remote JS debugging:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的设备上（无论是真实设备还是模拟设备），通过摇动（在实际设备上）或在macOS上使用command + m或在Windows或Linux上使用Ctrl
    + M来访问开发者菜单。至少，您希望启用远程JS调试：
- en: '![](img/3b4d9410-50e0-43b2-aa9a-5aae78aa05c3.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b4d9410-50e0-43b2-aa9a-5aae78aa05c3.png)'
- en: Using the device's developer menu to enable remote JS debugging
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设备的开发者菜单启用远程JS调试
- en: 'Now, open the `react-native-debugger` app by clicking on the executable you
    downloaded. If nothing happens, even after reloading the app, then the problem
    is surely due to a different port being set: in the menu, select Debugger, then New
    Window, and pick port 19001, and everything should be fine. When you start the
    app, it should look like the following screenshot. Notice all our logs on the
    right of the screen, the first `Redux` actions in the top left, and the React
    tools in the bottom left (and if you don''t care for some of these tools, right-click
    on the screen to hide any of the three):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过点击下载的可执行文件打开`react-native-debugger`应用程序。如果没有任何反应，即使重新加载应用程序后仍然没有反应，那么问题肯定是由于设置了不同的端口：在菜单中，选择Debugger，然后New
    Window，选择端口19001，一切都应该正常。当您启动应用程序时，它应该看起来像以下截图。请注意屏幕右侧的所有日志，左上角的第一个`Redux`操作，左下角的React工具（如果您不喜欢其中的某些工具，右键单击屏幕以隐藏其中的任何一个）：
- en: '![](img/58bf756b-f41f-4a72-b8d2-9c97f0f96783.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58bf756b-f41f-4a72-b8d2-9c97f0f96783.png)'
- en: Upon successful connection, you'll see the three tools in react-native-debugger
    running at once
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 成功连接后，您将看到react-native-debugger中的三个工具同时运行
- en: 'If you check the Network tab, you''ll see that the API calls from the app don''t
    appear by default. There''s a simple workaround for this: right-click on `react-native-debugger`,
    choose Enable network inspection, then right-click on the Chrome Developer tools
    and select Log  XMLHttpRequests, and all calls will appear:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查网络选项卡，您会发现应用程序的API调用默认情况下不会显示。有一个简单的解决方法：右键单击`react-native-debugger`，选择启用网络检查，然后右键单击Chrome开发人员工具并选择Log
    XMLHttpRequests，所有调用都将显示：
- en: '![](img/dc2d3c4a-f7e0-4d00-b545-d04b780a354e.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc2d3c4a-f7e0-4d00-b545-d04b780a354e.png)'
- en: API calls are not displayed by default, but can be enabled by right-clicking
    on the react-native-debugger screen
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: API调用默认情况下不会显示，但可以通过右键单击react-native-debugger屏幕启用
- en: 'You can also inspect `AsyncStorage`—see the following screenshot. I opted to
    hide `React` and `Redux DevTools`, as I mentioned previously, just for clarity. Since
    our app doesn''t actually use `AsyncStorage`, I fudged it a bit: note that you
    can use a `require()` function on any module, and then use it directly:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查`AsyncStorage`-请参阅以下屏幕截图。我选择隐藏`React`和`Redux DevTools`，就像我之前提到的那样，只是为了清晰。由于我们的应用实际上并没有使用`AsyncStorage`，我稍微捏造了一下：请注意，您可以对任何模块使用`require()`函数，然后直接使用它：
- en: '![](img/ee47bfc1-178f-47e8-9aac-9536ed3b0234.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee47bfc1-178f-47e8-9aac-9536ed3b0234.png)'
- en: Examining AsyncStorage with the RN debugger
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RN调试器检查AsyncStorage
- en: What else can we say? Not much, actually, since these tools are basically the
    same that we saw when using `React` for the web. The interesting detail here is
    that you get all of them together, instead of having to deal with many separate
    windows. Let's finish this chapter by considering an alternate tool, which you
    might just happen to prefer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 还能说什么呢？实际上并不多，因为这些工具基本上与我们在Web上使用`React`时看到的工具相同。这里有趣的细节是，您可以一次获得所有这些工具，而不必处理许多单独的窗口。让我们通过考虑一个可能更喜欢的备用工具来结束这一章节。
- en: Debugging in an alternate way with Reactotron
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Reactotron以另一种方式进行调试
- en: 'While it''s possible that `react-native-debugger` will work for most of your
    needs, there''s another package that, while coinciding with many features, also
    adds some new ones, or at least give a twist to old ones: Reactotron. This tool
    can also work with plain `React`, but I opted to show it here with RN, because
    it''s more likely you''ll require it. After all, `React` tools for the web are
    easy to use without any undue complications, while RN debugging is, as we''ve
    seen, a bit more of a challenge. Reactotron is said to be more efficient than
    `react-native-debugger`, but I won''t attest to that: check it out, and be aware
    that **Your mileage may vary** (**YMMV**). Let''s finish this chapter with a recipe
    to demonstrate this alternative way of debugging.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`react-native-debugger`可能适用于您大部分的需求，但还有另一个软件包，虽然与许多功能相符，但也添加了一些新功能，或者至少对旧功能进行了调整：Reactotron。这个工具也可以与纯`React`一起使用，但我选择在这里与RN一起显示它，因为您更有可能需要它。毕竟，Web的`React`工具易于使用，而无需任何不必要的复杂性，而RN调试，正如我们所见，稍微有些挑战。据说Reactotron比`react-native-debugger`更有效，但我不会证明这一点：去试试看，并且要知道**结果可能有所不同**（**YMMV**）。让我们通过演示这种替代调试方式来结束这一章节。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll need a pair of packages: the basic Reactotron one, along with `reactotron-redux`
    to help with Redux. Install them with the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一对包：基本的Reactotron包，以及`reactotron-redux`来帮助处理Redux。使用以下命令安装它们：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Reactotron can work with `redux-sagas` instead of `redux-thunk`, and even with
    MobX, instead of Redux. Read more about this at [https://github.com/infinitered/reactotron](https://github.com/infinitered/reactotron).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Reactotron可以与`redux-sagas`一起工作，而不是`redux-thunk`，甚至可以与MobX一起工作，而不是Redux。在[https://github.com/infinitered/reactotron](https://github.com/infinitered/reactotron)上了解更多信息。
- en: 'You''ll also require the native executable tool that connects to your app. Go
    to the releases page at [https://github.com/infinitered/reactotron/releases](https://github.com/infinitered/reactotron/releases) and
    get the package that matches your environment: in my particular case, I just downloaded
    and unzipped the `Reactotron-linux-x64.zip` file. For macOS users, there is another
    possibility: check out [https://github.com/infinitered/reactotron/blob/master/docs/installing.md](https://github.com/infinitered/reactotron/blob/master/docs/installing.md).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个连接到您的应用程序的本机可执行工具。转到[https://github.com/infinitered/reactotron/releases](https://github.com/infinitered/reactotron/releases)的发布页面，并获取与您的环境匹配的软件包：在我特定的情况下，我只下载并解压了`Reactotron-linux-x64.zip`文件。对于macOS用户，还有另一种可能性：查看[https://github.com/infinitered/reactotron/blob/master/docs/installing.md](https://github.com/infinitered/reactotron/blob/master/docs/installing.md)。
- en: After installing all of this, we are ready to prepare our app; let's do so now!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所有这些后，我们准备好准备我们的应用程序；现在让我们这样做！
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'It''s a fact that you can use both Reactotron and `react-native-debugger` at
    the same time, but in order to avoid mixing things up, let''s have a separate
    `App.reactotron.js` file and a few other changes. We have to follow a few simple
    steps. First, let''s begin by adding a new script to `package.json` in order to
    enable running our app with Reactotron:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，您可以同时使用Reactotron和`react-native-debugger`，但为了避免混淆，让我们有一个单独的`App.reactotron.js`文件和一些其他更改。我们必须遵循一些简单的步骤。首先，让我们通过向`package.json`添加一个新的脚本来启用使用Reactotron运行我们的应用程序：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Second, let''s configure the connection and plugins. We''ll create a `reactotronConfig.js`
    file to establish the connection with `Reactotron`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们配置连接和插件。我们将创建一个`reactotronConfig.js`文件来与`Reactotron`建立连接：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here are a few details about some of the values and options in the previous
    code snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上一个代码片段中一些值和选项的一些细节：
- en: '`192.168.1.200` is the IP for my machine, and `9090` is the suggested port
    to use.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.1.200`是我的机器的IP，`9090`是建议使用的端口。'
- en: The `ignoreUrls` option for networking gets rid of some calls made by Expo,
    but not our own code, making for a clearer session.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络调试的`ignoreUrls`选项可以消除Expo发出的一些调用，但不会消除我们自己的代码，使会话更清晰。
- en: The `isActionImportant` function lets you highlight some actions so that they
    will be more noticeable. In our case, I opted to pick out the `countries:success`
    and `regions:success` actions, both of which include `"success"` in their types,
    but of course, you could select any others as well.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isActionImportant`函数允许您突出显示一些操作，以便它们更加显眼。在我们的情况下，我选择了`countries:success`和`regions:success`操作，这两个操作的类型都包含“success”，但当然，您也可以选择任何其他操作。'
- en: '`Reactotron` also includes logging functions, so I added three (useless!) calls
    just to see how they appear in our debugging. I didn''t want to show all the logging
    we added, but you would probably want to use the following commands so all your
    logging will go to `Reactotron` instead:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reactotron`还包括日志记录功能，因此我添加了三个（无用的！）调用，只是为了看看它们在我们的调试中是如何显示的。我不想展示我们添加的所有日志，但您可能希望使用以下命令，以便所有日志都会发送到`Reactotron`：'
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we have to adapt our store so that it will work with the `reactotron-redux`
    plugin. I opted to make a copy of `store.js`, called `store.reactotron.js`, with
    the following necessary changes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须调整我们的存储，以便它可以与`reactotron-redux`插件一起使用。我选择复制`store.js`，并将其命名为`store.reactotron.js`，并进行以下必要的更改：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Just for variety, and to be able to see how `Reactotron` handles `AsyncStorage`,
    I added a few (totally useless!) lines to set a few items:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了多样化，并且能够看到`Reactotron`如何处理`AsyncStorage`，我添加了一些（完全无用的！）行来设置一些项目：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, let''s make some changes to our `App.js` file. These changes are minor:
    simply include the configuration file, and use the store I just adapted:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们对`App.js`文件进行一些更改。这些更改很小：只需包含配置文件，并使用我刚刚调整的存储：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, we're ready; let's see it work!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好了；让我们看看它的运行情况！
- en: For full documentation on `Reactotron`, check out the developers' web page at [https://github.com/infinitered/reactotron](https://github.com/infinitered/reactotron). `Reactotron`
    includes more plugins that can help you when working with `Redux` or `Storybook` to
    do benchmarking of slow functions, or to log messages, so you may find many things
    of interest there.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Reactotron`的完整文档，请查看开发者的网页[https://github.com/infinitered/reactotron](https://github.com/infinitered/reactotron)。`Reactotron`还包括更多插件，可以在使用`Redux`或`Storybook`时帮助您进行慢函数的基准测试，或记录消息，因此您可能会在那里找到许多有趣的东西。
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To use `Reactotron`, just start it (double-clicking should do the job) and
    you''ll get the initial screen shown in the following screenshot. The tool will
    just wait for your app to connect; sometimes, it may take more than one attempt
    to get the initial connection started, but after that, things should move along
    swimmingly:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Reactotron`，只需启动它（双击应该就可以了），您将看到以下截图中显示的初始屏幕。该工具将等待您的应用连接；有时，可能需要多次尝试才能开始初始连接，但之后，事情应该会顺利进行。
- en: '![](img/53889851-b482-4fab-81f1-b32dbc58e568.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53889851-b482-4fab-81f1-b32dbc58e568.png)'
- en: The initial screen for Reactotron shows it waiting for connections
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Reactotron的初始屏幕显示它正在等待连接
- en: 'After you start the application, you will see that it made a connection. `Reactotron`
    shows some details: for example, the device is on Android, running version 8.1.0,
    and we can also see the size and scale of the device. See the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序后，您将看到它已经建立了连接。`Reactotron`显示了一些详细信息：例如，设备正在运行Android 8.1.0版本，我们还可以看到设备的大小和比例。请参阅以下截图：
- en: '![](img/67fd3435-06d3-4250-b1c4-3271e18a3e31.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67fd3435-06d3-4250-b1c4-3271e18a3e31.png)'
- en: After a connection is made, you can see the details about the device
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 连接成功后，您可以查看有关设备的详细信息
- en: 'When the app starts, we get something like the following screenshot. Notice
    the highlighted action (`countries:success`), the ASYNC STORAGE logs, and the
    three lines from old movies that we added (trivia time, for movie buffs: who said
    those three lines?):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动时，我们会得到类似以下截图的东西。请注意突出显示的操作（`countries:success`），ASYNC STORAGE日志，以及我们添加的来自老电影的三行（对于电影爱好者来说，这是一个有趣的时间：谁说了这三句话？）：
- en: '![](img/6e2f9fe5-cab8-43b9-8185-fa74553a599a.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e2f9fe5-cab8-43b9-8185-fa74553a599a.png)'
- en: When our app starts to run, we get all these debugging texts in the Reactotron
    window
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序开始运行时，我们会在Reactotron窗口中得到所有这些调试文本。
- en: 'We can also see the state of the `Redux` store—see the following screenshot.
    I inspected `deviceData` and one of the countries:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看`Redux`存储的状态——请参阅以下截图。我检查了`deviceData`和一个国家：
- en: '![](img/cef3163e-ae4e-443a-abcb-6290027d3776.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cef3163e-ae4e-443a-abcb-6290027d3776.png)'
- en: You can examine the Redux store to see what was put in it
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查Redux存储以查看其中放入了什么
- en: 'Finally, I select Austria in the app. We can examine the API call that went
    out, and also the action that was dispatched afterwards; see the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我在应用程序中选择了奥地利。我们可以检查已发出的API调用，以及随后分派的操作；请参阅以下截图：
- en: '![](img/317cfaa2-af06-4c2b-97e0-41579c46d748.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/317cfaa2-af06-4c2b-97e0-41579c46d748.png)'
- en: 'The results of selecting Austria in our app: we can examine the API call and
    the Redux actions as well. Here, we see the'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中选择奥地利的结果：我们可以检查API调用和Redux操作。在这里，我们看到了
- en: nine regions of Austria, and the details for the fifth one, Salzburg, of Mozart
    fame
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 奥地利的九个地区，以及莫扎特故乡萨尔茨堡的详细信息
- en: '`Reactotron` has, as we said, some different features, and for some purposes,
    it may suit you better than `react-native-debugger`, so it''s a worthwhile inclusion
    in your arsenal of debugger tools.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reactotron`有一些不同的功能，正如我们所说的，对于某些目的，它可能比`react-native-debugger`更适合您，因此它是您调试工具库中值得包含的内容。'
