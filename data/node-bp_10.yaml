- en: Chapter 10. Writing Flexible and Modular CSS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：编写灵活和模块化的CSS
- en: 'In the previous chapter, we learned about the most popular testing instruments
    under Node.js. We saw the importance of writing tests and learned about TDD and
    BDD. This chapter will be about **CSS** (**Cascading Style Sheets**) and the usage
    of preprocessors. The Web is built on the basis of three languages—HTML, CSS,
    and JavaScript. As part of modern technology, Node.js provides really helpful
    instruments to write CSS; in this chapter, we will have a look at these instruments
    and how they can improve our style sheets. This chapter will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了在Node.js下最流行的测试工具。我们看到了编写测试的重要性，并了解了TDD和BDD。本章将介绍**CSS**（**层叠样式表**）和预处理器的作用。网络建立在三种语言的基础之上——HTML、CSS和JavaScript。作为现代技术的一部分，Node.js提供了非常有帮助的工具来编写CSS；在本章中，我们将探讨这些工具以及它们如何改进我们的样式表。本章将涵盖以下主题：
- en: Popular techniques to write modular CSS
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写模块化CSS的流行技术
- en: The Less preprocessor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Less预处理器
- en: The Stylus preprocessor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stylus预处理器
- en: The Sass preprocessor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass预处理器
- en: The AbsurdJS preprocessor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AbsurdJS预处理器
- en: Writing modular CSS
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模块化CSS
- en: CSS has changed a lot in the last few years. Developers used CSS2 as a declarative
    language to decorate the page. Today's CSS3 gives us many more capabilities. Nowadays,
    CSS is used widely to implement design ideas animating elements on the page or
    even applying logic such as hiding and showing content blocks. A lot of CSS code
    requires better architecture, file structuring, and proper CSS selectors. Let's
    explore a few concepts that could help with this.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，CSS（层叠样式表）发生了很大的变化。开发者曾经使用CSS2作为声明性语言来装饰页面。今天的CSS3给我们带来了更多的能力。如今，CSS被广泛用于在页面上实现设计理念，动画化元素，甚至应用逻辑，如隐藏和显示内容块。大量的CSS代码需要更好的架构、文件结构和合适的CSS选择器。让我们探索一些可能有助于此的概念。
- en: BEM (block, element, modifier)
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BEM（块、元素、修饰符）
- en: BEM ([http://bem.info/method/definitions](http://bem.info/method/definitions))
    is a naming convention introduced by Yandex back in 2007\. It became a popular
    concept to develop frontend applications. In fact, it is not only applicable for
    CSS but also for any other language because it has very few rules that work well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: BEM（[http://bem.info/method/definitions](http://bem.info/method/definitions)）是由Yandex在2007年引入的一种命名约定。它成为了一种流行的前端应用开发概念。实际上，它不仅适用于CSS，也适用于任何其他语言，因为它只有很少的规则却能很好地工作。
- en: 'Let''s say we have the following HTML markup:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下HTML标记：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The instant CSS which we can come up with is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即想到的即时CSS如下：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, it will probably not work really well because we may have another
    logo in the sidebar of the page. Of course, we could use descendant selectors
    such as `.site-header { ... }` and `.logo { ... }`, but these come with a new
    problem. It is not really a good practice to connect selectors in a tree because
    we can''t extract a part of it and use it somewhere else. BEM solves this problem
    by defining rules which we can follow. A block in the context of BEM is an independent
    entity. It can be a simple one or a compound one (containing other blocks). In
    the previous example, the `<header>` tag precedes the CSS block. The elements
    are placed inside the block and they are context-dependent, that is, they mean
    something only if they are placed inside the block which they belong to. The `.logo`
    and `.navigation` selectors in the block are the elements. There is one more type
    of selector called **modifiers**. To better understand them, we will use an example.
    Let''s say that Christmas will arrive soon and we need to make a holiday version
    of the logo. At the same time, we need to keep the old styles because after a
    few months we need to revert it to its previous version. This is what modifiers
    are made for. We apply them on already existing elements to set a new look or
    style. The same can be said for a button, which has a normal, pressed, or disabled
    state. To separate the different types of selectors, BEM introduces the following
    syntax:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能不会真正奏效，因为我们可能在页面的侧边栏中还有另一个标志。当然，我们可以使用后代选择器，如`.site-header { ... }`和`.logo
    { ... }`，但这些选择器带来了新的问题。将选择器连接成树状结构并不是一个好的实践，因为我们不能从中提取一部分并用于其他地方。BEM通过定义我们可以遵循的规则来解决此问题。在BEM的上下文中，一个块是一个独立的实体。它可以是一个简单的块，也可以是一个复合块（包含其他块）。在先前的例子中，`<header>`标签先于CSS块。元素放置在块内，并且它们是上下文相关的，也就是说，只有当它们放置在所属的块内时才有意义。块中的`.logo`和`.navigation`选择器是元素。还有一种类型的选择器称为**修饰符**。为了更好地理解它们，我们将使用一个例子。假设圣诞节即将到来，我们需要制作一个假日版本的标志。同时，我们需要保留旧样式，因为几个月后我们需要将其恢复到之前的版本。这就是修饰符的作用。我们将它们应用于已存在的元素，以设置新的外观或样式。对于按钮也是如此，它有正常、按下或禁用状态。为了区分不同类型的选择器，BEM引入了以下语法：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The name of the elements is added with double underscores and modifiers with
    double dashes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 元素名称添加双下划线，修饰符添加双破折号。
- en: Using the Object Oriented CSS approach
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用面向对象的CSS方法
- en: '**Object Oriented CSS** (**OOCSS**) ([https://github.com/stubbornella/oocss/wiki](https://github.com/stubbornella/oocss/wiki))
    is another concept which helps us write better CSS. It was originally introduced
    by Nicole Sullivan and defines the following two principles.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象的CSS**（**OOCSS**）([https://github.com/stubbornella/oocss/wiki](https://github.com/stubbornella/oocss/wiki))是另一个有助于我们编写更好CSS的概念。它最初由Nicole
    Sullivan提出，并定义了以下两个原则。'
- en: Separate structure and skin
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分离结构和皮肤
- en: 'Consider the following CSS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下CSS：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are styles that describe the look and skin of the elements. The duplication
    is a good reason to extract them in a separate definition. Continue the preceding
    code as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些样式描述了元素的视觉和皮肤外观。重复是将其提取到单独定义中的良好理由。继续前面的代码如下：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's nice that we can use the same `.colors-skin` class against other elements
    or even better, we can change the whole theme of the page with just one little
    modification in that particular class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们可以使用相同的`.colors-skin`类应用于其他元素，甚至更好的是，我们只需在该特定类中稍作修改，就可以更改整个页面的主题。
- en: Separate container and content
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分离容器和内容
- en: 'The idea is that every element should have its styles applied no matter what
    context it is put in. Let''s use the following code as an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是每个元素都应该有它的样式应用于它所处的任何上下文中。以下代码作为例子：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At some point, we may need to put the same form in the footer of the site. The
    `20px` value and the `#FF0033` color, which we applied, will be lost because the
    form does not live in the header anymore. So, avoiding such selectors will help
    us to prevent such situations. Of course, we can't follow this principle for every
    element, but it is a really good practice overall.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们可能需要在网站的页脚中放置相同的表单。我们应用的`20px`值和`#FF0033`颜色将会丢失，因为表单不再位于页眉中。因此，避免这样的选择器将帮助我们防止此类情况发生。当然，我们不可能对每个元素都遵循这个原则，但总体来说，这是一个非常好的实践。
- en: Scalable and modular architecture for CSS
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS的可伸缩和模块化架构
- en: 'Jonathan Snook introduced another interesting approach called **Scalable and
    modular architecture for CSS** (**SMACSS**) ([http://smacss.com/](http://smacss.com/)).
    His idea was to categorize the styles of the application into different categories
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 乔纳森·斯努克介绍了一种名为**可伸缩和模块化CSS架构**（**SMACSS**）的另一种有趣的方法([http://smacss.com/](http://smacss.com/))。他的想法是将应用程序的样式分类到不同的类别中，如下所示：
- en: '**Basic selectors**: Basic selectors such as those for float clearing or the
    base font sizes'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本选择器**：如用于清除浮动或基本字体大小等的基本选择器'
- en: '**Layout**: The CSS styles defining the grid of the page'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局**：定义页面网格的CSS样式'
- en: '**Modules**: These are similar to the BEM block, that is, a group of elements
    that form a meaningful block'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**：这些类似于BEM块，即形成有意义块的一组元素'
- en: '**State**: CSS styles that define the state of the elements, for example, pressed,
    expanded, visible, hidden, and so on'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：定义元素状态的CSS样式，例如，按下、展开、可见、隐藏等'
- en: '**Theme**: Theme rules are similar to the state rules in which they describe
    how modules or layouts might look'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：主题规则类似于状态规则，它们描述了模块或布局可能的外观'
- en: Constructing the style sheet in this manner organizes the selectors very well.
    We can create different directories or files for the different categories, and
    in the end we will have everything properly set up.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建样式表很好地组织了选择器。我们可以为不同类别创建不同的目录或文件，最终我们将拥有一切都设置得当。
- en: Atomic design
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子设计
- en: 'Atomic design ([http://bradfrostweb.com/blog/post/atomic-web-design](http://bradfrostweb.com/blog/post/atomic-web-design)),
    a concept presented by Brad Frost, is a simple but really powerful approach. We
    know that the basic unit of matter is an atom. Applying this to CSS, we can define
    the atom as a simple HTML tag:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 原子设计([http://bradfrostweb.com/blog/post/atomic-web-design](http://bradfrostweb.com/blog/post/atomic-web-design))，由布拉德·弗罗斯特提出的一个概念，是一种简单但非常强大的方法。我们知道物质的基本单位是原子。将这个概念应用到CSS中，我们可以将原子定义为简单的HTML标签：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The atom contains some basic styling such as color, font size, or line height.
    Later, we can combine the atoms into molecules. The following example shows how
    a `form` tag is made of few atoms:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 原子包含一些基本样式，如颜色、字体大小或行高。稍后，我们可以将原子组合成分子。以下示例显示了如何将`form`标签由几个原子组成：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Properly styling and combining little blocks brings flexibility. If we follow
    this concept, we can reuse the same atoms again and again or put any molecule
    in a different context. Brad Frost didn't stop here. He continued by saying that
    the molecules can be merged into organisms and the organisms into templates. For
    example, the login form and the main-menu molecules define an organism header.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地样式化和组合小块块带来了灵活性。如果我们遵循这个概念，我们可以反复使用相同的原子，或者将任何分子放在不同的上下文中。布拉德·弗罗斯特并没有止步于此。他继续说，分子可以合并成生物体，生物体可以合并成模板。例如，登录表单和主菜单分子定义了一个生物体头部。
- en: All the concepts mentioned in this section are not ideal for every project.
    However, all of them have something valuable to use. We should try not to follow
    them strictly but get the rules which fit best in our current application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中提到的所有概念并不适合每个项目。然而，它们都有一些有价值的东西可以应用。我们应尽量避免严格遵循它们，而是获取最适合我们当前应用的规则。
- en: Exploring CSS preprocessors
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索CSS预处理器
- en: '**Preprocessors** are tools that accept code and compile it. In our context,
    such instruments output CSS. There are few big benefits of using preprocessors.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**预处理器**是接受代码并编译的工具。在我们的环境中，这些工具输出CSS。使用预处理器有几个显著的优点。'
- en: '**Concatenation**: Writing everything in one single `.css` file is not an option
    anymore. We all need to split our styles logically and this normally happens by
    creating a bunch of different files. CSS has a mechanism to import one file from
    another—the `@import` directive. However, by using it, we are forcing the browser
    to create another HTTP request to the server, which can decrease the performance
    of our application. CSS preprocessors normally deliver only one file by replacing
    the functionality of `@import` and simply concatenating all the used files.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：将所有内容写入一个单独的`.css`文件不再是可行的选择。我们都需要逻辑地分割我们的样式，这通常是通过创建多个不同的文件来实现的。CSS有一个从另一个文件导入文件的机制——`@import`指令。然而，使用它，我们迫使浏览器向服务器创建另一个HTTP请求，这可能会降低我们应用程序的性能。CSS预处理器通常通过替换`@import`的功能并简单地连接所有使用的文件来只输出一个文件。'
- en: '**Extending**: We don''t like to write things over and over again and with
    pure CSS coding, this happens all the time. The good news is that preprocessors
    provide a feature that solves this problem. It''s called a mixin. We can think
    of it as a function which is executed and all the styles defined in it are applied
    to the selector which calls it. We will see how this works in practice further
    in this chapter.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展（Extending**）：我们不喜欢反复写同样的事情，而在纯CSS编码中，这种情况经常发生。好消息是预处理器提供了一个解决这个问题的功能。它被称为混入。我们可以将其视为一个执行并应用其中定义的所有样式的函数。我们将在本章后面看到它在实际中的应用。'
- en: '**Configuration**: Normally, we need to repeat colors, widths, and font sizes
    all over the CSS file. By using the CSS preprocessor, we can put these values
    in variables and define them in only one place. Switching to a new color scheme
    or typography can happen really fast.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置（Configuration**）：通常，我们需要在CSS文件中重复颜色、宽度和字体大小。通过使用CSS预处理器，我们可以将这些值放入变量中，并在一个地方定义它们。切换到新的颜色方案或字体排印可以非常快地完成。'
- en: The syntax used in most preprocessors is similar to the normal CSS. This allows
    developers to start using them almost immediately. Let's check out the available
    CSS preprocessors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数预处理器中使用的语法与正常CSS类似。这使得开发者可以几乎立即开始使用它们。让我们来看看可用的CSS预处理器。
- en: Using Less
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Less
- en: 'Less is a CSS preprocessor based on Node.js. It is distributed as a Node.js
    module and can be installed using the following command line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Less是一个基于Node.js的CSS预处理器。它作为Node.js模块分发，可以使用以下命令行安装：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the successful installation, we should be able to call the `lessc` command
    in the terminal. Create a new `styles.less` file somewhere and put the following
    code inside it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，我们应该能够在终端中调用`lessc`命令。在某个地方创建一个新的`styles.less`文件，并将以下代码放入其中：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we run `lessc ./styles.less`, we will see the same CSS shown as a result.
    The approach, which is taken by Less, is to use a syntax close to the one used
    in the normal CSS. So, in practice, every existing CSS code could be compiled
    by Less, which comes in handy, because we can start using it without doing any
    preparation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`lessc ./styles.less`，我们将看到作为结果的相同CSS。Less采取的方法是使用与正常CSS中使用的语法相近的语法。因此，在实践中，几乎所有的现有CSS代码都可以由Less编译，这非常方便，因为我们可以在不做任何准备的情况下开始使用它。
- en: Defining variables
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义变量
- en: 'The variables in Less are defined as we write the CSS properties. We just have
    to put the `@` sign in front of the property''s name, as shown in the following
    code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Less中的变量定义方式与我们编写CSS属性的方式相同。我们只需在属性名前加上`@`符号，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using mixins
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用混入
- en: '**Mixins** are very useful when we want to transfer specific styles from one
    place to another or even several places. Let''s say, for example, that we have
    constant borders that need to be set for different elements on our page. We will
    then use the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**混入（Mixins**）在我们想要将特定样式从一个地方转移到另一个地方，甚至多个地方时非常有用。比如说，如果我们有一些需要为页面上的不同元素设置的固定边框，我们就会使用以下代码片段：'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can skip the brackets of `.my-border` but then we will have the same class
    in the resulted file. The code, as it is now, is compiled as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以省略`.my-border`的括号，但这样结果文件中将会出现相同的类。现在的代码编译如下：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The mixins can accept parameters, which makes them one of the most important
    features in Less.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 混入可以接受参数，这使得它们成为Less中最重要的功能之一。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the example, the size of the border is passed as a parameter. It also has
    a default value of two pixels. The result after the compilation is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，边框的大小作为参数传递。它还有一个默认值，为两像素。编译后的结果如下：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Structuring the styles into nested definitions
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将样式结构化为嵌套定义
- en: 'Very often, when we use descendent selectors, we end up with a really long
    style definition. This is annoying because we have to type more and it is difficult
    to read. CSS preprocessors solve that problem by allowing us to write nested styles.
    The next code shows how we may nest selectors:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用后代选择器时，经常会遇到一个非常长的样式定义。这很烦人，因为我们必须输入更多，而且难以阅读。CSS预处理器通过允许我们编写嵌套样式来解决此问题。以下代码显示了如何嵌套选择器：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is much easier to understand and follow. We don''t have to worry about
    collisions either. For example, the paragraph in the `.content` element will have
    a 24-pixel font size and will not be mixed with the styles of the footer. That''s
    because at the end, we have properly generated selectors:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这要容易理解得多，也更容易遵循。我们也不必担心冲突。例如，`.content` 元素中的段落将具有 24 像素的字体大小，并且不会与页脚的样式混合。这是因为最后，我们正确地生成了选择器：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Less has a dozen other features such as math calculation, function definitions,
    conditional mixins, and even loops. We can write a whole new book on this topic.
    A full list of all the functionalities can be seen at [http://lesscss.org/](http://lesscss.org/),
    which is the official site of Less and contains its documentation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Less 有十几个其他功能，如数学计算、函数定义、条件混入，甚至循环。我们可以就这个主题写一本全新的书。所有功能的完整列表可以在 [http://lesscss.org/](http://lesscss.org/)
    上看到，这是 Less 的官方网站，包含其文档。
- en: Using Sass
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Sass
- en: 'There is another popular CSS preprocessor called **Sass**. It''s actually not
    based on Node.js but on Ruby. So, we need to install Ruby first. You can also
    find detail information about how to install Ruby on the official download page:
    [https://www.ruby-lang.org/en/downloads](https://www.ruby-lang.org/en/downloads).
    Once we have it properly set up, we need to run the following command to get Sass:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个流行的 CSS 预处理器叫做 **Sass**。实际上它不是基于 Node.js，而是基于 Ruby。因此，我们首先需要安装 Ruby。你还可以在官方下载页面找到有关如何安装
    Ruby 的详细信息：[https://www.ruby-lang.org/en/downloads](https://www.ruby-lang.org/en/downloads)。一旦我们正确地设置了它，我们需要运行以下命令来获取
    Sass：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the execution, we have a command-line instrument installed, that is,
    `sass`, and we can run it against a `.sass` or `.scss` file. The syntax used in
    the `.sass` files looks like the one used in Stylus (we will learn about this
    in the *Using Stylus* section), and the syntax used in the `.scss` file is similar
    to the Less variant. At first, Less and Sass look pretty similar. Sass uses the
    `$` sign in front of the variables, while Less uses the `@` sign. Sass has the
    same features as Less—conditional statements, nesting, mixins, extending. The
    following code is a short example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们将安装一个命令行工具，即 `sass`，我们可以用它来运行 `.sass` 或 `.scss` 文件。`.sass` 文件中使用的语法看起来与
    Stylus 中使用的语法相似（我们将在 *使用 Stylus* 部分学习这一点），而 `.scss` 文件中使用的语法与 Less 变体相似。起初，Less
    和 Sass 看起来非常相似。Sass 在变量前使用 `$` 符号，而 Less 使用 `@` 符号。Sass 具有与 Less 相同的功能——条件语句、嵌套、混入、扩展。以下是一个简短的示例代码：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code produces the following CSS code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成以下 CSS 代码：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are two keywords: `@mixin` and `@include`. The first one defines the
    mixin and the second one is needed during its usage.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个关键字：`@mixin` 和 `@include`。第一个定义混入，第二个在混入使用时是必需的。
- en: Using Stylus
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Stylus
- en: '**Stylus** is another popular CSS preprocessor written in Node.js. Similar
    to Less, Stylus also accepts the usual CSS syntax. However, it introduces another
    type of writing—without braces, colons, and semicolons. The following code is
    a short example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Stylus** 是另一个流行的 CSS 预处理器，由 Node.js 编写。与 Less 类似，Stylus 也接受常规 CSS 语法。然而，它引入了另一种编写方式——没有花括号、冒号和分号。以下是一个简短的示例代码：'
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In Stylus, the CSS code produced may look like the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Stylus 中，生成的 CSS 代码可能看起来像以下代码片段：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The language uses the indentation to recognize the definitions. Stylus is distributed
    as a Node.js module and can be installed using the `npm install -g stylus` command
    line. Once the process is completed, we can compile with the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言使用缩进来识别定义。Stylus 作为 Node.js 模块分发，可以使用 `npm install -g stylus` 命令行安装。一旦过程完成，我们可以使用以下命令进行编译：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the command line where `styles.styl` contains the necessary CSS. As
    a result, we will get the `styles.css` file in the same directory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令行，其中 `styles.styl` 包含必要的 CSS。结果，我们将在同一目录下得到 `styles.css` 文件。
- en: 'Stylus is a little bit more advanced than Less. It still supports the same
    features but has more logical operators. Let''s see an example that demonstrates
    most of its features:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Stylus 比 Less 稍微复杂一些。它仍然支持相同的功能，但具有更多的逻辑运算符。让我们看看一个演示其大多数功能的示例：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first line defines a variable called `brandColor`. Later, this variable
    is used to set the color of the paragraph. Stylus supports hash objects as a value
    of the variables. It''s really nice because we can define a set of options. In
    the preceding example, `borderSettings` holds the size and the position of the
    paragraph''s border. The `paragraph-border` mixin accepts two arguments. The second
    one is not mandatory and has a default value. There is an `if`-`else` statement
    that defines the type of the applied border. Similar to Less, we have the ability
    to nest selectors. The paragraph''s styles are nested inside the `body` selector.
    After the compilation, the resulted CSS is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了一个名为 `brandColor` 的变量。稍后，这个变量被用来设置段落的颜色。Stylus 支持将哈希对象作为变量的值。这真的很不错，因为我们可以定义一组选项。在前面的例子中，`borderSettings`
    包含段落边框的大小和位置。`paragraph-border` 混入接受两个参数。第二个参数不是必需的，有一个默认值。有一个 `if`-`else` 语句定义了应用的边框类型。类似于
    Less，我们有嵌套选择器的能力。段落的样式嵌套在 `body` 选择器内部。编译后，生成的 CSS 如下所示：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Working with AbsurdJS
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AbsurdJS
- en: '**AbsurdJS** is another CSS preprocessor available in Node.js that takes a
    slightly different direction. Instead of inventing a new syntax, it uses the already
    existing language—JavaScript. So, features such as variables, mixins, or logical
    operators came naturally without any additional effort.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**AbsurdJS** 是 Node.js 中可用的另一个 CSS 预处理器，它采取了略微不同的方向。它不是发明新的语法，而是使用已经存在的语言——JavaScript。因此，变量、混入或逻辑运算符等特性自然出现，无需任何额外努力。'
- en: 'Similar to the other preprocessors, AbsurdJS is distributed via the package
    manager of Node.js. The following command line installs the library on your machine:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他预处理器类似，AbsurdJS 通过 Node.js 的包管理器分发。以下命令行将库安装到您的机器上：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The CSS styles are written in the `.js` files. In fact, the library accepts
    the `.css`, `.json`, and `.yaml` files and successfully processes them, but in
    this book we will stick to the JavaScript format because it is the most interesting
    one. Every file which is passed to AbsurdJS starts with the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 样式写在 `.js` 文件中。实际上，该库接受 `.css`、`.json` 和 `.yaml` 文件，并成功处理它们，但在这本书中，我们将坚持使用
    JavaScript 格式，因为它是最有趣的。每个传递给 AbsurdJS 的文件都以以下代码开始：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The function that is exported accepts the API of the module. All the operations
    work through the API object. Because everything is in JavaScript, the CSS styles
    are represented in the JSON format. The following is an example code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的函数接受模块的 API。所有操作都通过 API 对象进行。因为一切都在 JavaScript 中，CSS 样式以 JSON 格式表示。以下是一个示例代码：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code is compiled to the following CSS:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被编译成以下 CSS：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'AbsurdJS could work as a command-line tool. To process a `styles.js` file containing
    the preceding code snippet, we should execute the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: AbsurdJS 可以作为一个命令行工具使用。要处理包含前面代码片段的 `styles.js` 文件，我们应该执行以下代码：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `-s` flag comes from the source and `-o` from the output. The module can
    be used in code as well as to integrate AbsurdJS into every Node.js application.
    All we have to do is add the library in our `package.json` file and require it
    as shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`-s` 标志来自源代码，`-o` 来自输出。该模块既可以用在代码中，也可以将 AbsurdJS 集成到每个 Node.js 应用程序中。我们只需在我们的
    `package.json` 文件中添加库，并按以下代码所示引入它：'
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Actually, the same thing is valid for the Less preprocessor. It could be used
    in a Node.js script too.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于 Less 预处理器，同样适用。它也可以在 Node.js 脚本中使用。
- en: 'While discussing Sass and Stylus, we used an example: a few lines of code that
    put a border on the page''s `paragraph` tag. The following code elaborates how
    this can be achieved using AbsurdJS:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 Sass 和 Stylus 时，我们使用了一个例子：几行代码为页面的 `paragraph` 标签添加边框。以下代码阐述了如何使用 AbsurdJS
    实现这一点：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It's all about constructing JavaScript objects and passing them to the `add`
    method. There is still nesting, defining variables, and using a mixin (`paragraphBorder`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是关于构建 JavaScript 对象并将它们传递给 `add` 方法。仍然有嵌套、定义变量和使用混入（`paragraphBorder`）。
- en: Styling a simple login form
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计简单的登录表单样式
- en: 'We will now write the CSS styles for a simple login form. The HTML markup is
    pretty simple. It has two labels, two input fields, and two buttons, as shown
    in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写一个简单登录表单的 CSS 样式。HTML 标记非常简单。它有两个标签、两个输入字段和两个按钮，如下代码所示：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result that we want to achieve at the end looks like the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终想要达到的结果如下截图所示：
- en: '![Styling a simple login form](img/00062.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![设计简单的登录表单](img/00062.jpeg)'
- en: 'As a preprocessor, we are going to use AbsurdJS and write our styles in the
    JavaScript format. Let''s create an empty `style.js` file and enter the following
    code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为预处理器，我们将使用 AbsurdJS 并以 JavaScript 格式编写我们的样式。让我们创建一个空的 `style.js` 文件并输入以下代码：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We defined the settings of the page. They are only colors in our case, but it
    could be anything else, for example, font size, margin, or the space between the
    lines. The `api.lighten` and `api.darken` functions are used to produce variants
    of colors. They change the passed values by making them lighter or darker depending
    on the percentages.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了页面的设置。在我们的例子中，它们只是颜色，但可以是任何其他东西，例如字体大小、边距或行间距。`api.lighten` 和 `api.darken`
    函数用于生成颜色的变体。它们通过使它们变亮或变暗来改变传递的值，具体取决于百分比。
- en: 'We have our configurations set up and we can continue with the following basic
    CSS:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了配置，我们可以继续以下基本 CSS：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These styles are applied to the `body` tag of our page. If we open the page
    now, we will see the following result:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些样式应用于我们页面上的 `body` 标签。如果我们现在打开页面，我们将看到以下结果：
- en: '![Styling a simple login form](img/00063.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![简单登录表单的样式](img/00063.jpeg)'
- en: 'This is because we have still not worked on the form. Let''s continue and define
    the basic rules for it, using the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们还没有处理表单。让我们继续并使用以下代码定义其基本规则：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `#login` selector matches the form. We position it in the middle of the
    page and set padding from the top and bottom sides. We are also making the `label`
    tag a block element. Now the example looks much better, as shown in the following
    screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`#login` 选择器匹配表单。我们将它定位在页面中间，并设置顶部和底部的填充。我们还使 `label` 标签成为一个块元素。现在示例看起来好多了，如下面的截图所示：'
- en: '![Styling a simple login form](img/00064.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![简单登录表单的样式](img/00064.jpeg)'
- en: 'If we check the HTML markup, which we started from, we will see that the rest
    of the elements are the `input` tags, that is, two fields and two buttons. Let''s
    create a function (mixin), which will generate CSS for these elements:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查从其开始的 HTML 标记，我们会看到其余的元素都是 `input` 标签，即两个字段和两个按钮。让我们创建一个函数（混合），用于生成这些元素的
    CSS：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `input` method accepts a selector and an object. Because we will use the
    function to style fields and at the same buttons, we need a mechanism to add custom
    rules. The `addons` object (if defined) holds those styles which need to be set
    in addition. There are two properties that may look strange: `-wm-border-radius`
    and `-wm-box-sizing`. The `-wm-` property, at the beginning, adds browser prefixes
    to the end CSS. For example, `-wm-box-sizing: border-box` produces the following
    output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`input` 方法接受一个选择器和对象。因为我们将使用该函数来样式字段和按钮，我们需要一个机制来添加自定义规则。如果定义了 `addons` 对象，它将包含需要设置的额外样式。有两个属性可能看起来很奇怪：`-wm-border-radius`
    和 `-wm-box-sizing`。在开始时，`-wm-` 属性将浏览器前缀添加到 CSS 的末尾。例如，`-wm-box-sizing: border-box`
    产生以下输出：'
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `&:focus` property is also a special property. The ampersand represents
    the selector in which the style is written. At the end of the function, we added
    the custom CSS. Now, let''s see the use case:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`&:focus` 属性也是一个特殊属性。井号代表编写样式的选择器。在函数的末尾，我们添加了自定义 CSS。现在，让我们看看用例：'
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the input fields, we call the input method with only a selector. However,
    for the buttons, we need more styles and they are passed as a JavaScript object.
    AbsurdJS has built-in mixins that allow us to generate cross-browser CSS, for
    example, the `gradient` and `transparent` properties. The result of the execution
    of the `gradient` property is:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入字段，我们仅使用选择器调用输入方法。然而，对于按钮，我们需要更多的样式，并且它们作为 JavaScript 对象传递。AbsurdJS 内置了混合，允许我们生成跨浏览器的
    CSS，例如 `gradient` 和 `transparent` 属性。执行 `gradient` 属性的结果如下：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, the result of the execution of the `transparent` property is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，执行 `transparent` 属性的结果如下：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using a mixin is much easier than writing all these things by ourselves. Once
    we add the `input` invocations, we are done. AbsurdJS produces the desired result.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混合比我们自己编写所有这些内容要容易得多。一旦我们添加了 `input` 调用，我们就完成了。AbsurdJS 产生了期望的结果。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: CSS is and will always be an important part of the Web. Making it simple, well-structured,
    and with a flexible markup leads to a good architecture. In this chapter, we learned
    about the most popular concept to write modular CSS. Along with that, we checked
    the latest trends in CSS preprocessing, the available tools, and their features.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 是并且将始终是网络的重要组成部分。使其简单、结构良好且具有灵活的标记，有助于构建良好的架构。在本章中，我们学习了编写模块化 CSS 的最流行概念。同时，我们还探讨了
    CSS 预处理领域的最新趋势、可用工具及其特性。
- en: Node.js is fast and is very often used as a REST API. In the next chapter, we
    will see how to write a REST API and what the best practices in this direction
    are.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 运行速度快，经常被用作 REST API。在下一章中，我们将看到如何编写 REST API 以及这一方向的最佳实践。
