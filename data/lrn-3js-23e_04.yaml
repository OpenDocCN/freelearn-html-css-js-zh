- en: Chapter 4. Working with Three.js Materials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。使用 Three.js 材质
- en: 'In the previous chapters, we talked a bit about materials. You learned that
    a material, together with `THREE.Geometry`, forms `THREE.Mesh`. The material is
    like the skin of the object that defines what the outside of a geometry looks
    like. For example, a skin defines whether a geometry is metallic-looking, transparent,
    or shown as a wireframe. The resulting `THREE.Mesh` object can then be added to
    the scene to be rendered by Three.js. Until now, we haven''t really looked at
    materials in much detail. In this chapter, we''ll dive into all the materials
    Three.js has to offer, and you''ll learn how you can use these materials to create
    good-looking 3D objects. The materials we''ll explore in this chapter are shown
    in the following table:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们简要地讨论了材质。你了解到，材质与 `THREE.Geometry` 一起构成 `THREE.Mesh`。材质就像物体的皮肤，定义了几何体的外观。例如，皮肤定义了几何体是否看起来像金属、透明，或者以线框形式显示。然后，生成的
    `THREE.Mesh` 对象可以被添加到场景中，由 Three.js 进行渲染。到目前为止，我们还没有真正详细地查看材质。在本章中，我们将深入了解 Three.js
    提供的所有材质，并学习如何使用这些材质创建外观良好的 3D 对象。本章我们将探讨的材质如下表所示：
- en: '| Name | Description |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `MeshBasicMaterial` | This is a basic material that you can use to give your
    geometries a simple color or show the wireframe of your geometries. |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| `MeshBasicMaterial` | 这是一种基本材质，你可以用它为你的几何体赋予简单的颜色或显示几何体的线框。 |'
- en: '| `MeshDepthMaterial` | This is a material that uses the distance from the
    camera to determine how to color your mesh. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| `MeshDepthMaterial` | 这是一种使用与相机之间的距离来确定如何着色网格的材质。 |'
- en: '| `MeshNormalMaterial` | This is a simple material that bases the color of
    a face on its normal vector. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| `MeshNormalMaterial` | 这是一种简单的材质，它根据面的法向量来决定面的颜色。 |'
- en: '| `MeshFacematerial` | This is a container that allows you to specify a unique
    material for each face of the geometry. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `MeshFacematerial` | 这是一个容器，允许你为几何体的每个面指定一个独特的材质。 |'
- en: '| `MeshLambertMaterial` | This is a material that takes lighting into account
    and is used to create *dull* non-shiny-looking objects. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `MeshLambertMaterial` | 这是一种考虑光照的材质，用于创建 *暗淡* 的非闪亮物体。 |'
- en: '| `MeshPhongMaterial` | This is a material that also takes lighting into account
    and can be used to create shiny objects. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `MeshPhongMaterial` | 这是一种也考虑光照的材质，可以用来创建闪亮的物体。 |'
- en: '| `ShaderMaterial` | This material allows you to specify your own shader programs
    to directly control how vertices are positioned and pixels are colored. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `ShaderMaterial` | 这种材质允许你指定自己的着色器程序，以直接控制顶点的位置和像素的着色。 |'
- en: '| `LineBasicMaterial` | This is a material that can be used on the `THREE.Line`
    geometry to create colored lines. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `LineBasicMaterial` | 这是一种可以用于 `THREE.Line` 几何体以创建彩色线条的材质。 |'
- en: '| `LineDashMaterial` | This is the same as `LineBasicMaterial`, but this material
    also allows you to create a dashed effect. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `LineDashMaterial` | 这与 `LineBasicMaterial` 相同，但此材质还允许你创建虚线效果。 |'
- en: If you look through the source code of Three.js, you might run into `THREE.RawShaderMaterial`.
    This is a specialized material that can only be used together with `THREE.BufferedGeometry`.
    This geometry is a specialized form that is optimized for static geometries (for
    instance, vertices and faces don't change). We won't explore this material in
    this chapter, but we will use it in [Chapter 11](ch11.html "Chapter 11. Custom
    Shaders and Render Postprocessing"), *Custom Shaders and Render Postprocessing*,
    when we talk about creating custom shaders. In the code, you can also find `THREE.SpriteCanvasMaterial`,
    `THREE.SpriteMaterial`, and `THREE.PointCloudMaterial`. These are materials you
    use when styling individual points. We won't discuss those in this chapter, but
    we'll explore them in [Chapter 7](ch07.html "Chapter 7. Particles, Sprites, and
    the Point Cloud"), *Particles, Sprites, and the Point Cloud*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览了 Three.js 的源代码，你可能会遇到 `THREE.RawShaderMaterial`。这是一种只能与 `THREE.BufferedGeometry`
    一起使用的专用材质。这种几何体是一种优化了静态几何体（例如，顶点和面不会改变）的专用形式。我们不会在本章中探讨这种材质，但当我们谈到创建自定义着色器时，我们将在
    [第 11 章](ch11.html "第 11 章。自定义着色器和渲染后处理")，*自定义着色器和渲染后处理* 中使用它。在代码中，你还可以找到 `THREE.SpriteCanvasMaterial`、`THREE.SpriteMaterial`
    和 `THREE.PointCloudMaterial`。这些是在样式化单个点时使用的材质。我们不会在本章中讨论这些，但将在 [第 7 章](ch07.html
    "第 7 章。粒子、精灵和点云")，*粒子、精灵和点云* 中探讨它们。
- en: Materials have a number of common properties, so before we look at the first
    material, `MeshBasicMaterial`, we'll look at the properties shared by all the
    materials.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 材质有许多常见属性，所以在我们查看第一个材质，`MeshBasicMaterial` 之前，我们将查看所有材质共享的属性。
- en: Understanding common material properties
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解常见材质属性
- en: 'You can quickly see for yourself which properties are shared between all the
    materials. Three.js provides a material base class, `THREE.Material`, that lists
    all the common properties. We''ve divided these common material properties into
    the following three categories:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以快速地看到所有材料之间共享哪些属性。Three.js提供了一个材质基类，`THREE.Material`，其中列出了所有常见属性。我们将这些常见材质属性分为以下三个类别：
- en: '**Basic properties**: These are the properties you''ll use most often. With
    these properties, you can, for instance, control the opacity of the object, whether
    it is visible, and how it is referenced (by ID or custom name).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本属性**：这些是你最常使用的属性。使用这些属性，例如，你可以控制对象的透明度、是否可见以及如何引用（通过 ID 或自定义名称）。'
- en: '**Blending properties**: Every object has a set of blending properties. These
    properties define how the object is combined with its background.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合属性**：每个对象都有一组混合属性。这些属性定义了对象如何与其背景结合。'
- en: '**Advanced properties**: There are a number of advanced properties that control
    how the low-level WebGL context renders objects. In most cases, you won''t need
    to mess with these properties.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级属性**：有一些高级属性控制了低级 WebGL 上下文如何渲染对象。在大多数情况下，你不需要与这些属性打交道。'
- en: Note that in this chapter, we skip any properties related to textures and maps.
    Most materials allow you to use images as textures (for instance, a wood-like
    or stone-like texture). In [Chapter 10](ch10.html "Chapter 10. Loading and Working
    with Textures"), *Loading and Working with Textures*, we will dive into the various
    texture and mapping options that are available. Some materials also have specific
    properties related to animation (skinning and `morphTargets`); we'll also skip
    those properties. These will be addressed in [Chapter 9](ch09.html "Chapter 9. Animations
    and Moving the Camera"), *Animations and Moving the Camera*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本章中，我们跳过了任何与纹理和贴图相关的属性。大多数材质允许你使用图像作为纹理（例如，类似木材或石头的纹理）。在[第 10 章](ch10.html
    "第 10 章。加载和使用纹理")，*加载和使用纹理*中，我们将深入了解可用的各种纹理和贴图选项。一些材质还具有与动画相关的特定属性（蒙皮和 `morphTargets`）；我们也将跳过这些属性。这些将在[第
    9 章](ch09.html "第 9 章。动画和移动相机")，*动画和移动相机*中讨论。
- en: 'We start with the first one from the list: the basic properties.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从列表中的第一个开始：基本属性。
- en: Basic properties
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本属性
- en: 'The basic properties of the `THREE.Material` object are listed in the following
    table (you can see these properties in action in the section on `THREE.BasicMeshMaterial`):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.Material` 对象的基本属性列在以下表格中（你可以在 `THREE.BasicMeshMaterial` 部分看到这些属性的实际应用）：'
- en: '| Property | Description |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `id` | This is used to identify a material and is assigned when you create
    a material. This starts at `0` for the first material and is increased by `1`
    for each additional material that is created. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `id` | 这用于识别材质，并在创建材质时分配。第一个材质从 `0` 开始，并为每个额外创建的材质增加 `1`。|'
- en: '| `uuid` | This is a uniquely generated ID and is used internally. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `uuid` | 这是一个唯一生成的 ID，并在内部使用。|'
- en: '| `name` | You can assign a name to a material with this property. This can
    be used for debugging purposes. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 你可以使用此属性给材质分配一个名称。这可以用于调试目的。|'
- en: '| `opacity` | This defines how transparent an object is. Use this together
    with the `transparent` property. The range of this property is from `0` to `1`.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `opacity` | 这定义了对象的透明度。请与 `transparent` 属性一起使用。此属性的取值范围从 `0` 到 `1`。|'
- en: '| `transparent` | If this is set to `true`, Three.js will render this object
    with the set opacity. If this is set to `false`, the object won''t be transparent—just
    more lightly colored. This property should also be set to `true` if you use a
    texture that uses an alpha (transparency) channel. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `transparent` | 如果设置为 `true`，Three.js 将使用设置的透明度渲染此对象。如果设置为 `false`，对象将不会透明——只是颜色更浅。如果你使用了一个使用
    alpha（透明度）通道的纹理，此属性也应设置为 `true`。|'
- en: '| `overdraw` | When you use `THREE.CanvasRenderer`, the polygons will be rendered
    a bit bigger. Set this to `true` when you see gaps when using this renderer. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `overdraw` | 当你使用 `THREE.CanvasRenderer` 时，多边形将被渲染得略大一些。当你使用此渲染器看到间隙时，请将此设置为
    `true`。|'
- en: '| `visible` | This defines whether this material is visible. If you set this
    to `false`, you won''t see the object in the scene. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `visible` | 这定义了此材料是否可见。如果你将其设置为`false`，你将不会在场景中看到该对象。|'
- en: '| `Side` | With this property, you can define to which side of the geometry
    a material is applied. The default is `THREE.Frontside`, which applies the material
    to the front (outside) of an object. You can also set this to `THREE.BackSide`,
    which applies is to the back (inside), or `THREE.DoubleSide`, which applies it
    to both sides. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `Side` | 使用此属性，你可以定义材料应用于几何形状的哪一侧。默认是`THREE.Frontside`，它将材料应用于对象的正面（外部）。你也可以将其设置为`THREE.BackSide`，将其应用于背面（内部），或`THREE.DoubleSide`，将其应用于两侧。|'
- en: '| `needsUpdate` | For some updates to the material, you need to tell Three.js
    that the material has been changed. If this property is set to `true`, Three.js
    will update its cache with the new material properties. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `needsUpdate` | 对于材料的某些更新，你需要告诉Three.js该材料已更改。如果此属性设置为`true`，Three.js将使用新的材料属性更新其缓存。|'
- en: For each material, you can also set a number of blending properties.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种材料，你还可以设置多个混合属性。
- en: Blending properties
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合属性
- en: 'Materials have a couple of generic blending-related properties. Blending determines
    how the colors we render interact with the colors that are behind them. We''ll
    touch upon this subject a little bit when we talk about combining materials. The
    blending properties are listed in the following table:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 材料有几个通用的与混合相关的属性。混合决定了我们渲染的颜色如何与它们后面的颜色交互。当我们讨论组合材料时，我们会稍微涉及这个主题。混合属性列在以下表格中：
- en: '| Name | Description |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `blending` | This determines how the material on this object blends with
    the background. The normal mode is `THREE.NormalBlending`, which only shows the
    top layer. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `blending` | 这确定此对象上的材料如何与背景混合。正常模式是`THREE.NormalBlending`，它只显示顶层。|'
- en: '| `blendsrc` | Besides using the standard blending modes, you can also create
    custom blend modes by setting `blendsrc`, `blenddst`, and `blendequation`. This
    property defines how this object (the source) is blended into the background (the
    destination). The default `THREE.SrcAlphaFactor` setting uses the alpha (transparency)
    channel for blending. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `blendsrc` | 除了使用标准混合模式外，你还可以通过设置`blendsrc`、`blenddst`和`blendequation`来创建自定义混合模式。此属性定义了如何将此对象（源）混合到背景（目标）。默认的`THREE.SrcAlphaFactor`设置使用alpha（透明度）通道进行混合。|'
- en: '| `blenddst` | This property defines how the background (the destination) is
    used in blending and defaults to `THREE.OneMinusSrcAlphaFactor`, which means this
    property too uses the alpha channel of the source for blending but uses `1` (alpha
    channel of the source) as the value. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `blenddst` | 此属性定义了在混合中如何使用背景（目标），默认为`THREE.OneMinusSrcAlphaFactor`，这意味着此属性也使用源alpha通道进行混合，但使用`1`（源的alpha通道）作为值。|'
- en: '| `blendequation` | This defines how the `blendsrc` and `blenddst` values are
    used. The default is to add them (`AddEquation`). With these three properties,
    you can create your own custom blend modes. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `blendequation` | 这定义了如何使用`blendsrc`和`blenddst`值。默认是相加（`AddEquation`）。通过这三个属性，你可以创建自己的自定义混合模式。|'
- en: The last set of properties is mostly used internally and controls the specifics
    of how WebGL is used to render the scene.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一批属性主要用于内部，并控制WebGL渲染场景的具体细节。
- en: Advanced properties
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级属性
- en: 'We won''t go into the details of these properties. These are related to how
    WebGL works internally. If you do want to know more about these properties, the
    OpenGL specification is a good starting point. You can find this specification
    at [http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf](http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf).
    The following table provides a brief description of these advanced properties:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这些属性的细节。这些属性与WebGL内部工作方式有关。如果你确实想了解更多关于这些属性的信息，OpenGL规范是一个好的起点。你可以在此规范中找到[http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf](http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf)。以下表格提供了这些高级属性的简要描述：
- en: '| Name | Description |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `depthTest` | This is an advanced WebGL property. With this property, you
    can enable or disable the `GL_DEPTH_TEST` parameter. This parameter controls whether
    the *depth* of a pixel is used to determine a new pixel''s value. Normally, you
    wouldn''t need to change this. More information can be found in the OpenGL specifications
    we mentioned earlier. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `depthTest` | 这是一个高级 WebGL 属性。使用此属性，您可以选择启用或禁用 `GL_DEPTH_TEST` 参数。此参数控制是否使用像素的
    *深度* 来确定新像素的值。通常，您不需要更改此参数。更多信息可以在我们之前提到的 OpenGL 规范中找到。|'
- en: '| `depthWrite` | This is another internal property. This property can be used
    to determine whether this material affects the WebGL depth buffer. If you use
    an object for a 2D overlay (for example, a hub), you should set this property
    to `false`. Usually, though, you shouldn''t need to change this property. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `depthWrite` | 这是另一个内部属性。此属性可以用来确定此材质是否影响 WebGL 深度缓冲区。如果您使用一个对象作为 2D 浮层（例如，一个中心点），您应该将此属性设置为
    `false`。不过，通常您不需要更改此属性。|'
- en: '| `polygonOffset`, `polygonOffsetFactor`, and `polygonOffsetUnits` | With these
    properties, you can control the `POLYGON_OFFSET_FILL` WebGL feature. These are
    normally not needed. For an explanation of what they do in detail, you can look
    at the OpenGL specifications. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `polygonOffset`、`polygonOffsetFactor` 和 `polygonOffsetUnits` | 使用这些属性，您可以控制
    `POLYGON_OFFSET_FILL` WebGL 功能。这些属性通常不需要。有关它们详细功能的解释，您可以查看 OpenGL 规范。|'
- en: '| `alphatest` | This value can be set to a specific value (`0` to `1`). Whenever
    a pixel has an alpha value smaller than this value, it won''t be drawn. You can
    use this property to remove some transparency-related artifacts. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `alphatest` | 此值可以设置为特定值（`0` 到 `1`）。每当一个像素的 alpha 值小于此值时，它将不会被绘制。您可以使用此属性来移除一些与透明度相关的伪影。|'
- en: Now, let's look at all the available materials so that you can see the effect
    these properties have on the rendered output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看所有可用的材质，以便您可以看到这些属性对渲染输出的影响。
- en: Starting with a simple mesh
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个简单的网格开始
- en: 'In this section, we''ll look at a few simple materials: `MeshBasicMaterial`,
    `MeshDepthMaterial`, `MeshNormalMaterial`, and `MeshFaceMaterial`. We start with
    `MeshBasicMaterial`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些简单的材质：`MeshBasicMaterial`、`MeshDepthMaterial`、`MeshNormalMaterial`
    和 `MeshFaceMaterial`。我们首先从 `MeshBasicMaterial` 开始。
- en: 'Before we look into the properties of these materials, here''s a quick note
    on how you can pass in properties to configure the materials. There are two options:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这些材质的属性之前，这里有一个关于如何传递属性以配置材质的快速说明。有两种选项：
- en: 'You can pass in the arguments in the constructor as a parameters object, like
    this:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将参数对象作为构造函数的参数传递，如下所示：
- en: '[PRE0]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can also create an instance and set the properties individually,
    like this:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您也可以创建一个实例并单独设置属性，如下所示：
- en: '[PRE1]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Usually, the best way is to use the constructor if we know all the properties'
    values while creating the material. The arguments used in both these styles use
    the same format. The only exception to this rule is the `color` property. In the
    first style, we can just pass in the hex value, and Three.js will create a `THREE.Color`
    object itself. In the second style, we have to explicitly create a `THREE.Color`
    object. In this book, we'll use both of these styles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果我们知道创建材质时所有属性的值，使用构造函数是最好的方式。这两种风格中使用的参数格式相同。唯一的例外是 `color` 属性。在第一种风格中，我们可以直接传递十六进制值，Three.js
    将自己创建一个 `THREE.Color` 对象。在第二种风格中，我们必须显式创建一个 `THREE.Color` 对象。在本书中，我们将使用这两种风格。
- en: THREE.MeshBasicMaterial
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshBasicMaterial
- en: '`MeshBasicMaterial` is a very simple material that doesn''t take into account
    the lights that are available in the scene. Meshes with this material will be
    rendered as simple, flat polygons, and you also have the option to show the geometry''s
    wireframe. Besides the common properties we saw in the earlier section on this
    material, we can set the following properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeshBasicMaterial` 是一个非常简单的材质，它不考虑场景中可用的灯光。使用此材质的网格将被渲染为简单的、平面的多边形，并且您还可以选择显示几何体的线框。除了我们在本材料早期部分看到的常见属性外，我们还可以设置以下属性：'
- en: '| Name | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This property allows you to set the color of the material. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 此属性允许您设置材质的颜色。|'
- en: '| `wireframe` | This allows you to render the material as a wireframe. This
    is great for debugging purposes. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `wireframe` | 这允许您将材质渲染为线框。这对于调试目的非常有用。|'
- en: '| `Wireframelinewidth` | If you enable the wireframe, this property defines
    the width of the wires from the wireframe. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `Wireframelinewidth` | 如果您启用了线框，此属性定义线框中线的宽度。 |'
- en: '| `Wireframelinecap` | This property defines how the ends of lines look in
    wireframe mode. The possible values are `butt`, `round`, and `square`. The default
    value is `round`. In practice, the results from changing this property are very
    difficult to see. This property isn''t supported on `WebGLRenderer`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `Wireframelinecap` | 此属性定义在线框模式中线条的末端看起来如何。可能的值有 `butt`、`round` 和 `square`。默认值是
    `round`。在实际应用中，更改此属性的结果很难看到。此属性在 `WebGLRenderer` 上不受支持。 |'
- en: '| `wireframeLinejoin` | This defines how the line joints are visualized. The
    possible values are `round`, `bevel`, and `miter`. The default value is `round`.
    If you look very closely, you can see this in the example using low `opacity`
    and a very large `wireframeLinewidth` value. This property isn''t supported on
    `WebGLRenderer`. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `wireframeLinejoin` | 这定义了如何可视化线条接合处。可能的值有 `round`、`bevel` 和 `miter`。默认值是
    `round`。如果您非常仔细地看，您可以在使用低 `opacity` 和非常大的 `wireframeLinewidth` 值的示例中看到这一点。此属性在
    `WebGLRenderer` 上不受支持。 |'
- en: '| `Shading` | This defines how shading is applied. The possible values are
    `THREE.SmoothShading`, `THREE.NoShading`, and `THREE.FlatShading`. The default
    value is `THREE.SmoothShading`, which results in a smooth object where you won''t
    see the individual faces. This property isn''t enabled in the example for this
    material. For an example, look at the section on `MeshNormalMaterial`. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `Shading` | 这定义了如何应用阴影。可能的值有 `THREE.SmoothShading`、`THREE.NoShading` 和 `THREE.FlatShading`。默认值是
    `THREE.SmoothShading`，这会导致一个平滑的对象，您不会看到单个面。此属性在此材质的示例中未启用。例如，请参阅 `MeshNormalMaterial`
    的部分。 |'
- en: '| `vertexColors` | You can define individual colors to be applied to each vertex
    with this property. The default value is `THREE.NoColors`. If you set this value
    to `THREE.VertexColors`, the renderer will take the colors set on the colors property
    of `THREE.Geometry` into account.This property doesn''t work on `CanvasRenderer`
    but does work on `WebGLRenderer`. Look at the `LineBasicMaterial` example, where
    we use this property to color the various parts of a line. You can also use this
    property to create a gradient effect for this material type. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `vertexColors` | 您可以使用此属性为每个顶点定义单独的颜色。默认值是 `THREE.NoColors`。如果您将此值设置为 `THREE.VertexColors`，渲染器将考虑
    `THREE.Geometry` 的颜色属性上设置的颜色。此属性在 `CanvasRenderer` 上不起作用，但在 `WebGLRenderer` 上起作用。查看
    `LineBasicMaterial` 示例，我们使用此属性为线条的各个部分着色。您还可以使用此属性为此材质类型创建渐变效果。 |'
- en: '| `fog` | This property determines whether this material is affected by global
    fog settings. This is not shown in action, but if this is set to `false`, the
    global fog we saw in [Chapter 2](ch02.html "Chapter 2. Basic Components That Make
    Up a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*, doesn''t
    affect how this object is rendered. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `fog` | 此属性确定此材质是否受全局雾设置的影响。此效果在动作中未显示，但如果将其设置为 `false`，我们在[第2章](ch02.html
    "第2章。构成Three.js场景的基本组件")中看到的全局雾*构成Three.js场景的基本组件*不会影响此对象的渲染。 |'
- en: 'In the previous chapters, we saw how to create materials and assign them to
    objects. For `THREE.MeshBasicMaterial`, we do it like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何创建材质并将它们分配给对象。对于 `THREE.MeshBasicMaterial`，我们这样做：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a new `THREE.MeshBasicMaterial` and initializes the `color` property
    to `0x7777ff` (which is purple).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的 `THREE.MeshBasicMaterial` 并将 `color` 属性初始化为 `0x7777ff`（这是紫色）。
- en: 'I''ve added an example that you can use to play around with the `THREE.MeshBasicMaterial`
    properties and the basic properties we discussed in the previous section. If you
    open up the `01-basic-mesh-material.html` example in the `chapter-04` folder,
    you''ll see a rotating cube like the one shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个示例，您可以使用它来尝试 `THREE.MeshBasicMaterial` 的属性和我们在上一节中讨论的基本属性。如果您打开 `chapter-04`
    文件夹中的 `01-basic-mesh-material.html` 示例，您将看到一个旋转的立方体，就像以下截图所示：
- en: '![THREE.MeshBasicMaterial](img/2215OS_04_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshBasicMaterial](img/2215OS_04_01.jpg)'
- en: 'This is a very simple object. With the menu in the upper-right corner, you
    can play around with the properties and select different meshes (you can also
    change the renderer). For instance, a sphere with `opacity` of `0.2`, `transparent`
    set to `true`, `wireframe` set to `true`, `wireframeLinewidth` of `9`, and using
    `CanvasRenderer` is rendered like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的对象。通过右上角的菜单，你可以玩转其属性并选择不同的网格（你还可以更改渲染器）。例如，一个具有`opacity`为`0.2`、`transparent`设置为`true`、`wireframe`设置为`true`、`wireframeLinewidth`为`9`，并使用`CanvasRenderer`渲染出来的效果如下：
- en: '![THREE.MeshBasicMaterial](img/2215OS_04_02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshBasicMaterial](img/2215OS_04_02.jpg)'
- en: One of the properties you can set in this example is the `side` property. With
    this property, you define to which side of `THREE.Geometry` the material is applied.
    You can test how this property works when you select the plane mesh. Since normally
    a material is only applied to the front side of a material, the rotating plane
    will be invisible half the time (when it shows it's back to you). If you set the
    `side` property to `double`, the plane will be visible the whole time, since the
    material is applied to both sides of the geometry. Note, though, that the renderer
    will need to do more work when the `side` property is set to `double`, so this
    could have an impact on the performance of your scene.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以设置的属性之一是`side`属性。使用这个属性，你定义材质应用于`THREE.Geometry`的哪一侧。当你选择平面网格时，你可以测试这个属性的工作方式。由于通常材质只应用于材质的前面，旋转的平面将有一半的时间是不可见的（当你看到它的背面时）。如果你将`side`属性设置为`double`，则平面将始终可见，因为材质应用于几何体的两侧。不过，请注意，当`side`属性设置为`double`时，渲染器需要做更多的工作，这可能会影响场景的性能。
- en: THREE.MeshDepthMaterial
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshDepthMaterial
- en: 'The next material on the list is `THREE.MeshDepthMaterial`. With this material,
    the way an object looks isn''t defined by lights or by a specific material property;
    it is defined by the distance from the object to the camera. You can combine this
    with other materials to easily create fading effects. The only relevant properties
    this material has are the following two that control whether you want to show
    a wireframe:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的下一个材质是`THREE.MeshDepthMaterial`。使用这种材质，对象的视觉效果不是由灯光或特定的材质属性定义的；它是由对象到摄像机的距离定义的。你可以结合其他材质，轻松创建渐变效果。这种材质只有以下两个相关属性，用于控制是否显示线框：
- en: '| Name | Description |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wireframe` | This determines whether or not to show the wireframe. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `wireframe` | 这决定了是否显示线框。 |'
- en: '| `wireframeLineWidth` | This determines the width of the wireframe. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `wireframeLineWidth` | 这决定了线框的宽度。 |'
- en: 'To demonstrate this, we modified the cubes example from [Chapter 2](ch02.html
    "Chapter 2. Basic Components That Make Up a Three.js Scene"), *Basic Components
    That Make Up a Three.js Scene* (`02-depth-material` from the `chapter-04` folder).
    Remember that you have to click on the **addCube** button to populate the scene.
    The following screenshot shows the modified example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们修改了[第2章](ch02.html "第2章. 构成Three.js场景的基本组件")，*构成Three.js场景的基本组件*（`chapter-04`文件夹中的`02-depth-material`）中的立方体示例。记住，你必须点击**addCube**按钮来填充场景。以下截图显示了修改后的示例：
- en: '![THREE.MeshDepthMaterial](img/2215OS_04_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshDepthMaterial](img/2215OS_04_03.jpg)'
- en: Even though the material doesn't have many additional properties to control
    how an object is rendered, we can still control how fast the object's color fades
    out. In this example, we exposed the `near` and `far` properties of the camera.
    As you probably remember from [Chapter 2](ch02.html "Chapter 2. Basic Components
    That Make Up a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*,
    with these two properties, we set the visible area for the camera. Any objects
    that are nearer to the camera than the `near` property aren't shown, and any objects
    further away than the `far` property also fall outside the camera's visible area.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种材质没有很多额外的属性来控制对象的渲染方式，我们仍然可以控制对象颜色淡出的速度。在这个例子中，我们暴露了摄像机的`near`和`far`属性。你可能还记得[第2章](ch02.html
    "第2章. 构成Three.js场景的基本组件")，*构成Three.js场景的基本组件*，通过这两个属性，我们设置了摄像机的可见区域。任何比`near`属性更靠近摄像机的对象都不会显示，任何比`far`属性更远的对象也超出了摄像机的可见区域。
- en: 'The distance between the `near` and `far` properties of the camera defines
    the brightness and the rate at which objects fade out. If the distance is very
    large, objects will only fade out a little as they move away from the camera.
    If the distance is small, the fadeout will be much more notable (as you can see
    in the following screenshot):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 照相机 `near` 和 `far` 属性之间的距离定义了亮度以及物体淡出的速率。如果距离非常大，物体在远离照相机时只会稍微淡出。如果距离很小，淡出将会更加明显（如下面的截图所示）：
- en: '![THREE.MeshDepthMaterial](img/2215OS_04_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshDepthMaterial](img/2215OS_04_04.jpg)'
- en: 'Creating `THREE.MeshDepthMaterial` is very easy and the object doesn''t require
    any arguments. For this example, we''ve used the `scene.overrideMaterial` property
    to make sure all the objects in the scene use this material without having to
    explicitly specify it for each `THREE.Mesh` object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `THREE.MeshDepthMaterial` 非常简单，该对象不需要任何参数。在这个例子中，我们使用了 `scene.overrideMaterial`
    属性来确保场景中的所有对象都使用这种材料，而无需为每个 `THREE.Mesh` 对象显式指定它：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The next part in this chapter isn't really about a specific material, but shows
    a way in which you can combine multiple materials together.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一部分并不是真的关于某种特定的材料，而是展示了你可以将多个材料组合在一起的方法。
- en: Combining materials
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料组合
- en: 'If you look back at the properties of `THREE.MeshDepthMaterial`, you can see
    that there isn''t an option to set the color of the cubes. Everything was decided
    for you by the default properties of the material. Three.js, however, has the
    option to combine materials together to create new effects (this is also where
    blending comes into play). The following code shows how we can combine materials
    together:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下 `THREE.MeshDepthMaterial` 的属性，你可以看到没有选项可以设置立方体的颜色。所有的事情都是由材料的默认属性为你决定的。然而，Three.js
    提供了将材料组合在一起以创建新效果的选择（这也是混合模式发挥作用的地方）。以下代码显示了如何将材料组合在一起：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We get the following green-colored cubes that use the brightness from `THREE.MeshDepthMaterial`
    and the color from `THREE.MeshBasicMaterial` (open `03-combined-material.html`
    for this example). The following screenshot shows the example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下使用 `THREE.MeshDepthMaterial` 的亮度和 `THREE.MeshBasicMaterial` 的颜色的绿色立方体（打开
    `03-combined-material.html` 以查看此示例）。以下截图显示了示例：
- en: '![Combining materials](img/2215OS_04_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![结合材料](img/2215OS_04_05.jpg)'
- en: Let's look at the steps you need to take to get this specific result.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你需要采取哪些步骤来获得这个具体的结果。
- en: First, we need to create our two materials. For `THREE.MeshDepthMaterial`, we
    don't do anything special; for `THREE.MeshBasicMaterial`, however, we set `transparent`
    to `true` and define a `blending` mode. If we don't set the `transparent` property
    to `true`, we'll just have solid, green objects since Three.js won't know to take
    the already-rendered colors into account. With `transparent` set to `true`, Three.js
    will check the `blending` property to see how the green `THREE.MeshBasicMaterial`
    object should interact with the background. The background in this case is the
    cube rendered with `THREE.MeshDepthMaterial`. In [Chapter 9](ch09.html "Chapter 9. Animations
    and Moving the Camera"), *Animations and Moving the Camera*, we'll discuss in
    greater detail the various blend modes that are available.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的两种材料。对于 `THREE.MeshDepthMaterial`，我们不做任何特殊处理；然而，对于 `THREE.MeshBasicMaterial`，我们设置
    `transparent` 为 `true` 并定义一个 `blending` 模式。如果我们不将 `transparent` 属性设置为 `true`，那么我们只会得到实心的绿色物体，因为
    Three.js 不会知道要考虑已经渲染的颜色。当 `transparent` 设置为 `true` 时，Three.js 将检查 `blending` 属性以查看绿色
    `THREE.MeshBasicMaterial` 对象应该如何与背景交互。在这个例子中，背景是使用 `THREE.MeshDepthMaterial` 渲染的立方体。在
    [第 9 章](ch09.html "第 9 章。动画和移动相机")，*动画和移动相机* 中，我们将更详细地讨论可用的各种混合模式。
- en: 'For this example, though, we used `THREE.MultiplyBlending`. This blend mode
    multiplies the foreground color with the background color and gives you the desired
    effect. The last line in this code fragment is also an important one. What happens
    when we create a mesh with the `THREE.SceneUtils.createMultiMaterialObject()`
    function is that the geometry gets copied and two exactly the same meshes are
    returned in a group. If we render these without the last line, you should see
    a flickering effect. This can happen sometimes when objects are rendered one on
    top of the other and one of them is transparent. By scaling down the mesh created
    with `THREE.MeshDepthMaterial`, we can avoid this. To do so, use the following
    code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在这个例子中，我们使用了 `THREE.MultiplyBlending`。这种混合模式将前景色与背景色相乘，从而得到所需的效果。这段代码片段中的最后一行也是很重要的一行。当我们使用
    `THREE.SceneUtils.createMultiMaterialObject()` 函数创建网格时会发生什么，几何体被复制，并返回两个完全相同的网格组。如果我们不使用最后一行渲染这些网格，你应该会看到一个闪烁的效果。这种情况有时会在一个物体渲染在另一个物体之上，并且其中一个物体是透明的时候发生。通过缩小使用
    `THREE.MeshDepthMaterial` 创建的网格，我们可以避免这种情况。要做到这一点，请使用以下代码：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next material is also one where we won't have any influence on the colors
    used in rendering.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个材质也是我们不会对渲染中使用的颜色产生任何影响的一种材质。
- en: THREE.MeshNormalMaterial
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshNormalMaterial
- en: 'The easiest way to understand how this material is rendered is by first looking
    at an example. Open up the `04-mesh-normal-material.html` example from the `chapter-04`
    folder. If you select the sphere as the mesh, you''ll see something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种材质如何渲染的最简单方法是通过先查看一个示例。打开 `chapter-04` 文件夹中的 `04-mesh-normal-material.html`
    示例。如果你选择球体作为网格，你会看到如下内容：
- en: '![THREE.MeshNormalMaterial](img/2215OS_04_06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshNormalMaterial](img/2215OS_04_06.jpg)'
- en: 'As you can see, each face of the mesh is rendered in a slightly different color,
    and even though the sphere rotates, the colors stay pretty much at the same place.
    This happens because the color of each face is based on the *normal* pointing
    out from the face. This normal is the vector perpendicular to the face. The normal
    vector is used in many different parts of Three.js. It is used to determine light
    reflections, helps in mapping textures to 3D models, and gives information on
    how to light, shade, and color pixels on a surface. Luckily, though, Three.js
    handles the computation of these vectors and uses them internally, so you don''t
    have to calculate them yourselves. The following screenshot shows all the normal
    vectors of `THREE.SphereGeometry`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，网格的每个面都以略不同的颜色渲染，即使球体旋转，颜色也基本保持在同一位置。这是因为每个面的颜色基于从面指向外的 *法线*。这个法线是与面垂直的向量。法线向量在
    Three.js 的许多不同部分中使用。它用于确定光反射，帮助将纹理映射到 3D 模型，并提供了有关如何在表面上光照、阴影和着色的信息。幸运的是，尽管如此，Three.js
    处理这些向量的计算并在内部使用它们，所以你不必自己计算它们。以下截图显示了 `THREE.SphereGeometry` 的所有法线向量：
- en: '![THREE.MeshNormalMaterial](img/2215OS_04_07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshNormalMaterial](img/2215OS_04_07.jpg)'
- en: 'The direction this normal points in determines the color a face gets when you
    use `THREE.MeshNormalMaterial`. Since all normals for the faces of a sphere point
    in a different direction, we get the colorful sphere you can see in the examples.
    As a quick side note, to add these normal arrows, you can use `THREE.ArrowHelper`
    like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个法线指向的方向决定了当你使用 `THREE.MeshNormalMaterial` 时，面得到的颜色。由于球体上所有面的法线指向不同的方向，所以我们得到了在示例中可以看到的多彩球体。作为一个快速的小贴士，要添加这些法线箭头，你可以像这样使用
    `THREE.ArrowHelper`：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this code snippet, we iterate through all the faces of `THREE.SphereGeometry`.
    For each of these `THREE.Face3` objects, we calculate the center (the centroid)
    by adding the vertices that make up this face and dividing the result by 3\. We
    use this centroid, together with the normal vector of the face, to draw an arrow.
    The `THREE.ArrowHelper` takes the following arguments: `direction`, `origin`,
    `length`, `color`, `headLength`, and `headWidth`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们遍历 `THREE.SphereGeometry` 的所有面。对于这些 `THREE.Face3` 对象中的每一个，我们通过将构成这个面的顶点相加并除以
    3 来计算中心（质心）。我们使用这个质心，以及面的法线向量，来绘制箭头。`THREE.ArrowHelper` 接受以下参数：`direction`、`origin`、`length`、`color`、`headLength`
    和 `headWidth`。
- en: 'There are a couple of other properties that you can set on `THREE.MeshNormalMaterial`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `THREE.MeshNormalMaterial` 上设置一些其他属性：
- en: '| Name | Description |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wireframe` | This determines whether or not to show the wireframe. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `wireframe` | 这确定是否显示线框。 |'
- en: '| `wireframeLineWidth` | This determines the width of the wireframe. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `wireframeLineWidth` | 这决定了线框的宽度。 |'
- en: '| `shading` | This configures shading in the form of flat shading with `THREE.FlatShading`
    and smooth shading with `THREE.SmoothShading`. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `shading` | 这配置了以 `THREE.FlatShading` 的平面着色和 `THREE.SmoothShading` 的平滑着色形式进行的着色。
    |'
- en: 'We''ve already seen `wireframe` and `wireframeLinewidth` but skipped the `shading`
    property in our `THREE.MeshBasicMaterial` example. With the `shading` property,
    we can tell Three.js how to render our objects. If you use `THREE.FlatShading`,
    each face will be rendered as is (as you can see in the previous couple of screenshots),
    or you can use `THREE.SmoothShading`, which smoothens out the faces of our object.
    For instance, if we render the sphere using `THREE.SmoothShading`, the result
    looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `wireframe` 和 `wireframeLinewidth`，但在我们的 `THREE.MeshBasicMaterial` 示例中跳过了
    `shading` 属性。使用 `shading` 属性，我们可以告诉 Three.js 如何渲染我们的对象。如果你使用 `THREE.FlatShading`，每个面将按原样渲染（如前几个截图所示），或者你可以使用
    `THREE.SmoothShading`，这将平滑我们的对象的面。例如，如果我们使用 `THREE.SmoothShading` 渲染球体，结果看起来就像这样：
- en: '![THREE.MeshNormalMaterial](img/2215OS_04_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshNormalMaterial](img/2215OS_04_08.jpg)'
- en: We're almost done with the simple materials. The last one is `THREE.MeshFaceMaterial`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了简单的材料。最后一个材料是 `THREE.MeshFaceMaterial`。
- en: THREE.MeshFaceMaterial
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshFaceMaterial
- en: 'The last of the basic materials isn''t really a material but much more a container
    of other materials. `THREE.MeshFaceMaterial` allows you to assign a different
    material to each face of your geometry. For instance, if you have a cube, which
    has 12 faces (remember, Three.js only works with triangles), you can use this
    material to assign a different material (for example, with a different color)
    to each side of the cube. Using this material is really simple, as you can see
    from the following piece of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 基本材料中的最后一个实际上并不是一种材料，而更多的是其他材料的容器。`THREE.MeshFaceMaterial` 允许你为你的几何形状的每个面分配不同的材料。例如，如果你有一个立方体，它有12个面（记住，Three.js
    只与三角形一起工作），你可以使用这种材料为立方体的每个侧面分配不同的材料（例如，使用不同的颜色）。使用这种材料非常简单，正如你从下面的代码片段中可以看到：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We first create an array, named `matArray`, to hold all the materials. Next,
    we create a new material, `THREE.MeshBasicMaterial` in this example, with a different
    color for each face. With this array, we instantiate `THREE.MeshFaceMaterial`
    and use it together with the cube geometry to create the mesh. Let''s dive a bit
    deeper into the code and see what you need to do to recreate the following example:
    a simple 3D Rubik''s cube. You can find this example in `05-mesh-face-material.html`.
    The following screenshot shows this example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `matArray` 的数组来存储所有材料。接下来，我们创建一个新的材料，在这个例子中是 `THREE.MeshBasicMaterial`，并为每个面分配不同的颜色。使用这个数组，我们实例化
    `THREE.MeshFaceMaterial` 并与立方体几何形状一起使用，以创建网格。让我们更深入地看看代码，看看你需要做什么来重新创建以下示例：一个简单的3D魔方。你可以在
    `05-mesh-face-material.html` 中找到这个示例。以下截图显示了此示例：
- en: '![THREE.MeshFaceMaterial](img/2215OS_04_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshFaceMaterial](img/2215OS_04_09.jpg)'
- en: 'This Rubik''s cube consists of a number of smaller cubes: three cubes along
    the *x* axis, three along the *y* axis, and three along the *z* axis. Here''s
    how this is done:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个魔方由许多小立方体组成：沿着 *x* 轴有三个立方体，沿着 *y* 轴有三个，沿着 *z* 轴也有三个。以下是它是如何实现的：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this piece of code, we first create `THREE.Mesh`, which will hold all the
    individual cubes (`group`); next, we create the materials for each face and push
    them to the `mats` array. Remember, each side of the cube consists of two faces,
    so we need 12 materials. From these materials, we create `THREE.MeshFaceMaterial`.
    Then, we create three loops to make sure we create the right number of cubes.
    In this loop, we create each of the individual cubes, assign the material, position
    them, and add them to the group. What you should remember is that the position
    of the cubes is relative to the position of this group. If we move or rotate the
    group, all the cubes will move and rotate with it. For more information on how
    to work with groups, look at [Chapter 8](ch08.html "Chapter 8. Creating and Loading
    Advanced Meshes and Geometries"), *Creating and Loading Advanced Meshes and Geometries*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先创建 `THREE.Mesh`，它将包含所有单个立方体（`group`）；接下来，我们为每个面创建材质并将它们推送到 `mats`
    数组。记住，立方体的每个侧面由两个面组成，因此我们需要 12 种材质。从这些材质中，我们创建 `THREE.MeshFaceMaterial`。然后，我们创建三个循环以确保创建正确数量的立方体。在这个循环中，我们创建每个单个立方体，分配材质，定位它们，并将它们添加到组中。你应该记住的是，立方体的位置相对于这个组的位置。如果我们移动或旋转组，所有立方体都会随着它移动和旋转。有关如何使用组的更多信息，请参阅[第
    8 章](ch08.html "第 8 章。创建和加载高级网格和几何体")，*创建和加载高级网格和几何体*。
- en: 'If you''ve opened the example in your browser, you can see that the complete
    Rubik''s cube rotates, and not the individual cubes. This happens because we use
    the following in our rendering loop:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在浏览器中打开了示例，你可以看到整个魔方旋转，而不是单个立方体。这是因为我们在渲染循环中使用以下内容：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This causes the complete group to rotate around its center (0,0,0). When we
    positioned the individual cubes, we made sure they were positioned around this
    center point. That's why you see the -3 offset in the `cube.position.set(x * 3
    - 3, y * 3, z * 3 - 3);` line of the preceding code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致整个组围绕其中心（0,0,0）旋转。当我们定位单个立方体时，我们确保它们围绕这个中心点定位。这就是为什么你会在前述代码的 `cube.position.set(x
    * 3 - 3, y * 3, z * 3 - 3);` 行中看到 -3 偏移。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you look at this code, you might wonder how Three.js determines which material
    to use for a specific face. For this, Three.js uses the `materialIndex` property,
    which you can set on each individual face of the `geometry.faces` array. The property
    points to the array index of the materials we add in the constructor of the `THREE.FaceMaterial`
    object. When you create a geometry using one of the standard Three.js geometries,
    Three.js provides sensible defaults. If you want other behavior, you can just
    set the `materialIndex` property yourself for each face to point at one of the
    provided materials.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这段代码，可能会想知道 Three.js 是如何确定用于特定面的材质的。为此，Three.js 使用 `materialIndex` 属性，你可以在
    `geometry.faces` 数组的每个单独的面上设置该属性。该属性指向我们在 `THREE.FaceMaterial` 对象的构造函数中添加的材质的数组索引。当你使用标准
    Three.js 几何体创建几何体时，Three.js 提供了合理的默认值。如果你想有其他行为，你只需为每个面设置 `materialIndex` 属性，使其指向提供的材质之一。
- en: '`THREE.MeshFaceMaterial` was the last of our basic materials. In the next section,
    we''ll look at some of the more advanced materials available in Three.js.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.MeshFaceMaterial` 是我们基本材质中的最后一个。在下一节中，我们将探讨 Three.js 中一些更高级的材质。'
- en: Advanced materials
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级材质
- en: 'In this section, we''ll look at the more advanced materials Three.js has to
    offer. We''ll first look at `THREE.MeshPhongMaterial` and `THREE.MeshLambertMaterial`.
    These two materials react to light sources and can be used to create shiny and
    dull-looking materials, respectively. In this section, we''ll also look at one
    of the most versatile, but most difficult to use, materials: `THREE.ShaderMaterial`.
    With `THREE.ShaderMaterial`, you can create your own shader programs that define
    how the material and object should be shown.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Three.js 提供的更高级的材质。我们首先将探讨 `THREE.MeshPhongMaterial` 和 `THREE.MeshLambertMaterial`。这两种材质对光源做出反应，可以分别用于创建闪亮的和看起来暗淡的材质。在本节中，我们还将探讨一种最通用但最难使用的材质：`THREE.ShaderMaterial`。使用
    `THREE.ShaderMaterial`，你可以创建自己的着色器程序，以定义材质和对象应该如何显示。
- en: THREE.MeshLambertMaterial
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshLambertMaterial
- en: 'This material can be used to create dull-looking, non-shiny surfaces. This
    is a very easy-to-use material that responds to the lighting sources in the scene.
    This material can be configured with a number of properties we''ve seen before:
    `color`, `opacity`, `shading`, `blending`, `depthTest`, `depthWrite`, `wireframe`,
    `wireframeLinewidth`, `wireframeLinecap`, `wireframeLineJoin`, `vertexColors`,
    and `fog`. We won''t go into the details of those properties, but will focus on
    the ones specific to this material. That just leaves us with the following four
    properties:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材料可以用来创建看起来平淡无光、不反光的表面。这是一种非常易于使用的材料，能够对场景中的光源做出反应。这种材料可以配置我们之前见过的多种属性：`颜色`、`不透明度`、`阴影`、`混合`、`深度测试`、`深度写入`、`线框`、`线框线宽`、`线框线帽`、`线框线连接`、`顶点颜色`和`雾效`。我们不会深入探讨这些属性的细节，但会专注于与这种材料相关的特定属性。这仅剩下以下四个属性：
- en: '| Name | Description |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ambient` | This is the *ambient* color of the material. This works together
    with the ambient light we saw in the previous chapter. This color is multiplied
    with the color provided by the ambient light. This defaults to white. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `ambient` | 这是材料的*环境色*。这与我们在上一章中看到的环境光一起工作。此颜色与提供的环境光颜色相乘。默认为白色。|'
- en: '| `emissive` | This is the color this material emits. It doesn''t really act
    as a light source, but this is a solid color that is unaffected by other lighting.
    This defaults to black. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `emissive` | 这是这种材料发出的颜色。它并不真正作为光源，但这是一个不受其他光照影响的实色。默认为黑色。|'
- en: '| `wrapAround` | If this property is set to `true`, you enable the half-lambert
    lighting technique. With half-lambert lighting, the drop-off of light is more
    subtle. If you have a mesh with harsh, dark areas, enabling this property will
    soften the shadows and more evenly distribute the light. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `wrapAround` | 如果此属性设置为`true`，则启用半朗伯光照技术。在半朗伯光照中，光的衰减更为微妙。如果你有一个具有刺眼、黑暗区域的网格，启用此属性将使阴影变柔和，并更均匀地分布光线。|'
- en: '| `wrapRGB` | When `wrapAround` is set to true, you can use `THREE.Vector3`
    to control how fast the light is dropped off. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `wrapRGB` | 当`wrapAround`设置为true时，你可以使用`THREE.Vector3`来控制光衰减的速度。|'
- en: 'This material is created just like all the other ones. Here''s how it''s done:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材料就像所有其他材料一样创建。下面是如何做到的：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For an example of this material, look at `06-mesh-lambert-material.html`. The
    following screenshot shows this example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个这种材料的示例，请查看`06-mesh-lambert-material.html`。以下屏幕截图显示了此示例：
- en: '![THREE.MeshLambertMaterial](img/2215OS_04_10.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshLambertMaterial](img/2215OS_04_10.jpg)'
- en: As you can see in the preceding screenshot, the material looks rather dull.
    There is another material we can use to create shiny surfaces.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所见，这种材料看起来相当平淡。我们还可以使用另一种材料来创建具有光泽的表面。
- en: THREE.MeshPhongMaterial
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshPhongMaterial
- en: 'With `THREE.MeshPhongMaterial`, we can create a material that is shiny. The
    properties you can use for that are pretty much the same as for a non-shiny `THREE.MeshLambertMaterial`
    object. We''ll once again skip the basic properties and those already discussed:
    `color`, `opacity`, `shading`, `blending`, `depthTest`, `depthWrite`, `wireframe`,
    `wireframeLinewidth`, `wireframeLinecap`, `wireframelineJoin`, and `vertexColors`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.MeshPhongMaterial`，我们可以创建一个具有光泽的材料。你可以使用的属性基本上与非光泽的`THREE.MeshLambertMaterial`对象相同。我们再次跳过基本属性和已经讨论过的属性：`颜色`、`不透明度`、`阴影`、`混合`、`深度测试`、`深度写入`、`线框`、`线框线宽`、`线框线帽`、`线框线连接`和`顶点颜色`。
- en: 'The interesting properties for this material are shown in the following table:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材料的有趣属性如下表所示：
- en: '| Name | Description |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ambient` | This is the *ambient* color of the material. This works together
    with the ambient light we saw in the previous chapter. This color is multiplied
    with the color provided by the ambient light. This defaults to white. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `ambient` | 这是材料的*环境色*。这与我们在上一章中看到的环境光一起工作。此颜色与提供的环境光颜色相乘。默认为白色。|'
- en: '| `emissive` | This is the color this material emits. It doesn''t really act
    as a light source, but this is a solid color that is unaffected by other lighting.
    This defaults to black. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `emissive` | 这是这种材料发出的颜色。它并不真正作为光源，但这是一个不受其他光照影响的实色。默认为黑色。|'
- en: '| `specular` | This property defines how shiny the materials are and with what
    color it shines. If this is set to the same color as the `color` property, you
    get a more metallic-looking material. If this is set to grey, it results in a
    more plastic-looking material. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `specular` | 这个属性定义了材质的光泽度和它以什么颜色发光。如果这个设置与 `color` 属性的颜色相同，你会得到一个看起来更金属的材质。如果设置为灰色，则结果是一个看起来更像塑料的材质。|'
- en: '| `shininess` | This property defines how shiny the specular highlight is.
    The default value for the shininess is `30`. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `shininess` | 这个属性定义了镜面高光的光泽度。光泽度的默认值是 `30`。|'
- en: '| `metal` | When this property is set to `true`, Three.js uses a slightly different
    way of calculating the color of a pixel to make the object look more like a metal.
    Note that the effect is very minimal. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `metal` | 当这个属性设置为 `true` 时，Three.js 会使用一种稍微不同的方式来计算像素的颜色，使对象看起来更像金属。请注意，这种效果非常微弱。|'
- en: '| `wrapAround` | If this property is set to `true`, you enable the half-lambert
    lighting technique. With half-lambert lighting, the drop-off of light is more
    subtle. If you have a mesh with harsh, dark areas, enabling this property will
    soften the shadows and more evenly distribute the light. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `wrapAround` | 如果这个属性设置为 `true`，你将启用半朗伯光照技术。使用半朗伯光照，光线的衰减更加微妙。如果你有一个具有刺眼、暗淡区域的网格，启用此属性将使阴影变柔和，并更均匀地分布光线。|'
- en: '| `wrapRGB` | When `wrapAround` is set to `true`, you can use `THREE.Vector3`
    to control how fast the light is dropped off. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `wrapRGB` | 当 `wrapAround` 设置为 `true` 时，你可以使用 `THREE.Vector3` 来控制光线衰减的速度。|'
- en: 'Initializing a `THREE.MeshPhongMaterial` object is done in the same way as
    we''ve already seen for all the other materials and is shown in the following
    line of code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化 `THREE.MeshPhongMaterial` 对象的方式与我们之前看到的所有其他材质相同，如下代码所示：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To give you the best comparison, we''ve created the same example for this material
    as we did for `THREE.MeshLambertMaterial`. You can use the control GUI to play
    around with this material. For instance, the following settings create a plastic-looking
    material. You can find this example in `07-mesh-phong-material.html`. The following
    screenshot shows this example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供最佳的对比，我们为这种材质创建了一个与 `THREE.MeshLambertMaterial` 相同的例子。你可以使用控制 GUI 来玩转这种材质。例如，以下设置创建了一个看起来像塑料的材质。你可以在
    `07-mesh-phong-material.html` 中找到这个例子。以下截图显示了此示例：
- en: '![THREE.MeshPhongMaterial](img/2215OS_04_11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.MeshPhongMaterial](img/2215OS_04_11.jpg)'
- en: The last one of the advanced materials we'll explore is `THREE.ShaderMaterial`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的最后一个高级材质是 `THREE.ShaderMaterial`。
- en: Creating your own shaders with THREE.ShaderMaterial
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 THREE.ShaderMaterial 创建自己的着色器
- en: '`THREE.ShaderMaterial` is one of the most versatile and complex materials available
    in Three.js. With this material, you can pass in your own custom shaders that
    are directly run in the WebGL context. A shader converts Three.js JavaScript meshes
    to pixels on screen. With these custom shaders, you can define exactly how your
    object should be rendered and how to override or alter the defaults from Three.js.
    In this section, we won''t go into the details yet of how to write custom shaders.
    For more information on that, see [Chapter 11](ch11.html "Chapter 11. Custom Shaders
    and Render Postprocessing"), *Custom Shaders and Render Postprocessing*. For now,
    we''ll just look at a very basic example that shows how you can configure this
    material.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.ShaderMaterial` 是 Three.js 中最灵活和复杂的材质之一。使用这种材质，你可以传递自己的自定义着色器，这些着色器将在
    WebGL 上下文中直接运行。着色器将 Three.js 的 JavaScript 网格转换为屏幕上的像素。使用这些自定义着色器，你可以精确地定义你的对象应该如何渲染，以及如何覆盖或修改
    Three.js 的默认设置。在本节中，我们不会深入介绍如何编写自定义着色器的细节。有关更多信息，请参阅[第 11 章](ch11.html "第 11 章。自定义着色器和渲染后处理")，*自定义着色器和渲染后处理*。现在，我们只看一个非常基础的例子，展示如何配置这种材质。'
- en: '`THREE.ShaderMaterial` has a number of properties you can set that we''ve already
    seen. With `THREE.ShaderMaterial`, Three.js passes in all the information regarding
    these properties, but you still have to process the information in your own shader
    programs. The following are the properties of `THREE.ShaderMaterial` that we have
    already seen:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.ShaderMaterial` 有许多你可以设置的属性，我们之前已经见过。使用 `THREE.ShaderMaterial`，Three.js
    会传递所有关于这些属性的信息，但你仍然需要在你的着色器程序中处理这些信息。以下是我们已经见过的 `THREE.ShaderMaterial` 的属性：'
- en: '| Name | Description |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wireframe` | This renders the material as a wireframe. This is great for
    debugging purposes. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `wireframe` | 这会将材质渲染为线框。这对于调试目的非常有用。|'
- en: '| `Wireframelinewidth` | If you enable the wireframe, this property defines
    the width of the wires from the wireframe. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `Wireframelinewidth` | 如果你启用了线框，这个属性定义了线框线的宽度。|'
- en: '| `linewidth` | This defines the width of the line to be drawn. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `linewidth` | 这定义了要绘制的线的宽度。|'
- en: '| `Shading` | This defines how shading is applied. The possible values are
    `THREE.SmoothShading` and `THREE.FlatShading`. This property isn''t enabled in
    the example for this material. For example, look at the section on `MeshNormalMaterial`.
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `Shading` | 这定义了着色是如何应用的。可能的值是`THREE.SmoothShading`和`THREE.FlatShading`。这个属性在这个材质的示例中未启用。例如，看看`MeshNormalMaterial`部分。|'
- en: '| `vertexColors` | You can define individual colors to be applied to each vertex
    with this property. This property doesn''t work on `CanvasRenderer` but does work
    on `WebGLRenderer`. Look at the `LineBasicMaterial` example, where we use this
    property to color the various parts of a line. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `vertexColors` | 你可以使用这个属性为每个顶点定义单独的颜色。这个属性在`CanvasRenderer`上不起作用，但在`WebGLRenderer`上起作用。看看`LineBasicMaterial`示例，我们使用这个属性来为线的各个部分着色。|'
- en: '| `fog` | This determines whether this material is affected by global fog settings.
    This is not shown in action. If this is set to `false`, the global fog we saw
    in [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up a Three.js
    Scene"), *Basic Components That Make Up a Three.js Scene*, doesn''t affect how
    this object is rendered. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `fog` | 这决定了这个材质是否受全局雾设置的影响。这没有在动作中显示。如果设置为 `false`，我们在[第2章](ch02.html "第2章。构成Three.js场景的基本组件")中看到的全局雾*构成Three.js场景的基本组件*不会影响这个对象的渲染。|'
- en: 'Besides these properties that are passed into the shader, `THREE.ShaderMaterial`
    also provides a number of specific properties you can use to pass in additional
    information into your custom shader (they might seem a bit obscure at the moment;
    for more details, see [Chapter 11](ch11.html "Chapter 11. Custom Shaders and Render
    Postprocessing"), *Custom Shaders and Render Postprocessing*), which are as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传递给着色器的这些属性之外，`THREE.ShaderMaterial`还提供了一些特定的属性，你可以使用它们将额外的信息传递到你的自定义着色器中（它们目前可能看起来有点晦涩；更多详情请见[第11章](ch11.html
    "第11章。自定义着色器和渲染后处理")，*自定义着色器和渲染后处理*），如下所示：
- en: '| Name | Description |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fragmentShader` | This shader defines the color of each pixel that is passed
    in. Here, you need to pass in the string value of your fragment shader program.
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `fragmentShader` | 这个着色器定义了传入的每个像素的颜色。在这里，你需要传入你的片段着色器程序的字符串值。|'
- en: '| `vertexShader` | This shader allows you to change the position of each vertex
    that is passed in. Here, you need to pass in the string value of your vertex shader
    program. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `vertexShader` | 这个着色器允许你改变传入的每个顶点的位置。在这里，你需要传入你的顶点着色器程序的字符串值。|'
- en: '| `uniforms` | This allows you to send information to your shader. The same
    information is sent to each vertex and fragment. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `uniforms` | 这允许你将信息发送到你的着色器。相同的信息被发送到每个顶点和片段。|'
- en: '| `defines` | Converts to #define code fragments. With these fragments, you
    can set some additional global variables in the shader programs. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `defines` | 转换为`#define`代码片段。使用这些片段，你可以在着色器程序中设置一些额外的全局变量。|'
- en: '| `attributes` | These can change between each vertex and fragment. They are
    usually used to pass positional and normal-related data. If you want to use this,
    you need to provide information for all the vertices of the geometry. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `attributes` | 这些可以在每个顶点和片段之间改变。它们通常用于传递位置和法线相关的数据。如果你想使用这个，你需要为几何体的所有顶点提供信息。|'
- en: '| `lights` | This determines whether light data should be passed into the shaders.
    This defaults to `false`. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `lights` | 这决定了是否应该将光数据传递到着色器中。默认为`false`。|'
- en: 'Before we look at an example, we''ll give a quick explanation about the most
    important parts of `ShaderMaterial`. To work with this material, we have to pass
    in two different shaders:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看示例之前，我们将简要解释`ShaderMaterial`最重要的部分。要使用这个材质，我们必须传入两个不同的着色器：
- en: '`vertexShader`: This is run on each vertex of the geometry. You can use this
    shader to transform the geometry by moving the position of the vertices around.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertexShader`：这个着色器在几何体的每个顶点上运行。你可以使用这个着色器通过移动顶点的位置来变换几何体。'
- en: '`fragmentShader`: This is run on each fragment of the geometry. In `vertexShader`,
    we return the color that should be shown for this specific fragment.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fragmentShader`：这个着色器在几何体的每个片段上运行。在`vertexShader`中，我们返回应该显示在这个特定片段上的颜色。'
- en: For all the materials we've discussed until now in this chapter, Three.js provides
    `fragmentShader` and `vertexShader`, so you don't have to worry about those.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中我们讨论的所有材料，Three.js 提供了 `fragmentShader` 和 `vertexShader`，所以你不必担心这些。
- en: For this section, we'll look at a simple example that uses a very simple `vertexShader`
    program that changes the *x*, *y*, and *z* coordinates of the vertices of a cube
    and a `fragmentShader` program that uses shaders from [http://glslsandbox.com/](http://glslsandbox.com/)
    to create an animating material.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将查看一个简单的示例，该示例使用一个非常简单的 `vertexShader` 程序来改变立方体的顶点 *x*、*y* 和 *z* 坐标，以及一个使用来自
    [http://glslsandbox.com/](http://glslsandbox.com/) 的着色器创建动画材料的 `fragmentShader`
    程序。
- en: 'Up next, you can see the complete code for `vertexShader` that we''ll use.
    Note that writing shaders isn''t done in JavaScript. You write shaders in a C-like
    language called **GLSL** (WebGL supports OpenGL ES Shading Language 1.0—for more
    information on GLSL, see [https://www.khronos.org/webgl/](https://www.khronos.org/webgl/)),
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以看到我们将使用的 `vertexShader` 的完整代码。请注意，编写着色器不是在 JavaScript 中完成的。你使用一种类似于 C
    的语言编写着色器，称为 **GLSL**（WebGL 支持 OpenGL ES 着色语言 1.0——有关 GLSL 的更多信息，请参阅 [https://www.khronos.org/webgl/](https://www.khronos.org/webgl/)），如下所示：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We won''t go into too much detail here and just focus on the most important
    parts of this code. To communicate with the shaders from JavaScript, we use something
    called uniforms. In this example, we use the `uniform float time;` statement to
    pass in an external value. Based on this value, we change the *x*, *y*, and *z*
    coordinates of the passed-in vertex (which is passed in as the position variable):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会过多地深入细节，只是关注这段代码中最重要的一部分。要与着色器从 JavaScript 进行通信，我们使用一种称为 uniforms 的东西。在本例中，我们使用
    `uniform float time;` 语句传入一个外部值。基于这个值，我们改变传入的顶点（作为位置变量传入）的 *x*、*y* 和 *z* 坐标：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `posChanged` vector now contains the new coordinate for this vertex based
    on the passed-in time variable. The last step we need to perform is pass this
    new position back to Three.js, which is always done like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`posChanged` 向量现在包含基于传入的时间变量的这个顶点的新的坐标。我们需要执行的最后一个步骤是将这个新位置返回到 Three.js，这通常是这样做的：'
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `gl_Position` variable is a special variable that is used to return the
    final position. Next, we need to create `shaderMaterial` and pass in `vertexShader`.
    For this, we''ve created a simple helper function, which we use like this: `var
    meshMaterial1 = createMaterial("vertex-shader","fragment-shader-1");` in the following
    code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl_Position` 变量是一个特殊变量，用于返回最终位置。接下来，我们需要创建 `shaderMaterial` 并传入 `vertexShader`。为此，我们创建了一个简单的辅助函数，其用法如下：`var
    meshMaterial1 = createMaterial("vertex-shader","fragment-shader-1");` 在以下代码中：'
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The arguments point to the ID of the `script` element in the HTML page. Here,
    you can also see that we set up a uniforms variable. This variable is used to
    pass information from our renderer into our shader. Our complete render loop for
    this example is shown in the following code snippet:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 参数指向 HTML 页面中 `script` 元素的 ID。在这里，你还可以看到我们设置了 uniforms 变量。这个变量用于将信息从我们的渲染器传递到我们的着色器。本例的完整渲染循环如下代码片段所示：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see that we increase the time variable by 0.01 each time the render
    loop is run. This information is passed into `vertexShader` and used to calculate
    the new position of the vertices of our cube. Now open up the `08-shader-material.html`
    example, and you''ll see that the cube shrinks and grows around its axis. The
    following screenshot gives a still image of this example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，每次渲染循环运行时，我们都会将时间变量增加 0.01。这个信息被传递到 `vertexShader` 中，用于计算我们立方体顶点的新位置。现在打开
    `08-shader-material.html` 示例，你会看到立方体围绕其轴收缩和膨胀。以下截图给出了这个示例的静态图像：
- en: '![Creating your own shaders with THREE.ShaderMaterial](img/2215OS_04_12.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![使用 THREE.ShaderMaterial 创建自己的着色器](img/2215OS_04_12.jpg)'
- en: 'In this example, you can see that each of the cube''s faces has an animating
    pattern. The fragment shader that is assigned to each face of the cube creates
    these patterns. As you might have guessed, we''ve used `THREE.MeshFaceMaterial`
    (and the `createMaterial` function we explained earlier) for this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你可以看到立方体的每个面都有一个动画图案。分配给立方体每个面的片段着色器创建了这些图案。正如你可能猜到的，我们使用了 `THREE.MeshFaceMaterial`（以及我们之前解释的
    `createMaterial` 函数）来完成这个任务：
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The only part we haven''t explained yet is about `fragmentShader`. For this
    example, all the `fragmentShader` objects were copied from [http://glslsandbox.com/](http://glslsandbox.com/).
    This site provides an experimental playground where you can write and share `fragmentShader`
    objects. I won''t go into the details here, but `fragment-shader-6` used in this
    example looks like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未解释的部分是关于`fragmentShader`。在这个例子中，所有的`fragmentShader`对象都是从[http://glslsandbox.com/](http://glslsandbox.com/)复制的。该网站提供了一个实验性的游乐场，你可以在这里编写和分享`fragmentShader`对象。我不会在这里详细介绍，但这个例子中使用的`fragment-shader-6`看起来是这样的：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The color that finally gets passed back to Three.js is the one set with `gl_FragColor
    = color_final`. A good way to get a bit more of a feeling for `fragmentShader`
    is to explore what''s available at [http://glslsandbox.com/](http://glslsandbox.com/)
    and to use the code for your own objects. Before we move to the next set of materials,
    here is one more example of what is possible with a custom `vertexShader` program
    ([https://www.shadertoy.com/view/4dXGR4](https://www.shadertoy.com/view/4dXGR4)):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最终传递给Three.js的颜色是使用`gl_FragColor = color_final`设置的。要更好地理解`fragmentShader`，一个不错的方法是探索[http://glslsandbox.com/](http://glslsandbox.com/)上可用的内容，并使用该代码为你的对象编写代码。在我们转向下一组材料之前，这里有一个使用自定义`vertexShader`程序（[https://www.shadertoy.com/view/4dXGR4](https://www.shadertoy.com/view/4dXGR4)）的例子：
- en: '![Creating your own shaders with THREE.ShaderMaterial](img/2215OS_04_13.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![使用THREE.ShaderMaterial创建自己的着色器](img/2215OS_04_13.jpg)'
- en: Much more on the subject of fragment and vertex shaders can be found in [Chapter
    11](ch11.html "Chapter 11. Custom Shaders and Render Postprocessing"), *Custom
    Shaders and Render Postprocessing*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关于片段和顶点着色器的更多内容可以在[第11章](ch11.html "第11章。自定义着色器和渲染后处理") *自定义着色器和渲染后处理*中找到。
- en: Materials you can use for a line geometry
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用于线几何形状的材料
- en: 'The last couple of materials we''re going to look at can only be used on one
    specific geometry: `THREE.Line`. As the name implies, this is just a single line
    that only consists of vertices and doesn''t contain any faces. Three.js provides
    two different materials you can use on a line, which are as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后几种材料只能用于一个特定的几何形状：`THREE.Line`。正如其名所示，这仅仅是一条由顶点组成而没有面的线。Three.js提供了两种可以在线上使用的不同材料，如下所示：
- en: '`THREE.LineBasicMaterial`: The basic material for a line allows you to set
    the `colors`, `linewidth`, `linecap`, and `linejoin` properties'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LineBasicMaterial`：线的基材允许你设置`colors`、`linewidth`、`linecap`和`linejoin`属性'
- en: '`THREE.LineDashedMaterial`: This has the same properties as `THREE.LineBasicMaterial`
    but allows you to create a *dash* effect by specifying dash and spacing sizes'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LineDashedMaterial`：这与`THREE.LineBasicMaterial`具有相同的属性，但允许你通过指定划线和间距大小来创建*划线*效果'
- en: We'll start with the basic variant and after that look at the dashed variant.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从基本变体开始，然后查看划线变体。
- en: THREE.LineBasicMaterial
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.LineBasicMaterial
- en: 'The materials available for the `THREE.Line` geometry are very simple. The
    following table shows the properties available to this material:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于`THREE.Line`几何形状的材料非常简单。以下表格显示了此材料可用的属性：
- en: '| Name | Description |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This determines the color of the line. If you specify `vertexColors`,
    this property is ignored. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这决定了线的颜色。如果你指定了`vertexColors`，则忽略此属性。 |'
- en: '| `linewidth` | This determines the width of the line. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `linewidth` | 这决定了线的宽度。 |'
- en: '| `linecap` | This property defines how the ends of lines look in the wireframe
    mode. The possible values are `butt`, `round`, and `square`. The default is `round`.
    In practice, the results from changing this property are very difficult to see.
    This property isn''t supported on `WebGLRenderer`. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `linecap` | 此属性定义了在线框模式下线的末端看起来如何。可能的值是`butt`、`round`和`square`。默认值是`round`。实际上，改变此属性的结果很难看到。此属性在`WebGLRenderer`上不受支持。
    |'
- en: '| `linejoin` | Define how the line joints are visualized. The possible values
    are `round`, `bevel`, and `miter`. The default value is `round`. If you look very
    closely, you can see this in the example using low `opacity` and a very large
    `wireframeLinewidth`. This property isn''t supported on `WebGLRenderer`. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `linejoin` | 定义如何可视化线接头。可能的值是`round`、`bevel`和`miter`。默认值是`round`。如果你非常仔细地看，你可以在使用低`opacity`和非常大的`wireframeLinewidth`的示例中看到这一点。此属性在`WebGLRenderer`上不受支持。
    |'
- en: '| `vertexColors` | You can supply a specific color for each vertex by setting
    this property to the `THREE.VertexColors` value. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `vertexColors` | 你可以通过将此属性设置为`THREE.VertexColors`值来为每个顶点提供特定的颜色。 |'
- en: '| `fog` | This determines whether this object is affected by the global fog
    property. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `fog` | 这决定了此对象是否受全局雾属性的影响。|'
- en: 'Before we look at an example of `LineBasicMaterial`, let''s first have a quick
    look at how we can create a `THREE.Line` mesh from a set of vertices and combine
    that with `LineMaterial` to create the mesh, as shown in the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看 `LineBasicMaterial` 的示例之前，让我们先快速看一下如何从一组顶点创建一个 `THREE.Line` 网格，并将其与 `LineMaterial`
    结合起来创建网格，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first part of this code fragment, `var points = gosper(4, 60);`, is used
    as an example to get a set of *x* and *y* coordinates. This function returns a
    gosper curve (for more information, check out [http://en.wikipedia.org/wiki/Gosper_curve](http://en.wikipedia.org/wiki/Gosper_curve)),
    which is a simple algorithm that fills a 2D space. What we do next is we create
    a `THREE.Geometry` instance, and for each coordinate, we create a new vertex,
    which we push into the lines property of this instance. For each coordinate, we
    also calculate a color value that we use to set the `colors` property.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段的第一部分，`var points = gosper(4, 60);`，用作示例以获取一组 *x* 和 *y* 坐标。此函数返回一个 Gosper
    曲线（更多信息，请参阅 [http://en.wikipedia.org/wiki/Gosper_curve](http://en.wikipedia.org/wiki/Gosper_curve)），这是一个简单的算法，用于填充
    2D 空间。我们接下来要做的是创建一个 `THREE.Geometry` 实例，并为每个坐标创建一个新的顶点，然后将它推入此实例的线条属性中。对于每个坐标，我们还计算一个颜色值，我们使用它来设置
    `colors` 属性。
- en: Tip
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'In this example, we''ve set the color using the `setHSL()` method. Instead
    of providing values for red, green, and blue, with HSL, we provide the hue, saturation,
    and lightness. Using HSL is much more intuitive than RGB, and it is much easier
    to create sets of matching colors. A very good explanation of HSL can be found
    in the CSS specification: [http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color](http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 `setHSL()` 方法设置了颜色。与提供红色、绿色和蓝色的值不同，使用 HSL，我们提供色调、饱和度和亮度。使用 HSL 比使用
    RGB 更直观，并且更容易创建匹配的颜色集。CSS 规范中可以找到关于 HSL 的非常好的解释：[http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color](http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color)。
- en: 'Now that we have our geometry, we can create `THREE.LineBasicMaterial` and
    use this together with the geometry to create a `THREE.Line` mesh. You can see
    the result in the `09-line-material.html` example. The following screenshot shows
    this example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的几何形状，我们可以创建 `THREE.LineBasicMaterial` 并与几何形状一起使用来创建一个 `THREE.Line`
    网格。您可以在 `09-line-material.html` 示例中看到结果。以下截图显示了此示例：
- en: '![THREE.LineBasicMaterial](img/2215OS_04_14.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.LineBasicMaterial](img/2215OS_04_14.jpg)'
- en: The next and last material we'll discuss in this chapter is only slightly different
    from `THREE.LineBasicMaterial`. With `THREE.LineDashedMaterial`, not only can
    we color lines, but we can also add a *dash* effect.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将讨论的下一个和最后一个材料与 `THREE.LineBasicMaterial` 只略有不同。使用 `THREE.LineDashedMaterial`，我们不仅可以着色线条，还可以添加
    *虚线* 效果。
- en: THREE.LineDashedMaterial
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.LineDashedMaterial
- en: 'This material has the same properties as `THREE.LineBasicMaterial` and two
    additional ones you can use to define the dash width and the width of the gaps
    between the dashes, which are as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此材料具有与 `THREE.LineBasicMaterial` 相同的属性，以及两个您可以用来定义虚线宽度和虚线之间间隙宽度的附加属性，如下所示：
- en: '| Name | Description |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `scale` | This scales `dashSize` and `gapSize`. If the scale is smaller than
    `1`, `dashSize` and `gapSize` increase, and if the scale is larger than `1`, `dashSize`
    and `gapSize` decrease. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `scale` | 这会缩放 `dashSize` 和 `gapSize`。如果缩放小于 `1`，则 `dashSize` 和 `gapSize`
    增加，如果缩放大于 `1`，则 `dashSize` 和 `gapSize` 减少。|'
- en: '| `dashSize` | This is the size of the dash. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `dashSize` | 这是虚线的尺寸。|'
- en: '| `gapSize` | This is the size of the gap. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `gapSize` | 这是间隙的尺寸。|'
- en: 'This material works almost exactly like `THREE.LineBasicMaterial`. Here''s
    how it works:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此材料几乎与 `THREE.LineBasicMaterial` 完全相同。以下是它的工作方式：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The only difference is that you have to call `computeLineDistances()` (which
    is used to determine the distance between the vertices that make up a line). If
    you don''t do this, the gaps won''t be shown correctly. An example of this material
    can be found in `10-line-material-dashed.html` and looks like the following screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是您必须调用 `computeLineDistances()`（用于确定构成线的顶点之间的距离）。如果您不这样做，间隙将不会正确显示。此材料的示例可以在
    `10-line-material-dashed.html` 中找到，如下面的截图所示：
- en: '![THREE.LineDashedMaterial](img/2215OS_04_15.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.LineDashedMaterial](img/2215OS_04_15.jpg)'
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Three.js gives you a lot of materials you can use to skin your geometries. The
    materials range from the very simple `(THREE.MeshBasicMaterial`) to the complex
    `(THREE.ShaderMaterial`), where you can provide your own `vertexShader` and `fragmentShader`
    programs. Materials share a lot of basic properties. If you know how to use a
    single material, you'll probably also know how to use the other materials. Note
    that not all materials respond to the lights in your scene. If you want a material
    that takes lighting into effect, use `THREE.MeshPhongMaterial` or `THREE.MeshLamberMaterial`.
    Determining the effect of certain material properties just from code is very hard.
    Often, a good idea is to use a dat.GUI approach to experiment with these properties.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了许多你可以用来为几何形状添加材质的资源。这些材质从非常简单的 `(THREE.MeshBasicMaterial)` 到复杂的
    `(THREE.ShaderMaterial)`，其中你可以提供自己的 `vertexShader` 和 `fragmentShader` 程序。材质共享许多基本属性。如果你知道如何使用一种材质，你很可能也知道如何使用其他材质。请注意，并非所有材质都会对场景中的灯光做出反应。如果你想使用考虑光照效果的材质，请使用
    `THREE.MeshPhongMaterial` 或 `THREE.MeshLamberMaterial`。仅从代码中确定某些材质属性的效果是非常困难的。通常，一个好的方法是使用
    dat.GUI 方法来实验这些属性。
- en: 'Also, remember that most of the properties of a material can be modified at
    runtime. Some though (for example, `side`) can''t be modified at runtime. If you
    change such a value, you need to set the `needsUpdate` property to `true`. For
    a complete overview of what can and cannot be changed at runtime, see the following
    page: [https://github.com/mrdoob/three.js/wiki/Updates](https://github.com/mrdoob/three.js/wiki/Updates).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，大多数材质的属性都可以在运行时修改。但有些属性（例如，`side`）则不能在运行时修改。如果你更改这样的值，你需要将 `needsUpdate`
    属性设置为 `true`。有关可以在运行时更改和不能更改的完整概述，请参阅以下页面：[https://github.com/mrdoob/three.js/wiki/Updates](https://github.com/mrdoob/three.js/wiki/Updates)。
- en: In this and the previous chapters, we talked about geometries. We used these
    in our examples and explored a couple of them. In the next chapter, you'll learn
    everything about geometries and how you can work with them.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和上一章中，我们讨论了几何形状。我们在示例中使用了这些形状，并探索了其中的一些。在下一章，你将了解有关几何形状的所有知识以及如何与它们一起工作。
