- en: Chapter 4. Learn about Swipes through the making of Sokoban
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 通过Sokoban的制作了解滑动操作
- en: Do you know the Sokoban game? It's a funny puzzle game featuring a player pushing
    crates to some designated places. Normally, on a computer, these kinds of games—called
    tile-based games—are controlled by arrow keys, but since our game has to be cross-platform,
    we will let the player control in-game movements using swipes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道Sokoban游戏吗？这是一个有趣的益智游戏，玩家需要推动箱子到指定的位置。通常，在电脑上，这类游戏——称为基于图块的游戏——是通过箭头键控制的，但鉴于我们的游戏需要跨平台，我们将让玩家通过滑动来控制游戏中的移动。
- en: The game we will build is very similar to an iOS game I made called BWBan. It's
    free; you can play it at [http://bit.ly/1fUXP8c](http://bit.ly/1fUXP8c).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的游戏与我制作的iOS游戏BWBan非常相似。它是免费的；你可以在[http://bit.ly/1fUXP8c](http://bit.ly/1fUXP8c)上玩。
- en: 'In the process of making this game, which we''ll call Cocosban, you will learn
    about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作这个游戏的过程中，我们将称之为Cocosban，你将学习以下主题：
- en: How to detect swipes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测滑动操作
- en: How to load graphic assets through a sprite sheet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过精灵表加载图形资源
- en: How to create 8-bit-like pixel games by playing with anti-aliasing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过抗锯齿玩转8位像素游戏的创建方法
- en: There's a lot to do, so let's start with the good old blueprint made in the
    first chapter and work on it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情要做，所以让我们从第一章中制作的好老蓝图开始，并在此基础上进行工作。
- en: Loading graphic assets
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载图形资源
- en: Needless to say, the first thing you should do is place your graphic assets
    in the `assets` folder, but there is something new about this step.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不必说，你应该做的第一件事是将你的图形资源放在`assets`文件夹中，但这一步有一些新的内容。
- en: In previous examples, we always filled our `assets` folder with one `PNG` image
    for each game actor—the spaceship and asteroid had their own image. This also
    applies for all Concentration tiles and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们总是为每个游戏角色在`assets`文件夹中填充一个`PNG`图像——太空船和小行星有自己的图像。这也适用于所有注意力集中瓷砖等等。
- en: Cocos2d-JS has no problems in dealing with multiple images, but as a golden
    rule, remember the less images you have to deal with, the better your game performs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-JS在处理多个图像时没有问题，但作为一条黄金法则，记住你处理的图像越少，你的游戏性能越好。
- en: So, where's the trick? In order to have a spaceship and an asteroid, you would
    think you have to load a spaceship image and an asteroid image, but there's another
    better way to do it, using **sprite sheets**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，技巧在哪里？为了有一个太空船和小行星，你可能认为你需要加载一个太空船图像和一个小行星图像，但还有另一种更好的方法来做这件事，那就是使用**精灵表**。
- en: A sprite sheet is a single image made by combining various small images into
    it. If you are in to web designing, they are called **CSS sprites**, and if you
    have already made some native iOS applications, they are called texture atlases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵表是由将各种小图像组合成单个图像而制成的图像。如果你从事网页设计，它们被称为**CSS精灵**，如果你已经制作了一些原生iOS应用程序，它们被称为纹理图集。
- en: Does this mean that you have to manually create a large image and place all
    your graphic assets inside of it? Well, although you can do it manually, there
    are several software solutions to speed up the process. The one I use and recommend
    to you is TexturePacker, which you can find at [www.codeandweb.com/texturepacker](http://www.codeandweb.com/texturepacker).
    It works with an intuitive drag-and-drop interface and supports Cocos2d export.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着你必须手动创建一个大型图像，并将所有图形资源都放在里面？嗯，虽然你可以手动完成，但有几个软件解决方案可以加快这个过程。我使用并推荐给你的是TexturePacker，你可以在[www.codeandweb.com/texturepacker](http://www.codeandweb.com/texturepacker)找到它。它使用直观的拖放界面，并支持Cocos2d导出。
- en: 'These are the four images I created for the game, directly from my Photoshop:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是为游戏创建的四个图像，直接来自我的Photoshop：
- en: '![Loading graphic assets](img/0075OS_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![加载图形资源](img/0075OS_04_01.jpg)'
- en: I would like you to notice the zoom factor of the images—actually, they are
    really tiny. Since we are making a pixel game, the image I made are really small,
    from 96 x 64 pixels for the title image down to 5 x 5 pixels for the crate and
    the player.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让你注意图像的缩放因子——实际上，它们真的很小。由于我们正在制作像素游戏，我制作的图像都非常小，从标题图像的96 x 64像素到箱子玩家的5 x 5像素。
- en: 'Once processed by TexturePacker and exported to Cocos2d, your assets folder
    should contain the following two files:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦由TexturePacker处理并导出到Cocos2d，你的资源文件夹应该包含以下两个文件：
- en: '![Loading graphic assets](img/0075OS_04_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![加载图形资源](img/0075OS_04_02.jpg)'
- en: You should easily recognize all previously drawn graphic assets packed into
    `spritesheet.png`, and you will wonder why we need the `spritesheet.plist` file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该很容易识别所有之前绘制并打包到 `spritesheet.png` 中的图形资源，你可能会想知道为什么我们需要 `spritesheet.plist`
    文件。
- en: 'Open it and you will basically find an XML file with all the information for
    the images, from their original file names to their current sizes and coordinates
    inside `spritesheet.plist`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 打开它，你基本上会找到一个包含所有图像信息的 XML 文件，从它们的原始文件名到它们在 `spritesheet.plist` 中的当前大小和坐标：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In various Cocos2d-JS guides and references, this is referred to as a sprite
    sheet. Actually, it's more of a texture atlas; thanks to the XML file, which explains
    and describes each image included in the sheet.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种 Cocos2d-JS 指南和参考资料中，这被称为精灵表。实际上，它更像是一个纹理图集；多亏了 XML 文件，它解释并描述了图集中包含的每个图像。
- en: 'So, it''s time to load both files with `loadassets.js`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候使用 `loadassets.js` 加载这两个文件了：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Meanwhile, `main.js` will set our resolution policy at 480 x 320 pixels in
    portrait mode:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`main.js` 将在横屏模式下将我们的分辨率策略设置为 480 x 320 像素：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, it's time to create the game itself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建游戏本身了。
- en: Building a level
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建关卡
- en: 'Normally, tile-based levels are stored in two-dimensional arrays, and Cocosban
    follows this trend. So, the first global variable we''ll declare in `gamescript.js`,
    which is an array containing level data, is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基于瓦片的关卡存储在二维数组中，Cocosban 也遵循这一趋势。因此，我们在 `gamescript.js` 中声明的第一个全局变量，它是一个包含关卡数据的数组，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each item represents a tile, and each value represents an item, which I coded
    this way:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目代表一个瓦片，每个值代表一个项目，我这样编码：
- en: '`0`: This item is an empty tile'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：这个项目是一个空瓦片'
- en: '`1`: This item is a wall'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：这个项目是墙壁'
- en: '`2`: This item is the place where to drop a crate'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：这个项目是放置箱子的地方'
- en: '`3`: This item is the crate'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：这个项目是箱子'
- en: '`4`: This item is the player'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`：这个项目是玩家'
- en: '`5`: This item is the crate on a place where to drop a crate (3+2)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`：这个项目是在放置箱子的地方（3+2）'
- en: '`6`: This item is the player on a place where to drop a crate (4+2)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6`：这个项目是在放置箱子的地方的玩家（4+2）'
- en: 'Our `gameScene` declaration is always the same:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `gameScene` 声明始终相同：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And finally, we are ready to extend the `game` class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备扩展 `game` 类。
- en: Before we start, I want to quickly discuss mobile tile-based games.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我想简要讨论一下移动端基于瓦片的游戏。
- en: If you look at the `level` array, you will see it's a *7x7=49* items array.
    This means we are going to place *49 tiles = 49 sprites* on the screen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `level` 数组，你会看到它是一个 *7x7=49* 项目的数组。这意味着我们将放置 *49 个瓦片 = 49 个精灵* 在屏幕上。
- en: That's OK, but placing stuff on the screen costs performance. Since we don't
    know on which devices our game will run, the less potentially moving stuff on
    the screen, the better the performances.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 没关系，但在屏幕上放置东西会消耗性能。由于我们不知道我们的游戏将在哪些设备上运行，屏幕上潜在的移动元素越少，性能就越好。
- en: Since the only moving stuff in our game are the crates and the hero, while all
    wall and floor tiles always remain in their place, I simply hand-drew the level,
    adding only moveable characters as tiles.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们游戏中唯一移动的元素是箱子和小英雄，而所有墙壁和地板瓦片始终保持在它们的位置，我简单地手绘了关卡，只添加了可移动的角色作为瓦片。
- en: You should do the same when designing for cross-platform purposes unless you
    are using random or procedurally generated content.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计跨平台应用时，你应该做同样的事情，除非你使用的是随机或程序生成的内容。
- en: 'That said, this is how the `game` class is declared:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这是 `game` 类的声明方式：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, most of the code has already been explained in the previous
    chapters. We enable the game to be touch-driven and add some sprites on the stage.
    Just look at how I am loading the sprite sheet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，大部分代码已经在之前的章节中解释过了。我们使游戏能够触摸驱动，并在舞台上添加了一些精灵。只需看看我是如何加载精灵表的：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And this is how you can select a single image from a sprite sheet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样从精灵表中选择单个图像：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, since our sprites are very, very tiny, they need to be scaled up.
    The `setScale` method allows us to scale sprites:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们的精灵非常非常小，它们需要放大。`setScale` 方法允许我们放大精灵：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we are ready to launch the game and see our sprites scaled up by 5x:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备启动游戏并看到我们的精灵被放大了5倍：
- en: '![Building a level](img/0075OS_04_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![构建关卡](img/0075OS_04_03.jpg)'
- en: The preceding image is not a blurred, low-resolution image. It's the actual
    game as you will see on the screen, because Cocos2d-JS applies an anti-aliasing
    effect, which, in this case, wastes the 8-bit look we wanted to give the game.
    Anti-aliasing is very useful when you want to get smooth images, but will make
    your game look really bad if you plan to create a pixel game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像不是一个模糊的低分辨率图像。它就是你将在屏幕上看到的实际游戏，因为 Cocos2d-JS 应用了抗锯齿效果，在这种情况下，浪费了我们想要给游戏的
    8 位外观。抗锯齿在你想获得平滑图像时非常有用，但如果你的计划是创建像素游戏，它会使你的游戏看起来真的很糟糕。
- en: 'You can prevent anti-aliasing from being applied to a texture with the `setAliasTexParameters`
    method by just adding this line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 `setAliasTexParameters` 方法通过添加这一行来防止将抗锯齿应用于纹理：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the game again, and you will see your pixel-perfect game:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你将看到你的像素完美游戏：
- en: '![Building a level](img/0075OS_04_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![构建关卡](img/0075OS_04_04.jpg)'
- en: Also, I would like you to notice that the `setAliasTexParameters` method is
    called once and works on both sprites—and will work on every other sprite created
    in this game—because it's applied on the whole sprite sheet.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还想让你注意，`setAliasTexParameters` 方法只调用一次，并且作用于所有精灵——并且将作用于在这个游戏中创建的每个其他精灵——因为它应用于整个精灵图集。
- en: At this time, we can create the player and the crates. They are just sprites
    manually positioned in the right place according to their position in the `level`
    array and the position of the level image in the stage.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们可以创建玩家和箱子。它们只是根据 `level` 数组中的位置和关卡图像在舞台中的位置手动定位的精灵。
- en: 'The rest of the script to build the level has nothing to do with Cocos2d-JS
    since it''s pure JavaScript, so I am going to speed up a bit. First, I need three
    more global variables:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 构建关卡的其他脚本与 Cocos2d-JS 无关，因为它完全是 JavaScript，所以我将稍微加快一点。首先，我需要三个更多的全局变量：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is what they represent:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它们所代表的：
- en: '`cratesArray`: This is the array that will contain all crate sprites'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cratesArray`：这是一个将包含所有箱体精灵的数组'
- en: '`playerPosition`: This is the variable that will be used to store a player''s
    position inside the maze'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerPosition`：这是一个将用于在迷宫中存储玩家位置的变量'
- en: '`playerSprite`: This variable represents the player itself'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerSprite`：这个变量代表玩家本身'
- en: 'Then, after the line that added the `level` sprite, we can place the player
    and the crates:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在添加了 `level` 精灵的行之后，我们可以放置玩家和箱子：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Did you see? Through pure JavaScript, we just added the crate sprite when the
    `level` array item is 3 or 5 and the player sprite when the `level` array item
    is 4 or 6.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了吗？通过纯 JavaScript，我们只是在 `level` 数组项为 3 或 5 时添加了箱子精灵，在 `level` 数组项为 4 或 6
    时添加了玩家精灵。
- en: The strange math operations are just used to place tiles in the right place
    according to their position.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那些奇怪的数学运算只是用来根据它们的位置将瓦片放置在正确的位置。
- en: 'This following screenshot is the result you should see when you run the script:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是当你运行脚本时应看到的结果：
- en: '![Building a level](img/0075OS_04_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![构建关卡](img/0075OS_04_05.jpg)'
- en: And that's it! You have your pixel level ready to be played. Let's detect player
    movements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你的像素关卡已经准备好可以玩了。让我们检测玩家的移动。
- en: Detecting swipes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测滑动
- en: 'If we analyze a swipe, we can break it down into three parts:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析一个滑动，我们可以将其分解为三个部分：
- en: The player is touching the stage at a certain point.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家在舞台的某个点上触摸。
- en: The player is dragging their finger in a certain direction.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家正在某个方向上拖动他们的手指。
- en: The player is releasing the finger.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家正在释放手指。
- en: By comparing the coordinates of the points where the drag started and ended,
    we can determine the direction of the swipe and move the player accordingly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较拖动开始和结束的点坐标，我们可以确定滑动的方向，并相应地移动玩家。
- en: 'We need to add three new global variables:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加三个新的全局变量：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Their names are quite self-explicative: `startTouch` and `endTouch` will store
    the starting and ending points of the swipe, while `swipeTolerance` is the minimum
    allowed distance in pixels between `startTouch` and `endTouch` in order to consider
    the whole action as a swipe.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的名字相当自解释：`startTouch` 和 `endTouch` 将存储滑动操作的起始点和结束点，而 `swipeTolerance` 是 `startTouch`
    和 `endTouch` 之间允许的最小像素距离，以便将整个操作视为滑动。
- en: 'Now, we will let `game` detect when a touch starts or ends:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将让 `game` 检测触摸开始或结束：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As usual, we added a listener attached to a variable called `listener`, which
    we''ll define this way:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们添加了一个附加到名为 `listener` 的变量的监听器，我们将这样定义它：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `onTouchBegan` function will register the initial touch and update the `startTouch`
    content; thanks to the `getLocation` method. Also, notice the function returns
    `true`. It's very important you make this function return `true`, or `onTouchEnded`
    won't be triggered.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`onTouchBegan`函数将注册初始触摸并更新`startTouch`内容；多亏了`getLocation`方法。注意，该函数返回`true`。你确保这个函数返回`true`非常重要，否则`onTouchEnded`不会被触发。'
- en: 'The same applies for `onTouchEnded`, which will update `endTouch`. Then, the
    `swipeDirection` function is called. It will allow us to move the player:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`onTouchEnded`也是如此，它将更新`endTouch`。然后，调用`swipeDirection`函数。它将允许我们移动玩家：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the game and the following screenshot is what you will see:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，以下是你将看到的截图：
- en: '![Detecting swipes](img/0075OS_04_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![检测滑动](img/0075OS_04_06.jpg)'
- en: Once you swipe in a direction, the player moves accordingly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你向一个方向滑动，玩家就会相应地移动。
- en: 'Let''s see what happens in the `swipeDirection` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`swipeDirection`函数中会发生什么：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Horizontal and vertical distances from the start to the end of the touch are
    calculated:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从开始触摸到结束触摸的水平距离和垂直距离被计算：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The whole function is executed only if the sum of horizontal and vertical distances
    is greater than the minimum pixel tolerance allowed to say that the movement is
    actually a swipe:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当水平和垂直距离之和大于允许的最小像素容差，才能说移动实际上是一个滑动时，整个函数才会执行：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next step is to determine whether the player swiped horizontally or vertically.
    There''s no check to see whether a swipe was strictly horizontal or vertical;
    so, diagonal swipes will be seen as either horizontal or vertical, according to
    their biggest component:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定玩家是水平还是垂直滑动。没有检查滑动是否严格水平或垂直；因此，对角线滑动将被视为水平或垂直，根据它们最大的分量：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once we know whether the movement is horizontal or vertical, it''s time to
    check for the direction: left or right? Up or down? The rest of the code just
    checks for these questions and moves the player by 25 pixels accordingly. Unfortunately,
    you will be able to walk through crates and walls. It''s time to code game rules.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道移动是水平还是垂直，就到了检查方向的时候：左或右？上或下？代码的其余部分只是检查这些问题，并相应地移动玩家25像素。不幸的是，你将能够穿过箱子和墙壁。是时候编写游戏规则了。
- en: Completing the game
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成游戏
- en: The code I am about to write has nothing to do with Cocos2d-JS as it's just
    plain JavaScript, and explaining it would go beyond the scope of this book. I
    am just checking for legal moves and will move the player and the crates accordingly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我即将编写的代码与Cocos2d-JS无关，因为它只是纯JavaScript，解释它将超出本书的范围。我只是检查合法移动，并相应地移动玩家和箱子。
- en: Everything is managed by the `move` function, which will check for legal moves
    and update crates and player positions. The `move` function has two arguments,
    `deltaX` and `deltaY`, which represent the amount of tiles the player is trying
    to move horizontally or vertically.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有一切都由`move`函数管理，该函数将检查合法移动并更新箱子和玩家的位置。`move`函数有两个参数，`deltaX`和`deltaY`，它们代表玩家试图水平或垂直移动的瓷砖数量。
- en: This means `move(0,1)` will try to move the player up (0 tiles horizontally,
    1 tile vertically), `move(-1,0)` will try to move the player left, and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`move(0,1)`将尝试将玩家向上移动（水平方向0个瓷砖，垂直方向1个瓷砖），`move(-1,0)`将尝试将玩家向左移动，以此类推。
- en: 'The `swipeDirection` function changes this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`swipeDirection`函数改变了这一点：'
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A valid swipe is detected each time the `move` function is called.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`move`函数时，都会检测到一个有效的滑动。
- en: 'This is the `move` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`move`函数：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Enjoy your game.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 享受你的游戏。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to use sprite sheets to manage your assets,
    create pixel-perfect games, and detect swipes. You also created a great puzzle
    game called Cocosban.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用精灵表来管理你的资产，创建像素完美的游戏，并检测滑动。你还创建了一个名为Cocosban的精彩益智游戏。
- en: If you noticed, player and crate movements are made by making assets jump to
    their destination. Why don't you add a tween to create a smooth movement? It would
    be a great achievement for you to do it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，玩家和箱子的移动是通过让资产跳转到目的地来实现的。你为什么不添加一个缓动效果来创建平滑的移动呢？这将是你的一大成就。
- en: Also, there's no check to see whether the player completed the level. A completed
    level has no crates outside crate goals. Try to develop it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有检查玩家是否完成了关卡。完成关卡没有箱子在箱子目标之外。试着开发它。
- en: Then, follow me through a path full of music; we will add sound effects to our
    games!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，跟随我通过一条充满音乐的小径；我们将为我们的游戏添加音效！
