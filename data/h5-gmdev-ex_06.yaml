- en: Chapter 6. Adding Sound Effects to Your Games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。为您的游戏添加声音效果
- en: '*In the earlier chapters, we discussed several techniques to draw game objects
    visually. In this chapter, we will focus on using the `audio` tag that is introduced
    in the HTML5 specification. We can add sound effects, background music, and control
    the audio through the JavaScript API. In addition, we will build a music game
    in this chapter. It is a game that requires players to hit the correct string
    at the right time to produce the music.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前面几章中，我们讨论了几种绘制游戏对象的技术。在本章中，我们将专注于使用 HTML5 规范中引入的 `audio` 标签。我们可以添加声音效果、背景音乐，并通过
    JavaScript API 控制音频。此外，我们将在本章中构建一个音乐游戏。这是一个需要玩家在正确的时间击中正确的弦来产生音乐的游戏。*'
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Adding a sound effect to the **Play** button
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 **播放** 按钮添加声音效果
- en: Building a mini piano musical game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建迷你钢琴音乐游戏
- en: Linking the music game and the **Play** button
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将音乐游戏与 **播放** 按钮链接
- en: Adding keyboard and touch inputs to the game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为游戏添加键盘和触摸输入
- en: Creating a keyboard-driven music game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建键盘驱动的音乐游戏
- en: Completing the musical game with a level data recording and the game over event
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用等级数据记录和游戏结束事件完成音乐游戏
- en: 'You can play the game example at: [http://makzan.net/html5-games/audiogame/](http://makzan.net/html5-games/audiogame/).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在：[http://makzan.net/html5-games/audiogame/](http://makzan.net/html5-games/audiogame/)
    上播放游戏示例。
- en: 'The following screenshot shows the final result we will create through this
    chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将通过本章创建的最终结果：
- en: '![Adding Sound Effects to Your Games](img/B04290_06_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![为您的游戏添加声音效果](img/B04290_06_01.jpg)'
- en: So, let's get on with it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Adding a sound effect to the Play button
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为播放按钮添加声音效果
- en: We had several mouse interactions in the Untangle game examples in previous
    chapters. Now imagine that we want to have sound effects with the mouse interaction.
    This requires us to instruct the game about the audio file to be used. We will
    use the `audio` tag to create a sound effect when a button is clicked.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 Untangle 游戏示例中，我们有一些鼠标交互。现在想象一下，我们想要在鼠标交互中添加声音效果。这需要我们指导游戏使用音频文件。我们将使用
    `audio` 标签在按钮被点击时创建声音效果。
- en: Time for action – adding sound effects to the Play button
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到播放按钮的声音效果 - 行动时间
- en: 'We will start with the code example available in the code bundle. We will have
    a folder structure similar to the one shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从代码包中提供的代码示例开始。我们将有一个类似于以下截图所示的文件夹结构：
- en: '![Time for action – adding sound effects to the Play button](img/B04290_06_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![添加到播放按钮的声音效果 - 行动时间](img/B04290_06_02.jpg)'
- en: 'Perform the following set of steps to add sound effects to the **Play** button:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤集以向 **播放** 按钮添加声音效果：
- en: 'The `index.html` file contains the basic structure of the HTML. Now let''s
    add the following code to the body section of the `index.html` file:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`index.html` 文件包含 HTML 的基本结构。现在让我们将以下代码添加到 `index.html` 文件的主体部分：'
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The HTML file runs successfully with a stylesheet. The file can be found in
    the code bundle named `audiogame.css`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML 文件成功运行了样式表。该文件可以在名为 `audiogame.css` 的代码包中找到。
- en: 'Next, we create the basic code structure in the JavaScript file. Add the following
    JavaScript in the `audiogame.js` file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在 JavaScript 文件中创建基本的代码结构。在 `audiogame.js` 文件中添加以下 JavaScript 代码：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then we store the references of the audio tags. Add the following code inside
    the `initMedia` function:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们存储音频标签的引用。在 `initMedia` 函数中添加以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We add a sound effect to the button in the JavaScript file. Add the following
    JavaScript inside the `handlePlayButton` function:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 JavaScript 文件中为按钮添加声音效果。在 `handlePlayButton` 函数中添加以下 JavaScript 代码：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Open the `index.html` file in a browser. There, you should see a **PLAY** button
    on a yellow background, as shown in the following screenshot. Try to move the
    mouse on the button and click on it. You should be able to hear a sound when you
    hover over the button and another sound when you click on it:![Time for action
    – adding sound effects to the Play button](img/B04290_06_03.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `index.html` 文件。在那里，你应该看到一个黄色背景上的 **播放** 按钮，如下面的截图所示。尝试将鼠标移至按钮上并点击它。当你悬停在按钮上时，你应该能听到声音，当你点击按钮时，应该能听到另一个声音：![添加到播放按钮的声音效果
    - 行动时间](img/B04290_06_03.jpg)
- en: '*What just happened?*'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: We just created a basic HTML5 game layout with a play button placed in the middle
    of the page. The JavaScript file handles the mouse hover and clicks of the button
    and plays corresponding sound effects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个基本的HTML5游戏布局，将播放按钮放置在页面中间。JavaScript文件处理按钮的鼠标悬停和点击事件，并播放相应的音效。
- en: Defining an audio element
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义音频元素
- en: 'The easiest way to use the `audio` tag is by providing a source file. The following
    code snippet shows how we can define an audio element:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`audio`标签的最简单方法是提供源文件。以下代码片段显示了我们可以如何定义一个音频元素：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Besides setting the source file of the `audio` tag, we can have additional
    controls by using several attributes. The following table shows the attributes
    we can set for the audio element:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置`audio`标签的源文件外，我们还可以通过使用几个属性来获得额外的控制。以下表格显示了我们可以为音频元素设置的属性：
- en: '| Arguments | Definition | Explanation |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `src` | Defines the source file of the audio element | When we use the `src`
    attribute in the `audio` tag, it specifies one source file for the audio file.
    For example, we load a sound effect Ogg file in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '| `src` | 定义音频元素的源文件 | 当我们在`audio`标签中使用`src`属性时，它指定了一个音频文件的源文件。例如，在以下代码中，我们加载了一个Ogg格式的音效文件：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we want to specify multiple files with different formats, then we use the
    `source` tag inside the audio element. The following code specifies the `audio`
    tag with different formats to support different web browsers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想指定多个不同格式的文件，那么我们就在音频元素内部使用`source`标签。以下代码指定了具有不同格式的`audio`标签，以支持不同的网络浏览器：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `autoplay` | Specifies that the audio plays automatically once it is loaded
    | Autoplay is used as a standalone attribute. This means that there is no difference
    in the following two lines of code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '| `autoplay` | 指定音频在加载后自动播放 | 自动播放作为一个独立的属性使用。这意味着以下两行代码没有区别：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `loop` | Specifies that the audio plays from the beginning again after playback
    finishes | This is also used as a standalone attribute. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `loop` | 指定音频在播放结束后从开头再次播放 | 这也是一个独立的属性。|'
- en: '| `preload` | Specifies that the audio source is loaded once the page is loaded
    | The `preload` attribute takes either of the following values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '| `preload` | 指定音频源在页面加载时加载 | `preload`属性可以取以下任一值：'
- en: '`preload="auto"`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preload="auto"`'
- en: '`preload="metadata`"'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preload="metadata"`'
- en: '`preload="none"`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preload="none"`'
- en: When `preload` is used as a standalone attribute and set to `auto`, the browser
    will preload the audio.When `preload` is set as `metadata`, the browser will not
    preload the content of the audio. However, it will load the metadata of the audio,
    such as the duration and size.When `preload` is set to `none`, the browser will
    not preload the audio at all. The content and metadata is loaded once it is played.
    |
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当`preload`作为一个独立的属性并设置为`auto`时，浏览器将预加载音频。当`preload`设置为`metadata`时，浏览器不会预加载音频的内容。然而，它将加载音频的元数据，如时长和大小。当`preload`设置为`none`时，浏览器将不会预加载音频。内容和元数据将在播放时加载。|
- en: '| `controls` | Shows the playback control of the audio | The `controls` attribute
    is a standalone attribute. It instructs the browser to show a playback control
    in the audio position. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `controls` | 显示音频的播放控制 | `controls`属性是一个独立的属性。它指示浏览器在音频位置显示播放控制。|'
- en: 'The following screenshot shows the Chrome display controls:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Chrome显示控制：
- en: '![Defining an audio element](img/B04290_06_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![定义音频元素](img/B04290_06_04.jpg)'
- en: Playing a sound
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放声音
- en: 'We can get the reference of the audio element by calling the `getElementById`
    function. Then, we play it by calling the `play` function. The following code
    plays the `buttonactive` audio:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`getElementById`函数来获取音频元素的引用。然后，通过调用`play`函数来播放它。以下代码播放了`buttonactive`音频：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `play` function plays the audio from the elapsed time, which is stored
    in the `currentTime` property. The default value of `currentTime` is zero. The
    following code plays the audio from 3.5 seconds:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`play`函数从已播放时间开始播放音频，该时间存储在`currentTime`属性中。`currentTime`的默认值是零。以下代码从3.5秒处播放音频：'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: jQuery's selector versus browser selector
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery选择器与浏览器选择器
- en: We were using jQuery's query selector `$("#buttonactive")` to select an element.
    We were applying DOM manipulation to those selected elements, such as toggling
    classes, or getting text content. In this example, we use `document.getElementById("buttonactive")`
    to get the reference of the element. That's because we are using the browser's
    Web Audio API on the element. We don't want the jQuery object, we want the browser
    DOM element.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用 jQuery 的查询选择器 `$("#buttonactive")` 来选择元素。我们对选中的元素应用 DOM 操作，例如切换类或获取文本内容。在这个例子中，我们使用
    `document.getElementById("buttonactive")` 来获取元素的引用。这是因为我们正在使用浏览器上的 Web Audio API
    对该元素进行操作。我们不需要 jQuery 对象，我们想要的是浏览器 DOM 元素。
- en: An alternative way is to select the element via jQuery and use its `.get()`
    method to retrieve the DOM elements of the jQuery object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 jQuery 选择元素，并通过其 `.get()` 方法检索 jQuery 对象的 DOM 元素。
- en: Pausing a sound
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停声音
- en: 'Similar to the play button, we can also pause the playback of an audio element
    by using the `pause` function. The following code pauses the `buttonactive` audio
    element:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与播放按钮类似，我们可以通过使用 `pause` 函数来暂停音频元素的播放。以下代码将暂停 `buttonactive` 音频元素：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is no `stop` function to stop the audio element. Instead, we can pause
    the audio and reset the `currentTime` property of the element to zero. The following
    code shows how we can stop an audio element:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 没有用于停止音频元素的 `stop` 函数。相反，我们可以暂停音频并重置元素的 `currentTime` 属性为 0。以下代码展示了如何停止音频元素：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adjusting the sound volume
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整声音音量
- en: 'We can also set the volume of the audio element. The volume must range between
    0 and 1\. We can set the volume to 0 to mute it, and set it to 1 for the maximum
    volume. The following code snippet sets the volume of the `buttonactive` audio
    to 30%:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以设置音频元素的音量。音量必须在 0 到 1 之间。我们可以将音量设置为 0 以静音，或设置为 1 以获得最大音量。以下代码片段将 `buttonactive`
    音频的音量设置为 30%：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using the jQuery hover event
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 jQuery 鼠标悬停事件
- en: 'jQuery provides a `hover` function to define the behavior when we mouse over
    and mouse out a DOM element. Here is how we use the `hover` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 提供了一个 `hover` 函数来定义当我们将鼠标悬停在 DOM 元素上和移出时应该执行的行为。以下是使用 `hover` 函数的方法：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The arguments of the `hover` function are explained as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`hover` 函数的参数解释如下：'
- en: '| Arguments | Discussion |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 讨论 |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `handlerIn` | The function is executed when the mouse moves in. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `handlerIn` | 当鼠标移入时执行该函数。 |'
- en: '| `handlerOut` | This is optional. The function is executed when the mouse
    moves out. When this function is not provided, the move out behavior is the same
    as the first function. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `handlerOut` | 这是可选的。当鼠标移出时执行该函数。当未提供此函数时，移出行为与第一个函数相同。 |'
- en: 'In the following code, we''ll play the mouse over sound effect when moving
    the mouse in and will pause the sound during mouse out:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，当鼠标移入时我们将播放鼠标悬停声音效果，并在鼠标移出时暂停声音：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: File format for WebAudio
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebAudio 文件格式
- en: We use an **AAC** format and the **Ogg** format file when we define the source
    of the audio element. Ogg is a free and open source media container format that
    is supported in Mozilla Firefox. There are applications that convert audio files
    into Ogg files. Audacity is one of these. Also, there are online tools that are
    convenient to use. Online-Convert ([http://audio.online-convert.com](http://audio.online-convert.com))
    is one of them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义音频元素的源时，我们使用 **AAC** 格式和 **Ogg** 格式文件。Ogg 是一个免费且开源的媒体容器格式，在 Mozilla Firefox
    中得到支持。有一些应用程序可以将音频文件转换为 Ogg 文件。Audacity 就是其中之一。此外，还有一些方便使用的在线工具。Online-Convert
    ([http://audio.online-convert.com](http://audio.online-convert.com)) 就是其中之一。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We didn't use the MP3 format because of the license costs. The royalty rates
    to use an MP3 in a distributed game is $2500 per game once there are more than
    5,000 distributed copies, according to the MP3 license website ([http://www.mp3licensing.com/royalty/games.html](http://www.mp3licensing.com/royalty/games.html)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用 MP3 格式，是因为许可证费用。根据 MP3 许可网站 ([http://www.mp3licensing.com/royalty/games.html](http://www.mp3licensing.com/royalty/games.html))，在发行超过
    5,000 份副本的分布式游戏中使用 MP3 的版税为每款游戏 2,500 美元。
- en: 'The following table shows the audio formats supported by the latest popular
    web browsers at the time of writing this book:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了在撰写本书时最新流行网络浏览器支持的音频格式：
- en: '| Browser | Ogg | AAC | WAV |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器 | Ogg | AAC | WAV |'
- en: '| --- | --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Firefox | Yes | Yes | Yes |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| Firefox | 是 | 是 | 是 |'
- en: '| Safari | - | Yes | Yes |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| Safari | - | 是 | 是 |'
- en: '| Chrome | Yes | Yes | Yes |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| Chrome | 是 | 是 | 是 |'
- en: '| Opera | Yes | Yes | Yes |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| Opera | 是 | 是 | 是 |'
- en: '| Internet Explorer | - | Yes | - |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 因特网浏览器 | - | 是 | - |'
- en: Pop quiz – using the audio tag
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 - 使用音频标签
- en: Q1\. How can we stop an `audio` element playing?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 我们如何停止一个 `audio` 元素播放？
- en: Use the `stop` function.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `stop` 函数。
- en: Use the `pause` function and reset the value of `currentTime` to `0`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pause` 函数并将 `currentTime` 的值重置为 `0`。
- en: Reset the value of `currentTime` to `0`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `currentTime` 的值重置为 `0`。
- en: Q2\. How can we put fallback content to display in browsers that do not support
    `audio` tags?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 我们如何将回退内容放置在不支持 `audio` 标签的浏览器中显示？
- en: Building a mini piano musical game
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建迷你钢琴音乐游戏
- en: Imagine now that we are not only playing a sound effect, but also playing a
    full song with the `audio` tag. Along with the song playing, there are some music
    dots moving downwards as a visualization of the music.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们现在不仅正在播放音效，而且还在使用 `audio` 标签播放完整的歌曲。随着歌曲的播放，还有一些音乐点向下移动，作为音乐的视觉表现。
- en: Time for action – creating a basic background for the music game
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为音乐游戏创建基本背景的时间行动
- en: First, we will draw a few paths in the Canvas as the background of the music
    playback.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在 Canvas 上绘制一些路径作为音乐播放的背景。
- en: 'We will continue working with our example and draw the background. Open the
    `index.html` file in a text editor and add the following highlighted code that
    defines the game scene with two Canvases set up:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续使用我们的示例并绘制背景。在文本编辑器中打开 `index.html` 文件，并添加以下突出显示的代码，该代码定义了带有两个 Canvas 的游戏场景：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We added a game scene in the HTML file. We want to put it on top of the menu
    scene, so we style the game scene to have an `absolute` position by adding the
    following to `audiogame.css`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 HTML 文件中添加了一个游戏场景。我们希望将其放在菜单场景的顶部，因此我们在 `audiogame.css` 中添加以下样式以使游戏场景具有
    `absolute` 位置：
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we will move on to the JavaScript part. Open the `html5games.audio.js`
    JavaScript file.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续到 JavaScript 部分。打开 `html5games.audio.js` JavaScript 文件。
- en: 'In the **Play** button click handler, we add the following highlighted code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **播放** 按钮的点击处理程序中，我们添加了以下突出显示的代码：
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Save all files and open the `index.html` in a browser. There should be a slide-in
    animation to show the music playback scene when we click on the **Play** button.
    The following screenshot sequence shows the slide-in animation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有文件并在浏览器中打开 `index.html`。当我们点击 **播放** 按钮时，应该有一个滑动动画来显示音乐播放场景。以下截图序列显示了滑动动画：
- en: '![Time for action – creating a basic background for the music game](img/B04290_06_05.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![为音乐游戏创建基本背景的时间行动](img/B04290_06_05.jpg)'
- en: '*What just happened?*'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created a game scene with Canvas. In this music game example, we introduced
    basic scene management in HTML5 games. We created a transition that links between
    the menu scene and the game scene.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Canvas 创建了一个游戏场景。在这个音乐游戏示例中，我们介绍了 HTML5 游戏中的基本场景管理。我们创建了一个连接菜单场景和游戏场景的过渡。
- en: Creating scenes in games
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏中的场景
- en: 'Creating **scenes** in a game is similar to creating **layers**, like we did
    in the last chapter. A scene is a DOM element that contains several children.
    All the children elements are positioned in absolute positions. We have two scenes
    in our example now. The following code snippet shows a possible scene structure
    in an entire game with a game over scene, credit scene, and leaderboard scene
    included:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中创建 **场景** 与创建 **层** 类似，就像我们在上一章中所做的那样。场景是一个包含多个子元素的 DOM 元素。所有子元素都定位在绝对位置。现在我们的示例中有两个场景。以下代码片段显示了一个整个游戏中的可能场景结构，包括游戏结束场景、信用场景和排行榜场景：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following screenshot shows that the scenes are placed in the same place
    on a web page. It is very similar to the layers structure. The difference is that
    we will control the scene by showing and hiding each scene:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示场景被放置在网页的相同位置。它与层结构非常相似。区别在于我们将通过显示和隐藏每个场景来控制场景：
- en: '![Creating scenes in games](img/B04290_06_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏中的场景](img/B04290_06_06.jpg)'
- en: Creating a slide-in effect in CSS3
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 CSS3 中创建滑动效果
- en: The game scene slides in from the top when the play button is clicked. This
    scene transition effect is done by moving the game scene using a CSS3 transition.
    The game scene position is initially placed with a negative top value. We then
    change the top position from negative value to zero with a transition, so it animates
    from the top to the correct position.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击播放按钮时，游戏场景从顶部滑动进入。这个场景转换效果是通过使用 CSS3 过渡移动游戏场景来实现的。游戏场景的初始位置具有负的顶部值。然后我们通过过渡将顶部位置从负值变为零，因此它从顶部动画到正确的位置。
- en: Another important thing to make the sliding effect work is to set the overflow
    of the parent DIV of the scenes to `hidden`. Without the hidden overflow, the
    game scene is visible even with a negative top position. Therefore, it is important
    to set the parent DIV of the scenes to the hidden overflow.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使滑动效果起作用的一个重要因素是设置场景的父`DIV`的溢出为`hidden`。如果没有隐藏溢出，即使顶部位置为负，游戏场景仍然是可见的。因此，将场景的父`DIV`设置为隐藏溢出是很重要的。
- en: 'The following screenshot illustrates the slide-in transition of the game scene.
    The `#game` DIV is the parent of both the menu scene and the game scene. The game
    scene moves from the top when we add the `.show-scene` class, which sets the top
    value to 0 with a transition:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了游戏场景的滑动过渡。`#game` DIV是菜单场景和游戏场景的父元素。当我们将`.show-scene`类添加到游戏场景时，它将顶部值设置为0，并带有过渡效果：
- en: '![Creating a slide-in effect in CSS3](img/B04290_06_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![在CSS3中创建滑动效果](img/B04290_06_07.jpg)'
- en: Have a go hero – creating different scene transition effects
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄 - 创建不同的场景过渡效果
- en: We made a slide-in effect for the scene transition when showing the game. By
    using JavaScript and CSS3, we can make many different scene transition effects
    creatively. Try adding your own transition effect to the game, such as fading
    in, pushing in from the right, or even flipping with a 3D rotation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为游戏显示时场景的过渡制作了一个滑动效果。通过使用JavaScript和CSS3，我们可以创造性地制作许多不同的场景过渡效果。尝试为游戏添加你自己的过渡效果，例如淡入、从右侧推入，甚至使用3D旋转翻转。
- en: Visualizing the music playback
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化音乐回放
- en: 'If you have ever played the Dance Dance Revolution, Guitar Hero, or the Tap
    Tap Revenge games, then you may be familiar with the music dots moving downwards
    or upwards and the player hitting the music dots when they move to the right place.
    The following screenshot demonstrates the Tap Tap Revenge game:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经玩过《舞力全开》、《吉他英雄》或《Tap Tap Revenge》游戏，那么你可能对音乐点向下或向上移动以及玩家在它们移动到正确位置时击打音乐点的情况很熟悉。以下截图展示了《Tap
    Tap Revenge》游戏：
- en: '![Visualizing the music playback](img/B04290_06_08.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![可视化音乐回放](img/B04290_06_08.jpg)'
- en: We will play a song in the `audio` tag with similar music visualization in the
    canvas.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`audio`标签中播放一首歌曲，并在画布中实现类似的音乐可视化。
- en: Time for action – creating the playback visualization in the music game
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 在音乐游戏中创建回放可视化
- en: 'In order to create the playback visualization in the music game, you''ll need
    to carry out the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在音乐游戏中创建回放可视化，你需要执行以下步骤：
- en: We need a song with both a melody part and a base part. Copy the `minuet_in_g.ogg`,
    `minuet_in_g.aac`, `minuet_in_g_melody.ogg`, and `minuet_in_g_melody.aac` files
    from the downloaded files or from the code bundle in the `media` folder.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个既有旋律部分又有基座的歌曲。从下载的文件或从`media`文件夹中的代码包中复制`minuet_in_g.ogg`、`minuet_in_g.aac`、`minuet_in_g_melody.ogg`和`minuet_in_g_melody.aac`文件。
- en: 'Then, add the `audio` tag with the song as a source file. Open the `index.html`
    file and add the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加带有歌曲作为源文件的`audio`标签。打开`index.html`文件并添加以下代码：
- en: '[PRE19]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The music visualization is mainly done in JavaScript. Open the `audiogame.js`
    JavaScript file in a text editor.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 音乐可视化主要在JavaScript中完成。在文本编辑器中打开`audiogame.js` JavaScript文件。
- en: 'Add a `MusicNote` object type to represent the music data and a `Dot` object
    type to represent the visual dot of the music note in the canvas as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`MusicNote`对象类型来表示音乐数据，并添加一个`Dot`对象类型来表示在画布中音乐音符的视觉点，如下所示：
- en: '[PRE20]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we need several game variables to store the `MusicNote` instances, the
    `Dot` instance, and other information. The level data is a sequence of time and
    the appearing line that is separated by a semicolon. We will record and create
    our own data in a later section. The level data represents the time and line at
    which the music note should appear:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要几个游戏变量来存储`MusicNote`实例、`Dot`实例和其他信息。关卡数据是一系列由分号分隔的时间和出现的线路。我们将在稍后的部分记录和创建我们自己的数据。关卡数据表示音乐音符应该出现的时间和线路：
- en: '[PRE21]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The level data is serialized and stored in a string format. We have the following
    function to extract the string in the `MusicNote` object instances and store in
    an array:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关卡数据以序列化字符串格式存储。我们有一个以下函数来提取`MusicNote`对象实例中的字符串并将其存储在数组中：
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code inside the `initMedia` function. It references the `melody`
    and `base` audio tags and loads the dot image for later use:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initMedia`函数内部添加以下代码。它引用了`melody`和`base`音频标签，并加载了点图像以供以后使用：
- en: '[PRE23]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the following code inside the `initGame` function. It references the canvas
    and `canvasContext` variables for later use:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initGame`函数内部添加以下代码。它引用了`canvas`和`canvasContext`变量，以供以后使用：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following two functions in the JavaScript file. The `startGame` function
    sets the starting time and executes the `playMusic` function with a delay. The
    latter function plays both the melody and base audios:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript文件中添加以下两个函数。`startGame`函数设置开始时间，并延迟执行`playMusic`函数。后者函数播放旋律和基音音频：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following `gameloop` function to JavaScript. The `gameloop` function
    creates new dots at the top of the game and moves the existing notes down:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`gameloop`函数添加到JavaScript中。`gameloop`函数在游戏顶部创建新的点，并将现有的音符向下移动：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, add the following code at the end of the jQuery ready function:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在jQuery ready函数的末尾添加以下代码：
- en: '[PRE27]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we call the `startGame` function in the click event handler of the
    **Play** button:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在**播放**按钮的点击事件处理程序中调用`startGame`函数：
- en: '[PRE28]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Save all files and open the `index.html` file in a web browser. The following
    screenshot shows the music playing with the music dots appearing on the top and
    moving downwards:![Time for action – creating the playback visualization in the
    music game](img/B04290_06_01.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件，并在网络浏览器中打开`index.html`文件。以下截图显示了音乐播放，音乐点出现在顶部并向下移动：![时间动作 – 在音乐游戏中创建回放可视化](img/B04290_06_01.jpg)
- en: '*What just happened?*'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just built a fully functional music game. This is the basic playback function.
    It plays the song with both the melody and the base part with some music dots
    moving downwards.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个功能齐全的音乐游戏。这是基本回放功能。它播放歌曲，同时旋律和基音部分有一些音乐点向下移动。
- en: Choosing the right song for the music game
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择适合音乐游戏的正确歌曲
- en: We have to be careful of copyright issues when choosing a song for the music
    game, as this usually requires you to pay a usage fee or make an agreement with
    the song copyright owner. This is fine if you are building a commercial music
    game that is going to be a hit in the game industry and the earnings can outweigh
    the copyright usage expense. As a book example here, however, we are going to
    use a copyright-free song. That is why we use the classical song *Minute in G*,
    which is in the public domain and free, and is also generated by computer software
    without a copyrighted performance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择音乐游戏的歌曲时，我们必须小心版权问题，因为这通常需要你支付使用费或与歌曲版权所有者达成协议。如果你正在构建一个即将在游戏行业取得成功的商业音乐游戏，并且收益可以抵消版权使用费用，那么这是可以接受的。然而，在这里作为一个书籍示例，我们将使用一首无版权的歌曲。这就是为什么我们使用古典歌曲*G小调的瞬间*，这是一首公共领域的免费歌曲，也是由计算机软件生成的，没有版权表演。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The performance of music can be copyrighted even if the song itself is free.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 即使歌曲本身是免费的，音乐的表现也可以受到版权保护。
- en: Playing audio on mobile devices
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在移动设备上播放音频
- en: There are restrictions on playing audio on mobile devices, specifically iOS
    and Android. The latest Android with Chrome browser can only play audio that's
    triggered by the user. That's why we cannot play the audio plainly after a timeout.
    We need to play the audio right after the click handler, and then we pause the
    audio for a suitable time delay to sync the audio with our music dots. In iOS,
    there are similar user-triggering restrictions. We cannot control audio volume
    programmatically in mobile Safari. We may not be able to dim the melody in mobile
    Safari. Apart from this, the game is still playable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上播放音频有一些限制，特别是iOS和Android。最新的Android设备上搭载的Chrome浏览器只能播放由用户触发的音频。这就是为什么我们无法在超时后直接播放音频。我们需要在点击处理程序之后立即播放音频，然后暂停音频一段时间以同步音频与我们的音乐点。在iOS中，也有类似的用户触发限制。我们无法在移动Safari中通过编程控制音频音量。我们可能无法在移动Safari中降低旋律的音量。除此之外，游戏仍然可以玩。
- en: Storing and extracting the song-level data
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储和提取歌曲水平数据
- en: 'The level data shown in the *Time* *for* *action—creating the playback visualization
    in the music game* section is just a portion of the entire level data. It is a
    very long string storing music note information, including the time and the line.
    It is stored in the following format, which I came up with:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在“*时间* *动作—在音乐游戏中创建回放可视化”部分显示的水平数据只是整个水平数据的一部分。这是一个非常长的字符串，存储音乐音符信息，包括时间和行。它以以下格式存储，这是我提出的：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Each music dot data contains two pieces of information: the time to show up,
    and the line that is shown. This data is separated by a comma. Every piece of
    music dot data is separated by a semicolon. You can choose any characters to separate
    the data as long as the splitter doesn''t conflict with the data content. For
    example, choosing a number or full stop would be a bad choice here. The following
    code extracts the level string into a `MusicNote` object by splitting the semicolon
    and the comma:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个音乐点数据包含两件信息：出现的时间和显示的线路。这些数据由逗号分隔。每个音乐点数据由分号分隔。你可以选择任何字符来分隔数据，只要分隔符不与数据内容冲突即可。例如，选择数字或句点在这里会是一个糟糕的选择。以下代码通过分割分号和逗号将等级字符串提取到一个`MusicNote`对象中：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The level data string is recorded by the keyboard and we are going to discuss
    the recording later in this chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 等级数据字符串是通过键盘记录的，我们将在本章后面讨论记录过程。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The level data contains only a few music notes here. In the code bundle, there
    is the entire level data of the complete song.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 等级数据在这里只包含几个音乐点。在代码包中，有完整歌曲的整个等级数据。
- en: There is an optional second parameter for the JavaScript `parseInt` function.
    It defines the radix of the number to parse. By default, it uses a decimal but
    `parseInt` will parse the string as an octal when the string begins with zero.
    For example, `parseInt("010")` returns result 8 instead of 10\. If we want the
    decimal number, then we can use `parseInt("010",10)` to specify the radix.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`parseInt`函数有一个可选的第二个参数。它定义了要解析的数字的基数。默认情况下，它使用十进制，但`parseInt`会在字符串以零开头时将其解析为八进制。例如，`parseInt("010")`返回结果8而不是10。如果我们想得到十进制数，则可以使用`parseInt("010",10)`来指定基数。
- en: Getting the elapsed time of the game
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取游戏的已过时间
- en: Although we know the elapsed time of an audio element by accessing the `currentTime`
    property, we want to get the time from the start of the game.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以通过访问`currentTime`属性来知道音频元素的已过时间，但我们想从游戏开始的时间获取时间。
- en: We can get the elapsed time by storing the current computer time when starting
    the game and subtracting the current time value to get the elapsed time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在游戏开始时存储当前计算机时间，然后减去当前时间值来获取已过时间。
- en: 'We get the current computer time by using the `Date` object. The following
    code snippet shows how we use `startingTime` to get the elapsed time, which is
    in milliseconds:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`Date`对象来获取当前计算机时间。以下代码片段展示了我们如何使用`startingTime`来获取已过时间，它是以毫秒为单位的：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following screenshot shows the preceding code snippet running in the console:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在控制台中运行的上述代码片段：
- en: '![Getting the elapsed time of the game](img/B04290_06_13.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![获取游戏的已过时间](img/B04290_06_13.jpg)'
- en: Creating music dots
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建音乐点
- en: 'In the `gameloop` function, we check all the `MusicNote` instances and see
    whether it is time to create the visual dot of that music note. The following
    code shows the logic we used to create the visual music dot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gameloop`函数中，我们检查所有的`MusicNote`实例，看是否是创建该音符视觉点的时间。以下代码展示了我们用来创建视觉音乐点的逻辑：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Basically, we get the elapsed time of the game and compare it with the current
    time of each music note. If the time difference between the note's current time
    and elapsed time is within 30 milliseconds, then we create the visual dot instance
    and let the `gameloop` function draw it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们获取游戏的已过时间，并将其与每个音符的当前时间进行比较。如果音符的当前时间与已过时间之间的时间差在30毫秒以内，那么我们就创建视觉点实例，并让`gameloop`函数绘制它。
- en: Moving the music dots
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动音乐点
- en: There is a time difference between the game start and music start. The game
    starts several seconds before the song starts playing. This is because we need
    to show the music dots and move them down before the music starts.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始和音乐开始之间存在时间差。游戏在歌曲开始播放前几秒钟就开始了。这是因为我们需要在音乐开始之前显示并移动音乐点。
- en: The music dots should match the song when the dots are on the grey line. The
    music dots appear from the top of the game and move down towards the grey line.
    We delay the music play to wait as the dots move from top to bottom. This is around
    3.55 seconds in this example, so we delay the music playing by 3.55 seconds. This
    delay may vary when playing different songs. So we may store this information
    later if we extend the game to support multiple songs playback.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当点在灰色线上时，音乐点应该与歌曲匹配。音乐点从游戏顶部出现并向下移动到灰色线。我们延迟音乐播放以等待点从顶部移动到底部。在这个例子中，这大约是3.55秒，所以我们延迟了3.55秒的音乐播放。这个延迟在播放不同歌曲时可能会有所不同。因此，如果我们扩展游戏以支持多首歌曲播放，我们可能会稍后存储此信息。
- en: 'When the dot is created, it is placed at a given distance. We decrease all
    the dots'' distances by 2.5 every time the `gameloop` function is executed. The
    distance is stored in each `dot` object, representing how far away it is from
    the grey line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当点被创建时，它放置在给定的距离。每次执行`gameloop`函数时，我们都会将所有点的距离减少2.5。这个距离存储在每个`dot`对象中，表示它离灰色线的距离：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The *y* position of the dot is calculated by the grey line, subtracting the
    distance as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 点的*y*位置是通过灰色线计算的，减去距离如下：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following screenshot shows the distance between the grey line and each
    dot. When the distance is zero, it is exactly on the grey line:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了灰色线和每个点之间的距离。当距离为零时，它正好在灰色线上：
- en: '![Moving the music dots](img/B04290_06_09.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![移动音乐点](img/B04290_06_09.jpg)'
- en: Creating a keyboard-driven mini piano musical game
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个键盘驱动的迷你钢琴音乐游戏
- en: Now we can click on the **Play** button. The music game slides in and plays
    the song with music notes dropping down. Our next step is adding interaction to
    the music notes. Therefore, we will add keyboard events to control the three lines
    to hit the music notes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以点击**播放**按钮。音乐游戏滑入并播放歌曲，音符从上往下落下。我们的下一步是添加交互到音乐音符。因此，我们将添加键盘事件来控制三条线击中音乐音符。
- en: Time for action – creating a mini piano musical game
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建迷你钢琴音乐游戏
- en: 'Carry out the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'We want to show an indication when pressing the keyboard. Open the `index.html`
    file and add the following highlighted HTML:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想在按下键盘时显示一个指示。打开`index.html`文件并添加以下高亮的HTML：
- en: '[PRE35]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we may want to inform visitors that they can play the game by pressing
    the *J*, *K*, and *L* keys. Modify the footer content as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可能想通知访客他们可以通过按下*J*、*K*和*L*键来玩游戏。修改页脚内容如下：
- en: '[PRE36]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we will move on to the stylesheet. Open the `css/audiogame.css` file and
    put the following code at the end of the file:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续到样式表。打开`css/audiogame.css`文件并将以下代码放在文件末尾：
- en: '[PRE37]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we will add the keyboard event in the JavaScript part. Open the `audiogame.js`
    JavaScript file and add the following code inside the audiogame object:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在JavaScript部分添加键盘事件。打开`audiogame.js` JavaScript文件并在audiogame对象内部添加以下代码：
- en: '[PRE38]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we call the `initKeyboardListener` function in the `initGame` function:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`initGame`函数中调用`initKeyboardListener`函数：
- en: '[PRE39]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now save all the files and open the game in a browser. Try pressing the *J*,
    *K*, and *L* keys. The three hit line indicator should appear and fade out when
    the key is pressed. If the music dot passes by the horizontal line when hitting
    the right key, then it disappears:![Time for action – creating a mini piano musical
    game](img/B04290_06_10.jpg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存所有文件并在浏览器中打开游戏。尝试按下*J*、*K*和*L*键。当按下键时，三个击中线条指示器应该出现并淡出。如果音乐点在按下正确键时通过水平线，则它消失：![行动时间
    - 创建迷你钢琴音乐游戏](img/B04290_06_10.jpg)
- en: '*What just happened?*'
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We just added keyboard interaction to our music game. There is a glow animation
    when hitting the keys. The music dot will disappear when the right key is pressed
    at the right moment. You can take a look at the following URL for an example of
    the current progress: [http://makzan.net/html5-games/audiogame-wip-keyboard/](http://makzan.net/html5-games/audiogame-wip-keyboard/).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为我们音乐游戏添加了键盘交互。当击中键时，会有一个发光动画。当在正确的时间按下正确的键时，音乐点将消失。您可以查看以下URL查看当前进度的示例：[http://makzan.net/html5-games/audiogame-wip-keyboard/](http://makzan.net/html5-games/audiogame-wip-keyboard/)。
- en: Hitting the three music lines by key down
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过按下键来击中三条音乐线
- en: We use the *J*, *K*, and *L* keys to hit the three music lines in the game.
    The *J* key controls the left line, the *K* key controls the middle line, and
    the *L* key controls the right one.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*J*，*K*和*L*键来击中游戏中的三条音乐线。*J*键控制左侧线，*K*键控制中间线，*L*键控制右侧线。
- en: 'There is also an indication showing that we just hit the music line. This is
    done by placing the following image at the intersection of the horizontal line
    and the vertical lines:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个指示显示我们刚刚触发了音乐线。这是通过在水平线和垂直线的交点放置以下图像来完成的：
- en: '![Hitting the three music lines by key down](img/B04290_06_11.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![通过按键触发三条音乐线](img/B04290_06_11.jpg)'
- en: 'Next, we can control the showing and hiding of the hit indication graphics
    with the following jQuery code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用以下jQuery代码来控制显示和隐藏触发的指示图形：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The *J*, *K*, and *L* keys control the music lines 1 to 3\. As J, K, and L have
    the key code 74, 75, and 76 respectively, we know which line number it is by subtracting
    73 from the key code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*J*，*K*和*L*键控制音乐线1到3。由于J，K和L的键码分别是74，75和76，我们可以通过从键码中减去73来确定是哪条线。'
- en: Determining music dot hits on key down
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在按键按下时确定音乐点击中
- en: 'The distance is close to zero if the dot is almost on the grey horizontal line.
    This helps us to determine whether the dots hit the grey line. By checking both
    the key down event and the dot distance, we can determine whether we successfully
    hit a music dot. The following code snippet shows that we consider the dot is
    hit when the distance is close enough; in this case it''s within 20 pixels:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点几乎在灰色水平线上，则距离接近零。这有助于我们确定点是否击中了灰色线。通过检查按键按下事件和点距离，我们可以确定是否成功击中了音乐点。以下代码片段显示，当距离足够近时，我们认为点被击中；在这种情况下，它是在20像素以内：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With determination, we remove the music dots when we hit them. The missed dots
    will still pass through the grey line and move toward the bottom. This creates
    basic game play where the player has to eliminate all the music dots by hitting
    them correctly at the right moment when the song is playing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 坚定地，当我们击中音乐点时，我们会移除音乐点。未击中的点仍然会穿过灰色线并移动到底部。这创造了基本的游戏玩法，玩家必须通过在歌曲播放时正确地在正确的时间击中音乐点来消除所有的音乐点。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we remove elements in array inside an iteration, we usually iterate it
    backwards to avoid an error of null reference after elements are deleted in the
    array.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在迭代中移除数组内的元素时，我们通常从后向前迭代，以避免在数组中删除元素后的空引用错误。
- en: Removing an element in an array with the given index
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据给定的索引从数组中移除一个元素
- en: 'We remove the music dot data from an array when it is hit (and thus it will
    not be drawn anymore). To remove an element in an array, we use the `splice` function.
    The following line of code removes one element from an array at the given index:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们触发音乐点时，我们会从数组中移除音乐点数据（因此它将不再被绘制）。要移除数组中的元素，我们使用`splice`函数。以下代码行从给定索引的数组中移除一个元素：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `splice` function is a little tricky to use. This is because it allows us
    to add or remove elements in an array. Then, it returns removed elements as another
    array.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice`函数使用起来有点棘手。这是因为它允许我们在数组中添加或移除元素。然后，它将移除的元素作为另一个数组返回。'
- en: 'This is how we use the `splice` function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`splice`函数的使用方法：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following table shows how we use the arguments:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了如何使用参数：
- en: '| Argument | Definition | Discussion |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `index` | Specifies the index of an element to be added or removed in the
    array | The index starts from 0\. 0 means the first element, 1 means the second
    one, and so on. We can also use negative indexes, such as -1, which means the
    last element, -2, which means the second last element, and so on. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `index` | 指定要添加或移除的数组中元素的索引 | 索引从0开始。0表示第一个元素，1表示第二个，以此类推。我们也可以使用负索引，例如-1，表示最后一个元素，-2，表示倒数第二个元素，依此类推。
    |'
- en: '| `length` | Specifies how many elements we want to remove | Putting 0 means
    we do not remove any element. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `length` | 指定我们想要移除的元素数量 | 将0放入表示我们不移除任何元素。 |'
- en: '| `element1`, `element2`, … `elementN` | The new elements to be added into
    the array | This is optional. Putting a list of elements here means we add the
    elements at the given index. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `element1`, `element2`, … `elementN` | 要添加到数组中的新元素 | 这是可选的。在这里放入一个元素列表表示我们在给定的索引处添加元素。
    |'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Mozilla Developer Network link discusses different usages of the `splice`
    function at: [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla开发者网络链接讨论了`splice`函数的不同用法，请参阅：[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)。
- en: Have a go hero
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: In similar commercial music games, there are some words showing when the player
    hits or misses a music dot. How can we add this feature to our game?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似商业音乐游戏中，当玩家击中或错过音乐点时，有一些文字会显示出来。我们如何将这个功能添加到我们的游戏中？
- en: Adding additional features to the mini piano game
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为迷你钢琴游戏添加额外功能
- en: We have created basic interaction in the game. We can go further to make the
    game better by adding melody volume feedback. This will make the performance playing
    realistic and count the success rate of the performance.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在游戏中创建了基本的交互。我们可以通过添加旋律音量反馈来进一步改进游戏，这将使表演更加逼真，并计算表演的成功率。
- en: Adjusting the music volume according to the player
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据玩家调整音乐音量
- en: Imagine that now we are in a performance playing the music. We hit the music
    dots to play the melody. If we miss any of them, then we fail to perform it well
    and the melody disappears.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，现在我们正在一场表演中演奏音乐。我们击打音乐点来演奏旋律。如果我们错过任何一个，那么我们就无法很好地完成表演，旋律就会消失。
- en: Time for action – removing missed melody notes
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 移除未击中的旋律音符
- en: 'We will store some game play statistics and use them to adjust the melody volume.
    We will continue with our JavaScript file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将存储一些游戏统计数据，并使用它们来调整旋律音量。我们将继续使用我们的JavaScript文件：
- en: 'First, add the following variables in the variable declaration region:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在变量声明区域添加以下变量：
- en: '[PRE44]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We want to not only remove a dot but also keep track of the result when we
    hit it by using a keyboard. Add the following code inside the `hitOnLine` function:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不仅想要移除一个点，还要通过使用键盘击中它来跟踪结果。在`hitOnLine`函数内部添加以下代码：
- en: '[PRE45]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `gameloop` function, we calculate all missed dots and store the result.
    Then, we can use these statistics to get the successful rate of the game. Add
    the following code to the `gameloop` function:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameloop`函数中，我们计算所有未击中的点并存储结果。然后，我们可以使用这些统计数据来获取游戏的成功率。将以下代码添加到`gameloop`函数中：
- en: '[PRE46]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Lastly, we adjust the melody volume by using the successful rate. Put the following
    code after the code we just added in the `gameloop` function:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过使用成功率来调整旋律音量。在刚刚添加的`gameloop`函数代码之后放置以下代码：
- en: '[PRE47]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Save all files and test our game in a browser. When the player continues to
    play the game well, the melody keeps playing. When the player misses several music
    dots, the melody disappears and only the base plays.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件，并在浏览器中测试我们的游戏。当玩家继续很好地玩游戏时，旋律会继续播放。当玩家错过几个音乐点时，旋律会消失，只有基础音会播放。
- en: '*What just happened?*'
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We just used the player''s performance as feedback on the melody volume. This
    gives the player the feeling that we are really performing the music. When we
    perform poorly, the melody volume is low and the song sounds poor too. You may
    try the working example at the following URL: [http://makzan.net/html5-games/audiogame-wip-volume/](http://makzan.net/html5-games/audiogame-wip-volume/).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用玩家的表现作为旋律音量的反馈。这给玩家一种我们真的在演奏音乐的感觉。当我们表现不佳时，旋律音量会降低，歌曲听起来也很糟糕。你可以尝试以下URL中的工作示例：[http://makzan.net/html5-games/audiogame-wip-volume/](http://makzan.net/html5-games/audiogame-wip-volume/)。
- en: Removing dots from the game
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从游戏中移除点
- en: 'We want to remove the dots either after they drop under the bottom bound or
    when they are being hit by the player. The game loop displays all the dots in
    the dot list on the game canvas. We can remove the dot graphic by removing its
    data from the array of dots. We''ll use the following `splice` function to remove
    an entry in the array of the target index:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在点掉到下界以下或被玩家击中时移除点。游戏循环在游戏画布上显示点列表中的所有点。我们可以通过从点的数组中移除其数据来移除点图形。我们将使用以下`splice`函数来移除目标索引处的条目：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Storing the success count in the last five results
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将成功次数存储在最后五次结果中
- en: In our game, we need to store the success count in the last five results to
    calculate the success rate. We can do this by using a counter representing this.
    When a dot is successfully hit, the counter increases by one, but when the player
    fails to hit a dot, the counter decreases by 1.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们需要存储最后五个结果中的成功计数来计算成功率。我们可以通过使用表示这个的计数器来实现这一点。当一个点成功击中时，计数器增加1，但是当玩家未能击中点时，计数器减少1。
- en: The counter then represents the successful counts within the last few results
    if we limit the counter to have a range, 0 to 5 in our example.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将计数器限制在0到5的范围内，那么计数器就代表了最后几个结果中的成功计数。
- en: Have a go hero
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: We discussed how to display the game progress in the Untangle game in the last
    chapter. Can we apply a similar technique in the music game? We have the player's
    success percentage during game play. How about displaying it as a percentage bar
    at the top of the game?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个章节中讨论了如何在Untangle游戏中显示游戏进度。我们能否在音乐游戏中应用类似的技术？我们有玩家在游戏中的成功率。我们是否可以将它显示为游戏顶部的百分比条形图？
- en: Recording music notes as level data
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将音乐音符记录为级别数据
- en: The game relies on the level data to play. The playback visualization will not
    work if there is no level data. We also cannot play it if the playback visualization
    is not working. So how can we record that level data?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏依赖于级别数据来播放。如果没有级别数据，播放可视化将不起作用。如果播放可视化不起作用，我们也不能播放。那么我们如何记录这些级别数据呢？
- en: Imagine that now the music is playing without any music dots appearing in the
    game. We listen to the music carefully and press the *J*, *K*, *L* keys when the
    music plays. After the music ends, we print out all the keys and time we pressed.
    This data will then be used in the playback visualization of the music.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，现在音乐正在播放，但游戏中没有出现任何音乐点。我们仔细聆听音乐，并在音乐播放时按下*J*、*K*、*L*键。音乐结束后，我们打印出所有按下的键和时间。然后，这些数据将用于音乐的播放可视化。
- en: Time for action – adding functionalities to record the music level data
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动 – 添加记录音乐级别数据的函数
- en: 'Carry out the following steps:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First, we create a variable to toggle between the recording mode and normal
    playing mode. Open the `html5games.audio.js` file and add the code as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个变量来在录制模式和正常播放模式之间切换。打开`html5games.audio.js`文件，并添加以下代码：
- en: '[PRE49]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we add the following highlighted code in the `keydown` event handler.
    This code stores all our pressed keys in an array and prints them out to the console
    when the semicolon key is pressed:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在`keydown`事件处理器中添加以下突出显示的代码。这段代码将所有按下的键存储在一个数组中，并在按下分号键时将它们打印到控制台：
- en: '[PRE50]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we want to make sure that the `setupLevelData` and `gameloop` functions
    are not executed during the recording mode. These functions are for the playing
    mode only:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们想要确保在录制模式下不执行`setupLevelData`和`gameloop`函数。这些函数仅用于播放模式：
- en: '[PRE51]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now open the `index.html` file in a browser. After clicking on the **Play**
    button, the game starts and the music plays without the music notes. Try pressing
    the *J*, *K*, and *L* keys following the music beat. After finishing the music,
    press the semicolon to print the level data in the console. The following screenshot
    shows the console displaying the level data string:![Time for action – adding
    functionalities to record the music level data](img/B04290_06_12.jpg)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在浏览器中打开`index.html`文件。点击**播放**按钮后，游戏开始，音乐播放但没有音乐音符。尝试按照音乐节奏按下*J*、*K*和*L*键。音乐结束后，按下分号键将级别数据打印到控制台。以下截图显示了控制台显示的级别数据字符串：![时间行动
    – 添加记录音乐级别数据的函数](img/B04290_06_12.jpg)
- en: '*What just happened?*'
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just added a recording feature to our game. We can now record our music notes.
    We can toggle the record mode and playing mode by setting the `audiogame.isRecordMode`
    variable to `true` and `false`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为我们的游戏添加了一个录制功能。现在我们可以录制我们的音乐音符。我们可以通过设置`audiogame.isRecordMode`变量为`true`和`false`来切换录制模式和播放模式。
- en: 'On every key press, we get the elapsed time of the melody and create a `MusicNote`
    instance with the time and line number. The following code shows how we record
    the pressed keys. The `currentTime` is cut to two decimal digits before saving:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次按键时，我们获取旋律的经过时间，并创建一个带有时间和行号的`MusicNote`实例。以下代码展示了我们如何记录按下的键。在保存之前，`currentTime`被截断到两位小数：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We also capture the semicolon key to print out all the recorded `MusicNote`
    data into a string. The string follows the `time,line;time,line;` format, so we
    can directly copy the printed string and paste it as level data to play.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还捕获分号键，将所有记录的 `MusicNote` 数据打印成一个字符串。字符串遵循 `time,line;time,line;` 格式，因此我们可以直接复制打印的字符串并将其粘贴为关卡数据来播放。
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `toFixed` function formats the number with the given number of trailing
    decimals. In our example, we used it to get the current time with `3` trailing
    decimals.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`toFixed` 函数使用给定的尾随小数位数格式化数字。在我们的例子中，我们使用它来获取带有 `3` 位尾随小数的当前时间。'
- en: Adding touch support
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加触摸支持
- en: Now the game works well on a desktop browser. But we want to make the game playable
    on mobile devices too.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏在桌面浏览器上运行良好。但我们希望使游戏在移动设备上也能玩。
- en: Time for action – indicating a game over event in the console
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在控制台中指示游戏结束事件
- en: We target the 3-intersection point between the horizontal line and the vertical
    line.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们针对水平线和垂直线之间的 3 个交点。
- en: 'We have defined three DIV elements there to display the graphics when hitting
    the *J*, *K*, and *L* keys. We modify the HTML to add a data-line-no attribute
    to these elements:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在那里定义了三个 DIV 元素来显示当按下 *J*、*K* 和 *L* 键时的图形。我们修改 HTML 以向这些元素添加一个 data-line-no
    属性：
- en: '[PRE53]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We move to JavaScript. We define a new function inside the `audiogame` object:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们转向 JavaScript。我们在 `audiogame` 对象内部定义了一个新函数：
- en: '[PRE54]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We call our newly created `initTouchAndClick` function in the `initGame` function:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `initGame` 函数中调用我们新创建的 `initTouchAndClick` 函数：
- en: '[PRE55]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We can now open the game in a mobile browser and play it with our fingers.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在移动浏览器中打开游戏，并用手指玩游戏。
- en: '*What just happened?*'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have added a touch event to the game. The data-line-no attribute in the HTML
    elements lets us know which line the player is touching. Then we call the same
    `hitOnLine` function that the `keydown` event calls, which shares the some code
    that handles the hit-or-miss determination.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为游戏添加了一个触摸事件。HTML 元素中的 data-line-no 属性让我们知道玩家正在触摸哪一行。然后我们调用与 `keydown` 事件调用的相同的
    `hitOnLine` 函数，它共享一些处理命中或未命中的代码。
- en: Handling the audio event in playback complete events
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在播放完成事件中处理音频事件
- en: We can play the game now, but there is no indication when the game is over.
    Imagine that now we want to know how well we played when the game is completed.
    We will capture the melody-ending signal and display the success rate of the game.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以玩游戏了，但没有指示游戏何时结束。想象一下，现在我们想知道游戏完成时我们玩得怎么样。我们将捕获旋律结束信号并显示游戏的成功率。
- en: Time for action – indicating a game over event in the console
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在控制台中指示游戏结束事件
- en: 'Carry out the following steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `audiogame.js` JavaScript file.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `audiogame.js` JavaScript 文件。
- en: 'Add the following code in the jQuery ready function:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 jQuery ready 函数中添加以下代码：
- en: '[PRE56]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the following event handler function at the end of the file:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾添加以下事件处理函数：
- en: '[PRE57]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It is time to save all files and play the game in a web browser. When the game
    is over, we should see a pop-up alert with the successful rate.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候保存所有文件并在网络浏览器中玩游戏了。当游戏结束时，我们应该看到一个弹出警告，显示成功率。
- en: '*What just happened?*'
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just listened to the `ended` event of the audio element and handled it with
    a handler function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚监听了音频元素的 `ended` 事件，并用处理函数处理了它。
- en: Handling audio events
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理音频事件
- en: 'There are many other events in the audio element. The following table lists
    a few commonly used audio events:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 音频元素中还有许多其他事件。以下表格列出了几个常用音频事件：
- en: '| Event | Discussion |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 讨论 |'
- en: '| --- | --- |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ended` | Sent when the audio element finishes a playback |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `ended` | 发送音频元素完成播放时 |'
- en: '| `play` | Sent when the audio element plays or resumes |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `play` | 发送音频元素播放或恢复时 |'
- en: '| `pause` | Sent when the audio element pauses |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `pause` | 发送音频元素暂停时 |'
- en: '| `progress` | Sent periodically when the audio element is downloading |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `progress` | 当音频元素正在下载时定期发送 |'
- en: '| `timeupdate` | Sent when the `currentTime` property changes |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `timeupdate` | 当 `currentTime` 属性改变时发送 |'
- en: 'Here we just listed a few commonly used events; you can refer to the complete
    audio event list in the Mozilla Developer Center at: [https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Media_events](https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Media_events).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们只列出了几个常用的事件；你可以参考 Mozilla 开发者中心中的完整音频事件列表：[https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Media_events](https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Media_events)。
- en: Have a go hero
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: In our music game, we print out the success rate in the console when the game
    is over. How about adding a game over scene to our game and showing it at the
    end of the game? It would be good to use animation transition when showing a game
    over scene too.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的音乐游戏中，当游戏结束时，我们在控制台打印出成功率。我们是否可以在游戏结束时添加一个游戏结束场景并显示它呢？在显示游戏结束场景时使用动画过渡也会很好。
- en: Note
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We have managed the sound assets and played the audio with the native JavaScript
    API. Sometimes it will get troublesome to manage a large amount of audio loading
    and playing. There are some JS libraries to help you manage HTML5 audio easier.
    Here are few of them:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经管理了声音资源，并使用原生的JavaScript API播放音频。有时管理大量音频的加载和播放会变得很麻烦。有一些JavaScript库可以帮助你更容易地管理HTML5音频。以下是一些：
- en: SoundJS ([http://www.createjs.com/SoundJS](http://www.createjs.com/SoundJS))
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SoundJS ([http://www.createjs.com/SoundJS](http://www.createjs.com/SoundJS))
- en: Buzz ([http://buzz.jaysalvat.com](http://buzz.jaysalvat.com))
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buzz ([http://buzz.jaysalvat.com](http://buzz.jaysalvat.com))
- en: AudioJS ([http://kolber.github.io/audiojs/](http://kolber.github.io/audiojs/))
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AudioJS ([http://kolber.github.io/audiojs/](http://kolber.github.io/audiojs/))
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about using the HTML5 audio element and built
    a music game. Specifically, we managed and controlled audio playback by using
    the HTML audio tag and related JavaScript API. You learned different attributes
    that change the audio tag's behavior. We made use of the audio tag to create a
    keyboard-based canvas game. We also made the game work on touch devices by sharing
    the common logic between keyboard input and touch input. We created the game with
    a special mode that helps the game level designer to create the level data.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用HTML5音频元素，并构建了一个音乐游戏。具体来说，我们通过使用HTML音频标签和相关JavaScript API来管理和控制音频播放。你学习了改变音频标签行为的不同属性。我们利用音频标签创建了一个基于键盘的canvas游戏。我们还通过在键盘输入和触摸输入之间共享通用逻辑，使游戏能够在触摸设备上运行。我们使用一种特殊模式创建游戏，这种模式有助于游戏关卡设计师创建关卡数据。
- en: You learned about adding music and sound effects in our HTML5 games. Now we
    are ready to build a more complete game by adding a leaderboard to store game
    scores in the next chapter.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你在我们的HTML5游戏中学习了如何添加音乐和音效。现在，我们准备在下一章中通过添加排行榜来构建一个更完整的游戏，用于存储游戏分数。
