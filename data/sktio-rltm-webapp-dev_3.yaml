- en: Chapter 3. Let's Chat
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。让我们聊天
- en: Beginning with Yahoo! Chat in the early 2000 and up to today's popular Google
    Talk or Facebook Chat, chatting has been the most popular form of real-time communication
    on the Internet. In this chapter, we will build a chat room using node and express,
    which we learned in the previous chapter, and the socket.io library that we will
    learn in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2000 年初的 Yahoo! Chat 到今天流行的 Google Talk 或 Facebook Chat，聊天一直是互联网上最受欢迎的实时通信形式。在本章中，我们将使用我们在上一章中学到的
    node 和 express 以及本章将要学习的 socket.io 库来构建一个聊天室。
- en: Creating the application
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: 'Similar to the way we created our application in the previous chapter, we will
    create a new `awesome-chat` application by executing the following commands in
    the command line:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一章中创建应用程序的方式类似，我们将通过在命令行中执行以下命令来创建一个新的 `awesome-chat` 应用程序：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will create our application and install the express application dependencies.
    Open the `package.json` file and change the name to `awesome-chat`, as shown in
    the following code snippet:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们的应用程序并安装 express 应用程序依赖项。打开 `package.json` 文件，将其名称更改为 `awesome-chat`，如下所示：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Designing the chat room
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计聊天室
- en: 'Let''s modify the view to make it look like a chat room. We will need an area
    to display the messages, a text input for the user to enter the message, and a
    button to send the message. We will add some aesthetic elements, such as a header,
    banner, and footer. When we are done, our chat room user interface should look
    like the one shown in the following screenshot:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改视图，使其看起来像聊天室。我们需要一个区域来显示消息，一个文本输入框供用户输入消息，以及一个发送消息的按钮。我们将添加一些美学元素，如页眉、横幅和页脚。完成之后，我们的聊天室用户界面应该看起来像以下截图所示：
- en: '![Designing the chat room](img/0786_03_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![设计聊天室](img/0786_03_01.jpg)'
- en: Awesome chat UI
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊叹的聊天 UI
- en: 'Let''s start editing `layout.jade` by adding a header and footer to it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编辑 `layout.jade` 开始，向其中添加页眉和页脚：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first change we make is to add the `block` keyword before `head`. This makes
    `head` a block, to which we can append content from the extending pages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一个更改是在 `head` 前添加 `block` 关键字。这使得 `head` 成为一个块，我们可以从中添加扩展页面的内容。
- en: 'The other change is the addition of a new header and footer. Note that we are
    using the `header` and `footer` tags from HTML5\. This code also introduces us
    to a new jade syntax. When we write `header#banner`, it will generate headers
    with `banner` as the `id` value. The generated HTML code will be as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变化是添加了新的页眉和页脚。请注意，我们正在使用 HTML5 中的 `header` 和 `footer` 标签。此代码还向我们介绍了一种新的 jade
    语法。当我们写 `header#banner` 时，它将生成具有 `banner` 作为 `id` 值的页眉。生成的 HTML 代码如下：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will edit `index.jade` to add the message area, message input, and
    the **Send** button:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编辑 `index.jade` 以添加消息区域、消息输入和 **发送** 按钮：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s run and see what our `awesome-chat` application looks like. Execute
    the application using `npm` and open `http://localhost:3` `000/` in the browser:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一下，看看我们的 `awesome-chat` 应用程序看起来怎么样。使用 `npm` 执行应用程序，并在浏览器中打开 `http://localhost:3000/`：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Hey, all the elements are there, but it doesn't look right! That's correct;
    to improve the look and feel of the application, we need to edit the stylesheet,
    which is located at `public/stylesheets/style.css`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，所有元素都在那里，但看起来不太对！没错；为了改善应用程序的外观和感觉，我们需要编辑样式表，它位于 `public/stylesheets/style.css`。
- en: 'We can edit it according to our taste. Here is one that works just fine for
    me:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据自己的喜好进行编辑。这里有一个对我来说效果很好的例子：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After saving this CSS and refreshing the page, here is what the chat room looks
    like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此 CSS 并刷新页面后，聊天室看起来是这样的：
- en: '![Designing the chat room](img/0786_03_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![设计聊天室](img/0786_03_02.jpg)'
- en: The awesome chat room
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊叹的聊天室
- en: Bringing in jQuery
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 jQuery
- en: 'jQuery is almost ubiquitous when it comes to JavaScript libraries, and we will
    use it in our application too. To add jQuery to our application, let''s download
    the latest release from [http://www.jquery.com/](http://www.jquery.com/) and save
    it to `public/javascript/jquery.min.js`. Then, we add the script in `layout.jade`
    to pull in jQuery to our application''s pages:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 在 JavaScript 库中几乎是无处不在的，我们也将它在我们的应用程序中使用。要将 jQuery 添加到我们的应用程序中，让我们从 [http://www.jquery.com/](http://www.jquery.com/)
    下载最新版本并将其保存到 `public/javascript/jquery.min.js`。然后，我们在 `layout.jade` 中添加脚本以将 jQuery
    拉入我们的应用程序页面：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Socket.IO
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO
- en: Ever since the onset of web applications, developers have worked towards different
    ways of getting duplex communication between the server and the browser. Be it
    using Java, Flash, Comet, or many other workarounds, all aim to do the same. But
    for the first time, there is a specification to build a full-duplex communication
    system by using HTML5 WebSockets. **WebSocket** is a revolutionary, new communication
    feature in the HTML5 specification that defines a full-duplex communication channel
    operating over the Web through a single socket.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Web应用程序的兴起以来，开发者们一直在寻找不同的方法来实现服务器和浏览器之间的全双工通信。无论是使用Java、Flash、Comet还是许多其他解决方案，所有这些目标都是相同的。但第一次，有一个规范可以通过使用HTML5
    WebSockets来构建全双工通信系统。**WebSocket**是HTML5规范中的一项革命性的新通信功能，它定义了一个通过单个socket在Web上操作的全双工通信通道。
- en: Although the WebSockets RFC is published, it is not, and will never be, available
    on older browsers that are still in use. Socket.io is an abstraction layer for
    WebSockets, with Flash, XHR, JSONP, and HTMLFile fallbacks. Socket.io provides
    an easy server and client library for making real-time, streaming updates between
    a web server and a browser client.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WebSocket RFC已经发布，但它并不，也永远不会在仍在使用的旧浏览器上可用。Socket.io是WebSocket的一个抽象层，具有Flash、XHR、JSONP和HTMLFile后备方案。Socket.io提供了一个简单易用的服务器和客户端库，用于在Web服务器和浏览器客户端之间进行实时、流式更新。
- en: 'Socket.io is a node module available through the npm, and we will add it to
    our package dependencies. The current release of socket.io is `0.9.10`. To add
    this to our dependencies, add the following line to the dependencies object in
    `package.json`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.io是通过npm提供的node模块，我们将将其添加到我们的包依赖项中。socket.io的当前版本是`0.9.10`。要将此添加到依赖项中，请将以下行添加到`package.json`中的依赖项对象：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And install it using the npm:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用npm安装它：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will bring socket.io in the `node_modules` folder. Now let's see how we
    will use it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把socket.io放入`node_modules`文件夹中。现在让我们看看我们将如何使用它。
- en: Handling events
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理
- en: Since the socket.io framework has components for both the server and the client,
    we will use these components to code our communication on both the sides. Events
    emitted on a socket on one side will be handled by the corresponding event handler
    on the other side. Socket.io is built so that both the sides can send messages
    or attach handlers to process the incoming messages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于socket.io框架同时包含服务器和客户端的组件，我们将使用这些组件在双方进行通信编码。在一侧socket上发出的事件将由另一侧相应的事件处理器处理。Socket.io就是这样构建的，使得双方都可以发送消息或附加处理器来处理传入的消息。
- en: 'Let''s begin by understanding how the messages will flow. It is important to
    remember that "messages" here are not the actual messages sent and received by
    users of the chat system, but the messages used for communication by the client
    and the server. There will be two types of messages, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解消息的流动方式。重要的是要记住，“消息”在这里并不是聊天系统用户实际发送和接收的消息，而是客户端和服务器用于通信的消息。将有两种类型的消息，如下所示：
- en: '**The system messages**: These messages will be sent by our chat system to
    the client, like when the user is connected, when others connect, or when users
    disconnect. Let''s identify it with `serverMessage`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统消息**：这些消息将由我们的聊天系统发送到客户端，比如当用户连接、其他人连接或用户断开连接时。让我们用`serverMessage`来标识它。'
- en: '**The user messages**: These messages will be sent by the client to the server
    and will actually carry the user''s message content in the payload. We will probably
    want to differentiate between the messages we send and the messages other users
    send. So let''s call them `myMessage` and `userMessage` respectively.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户消息**：这些消息将由客户端发送到服务器，实际上会在负载中携带用户的消息内容。我们可能想要区分我们发送的消息和其他用户发送的消息。所以让我们分别称它们为`myMessage`和`userMessage`。'
- en: When a user connects for the first time, the server will send a welcome message
    to the user as a `serverMessage` message.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户第一次连接时，服务器将发送一条欢迎消息给用户，作为`serverMessage`消息。
- en: When a user types in a message and presses the **Send** button, we will send
    a `userMessage` message from the browser to the server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入一条消息并按下**发送**按钮时，我们将从浏览器发送一条`userMessage`消息到服务器。
- en: On receiving the user message, the server will broadcast this message to all
    the other users. It will also send back the same message as `myMessage` to the
    user who originally sent the message.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到用户消息后，服务器将向所有其他用户广播这条消息。它还会将相同的信息作为`myMessage`发送回最初发送消息的用户。
- en: On receiving any message from the server, the browser will display the contents
    of the message in the message area.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当从服务器接收到任何消息时，浏览器将在消息区域显示消息的内容。
- en: The server
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: 'Now we will implement the server, which will perform the task of relaying the
    messages, as already mentioned. Create a file in the `routes` folder called `sockets.js`
    and insert the following code into it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现服务器，它将执行之前提到的中继消息的任务。在`routes`文件夹中创建一个名为`sockets.js`的文件，并将以下代码插入其中：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the first line of code (you must be familiar with this by now), we import
    the `socket.io` module; we will identify this module by the `io` variable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行代码（你现在应该已经熟悉了），我们导入`socket.io`模块；我们将通过`io`变量来识别这个模块。
- en: 'Since socket.io works with the communication layer, we need to set it up to
    listen to the HTTP server. The HTTP server can only be accessed from the main
    application module, so we have to pass `server` to our module before our module
    can do anything. Hence, we export a method called `initialize` from our module,
    which will set up the socket.io server and also bind all the message handlers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于socket.io与通信层一起工作，我们需要将其设置为监听HTTP服务器。HTTP服务器只能从主应用程序模块访问，因此我们必须在我们模块之前将`server`传递给我们的模块，这样我们的模块才能执行任何操作。因此，我们从我们的模块中导出一个名为`initialize`的方法，该方法将设置socket.io服务器并绑定所有消息处理程序：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `initialize` method will accept the HTTP `server` object as a parameter.
    This is required by socket.io:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialize`方法将接受HTTP `server`对象作为参数。这是socket.io所必需的：'
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On the first line of the method, we will pass the server to the socket.io module's
    `listen` method. The server is an instance of the node HTTP server module; socket.io
    will configure various handlers on this server. This is the only boilerplate code
    required to set up socket.io. Next, we need to set up our message handler for
    socket.io messages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的第一行，我们将服务器传递给socket.io模块的`listen`方法。服务器是node HTTP服务器模块的一个实例；socket.io将在该服务器上配置各种处理程序。这是设置socket.io所需的唯一模板代码。接下来，我们需要设置我们的socket.io消息处理程序。
- en: 'The first event that our server will receive is a new connection from a new
    client. This is identified by the `connection` event on the `io.sockets` object
    and notifies our application that a new client has opened a new connection and
    all the protocol negotiation (transparent to us) has been completed and now we
    have a socket to communicate with this client:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器将接收到的第一个事件是来自新客户端的新连接。这通过`io.sockets`对象的`connection`事件来识别，并通知我们的应用程序一个新客户端已经打开了一个新的连接，并且所有协议协商（对我们来说是透明的）已经完成，现在我们有一个可以与这个客户端通信的套接字：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `connection` event handler will be triggered, passing along the socket
    that was just established. The socket is an event emitter that can trigger different
    events based on the messages it gets, and we will use this socket also to communicate
    with the client for which it was created. There are several events exposed, such
    as the `connection` event to handle events on the server. Let''s take a quick
    look at these events:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`connection`事件处理程序将被触发，传递刚刚建立的套接字。套接字是一个事件发射器，可以根据它接收到的消息触发不同的事件，我们也将使用这个套接字与为它创建的客户端进行通信。有多个事件被公开，例如`connection`事件来处理服务器上的事件。让我们快速看一下这些事件：'
- en: '`io.sockets.on(''connection'', function(socket) {})`: Initial connection from
    a client. The `socket` argument should be used in further communication with the
    client.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.sockets.on(''connection'', function(socket) {})`：客户端的初始连接。`socket`参数应在后续与客户端的通信中使用。'
- en: '`socket.on(''message'', function(message, callback) {})`: The `message` handler
    is triggered when a message sent with `socket.send` is received. The `message`
    parameter is the message sent, and `callback` is an optional acknowledgment function.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''message'', function(message, callback) {})`：当通过`socket.send`发送的消息被接收时，`message`处理程序被触发。`message`参数是发送的消息，`callback`是一个可选的确认函数。'
- en: '`socket.on(''anything'', function(data) {})`: The `anything` event can be any
    event except the reserved events.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''anything'', function(data) {})`：`anything`事件可以是任何事件，除了保留事件。'
- en: '`socket.on(''disconnect'', function() {})`: This event is fired when the socket
    disconnects.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''disconnect'', function() {})`：当套接字断开连接时，此事件被触发。'
- en: 'Now that we have seen how to handle the socket events, let''s see how we can
    send messages from the server to the client:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何处理套接字事件，让我们看看我们如何从服务器向客户端发送消息：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `socket.send` method will send the message on the socket, which will be
    triggering the `message` event on the client. The message sent has to be a string,
    so we will use `JSON.stringify` to send the data for the message as a string.
    Here our message has two parts, a type and a message.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.send` 方法将在套接字上发送消息，这将触发客户端上的 `message` 事件。发送的消息必须是一个字符串，所以我们将使用 `JSON.stringify`
    将消息数据作为字符串发送。在这里，我们的消息有两个部分，一个类型和一个消息。'
- en: 'One part of our task is over, we are now able to welcome the user. The next
    task is to handle the user messages when they come in. For this, we set a `message`
    event handler on the socket:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务的一部分已经完成，我们现在能够欢迎用户。下一个任务是处理当用户消息到来时的用户消息。为此，我们在套接字上设置了一个 `message` 事件处理器：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just like any other event connector, `socket.on` will take two parameters, namely
    the event to handle and the event handler for it. In this case, unlike the `io.sockets.on`
    event, this event handler will receive the message as the parameter and not the
    socket.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他事件连接器一样，`socket.on` 将接受两个参数，即要处理的事件和相应的事件处理器。在这种情况下，与 `io.sockets.on`
    事件不同，这个事件处理器将接收消息作为参数，而不是套接字。
- en: Since the message is a string, we will parse the message's JSON string to create
    a `message` object. If this is a message sent by the user, this message will be
    of the type `userMessage`, and that is what we check.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消息是一个字符串，我们将解析消息的 JSON 字符串来创建一个 `message` 对象。如果这是一个用户发送的消息，这个消息将是 `userMessage`
    类型，这就是我们要检查的。
- en: Now, we have to send out this message to all the connected users. For this,
    socket.io provides us with a `broadcast` object. When we send the message using
    the `broadcast` object, it will be sent to all the clients that are connected,
    except to the one for which this socket was created. The syntax for sending the
    message here is the same; the difference is that it is called on the `broadcast`
    object, referred to as message flags in socket.io, instead of the socket itself.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将这条消息发送给所有已连接的用户。为此，socket.io 为我们提供了一个 `broadcast` 对象。当我们使用 `broadcast`
    对象发送消息时，它将被发送到所有已连接的客户端，除了创建此套接字的客户端。在这里发送消息的语法是相同的；区别在于它是在 `broadcast` 对象上调用的，在
    socket.io 中被称为消息标志，而不是套接字本身。
- en: Also, we want to send back the same content to the client that sent this message,
    but just change the type to `myMessage`. For this, we send the message directly
    on the socket.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想将相同的内容发送回发送此消息的客户端，但只需将类型更改为 `myMessage`。为此，我们直接在套接字上发送消息。
- en: 'That''s it. We have written the code for the server; but now we have to actually
    initialize this server. To do this, modify the server creation in `app.js` to
    set the `server` variable, as shown in the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们已经为服务器编写了代码；但现在我们必须实际初始化这个服务器。为此，修改 `app.js` 中的服务器创建，设置 `server` 变量，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have modified the HTTP server, we can call the socket module''s
    `initialize` method, passing this server as a parameter to it. Add the following
    line to the end of `app.js`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经修改了 HTTP 服务器，我们可以调用套接字模块的 `initialize` 方法，并将这个服务器作为参数传递给它。将以下行添加到 `app.js`
    的末尾：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The client
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: 'Now that we have seen how the server works, let''s see what the client does.
    The best part of socket.io is that it provides us the same API on the server and
    the client. For our chat logic on the client, let''s create a file called `chat.js`
    in the `public/javascripts` folder and add the following code to it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了服务器的工作方式，让我们看看客户端会做什么。socket.io 的最好之处在于它为服务器和客户端提供了相同的 API。对于客户端的聊天逻辑，让我们在
    `public/javascripts` 文件夹中创建一个名为 `chat.js` 的文件，并将以下代码添加到其中：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first step in starting the chat is to connect to the server:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 开始聊天的第一步是连接到服务器：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will send a connection request to the server from which the page was loaded.
    This will also negotiate the actual transport protocol and will finally result
    in the `connection` event being triggered on the server app.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从加载页面的服务器发送一个连接请求。这还将协商实际的传输协议，并最终在服务器应用程序上触发 `connection` 事件。
- en: 'The following code snippet connects the event handler for the `message` event:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段连接了 `message` 事件的处理器：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All we have to do with the incoming message is to append it to the `messages`
    area. We are adding one additional detail here by setting the `class` property
    for the newly appended `div` tag to be of the same type as that of the message.
    We can later use this to give a different look to the different types of messages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是将收到的消息追加到`messages`区域。我们在这里添加了一个额外的细节，通过设置新追加的`div`标签的`class`属性与消息类型相同。我们稍后可以使用这个属性来为不同类型的消息提供不同的外观。
- en: 'The last thing to do on the client side is to send the messages from the user.
    This will be done when the user writes his/her message in the message box and
    clicks the **Send** button. So, let''s add an event handler to the **Send** button.
    The important thing about UI elements'' event handlers is that they should be
    attached once the element is added to the document, that is, after it is created
    and ready. jQuery provides a convenient method to detect when the document is
    ready and adds a handler function to execute. There are two ways to do this; one
    is the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端最后要做的就是发送用户的消息。这将在用户在消息框中写下他的/她的消息并点击**发送**按钮时完成。因此，让我们给**发送**按钮添加一个事件处理器。关于UI元素的事件处理器，重要的是它们应该在元素被添加到文档中后附加，也就是说，在它被创建并准备好之后。jQuery提供了一个方便的方法来检测文档何时准备好，并将处理函数添加到执行。有两种方法可以做到这一点；一种如下所示：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The shortcut for the same is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的快捷方式如下所示：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the document is ready, we attach the event handler to the `cl` `ick` event
    of the **Send** button:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文档准备好，我们就将事件处理器附加到**发送**按钮的`click`事件上：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On clicking the **Send** button, we create our `data` object, setting the content
    of the message box as `message`, and `type` as `userMessage`. We can then use
    the `socket.send` method to send this data to the server. As you can see from
    the preceding code snippet, the syntax for sending messages from the client is
    the same as that of the server, and here too the message will be sent as a sting,
    which we create using `JSON.stringify(data)`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击**发送**按钮时，我们创建我们的`data`对象，将消息框的内容设置为`message`，并将`type`设置为`userMessage`。然后我们可以使用`socket.send`方法将此数据发送到服务器。正如您从前面的代码片段中可以看到，从客户端发送消息的语法与服务器相同，并且在这里消息也将以字符串的形式发送，我们使用`JSON.stringify(data)`创建这个字符串。
- en: 'Like the `connection` event and other predefined events on the server, we have
    some predefined events on the client too. These are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就像服务器上的`connection`事件和其他预定义事件一样，客户端也有一些预定义的事件。这些如下所示：
- en: '`socket.on(''connect'', function () {})`: The `connect` event is emitted when
    the socket is connected successfully.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''connect'', function () {})`：当套接字成功连接时，会触发`connect`事件。'
- en: '`socket.on(''connecting'', function () {})`:The `connecting` event is emitted
    when the socket is attempting to connect with the server.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''connecting'', function () {})`：当套接字尝试与服务器连接时，会触发`connecting`事件。'
- en: '`socket.on(''disconnect'', function () {})`: The `disconnect` event is emitted
    when the socket is disconnected.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''disconnect'', function () {})`：当套接字断开连接时，会触发`disconnect`事件。'
- en: '`socket.on(''connect_failed'', function () {})`: The `connect_failed` event
    is emitted when socket.io fails to establish a connection to the server and has
    no more transports to fall back to.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''connect_failed'', function () {})`：当socket.io无法与服务器建立连接且没有更多传输可以回退时，会触发`connect_failed`事件。'
- en: '`socket.on(''error'', function () {})`: The `error` event is emitted when an
    error occurs and it cannot be handled by the other event types.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''error'', function () {})`：当发生错误且无法由其他事件类型处理时，会触发`error`事件。'
- en: '`socket.on(''message'', function (message, callback) {})`: The `message` event
    is emitted when a message sent by using `socket.send` is received. The `message`
    parameter is the sent message, and `callback` is an optional acknowledgment function.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''message'', function (message, callback) {})`：当通过`socket.send`发送的消息被接收时，会触发`message`事件。`message`参数是发送的消息，`callback`是一个可选的确认函数。'
- en: '`socket.on(''anything'', function(data, callback) {})`: The `anything` event
    can be any event except the reserved events. The `data` parameter represents the
    data, and `callback` can be used to send a reply.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''anything'', function(data, callback) {})`：`anything`事件可以是任何事件，除了保留的事件。`data`参数表示数据，`callback`可以用来发送回复。'
- en: '`socket.on(''reconnect_failed'', function () {})`: The `reconnect_failed` event
    is emitted when socket.io fails to reestablish a working connection after the
    connection was dropped.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''reconnect_failed'', function () {})`：当socket.io在连接断开后无法重新建立有效连接时，会触发`reconnect_failed`事件。'
- en: '`socket.on(''reconnect'', function () {})`: The `reconnect` event is emitted
    when socket.io is successfully reconnected to the server.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''reconnect'', function () {})`: 当socket.io成功重新连接到服务器时，会触发`reconnect`事件。'
- en: '`socket.on(''reconnecting'', function () {})`: The `reconnecting` event is
    emitted when the socket is attempting to reconnect with the server.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''reconnecting'', function () {})`: 当套接字尝试重新连接到服务器时，会触发`reconnecting`事件。'
- en: The last task to be done on the client side is to add socket.io and the chat
    scripts to our chat room page. Since these will not be used on every page, instead
    of adding them to `layout.jade`, we will add these to `index.jade`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端的最后任务是添加socket.io和聊天脚本到我们的聊天室页面。由于这些脚本不会在每一个页面上使用，我们不会将它们添加到`layout.jade`中，而是将它们添加到`index.jade`中。
- en: 'Remember the change we had made to `layout.jade`, changing the code from `head`
    to `block head`? It will allow us to append the content from `index.jade` to the
    `head` tag:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们对`layout.jade`所做的更改，将代码从`head`更改为`block head`？这将允许我们将`index.jade`中的内容追加到`head`标签：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the following line of code, we are using Jade''s functionality to append
    content to a block in an inherited template from the child element. This is done
    using the `append` keyword. The syntax is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行代码中，我们使用Jade的功能将内容追加到从子元素继承的模板中的块。这是通过使用`append`关键字完成的。语法如下：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The shorter form is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 简短形式如下：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The next two lines of code add the script tags by adding `socket.io.js` and
    `chat.js` to our page. You might be wondering where the `/socket.io/socket.io.js`
    file comes from, since we neither add it and nor does it exist on the filesystem.
    This is part of the magic done by `io.listen` on the server. It creates a handler
    on the server to serve the `socket.io.js` script file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行代码通过将`socket.io.js`和`chat.js`添加到我们的页面中，添加了脚本标签。你可能想知道`/socket.io/socket.io.js`文件从何而来，因为我们既没有添加它，它也不存在于文件系统中。这是服务器上`io.listen`所做魔法的一部分。它会在服务器上创建一个处理程序来提供`socket.io.js`脚本文件。
- en: And we are ready. Restart the node server and browse to `http://localhost:3000`
    `/` to open the chat room. You will see the welcome message, **Welcome to the
    most interesting chat room on earth!**, being displayed in the message area.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了。重新启动node服务器，并浏览到`http://localhost:3000` `/`以打开聊天室。你将看到欢迎信息**欢迎来到地球上最有趣的聊天室**在消息区域显示。
- en: To see how our chat application works, open it in two separate browser instances.
    Now you can enter your message in the message box in one of the browsers and click
    **Send**. You will see it appear on the message area of both the browsers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们的聊天应用程序是如何工作的，请同时在两个不同的浏览器实例中打开它。现在你可以在一个浏览器中的消息框中输入你的消息，并点击**发送**。你将看到它在两个浏览器的消息区域显示。
- en: Congratulations! We now have a chat room. If you deploy it to a server or allow
    access to port `3000` on your system, you can invite your friends to chat.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们现在有一个聊天室了。如果你将其部署到服务器上，或者允许系统上的端口`3000`访问，你可以邀请你的朋友来聊天。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about socket.io and worked through some very basic
    concepts and APIs provided by socket.io. We also saw how to set up socket.io on
    the server and the client, and how to send and receive messages. While doing so,
    we also built a chat room application using all that we have learned up to this
    point.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了socket.io，并探讨了socket.io提供的一些非常基本的概念和API。我们还看到了如何在服务器和客户端上设置socket.io，以及如何发送和接收消息。在这个过程中，我们还使用我们到目前为止所学的一切构建了一个聊天室应用程序。
- en: In the next chapter we will build upon the application that we have created
    to add other features such as session data, multiple chat rooms, namespacing,
    and authentication while getting acquainted with the related features of socket.io.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将基于我们创建的应用程序添加其他功能，例如会话数据、多个聊天室、命名空间和身份验证，同时熟悉socket.io的相关功能。
