- en: Writing End-to-End Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写端到端测试
- en: In the previous chapter, [Chapter 4](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml),
    *Setting Up Development Tools*, we successfully bootstrapped our project. In this
    chapter, we'll begin the development of our user directory API, which simply consists
    of **Create, Read, Update, and Delete** (**CRUD**) endpoints.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，[第 4 章](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml)，*设置开发工具*中，我们成功启动了我们的项目。在本章中，我们将开始开发我们的用户目录
    API，它仅由 **创建、读取、更新和删除**（**CRUD**）端点组成。
- en: 'In [Chapter 1](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml), *The Importance
    of Good Code*, we discussed the importance of testing and briefly outlined the
    principles and high-level processes of **Test-Driven Development** (**TDD**).
    But theory and practice are two very different things. In this chapter, we will
    put the TDD approach into practice by first writing **End-to-End** (**E2E**) tests,
    and then using them to drive the development of our API. Specifically, we will
    do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml)，*良好代码的重要性*中，我们讨论了测试的重要性，并简要概述了
    **测试驱动开发**（**TDD**）的原则和高级流程。但理论和实践是两件非常不同的事情。在本章中，我们将通过首先编写 **端到端**（**E2E**）测试，然后使用它们来驱动我们
    API 的开发来实践 TDD 方法。具体来说，我们将做以下几件事：
- en: Learn about different types of test
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解不同类型的测试
- en: Practice implementing a TDD workflow, specifically following the **Red-Green-Refactor**
    cycle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习实现 TDD 工作流程，特别是遵循 **红-绿-重构** 循环
- en: Write E2E tests with **Cucumber** and **Gherkin**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Cucumber** 和 **Gherkin** 编写端到端测试
- en: Understanding different types of test
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同类型的测试
- en: 'First, let''s learn about the different types of tests and how they all fit
    into our project''s workflow. The first thing to note is that some tests are more
    technically-focused, while others are more business-focused; some tests are only
    concerned with a very small part of the whole system, while others test the system
    as a whole. Here''s a brief overview of the most common types of tests you''ll
    encounter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解不同类型的测试以及它们如何适应我们项目的流程。首先要注意的是，有些测试更侧重于技术，而有些则更侧重于业务；有些测试只关注整个系统的一个非常小的部分，而有些则测试整个系统。以下是您可能会遇到的最常见测试类型的简要概述：
- en: '**Unit tests**: These test the smallest testable parts of an application, called **units**.
    For example, if we have a function called `createUser`, we can write a unit test
    that tests that the function always returns a promise.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些测试应用程序中最小的可测试部分，称为**单元**。例如，如果我们有一个名为 `createUser` 的函数，我们可以编写一个单元测试来测试该函数始终返回一个承诺。'
- en: With unit tests, we are only concerned with the function of the unit, *independent
    of external dependencies*. If the unit has external dependencies, such as a database,
    we must substitute the real database client with a fake one. This fake client
    must be able to mimic the behavior of the database adequately so that, from the
    perspective of the unit under test, the fake behaves in the same way as the authentic
    database.
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在单元测试中，我们只关心单元的功能，*独立于外部依赖*。如果单元有外部依赖，例如数据库，我们必须用伪造的客户端替换真实的数据库客户端。这个伪造客户端必须能够充分模拟数据库的行为，以便从被测试单元的角度来看，伪造的行为与真实的数据库相同。
- en: We will talk more about fakes later, but the important takeaway is that unit
    tests test a small and specific component of the whole code base, using minimal
    (or no) dependencies, and without calling other parts of the application (that
    is, there are no **side-effects**).
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在稍后更详细地讨论伪造内容，但重要的是要记住，单元测试测试的是整个代码库中很小且特定的组件，使用最少的（或没有）依赖，并且不调用应用程序的其他部分（也就是说，没有**副作用**）。
- en: '**Integration tests:** These test whether different units can work together
    as a single, larger ensemble. To continue our example, the `createUser` function
    may rely on the `Auth` module to check whether the client has permission to create
    the user. We can create a test case where `createUser` is called with an unauthenticated
    client, and assert that the function throws an error.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些测试不同单元是否可以作为一个单一、更大的整体协同工作。以我们的例子继续，`createUser` 函数可能依赖于 `Auth`
    模块来检查客户端是否有权限创建用户。我们可以创建一个测试用例，其中 `createUser` 使用未认证的客户端调用，并断言该函数抛出错误。'
- en: Integration tests test the integration between two or more units and ensure
    they are compatible. In our example, if the `Auth` module changes the data structure
    of its response payload, and we forget to update our `createUser` method to consume
    this new data structure, the integration test should fail, alerting us to fix
    it.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 集成测试测试两个或多个单元之间的集成，并确保它们是兼容的。在我们的例子中，如果`Auth`模块更改其响应负载的数据结构，而我们忘记更新`createUser`方法以消费这种新的数据结构，集成测试应该失败，提醒我们修复它。
- en: '**E2E/functional tests**: These test the flow of an application from start
    to finish, acting as if we are the end consumers. In our example, we''d attempt
    to create a new user by actually sending a `POST` request to the `/users` endpoint,
    because that''s how our end users would actually interact with our API. After
    the call, we''d check the database to ensure that a user document is indeed created
    and conforms to the expected data structure.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端/功能测试**：这些测试从开始到结束测试应用程序的流程，就像我们是最终消费者一样。在我们的例子中，我们会尝试通过向`/users`端点发送实际的`POST`请求来创建新用户，因为这是我们的最终用户实际上与我们API交互的方式。调用后，我们会检查数据库以确保确实创建了一个用户文档，并且符合预期的数据结构。'
- en: '**User interface** (**UI**) **tests**: For applications that include a frontend
    component, UI tests are automated tests that mimic the behavior of real users
    interacting with the UI, such as scrolling and clicking. You may use generic browser
    automation tools such as **Selenium** ([https://www.seleniumhq.org/](https://www.seleniumhq.org/)),
    or framework-specific tools such as **Enzyme** ([airbnb.io/enzyme/](http://airbnb.io/enzyme/),
    used for React applications).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面**（**UI**）**测试**：对于包含前端组件的应用程序，UI测试是模拟真实用户与UI交互行为的自动化测试，例如滚动和点击。您可以使用通用的浏览器自动化工具，如**Selenium**（[https://www.seleniumhq.org/](https://www.seleniumhq.org/)），或者特定于框架的工具，如**Enzyme**（[airbnb.io/enzyme/](http://airbnb.io/enzyme/)，用于React应用程序）。'
- en: '**Manual tests**: These are tests that cannot be automated. Manual tests should
    be kept to a minimum as they are not deterministic and there''s a high cost to
    running them. Apart from catching bugs, manual tests can also unearth scenarios
    that are unintuitive and/or bad for **user experience** (**UX**).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动测试**：这些是无法自动化的测试。手动测试应尽量减少，因为它们不是确定性的，并且运行它们成本很高。除了捕获错误之外，手动测试还可以揭示不直观且/或对**用户体验**（**UX**）不利的场景。'
- en: '**Acceptance tests**: These differ from the other tests that have already been
    outlined because they are more focused on business needs. They are a list of business
    requirements (as opposed to functional requirements), laid out by the business
    stakeholders, that the platform must fulfill. For example, one such requirement
    might read "95% of all visitors must be able to load the page within 3 seconds".'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**：这些与其他已经概述的测试不同，因为它们更侧重于业务需求。它们是由业务利益相关者列出的一组业务需求（而不是功能需求），平台必须满足。例如，这样一个要求可能读作：“95%的所有访客必须在3秒内加载页面”。'
- en: This is not a purely technical requirement, but it drives the technical decisions
    that are to be made. For example, the development team may now be required to
    install analytics libraries to collect data on the load times of the site for
    all visitors, and to prioritize optimizing the site over developing new features.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不是一个纯粹的技术要求，但它推动了将要做出的技术决策。例如，开发团队现在可能需要安装分析库来收集有关所有访客网站加载时间的数据，并将优化网站优先于开发新功能。
- en: Parts of the acceptance tests may be written in a **Behavior-Driven Development**
    (**BDD**) format, which focuses on the steps that an actual user may take when
    interacting with the platform. One such requirement may read "Given a user has
    successfully authenticated and he is on a product page, when he clicks the Add
    to Cart button, then that product should be added to the cart". Then, when this
    requirement is verified, either through automated and/or manual testing, it would
    pass the acceptance test.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验收测试的部分可能以**行为驱动开发**（**BDD**）格式编写，这侧重于实际用户在与平台交互时可能采取的步骤。一个这样的要求可能读作：“给定一个用户已成功认证并且他正在产品页面上，当他点击“添加到购物车”按钮时，则该产品应添加到购物车”。然后，当这个要求通过自动化和/或手动测试得到验证时，它将通过验收测试。
- en: Think of acceptance tests as a final stage of the development process, when
    the business stakeholder accepts the work as complete.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将验收测试视为开发过程的最终阶段，此时业务利益相关者接受工作已完成。
- en: Structuring our test suite with the testing pyramid
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试金字塔结构化我们的测试套件
- en: Unit testing is the most **granular** form of testing, as it addresses the lowest
    possible level of detail of your project. Unit tests give you confidence in a
    very small part of your application, but are also the quickest to run, as they
    do not depend on other modules, databases, filesystems, or the network.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是测试的最**细粒度**形式，因为它针对的是项目可能达到的最小细节级别。单元测试让你对应用程序的非常小部分充满信心，但它们也是运行最快的，因为它们不依赖于其他模块、数据库、文件系统或网络。
- en: Therefore, you can set up your unit tests to run every time a change is made
    to your code; this will provide timely feedback as you develop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以设置你的单元测试，每次对代码进行更改时都运行；这将在你开发过程中提供及时反馈。
- en: Granularity decreases as you move to integration tests and E2E tests. These
    tests give you confidence in a larger part of your project, but are also slower
    to run.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你转向集成测试和端到端测试，粒度会降低。这些测试让你对项目更大的一部分充满信心，但它们的运行速度也更慢。
- en: Therefore, when we design our test suite, we should find a balance between writing
    unit, integration, and E2E tests. In [Chapter 1](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml),
    *The Importance of Good Code*, we briefly mentioned the concept of the **Testing
    Pyramid**; let's apply it here and make sure that our test suite contains a lot
    of unit tests, fewer integration tests, and the fewest E2E tests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们设计测试套件时，我们应该在编写单元、集成和端到端测试之间找到一个平衡。在[第一章](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml)《良好代码的重要性》中，我们简要提到了**测试金字塔**的概念；让我们在这里应用它，并确保我们的测试套件包含大量的单元测试、较少的集成测试和最少的端到端测试。
- en: When implementing a new feature, write your E2E tests first
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当实现新功能时，首先编写端到端测试。
- en: A common misinterpretation of TDD and the Testing Pyramid is that unit tests
    are more important than E2E tests, and that you should start writing unit tests
    *first*. This is wrong. TDD only requires you to write tests first, but does not
    specify the type of test you must use. The Testing Pyramid simply encourages you
    balance your test suite to have more granular tests; it does not specify the importance
    or order for which you test.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对TDD和测试金字塔的常见误解是单元测试比端到端测试更重要，你应该首先编写单元测试。这是错误的。TDD只要求你首先编写测试，但并没有指定你必须使用的测试类型。测试金字塔只是鼓励你平衡测试套件，使其包含更多细粒度的测试；它并没有指定测试的重要性或顺序。
- en: In fact, when implementing a new feature, E2E tests are the most important tests,
    and should be the first test you write when composing your test suite. E2E tests
    mimic how your end users would interact with the project, and are often tied to
    the business requirements. If your E2E tests pass, it means the feature you are
    developing is working.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当实现新功能时，端到端测试是最重要的测试，应该是在构建测试套件时首先编写的测试。端到端测试模拟了最终用户如何与项目交互，通常与业务需求相关。如果你的端到端测试通过，这意味着你正在开发的功能是正常工作的。
- en: Moreover, it's often impractical to write your unit tests first. A unit tests
    concerns itself with implementation details, but there are many ways to implement
    a set of features and our first solutions are often substandard. It is likely
    to undergo many iterations of changes before it becomes stable. Since unit tests
    are coupled to the implementation they are testing, when the implementation changes,
    the unit tests would be discarded.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通常在编写单元测试之前是不切实际的。单元测试关注的是实现细节，但实现一组功能的方式有很多种，我们的初始解决方案通常是不够标准的。它可能需要经过多次迭代才能变得稳定。由于单元测试与它们所测试的实现紧密耦合，当实现发生变化时，单元测试就会被丢弃。
- en: Therefore, when implementing new features, E2E tests should be written first;
    unit and integration tests should be written only after the implementation has
    settled.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在实现新功能时，应该首先编写端到端测试；单元和集成测试应该在实现确定之后编写。
- en: Finally, E2E tests and unit tests are not mutually exclusive. For example, if
    you are writing a library that exports as single utility function, then your E2E
    tests *are* your unit tests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，端到端测试和单元测试并不是相互排斥的。例如，如果你正在编写一个导出为单个实用函数的库，那么你的端到端测试**就是**你的单元测试。
- en: This is because your end users would interact with your unit directly, making
    E2E and unit tests one and the same. Therefore, always keep your target audience
    in mind, and think about how they'll interact with your project. Use the appropriate
    type of tests to define contracts/interfaces with the end consumers, and use these
    test to drive your development.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为您的最终用户将直接与您的单元交互，使得端到端测试和单元测试变得相同。因此，始终牢记您的目标受众，并考虑他们将如何与您的项目互动。使用适当的测试类型来定义与最终消费者的合同/接口，并使用这些测试来推动您的开发。
- en: 'Since we are developing new features, this chapter will focus on E2E tests.
    Unit and integration tests will be covered in the next chapter, *TDD Part II:
    Unit/Integration Tests*; and UI testing with Selenium will be covered in [Chapter
    15](76ad50ef-1134-4672-88e1-c2700f63268f.xhtml), *E2E Testing with React*. Manual
    tests are not programmable and thus earn only a brief mention at the end of this
    section.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们正在开发新功能，本章将重点介绍端到端测试。单元和集成测试将在下一章，*TDD Part II: 单元/集成测试*中介绍；而使用Selenium的UI测试将在[第15章](76ad50ef-1134-4672-88e1-c2700f63268f.xhtml)，*使用React进行端到端测试*中介绍。手动测试不可编程，因此在本节末尾只简要提及。'
- en: Following a TDD workflow
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循TDD工作流程
- en: Next, let's examine a typical TDD workflow, and see how the different types
    of tests fit into it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考察一个典型的TDD工作流程，看看不同类型的测试是如何融入其中的。
- en: Gathering business requirements
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集业务需求
- en: The TDD workflow starts with the product manager gathering **business requirements**
    from the business stakeholders, and then liaising with the technical team to refine
    these requirements, taking into account feasibility, costs, and time constraints.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TDD工作流程从产品经理从业务利益相关者收集**业务需求**开始，然后与技术团队协商以细化这些需求，考虑可行性、成本和时间限制。
- en: The scope of the requirements should be small. If the application is large,
    the product manager should prioritize the requirements by importance and urgency,
    and group them into phases. The first phase should contain the highest priority
    requirements, which would be implemented first.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 需求的范围应该小。如果应用程序很大，产品经理应该根据重要性和紧急性对需求进行优先级排序，并将它们分组到不同的阶段。第一阶段应包含最高优先级的需求，这些需求将首先实施。
- en: These requirements should be well-defined and unambiguous, so that there's no room
    for (mis)interpretation. This means they should quantified as much as possible.
    For example, instead of "the app must load quickly", it should say "the app must
    load within 1 second on an iPhone 5S".
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些需求应该定义明确且无歧义，以便没有（误解）的空间。这意味着它们应该尽可能地量化。例如，与其说“应用程序必须快速加载”，不如说“应用程序必须在iPhone
    5S上在1秒内加载”。
- en: Secondly, the requirement-gathering stage should be a joint-process involving
    many teams. Developers, designers, product managers, and business owners all provide
    different expertise and points of view. By allowing everyone to give feedback
    on the scope, timeline, and overall business strategy, it could help the team
    set realistic expectations and avoid common pitfalls.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，需求收集阶段应该是一个涉及许多团队的联合过程。开发者、设计师、产品经理和业务所有者都提供不同的专业知识和观点。通过允许每个人对范围、时间表和整体业务战略提供反馈，这可以帮助团队设定现实的目标并避免常见的陷阱。
- en: Formalizing requirements through documentation
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过文档正式化需求
- en: 'Once everyone has agreed on the requirements for the current phase, it is extremely
    important that they are formally documented. When everyone involved understands
    the requirements, it''s very tempting to not write them down; after all, it''s
    a boring chore that no one wants to do. One may even argue that it slows down
    development unnecessarily. However, we must fight against that temptation and
    be disciplined because of the following reasons:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦每个人都同意当前阶段的需求，正式记录它们就非常重要。当所有相关人员都理解了需求时，他们往往会觉得没有必要写下它们；毕竟，这是一项无聊的任务，没有人愿意做。有人甚至可能会争辩说，这无必要地减缓了开发进度。然而，我们必须抵制这种诱惑，并保持纪律，因为以下原因：
- en: '**People have bad memories**: I once read a tongue-in-cheek comment from an
    online discussion that said "Good programmers have good minutiae memory. Great
    programmers have good gestalt memory. Legendary programmers have no memory at
    all." Don''t rely on your memory—write down the requirements!'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人们记忆力不好**：我曾在一篇在线讨论中读到一条半开玩笑的评论说“好的程序员有好的细节记忆。伟大的程序员有好的整体记忆。传奇程序员根本就没有记忆。”不要依赖你的记忆——写下需求！'
- en: '**It prevents misinterpretation.**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这可以防止误解。**'
- en: '**A formalized requirement provides a** **S****ingle Source of Truth** (**SSoT**):
    In development, change is often the only constant. It is inevitable that requirements
    will change. 99% of the problems with requirement changes lies in not communicating
    that change with everyone, resulting in different team members having different,
    possibly conflicting, snapshots of the requirements. By having a single document
    that acts as an SSoT, we can ensure everyone has access to the latest, *and the
    same*, information.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范化的需求提供了一个** **单一事实来源** (**SSoT**)：在开发过程中，变化往往是唯一的不变因素。需求的变化是不可避免的。99%的需求变更问题在于没有与所有人沟通这一变化，导致不同的团队成员拥有不同、可能冲突的需求快照。通过拥有一个充当SSoT的单个文档，我们可以确保每个人都能访问最新的、*并且是相同的*信息。'
- en: '**A formalized requirement can be improved**: If there are areas of ambiguity,
    the language of the requirement can be revised to be more explicit. If someone
    forgot an important point, they can add it as an addendum.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范化的需求可以改进**：如果有模糊不清的地方，可以修订需求的语言使其更加明确。如果有人遗漏了重要的点，他们可以添加作为附录。'
- en: Finally, having a set of formal requirements is only helpful if it is kept up
    to date. It is very important that a single person is put in sole charge of maintaining
    the requirements document. Otherwise, everyone may assume someone else will update
    it, but then no one does. Out-of-date requirements may be worse than no requirements
    at all, if the old version conflicts with the most up-to-date version.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，只有当规范保持最新时，一套正式的需求才有帮助。非常重要的一点是，应该指定一个人负责维护需求文档。否则，每个人都可能认为其他人会更新它，但最终没有人去做。过时的需求可能比没有需求更糟，如果旧版本与最新版本冲突。
- en: However, this does not mean the person in charge has to be the one to actually
    update the document itself; he/she may appoint someone more suitable to do the
    task. But the point is that, ultimately, it is his/her responsibility to make
    sure the requirements are up to date.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着负责人必须亲自更新文档；他/她可以指派更适合的人来完成这项任务。但关键是，最终，他/她的责任是确保需求是最新的。
- en: Refining requirements into specification
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将需求细化成规范
- en: The requirements outline the high-level goals that the business wants the application
    to achieve, but it does not have sufficient details for developers to start implementation
    straight away. Requirements are imprecise and do not translate well into code,
    which is very explicit.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需求概述了业务希望应用实现的高级目标，但它没有足够的细节让开发者立即开始实施。需求是不精确的，并且不容易转换为代码，而代码是非常明确的。
- en: Instead, developers need to understand the overall business goal, and the current
    sets of requirements, and produces a more detailed set of **technical specifications**. A
    specification should contain sufficient technical details needed by developers
    to begin implementation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，开发者需要理解整体业务目标，当前的需求集合，并生成一套更详细的技术规范。规范应包含开发者开始实施所需的足够技术细节。
- en: 'In our case, the overall goal of the project is to "Create a web application
    that allows users to log in and update their profiles."; and the first requirement
    may be to "create an API server with an endpoint to create new users". You should
    now think about how to structure the application. For example, you may split the
    application into the following modules:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，项目的整体目标是“创建一个允许用户登录并更新其配置文件的Web应用程序”；第一个需求可能是“创建一个具有创建新用户端点的API服务器”。你现在应该考虑如何构建应用程序。例如，你可能将应用程序拆分为以下模块：
- en: '**Authentication**: To allow users to register and log in'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：允许用户注册和登录'
- en: '**Profile**: To allow users to edit their own profile and view the profile
    of others'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：允许用户编辑自己的配置文件并查看他人的配置文件'
- en: '**Database(s)**: To store user data'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库（s）**：用于存储用户数据'
- en: '**API server**: The interface between our internal services and external consumers'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API服务器**：我们内部服务和外部消费者之间的接口'
- en: With the structure of the application on the back of your mind, we can now move
    on to writing the specification. As we've already mentioned in [Chapter 1](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml), *The
    Importance of Good Code*, the best specifications are tests, so let's write some
    tests!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记应用程序的结构后，我们现在可以继续编写规范。正如我们在[第1章](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml)中提到的，“良好代码的重要性”，最好的规范是测试，所以让我们编写一些测试吧！
- en: Writing tests as specification
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将测试作为规范编写
- en: 'Tests are the best form of specification because:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是最佳规范形式，因为：
- en: Tests can be run, which means you can programmatically verify your implementation
    against your specification. If the tests pass, your implementation conforms to
    the specification.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试可以运行，这意味着你可以通过编程方式验证你的实现是否符合规范。如果测试通过，则你的实现符合规范。
- en: Tests are an integral part of the code (that is, **S****pecification-as-Code**
    (**SaC**)). There is less chance that your specification becomes outdated, because
    if it does, the test would fail.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是代码的组成部分（即**规范即代码**（**SaC**））。规范变得过时的可能性较小，因为如果它确实如此，测试就会失败。
- en: Therefore, we can write our technical specifications as E2E tests, which then
    drives the TDD development process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将我们的技术规范编写为端到端测试，这随后推动TDD开发过程。
- en: Remember that it's very hard for a single developer to be able to conjure up
    an exhaustive list of scenarios and edge cases to test for; we are bound to miss
    some. That's why it is important that the tests and code are inspected by multiple
    people. This may involve writing the test descriptions as a pair or mob, putting
    in place a code review workflow involving developers both within and outside the
    project. Doing so maximizes the value of the tests and ensures that they cover
    the most relevant edge cases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，单个开发者很难能够想出一套详尽的场景和边缘情况来测试；我们注定会错过一些。这就是为什么测试和代码需要由多个人检查很重要。这可能涉及以对的形式编写测试描述，实施涉及项目内外开发者的代码审查工作流程。这样做最大化了测试的价值，并确保它们覆盖了最相关的边缘情况。
- en: Test-driven development
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: As soon as the first E2E test for our selected feature has been written, the
    TDD process can begin. We should now run the test, see it fail, implement the
    feature so it passes the test, and then refactor. Unit and integration tests should
    be written, where appropriate, to increase confidence in the code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为我们的选定功能编写了第一个端到端测试，就可以开始TDD过程。我们现在应该运行测试，看到它失败，实现功能使其通过测试，然后进行重构。在适当的情况下，应该编写单元和集成测试，以增加对代码的信心。
- en: Repeat this process for every test case until the current set of features has
    been fully implemented.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个测试用例重复此过程，直到当前功能集完全实现。
- en: Writing manual tests
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写手动测试
- en: As we are developing our feature, the product manager should also be defining
    manual tests. Manual tests are required because not all requirements can be automated,
    and some may require real user data (for example, usability testing). For example,
    part of the acceptance criteria may be that "95% of users are able to find the
    settings page within 5 seconds". In these scenarios, manual testing is required.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发功能时，产品经理也应该定义手动测试。需要手动测试，因为并非所有需求都可以自动化，有些可能需要真实用户数据（例如，可用性测试）。例如，验收标准的一部分可能是“95%的用户能在5秒内找到设置页面”。在这些情况下，需要进行手动测试。
- en: Although we cannot automate this process, we can formalize it in a structured
    way. Instead of writing down the requirements in a text document, we can use **test
    case management tools**, such as TestLink ([testlink.org](http://testlink.org/)),
    as well as proprietary alternatives, such as TestRail ([gurock.com/testrail/](http://www.gurock.com/testrail/)),
    qTest ([qasymphony.com/software-testing-tools/qtest-manager/](https://www.qasymphony.com/software-testing-tools/qtest-manager/)),
    Helix TCM ([perforce.com/products/helix-test-case-management](https://www.perforce.com/products/helix-test-case-management)),
    Hiptest ([hiptest.net](https://hiptest.net/)), PractiTest ([practitest.com](https://www.practitest.com/)),
    and many more. These test case management systems help you define, run, and record
    test cases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们无法自动化此过程，但我们可以用一种结构化的方式将其形式化。我们不是在文本文档中写下需求，而是可以使用**测试用例管理工具**，例如TestLink
    ([testlink.org](http://testlink.org/))，以及专有替代品，如TestRail ([gurock.com/testrail/](http://www.gurock.com/testrail/))、qTest
    ([qasymphony.com/software-testing-tools/qtest-manager/](https://www.qasymphony.com/software-testing-tools/qtest-manager/))、Helix
    TCM ([perforce.com/products/helix-test-case-management](https://www.perforce.com/products/helix-test-case-management))、Hiptest
    ([hiptest.net](https://hiptest.net/))、PractiTest ([practitest.com](https://www.practitest.com/))等。这些测试用例管理系统帮助您定义、运行和记录测试用例。
- en: Each test should contain a set of clear, unambiguous steps to follow. A group
    of testers, who, ideally, have no prior knowledge of the platform, would then
    be given the instructions, the expected results, and be asked whether the results obtained match
    the expected ones.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试都应该包含一组清晰、无歧义的步骤。一组测试人员，理想情况下，对该平台没有先前的了解，然后会被提供指令、预期结果，并询问是否获得的结果与预期相符。
- en: Exploratory testing
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索性测试
- en: Lastly, you may simply ask manual testers to poke around the application, or
    explore the API themselves, without being given any steps to follow. This is called **exploratory
    testing** and may be grouped under manual testing. The purpose of exploratory
    testing is to identify edge cases that were missed, identify unintuitive outcomes,
    or find bugs that may otherwise break the system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以简单地要求手动测试人员探索应用程序，或者自行探索API，而不需要给他们任何要遵循的步骤。这被称为**探索性测试**，可以归类于手动测试。探索性测试的目的是识别遗漏的边缘情况，识别不直观的结果，或者找到可能破坏系统的错误。
- en: Maintenance
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护
- en: 'Inevitably, all applications, no matter how well tested, will have bugs and
    areas of improvement. An essential part of any workflow is to allow users to report
    bugs, raise issues, and ask questions. As an extension to this, we also need a
    system to triage these issues, prioritizing them based on the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不可避免的是，所有应用程序，无论测试得多好，都会存在错误和改进的区域。任何工作流程的一个基本部分是允许用户报告错误、提出问题和提问。作为这一点的扩展，我们还需要一个系统来对这些问题进行分类，根据以下标准进行优先级排序：
- en: '**Impact**: How many users are impacted? How important are these users?'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**影响**：有多少用户受到影响？这些用户有多重要？'
- en: '**Ease**: How easy is it to fix?'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：修复这个问题有多容易？'
- en: '**Urgency**: How time-sensitive is this issue?'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧急程度**：这个问题的时间敏感性如何？'
- en: This can be done through platforms such as GitHub's issue trackers, Atlassian's
    JIRA, or similar software.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过GitHub的问题跟踪器、Atlassian的JIRA或类似软件等平台来完成。
- en: When a bug is reported, it should be reproduced and confirmed. Once confirmed,
    test cases that cover that scenario should be written to prevent regression in
    the future. For example, if the bug is that the `age` field is returned as a float,
    a test case should be written to test that the `age` field is always a positive
    integer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当有错误报告时，应该重现并确认。一旦确认，应该编写覆盖该场景的测试用例，以防止未来出现回归。例如，如果错误是`age`字段返回浮点数，则应该编写一个测试用例来测试`age`字段始终是正整数。
- en: Gathering requirements
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集需求
- en: Now that we understand the workflow, let's put it into practice!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了工作流程，让我们将其付诸实践！
- en: 'We begin by selecting a small portion of our application and defining its requirements.
    We picked the Create User feature because many other features depend on it. Specifically,
    the feature requires us to create an API endpoint, `/users`, that accepts `POST`
    requests, and stores the JSON payload of the request (representing the user) into
    a database. In addition, the following constraints should be applied:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择我们应用程序的一小部分，并定义其需求。我们选择了创建用户功能，因为许多其他功能都依赖于它。具体来说，该功能要求我们创建一个接受`POST`请求的API端点`/users`，并将请求的JSON负载（表示用户）存储到数据库中。此外，还应应用以下约束：
- en: The user payload must include the email address and password fields
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户负载必须包括电子邮件地址和密码字段
- en: The user payload may optionally provide a profile object; otherwise, an empty
    profile will be created for them
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户负载可以可选地提供一个配置文件对象；否则，将为他们创建一个空配置文件。
- en: Now that we have our requirements, let's write our specification as E2E tests,
    using a tool called *Cucumber*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了需求，让我们使用名为*Cucumber*的工具编写我们的规范作为端到端测试。
- en: Setting Up E2E tests with Cucumber
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cucumber设置端到端测试
- en: Cucumber is an automated test runner that executes tests written in a **Domain-Specific
    Language** (**DSL**) called *Gherkin*. Gherkin allows you to write tests in plain
    language, usually in a behavior-driven way, which can be read and understood by
    anyone, even if they are not technically-minded.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber是一个自动化测试执行器，它执行用称为*Gherkin*的**领域特定语言**（**DSL**）编写的测试。Gherkin允许你用普通语言编写测试，通常是以行为驱动的方式，这样任何人都可以阅读和理解，即使他们不是技术型的人。
- en: 'There are many Cucumber implementations for different languages and platforms,
    such as Ruby, Java, Python, C++, PHP, Groovy, Lua, Clojure, .NET and, of course,
    JavaScript. The JavaScript implementation is available as an npm package, so let''s
    add it to our project:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber有针对不同语言和平台的许多实现，例如Ruby、Java、Python、C++、PHP、Groovy、Lua、Clojure、.NET，当然还有JavaScript。JavaScript实现作为一个npm包可用，所以让我们将其添加到我们的项目中：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are now ready to write the specification for our first feature.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写我们第一个功能的规范了。
- en: Features, scenarios, and steps
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能、场景和步骤
- en: 'To use Cucumber, you''d first separate your platform into multiple **features**;
    then, within each feature, you''d define **scenarios** to test for. For us, we
    can take the "Create user" requirement as one feature, and start breaking it down
    into scenarios, starting with the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Cucumber，你首先将你的平台分成多个 **特性**；然后，在特性内部，你将定义用于测试的 **场景**。对我们来说，我们可以将“创建用户”需求作为一个特性，并开始将其分解为场景，从以下内容开始：
- en: If the client sends a `POST` request to `/users` with an empty payload, our
    API should respond with a `400 Bad Request` HTTP status code and a JSON object
    payload containing an appropriate error message
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端向 `/users` 发送一个空负载的 `POST` 请求，我们的 API 应该响应一个 `400 Bad Request` HTTP 状态码，并包含适当错误信息的
    JSON 对象负载。
- en: If the client sends a `POST` request to `/users` with a payload that is not
    JSON, our API should respond with a `415 Unsupported Media Type` HTTP status code
    and a JSON response payload containing an appropriate error message
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端向 `/users` 发送一个非 JSON 负载的 `POST` 请求，我们的 API 应该响应一个 `415 不支持媒体类型` HTTP 状态码，并包含适当错误信息的
    JSON 响应负载。
- en: If the client sends a `POST` request to `/users` with a malformed JSON payload,
    our API should respond with a `400 Bad Request` HTTP status code and a JSON response
    payload containing an appropriate error message
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端向 `/users` 发送一个格式错误的 JSON 负载的 `POST` 请求，我们的 API 应该响应一个 `400 Bad Request`
    HTTP 状态码，并包含适当错误信息的 JSON 响应负载。
- en: We will define more scenarios later, but let's focus on these three to get us
    started.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后定义更多场景，但让我们先关注这三个，以便我们开始。
- en: Each feature should be defined, using the Gherkin language, within its own `.feature` file.
    So, let's create one now.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特性都应该使用 Gherkin 语言在其自己的 `.feature` 文件中定义。所以，我们现在就创建一个。
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's translate the scenarios for our Create User feature into Gherkin.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的创建用户特性中的场景翻译成 Gherkin。
- en: Gherkin keywords
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gherkin 关键词
- en: 'In Gherkin, every non-empty line starts with a Gherkin **keyword** (although
    there are several common exceptions). We will go over the relevant keywords in
    more detail when we use them, but here''s a brief overview of each keyword and
    its uses:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gherkin 中，每行非空行都以一个 Gherkin **关键词** 开头（尽管有几个常见的例外）。当我们使用它们时，我们将更详细地介绍相关关键词，但以下是每个关键词及其用法的简要概述：
- en: '`Feature`: Specifies the name and description of the feature. A feature is
    just a way to group related scenarios together.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Feature`: 指定特性的名称和描述。特性只是将相关的场景分组在一起的一种方式。'
- en: '`Scenario`: Specifies the name and description of the scenario.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scenario`: 指定场景的名称和描述。'
- en: '`Given`, `When`, `Then`, `And`, `But`: Each scenario is made up of one or more
    **steps**, each corresponding to a JavaScript function that is to be executed
    by Cucumber. If, after executing all the steps, no errors were thrown, then the
    test is deemed to have passed. The five step keywords are equivalent; you should
    use the one that makes your test most readable.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Given`, `When`, `Then`, `And`, `But`: 每个场景由一个或多个 **步骤** 组成，每个步骤对应一个将由 Cucumber
    执行的 JavaScript 函数。如果在执行所有步骤后没有抛出错误，则测试被认为已通过。这五个步骤关键词是等效的；你应该使用使你的测试最易读的那个。'
- en: '`Background`: Allows you to set up a common environment to execute all your
    scenarios. This saves you from defining duplicate set-up steps for all scenarios.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Background`: 允许你设置一个公共环境来执行所有场景。这可以节省你为所有场景定义重复的设置步骤。'
- en: '`Scenario Outline`: Allows you to define a template for multiple scenarios
    that differ only in certain values. This prevents specifying many scenarios/steps
    that are very similar to each other.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scenario Outline`: 允许你为具有某些值差异的多个场景定义一个模板。这可以防止指定许多非常相似的场景/步骤。'
- en: '`Examples`: When using scenario outline, the `Examples` keyword allows you
    to specify values to plug into the scenario outline.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Examples`: 当使用场景概述时，`Examples` 关键词允许你指定要插入到场景概述中的值。'
- en: '`"""`: Allows you to use **doc strings** to specify multiline strings as parameters.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"""`: 允许你使用 **文档字符串** 来指定多行字符串作为参数。'
- en: '`|`: Allows you to specify more complex data tables as parameters.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|`: 允许你指定更复杂的数据表作为参数。'
- en: '`@`: Allows you to group related scenarios together using **tags**. After tagging
    scenarios, you can instruct Cucumber to execute only those with a certain tag,
    or, conversely, exclude tests with certain tags.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@`: 允许你使用 **标签** 将相关的场景分组在一起。在标记场景之后，你可以指示 Cucumber 仅执行具有特定标签的场景，或者相反，排除具有特定标签的测试。'
- en: '`#`: Allows you to specify comments, which will not be executed by Cucumber.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#`: 允许你指定注释，这些注释将由 Cucumber 跳过执行。'
- en: If you are using Visual Studio Code (VSCode), we recommend that you install
    the *Cucumber (Gherkin) Full Support* VSCode Extension ([github.com/alexkrechik/VSCucumberAutoComplete](https://github.com/alexkrechik/VSCucumberAutoComplete)),
    which provides syntax highlighting and snippet support.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Visual Studio Code (VSCode)，我们建议你安装名为*Cucumber (Gherkin) Full Support*的VSCode扩展（[github.com/alexkrechik/VSCucumberAutoComplete](https://github.com/alexkrechik/VSCucumberAutoComplete)），它提供语法高亮和代码片段支持。
- en: Specifying our feature
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定我们的特性
- en: 'So, let''s start defining our feature by adding a name and description to `spec/cucumber/features/users/create/main.feature`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过向`spec/cucumber/features/users/create/main.feature`添加一个名称和描述来开始定义我们的特性：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Writing our first scenario
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个场景
- en: Next, we'll write our first scenario and steps. As a reminder, the scenario
    is "If the client sends a `POST` request to `/users` with an empty payload, our
    API should respond with a `400 Bad Request` HTTP status code, and a JSON object
    payload containing an appropriate error message".
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写我们的第一个场景和步骤。作为提醒，场景是：“如果客户端向`/users`发送一个空的`POST`请求，我们的API应该响应一个`400
    Bad Request` HTTP状态码，并包含一个适当的错误信息的JSON对象负载”。
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have broken the scenario down into modular units called **steps** and prefixed
    them with the Gherkin keywords. Here, we've used the keywords `When`, `Then`, and `And`,
    although we could have used any of the five keywords; we chose these because it
    makes the specification more readable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将场景分解成称为**步骤**的模块化单元，并在其前面加上Gherkin关键字。在这里，我们使用了关键字`When`、`Then`和`And`，尽管我们可以使用任何五个关键字中的任何一个；我们选择这些是因为它使规范更易于阅读。
- en: 'Generally, you can group steps into three categories:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以将步骤分为三类：
- en: '**Setup**: Used to set up the environment in preparation for an action to be
    executed. Usually, you''d use the `Given` keyword to define setup steps.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**：用于在执行动作之前设置环境。通常，你会使用`Given`关键字来定义设置步骤。'
- en: '**Action**: Used to execute an action, which is usually the event we are testing
    for. You''d typically use the `When` keyword to define action steps.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：用于执行动作，这通常是我们要测试的事件。你通常会使用`When`关键字来定义动作步骤。'
- en: '**Assertions**: Used to assert whether the actual outcome of the action is
    the same as the expected outcome. Usually, you''d use the `Then` keyword to define
    assertion steps.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：用于断言动作的实际结果是否与预期结果相同。通常，你会使用`Then`关键字来定义断言步骤。'
- en: Furthermore, you can use the `And` and `But` keywords to chain multiple steps
    together and make the specification more readable. But, remember that all step
    keywords are functionally equivalent.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用`And`和`But`关键字将多个步骤链接在一起，使规范更易于阅读。但请记住，所有步骤关键字在功能上是等效的。
- en: Laying out our step definitions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局我们的步骤定义
- en: With the help of Gherkin, we now have our specification written in plain English.
    Next, let's try to use Cucumber to run our specification.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gherkin的帮助下，我们现在已经用纯英语编写了规范。接下来，让我们尝试使用Cucumber来运行我们的规范。
- en: 'By default, Cucumber will look for a directory called `features` in the project''s
    root directory and run the `.feature` files it finds inside. Since we have placed
    our `main.feature` file inside the `spec/cucumber/features` directory, we should
    pass this path to Cucumber:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Cucumber将在项目的根目录中查找名为`features`的目录，并运行它里面找到的`.feature`文件。由于我们将`main.feature`文件放置在`spec/cucumber/features`目录中，我们应该将此路径传递给Cucumber：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The test result informs us that our tests are undefined. This is because Cucumber
    is not clever enough to parse the plain text specification and figure out how
    to run these tests. We must link these steps to actual JavaScript code, which,
    in the context of Cucumber, are called **step definitions**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果告诉我们，我们的测试是未定义的。这是因为Cucumber还不够聪明，无法解析纯文本规范并找出如何运行这些测试。我们必须将这些步骤链接到实际的JavaScript代码，在Cucumber的上下文中，这些代码被称为**步骤定义**。
- en: 'Create a new directory called `steps` next to the `features` directory; here''s
    where we''ll define all our step definitions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`features`目录旁边创建一个名为`steps`的新目录；这是我们定义所有步骤定义的地方：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Defining steps inside their own directory helps us to mentally dissociate steps
    from being tied to any particular feature, and keep steps as modular as possible.
    Create an `index.js` file within the `steps` directory and add the following placeholder
    step definitions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们自己的目录中定义步骤有助于我们心理上将步骤与任何特定特性分离，并尽可能保持步骤的模块化。在`steps`目录中创建一个名为`index.js`的文件，并添加以下占位符步骤定义：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you have the ESLint extension installed on your editor, you may see ESLint
    complain about arrow functions and function names. Normally, these would be valid
    problems, but this is not the case in our test files. Therefore, we should override
    the default configuration and turn these rules off.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在你的编辑器上安装了ESLint扩展，你可能会看到ESLint对箭头函数和函数名提出抱怨。通常，这些问题是有效的，但在这个测试文件中并不是这样。因此，我们应该覆盖默认配置并关闭这些规则。
- en: 'Inside the `spec/` directory, create a new `.eslintrc.json` file, and paste
    in the following content:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spec/`目录内，创建一个新的`.eslintrc.json`文件，并粘贴以下内容：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will turn off the `func-names` and `prefer-arrow-callback` rules for all
    files inside the `spec/` directory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将关闭`spec/`目录内所有文件的`func-names`和`prefer-arrow-callback`规则。
- en: Each step definition consists of the step keyword method (`When`/`Then` and
    so on), which takes in two parameters. The first one is the **pattern**, which
    is a string that is used to match the text in the feature specification with the
    step definition. The second parameter is the **code function**, which is a function
    that is run for that step.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤定义由步骤关键字方法（`When`/`Then`等）组成，它接受两个参数。第一个参数是**模式**，它是一个字符串，用于将特性规范中的文本与步骤定义相匹配。第二个参数是**代码函数**，它是一个为该步骤运行的函数。
- en: In our example, when Cucumber gets to the `When the client creates a POST request
    to /users` step in our scenario, it will try to run the function associated with
    the `When('the client creates a POST request to /users')` step definition, because
    the pattern matches the step description.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，当Cucumber到达我们的场景中的`When the client creates a POST request to /users`步骤时，它会尝试运行与`When('the
    client creates a POST request to /users')`步骤定义相关联的函数，因为模式与步骤描述匹配。
- en: Running our scenarios
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的场景
- en: Before we implement the logic behind each step definition, let's make sure our
    setup is working. By default, Cucumber will look for step definitions inside a
    root-level `features/` directory; since we placed our definitions in a different
    directory, we must use the `--require` flag to tell Cucumber where to find them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现每个步骤定义背后的逻辑之前，让我们确保我们的设置是正常工作的。默认情况下，Cucumber会在根级别的`features/`目录内寻找步骤定义；由于我们将定义放在了不同的目录，我们必须使用`--require`标志告诉Cucumber在哪里找到它们。
- en: 'Run `npx cucumber-js spec/cucumber/features --require spec/cucumber/steps` to
    trigger the tests:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npx cucumber-js spec/cucumber/features --require spec/cucumber/steps`以触发测试：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It returns with a `SyntaxError: Unexpected token import` error. This is because
    we are not using Babel to transpile the code before running it, and so the `import` ES6
    keyword is not supported. This is where the `@babel/register` package is useful:
    it allows us to instruct Cucumber to use Babel as the compiler to process our
    step definitions before running them.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '它返回一个`SyntaxError: Unexpected token import`错误。这是因为我们没有在运行代码之前使用Babel进行代码转换，因此`import`
    ES6关键字不受支持。这就是`@babel/register`包有用的地方：它允许我们指示Cucumber在运行步骤定义之前使用Babel作为编译器来处理我们的步骤定义。'
- en: 'First, let''s install the `@babel/register` package as a development dependency:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将`@babel/register`包安装为开发依赖项：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we can run `cucumber-js` again with the `--require-module` flag and it
    should be **able to find and run our step definitions:**
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次使用带有`--require-module`标志的`cucumber-js`运行，它应该能够找到并运行我们的步骤定义：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Behind the scenes, Cucumber would first execute all the step definition functions
    (`When` and `Then`), register the code function, and associate it with the corresponding
    pattern. Then, it will parse and run the feature files, attempting to match the
    string with step definitions that it has registered.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Cucumber会首先执行所有的步骤定义函数（`When`和`Then`等），注册代码函数，并将其与相应的模式关联。然后，它将解析并运行特性文件，尝试将字符串与已注册的步骤定义相匹配。
- en: 'Here, the test result reads `pending` because we have not implemented the code
    function for each step definition, which we will do in the next section. But before
    that, let''s first formalize our E2E test command into an npm script, to save
    us all that typing:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，测试结果显示为`pending`，因为我们还没有为每个步骤定义实现代码函数，这将在下一节中完成。但在那之前，让我们首先将我们的端到端测试命令正式化为一个npm脚本，以节省我们所有的输入：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we have set up the infrastructure for running E2E tests, it''d be a perfect
    time to commit our code. First, let''s create the `dev` branch:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为运行端到端测试设置了基础设施，现在是时候提交我们的代码了。首先，让我们创建`dev`分支：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, check out the new feature branch, `create-user/main`, and commit our
    changes to the repository:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检查新的特性分支`create-user/main`，并将我们的更改提交到仓库：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Implementing step definitions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现步骤定义
- en: 'To test our API server, we would need to run the server itself and send HTTP
    requests to it. There are many ways to send requests in Node.js:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的 API 服务器，我们需要运行服务器本身并向其发送 HTTP 请求。在 Node.js 中发送请求有许多方法：
- en: Using the `request` method provided by Node's native `http` module.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node 的本地 `http` 模块提供的 `request` 方法。
- en: 'Using the new Fetch Web API syntax: `fetch` is an improvement on the traditional `XMLHttpRequest`
    used to make **AJAX** (**Asynchronous JavaScript And XML**) requests from the
    client. We can use polyfills, such as `isomorphic-fetch` ([https://www.npmjs.com/package/isomorphic-fetch](https://www.npmjs.com/package/isomorphic-fetch)),
    which will allow us to use the same syntax on the server.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的 Fetch Web API 语法：`fetch` 是对传统用于从客户端发起 **AJAX**（**Asynchronous JavaScript
    And XML**）请求的 `XMLHttpRequest` 的改进。我们可以使用 polyfills，例如 `isomorphic-fetch`（[https://www.npmjs.com/package/isomorphic-fetch](https://www.npmjs.com/package/isomorphic-fetch)），这将允许我们在服务器上使用相同的语法。
- en: Using a library, such as `request` ([https://www.npmjs.com/package/request](https://www.npmjs.com/package/request)), `superagent` ([npmjs.com/package/superagent](https://www.npmjs.com/package/superagent)), `axios` ([npmjs.com/package/axios](https://www.npmjs.com/package/axios)),
    and many more.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用库，例如 `request`（[https://www.npmjs.com/package/request](https://www.npmjs.com/package/request)）、`superagent`（[npmjs.com/package/superagent](https://www.npmjs.com/package/superagent)）、`axios`（[npmjs.com/package/axios](https://www.npmjs.com/package/axios)）以及更多。
- en: Using the native `http` module allows us to be as expressive as possible because
    it works at the lowest-level API layer; however, this also means the code is likely
    to be verbose. Using the Fetch API might provide a simpler syntax, but it will
    still have a lot of boilerplate code. For example, when we receive a response,
    we must explicitly tell our code how we want to parse it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地的 `http` 模块允许我们尽可能地进行表达，因为它在最低级别的 API 层面上工作；然而，这也意味着代码可能很冗长。使用 Fetch API
    可能会提供更简单的语法，但它仍然会有很多样板代码。例如，当我们收到响应时，我们必须明确告诉我们的代码我们希望如何解析它。
- en: 'For our use cases, using a library is probably the most appropriate. Libraries
    are more opinionated but they also save you from writing the same lines repeatedly;
    for example, response payloads are parsed automatically in most libraries. Of
    all the available libraries, I''ve found that `superagent` is the most suitable
    for our tests because it allows you to compose a request by chaining multiple
    steps together. To demonstrate, the following is the example given in `superagent`''s `README.md`
    file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，使用库可能是最合适的。库更具有意见导向，但它们也节省了你重复编写相同代码的时间；例如，在大多数库中，响应负载会自动解析。在所有可用的库中，我发现
    `superagent` 对于我们的测试是最合适的，因为它允许你通过链式多个步骤来组合请求。为了演示，以下是在 `superagent` 的 `README.md`
    文件中给出的示例：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This allows us to initiate a request object at the beginning, and each step
    in our scenario can simply modify that object to collectively compose the final
    request that we send to our test API server. Without further ado, let''s install
    `superagent`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在一开始就启动一个请求对象，并且我们场景中的每个步骤都可以简单地修改该对象，共同组成我们发送到测试 API 服务器的最终请求。现在，让我们不耽搁，安装
    `superagent`：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Calling our endpoint
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用我们的端点
- en: 'For the first call to our server, we have broken it down into three steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对服务器的第一次调用，我们将其分解为三个步骤：
- en: '`When the client creates a POST request to /users`'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`当客户端创建一个 POST 请求到 /users`'
- en: '`And attaches a generic empty payload`'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`附加一个通用的空负载`'
- en: '`And sends the request`'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`发送请求`'
- en: In the first step, we will create a new request object and save it as a file-scoped
    variable, making it available to be accessed by subsequent steps. In the second,
    we will attach an empty payload to the request; however, this is already the default
    behavior of `superagent`, so we can simply `return` from the function without
    doing anything. In the third step, we will send the request and save the response
    in another variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们将创建一个新的请求对象并将其保存为一个文件作用域的变量，使其在后续步骤中可访问。在第二步中，我们将向请求附加一个空的负载；然而，这已经是
    `superagent` 的默认行为，因此我们可以简单地从函数中 `return` 而不进行任何操作。在第三步中，我们将发送请求并将响应保存到另一个变量中。
- en: 'You should now update the start of your `spec/cucumber/steps/index.js` file
    to the following snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该将 `spec/cucumber/steps/index.js` 文件的开头更新为以下片段：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our third step definition involves sending a request to the server and waiting
    for a response; this is an asynchronous operation. To ensure the next step won't
    run before this asynchronous operation is complete, we can pass a `callback` function
    into the code function as its last parameter. Cucumber will wait for the `callback`
    function to be called before moving on to the next step. Here, we are executing
    the `callback` only after the result has been returned and we have saved it to
    the `result` variable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个步骤定义涉及向服务器发送请求并等待响应；这是一个异步操作。为了确保在异步操作完成之前不会运行下一个步骤，我们可以将一个`callback`函数传递给代码函数作为最后一个参数。Cucumber将在`callback`函数被调用之前等待，然后继续到下一个步骤。在这里，我们只在结果返回并将它保存到`result`变量之后执行`callback`。
- en: Now, when we run our E2E tests again, the first three steps should pass.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行我们的端到端测试时，前三个步骤应该通过。
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Asserting results
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言结果
- en: 'Now, let''s move on to our next step definition, which is an assertion step.
    In there, we should assert that the response from our server should have a `400`
    HTTP status code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到我们的下一个步骤定义，这是一个断言步骤。在那里，我们应该断言来自我们服务器的响应应该有一个`400` HTTP状态码：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, with our API server running in the background, run our E2E tests again.
    You should see the result of the second step changing from `pending` to `failed`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们的API服务器在后台运行，再次运行我们的端到端测试。你应该看到第二步的结果从`pending`变为`failed`：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It fails because our API is currently always returning the `Hello World` string with
    the HTTP status code of `200`, regardless of what the request is. But this is
    nothing to be concerned about! Writing a failing test is the first step of the
    TDD workflow; now, we just need to write the minimum amount to code to make the
    test pass.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败了，因为我们的API目前总是返回带有HTTP状态码`200`的`Hello World`字符串，无论请求是什么。但这没有什么好担心的！编写失败的测试是TDD工作流程的第一步；现在，我们只需要编写足够的代码来使测试通过。
- en: To make our fourth step pass, we must check the method and path of the `req`
    object in the `requestHandler` function, and if it matches `POST` and `/users`,
    respectively, we will send back a `400` response.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的第四步通过，我们必须检查`requestHandler`函数中`req`对象的方法和路径，如果分别匹配`POST`和`/users`，我们将返回一个`400`响应。
- en: But how do we know the structure of the `req` object? We can use `console.log` to
    print it onto the console, but the structure of objects such as `req` and `res` are
    complex and the output is going to be hard to read. Instead, we should use a debugger.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道`req`对象的结构呢？我们可以使用`console.log`将其打印到控制台，但`req`和`res`等对象的结构复杂，输出将难以阅读。相反，我们应该使用调试器。
- en: Using a debugger for Node.js debugging
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试器进行Node.js调试
- en: A **debugger** is a tool that allows us to pause the execution of the code at
    certain **breakpoints** and examine any variables that are accessible within that
    scope at the time. For us, we want to pause the execution inside our server's `requestHandler` method
    to enable us to examine the `req` object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试器**是一种工具，它允许我们在特定的**断点**处暂停代码的执行，并检查在那个范围内可访问的任何变量。对我们来说，我们希望在服务器的`requestHandler`方法内部暂停执行，以便我们能够检查`req`对象。'
- en: Using Chrome DevTools
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Chrome DevTools
- en: 'All modern browsers have a debugger built into them. Firefox has Firebug and
    Chrome has Chrome DevTools:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代浏览器都内置了调试器。Firefox有Firebug，Chrome有Chrome DevTools：
- en: '![](img/472b461f-84d2-47e8-9586-bfe4b2a0c3fa.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/472b461f-84d2-47e8-9586-bfe4b2a0c3fa.png)'
- en: The debugger in Chrome is available under the Sources tab of Chrome DevTools.
    We've set a breakpoint on line 3 and our script has paused there. While it is
    paused, we can access variables within the scope, which include local and global
    scope, as well as scope available due to closures. It also lists out all our breakpoints
    so we can activate/deactivate them easily.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome中的调试器位于Chrome DevTools的“源”选项卡下。我们在第3行设置了一个断点，我们的脚本在那里暂停。在暂停时，我们可以访问作用域内的变量，包括局部和全局作用域，以及由于闭包而可用的作用域。它还列出了我们所有的断点，这样我们就可以轻松地激活/停用它们。
- en: To use Chrome DevTools for Node.js debugging, simply pass in the `--inspect` flag
    when you run `node`, then navigate to `chrome://inspect/#devices` in Chrome, and
    click on the Open dedicated DevTools for Node link, which will open the debugger
    in a new window.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Chrome DevTools进行Node.js调试，只需在运行`node`时传递`--inspect`标志，然后在Chrome中导航到`chrome://inspect/#devices`，并点击打开Node的专用DevTools链接，这将在一个新窗口中打开调试器。
- en: Using ndb
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ndb
- en: On July 22, 2018, Google released **ndb** ([https://github.com/GoogleChromeLabs/ndb](https://github.com/GoogleChromeLabs/ndb)),
    an "improved" debugger that is based on Chrome DevTools, and uses **Puppeteer** ([github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer))
    to interact with **Chromium** over the **DevTools Protocol**. It requires at least
    Node.js v8.0.0.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 2018 年 7 月 22 日，Google 发布了 **ndb** ([https://github.com/GoogleChromeLabs/ndb](https://github.com/GoogleChromeLabs/ndb))，这是一个基于
    Chrome DevTools 的“改进”调试器，并使用 **Puppeteer** ([github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer))
    通过 **DevTools Protocol** 与 **Chromium** 交互。它至少需要 Node.js v8.0.0。
- en: 'You can try it out by installing it locally:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过本地安装来尝试它：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On Windows, you may also have to install the `windows-build-tools` package
    in order to compile native dependencies:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可能还必须安装 `windows-build-tools` 包以编译原生依赖项：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, you can run the `ndb` binary with `npx`, and a new window will pop up:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `npx` 运行 `ndb` 二进制文件，并将弹出一个新窗口：
- en: '![](img/1480d634-dec7-4990-86a7-2783e9c88abc.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1480d634-dec7-4990-86a7-2783e9c88abc.png)'
- en: ndb comes with its own integrated terminal, which will hook onto any node processes
    that you run from it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ndb 内置了自己的集成终端，它将连接到你从它运行的任何 node 进程。
- en: While using Chrome DevTools and/or ndb provides several unique benefits, such
    as the availability of the Console, Memory, and Profile tabs, I'd still recommend
    using the debugger that comes with your IDE or code editor, simply because there's
    less context switching that comes with switching between different tools.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 Chrome DevTools 和/或 ndb 提供了几个独特的优势，例如控制台、内存和配置文件标签页的可用性，但我仍然建议使用你 IDE 或代码编辑器自带的调试器，仅仅是因为在切换不同工具时，上下文切换更少。
- en: I recommend using Visual Studio Code as a code editor for JavaScript projects,
    and thus we will use the VSCode editor to illustrate our workflow; you are, however,
    free to use the IDE or editor of your choice.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用 Visual Studio Code 作为 JavaScript 项目的代码编辑器，因此我们将使用 VSCode 编辑器来展示我们的工作流程；然而，你仍然可以自由使用你选择的
    IDE 或编辑器。
- en: Using the Visual Studio Code debugger
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 调试器
- en: Open up `src/index.js` on VSCode. If you hover your mouse to the left of the
    line numbers, you'll see some small, dimmed, red circles appear; you can click
    on the circle to insert a breakpoint on that line. This means whenever the script
    is executing and reaches that line, it will pause there. This allows us to examine
    the variables available within scope at that point. Go ahead and set the breakpoint
    at line 5.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VSCode 中打开 `src/index.js`。如果你将鼠标悬停在行号左侧，你会看到一些小的、暗淡的红色圆圈出现；你可以点击圆圈在该行设置断点。这意味着每当脚本执行并到达该行时，它将暂停在那里。这允许我们检查在那个点作用域内可用的变量。请设置第
    5 行的断点。
- en: 'You may also use the `debugger` statement, which has exactly the same effect
    as setting a breakpoint. The only difference is that the `debugger` statement
    would now be part of the code, which is usually not what you want:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `debugger` 语句，它具有与设置断点完全相同的效果。唯一的区别是，`debugger` 语句现在将是代码的一部分，这通常不是你想要的：
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After you''ve set the breakpoint, go to the Debugger tab in your editor. Click
    the Start Debugging button (usually this looks like the "Play" button: ►); this
    will execute the current file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置断点后，转到你的编辑器中的调试器标签页。点击开始调试按钮（通常看起来像“播放”按钮：►）；这将执行当前文件：
- en: '![](img/dc4f4b1e-7457-423f-b222-1200442e21ff.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc4f4b1e-7457-423f-b222-1200442e21ff.png)'
- en: 'The debugger throws an error because it doesn''t recognize the ES6 modules'' `import`
    syntax. This is because we are running the debugger on the source file directly,
    instead of the compiled file produced by Babel. To instruct VSCode to process
    modules, we can do one of two things:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器抛出错误，因为它不识别 ES6 模块的 `import` 语法。这是因为我们直接在源文件上运行调试器，而不是在 Babel 生成的编译文件上。要指示
    VSCode 处理模块，我们可以做以下两件事之一：
- en: Install the `@babel/node` package and instruct VSCode to execute our file using
    `babel-node`.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 `@babel/node` 包，并指示 VSCode 使用 `babel-node` 执行我们的文件。
- en: Instruct VSCode to add the `--experimental-modules` flag when running Node.
    This has been supported since Node v8.5.0.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示 VSCode 在运行 Node 时添加 `--experimental-modules` 标志。这自 Node v8.5.0 版本以来已被支持。
- en: 'To do either of these, we need to add configurations to the VSCode debugger.
    Configurations in VSCode are defined as JSON objects inside a `launch.json` file.
    To edit the `launch.json` file, click the cogwheel button (![](img/f64144d2-6235-4f3c-a734-7c1a938ab8c3.png))
    near the top. Then, paste in the following JSON object, which will provide us
    with both configurations mentioned before, as well as an option to run the program
    as normal:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这些操作中的任何一个，我们需要向 VSCode 调试器添加配置。VSCode 中的配置定义为 `launch.json` 文件内的 JSON 对象。要编辑
    `launch.json` 文件，点击顶部附近的齿轮按钮 (![](img/f64144d2-6235-4f3c-a734-7c1a938ab8c3.png))。然后，粘贴以下
    JSON 对象，它将为我们提供之前提到的所有配置，以及一个以正常方式运行程序的选择：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, also remember to install the `@babel/node` package as a development dependency:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，也请记得将 `@babel/node` 包作为开发依赖项安装：
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Retaining line numbers
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留行号
- en: To use `babel-node` with the VSCode debugger, we also need to enable the `retainLines`
    option in Babel, which retains the line numbers between the source code and the
    built files. If we don't do this, VSCode's debugger would set the breakpoints
    at the incorrect lines.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `babel-node` 与 VSCode 调试器一起使用，我们还需要在 Babel 中启用 `retainLines` 选项，以保留源代码和构建文件之间的行号。如果我们不这样做，VSCode
    的调试器会在错误的行设置断点。
- en: 'However, we only want to retain lines when debugging our code; when we are
    building our application, we want it to be formatted sensibly. To do this, we
    can update our `.babelrc` to apply the `retainLines` option only when the `BABEL_ENV`
    environment variable is set to `"debug"`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们只想在调试代码时保留行号；当我们构建应用程序时，我们希望它有合理的格式。为此，我们可以更新我们的 `.babelrc`，以便仅在 `BABEL_ENV`
    环境变量设置为 `"debug"` 时应用 `retainLines` 选项：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, open up the `launch.json` file again and add the following to the Babel
    Node configuration:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次打开 `launch.json` 文件，并将以下内容添加到 Babel Node 配置中：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Examining the req object
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 req 对象
- en: 'Now, stop your API server (if you''re running it), go back to `src/index.js`,
    open up the Debug panel, select one of the two configurations we just defined,
    and click the Start Debugging button (►). This time, you should see it succeed:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，停止你的 API 服务器（如果你正在运行它），回到 `src/index.js`，打开调试面板，选择我们刚才定义的两个配置之一，然后点击开始调试按钮（►）。这次，你应该看到它成功：
- en: '![](img/7091a724-8d80-4836-8cec-adfb401137c6.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7091a724-8d80-4836-8cec-adfb401137c6.png)'
- en: If you do not see the configuration in the dropdown, try closing and restarting
    Visual Studio Code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在下拉菜单中看不到配置，请尝试关闭并重新启动 Visual Studio Code。
- en: In a new tab, navigate to `localhost:8080`. This time, you won't see our `Hello,
    World!` text; this is because our server hasn't provided a response yet! Instead,
    it has paused at the breakpoint we set.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新标签页中，导航到 `localhost:8080`。这次，你不会看到我们的 `Hello, World!` 文本；这是因为我们的服务器还没有提供响应！相反，它已经暂停在我们设置的断点处。
- en: 'On the left-hand side, we can see a tab called VARIABLES, and here we can see
    all the local, closure, and global variables available at our breakpoint. When
    we expand the `req` variable, we''ll find the `method` and `url` properties, which
    are exactly what we need:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们可以看到一个名为 VARIABLES 的标签页，在这里我们可以看到所有在断点处可用的本地、闭包和全局变量。当我们展开 `req` 变量时，我们会找到
    `method` 和 `url` 属性，这正是我们所需要的：
- en: '![](img/eb54222b-1e55-4329-9bb8-dd69941134eb.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb54222b-1e55-4329-9bb8-dd69941134eb.png)'
- en: I'd encourage you to spend a few minutes exploring the structure of the `req` and `res` objects.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你花几分钟时间探索 `req` 和 `res` 对象的结构。
- en: We've added several VSCode debugger configurations and should commit these changes
    to our Git repository. The VSCode configurations are, however, not part of our
    Create User feature, and should be committed directly to the `dev` branch.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了几个 VSCode 调试器配置，并且应该将这些更改提交到我们的 Git 仓库。然而，VSCode 配置并不是我们创建用户功能的组成部分，应该直接提交到
    `dev` 分支。
- en: Making work-in-progress (WIP) commits
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作工作进行中（WIP）提交
- en: However, we have already made some changes related to our Create User feature,
    and we can't check out the `dev` branch unless we `git commit` or `git stash`
    these changes. Ideally, we should commit the entire Create User feature together;
    it is not clean to have **work-in-progress** (**WIP**) **commits** in our Git
    history tree.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们已经对创建用户功能做了一些更改，除非我们 `git commit` 或 `git stash` 这些更改，否则我们无法检出 `dev` 分支。理想情况下，我们应该将整个创建用户功能一起提交；在我们的
    Git 历史树中保留 **工作进行中**（**WIP**）的提交是不干净的。
- en: To resolve this dilemma, we can use `git stash`, but it can be quite confusing
    and you risk losing your work. Instead, we are going to commit the WIP changes
    now and amend the commit later with the full implementation. We can do this because
    we are working on our local feature branch, not one of the permanent `dev` or
    `master` branches. This means that as long we do not push our changes onto the
    remote repository, no one else will know about the WIP commit.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个困境，我们可以使用 `git stash`，但这可能会相当令人困惑，并且你可能会丢失你的工作。相反，我们现在将提交 WIP 变更，稍后用完整的实现来修正提交。我们可以这样做，因为我们正在本地功能分支上工作，而不是永久的
    `dev` 或 `master` 分支之一。这意味着只要我们不将我们的变更推送到远程仓库，其他人就不会知道关于 WIP 提交的事情。
- en: 'The workflow will be as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程将如下所示：
- en: '`git commit` our WIP changes related to our Create User feature on the `create-user/main`
    branch.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `create-user/main` 分支上，将我们与创建用户功能相关的 WIP 变更 `git commit`。
- en: '`git checkout` the `dev` branch.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`git checkout` 到 `dev` 分支。'
- en: Add the `@babel/node` package once again.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次添加 `@babel/node` 包。
- en: '`git commit` the VSCode debugger configuration changes onto the `dev` branch.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 VSCode 调试器配置变更 `git commit` 到 `dev` 分支。
- en: '`git checkout` the `create-user/main` branch.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`git checkout` 到 `create-user/main` 分支。'
- en: '`git rebase` the `create-user/main` branch onto the `dev` branch.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `create-user/main` 分支 `git rebase` 到 `dev` 分支。
- en: Continue to work on the feature.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续工作在该功能上。
- en: Run `git add` and `git commit --amend` to commit our implementation code in
    the existing commit.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `git add` 和 `git commit --amend` 以在现有提交中提交我们的实现代码。
- en: Run `yarn install` to make sure all the packages are linked, especially those
    that are present in the `create-user/main` branch but not the `dev` branch.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `yarn install` 以确保所有包都已链接，特别是那些存在于 `create-user/main` 分支但不在 `dev` 分支中的包。
- en: 'Following that workflow, we should execute the following commands:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 按照该工作流程，我们应该执行以下命令：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Asserting the correct response status code
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言正确的响应状态码
- en: Now that we understand how to use the debugger to examine the structure of complex
    objects, we are ready to implement the logic to check for the status of the response.
    To make our second test pass, we must send back a response with a `400` HTTP status
    code. With TDD, we should write the minimum amount of code that is required to
    make the test pass. Once the test passes, we can then spend some time refactoring
    the code to make it more elegant.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用调试器检查复杂对象的结构，我们准备实现检查响应状态的逻辑。为了使第二个测试通过，我们必须返回一个带有 `400` HTTP 状态码的响应。使用
    TDD，我们应该编写最少的代码来使测试通过。一旦测试通过，我们就可以花一些时间重构代码，使其更加优雅。
- en: 'The most straightforward piece of logic to make the test pass is to simply
    check that the `req` object''s `method` and `url` match exactly with `''POST''`
    and `''/users''`, and return with a `400` HTTP status code specifically for this
    scenario. If they do not match, send back the `Hello World!` response as before.
    After making the change, the `requestHandler` function should look something like
    this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使测试通过的最直接逻辑是简单地检查 `req` 对象的 `method` 和 `url` 是否与 `'POST'` 和 `'/users'` 完全匹配，并针对此场景返回特定的
    `400` HTTP 状态码。如果不匹配，则像以前一样返回 `Hello World!` 响应。在做出更改后，`requestHandler` 函数应该看起来像这样：
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, restart our API server and run the E2E tests; the first four steps should
    now pass.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动我们的 API 服务器并运行端到端测试；前四个步骤现在应该通过了。
- en: You ain't gonna need it (YAGNI)
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你不需要它（YAGNI）
- en: Note that the previous logic will indiscriminately return a `400` response,
    even if the payload is not empty. This is fine because the TDD process encourages
    you to write the minimum amount of code possible to make the tests pass, and so
    far we have only written a test for the empty payload scenario.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前的逻辑将无差别地返回 `400` 响应，即使有效负载不为空。这是可以的，因为 TDD 流程鼓励你编写尽可能少的代码来使测试通过，到目前为止，我们只为空有效负载场景编写了一个测试。
- en: The rationale behind this is to ensure you are not falling into the trap of
    coding something that you don't need. This principle has been summarized in the
    phrase *"You ain't gonna need it,"* or **YAGNI**, which is a principle that originated
    from **extreme programming** (**XP**). The original states that you should "always
    implement things when you actually need them, never when you just foresee that
    you need them". You may have also heard the phrase *"do the simplest thing that
    could possibly work"* (**DTSTTCPW**).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个背后的理由是确保你没有陷入编写不需要的代码的陷阱。这个原则被总结为短语“你不需要它”，或**YAGNI**，这是一个起源于**极限编程**（**XP**）的原则。它最初的状态是“当你真正需要的时候才实现事物，永远不要只是预见你需要它们”。你可能也听说过短语“做最简单的事情，让它尽可能工作”（**DTSTTCPW**）。
- en: 'Being disciplined and sticking to this principle yields several benefits:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 严谨并坚持这个原则会带来几个好处：
- en: '**It ensures you follow TDD**: The tests are written before the code is.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它确保你遵循TDD**：测试是在代码之前编写的。'
- en: '**It saves you time**: If we preempt a feature and implement it before it is
    needed, it may turn out that the feature was not needed after all, or the feature
    has changed from what you had in mind when you implemented it, or other parts
    of the code have changed and you''d need to revise your original implementation.
    In any case, you would have spent time on something that is not useful.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它能节省你的时间**：如果我们提前实现一个特性，在它被需要之前，可能最终发现这个特性根本不需要，或者特性已经从你实现它时的想法发生了变化，或者代码的其他部分已经改变，你需要修改你的原始实现。无论如何，你都会在无用的东西上浪费时间。'
- en: Even when you "know" for sure, make it a habit to follow the YAGNI principle.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你“确信”无误，也要养成遵循YAGNI原则的习惯。
- en: Asserting the correct response payload
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言正确的响应有效载荷
- en: 'The next test requires that the payload is a JSON object. Since our server
    is replying with a JSON object, the `Content-Type` header should also reflect
    this. Therefore, in our step definition, we should check for both of these criteria.
    In the `spec/cucumber/steps/index.js`, update the step definition to the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试要求有效载荷是一个JSON对象。由于我们的服务器正在以JSON对象的形式回复，`Content-Type`头也应该反映这一点。因此，在我们的步骤定义中，我们应该检查这两个标准。在`spec/cucumber/steps/index.js`中更新步骤定义如下：
- en: '[PRE29]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, restart our API server and we run the tests again; we should get a failing
    test:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重启我们的API服务器并再次运行测试；我们应该得到一个失败的测试：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Red. Green. Refactor. Now we have a failing test (red), the next step is to
    make it pass (green). To do this, we must set the `Content-Type` header to `application/json`
    and provide a JSON object in the payload. Change our `requestHandler` function
    to the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 红色。绿色。重构。现在我们有一个失败的测试（红色），下一步是让它通过（绿色）。要做到这一点，我们必须将`Content-Type`头设置为`application/json`并在有效载荷中提供一个JSON对象。将我们的`requestHandler`函数更改为以下内容：
- en: '[PRE31]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the tests again, and the first five tests should have passed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，前五个测试应该已经通过。
- en: Asserting the correct response payload content
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言正确的响应有效载荷内容
- en: 'Now, on to our last test. We need our error object payload to contain a `message`
    property that reads `"Payload should not be empty"`. So first, let''s implement
    our test:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续到最后一个测试。我们需要我们的错误对象有效载荷包含一个读取为`"Payload should not be empty"`的`message`属性。所以首先，让我们实现我们的测试：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, run the tests again and they should fail. Then, to make it pass, we need
    to pass a different object into the `res.end` method. Your `if` block should now
    look like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，再次运行测试，它们应该失败。然后，为了让它通过，我们需要将一个不同的对象传递给`res.end`方法。你的`if`块现在应该看起来像这样：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, when we run our E2E tests again, they all pass:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行我们的端到端测试时，它们都应该通过：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Refactoring
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: 'Remember that the TDD process can be summed up with the phrase "Red. Green.
    Refactor". Here, we''ve written failing tests (red) and we''ve written some code
    to make them pass (green); therefore, the next step is to refactor, which, as
    a reminder, means restructuring and improving the quality of our implementation
    without changing its external behavior. This can mean the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，TDD过程可以用短语“红色。绿色。重构”来总结。在这里，我们编写了失败的测试（红色）并编写了一些代码来使它们通过（绿色）；因此，下一步是重构，提醒一下，这意味着重构和改进实现的质量，而不改变其外部行为。这可能意味着以下内容：
- en: Reducing duplicated code (keeping things DRY)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少重复代码（保持DRY）
- en: Improving readability
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高可读性
- en: Making our code more modular
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的代码更模块化
- en: Reducing cyclomatic complexity, probably by breaking larger functions into smaller
    ones
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少循环复杂度，可能通过将较大的函数分解成较小的函数
- en: Refactoring should be done for our entire code base, which includes both the
    test code and our application code. Here, however, our application code is already
    quite neat and there are no obvious areas we can improve on at this time. Therefore,
    we can focus on improving our test code.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 应该对我们的整个代码库进行重构，这包括测试代码和我们的应用程序代码。然而，我们的应用程序代码已经很整洁，目前没有明显的改进区域。因此，我们可以专注于改进我们的测试代码。
- en: Isolating contexts for each scenario
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为每个场景隔离上下文
- en: At the moment, we are storing the `request`, `result`, `error`, and `payload` variables
    at the top level of the file's scope.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在将`request`、`result`、`error`和`payload`变量存储在文件作用域的最高级别。
- en: But step definitions can be mixed and matched in different scenarios. For example,
    in another scenario where we are updating a specific user, we may want to test
    that the API returns with the correct status code when given a malformed request.
    Here, we can reuse the same step definition, `"our API should respond with a 400
    HTTP status code"`, but this time, the `error` variable may not be set if the
    previous steps were defined in a different file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但步骤定义可以在不同的场景中混合使用。例如，在另一个场景中，我们正在更新特定的用户，我们可能想测试当给出一个格式不正确的请求时，API是否返回正确的状态码。在这里，我们可以重用相同的步骤定义，`"我们的API应该响应400
    HTTP状态码"`，但这次，如果之前的步骤定义在不同的文件中，`error`变量可能不会被设置。
- en: Instead of using file-scoped variables, we can instead pass a context object
    into each step and use it to keep track of the results. This context object would
    be maintained throughout the entire scenario and be available in every step. In
    the vocabulary of Cucumber, an isolated context for each scenario is called a **world**.
    The context object is exposed inside each step as the `this` object.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用文件作用域变量，我们可以将上下文对象传递给每个步骤，并使用它来跟踪结果。这个上下文对象将贯穿整个场景，并在每个步骤中可用。在Cucumber的术语中，每个场景的独立上下文被称为**世界**。上下文对象作为每个步骤中的`this`对象暴露出来。
- en: '*Within* the step definition''s code function, make sure you''re using arrow
    functions, which automatically bind `this`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*在*步骤定义的代码函数内部，确保你使用箭头函数，这会自动绑定`this`。'
- en: 'Therefore, we can assign the response (regardless of it being a success or
    an error) to the more generically-named `this.response` and do the same for all
    other top-level file-scoped variables. After these changes, we should end up with
    the following `spec/cucumber/steps/index.js` file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将响应（无论它是成功还是错误）分配给更具通用名称的`this.response`，并对所有其他顶级文件作用域变量做同样的处理。经过这些更改后，我们应该得到以下`spec/cucumber/steps/index.js`文件：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we refactor, we must be careful not to change the behavior of the existing
    code. Therefore, run our tests again to make sure they are still passing:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重构时，我们必须小心不要改变现有代码的行为。因此，再次运行我们的测试以确保它们仍然通过：
- en: '[PRE36]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Making failure more informative
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使失败信息更加丰富
- en: 'At the moment, if one of the assertions fails, we''re throwing a generic `Error`
    object:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果其中一个断言失败，我们抛出一个通用的`Error`对象：
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When the test actually fails, the error message is not helpful because it doesn''t
    tell us what the actual result is:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试实际失败时，错误信息并不有帮助，因为它没有告诉我们实际的结果：
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can improve this by throwing an instance of `AssertionError` instead of just
    an instance of `Error`. `AssertionError` is a class provided by Node.js that allows
    you to specify the expected and actual outcomes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过抛出一个`AssertionError`实例而不是仅仅抛出一个`Error`实例来改进这一点。`AssertionError`是Node.js提供的一个类，允许你指定期望和实际的结果。
- en: 'To use it, first import it from the `assert` module:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，首先从`assert`模块中导入：
- en: '[PRE39]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, change our step definition to the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将我们的步骤定义更改为以下内容：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, when there''s an error, the error output is much more informative:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当出现错误时，错误输出信息更加丰富：
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, we can go one better and use the `equal` method from the `assert` module
    directly. Now, our step definition is much more concise:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以做得更好，直接使用`assert`模块中的`equal`方法。现在，我们的步骤定义更加简洁：
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`assert.equal` will automatically throw an `AssertionError` if the parameters
    passed into it are not equal.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert.equal`如果传入的参数不相等，将自动抛出一个`AssertionError`。'
- en: 'Now do the same for the step definition that checks for the response''s message:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在同样对检查响应消息的步骤定义进行相同的操作：
- en: '[PRE43]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Removing hardcoded values
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除硬编码的值
- en: Since we are only running these tests locally for now, we can simply hardcode
    the host name of our local API server, which we've set to `http://localhost:8080/`.
    However, it's never ideal to hardcode values into our code, as when we want to
    run these same tests on a different server, we'd have to edit the code itself.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在只是在本地上运行这些测试，我们可以简单地硬编码我们本地 API 服务器的主机名，我们将其设置为 `http://localhost:8080/`。然而，将值硬编码到我们的代码中永远不是最佳做法，因为当我们想在不同的服务器上运行这些相同的测试时，我们必须编辑代码本身。
- en: Instead, we can make use of environment variables, which we can set in an `.env` file at
    the project root directory and load it when we run our tests.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以利用环境变量，我们可以在项目根目录的 `.env` 文件中设置它们，并在运行测试时加载它们。
- en: 'Create a new `.env` file and add in the following entry:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `.env` 文件，并添加以下条目：
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we need to load the environment variable into our code. We can use the `dotenv-cli` package
    ([https://www.npmjs.com/package/dotenv-cli](https://www.npmjs.com/package/dotenv-cli))
    to do this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将环境变量加载到我们的代码中。我们可以使用 `dotenv-cli` 包 ([https://www.npmjs.com/package/dotenv-cli](https://www.npmjs.com/package/dotenv-cli))
    来完成这个任务：
- en: '[PRE45]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To use the `dotenv-cli` package, you simply place `dotenv` in front of the
    command you want to run, and it will load the variables from the `.env` file and
    then run the command:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `dotenv-cli` 包，你只需在你想运行的命令前加上 `dotenv`，它将从 `.env` 文件中加载变量，然后运行该命令：
- en: '[PRE46]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'So, let''s change our `serve` and `test:e2e` npm scripts to use the `dotenv-cli` package.
    Note that we are using a double dash (`--`) to pass the flags into `cucumber-js`
    after `dotenv` has finished loading the environment variables:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将我们的 `serve` 和 `test:e2e` npm 脚本更改为使用 `dotenv-cli` 包。请注意，我们在 `dotenv`
    加载完环境变量后，使用双横线 (`--`) 将标志传递给 `cucumber-js`：
- en: '[PRE47]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, in our code, remove the hardcoded hostname and replace it with the environment
    variable:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的代码中，删除硬编码的主机名，并用环境变量替换它：
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Again, we should run the tests to ensure they pass:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们应该运行测试以确保它们通过：
- en: '[PRE49]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Lastly, the point of using environment variables is that different environments
    would have different settings; therefore, we shouldn''t track the `.env` file
    in Git. However, we do want to keep a record of what environment variables are
    supported, and so we should copy our `.env` file into a new `.env.example` file
    and add that into our Git repository:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用环境变量的目的是不同的环境会有不同的设置；因此，我们不应该将 `.env` 文件跟踪到 Git 中。然而，我们确实想记录支持哪些环境变量，因此我们应该将我们的
    `.env` 文件复制到一个新的 `.env.example` 文件中，并将其添加到我们的 Git 仓库中：
- en: '[PRE50]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have now implemented a new feature that is functional for a single scenario;
    this is a good time to commit our code to the Git repository. Remember that we
    had previously made a WIP commit. So now, instead of running `git commit`, we
    should add an `--amend` flag, which will overwrite and replace our previous commit:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在实现了一个新的功能，它对单个场景是功能性的；这是一个将代码提交到 Git 仓库的好时机。记住我们之前已经做了一次 WIP 提交。所以现在，我们不应该运行
    `git commit`，而应该添加一个 `--amend` 标志，这将覆盖并替换我们之前的提交：
- en: '[PRE51]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Validating data type
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证数据类型
- en: 'We have completed our first scenario, so let''s move on to our second and third
    scenarios. As a reminder, they are as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了第一个场景，所以让我们继续我们的第二个和第三个场景。作为提醒，它们如下所示：
- en: If the client sends a `POST` request to `/users` with a payload that is not
    JSON, our API should respond with a `415 Unsupported Media Type` HTTP status code
    and a JSON object payload containing an appropriate error message.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端向 `/users` 发送一个非 JSON 有效负载的 `POST` 请求，我们的 API 应该返回一个 `415 Unsupported Media
    Type` HTTP 状态码，并包含一个适当的错误信息的 JSON 对象有效负载。
- en: If the client sends a `POST` request to `/users` with a malformed JSON payload,
    our API should respond with a `400 Bad Request` HTTP status code and a JSON response
    payload containing an appropriate error message.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端向 `/users` 发送一个包含格式错误的 JSON 有效负载的 `POST` 请求，我们的 API 应该返回一个 `400 Bad Request`
    HTTP 状态码，并包含一个适当的错误信息的 JSON 响应有效负载。
- en: 'Start by adding the following scenario definition to the `spec/cucumber/features/users/create/main.feature`
    file:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下场景定义添加到 `spec/cucumber/features/users/create/main.feature` 文件中：
- en: '[PRE52]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice that the first, third, and fifth steps are exactly the same as the ones
    in the previous scenario; therefore, Cucumber can re-use the step definition that
    we have already defined.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一步、第三步和第五步与上一个场景中的步骤完全相同；因此，Cucumber 可以重用我们已定义的步骤定义。
- en: 'For the rest of the steps, however, we need to implement their corresponding
    step definitions. But since they are similar to the ones we''ve just defined,
    we can copy and paste them and make some small adjustments. Copy the following
    step definitions into `spec/cucumber/steps/index.js`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩余的步骤，然而，我们需要实现它们对应的步骤定义。但由于它们与我们刚刚定义的步骤相似，我们可以复制并粘贴它们并进行一些小的调整。将以下步骤定义复制到
    `spec/cucumber/steps/index.js` 文件中：
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, when we run our tests again, the first three steps of the `Payload using
    Unsupported Media Type` scenario should pass:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行测试时，`Payload using Unsupported Media Type` 场景的前三个步骤应该通过：
- en: '[PRE54]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The fourth step fails because, in our code, we are not specifically handling
    cases where the payload is a non-JSON or malformed object. Therefore, we must
    add some additional logic to check the `Content-Type` header and the actual contents
    of the request payload, which is much more involved than indiscriminately returning
    a `400` response:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个步骤失败，因为在我们代码中，我们没有特别处理负载是非 JSON 或格式不正确的对象的情况。因此，我们必须添加一些额外的逻辑来检查 `Content-Type`
    标头和请求负载的实际内容，这比盲目返回 `400` 响应要复杂得多：
- en: '[PRE55]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For `POST` and `PUT` requests, the body payload can be quite large. So, instead
    of receiving the entire payload in one large chunk, it's better to consume it
    as a stream of smaller units. The request object, `req`, that is passed into the
    `requestHandler` function implements the `ReadableStream` interface. To extract
    the request body of `POST` and `PUT` requests, we must listen for the `data` and
    `end` events emitted from the stream.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `POST` 和 `PUT` 请求，请求体的负载可以相当大。因此，与其一次性接收整个负载的大块数据，不如将其作为更小的单元流式传输。传递给 `requestHandler`
    函数的请求对象 `req` 实现了 `ReadableStream` 接口。为了从 `POST` 和 `PUT` 请求中提取请求体，我们必须监听从流中发出的
    `data` 和 `end` 事件。
- en: Whenever a new piece of data is received by our server, the `data` event will
    be emitted. The parameter passed into the event listener for the `data` event
    is a type of `Buffer`, which is simply a small chunk of raw data. In our case,
    the `data` parameter represents a small chunk of our JSON request payload.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的服务器接收到新的数据时，将发出 `data` 事件。传递给 `data` 事件监听器的参数是 `Buffer` 类型，它只是原始数据的一个小块。在我们的情况下，`data`
    参数代表 JSON 请求负载的一小块。
- en: Then, when the stream has finished, the `end` event is emitted. It is here that
    we check whether the payload is empty, and if it is, we return a `400` error as
    we did before. But if it is not empty, we then check the `Content-Type` header
    to see if it is `application/json`; if not, we return a `415` error. Lastly, to
    check whether the JSON is well formed, we concatenate the buffer array to restore
    our original payload. Then, we try to parse the payload with `JSON.parse`. If
    the payload is able to be parsed, we don't do anything; if it is not, it means
    the payload is not valid JSON and we should return a `400` error, as specified
    in our step.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当流完成时，将发出 `end` 事件。正是在这里，我们检查负载是否为空，如果为空，则返回一个 `400` 错误，就像之前做的那样。但如果不是空的，我们接着检查
    `Content-Type` 标头，看它是否为 `application/json`；如果不是，我们返回一个 `415` 错误。最后，为了检查 JSON 是否格式正确，我们将缓冲区数组连接起来以恢复原始负载。然后，我们尝试使用
    `JSON.parse` 解析负载。如果负载可以被解析，我们不做任何事情；如果不能，这意味着负载不是有效的 JSON，我们应该返回一个 `400` 错误，正如我们在步骤中指定的那样。
- en: 'Lastly, we had to wrap the `JSON.parse()` call in a `try`/`catch` block because
    it''ll throw an error if the payload is not a JSON-serializable string:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将 `JSON.parse()` 调用包裹在 `try`/`catch` 块中，因为如果负载不是一个可序列化为 JSON 的字符串，它将抛出一个错误：
- en: '[PRE56]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We run the tests again; all tests should now pass, with one exception: somehow,
    the step `And contains a message property which says ''The "Content-Type" header
    must always be "application/json"''` is said to be undefined. But if we check
    our step definitions, we can certainly see it *is* defined. So what''s happening?'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行测试；现在所有测试都应该通过，只有一个例外：步骤 `And contains a message property which says 'The
    "Content-Type" header must always be "application/json"'` 被说成是未定义的。但如果我们检查我们的步骤定义，我们肯定可以看到它确实是定义过的。那么发生了什么？
- en: This is because the forward slash character (`/`) has a special meaning in Gherkin.
    It specifies **alternative text**, which allows you to match *either* of the strings
    adjacent to the slash.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为正斜杠字符 (`/`) 在 Gherkin 中有特殊含义。它指定 **替代文本**，这允许你匹配斜杠两侧的任意一个字符串。
- en: 'For example, the step definition pattern `the client sends a GET/POST request`
    would match both of the following steps:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，步骤定义模式 `客户端发送一个 GET/POST 请求` 将匹配以下两个步骤：
- en: '`` `the client sends a GET request` ``'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `客户端发送一个 GET 请求` ``'
- en: '`the client sends a POST request`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`客户端发送一个POST请求`'
- en: 'Unfortunately, there is no way to escape the alternative text character. Instead,
    we must employ regular expressions to match this step definition pattern to its
    steps. This is as simple as replacing the containing single quotes with `/^` and
    `$/,` and escaping the forward slash:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有方法可以转义替代文本字符。相反，我们必须使用正则表达式来匹配此步骤定义模式到其步骤。这就像将包含的单引号替换为`/^`和`$/,`，并转义正斜杠一样：
- en: '[PRE57]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, all our tests should pass:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们所有的测试都应该通过：
- en: '[PRE58]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For consistency's sake, replace all other string patterns with regular expressions;
    run the tests again to ensure they're still passing.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，将所有其他字符串模式替换为正则表达式；再次运行测试以确保它们仍然通过。
- en: Refactoring our tests
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构我们的测试
- en: Red. Green. Refactor. We again find ourselves at the "green" phase; therefore,
    the next step is to refactor. We are going to start with our test code first.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 红色。绿色。重构。我们又回到了“绿色”阶段；因此，下一步是重构。我们将首先从测试代码开始。
- en: Using scenario outlines
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用场景概述
- en: 'In our second scenario, we have three steps that are very similar to the steps
    defined for our first scenario. So far, we have simply been copying and pasting
    those step definitions and making small changes to them. Repetition or duplication
    is never good when it comes to code; so instead, we can define a *scenario outline*,
    which acts as a template scenario with placeholder variables that we can plug
    in. For example, we can combine these two scenarios into a scenario outline as
    follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二个场景中，我们有三个步骤与我们的第一个场景中定义的步骤非常相似。到目前为止，我们只是简单地复制粘贴这些步骤定义并对它们进行一些小的修改。在代码方面，重复或复制从来都不是好事；因此，我们可以定义一个*场景概述*，它作为一个模板场景，包含可以插入的占位符变量。例如，我们可以将这两个场景组合成一个场景概述，如下所示：
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: First, we changed the keyword from `Scenario` to `Scenario Outline` and added
    placeholders (enclosed in `<>`). Then, we use the `Examples` keyword to supply
    these placeholders with actual values in the form of a **datatable**, which is
    simply columns of values separated by the pipe character (`|`). Now, our Cucumber
    specification is a lot less repetitive!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将关键字从`Scenario`更改为`Scenario Outline`并添加了占位符（用`<>`括起来）。然后，我们使用`Examples`关键字提供这些占位符的实际值，形式为一个**数据表**，它只是由竖线字符（`|`）分隔的值列。现在，我们的Cucumber规范重复性少了很多！
- en: After each refactoring step, we should take care to ensure that we didn't break
    anything. So run our tests again and check they still pass.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次重构步骤之后，我们应该注意确保我们没有破坏任何东西。所以再次运行我们的测试并检查它们是否仍然通过。
- en: Combining duplicate step definitions
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并重复的步骤定义
- en: In a similar vein, we can introduce **parameters** into our step definitions
    to help us avoid duplicated code. With string patterns, parameters can be specified
    using curly braces (`{}`), inside of which the type of the variable is indicated.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以在步骤定义中引入**参数**来帮助我们避免代码重复。对于字符串模式，参数可以使用花括号（`{}`）指定，其中指示变量的类型。
- en: 'For example, our `Then our API should respond with a <statusCode> HTTP status
    code` step definition can be redefined as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的`Then our API should respond with a <statusCode> HTTP status code`步骤定义可以重新定义为以下内容：
- en: '[PRE60]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we've replaced the hardcoded `400` HTTP status code with a placeholder,
    `{int}`, which indicates that the pattern should match an integer. Then, we are
    passing the value of the placeholder into the code function as `statusCode`, which
    is then used to perform the checks.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将硬编码的`400` HTTP状态码替换为一个占位符，`{int}`，这表示模式应该匹配一个整数。然后，我们将占位符的值传递给代码函数作为`statusCode`，然后用于执行检查。
- en: 'We can do the same with regular expression patterns. Instead of curly braces,
    we can define parameters by adding capturing groups to the RegEx. For instance,
    the same step definition would look like this using a regular expression pattern:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用正则表达式模式来做同样的事情。而不是使用花括号，我们可以通过在RegEx中添加捕获组来定义参数。例如，使用正则表达式模式，同样的步骤定义看起来会是这样：
- en: '[PRE61]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Update your `spec/cucumber/steps/index.js` file to add groups to the regular
    expression patterns, and use those captured parameters in your step definition
    function. The end result should look like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的`spec/cucumber/steps/index.js`文件，为正则表达式模式添加组，并在你的步骤定义函数中使用这些捕获的参数。最终结果应该看起来像这样：
- en: '[PRE62]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Refactoring our application
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构我们的应用程序
- en: Now that our tests have been refactored, we can now turn our focus to refactoring
    our application code. The great thing about having existing E2E tests is that
    if, during the refactoring, we break something, the tests will fail and we'd be
    able to fix them quickly.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重构了测试，我们可以将注意力转向重构我们的应用程序代码。拥有现有的端到端测试的好处是，如果在重构过程中我们破坏了某些东西，测试将会失败，我们能够快速修复它们。
- en: 'As we did before, let''s list out all the issues with our current code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前，让我们列出我们当前代码的所有问题：
- en: It is not very readable.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的可读性并不高。
- en: We have to work with quite low-level constructs, such as streams and buffers.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须与相当低级的结构一起工作，例如流和缓冲区。
- en: We have not taken into consideration performance and security implications.
    For example, we are not handling situations where the payload is extremely large
    (or even infinite). This is a dangerous situation to avoid if we want to ensure
    high-availability of our service.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有考虑到性能和安全性的影响。例如，我们没有处理负载极大（甚至无限大）的情况。如果我们想确保我们服务的高可用性，这是一个需要避免的危险情况。
- en: 'For the last issue, we can add an additional `if` block inside the `req.on(''data'')`
    block to check whether the payload is getting too large; if it is, we can return
    a `413 Payload Too Large` error. In the following example, we are using a limit
    of `1e6`, which is one million, or `1,000,000`, bytes:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个问题，我们可以在`req.on('data')`块内添加一个额外的`if`块来检查负载是否变得过大；如果是，我们可以返回一个`413 Payload
    Too Large`错误。在下面的示例中，我们使用了一个限制为`1e6`，即一百万，或`1,000,000`字节。
- en: '[PRE63]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: However, this makes the code even harder to understand. At the moment, there's
    not too much functionality behind our API, yet our code is already quite long
    and complex; imagine how much more obscure it will get when we have to implement
    the logic to parse URL paths, query parameters, and so on.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这使得代码更加难以理解。目前，我们API背后的功能并不多，但我们的代码已经相当长且复杂；想象一下，当我们必须实现解析URL路径、查询参数等的逻辑时，它将变得多么晦涩难懂。
- en: As you may expect, these problems have already been solved and optimized by
    frameworks. So, let's take a look at some libraries we can use and then pick the
    one that best fits our use case.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，这些问题已经被框架解决并优化了。因此，让我们看看我们可以使用的库，然后选择最适合我们用例的一个。
- en: Choosing a framework
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个框架
- en: 'At a minimum, we want a basic router; at most, we want a web framework. In
    this section, we will focus on four of the most popular frameworks: **Express**, **Koa**, **Hapi**, and **Restify**:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，我们想要一个基本的路由器；最多，我们想要一个网络框架。在本节中，我们将关注四个最受欢迎的框架：**Express**、**Koa**、**Hapi**和**Restify**：
- en: '| **Name** | **Website** | **First** **released** | **GitHub** **stars** |
    **Description** |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **网站** | **首次发布** | **GitHub 星标** | **描述** |'
- en: '| Express | [expressjs.com](http://expressjs.com) | Jan, 3 2010 | 39,957 |
    "Fast, unopinionated, minimalist web framework for Node".Express is a thin routing
    layer above Node''s native `http` module, with support for templating and **middleware**
    (functions that preprocess the request object before it is passed to the handler).Express
    has been around the longest and is the most popular framework for Node.js. We
    will use Express as the benchmark from which comparisons with other libraries
    will be made. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| Express | [expressjs.com](http://expressjs.com) | 2010年1月3日 | 39,957 | "快速、无偏见、极简主义的Node.js网络框架"。Express是Node原生`http`模块之上的一个薄路由层，支持模板和**中间件**（在请求对象传递给处理器之前预处理请求对象的函数）。Express是存在时间最长的，也是Node.js最受欢迎的框架。我们将使用Express作为基准，与其他库进行比较。'
- en: '| Koa | [koajs.com](http://koajs.com/) | Nov, 8 2013 | 22,847 | Created by TJ
    Holowaychuk, the same developer behind Express. It is similar to Express but uses
    async functions instead of callbacks. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| Koa | [koajs.com](http://koajs.com/) | 2013年11月8日 | 22,847 | 由Express背后的开发者TJ
    Holowaychuk创建。它与Express类似，但使用异步函数而不是回调。'
- en: '| Hapi | [hapijs.com](https://hapijs.com/) | Aug, 21 2012 | 9,913 | While Express
    is minimalistic, Hapi ships with many built-in features, such as input validation,
    caching, and authentication; all you have to do is specify your settings in the
    configuration object for that route.Like middleware for Express, Hapi has a request
    life cycle and extension points where you can process the request or response
    objects.Hapi also supports a plugin system that allows you to split your app into
    modular parts. |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| Hapi | [hapijs.com](https://hapijs.com/) | Aug, 21 2012 | 9,913 | 虽然Express简约，但Hapi自带了许多内置功能，如输入验证、缓存和身份验证；你只需在配置对象中指定该路由的设置即可。与Express的中间件类似，Hapi也有请求生命周期和扩展点，你可以在这里处理请求或响应对象。Hapi还支持插件系统，允许你将应用程序拆分为模块化部分。|'
- en: '| Restify | [restify.com](http://restify.com/) | May, 6 2011 | 8,582 | REST
    framework for providing microservices APIs. It is essentially Express but without
    the templating parts. It supports **DTrace**, which allows you to find out the
    amount of resources (for example, memory, CPU time, filesystem I/O, and bandwidth)
    used by a process. |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| Restify | [restify.com](http://restify.com/) | May, 6 2011 | 8,582 | 提供微服务API的REST框架。它本质上与Express相同，但没有模板部分。它支持**DTrace**，这允许你找出进程使用的资源量（例如，内存、CPU时间、文件系统I/O和带宽）。|'
- en: For basic features such as routing, all of these frameworks are more than capable.
    They differ only in their philosophy and community support.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本功能，如路由，所有这些框架都绰绰有余。它们之间的区别仅在于它们的哲学和社区支持。
- en: Express is, without a doubt, the most popular and has the most community support,
    but it requires a lot of configuration and extra middleware just to get it out
    of the box. On the other hand, Hapi's configuration-centric philosophy is very
    interesting, because it means we don't have to change our code or update 10 different
    middleware, even when the feature code is changed and optimized. It's configuration-as-code,
    which is a nice philosophy to follow.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Express无疑是最受欢迎的，并且拥有最多的社区支持，但它需要大量的配置和额外的中间件才能使其正常工作。另一方面，Hapi以配置为中心的哲学非常有趣，因为它意味着我们不需要更改我们的代码或更新10个不同的中间件，即使功能代码被更改和优化也是如此。这是配置即代码，这是一个很好的哲学理念。
- en: However, when we develop our frontend application with React, we may later decide
    to use more advanced features, such as **Server-Side Rendering** (**SSR**). For
    these, we need to ensure that the tools and integrations we employ are widely
    used, so that if we run into any trouble, there'll be a large group of developers
    out there who have faced and resolved those issues. Otherwise, we may waste a
    long time looking at that source code to figure out a simple problem.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用React开发我们的前端应用程序时，我们可能会稍后决定使用更高级的功能，例如**服务器端渲染**（**SSR**）。对于这些，我们需要确保我们使用的工具和集成是广泛使用的，这样如果遇到任何问题，就会有大量的开发者已经遇到过并解决了这些问题。否则，我们可能会浪费大量时间查看源代码来找出一个简单的问题。
- en: So although Hapi might technically be a better choice in theory, we will use
    Express because it is more popular and has a lot more community support.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然从理论上讲Hapi可能是一个更好的选择，但我们将使用Express，因为它更受欢迎，并且拥有更多的社区支持。
- en: 'Since migration to Express is an involved process, I''d recommend you to commit
    your code before continuing:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 由于迁移到Express是一个复杂的过程，我建议你在继续之前提交你的代码：
- en: '[PRE64]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Migrating our API to Express
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的API迁移到Express
- en: 'There are two ways to install Express: directly in the code itself or through
    the `express-generator` application generator tool. The `express-generator` tool
    installs the `express` CLI, which we can use to generate an application skeleton
    from. However, we won''t be using that because it''s mainly meant for client-facing
    applications, while we are just trying to build a server-side API at the moment. Instead,
    we''ll add the `express` package directly into our code.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Express有两种方式：直接在代码中或通过`express-generator`应用程序生成器工具。`express-generator`工具安装了`express`
    CLI，我们可以用它来生成应用程序骨架。然而，我们不会使用它，因为它主要用于面向客户端的应用程序，而我们目前只是尝试构建一个服务器端API。相反，我们将直接将`express`包添加到我们的代码中。
- en: 'First, add the package into our project:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将包添加到我们的项目中：
- en: '[PRE65]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now open up your `src/index.js` file, and replace our `import` of the `http`
    module with the `express` package. Also replace the current `http.createServer` and
    `server.listen` calls with `express` and `app.listen`. What was previously this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开你的`src/index.js`文件，将我们的`import`语句中的`http`模块替换为`express`包。同时，将当前的`http.createServer`和`server.listen`调用替换为`express`和`app.listen`。之前是这样的：
- en: '[PRE66]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Would now be this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在会是这样的：
- en: '[PRE67]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To help us know when the server has successfully initialized, we should add
    a callback function to `app.listen`, which will log a message onto the console:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们了解服务器何时成功初始化，我们应该向`app.listen`添加一个回调函数，它将在控制台输出一条消息：
- en: '[PRE68]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We needed to disable ESLint for our `console.log` line because Airbnb's style
    guide enforces the `no-console` rule. `// eslint-disable-next-line` is a special
    type of comment recognized by ESLint, and will cause it to disable the specified
    rules for the next line. There is also the `// eslint-disable-line` comment if
    you want to disable the same line as the comment.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要禁用ESLint来处理`console.log`行，因为Airbnb的风格指南强制执行`no-console`规则。`// eslint-disable-next-line`是一种ESLint能识别的特殊注释，它会导致ESLint禁用下一行指定的规则。如果你想要禁用注释所在的同一行，也可以使用`//
    eslint-disable-line`注释。
- en: (Re)defining routes
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （重新）定义路由
- en: Next, let's migrate our `requestHandler` function to Express. With Express,
    instead of defining a single request handler for all our routes, we can define
    request handlers for each route using the format `app.METHOD('path', callback)`,
    where `METHOD` is the HTTP method of the request.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们的`requestHandler`函数迁移到Express。使用Express，我们不再需要为所有路由定义单个请求处理器，而是可以使用`app.METHOD('path',
    callback)`的格式为每个路由定义请求处理器，其中`METHOD`是请求的HTTP方法。
- en: 'Therefore, replace our previous `requestHandler` function with an `app.post`
    call. This is our old implementation:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用`app.post`调用替换我们之前的`requestHandler`函数。这是我们的旧实现：
- en: '[PRE69]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And this is our new implementation:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的新实现：
- en: '[PRE70]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `req` and `res` objects passed by Express are identical to the ones passed
    by Node''s `http` module; this is why we can reuse the same logic as before. Run
    the tests again and they should still all pass:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Express传递的`req`和`res`对象与Node的`http`模块传递的相同；这就是为什么我们可以重用之前的相同逻辑。再次运行测试，它们应该仍然全部通过：
- en: '[PRE71]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Our code using Express is much clearer than our original example; here, each
    route is defined in its own block. Furthermore, if a request comes in for an unspecified
    route, then a `404: Not Found` response is automatically given. These small conveniences
    highlight one of the benefits of using a framework rather than programming your
    own implementation.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用Express的代码比原始示例更清晰；在这里，每个路由都在自己的块中定义。此外，如果收到对未指定路由的请求，则会自动返回`404: Not Found`响应。这些小便利之处突出了使用框架而不是编写自己的实现的好处之一。'
- en: 'Furthermore, instead of using `res.writeHead`, we can use `res.status` and
    `res.set`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不再使用`res.writeHead`，而是可以使用`res.status`和`res.set`：
- en: '[PRE72]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Similarly, instead of using `res.end` with `JSON.stringify`, we can use the
    new `res.json` method provided by Express.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们不再使用`res.end`与`JSON.stringify`，而是可以使用Express提供的新的`res.json`方法。
- en: '[PRE73]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Using body-parser middleware
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用body-parser中间件
- en: That's just the start of our Express journey. The power of Express is in its
    abundance of middleware, which are functions that every request passes through.
    These middleware functions can opt to modify the request object before it arrives
    at the handler.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们Express之旅的开始。Express的力量在于其丰富的中间件，这些中间件是每个请求都必须通过的功能。这些中间件函数可以选择在请求到达处理器之前修改请求对象。
- en: 'Therefore, instead of working with streams and buffers to obtain our payload
    data, we can make use of a very popular middleware package, `body-parser`. `body-parser` provides
    the ability to parse request bodies into JavaScript objects, which can then be
    consumed by our handlers. It does this in an efficient and optimized way, and
    also provides safeguards to ensure the payload is not too large. So, let''s install
    it:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不再需要使用流和缓冲区来获取我们的有效负载数据，而是可以利用一个非常流行的中间件包`body-parser`。`body-parser`提供了将请求体解析为JavaScript对象的能力，然后这些对象可以被我们的处理器消费。它以高效和优化的方式完成这项工作，并提供保护措施以确保有效负载不会太大。所以，让我们来安装它：
- en: '[PRE74]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, add the following lines to the top of `src/index.js` to instruct our
    application server to use the `body-parser` package to parse any request that
    has a JSON body:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下行添加到`src/index.js`的顶部，以指示我们的应用程序服务器使用`body-parser`包来解析任何具有JSON体的请求：
- en: '[PRE75]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `bodyParser.json` method returns with a middleware.  Here, we are using
    the `app.use()` method to instruct our instance of the Express server to use the
    middleware generated by the `bodyParser.json` method. The middleware will parse
    the payload and assign it to the `body` property of the `req` object. We no longer
    need to work with streams and buffers; we can simply get the payload from `req.body`!
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`bodyParser.json`方法返回一个中间件。在这里，我们使用`app.use()`方法来指示我们的Express服务器实例使用由`bodyParser.json`方法生成的中间件。中间件将解析有效负载并将其分配给`req`对象的`body`属性。我们不再需要处理流和缓冲区；我们可以直接从`req.body`获取有效负载！'
- en: 'Inside our `app.post(''/users'')` call, remove any code that works with buffers
    and streams, and replace the `payloadData` variable with `req.body`. Lastly, replace
    the condition `req.body.length === 0` inside our first if block with `req.headers[''content-length'']
    === ''0''`. Our handler should now look like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`app.post('/users')`调用中，删除任何与缓冲区和流相关的代码，并将`payloadData`变量替换为`req.body`。最后，将我们第一个if块中的条件`req.body.length
    === 0`替换为`req.headers['content-length'] === '0'`。现在我们的处理器应该看起来像这样：
- en: '[PRE76]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Run E2E test
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行端到端测试
- en: 'But if we run our E2E tests now, the scenario that sends a malformed JSON would
    fail. This is because of how the `body-parser` middleware works. The `bodyParser.json()`
    middleware will attempt to parse the payload of all requests that has their `Content-Type` header
    set to `application/json`. However, if the payload itself is not a valid JSON
    object, the middleware will throw an error similar to the following:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们现在运行端到端测试，发送格式不正确的JSON的场景将会失败。这是因为`body-parser`中间件的工作方式。`bodyParser.json()`中间件将尝试解析所有请求的有效负载，这些请求的`Content-Type`头设置为`application/json`。然而，如果有效负载本身不是一个有效的JSON对象，中间件将抛出一个类似于以下错误：
- en: '[PRE77]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Therefore, we need to catch this error in order to provide the correct response.
    Error handling can also be done through middleware, but they must be defined *at
    the end*, after other middleware. In the error handler middleware, we need to
    check whether the error thrown is caused by a malformed JSON payload, and if it
    is, send the `'Payload should be in JSON format'` response we defined earlier.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要捕获这个错误，以便提供正确的响应。错误处理也可以通过中间件来完成，但它们必须在其他中间件之后定义*，即在最后*。在错误处理器中间件中，我们需要检查抛出的错误是否由格式不正确的JSON有效负载引起，如果是，则发送我们之前定义的`'Payload
    should be in JSON format'`响应。
- en: 'Try your hands on implementing this error handler middleware; when you finish,
    compare your `src/index.js` file with the following one:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试实现这个错误处理中间件；完成之后，比较你的`src/index.js`文件与以下文件：
- en: '[PRE78]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, when we run our E2E tests, they should all be passing:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行我们的端到端测试时，它们都应该通过：
- en: '[PRE79]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We have now successfully migrated our API to Express, and thus completed our
    (long) refactoring step. Let''s commit our hard work into the Git repository:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已成功将我们的API迁移到Express，并完成了我们的（漫长的）重构步骤。让我们将我们的辛勤工作提交到Git仓库：
- en: '[PRE80]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Moving common logic into middleware
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将通用逻辑移动到中间件
- en: 'Let''s see how we can improve our code further. If you examine our Create User
    endpoint handler, you may notice that its logic could be applied to all requests.
    For example, if a request comes in carrying a payload, we expect the value of
    its `Content-Type` header to include the string `application/json`, *regardless
    of which endpoint it is hitting*. Therefore, we should pull that piece of logic
    out into middleware functions to maximize reusability. Specifically, these middleware
    should perform the following checks:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何进一步改进我们的代码。如果你检查我们的创建用户端点处理器，你可能会注意到其逻辑可以应用于所有请求。例如，如果一个请求携带有效负载，我们期望其`Content-Type`头的值包含字符串`application/json`，*无论它击中哪个端点*。因此，我们应该将这部分逻辑提取到中间件函数中，以最大化可重用性。具体来说，这些中间件应该执行以下检查：
- en: If a request uses the method `POST`, `PUT` or `PATCH`, it must carry a non-empty
    payload.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个请求使用`POST`、`PUT`或`PATCH`方法，它必须携带非空的有效负载。
- en: If a request contains a non-empty payload, it should have its `Content-Type` header
    set. If it doesn't, respond with the `400 Bad Request` status code.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个请求包含非空的有效负载，它应该设置其`Content-Type`头。如果没有设置，则响应`400 Bad Request`状态码。
- en: If a request has set its `Content-Type` header, it must contain the string `application/json`.
    If it doesn't, respond with the `415 Unsupported Media Type` status code.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个请求设置了其`Content-Type`头，它必须包含字符串`application/json`。如果没有，则响应`415 Unsupported
    Media Type`状态码。
- en: 'Let''s translate these criteria into Cucumber/Gherkin specifications. Since
    these are generic requirements, we should create a new file at `spec/cucumber/features/main.feature` and
    define our scenarios there. Have a go at it yourself; once you''re done, compare
    it with the following solution:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些标准转换为Cucumber/Gherkin规范。由于这些是通用要求，我们应该在`spec/cucumber/features/main.feature`中创建一个新文件，并在那里定义我们的场景。尝试自己完成；完成后，与以下解决方案进行比较：
- en: '[PRE81]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When we run our tests, the step `But without a "Content-Type" header set` shows
    up as undefined; so let''s implement it. It is as simple as running the `unset` method
    on a superagent''s `request` object:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，步骤“但没有设置`Content-Type`头”显示为未定义；所以让我们实现它。这就像在superagent的`request`对象上运行`unset`方法一样简单：
- en: '[PRE82]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run the tests and see that all steps are now defined but some are failing.
    Red. Green. Refactor. We''re at the red stage, so let''s modify our application
    code so that it''ll pass (green). Again, have a go at it yourself, and compare
    it with our solution here once you''re done:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并查看所有步骤现在都已定义，但其中一些失败了。红。绿。重构。我们现在处于红色阶段，所以让我们修改我们的应用程序代码，使其通过（绿色）。再次尝试自己完成它，完成后与我们的解决方案在这里进行比较：
- en: '[PRE83]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'It is important to run our tests again to make sure we didn''t break existing
    functionality. On this occasion, they should all be passing. Therefore, the only
    thing left to do is to commit this refactoring into our Git repository:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行我们的测试非常重要，以确保我们没有破坏现有的功能。在这种情况下，它们都应该通过。因此，我们唯一剩下的事情是将这次重构提交到我们的Git存储库：
- en: '[PRE84]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Validating our payload
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证我们的有效载荷
- en: So far, we've been writing tests that ensure our request is valid and well-formed;
    in other words, making sure they are *syntactically *correct. Next, we are going
    to shift our focus to writing test cases that look at the payload object itself,
    ensuring that the payload has the correct structure and that it is *semantically*
    correct.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在编写测试来确保我们的请求是有效和格式良好的；换句话说，确保它们在语法上是正确的。接下来，我们将把重点转移到编写测试用例，这些测试用例将查看有效载荷对象本身，确保有效载荷具有正确的结构，并且是语义上正确的。
- en: Checking for required fields
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查必填字段
- en: In our requirements, we specified that in order to create a user account, the
    client must provide at least the `email` and `password` fields. So, let's write
    a test for this.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的要求中，我们指定，为了创建用户账户，客户端必须提供至少`email`和`password`字段。所以，让我们为这个写一个测试。
- en: 'In our `spec/cucumber/features/users/create/main.feature` file, add the following
    scenario outline:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`spec/cucumber/features/users/create/main.feature`文件中，添加以下场景概述：
- en: '[PRE85]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Apart from the second step, `And attaches a Create User payload which is missing
    the <missingFields> field`, every other step has already been implemented. The
    missing step should attach a dummy user payload, but then remove the specified
    property. Try implementing the logic of this step definition yourself, and compare
    it with the following solution:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第二个步骤，“附加一个缺少`<missingFields>`字段的创建用户有效载荷”之外，其他所有步骤都已实现。缺少的步骤应该附加一个虚拟用户有效载荷，然后删除指定的属性。尝试自己实现这个步骤定义的逻辑，并将其与以下解决方案进行比较：
- en: '[PRE86]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the step definition, we first extract the variables and convert the `missingFields`
    string into an array. We then loop through this array and delete each property
    from the payload object. Lastly, we feed this incomplete payload into the request
    as the payload.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤定义中，我们首先提取变量并将`missingFields`字符串转换为数组。然后我们遍历这个数组，从有效载荷对象中删除每个属性。最后，我们将这个不完整的有效载荷作为有效载荷输入到请求中。
- en: 'If we run the test now, it will fail. This is because we have not implemented
    the validation logic inside our Create User handler. Once again, have a go at
    implementing it, and check back here for our solution:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行测试，它将失败。这是因为我们还没有在我们的创建用户处理程序中实现验证逻辑。再次尝试实现它，并在这里检查我们的解决方案：
- en: '[PRE87]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, all our tests will pass again:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们所有的测试都将再次通过：
- en: '[PRE88]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Don''t forget to commit these changes into Git:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将这些更改提交到Git：
- en: '[PRE89]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Checking property type
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查属性类型
- en: 'Next, we must ensure that both our `email` and `password` fields are of type
    string and that the email address is formatted correctly. Have a go at defining
    a new scenario outline for this, and compare it to the following solution:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须确保我们的`email`和`password`字段都是字符串类型，并且电子邮件地址格式正确。尝试为这个场景定义一个新的场景概述，并将其与以下解决方案进行比较：
- en: '[PRE90]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Again, run the tests and confirm that one of the steps is undefined. Then,
    try to implement the step definition yourself, and check back with the following
    solution:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试并确认有一个步骤未定义。然后，尝试自己实现步骤定义，并检查以下解决方案：
- en: '[PRE91]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When we run the test, it fails because we have not implemented our application
    to handle that scenario. So, let''s do that now by adding this `if` block to the
    end of the request handler for `POST /users`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，它失败了，因为我们还没有实现我们的应用程序来处理该场景。所以，让我们现在通过在`POST /users`请求处理器的末尾添加这个`if`块来实现它：
- en: '[PRE92]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, run the tests to see them pass, and commit our changes to Git:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试以查看它们通过，并将我们的更改提交到Git：
- en: '[PRE93]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Checking the payload property's format
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查负载属性的格式
- en: 'Lastly, the email address field may be present and have the correct data type,
    but it may still not be a valid email. So, the final check is to ensure the email
    is a valid email address. You should get the drill by now: define a new feature
    inside `spec/cucumber/features/users/create/main.feature`, and check back here
    for the solution:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，电子邮件地址字段可能存在并且具有正确的数据类型，但它可能仍然不是一个有效的电子邮件地址。因此，最终的检查是确保电子邮件地址是有效的。你现在应该已经习惯了：在`spec/cucumber/features/users/create/main.feature`中定义一个新特性，并在这里检查解决方案：
- en: '[PRE94]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note that we are excluding emails that are technically valid email addresses
    (such as `a@1.2.3.4`), but for our API, we want to accept only the more "generic"
    email addresses (such as `jane@gmail.com`).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在排除技术上有效的电子邮件地址（例如`a@1.2.3.4`），但对我们来说，我们只想接受更“通用”的电子邮件地址（例如`jane@gmail.com`）。
- en: We are checking multiple examples here to give us confidence that our endpoint *really* won't
    accept an invalid email. In theory, the more examples we define, the better, because
    it gives us more confidence in our feature. However, E2E tests take a (relatively)
    long time to run; therefore, we must find a balance between confidence and speed.
    Here, we have specified three sufficiently diverse examples, which should cover
    most scenarios.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里检查多个示例，以增强我们对端点*真正*不会接受无效电子邮件的信心。理论上，我们定义的示例越多，越好，因为它增加了我们对功能的信心。然而，端到端测试运行时间相对较长；因此，我们必须在信心和速度之间找到平衡。在这里，我们指定了三个足够多样化的示例，应该覆盖大多数场景。
- en: 'Next, let''s define the step definition:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义步骤定义：
- en: '[PRE95]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Run the tests and see them fail. Then, implement the following application
    code to make them pass:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并观察它们失败。然后，实现以下应用程序代码以使它们通过：
- en: '[PRE96]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Run the tests again, make sure they all pass, and then commit your code:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，确保它们全部通过，然后提交你的代码：
- en: '[PRE97]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Refactoring our step definitions
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构我们的步骤定义
- en: Red. Green. Refactor. Now that all tests pass, it's a good time to refactor
    our code.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 红色、绿色、重构。现在所有测试都通过了，是时候重构我们的代码了。
- en: Our application code, although slightly repetitive, is easy to follow and read;
    therefore, we don't need to refactor it for now. There are, however, some improvements
    we can make to our test code. For example, we are hardcoding the Create User payload
    into our tests; it'll be better if we abstract that into a function that generates
    the payload when called.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序代码虽然有些重复，但易于理解和阅读；因此，我们现在不需要重构它。然而，我们可以在测试代码中做一些改进。例如，我们在测试中将创建用户的负载硬编码到测试中；如果将其抽象成一个函数，在调用时生成负载会更好。
- en: 'We are going to create a new `spec/cucumber/steps/utils.js` file to house our
    utility/support code. Add the following into the `utils.js` file:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`spec/cucumber/steps/utils.js`文件来存放我们的实用/支持代码。将以下内容添加到`utils.js`文件中：
- en: '[PRE98]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Import it and use it in our test code. For example, the `When(/^attaches an?
    (.+) payload where the ([a-zA-Z0-9, ]+) fields? (?:is|are) exactly (.+)$/)` step
    definition would become this:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 导入它并在我们的测试代码中使用它。例如，`When(/^attaches an? (.+) payload where the ([a-zA-Z0-9,
    ]+) fields? (?:is|are) exactly (.+)$/)`步骤定义将变成这样：
- en: '[PRE99]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Do this for all other step definitions that use an endpoint-specific payload.
    After this, run the tests again and make sure they all still pass (because refactoring
    shouldn''t modify the functionality), and then commit the changes to Git:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有其他使用特定端点负载的步骤定义都这样做。之后，再次运行测试并确保它们仍然全部通过（因为重构不应该修改功能），然后提交更改到Git：
- en: '[PRE100]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Testing the success scenario
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试成功场景
- en: We have covered almost all of the edge cases. Now, we must implement the happy
    path scenario, where our endpoint is called as intended, and where we are actually
    creating the user and storing it in our database.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了几乎所有边缘情况。现在，我们必须实现一个快乐路径场景，即我们的端点按预期被调用，并且我们实际上正在创建用户并将其存储在我们的数据库中。
- en: 'Let''s carry on with the same process and start by defining a scenario:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用相同的过程，并首先定义一个场景：
- en: '[PRE101]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'All steps are defined except the second, fifth, and last step. The second step
    can be implemented by using our `getValidPayload` method to get a valid payload,
    like so:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第二步、第五步和最后一步之外，所有步骤都已定义。第二步可以通过使用我们的`getValidPayload`方法来获取一个有效的有效载荷来实现，如下所示：
- en: '[PRE102]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The fifth step is a variation of the `Then(''the payload of the response should
    be a JSON object'')` step definition we have already defined, and therefore we
    can simply modify it to make it more generic:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 第五步是我们已经定义的`Then('the payload of the response should be a JSON object')`步骤定义的一个变体，因此我们可以简单地修改它使其更通用：
- en: '[PRE103]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: For the last step, however, we actually need a database to write to. But we
    have already achieved a lot in this chapter. So let's review what we have done
    up to this point, and set up a database in the next chapter!
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于最后一步，我们实际上需要一个数据库来写入。但在这个章节中，我们已经取得了很大的进展。所以，让我们回顾一下到目前为止我们所做的一切，并在下一章中设置一个数据库！
- en: Summary
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we coerced you into following TDD principles when developing
    your application. We used Cucumber and Gherkin to write our end-to-end test, and
    used that to drive the implementation of our first endpoint. As part of our refactoring
    efforts, we've also migrated our API to use the Express framework.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们强迫你遵循TDD原则来开发你的应用程序。我们使用了Cucumber和Gherkin来编写我们的端到端测试，并使用它来驱动我们第一个端点的实现。作为我们重构工作的部分，我们还迁移了我们的API以使用Express框架。
- en: 'At this point, you should have the TDD process drilled into your brain: Red.
    Green. Refactor. Begin by writing out test scenarios, implementing any undefined
    steps, then run the tests and see them fail, and finally, implementing the application
    code to make them pass. Once the tests have passed, refactor where appropriate. Rinse
    and repeat.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经将TDD过程深深印在你的脑海中：红。绿。重构。首先，编写测试场景，实现任何未定义的步骤，然后运行测试并观察它们失败，最后实现应用程序代码使它们通过。一旦测试通过，就在适当的地方进行重构。重复此过程。
- en: It's important to remember that TDD is not required to have self-testing code.
    You can, without following TDD, still write tests after to verify behavior and
    catch bugs. The emphasis of TDD is that it translates the design of your system
    into a set of concrete requirements, and uses these requirements to *drive* your
    development. Testing is a forethought, not an afterthought.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，TDD并不要求有自测试的代码。即使不遵循TDD，你仍然可以在之后编写测试来验证行为和捕获错误。TDD的重点是将你的系统设计转化为一系列具体的要求，并使用这些要求来*驱动*你的开发。测试是一种前瞻性思维，而不是事后思考。
- en: In the next chapter, we will implement the last remaining step of our E2E tests,
    setting up Elasticsearch and using it to persist our user data.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现我们E2E测试的最后一步，设置Elasticsearch并使用它来持久化我们的用户数据。
