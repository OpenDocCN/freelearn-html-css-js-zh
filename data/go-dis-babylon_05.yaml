- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Adding a Cut Scene and Handling Input
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加场景剪辑和处理输入
- en: Much of the work we’ve completed so far has contributed to the whole largely
    unseen and unheard. The only action we’ve required – or even listened for – from
    users is a single button click. How boring – and quiet. That’s all about to change,
    though! In this chapter, we’re going to add some flavor to our app’s launch by
    adding a Splash Screen that tells the world that everything they’re about to see
    is “Powered by Babylon.js” in the process of providing players with their first
    experience with Space-Truckers. We’ll also be giving users agency in the game
    world by adding inputs for multiple different device types, along with the logic
    to process inputs into actions in the game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止完成的大部分工作都为整个几乎看不见和听不到的整体做出了贡献。我们唯一要求用户执行或甚至监听的动作只是一个按钮点击。多么无聊——而且安静。但这一切都将改变！在本章中，我们将通过添加一个启动屏幕来为我们的应用程序启动增添一些趣味，这个屏幕告诉世界他们即将看到的一切都是“由Babylon.js提供动力”的过程，同时为玩家提供他们的第一次Space-Truckers体验。我们还将通过添加多种不同设备类型的输入以及将输入处理为游戏中的动作的逻辑，让用户在游戏世界中拥有更多的自主权。
- en: This seems like a lot to cover in such a short chapter, but thanks to how easy
    it can be to accomplish tasks in Babylon.js, progress can come faster than you
    might think.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎在如此短的章节中要涵盖很多东西，但多亏了Babylon.js中完成任务是多么容易，进度可能会比你想象的要快。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Space-Truckers – the Splash Screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Space-Truckers – 启动屏幕
- en: Designing the Input System
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计输入系统
- en: Everything we’ll be doing will build from the work we’ve done in previous chapters,
    but it’s OK if you’re just picking things up from here – read on for technical
    details on how to obtain the source code to complete this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的所有事情都将基于我们在之前章节中完成的工作，但如果你只是从这里开始学习，也没有关系——继续阅读以获取完成本章所需源代码的技术细节。
- en: Technical Requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This is the first time that we’re going to be expanding the technical requirements,
    but it should hardly be a surprise to anyone that to work with a particular type
    of input device – be it a mouse and keyboard, Xbox™ controller, Sony PlayStation™
    controller, or even a VR joystick – it is necessary to either have one of such
    devices handy or (worst case) download and install a suitable emulator/simulation
    app. That said, Space-Truckers should be playable with the following input types:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次扩展技术要求，但几乎对每个人来说都不会感到惊讶，因为要与特定类型的输入设备一起工作——无论是鼠标和键盘、Xbox™控制器、索尼PlayStation™控制器，甚至是VR摇杆——都需要手头有一个这样的设备，或者（最坏的情况）下载并安装一个合适的模拟器/应用程序。话虽如此，Space-Truckers应该可以使用以下输入类型进行游戏：
- en: Keyboard and mouse
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘和鼠标
- en: Virtual joysticks/touch screen
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟摇杆/触摸屏
- en: Xbox™ controller
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xbox™控制器
- en: Sony PlayStation™ controller
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索尼PlayStation™控制器
- en: Generic gamepads
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用游戏手柄
- en: An appropriate audio output device will be needed to play music and sounds.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个合适的音频输出设备来播放音乐和声音。
- en: 'This chapter will follow a similar pattern as previous chapters, where we will
    build out one or more PlayGround snippets before integrating them into the application’s
    code base. The code we’ll be starting from is at [https://github.com/jelster/space-truckers/tree/ch4](https://github.com/jelster/space-truckers/tree/ch4)
    if you want a reference point or a place from where you can start your journey.
    Now, with that squared away, we can turn our full attention to our first task:
    building the Splash Screen!'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将遵循与之前章节相似的模式，我们将在将它们集成到应用程序的代码库之前构建一个或多个PlayGround片段。如果您想找到一个参考点或开始您旅程的地方，起始代码位于[https://github.com/jelster/space-truckers/tree/ch4](https://github.com/jelster/space-truckers/tree/ch4)。现在，事情都安排妥当后，我们可以全神贯注于我们的第一个任务：构建启动屏幕！
- en: Space-Truckers – the Splash Screen
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Space-Truckers – 启动屏幕
- en: Nothing gets the attention of an audience better than a splashy entrance, and
    nobody knew this better than good ol’ William Shakespeare. A glance at the first
    few pages of any of his plays uncovers a host of different exciting scenes from
    a street brawl between rival gangs in *Romeo and Juliet* to an interrupted wedding
    in *A Midsummer Night’s Dream*. The Bard knew how to get the attention of his
    audiences – a notable feat in those times – and just as he shamelessly plundered
    history and mythology (sometimes both at the same time!) for his stories, we’re
    going to shamelessly plunder the techniques he used in our work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比一个引人注目的入场更能吸引观众的注意力了，而没有人比那位伟大的威廉·莎士比亚更懂得这一点。翻看他的任何一部戏剧的前几页，就能发现从《罗密欧与朱丽叶》中敌对帮派的街头斗殴到《仲夏夜之梦》中婚礼被打断的众多激动人心的场景。这位剧作家知道如何吸引观众的注意力——在那个时代这是一个显著的成就——就像他毫无顾忌地从历史和神话（有时同时进行！）中掠夺他的故事一样，我们也将毫无顾忌地掠夺他在我们的工作中使用的技巧。
- en: The specific inspiration from Mr. S. that we will examine is the idea of engaging
    the attention of an audience to prepare and prime them for what they’re about
    to experience. We don’t have a fancy fight scene or a fantasy wedding in the cards
    for Space-Truckers, but we do have our Splash Screen!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考察的具体灵感来自S先生的想法，即吸引观众的注意力，为他们即将体验的内容做好准备。对于太空卡车司机来说，我们没有计划任何华丽的战斗场景或奇幻的婚礼，但我们确实有我们的喷溅屏幕！
- en: Looking at the Splash Screen in context, the user has just clicked the **Launch**
    button on the regular HTML web page, transitioning the page over to WebGL and
    rendering the animated Loading Screen we built back in [*Chapter 2*](B17266_02_Final_AM.xhtml#_idTextAnchor030)*,
    Ramping up on Babylon.js*. Immediately following the completion of the Splash
    Screen (either because it ran to the end or because the user chose to skip through
    it), the user will be taken to the **Main Menu** screen that we built out in the
    previous chapter. Through a series of animated sequences and in conjunction with
    the audio soundtrack, users will be put solidly into the mood of a Space-Trucker.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文中观察喷溅屏幕，用户刚刚点击了常规HTML网页上的**启动**按钮，将页面过渡到WebGL，并渲染我们在[*第2章*](B17266_02_Final_AM.xhtml#_idTextAnchor030)*，在Babylon.js*中构建的动画加载屏幕。立即在喷溅屏幕完成（无论是运行到结束还是因为用户选择跳过）之后，用户将被带到我们在上一章中构建的**主菜单**屏幕。通过一系列动画序列和音频配乐的配合，用户将被完全带入太空卡车司机的氛围中。
- en: Storyboarding the Scene
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景分镜
- en: 'While it’s easy to let the mind wander off into the potential avenues that
    a splash scene might show, we’ll Save It For A PR™ and instead start with something
    incredibly simple that we can then use as a base for expansion. A storyboard doesn’t
    have to be an immensely complicated and planned-out artifact. Time spent storyboarding
    is time that isn’t being spent trying out the ideas laid out by the storyboard,
    so don’t worry about making it look good, worry about the boards capturing a set
    of snapshots of what you want to happen. The following diagram shows the sketched-out
    series of panels that comprise the Splash Screen storyboard:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然让思绪飘向可能出现的喷溅场景的潜在途径很容易，但我们将其留作公关活动™，而是从极其简单的东西开始，然后将其用作扩展的基础。分镜板不必是一个极其复杂和计划周详的物品。用于分镜的时间是不在尝试分镜中提出想法的时间，所以不要担心它看起来好不好，要担心的是这些板是否捕捉到了你想要发生的场景的一系列快照。以下图表显示了构成喷溅屏幕分镜的草图系列：
- en: '![Figure 5.1 – Storyboard for the Splash Screen sequence. Being a sketch, the
    numbers given for timings should not be taken at face value](img/Figure_5.01_B17266.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 喷溅屏幕序列的分镜。由于是草图，给出的时间数字不应直接作为依据](img/Figure_5.01_B17266.jpg)'
- en: Figure 5.1 – Storyboard for the Splash Screen sequence. Being a sketch, the
    numbers given for timings should not be taken at face value
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 喷溅屏幕序列的分镜。由于是草图，给出的时间数字不应直接作为依据
- en: Let’s break this diagram down a bit by walking through the scene in a temporal
    order. At time = 0, we have a blank stage (screen). After 2 seconds have passed,
    the first panel with the words “Powered By” is fully visible. Half (0.5) a second
    after that (or T+2.5s) marks the beginning of the exit sub-sequence, which completes
    with the panel fully hidden another half a second later. The total amount of time
    that the first panel depicts is 3 seconds. Armed with that explanation, the other
    three panels should also make sense. Each panel progresses the scene forward,
    starting at the top-left, moving right, and wrapping back to the left panel, respectively.
    The image shown in a panel fades in and out according to the given timings, but
    those numbers should be used as rough guide markers only – it’s important to tweak
    the values to what you like.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过按时间顺序走过场景来逐步分析这个图表。在时间=0时，我们有一个空白的舞台（屏幕）。经过2秒钟后，带有“由...提供支持”字样的第一个面板完全可见。在那之后半秒（或T+2.5秒）标志着退出子序列的开始，另一个半秒后（或T+3秒）面板完全隐藏。第一个面板描述的总时间是3秒。有了这个解释，其他三个面板也应该是有意义的。每个面板都推进场景，从左上角开始，向右移动，然后回到左面板。面板中显示的图像根据给定的时序淡入淡出，但那些数字应该仅用作粗略的指南标记——重要的是要调整这些值到你喜欢的程度。
- en: If you were to compare the storyboard with the final splash screen sequence,
    there are some gross similarities; the panels are all mostly the same and in the
    same order, the timings notated are roughly the same, and more. That shows the
    evolution of the design from start to finish and serves to drive home a central
    point of storyboarding – the boards are not the whole story! These admittedly
    crude sketches serve the purpose of putting a stake in the ground, giving loose
    definition to the basic elements and timings involved so that we can focus on
    other aspects of implementation – such as the code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将故事板与最终的启动屏幕序列进行比较，会发现一些明显的相似之处；面板几乎都是相同的，顺序也相同，标注的时间也大致相同，等等。这显示了设计从开始到结束的演变，并有助于强调故事板的一个核心观点——这些板不是全部的故事！这些诚实的草图是为了确定一个基准，为涉及的基本元素和时序提供一个大致的定义，这样我们就可以专注于其他实施方面——比如代码。
- en: Building the Scene
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建场景
- en: There is only one new concept that we haven’t encountered yet that we’ll need
    to learn to build out the Splash Screen in code. Everything else will use a combination
    of techniques that we’ve used in previous chapters in one way or another, so hopefully,
    this will seem pretty easy! For this part of the chapter, we’ll be working exclusively
    in the **PlayGround** (**PG**) – if you’re following along, this is where you’ll
    want to load up the PG with a new snippet.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中构建启动屏幕时，需要学习的一个新概念就是我们尚未遇到过的。其他所有内容都将使用我们在前几章中以一种或另一种方式使用过的技术组合，所以希望这看起来相当简单！对于本章的这一部分，我们将专门在**PlayGround**（**PG**）中工作——如果你在跟随，这就是你想要加载PG并添加新片段的地方。
- en: Important note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Code listings will continue to become less complete and more focused on specific
    aspects or areas of the code under discussion that are important, tricky, or non-obvious.
    The complete code for this chapter can be found at [https://github.com/jelster/space-truckers/tree/ch5](https://github.com/jelster/space-truckers/tree/ch5).
    Don’t hesitate to pull it up to compare your progress against it or check your
    work – sometimes, an explanation just won’t cut it and you need to see working
    code!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码列表将继续变得更加完整，更多地关注讨论中的特定方面或代码区域，这些方面或区域是重要的、棘手的或非直观的。本章的完整代码可以在[https://github.com/jelster/space-truckers/tree/ch5](https://github.com/jelster/space-truckers/tree/ch5)找到。不要犹豫，将它拉出来，与你的进度进行比较或检查你的工作——有时候，解释是不够的，你需要看到正在工作的代码！
- en: When we break out the various animated sequences outlined in the storyboard,
    there’s an immediate structure or way of ordering the cut scene that sticks out
    right away. Each board in the storyboard represents a distinct snapshot of what
    is happening at a given time in the scene, so we need to come up with a way to
    represent these cut scene segments in code. We want it to be a reusable component,
    and we want to be able to use The Power of `CutSceneSegment`, and a new `SplashScene`
    class can be used to compose and manage those segments with proper timings and
    transitions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从故事板中分离出各种动画序列时，场景的立即结构或排序方式会立即显现出来。故事板中的每一块代表场景在特定时间发生的一个独特的快照，因此我们需要想出一个在代码中表示这些场景片段的方法。我们希望它是一个可重用的组件，并且我们希望能够使用
    `CutSceneSegment` 的力量，以及一个新的 `SplashScene` 类，可以用来组合和管理这些片段，并具有适当的时序和过渡。
- en: The CutSceneSegment Class
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`CutSceneSegment` 类'
- en: The `CutSceneSegment` class is a simple container that can represent an atomic
    portion of the scene’s sequence, but although it is simple, it isn’t devoid of
    any behaviors. A `CutSceneSegment` should be able to `start` and `stop` its sequence,
    potentially looping playback. Similarly, other components may need to know when
    a segment completes, so a `onEnd` observable will make it easier for us to write
    controlling logic to manage multiple segments in sequence. Because we don’t hate
    ourselves and we don’t want to spend time debugging mysteriously misbehaving code,
    we’ll treat an instance of a `CutSceneSegment` as **immutable**. That is, once
    we’ve created the object, we’re not going to try to change it by say, swapping
    out the contained animations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`CutSceneSegment` 类是一个简单的容器，可以表示场景序列的原子部分，尽管它很简单，但并非没有行为。一个 `CutSceneSegment`
    应该能够 `start` 和 `stop` 其序列，可能还会循环播放。同样，其他组件可能需要知道何时完成一个片段，因此一个 `onEnd` 可观察者将使我们更容易编写控制逻辑来管理多个片段的顺序。因为我们不恨自己，也不想花时间调试神秘地表现不佳的代码，所以我们将
    `CutSceneSegment` 的实例视为 **不可变**。也就是说，一旦我们创建了对象，我们就不会尝试通过替换包含的动画等方式来改变它。'
- en: Important note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Can you keep a secret? Those who have experience with JavaScript may be thinking
    that the word “immutable” is incorrectly being applied. While it is true that
    from a strictly technical sense, the objects we’re dealing with are not immutable,
    the idea is that we simply pretend it is immutable. If we’re using it as-is, and
    if nobody tells, does it matter whether an object is immutable or not? Be warned,
    though – it’s easy to lose the distinction between ways of thinking about software
    and expressing those concepts in code, so don’t mistake this for language-specific
    guidance!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你能保密吗？有 JavaScript 经验的人可能会认为“不可变”这个词被错误地应用了。虽然从严格的技术意义上讲，我们处理的对象不是不可变的，但我们的想法是，我们只是假装它是不可变的。如果我们按原样使用它，而且没有人告诉，那么一个对象是否不可变有什么关系呢？但是要小心——很容易混淆软件思考的方式和在代码中表达这些概念的方式，所以不要将此误解为特定语言的指导！
- en: Although it would be useful to be able to control multiple target scene elements
    in a single `CutSceneSegment`, we don’t need that complexity to implement the
    scene from our storyboards. This decision, in conjunction with the previous decision
    regarding immutability, has two important implications for how we will write our
    classes’ **constructor**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能够在单个 `CutSceneSegment` 中控制多个目标场景元素会很方便，但我们不需要这种复杂性来实现我们的故事板场景。这个决定与关于不可变性的先前决定相结合，对我们如何编写类的
    **构造函数** 有两个重要的影响。
- en: 'First, we’ll need to get a `target` against which the segment will operate.
    This can be anything capable of being animated, so, pretty much any BJS type you
    may want to animate can be used here (with the notable exception of the types
    in `animationSequence`. Of course, the “ctor” (as the cool kids all call it) will
    need to take a reference to the current scene, which gives us the following signature
    for the method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取一个 `target`，该片段将对其操作。这可以是任何可以动画化的东西，所以，几乎任何你想要动画化的 BJS 类型都可以在这里使用（除了
    `animationSequence` 中的类型。当然，“ctor”（就像酷孩子们称呼的那样）需要引用当前场景，这为我们提供了以下方法签名：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You may be unfamiliar with the highlighted language construct. That’s OK because
    although it’s not uncommon, it’s also not something that you might encounter in
    your everyday JavaScript. The three periods (`.`) before `animationSequence` indicate
    that the parameter is treated as an arbitrary params-style array. This is merely
    a convenient piece of “syntactic sugar” that allows callers of the function to
    avoid the need to create and pass an `Array` and instead pass a comma-separated
    list of the elements comprising the Array. The following code fragment shows arrays
    being passed as the trailing three parameters:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不熟悉高亮显示的语言结构。没关系，因为虽然这并不罕见，但它也不是你可能在日常 JavaScript 中遇到的东西。在 `animationSequence`
    前面的三个点 (`.`) 表示该参数被视为一个任意的 params-style 数组。这仅仅是一块方便的“语法糖”，允许函数的调用者避免创建和传递一个 `Array`，而是传递由逗号分隔的元素列表。下面的代码片段显示了数组作为后跟的三个参数传递：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `CutSceneSegment` constructor, there are two primary things we need
    to accomplish:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CutSceneSegment` 构造函数中，我们需要完成两个主要任务：
- en: Create a `TargetedAnimation` from each Animation in `animationSequence`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `animationSequence` 中的每个动画创建一个 `TargetedAnimation`。
- en: Add the TargetedAnimations to a new `AnimationGroup`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标动画添加到一个新的 `AnimationGroup` 中。
- en: 'Going in reverse order, `AnimationGroup` is something new to the project. Do
    not try to overthink it – it is and does exactly what its name suggests. Next,
    because we already have animations that just need targeting, we can loop through
    the `animationSequence` collection and use AnimationGroup’s `addTargetedAnimation`
    method to complete the binding. The Babylon.js Docs site at [https://doc.babylonjs.com/divingDeeper/animation/groupAnimations](https://doc.babylonjs.com/divingDeeper/animation/groupAnimations)
    has more information on different aspects of the `AnimationGroup` properties and
    methods, but other than the previous looping logic, the usage of an `AnimationGroup`
    is very similar to an individual `Animation`. Having accomplished these tasks,
    all that’s left for the constructor is to delegate the `CutSceneSegment.onEnd`
    member property to `AnimationGroup.onAnimationGroupEndObservable`. Here’s what
    the entire `constructor` looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相反的顺序，`AnimationGroup` 是项目中的新功能。不要试图过度思考它——它确实和它的名字所暗示的一样。接下来，因为我们已经有了只需要定位的动画，我们可以遍历
    `animationSequence` 集合，并使用 `AnimationGroup` 的 `addTargetedAnimation` 方法来完成绑定。关于
    `AnimationGroup` 属性和方法的不同方面的更多信息，请参阅 Babylon.js 文档网站 [https://doc.babylonjs.com/divingDeeper/animation/groupAnimations](https://doc.babylonjs.com/divingDeeper/animation/groupAnimations)。除了之前的循环逻辑之外，`AnimationGroup`
    的使用与单个 `Animation` 非常相似。完成这些任务后，构造函数剩下的就是将 `CutSceneSegment.onEnd` 成员属性委托给 `AnimationGroup.onAnimationGroupEndObservable`。下面是整个
    `constructor` 的样子：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finishing the `CutSceneSegment` class are the `start` and `stop` methods. These
    are extremely simple, and just call the appropriate function of `this.animationGroup`.
    When we want to loop a `CutSceneSegment` – not a typical usage – we can set the
    `loopAnimation` flag to true before calling `start`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 `CutSceneSegment` 类的是 `start` 和 `stop` 方法。这些方法非常简单，只是调用 `this.animationGroup`
    的相应函数。当我们想要循环一个 `CutSceneSegment`（这不是典型的用法）时，我们可以在调用 `start` 之前将 `loopAnimation`
    标志设置为 true：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This completes the `CutSceneSegment` class. It’s ready to be used in the code
    we’re just about to write for the `SplashScene` class, where we’ll be creating
    a segment for each panel in the storyboard before playing them in sequence. First,
    though, let’s add another set of building blocks for our scene – the animations
    driving the scene’s visuals.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `CutSceneSegment` 类。它准备好在即将为 `SplashScene` 类编写的代码中使用，我们将为故事板中的每个面板创建一个段，然后再按顺序播放它们。不过，首先，让我们为场景添加另一组构建块——驱动场景视觉的动画。
- en: The Animations
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画
- en: 'There are only three separate types of animations that we need for the scene.
    The keyframes and targets may be different, but the base property being animated
    is the same. Separate from any class declaration, add declarations for `flipAnimation`,
    `fadeAnimation`, and `scaleAnimation`. To keep the frame rates the same, we declare
    `animationFps` as `const`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于场景，我们只需要三种不同的动画类型。关键帧和目标可能不同，但被动画化的基本属性是相同的。在类声明之外，添加 `flipAnimation`、`fadeAnimation`
    和 `scaleAnimation` 的声明。为了保持帧率相同，我们将 `animationFps` 声明为 `const`：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This should be pretty familiar by now, except for the highlighted `true` parameter;
    this instructs the Babylon.js animation engine to enable the animation to be blended
    with others. It’s not necessarily something we’re leveraging immediately in the
    scene, but it’s important to configure it correctly at the outset for when it’s
    needed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这应该已经很熟悉了，除了高亮显示的`true`参数；这指示Babylon.js动画引擎使动画能够与其他动画混合。这并不一定是我们立即在场景中利用的东西，但一开始正确配置它对于将来需要时是很重要的。
- en: Important note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the BJS PlayGround, IntelliSense may sometimes confuse the `BABYLON.Animation`
    type with browser or DOM types with the same name. Adding the `BABYLON` prefix
    can help clear up confusion, but remember to remove it later – you won’t need
    it when the code is integrated locally.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BJS PlayGround 中，IntelliSense 有时会将 `BABYLON.Animation` 类型与具有相同名称的浏览器或 DOM
    类型混淆。添加 `BABYLON` 前缀可以帮助消除混淆，但记住稍后要移除它——当代码本地集成时，你不需要它。
- en: The pieces have all been prepared and moved into place for us to start constructing
    the `SplashScene` class, where we’ll create and assemble CutSceneSegments into
    a complete scene.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有部件都已准备就绪并放置到位，以便我们开始构建 `SplashScene` 类，我们将创建并组装 CutSceneSegments 以形成一个完整的场景。
- en: The SplashScene Class
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SplashScene 类
- en: 'When designing a class or component’s code structure, a good way to start can
    be simply identifying and capturing any currently known variables of the state
    as class members, even if the value won’t be set until later. One such example
    of this is `currentSegment`. This property holds the currently playing `CutSceneSegment`.
    We’ll populate the various segments in the constructor, but by declaring the members
    outside of `constructor` (as opposed to defining it in the `this.foo = 3`), we
    improve the readability of the code – something that is incredibly important in
    any code destined for production! Here are the class members that we’ll want to
    define:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计类或组件的代码结构时，一个好的开始方式可能是简单地识别和捕获任何目前已知的状态变量作为类成员，即使其值将在稍后设置。这样的一个例子就是 `currentSegment`。这个属性持有当前正在播放的
    `CutSceneSegment`。我们将在构造函数中填充各种片段，但通过在 `constructor` 外声明成员（而不是在 `this.foo = 3`
    中定义它），我们提高了代码的可读性——这对于任何面向生产的代码来说都是极其重要的！以下是我们想要定义的类成员：
- en: '`currentSegment`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentSegment`'
- en: '`poweredBy`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poweredBy`'
- en: '`babylonBillboard`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babylonBillboard`'
- en: '`communityProduction`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`communityProduction`'
- en: '`dedication`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dedication`'
- en: '**onReadyObservable = new Observable()**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onReadyObservable = new Observable()**'
- en: '**skipRequested = false**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**skipRequested = false**'
- en: Each of the preceding segments (save the highlighted ones, for obvious reasons)
    corresponds to a panel on the storyboard – in order of execution to help with
    readability. Though we won’t use it until later in this chapter, `onReadyObservable`
    is there to signal that all the assets have finished loading and the cutscene
    is ready to start. It’s a similar situation with `skipRequested` – later in this
    chapter, we’ll add the ability for players to skip the cut scene, so adding this
    now is legitimate. Adding the small pieces of code to hook it up is trivial too
    since we’re already working in that area, and it’s one less thing to worry about
    later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的每个片段（除了高亮显示的，很明显的原因）都对应于故事板上的一个面板——按照执行顺序，有助于提高可读性。尽管我们将在本章的稍后部分使用它，但 `onReadyObservable`
    存在是为了表示所有资产都已加载完成，并且剪辑场景准备开始。`skipRequested` 的情况类似——在本章的稍后部分，我们将添加玩家跳过剪辑场景的能力，所以现在添加它是合理的。由于我们已经在那个区域工作，添加连接它的少量代码也很简单，这又少了一件需要担心的事情。
- en: There will be enough setup code in the constructor as it is, so a forward-thinker
    might consider adding method stubs to encapsulate each segment’s setup process!
    Turning our attention to the `createScene` function, we want to start seeing things
    as soon as possible, so let’s hook up one end of the logic, which will allow our
    segments to transition between each other.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中已经有了足够的设置代码，所以一个有前瞻性的人可能会考虑添加方法占位符来封装每个片段的设置过程！将注意力转向 `createScene` 函数，我们希望尽快看到东西，所以让我们连接逻辑的一端，这将允许我们的片段在彼此之间转换。
- en: 'Just as our previous PlayGround snippets have been structured, the `SplashScene`
    constructor needs a `BABYLON.Engine` instance passed as a parameter, which it
    uses to create the scene. Also similar is the sparse and simple `createScene`
    function, which is used purely in the PlayGround. In case a refresher is needed,
    here’s how to hook up the code with the Playground in the body of `createScene`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的 PlayGround 片段结构一样，`SplashScene` 构造函数需要一个 `BABYLON.Engine` 实例作为参数传递，它使用这个实例来创建场景。同样简单的是
    `createScene` 函数，它仅在 PlayGround 中使用。如果需要复习，以下是如何在 `createScene` 的主体中将代码与 PlayGround
    连接起来的方法：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to be able to discretely control when `SplashScene` starts and stops,
    so the constructor isn’t going to be the place to start playing CutSceneSegments.
    Instead, we’ll add a `run` method (highlighted in the preceding snippet) to perform
    those duties in response to a signal from `onReadyObservable`. Now, as we enhance
    and expand `SplashScene`, we’ll be able to build off from this without having
    to worry about getting everything to start at the same time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够离散地控制 `SplashScene` 的开始和停止，因此构造函数不是开始播放 CutSceneSegments 的地方。相反，我们将添加一个
    `run` 方法（在前面的片段中突出显示），以响应 `onReadyObservable` 的信号来执行这些任务。现在，随着我们对 `SplashScene`
    进行增强和扩展，我们将能够在此基础上构建，而无需担心所有内容同时开始。
- en: The `SplashScreen.run()` function looks very similar to the `run` function of
    the `SpaceTruckerApplication` run function if you squint enough and possibly stare
    unprotected at the sun for a bit.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你眯起眼睛足够多，并且可能暂时没有保护地盯着太阳看，`SplashScreen.run()` 函数看起来非常类似于 `SpaceTruckerApplication`
    运行函数中的 `run` 函数。
- en: Important note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Do not look directly at the sun without proper eye protection! Sunglasses, even
    ones that block UV radiation, are not sufficient protection for eyes, and permanent
    damage may result. On a related note, never take advice on what to do in the outdoors
    from a technical book on programming. HTH.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有适当的眼部保护的情况下，不要直接看太阳！即使是有阻挡紫外线功能的太阳镜，对眼睛的保护也不充分，可能会导致永久性损伤。相关的是，永远不要从编程技术书籍中获取户外活动的建议。祝你好运。
- en: 'The reason they look similar to each other is that they both serve similar
    duties. Similar problems face similar solutions and all, so here we are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来如此相似的原因是它们都执行类似的功能。面临相似问题，解决方案也相似，所以我们就到这里：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Even though this scene doesn’t use the `function*` generators that we saw in
    the previous chapter, it still qualifies as a simple type of state machine. The
    current state (represented by `currentSegment`) is polled on every frame and compared
    with the previous frame’s value. If they are different, then it means that a new
    segment has been swapped in and must have its `start` method invoked to continue
    the sequence. Because it’s so straightforward, and again because we’re already
    here, the logic for managing the use case where the player wishes to skip the
    cutscene and go straight to the Main Menu gets added as well. The only real items
    of note are the combination of setting `this.currentSegment = null` with the `?.`
    operators to prevent any attempt to call a method on an undefined value; if `currentSegment`
    is null (from the viewpoint of the code), then the cutscene either hasn’t started
    yet, or it has finished.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个场景没有使用我们在上一章中看到的 `function*` 生成器，但它仍然符合简单状态机的类型。当前状态（由 `currentSegment`
    表示）在每一帧都会被轮询并与前一帧的值进行比较。如果它们不同，那么这意味着一个新的片段已经被交换进来，并且必须调用其 `start` 方法来继续序列。由于它非常直接，而且因为我们已经在这里，所以还添加了管理玩家希望跳过预告片直接进入主菜单用例的逻辑。唯一真正值得注意的事项是，将
    `this.currentSegment = null` 与 `?.` 操作符组合起来，以防止对未定义值调用方法；如果 `currentSegment` 为空（从代码的角度来看），那么预告片要么还没有开始，要么已经结束。
- en: 'To provide a stable platform for creating the CutSceneSegments, there are still
    a few things that we need to add to the constructor logic, as shown in the following
    code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个稳定的平台来创建 CutSceneSegments，我们还需要在构造函数逻辑中添加一些内容，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Setting up the scene, camera, and light should be pretty standard by now, and
    although the `billboard` `camera` to render the scene, there’s `light` to illuminate
    `billboard`, and there’s `billboard` to display our content – whatever that may
    be! We want the billboard to face perpendicular to the camera’s view, hence setting
    the initial rotations. The values may seem a bit weird, but they will all make
    sense shortly. Now that we have the framework to render the cutscene, it’s time
    to start defining the cutscene segments! We’ve gone quite a bit without saving
    (or not, if you’re well disciplined!), so now’s a good time to run the snippet
    and check for any obvious issues or errors before saving it for posterity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景、摄像机和灯光现在应该相当标准了，尽管使用`billboard`摄像机渲染场景，有`light`照亮`billboard`，还有`billboard`显示我们的内容——无论那是什么！我们希望`billboard`垂直于摄像机的视图，因此设置初始旋转。这些值可能看起来有点奇怪，但很快就会变得有意义。现在我们已经有了渲染剪辑场景的框架，是时候开始定义剪辑场景片段了！我们已经进行了一些操作而没有保存（或者如果你有很好的自律，可能没有），所以现在是运行代码片段并检查任何明显的问题或错误的好时机，然后再保存以备将来参考。
- en: The “Powered By” CutScene Segment
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “由我们提供动力”的剪辑场景片段
- en: 'Referring to our initial storyboard, as our first segment, we’ve got a billboard
    displaying a stylized “Powered By” image. The timings make sense, and it’s perfectly
    serviceable. However, the problem with it is that it’s just plain outright *boring*.
    Let’s spice it up a bit by having the billboard spin around slowly throughout
    the segment using `flipAnimation` we created earlier. At the same time, we’ll
    apply `fadeAnimation` to fade the billboard in and out at the appropriate times.
    To keep the constructor to a manageable size, add a new class member function
    to `SplashScene` and call it `buildPoweredByAnimations`. Then, in the body of
    the function, start by declaring constants for each of the key timing events of
    the segment:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 参考我们的初始故事板，作为我们的第一个片段，我们有一个显示风格化的“由我们提供动力”图像的`billboard`。时间设置是合理的，而且完全可用。然而，它的问题是它太无聊了。让我们通过在整个片段中缓慢旋转`billboard`来增加一些趣味，使用我们之前创建的`flipAnimation`。同时，我们将在适当的时间应用`fadeAnimation`来淡入淡出`billboard`。为了保持构造函数的大小在可控范围内，向`SplashScene`添加一个新的成员函数，并将其命名为`buildPoweredByAnimations`。然后，在函数体中，首先为片段的每个关键时间事件声明常量：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The values in the preceding snippet were arrived at through experimentation,
    so feel free to try out other values until you find something that works right
    for you. With absolute timing values computed, we can also compute the associated
    frame number for each timing event:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段中的值是通过实验得到的，所以请随意尝试其他值，直到找到适合你的正确值。在计算出绝对时间值后，我们还可以计算每个时间事件相关的帧号：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These frame numbers are important when we want to define the animations’ `flipKey`
    values represent the **y** component of the target’s **rotation**:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要定义动画的`flipKey`值代表目标的**旋转**的**y**分量时，这些帧号很重要：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After defining each of the relevant keyframes according to the computed frame
    timings, it’s important to pass those keyframes onto the animation by calling
    `setKeys`. This works with our plan for reusing `Animations` because the keyframes
    are copied into the resulting `TargetAnimation` instance created when associated
    with its target; we can just call `setKeys` again with a new set of keyframes
    whenever needed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在根据计算出的帧时间定义了每个相关的关键帧之后，将那些关键帧通过调用`setKeys`传递给动画是很重要的。这符合我们重用`Animations`的计划，因为关键帧被复制到与目标关联时创建的`TargetAnimation`实例中；我们只需在需要时再次调用`setKeys`并使用一组新的关键帧即可。
- en: Important note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The pattern that we’re establishing here for this `CutSceneSegment` will be
    used for the rest of the segments. In other words, this will be on the test!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个`CutSceneSegment`建立的模式将被用于其余的片段。换句话说，这将在测试中用到！
- en: 'The final thing our `buildPoweredByAnimations` function needs to do is create
    and return a new `CutSceneSegment` that puts everything together:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`buildPoweredByAnimations`函数需要做的最后一件事是创建并返回一个新的`CutSceneSegment`，将所有内容组合在一起：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Back in the `SplashScene` constructor is where we’ll invoke the `buildPoweredByAnimations`
    function to create a `poweredBy` object variable. Assigning `poweredBy` to `this.currentSegment`
    will ensure that when `run` is called, the sequence is started. Following that,
    we need to load up the “Powered By” image as a texture that we can use with `billMat`.
    Since this involves an external image asset, add top-level declarations for the
    full URL to the image files (see the previous chapter for more on constructing
    the full GitHub URL for an asset). In this initial case, it’ll be a file called
    [https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/powered-by.png](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/powered-by.png).
    Use that URL to construct a new `billMat.diffuseTexture` property.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SplashScene` 构造函数中，我们将调用 `buildPoweredByAnimations` 函数来创建 `poweredBy` 对象变量。将
    `poweredBy` 分配给 `this.currentSegment` 将确保当调用 `run` 时，序列开始。之后，我们需要加载“由…提供支持”的图像作为纹理，我们可以使用
    `billMat`。由于这涉及到外部图像资产，请添加对图像文件的顶级声明（有关构建资产的完整 GitHub URL 的更多信息，请参阅上一章）。在这个初始情况下，它将是一个名为
    [https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/powered-by.png](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/powered-by.png)
    的文件。使用该 URL 构建一个新的 `billMat.diffuseTexture` 属性。
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure you load the texture before assigning it to the material!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在将其分配给材质之前加载纹理！
- en: When running, you should see the image on the surface of the billboard plane,
    which is a good way to test your work before saving it!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，你应该在广告牌平面上看到图像，这是在保存之前测试你工作的好方法！
- en: Transitioning to the Next CutSceneSegment… and Beyond
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换到下一个 CutSceneSegment…以及更远的地方
- en: 'When a `CutSceneSegment` begins running, it may make certain assumptions about
    the current state of the different actors and set pieces involved in a scene.
    For instance, a lighting animation that dims a light in a specific pattern may
    need the intensity values to start at a specific level. At the same time, a given
    segment can’t “know” anything about other segments or their relationships – with
    a single crucial, albeit caveated exception. Upon completion of a `CutSceneSegment`,
    the `onEnd` `onEnd` observable is the ideal solution – and at the same time is
    also the caveat! To keep some local variables in the constructor conveniently
    in scope, we can call `onEnd.addOnce(() => { … })`. The body of the function is
    where we want to tidy up objects in the scene, along with designating the next
    segment in the Splash Scene sequence:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `CutSceneSegment` 开始运行时，它可能会对场景中涉及的不同演员和场景元素的状态做出某些假设。例如，一个以特定模式减弱灯光的照明动画可能需要强度值从特定水平开始。同时，一个给定的部分不能“知道”关于其他部分或它们之间关系的任何信息——尽管有一个至关重要的、但有保留的例外。在
    `CutSceneSegment` 完成后，`onEnd` 可观察者是理想的解决方案——同时也是一个保留条件！为了在构造函数中方便地保持一些局部变量在作用域内，我们可以调用
    `onEnd.addOnce(() => { … })`。函数体是我们想要整理场景中的对象的地方，同时指定 Splash Scene 序列中的下一个部分：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our immediate case, the next segment is going to be the `babylonBillboard`
    segment, so make the last statement be `this.currentSegment = babylonBillboard`
    in the `poweredBy.onEnd` handler. Before that expression, we need to reset the
    `billMat.diffuseTexture` for the Babylon.js logo texture.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们立即的情况下，下一个部分将是 `babylonBillboard` 部分，所以在 `poweredBy.onEnd` 处理器中使最后一个语句为 `this.currentSegment
    = babylonBillboard`。在表达式之前，我们需要重置 Babylon.js 标志纹理的 `billMat.diffuseTexture`。
- en: Important note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Before moving on to the next segment, it’s a good idea to try and run the PlayGround
    snippet to see how it looks and test it for any major errors. Opening the browser's
    Dev Tools to see logged messages can help you gain a sense of timing!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到下一个部分之前，尝试运行 PlayGround 片段以查看其外观并测试是否存在任何重大错误是个好主意。打开浏览器的开发者工具查看记录的消息可以帮助你获得对时间的感觉！
- en: 'What’s that? The new segment doesn’t exist and neither does the `buildBabylonAnimation`
    function: for the texture, use [https://raw.githubusercontent.com/BabylonJS/Brand-Toolkit/master/babylonjs_identity/fullColor/babylonjs_identity_color.png](https://raw.githubusercontent.com/BabylonJS/Brand-Toolkit/master/babylonjs_identity/fullColor/babylonjs_identity_color.png)
    and for `animationSequence`, use `fadeAnimation`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那是什么？新的部分不存在，`buildBabylonAnimation` 函数也不存在：对于纹理，使用 [https://raw.githubusercontent.com/BabylonJS/Brand-Toolkit/master/babylonjs_identity/fullColor/babylonjs_identity_color.png](https://raw.githubusercontent.com/BabylonJS/Brand-Toolkit/master/babylonjs_identity/fullColor/babylonjs_identity_color.png)
    和对于 `animationSequence`，使用 `fadeAnimation`：
- en: '![](img/Table_5.01_B17266.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_5.01_B17266.jpg)'
- en: After adding the `buildBabylonAnimation` method, make sure to call it in the
    constructor so that you can subscribe to the new segment’s `onEnd` observable.
    In the `babylonBillboard.onEnd` handler, there’s no need to reposition the billboard
    since it didn’t move during this segment, but there is the matter of teeing up
    the next one, in what is hopefully a familiar cadence.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`buildBabylonAnimation`方法后，请确保在构造函数中调用它，以便您可以订阅新段落的`onEnd`可观察对象。在`babylonBillboard.onEnd`处理程序中，由于在此段落中没有移动，因此不需要重新定位billboard，但需要为下一个段落做好准备，希望这是一个熟悉的节奏。
- en: 'The next segment is called `communityProduction` and is functionally identical
    to the previous segment save for a different texture, located at [https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/splash-screen-community.png](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/splash-screen-community.png).
    It is also just using `fadeAnimation`. Here are the main relevant timings and
    numbers needed:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个段落被称为`communityProduction`，在功能上与上一个段落相同，只是纹理不同，位于[https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/splash-screen-community.png](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/splash-screen-community.png)。它也仅使用`fadeAnimation`。以下是该段落中需要的主要相关时间和数字：
- en: '![](img/Table_5.02_B17266.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_5.02_B17266.jpg)'
- en: Just like the previous segment, the `communityProduction.onEnd` handler will
    be responsible for setting the next segment – `callToAction` – and swapping `billMat.diffuseTexture`
    to the next one, which for lack of any better name will be called `rigTexture`.
    This texture is rendered onto the `billboard` mesh, where after fading in we’ll
    apply a looping animation to its `scaling` property to make it look more dynamic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一个段落一样，`communityProduction.onEnd`处理程序将负责设置下一个段落 – `callToAction` – 并将`billMat.diffuseTexture`更改为下一个，由于缺乏更好的名称，我们将称之为`rigTexture`。这种纹理被渲染到`billboard`网格上，在淡入后，我们将对其`scaling`属性应用循环动画，使其看起来更加动态。
- en: Important note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The storyboard indicates this panel is where copyright notices and such would
    go, but there’s no reason those can’t go someplace else that’s equally useful
    but less prominent. Instead, we’ll make the panel contain a Space-Trucker image,
    with the image slowly pulsing the scale and opacity in a ready-wait indication
    state, waiting for the player to interact.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 故事板指示这个面板是版权声明等内容的所在地，但没有任何理由这些内容不能放在其他同样有用但不太突出的地方。相反，我们将使该面板包含一个Space-Trucker图像，该图像将以准备等待指示状态缓慢地脉冲缩放和透明度，等待玩家交互。
- en: In a short while, we will be adding some input management. To prepare for that,
    we’re going to need a way to display some appropriately formatted Text. In a block.
    A sort of `TextBlock`, as it were. Our `SplashScreen` is going to need to use
    the **BABYLON.GUI**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在不久的将来，我们将添加一些输入管理。为此，我们需要一种显示适当格式化文本的方法。在一个块中。就像一个`TextBlock`一样。我们的`SplashScreen`将需要使用**BABYLON.GUI**。
- en: The Last Segment
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最后一个段落
- en: 'Our final `CutSceneSegment` – `callToAction` – follows a similar path that
    the others have taken, in that we use `billBoard` to display a `diffuseTexture`
    that fades into the scene. Here is where the segments start to diverge because
    instead of fading out again, we want it to fade in and then loop around without
    ever completely fading away. At the same time, we will use `scaleAnimation` to
    vary the scale of the `billboard` mesh along its *X*- and *Z*-axes. This will
    give the two-dimensional flat image a fake appearance of depth and scale as the
    animation cycles, which means that it looks cool! Here are the timings for each
    animation in the segment:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终`CutSceneSegment` – `callToAction` – 跟随了与其他相似的路径，即我们使用`billBoard`来显示一个`diffuseTexture`，使其淡入场景。在这里，段落开始出现分歧，因为不是再次淡出，我们希望它淡入然后循环，永远不会完全淡出。同时，我们将使用`scaleAnimation`来改变`billboard`网格沿其*X*-和*Z*-轴的缩放。这将给二维平面图像在动画循环时带来深度和缩放的假象，这意味着它看起来很酷！以下是该段落中每个动画的时间安排：
- en: '![](img/Table_5.03_B17266.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_5.03_B17266.jpg)'
- en: When the end timing is reached, we want our **Call To Action** (**CTA**) text
    to be made visible, inviting us to press a key or tap their touch screen to continue.
    In another of the Bard’s favorite tricks, here is some foreshadowing (not of the
    shading variety, the literary kind) – the **CTA** serves the subtle purpose of
    allowing the application to figure out what type of input the player wants to
    use. It’s an incredibly direct means of communication between two entities that
    otherwise have almost zero capability to understand each other, and it works because
    its binary (the irony! It burns!) simplicity conveys a user’s preference simply
    by them picking up the device and engaging an input.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到结束时间时，我们希望我们的**行动号召**（**CTA**）文本变得可见，邀请我们按下一个键或轻触触摸屏以继续。在巴德最喜欢的技巧之一中，这里有一些预示（不是阴影那种，而是文学上的）——**CTA**的微妙目的是让应用程序能够弄清楚玩家想使用哪种输入。这是两个实体之间的一种非常直接的联系手段，否则它们几乎没有任何能力理解对方，而且它之所以有效，是因为它的二进制（讽刺！它燃烧！）简单性通过玩家拿起设备并参与输入来传达用户的偏好。
- en: 'Before we go there, we need to wrap up the implementation of the constructor
    by creating `BABYLON.GUI.AdvancedDynamicTexture` mentioned earlier: `callToActionTexture`.
    Creating, configuring the properties of, and adding a `TextBlock` to a GUI is
    a familiar exercise by now (though stick around for [*Chapter 10*](B17266_10_Final_AM.xhtml#_idTextAnchor207),
    *Improving the Environment with Lighting and Materials,* where we’ll introduce
    the GUI Editor!), so the next listing should require very little explanation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要通过创建前面提到的`BABYLON.GUI.AdvancedDynamicTexture`来完成构造函数的实现：`callToActionTexture`。创建、配置GUI的属性并向其中添加`TextBlock`现在已经成为一项熟悉的练习（尽管在[*第10章*](B17266_10_Final_AM.xhtml#_idTextAnchor207)“通过光照和材质改进环境”中，我们将介绍GUI编辑器！），所以接下来的列表应该不需要太多解释：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One thing not to forget is to set the initial visibility of `ctaBlock` (highlighted)
    to `false`. If you want to display it sooner than in the handler for `callToAction.onEnd`,
    go ahead – it’s your game! Once you’ve gotten everything added to the constructor,
    give it a whirl and fix any errors that come up. Hit **Save**, then make sure
    you either put on headphones or can otherwise crank up your computer’s audio –
    it’s time to put in the theme song!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有一样东西不要忘记，那就是将`ctaBlock`（突出显示）的初始可见性设置为`false`。如果你想在`callToAction.onEnd`的处理程序之前显示它，那就去做吧——这是你的游戏！一旦你将所有内容添加到构造函数中，就试试看并修复出现的任何错误。点击**保存**，然后确保你戴上耳机或以其他方式提高电脑的音量——是时候加入主题曲了！
- en: Fading in the Title Music
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 淡入标题音乐
- en: After working on this `SplashScene` for so long by now, it’s probably started
    to feel a bit bland, and that is something we will not accept any longer. In [*Chapter
    4*](B17266_04_Final_AM.xhtml#_idTextAnchor070), *Creating the Application*, we
    added the Space-Truckers main theme song to the `SplashScene` twist.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们已经对`SplashScene`进行了这么长时间的工作，它可能开始显得有点平淡，而这正是我们不能再接受的事情。在[*第4章*](B17266_04_Final_AM.xhtml#_idTextAnchor070)“创建应用程序”中，我们将太空卡车手主题曲添加到了`SplashScene`的转折处。
- en: Recall what was hopefully not-so-long-ago, when you read this gem?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，你希望不是很久以前，你读过这个亮点吗？
- en: “Though we won’t use it until later in this chapter, onReadyObservable is there
    to signal that all the assets have finished loading and the cutscene is ready
    to start.”
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: “尽管我们将在本章的后面部分才会使用它，但`onReadyObservable`用于指示所有资源已加载完成，场景准备开始。”
- en: 'Well, “later in this chapter” starts right now. Since we’ve already put everything
    else into place, there are only four tasks left to wrap up this bad boy and take
    ‘er home:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，“本章后面的部分”现在就开始。由于我们已经将其他所有东西都安排妥当，现在只剩下四个任务来完成这个家伙并带它回家：
- en: Add a string to hold the URL to the song (or substitute your own) at [https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/music/space-trucker-title-theme.m4a](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/music/space-trucker-title-theme.m4a).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/music/space-trucker-title-theme.m4a](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/music/space-trucker-title-theme.m4a)添加一个字符串来保存歌曲的URL（或替换你自己的）。
- en: Create a new `SplashScene.onReadyObservable.notifyObservers` in the `readyToPlayCallback`.
    Set the volume really low – `0.01` works nicely – to give the volume room to grow.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`readyToPlayCallback`中创建一个新的`SplashScene.onReadyObservable.notifyObservers`。将音量设置得非常低——`0.01`效果很好——以给音量增长留出空间。
- en: Add a call to `this.music.play()` in the `SplashScene.run` method.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SplashScene.run`方法中添加对`this.music.play()`的调用。
- en: Crank up the volume (also in the `run` method) over some time by calling `this.music.setVolume(0.998,
    500)`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `this.music.setVolume(0.998, 500)` 在一段时间内提高音量（也在 `run` 方法中）。
- en: Do the usual drill of running, fixing issues, repeating as needed, and then
    saving. If you run into trouble or want to compare your results with a known “working”
    snippet, check out [https://playground.babylonjs.com/#DSALXR](https://playground.babylonjs.com/#DSALXR).
    Still can’t seem to get things working? Head over to the Space-Truckers GitHub
    Discussion boards at [https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions)
    and get help from the community, leave feedback or bug reports, and catch any
    updates to the code since this book was published. Having a runnable sample of
    what you want to accomplish in the PG is a great way to play around with ideas
    and concepts, but now, it’s time to metaphorically remove our more abstract and
    theoretical game designer’s hat and put on our more concrete and pragmatic software
    engineer’s work helmet – we’ll need those qualities as we integrate our PG code
    with the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 执行常规的运行、修复问题、重复所需操作，然后保存。如果您遇到麻烦或想比较您的结果与已知的“工作”片段，请查看 [https://playground.babylonjs.com/#DSALXR](https://playground.babylonjs.com/#DSALXR)。仍然似乎无法让事情正常工作？前往
    Space-Truckers GitHub 讨论板 [https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions)，从社区获得帮助，留下反馈或错误报告，并获取自本书出版以来的代码更新。在
    PG 中有一个可运行的示例，可以帮助您探索想法和概念，但现在，是时候象征性地摘下我们更抽象和理论的游戏设计师帽子，戴上我们更具体和务实的软件工程师工作头盔——在我们将
    PG 代码与应用程序集成时，我们将需要这些品质。
- en: Integrating the SplashScene
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成 SplashScene
- en: The integration phase of the work is where the shiny, pretty, elegant PG Snippet
    meets the hard-faced ugly truth of reality. It’s the part where things are most
    likely to go wrong, and also where bugs in the application code can be uncovered.
    The reason this happens has little to do with the character and attributes of
    the person writing the code, even though it might feel that way sometimes. Any
    bugs or defects uncovered at this point are reflections of what wasn’t known at
    the time the original code was written, and that means there’s an opportunity
    to improve it!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 工作集成阶段是光鲜亮丽的优雅 PG Snippet 与现实世界中冷酷丑陋的真相相遇的地方。这是事情最有可能出错的地方，也是应用程序代码中的错误被揭露的地方。这种情况发生的原因与编写代码的人的性格和属性关系不大，尽管有时可能会感觉是这样。在这个阶段发现的任何错误或缺陷都是对原始代码编写时未知内容的反映，这意味着有机会对其进行改进！
- en: Seeing the Difference
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 看到差异
- en: 'Because you have the benefit of this text to help guide your efforts, you’ll
    be spared having to track down and fix two issues uncovered in the `SpaceTruckerApplication.js`
    component, along with some other changes we’ll make structurally to the class.
    Including the two issues just mentioned, here is a list of the things we need
    to do to integrate `SplashScreen`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您有这份文本的帮助来指导您的努力，您将免于追踪和修复在 `SpaceTruckerApplication.js` 组件中发现的两个问题，以及我们将对类结构进行的其他一些更改。包括上述两个问题，以下是我们需要完成以集成
    `SplashScreen` 的事项列表：
- en: Add new files to `/src - cutSceneSegment.js` and `splashScene.js`
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新文件添加到 `/src - cutSceneSegment.js` 和 `splashScene.js`
- en: Add appropriate imports to new files and copy over class definitions
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新文件中添加适当的导入，并复制类定义
- en: 'The `spaceTruckerApplication.js` file will see the greatest changes with these
    tasks:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`spaceTruckerApplication.js` 文件将经历这些任务带来的最大变化：'
- en: Remove the placeholder `Promises` that were used to simulate loading times in
    `spaceTruckerApplication`. With those gone, we can also remove the `async` designator
    from their hosting functions.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除在 `spaceTruckerApplication` 中用于模拟加载时间的占位符 `Promises`。随着这些占位符的消失，我们也可以从它们的主函数中移除
    `async` 标识符。
- en: Instantiate the Scenes in the `initialize` method instead of previous locations.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `initialize` 方法中实例化场景，而不是之前的地点。
- en: Register an Observer in `goToOpeningCutscene` that listens for the `onReady`
    event.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `goToOpeningCutscene` 中注册一个监听 `onReady` 事件的观察者。
- en: 'And finally, the two issues that would otherwise prevent the application from
    correctly progressing and rendering are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是两个本应阻止应用程序正确进展和渲染的问题：
- en: (Issue) `AppStateMachine` should yield `currentState`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （问题）`AppStateMachine` 应该产生 `currentState`。
- en: (Issue) Logic in the `engine.runRenderLoop` callback needs to be a class-level
    function to access `this` properly. The problem can be resolved by extracting
    the arrow function into a class-level function – that is, `this._engine.runRenderLoop(()
    => this.onRender());`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （问题）在`engine.runRenderLoop`回调中的逻辑需要是一个类级别的函数，以便正确访问`this`。可以通过将箭头函数提取为类级别函数来解决这个问题——即`this._engine.runRenderLoop(()
    => this.onRender());`。
- en: The best way to visualize the changes is to view a `SplashScreen` into the app.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最直观地查看更改的方式是将**启动屏幕**查看为应用程序的一部分。
- en: However it is accessed, the range of revisions we need to compare can be represented
    with the `ch4...6db9f7e` expression. Use this as an argument to `git diff` or
    paste it into a browser as the trailing path to `<repo URL>/compare/<revision
    range>`, or in this case, [https://github.com/jelster/space-truckers/compare/ch4...6db9f7e](https://github.com/jelster/space-truckers/compare/ch4...6db9f7e).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何访问，我们需要比较的修订范围可以用`ch4...6db9f7e`表达式表示。将其用作`git diff`的参数，或者将其粘贴到浏览器中作为`<repo
    URL>/compare/<修订范围>`的尾随路径，或者在这种情况下，[https://github.com/jelster/space-truckers/compare/ch4...6db9f7e](https://github.com/jelster/space-truckers/compare/ch4...6db9f7e)。
- en: Depending on the particulars of your development environment, a **diff** will
    be displayed in a varying number of (pardon the pun) different ways. Regardless
    of the specific tool, almost every **diff** will organize its report by individual
    files that have changed between the given range of revisions. **VSCode’s** **Timeline**
    feature will show the commit history for an opened file; the diff can be viewed
    by clicking the revision in the **Timeline** pane.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的开发环境的具体情况，差异将以不同的方式显示。无论具体工具如何，几乎每个**差异**都会根据给定修订范围内的单个已更改文件组织其报告。**VSCode的**
    **时间轴**功能将显示打开文件的提交历史；可以通过点击**时间轴**面板中的修订版本来查看差异。
- en: Tip
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Making a habit of examining these diffs closely before each commit or merge
    can improve your coding abilities, together with the quality of your code. A good
    sign that you are trying to do too much in a single commit is having a complicated
    and long changeset. Break the work into smaller components and commit each separately,
    and not only will any reviewers of your **Pull Request** (**PR**) thank you, but
    you’ll find yourself moving faster and with greater confidence.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次提交或合并之前养成仔细检查这些差异的习惯可以提高你的编码能力，以及代码的质量。一个迹象表明你可能在一个提交中做了太多事情，就是有一个复杂且长的更改集。将工作分解成更小的组件，并分别提交，这样不仅任何**拉取请求**（**PR**）的审阅者会感谢你，而且你会发现自己在更快、更有信心地前进。
- en: 'The **GitHub** web interface can also be useful for viewing differences between
    **revisions**, **branches**, and even **forks** (also known as **upstream repositories**).
    Navigating through and understanding the different reports is a key skill for
    people who wish to become skilled in software development, but it can be tough
    to block out the inevitable noise that comes with viewing so much information.
    GitHub will try to do some of this for you, by collapsing large diffs by default,
    for instance, but the best way to deal with poor a signal:noise ratio is unfortunately
    not retroactive; it is only useful when applied at the time of **commit** or **push**.
    This solution is to be mindful of and structure commits with a high signal:noise
    ratio from the beginning. Here are some tips for helping with that:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub的网页界面在查看**修订版本**、**分支**甚至**分叉**（也称为**上游仓库**）之间的差异时也非常有用。对于希望成为软件开发高手的人来说，导航和理解不同的报告是一项关键技能，但面对如此多的信息，不可避免地会产生噪音，这可能很困难。GitHub会尝试为你做些这方面的工作，例如默认情况下折叠大的差异，但不幸的是，处理信号与噪音比不佳的方法并不是事后可以追溯的；它只有在**提交**或**推送**时应用才有效。这个解决方案是从一开始就注意并构建具有高信号与噪音比的提交。以下是一些有助于此的建议：
- en: '![](img/Table_5.04_B17266.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Table_5.04_B17266.jpg)'
- en: 'Using the diff as a reference guide when needed, try to accomplish the activities
    listed earlier on your own. Of course, since you’re already looking at the diff,
    you should feel free to simply pull down the code at **commit 6db9f7e** if you’d
    simply like to resume following along right away. The following figure shows a
    still capture of where you should end up after running the application, clicking
    the **Launch** button, and after the conclusion of the Splash Screen:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，将差异用作参考指南，尝试独立完成之前列出的活动。当然，既然你已经在查看差异，如果你只想立即继续，可以自由地拉取**提交6db9f7e**的代码。以下图显示了运行应用程序、点击**启动**按钮以及结束启动屏幕后你应该到达的位置：
- en: '![Figure 5.2 – Splash Screen finished and waiting for user input'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 启动屏幕完成并等待用户输入'
- en: '](img/Figure_5.02_B17266.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.02_B17266.jpg)'
- en: Figure 5.2 – Splash Screen finished and waiting for user input
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 启动屏幕完成并等待用户输入
- en: We’ll get into the nitty-gritty details of all of the items – some familiar,
    some new – contained in that commit’s **patch** soon enough, but before we do,
    let’s quickly recap what we’ve accomplished so far.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会深入探讨那个提交的**补丁**中包含的所有项目 – 一些熟悉，一些新项目 – 的细节，但在我们这样做之前，让我们快速回顾一下到目前为止我们已经取得的成果。
- en: Starting with a set of storyboard panels depicting snapshots of the scene at
    various points in time, we used the boards to pin down timings for the various
    animations and transitions involved. Then, we crafted some reusable code to define
    a `CutSceneSegment`, along with other logic relating to animating objects. Finally,
    we wrote the containing `SplashScreen` class and its attendant asset and `CutSceneSegment`
    orchestration logic that comprises the full timeline of the scene. That’s a lot
    to accomplish – don’t neglect to acknowledge that!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从一组故事板面板开始，这些面板展示了场景在不同时间点的快照，我们使用这些面板来确定各种动画和过渡的时间。然后，我们编写了一些可重用的代码来定义 `CutSceneSegment`，以及其他与动画对象相关的逻辑。最后，我们编写了包含
    `SplashScreen` 类及其相关的资产和 `CutSceneSegment` 协调逻辑的 `SplashScreen` 类，这构成了场景的全时间线。这是一项很大的成就
    – 不要忽视这一点！
- en: 'Next, we’ll be moving on to one of the more under-appreciated areas of game
    development: input systems. Because of its importance, we’ll be devoting the rest
    of this chapter to going over how the Space-Truckers input system functions and
    how it is implemented.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续探讨游戏开发中不太受重视的一个领域：输入系统。鉴于其重要性，我们将在本章的剩余部分详细介绍 Space-Truckers 输入系统的功能和实现方式。
- en: Designing the Input System
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计输入系统
- en: The topic of the **User Interface** (**UI**) often focuses quite heavily on
    visual elements, layout, and design. For the majority of web applications, the
    basics of tracking a pointer, touches, or taps along with keyboard input are handled
    by the web browser, which in turn delegates many responsibilities, such as hardware
    driver interfacing to the underlying **Operating System** (**OS**). When using
    a web-native application library such as Babylon.js, developers can take advantage
    of these already-present abstractions to make it quick and easy to add user interaction
    elements to their scenes. In this section, we’ll learn how to add the application
    scaffolding that can support multiple types of inputs on-the-fly, followed by
    implementing a way to map arbitrary inputs to actions or commands in the game.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户界面**（**UI**）的主题通常非常重视视觉元素、布局和设计。对于大多数网络应用来说，跟踪指针、触摸或点击以及键盘输入的基本功能由网络浏览器处理，它反过来将许多责任委托给底层**操作系统**（**OS**）。当使用像
    Babylon.js 这样的网络原生应用程序库时，开发者可以利用这些已经存在的抽象来快速轻松地将用户交互元素添加到他们的场景中。在本节中，我们将学习如何添加可以动态支持多种输入的应用程序框架，然后实现将任意输入映射到游戏中的动作或命令的方法。'
- en: 'It’s said that imitation is the sincerest form of flattery, so let’s flatter
    the Babylon.js team by “stealing” (called “researching” in polite company) the
    camera input management code. Using the **FreeCamera** as an example (read about
    it at [https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts](https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts)),
    here is how the data flows between the controller and the application:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 据说，模仿是最真诚的赞美形式，所以让我们通过“窃取”（在礼貌的场合被称为“研究”）Babylon.js 团队的相机输入管理代码来赞美他们。以 **FreeCamera**
    为例（了解更多信息请参阅 [https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts](https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts))，以下是控制器和应用程序之间数据流的方式：
- en: '![Figure 5.3 – Flow of input from a Human Input Device (HID) through the Web
    Browser’s APIs, to the HTML/Canvas and into Babylon.js and the various components
    of the FreeCamera’s input system](img/Figure_5.03_B17266.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 从人类输入设备（HID）通过网络浏览器的 API 流入，到 HTML/Canvas，再到 Babylon.js 以及 FreeCamera
    输入系统的各个组件](img/Figure_5.03_B17266.jpg)'
- en: Figure 5.3 – Flow of input from a Human Input Device (HID) through the Web Browser’s
    APIs, to the HTML/Canvas and into Babylon.js and the various components of the
    FreeCamera’s input system
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 从人类输入设备（HID）通过网络浏览器的 API 流入，到 HTML/Canvas，再到 Babylon.js 以及 FreeCamera
    输入系统的各个组件
- en: 'Data starts at the top with the device itself sending data to the connected
    host OS, which (via its device driver interface) translates that raw input data
    into structures compatible and familiar to the web browser or native host interfaces.
    Eventually, it makes its way into Babylon.js, where it is massaged, processed,
    filtered down, and passed around until it reaches the target of its affections:
    the **FreeCamera**. Here is a PG that represents a slightly simplified version
    of the actual input system we’ll be discussing now – use it as a working reference
    if you get lost: [https://playground.babylonjs.com/#78MJJ8#64](https://playground.babylonjs.com/%2378MJJ8%2364).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 数据从顶部开始，由设备本身发送数据到连接的主操作系统，该操作系统（通过其设备驱动程序接口）将原始输入数据转换为与网络浏览器或本地主机接口兼容和熟悉的结构。最终，它进入
    Babylon.js，在那里它被整理、处理、过滤并传递，直到达到其目标：**FreeCamera**。以下是一个PG，它代表我们将要讨论的实际输入系统的略微简化版本——如果您迷路了，请将其用作工作参考：[https://playground.babylonjs.com/#78MJJ8#64](https://playground.babylonjs.com/%2378MJJ8%2364)。
- en: Defining the Main Menu Control Scheme
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义主菜单控制方案
- en: 'Although we won’t be defining control maps for the game phases at this time,
    the foundations we’ll establish with this pattern will make it quick, painless,
    and easy to add whatever arbitrary control maps later as they become necessary.
    The table shows the various inputs and actions that we’ll be interested in handling
    in the Menu system:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在不会为游戏阶段定义控制映射，但我们将使用此模式建立的基石将使添加任何任意控制映射变得快速、轻松且容易，当它们成为必要的时候。该表显示了我们在菜单系统中感兴趣处理的各个输入和动作：
- en: '![Figure 5.4 – Menu controls mapped to various inputs'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.4 – 将菜单控制映射到各种输入'
- en: '](img/Figure_5.04_B17266.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.04_B17266.jpg](img/Figure_5.04_B17266.jpg)'
- en: Figure 5.4 – Menu controls mapped to various inputs
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 将菜单控制映射到各种输入
- en: When it comes to the basic keyboard and (mouse) pointer interactions, the Babylon.js
    `onKeyboardObservable` and `onPointerObservable` properties to allow subscribers
    to be notified of keyboard and mouse (touch) interactions, respectively. `GamepadManager`
    (accessible from a scene’s `gamepadManager` property) and `VirtualJoystick` are
    useful for adding gamepads and their virtual touch equivalents for when mouse
    and keyboard aren’t the goal. You can read more about these in the Babylon.js
    docs at [https://doc.babylonjs.com/divingDeeper/input/virtualJoysticks](https://doc.babylonjs.com/divingDeeper/input/virtualJoysticks)
    and [https://doc.babylonjs.com/divingDeeper/input/gamepads](https://doc.babylonjs.com/divingDeeper/input/gamepads).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到基本的键盘和（鼠标）指针交互时，Babylon.js的`onKeyboardObservable`和`onPointerObservable`属性允许订阅者分别通知键盘和鼠标（触摸）交互。`GamepadManager`（可通过场景的`gamepadManager`属性访问）和`VirtualJoystick`在添加游戏手柄及其虚拟触摸等效物时很有用，当鼠标和键盘不是目标时。您可以在Babylon.js文档中了解更多信息，请参阅[https://doc.babylonjs.com/divingDeeper/input/virtualJoysticks](https://doc.babylonjs.com/divingDeeper/input/virtualJoysticks)和[https://doc.babylonjs.com/divingDeeper/input/gamepads](https://doc.babylonjs.com/divingDeeper/input/gamepads)。
- en: Important note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As alluded to earlier, the topic of input handling is sufficiently complex that
    it would take a great deal of the finite space available in these pages to review
    all the code line by line, so the code that is listed will be highlighted in sections
    under a particular area of discussion. Don’t worry about not being able to follow
    along, though – you can still examine the full source code and the links to PG
    snippets won’t be going away either!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，输入处理的话题足够复杂，以至于需要占用这些页面有限的很大一部分空间来逐行审查所有代码，所以列出的代码将在特定讨论区域的各个部分中被突出显示。尽管如此，您不必担心无法跟上，您仍然可以检查完整的源代码，并且PG片段的链接也不会消失！
- en: Mapping Input Data
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射输入数据
- en: Although the table of controls from the previous section is something that would
    work well in the game or application’s user manual, it’s less clear how the information
    in that table can be leveraged in this application.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上一节中的控制表在游戏或应用程序的用户手册中会很好地工作，但如何利用该表中的信息在这个应用程序中并不那么清晰。
- en: 'A JavaScript `foo[“property”]`), indices will be represented in the new source
    file we’ll call `inputActionMaps.js`. In it, we will define all the various object
    constants and helper functions relating to – as suggested by the name – mapping
    inputs to actions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中映射`foo[“property”]`），索引将在我们称之为`inputActionMaps.js`的新源文件中表示。在其中，我们将定义所有与映射输入到动作相关的各种对象常量和辅助函数：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On the left-hand side (the property name or `button1` and `buttonStart` members.
    Although it seems duplicative and redundant, having a layer of indirection between
    the actual device codes and the logic handling them gives the system a ton of
    flexibility.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧（属性名称或`button1`和`buttonStart`成员。尽管看起来重复且冗余，但在实际设备代码和处理它们的逻辑之间有一个间接层，这为系统提供了大量的灵活性。
- en: 'When it comes to handling the various types of gamepad input, indirection comes
    in handy once again. The `BABYLON.DeviceType` enumeration defines constants for
    each supported type of gamepad device. We’ll use another object map to store how
    each particular device’s inputs matches up to our defined `inputControlsMap`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到处理各种类型的游戏手柄输入时，间接引用再次派上用场。`BABYLON.DeviceType`枚举定义了每个支持的游戏手柄设备的常量。我们将使用另一个对象映射来存储每个特定设备的输入如何与我们的`inputControlsMap`定义相匹配：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code is what the mapping for the Xbox360 controller looks like
    at a very basic level. As the comment indicates, each object in the `deviceType`
    array corresponds to a different input index on the controller.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了Xbox360控制器映射在非常基础的层面上的样子。正如注释所示，`deviceType`数组中的每个对象都对应控制器上的不同输入索引。
- en: 'In a moment, we’ll learn how to use this mapping information at runtime to
    resolve inputs from connected devices, but first, let’s get a bit of a wider perspective
    by taking a small step back – not too far, we don’t want to get overwhelmed in
    it all! The following diagram illustrates the different concerns we’ll need to
    address to be able to handle input in Space-Truckers:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何在运行时使用这种映射信息来解析来自连接设备的输入，但首先，让我们稍微退后一步，以获得更广阔的视角——不要退得太远，我们不想被所有这些内容压垮！以下图表说明了我们需要解决的不同关注点，以便能够处理《Space-Truckers》中的输入：
- en: '![Figure 5.5 – Handling input Part 1 of 4\. This section covers mapping input
    data from multiple devices and types into standardized structures that can be
    resolved to game or application-level actions'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.5 – 处理输入 第1部分/4。本节涵盖了将来自多个设备和类型的输入数据映射到标准化的结构中，这些结构可以解析为游戏或应用级别的操作]'
- en: '](img/Figure_5.05_B17266.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.05_B17266.jpg]'
- en: Figure 5.5 – Handling input Part 1 of 4\. This section covers mapping input
    data from multiple devices and types into standardized structures that can be
    resolved to game or application-level actions
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.5 – 处理输入 第1部分/4。本节涵盖了将来自多个设备和类型的输入数据映射到标准化的结构中，这些结构可以解析为游戏或应用级别的操作]'
- en: Entire books can be written just on the topic of designing the input models
    and such, but the important thing to take away here is that the goal of the code
    we’re writing or are about to write is to hide away (or **abstract**) the details
    of how inputs are processed from the game’s core logic. The game logic doesn’t
    care or need to know about whether a user wants to move their truck with a keyboard
    or a gamepad – it just needs to know that the user wants to move their truck and
    in what direction!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 仅关于设计输入模型等话题，就能写出整本书，但这里要吸取的重要信息是，我们正在编写或即将编写的代码的目标是隐藏（或**抽象**）输入处理细节，使其从游戏核心逻辑中分离出来。游戏逻辑并不关心或需要知道用户是想用键盘还是手柄来移动他们的卡车——它只需要知道用户想要移动他们的卡车以及移动的方向！
- en: Input Management
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入管理
- en: When it comes to managing the specific inputs and devices, `SpaceTruckerInputManager`
    (follow along with the code at [https://github.com/jelster/space-truckers/blob/ch5/src/spaceTruckerInput.js](https://github.com/jelster/space-truckers/blob/ch5/src/spaceTruckerInput.js))
    is responsible for managing the lower-level device management tasks of subscribing
    and unsubscribing to/from device events, retrieving input from the underlying
    Babylon.js input abstraction layers, and preparing it for being processed into
    actions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到管理特定的输入和设备时，`SpaceTruckerInputManager`（请参考代码[https://github.com/jelster/space-truckers/blob/ch5/src/spaceTruckerInput.js](https://github.com/jelster/space-truckers/blob/ch5/src/spaceTruckerInput.js)）负责管理订阅和取消订阅设备事件等低级设备管理任务，从底层Babylon.js输入抽象层检索输入，并将其准备用于处理成动作。
- en: '**Coalescing**, or aggregating input from multiple devices, can be both tricky
    and tedious – not the best combination for anything requiring concentration and
    recall as coding does. Tackling the tricky part by breaking down the complexity
    is the first step; the second step is paradoxically (or perhaps ironically) more
    complicated than the first step because it is more up to the individual involved
    to find ways to keep chugging through to the end.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并**，或从多个设备聚合输入，可能既棘手又繁琐——这对需要集中注意力和回忆的编码来说不是最好的组合。通过分解复杂性来解决棘手的问题是第一步；第二步在某种程度上（或许可以说是讽刺性地）比第一步更复杂，因为更多地取决于个人找到方法继续前进到终点。'
- en: Addressing Inputs
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理输入
- en: One of the most common decisions that needs to be made about a potential software
    design is where (in the code) to assign various responsibilities. It can sometimes
    be tempting to just put all the logic, data, and code into a single file for convenience’s
    sake, but unless this is all taking place in the PG, enhancing and maintaining
    the application will quickly become an uncontrollable nightmare in every practical
    respect.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在潜在软件设计方面需要做出的最常见决定之一是（在代码中）将各种责任分配在哪里。有时为了方便，可能会倾向于将所有逻辑、数据和代码都放入一个单独的文件中，但除非这一切都在
    PG 中进行，否则增强和维护应用程序将很快在所有实际方面变成一个无法控制的噩梦。
- en: 'One way that the **SpaceTruckerInputManager** (**STIM**) manages complexity
    is by maintaining individual and separate device-specific registration logic.
    Different devices present their data in different ways; some types of inputs lend
    themselves to Observables that can be subscribed to receive input events:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**SpaceTruckerInputManager**（**STIM**）管理复杂性的方法之一是维护单独的、针对特定设备的注册逻辑。不同的设备以不同的方式呈现其数据；某些类型的输入适合订阅可观察对象以接收输入事件：'
- en: '![Figure 5.6 – Observables propagating events – onKeyDownObservable in this
    case](img/Figure_5.06_B17266.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 事件传播的可观察对象 – 在此情况下为 onKeyDownObservable](img/Figure_5.06_B17266.jpg)'
- en: Figure 5.6 – Observables propagating events – onKeyDownObservable in this case
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 事件传播的可观察对象 – 在此情况下为 onKeyDownObservable
- en: 'Others are more suited to have their state polled on a frame-by-frame basis:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一些则更适合在每一帧的基础上轮询其状态：
- en: '![Figure 5.7 – Analog inputs (joystick axis, triggers, and more) need to be
    polled to get the current state of the device](img/Figure_5.07_B17266.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 模拟输入（摇杆轴、触发器等）需要轮询以获取设备当前状态](img/Figure_5.07_B17266.jpg)'
- en: Figure 5.7 – Analog inputs (joystick axis, triggers, and more) need to be polled
    to get the current state of the device
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 模拟输入（摇杆轴、触发器等）需要轮询以获取设备当前状态
- en: To make things more fun, many devices mix paradigms, with some inputs exposed
    via observable events and some only available via polling! All this data is aggregated
    into an `inputMap` **hashmap** (there it is again!) that contains the current
    state of all registered inputs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更有趣，许多设备混合了范式，一些输入通过可观察事件暴露出来，而一些则只能通过轮询获得！所有这些数据都汇总到一个 `inputMap` **哈希表**（又出现了！）中，其中包含所有已注册输入的当前状态。
- en: The Input Manager must deal with either scenario with aplomb and grace according
    to Etiquette, and so it shall. Leaving a subscription dangling after the subscriber
    has gone away is considered poor form, so we must ensure the Input Manager also
    cleans up after itself like a good houseguest. That means we need to track our
    subscriptions and their sources so that we can use `Observable.remove`. Fortunately,
    we also have a parallel need for the Input Manager to have access to a given Scene.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输入管理器必须根据礼仪优雅地处理任何一种情况，因此它应该这样做。在订阅者离开后留下悬挂的订阅被认为是不良的礼仪，因此我们必须确保输入管理器也像一位好客人一样清理自己的东西。这意味着我们需要跟踪我们的订阅及其来源，以便我们可以使用
    `Observable.remove`。幸运的是，我们还有一个并行需求，即输入管理器需要能够访问给定的场景。
- en: Input Registration
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入注册
- en: 'Whenever a `SpaceTruckerInputManager`, it doesn’t matter who is invoking `registerInputForScene`,
    it just needs `sceneToRegister` into its `inputSubscriptions` array. The object
    map that’s added to the list is keyed by the scene being registered because the
    lifetime of `SpaceTruckerInputManager` follows a `Scene.onDisposeObservable` (highlighted).
    The subscriptions array contains the returned set of `enableKeyboard`, `enableMouse`,
    and `enableGamePad`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时一个 `SpaceTruckerInputManager`，无论谁在调用 `registerInputForScene`，它只需要将 `sceneToRegister`
    添加到其 `inputSubscriptions` 数组中。添加到列表中的对象映射以注册的场景为键，因为 `SpaceTruckerInputManager`
    的生命周期遵循 `Scene.onDisposeObservable`（突出显示）。订阅数组包含返回的 `enableKeyboard`、`enableMouse`
    和 `enableGamePad` 的集合）：
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The aforementioned device-enable functions return an object with a very specific
    shape – and that shape is one of the keys (pardon the deep-running pun here) to
    making everything come together smoothly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述提到的设备启用函数返回一个具有非常特定形状的对象——而这个形状是使一切顺利结合的关键之一（请原谅这里的双关语）。
- en: Checking Inputs
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查输入
- en: 'To deal with inputs requiring polling, each type of device needs to have a
    `checkInput` method that knows how to retrieve input and place it into the `SpaceTruckerInputManager.inputMap`
    hash map. For devices that exclusively utilize observables in their input surfacing,
    the `checkInput` function can be a no-op or empty function that does nothing.
    Devices with mixed or solely axis inputs (for example, thumbsticks, joysticks,
    triggers – any input type that returns an input that isn’t always a 0 or 1) implement
    `checkInput` to read the gamepad’s state every time it is called (every frame).
    Since things such as normalizing input are concerns shared across different models
    of gamepads, the utility functions in `inputActionMap.js` (referenced as `SpaceTruckerControls`
    in the following code block) are leveraged to ensure that axis input values are
    in the range of *-1 <= value <= 1*. Other functions take those normalized values
    and map them to a particular input direction based on the inputs crossing a threshold
    value:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理需要轮询的输入，每种设备都需要有一个 `checkInput` 方法，该方法知道如何检索输入并将其放置到 `SpaceTruckerInputManager.inputMap`
    哈希表中。对于仅利用可观察值在其输入表面化的设备，`checkInput` 函数可以是一个空操作或空函数，不执行任何操作。具有混合或仅轴输入（例如，摇杆、操纵杆、扳机——任何返回的输入不是总是0或1的输入类型）的设备实现
    `checkInput` 以在每次调用时（每帧）读取游戏手柄的状态。由于诸如归一化输入等问题是不同游戏手柄模型共享的担忧，`inputActionMap.js`
    中的实用函数（在以下代码块中引用为 `SpaceTruckerControls`）被利用以确保轴输入值在范围 *-1 <= value <= 1* 内。其他函数接受这些归一化值并将它们映射到特定的输入方向，这取决于输入是否超过阈值值：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code block is from `spaceTruckerInput.js` and is contained as
    part of the `checkInputs` function object defined in the `enableGamepads` method.
    For any type of analog input device, there will be a certain amount of imprecision
    and noise in the inputs. To deal with that, the input is “normalized” (that is,
    values that are reported are in the range of `-1 <= x <= 1`) using static methods.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块来自 `spaceTruckerInput.js`，并作为 `enableGamepads` 方法中定义的 `checkInputs` 函数对象的一部分。对于任何类型的模拟输入设备，输入中都会有一定程度的精度和噪声。为了处理这个问题，输入被“归一化”（也就是说，报告的值在范围
    `-1 <= x <= 1` 内）使用静态方法。
- en: Disposing Input Subscriptions
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理输入订阅
- en: 'The other property of the `enableDevice` contract is the `dispose` method.
    This is a function, like `checkInputs`, that contains all the specific logic needed
    to unsubscribe any observers and clean up after itself. Those two properties allow
    the consumers of `inputManager` to remain completely ignorant about the specifics
    of how input is collected by the application. This makes the code simpler and
    gives us more attention to focus on accomplishing other things (such as getting
    through the rest of this chapter). This is what the return value of the `enableGamepad`
    method looks like:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`enableDevice` 合同的另一个属性是 `dispose` 方法。这是一个函数，就像 `checkInputs` 一样，它包含所有必要的特定逻辑来取消订阅任何观察者并清理自身。这两个属性允许
    `inputManager` 的消费者完全不了解输入是如何被应用程序收集的具体细节。这使得代码更简单，并让我们有更多精力关注其他事情（例如，完成本章的剩余部分）。这就是
    `enableGamepad` 方法的返回值看起来像这样：'
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All this talk about observers, observables, and subscriptions can be confusing.
    That’s the complexity you’re tasting, but hopefully, that taste will yield to
    a more pleasing robust, functional flavor as we discuss the final piece of the
    `getInputs` method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关于观察者、可观察的和订阅的讨论可能会让人困惑。这就是你正在品尝的复杂性，但希望随着我们讨论 `getInputs` 方法的最后一部分，这种味道会转变为更令人愉悦的强大、功能性的风味。
- en: The getInputs Method
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getInputs` 方法'
- en: Although we want a scene to check inputs every frame, we haven’t defined what
    will invoke that logic yet, or where it will occur in the application. For the
    `getInputs` function takes a Scene as its sole parameter. The `sceneInputHandler`
    local constant. Each of the subscriptions in the `sceneInputHandler.subscriptions`
    array has its `checkInputs` function invoked as part of a `forEach` loop; recall
    that each subscription represents a specific input type and that the `checkInputs`
    function populates `SpaceTruckerInputManager.inputMap` with the latest values.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们希望场景每帧都检查输入，但我们还没有定义将调用该逻辑的是什么，或者它将在应用程序中的哪个位置发生。因为 `getInputs` 函数将场景作为其唯一参数。`sceneInputHandler`
    本地常量。`sceneInputHandler.subscriptions` 数组中的每个订阅都会在 `forEach` 循环中调用其 `checkInputs`
    函数；回想一下，每个订阅代表一种特定的输入类型，而 `checkInputs` 函数会将最新的值填充到 `SpaceTruckerInputManager.inputMap`
    中。
- en: 'With `inputMap` containing all the various inputs to the Screen, an array of
    entries is iterated across and mapped into an input event structure containing
    the `lastEvent` property:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `inputMap` 包含了屏幕的所有各种输入，因此会迭代一个条目数组并将其映射到一个包含 `lastEvent` 属性的输入事件结构中：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The resulting inputs array is then returned to callers, as well as getting
    syndicated via `onInputAvailableObservable` (currently unused). Note the large
    gap in this discussion, namely the question as to where and who calls the `getInputs`
    function. This is indeed a good question, but it is not one that `SpaceTruckerInputManager`
    needs to concern itself with – that is a matter for our next topic: Input Processing:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将生成的输入数组返回给调用者，并通过 `onInputAvailableObservable`（目前未使用）进行分发。注意这个讨论中的大缺口，即关于在哪里以及谁调用
    `getInputs` 函数的问题。这确实是一个好问题，但并不是 `SpaceTruckerInputManager` 需要关心的问题——这是下一个主题的内容：输入处理：
- en: '![Figure 5.8 – Two of the four components covered so far](img/Figure_5.08_B17266.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 到目前为止涵盖的四个组件中的两个](img/Figure_5.08_B17266.jpg)'
- en: Figure 5.8 – Two of the four components covered so far
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 到目前为止涵盖的四个组件中的两个
- en: Input Processing
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入处理
- en: Mapping raw inputs to game or application inputs is a crucial part of Input
    Management, the two components of our input system that we’ve covered so far.
    That’s potentially enough to be sufficient for a relatively simple application
    or game, but Space-Truckers has different needs. It needs to be able to selectively
    route the input to Screens without needing to know anything about the details
    of that input. It also needs to handle input state – not just the current, but
    past as well.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始输入映射到游戏或应用程序输入是输入管理的关键部分，这是我们迄今为止涵盖的输入系统的两个组件。这可能对于相对简单的应用程序或游戏来说已经足够了，但
    Space-Truckers 有不同的需求。它需要能够选择性地将输入路由到屏幕，而不需要了解该输入的任何细节。它还需要处理输入状态——不仅仅是当前的，还包括过去的。
- en: 'There is a point whereupon it becomes rude to ask additional favors from a
    distinguished houseguest, and if our houseguest is `SpaceTruckerInputManager`,
    then asking it to take on these responsibilities is… well, it’s just too much.
    We need another component to take up the burden: `SpaceTruckerInputProcessor`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个点，向一位杰出的房客提出额外的请求变得不礼貌，如果我们的房客是 `SpaceTruckerInputManager`，那么要求它承担这些责任就是……好吧，这实在是太多了。我们需要另一个组件来承担这个负担：`SpaceTruckerInputProcessor`。
- en: Attaching Controls
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加控制
- en: 'Similar to the `registerInputForScene` and `unRegisterInputForScene` methods
    of its sibling, `SpaceTruckerInputManager`, the `attachControl` and `detachControl`
    functions. Unlike its sibling, though, the STIP functions do not accept a `SpaceTruckerInputProcessor.attachControl`
    method that calls `registerInputForScene` in the first place:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与其兄弟组件 `SpaceTruckerInputManager` 的 `registerInputForScene` 和 `unRegisterInputForScene`
    方法类似，`attachControl` 和 `detachControl` 函数。然而，与它的兄弟不同，STIP 函数不接受一个调用 `registerInputForScene`
    的 `SpaceTruckerInputProcessor.attachControl` 方法：
- en: '[PRE20]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Also, as part of attaching control to the Screen, `inputManager.onInputObservable`
    gets `SpaceTruckerInputProcessor.inputAvailableHandler` subscribed to be notified
    when a new set of inputs has been received. It’s a simple little method that just
    pushes received inputs into `inputQueue`, which is processed as part of the `update`
    method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为将控制权附加到屏幕的一部分，`inputManager.onInputObservable` 被订阅了 `SpaceTruckerInputProcessor.inputAvailableHandler`，以便在接收到一组新的输入时得到通知。这是一个简单的小方法，它只是将接收到的输入推入
    `inputQueue`，该队列作为 `update` 方法的一部分进行处理。
- en: Update
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新
- en: 'This is where the magic happens. After a quick check to ensure that it’s OK
    to be handling inputs, `inputManager.getInputs` is invoked, which, in turn, triggers
    an out-of-function process that ends up populating `inputQueue` with information.
    This may not happen in time for the rest of the update function logic, but that’s
    OK because it will just be handled in the next frame:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是魔法发生的地方。在快速检查以确保可以处理输入之后，调用`inputManager.getInputs`，这反过来又触发一个函数外的过程，最终将信息填充到`inputQueue`中。这可能不会及时完成更新函数逻辑的其他部分，但这没关系，因为它将在下一帧中处理：
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The current map of actions to state (`this.actionState`) is copied into `this.lastActionState`
    to preserve it for later usage in processing inputs. Then, `inputQueue` is drained
    of items one by one and dispatched by `inputCommandHandler`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当前将动作映射到状态（`this.actionState`）的映射被复制到`this.lastActionState`中，以保留它供后续处理输入时使用。然后，`inputQueue`中的项目逐个被清空并由`inputCommandHandler`分发。
- en: InputCommandHandler
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入命令处理器
- en: 'This deceptively simple method does a lot more than it might seem at first
    glance. That’s all due to the power of (third time’s the charm!) `actionMap`.
    The `actionMap` class member is an object map that relates a game action (`ACTIVATE`)
    to an executable function in the hosting Screen – a topic we’ll delve into shortly
    – which it uses to look up and invoke the game logic attached to the given action:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表面上看似简单的方法实际上做了很多看似不可能的事情。这都归功于（第三次总是幸运！）`actionMap`的力量。`actionMap`类成员是一个对象映射，它将游戏动作（`ACTIVATE`）与宿主屏幕中的可执行函数相关联——这是一个我们很快就会深入探讨的话题——它使用它来查找和调用与给定动作相关联的游戏逻辑：
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By convention, we pass an object with `lastActionState`, along with the event
    object passed along from `inputManager`, and store the return value in a previously
    mentioned object map, `actionState`. Each individual `actionFn` decides what to
    return, as well as what to do with the passed-in state value without `inputProcessor`
    ever needing to deal with the specifics – nice and tidy!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们传递一个包含`lastActionState`的对象，以及从`inputManager`传递过来的事件对象，并将返回值存储在之前提到的对象映射`actionState`中。每个单独的`actionFn`决定返回什么，以及如何处理传入的状态值，而无需`inputProcessor`处理具体细节——既整洁又方便！
- en: The buildActionMap Function
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建动作映射函数
- en: 'What `buildActionMap` does is what is known as `actionList`, the `actionDef.action`
    string property is used to look up a function with the same name in the `SpaceTruckerInputProcessor.screen`
    object:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildActionMap`所做的是所谓的`actionList`，`actionDef.action`字符串属性用于在`SpaceTruckerInputProcessor.screen`对象中查找具有相同名称的函数：'
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If located, `actionMap` is populated with the located function after optionally
    wrapping it with a pre-processing `bounce` function to prevent it from being invoked
    too many times in a given period… which brings us to the final component of our
    input system: Action Handling:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到，`actionMap`将在可选地用预处理`bounce`函数包装后填充找到的函数，以防止它在给定时间段内被调用过多……这把我们带到了我们输入系统的最后一个组件：动作处理：
- en: '![Figure 5.9 – Input Processing, Input Management, and Mapping of Input data
    covered. Just Action Handling remains](img/Figure_5.09_B17266.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 输入处理、输入管理和输入数据映射已覆盖。仅剩动作处理](img/Figure_5.09_B17266.png)'
- en: Figure 5.9 – Input Processing, Input Management, and Mapping of Input data covered.
    Just Action Handling remains
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 输入处理、输入管理和输入数据映射已覆盖。仅剩动作处理
- en: Action Handling
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作处理
- en: We’ve spent the last few pages diving through multiple levels of abstraction
    and indirection, and we’re now finally at the point where it all starts to do
    something – the Action Handling. While the previous steps were confined to a specific
    class or instance type, the action handlers are the screens themselves.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在过去的几页中深入探讨了多个层次的抽象和间接，现在我们终于到了所有这一切开始发挥作用的地方——动作处理。虽然之前的步骤仅限于特定的类或实例类型，但动作处理器本身就是屏幕。
- en: Conventional Actions
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习惯性动作
- en: 'Sounds like the name of a bad early 2000s cover band, but it’s a term for how
    we go about naming and describing our action functions on a given screen. It’s
    a lot simpler than it sounds: for every action that a `state` parameter. Should
    you need to get more information about the input event, add a second parameter
    to the function to accept an `inputEvent`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来像是一个糟糕的2000年代初期的封面乐队名字，但这是一个术语，用于描述我们在特定屏幕上命名和描述动作函数的方式。这比听起来简单得多：对于每个`state`参数的动作。如果您需要获取有关输入事件的更多信息，请向函数添加第二个参数以接受`inputEvent`。
- en: Important note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Remember, an action is a game-specific concept, such as `MOVE_UP`, or `ACTIVATE`.
    Those are just the names given for this game; you are free to name them whatever
    you want!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，动作是游戏特定的概念，例如 `MOVE_UP` 或 `ACTIVATE`。这些只是为这个游戏命名的名称；你可以随意命名它们！
- en: 'Using `SpaceTruckerMainMenuScreen` as an example, the `MOVE_UP` and `MOVE_DOWN`
    actions should increment or decrement `selectedItemIndex` for the menu items.
    An `ACTIVATE` action should invoke the menu item. Here’s what that looks like
    when we code up the `MOVE_UP` action:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `SpaceTruckerMainMenuScreen` 为例，`MOVE_UP` 和 `MOVE_DOWN` 动作应该增加或减少菜单项的 `selectedItemIndex`。`ACTIVATE`
    动作应该调用菜单项。以下是我们在编码 `MOVE_UP` 动作时的样子：
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Similarly, `ACTIVATE` retrieves `selectedItem` before simulating a click event
    by calling its `onPointerClickObservable.notifyObservers` method to invoke whatever
    result is indicated by the particular button selected.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`ACTIVATE` 在通过调用其 `onPointerClickObservable.notifyObservers` 方法来模拟点击事件之前，检索
    `selectedItem`。
- en: Skipping the Splash Screen
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳过启动屏幕
- en: 'As part of constructing the Splash screen earlier in this chapter, we added
    a `skipRequested` flag to the scene, but there wasn’t ever anything that would
    change that value… until now! The `ACTIVATE` action doesn’t need to know what
    key was pressed – it only needs to know that it happened at all; just that a key
    was pressed in the first place. That makes this a pretty simple piece of logic:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在本章早期构建启动屏幕的一部分，我们在场景中添加了一个 `skipRequested` 标志，但从未有任何东西会改变这个值……直到现在！`ACTIVATE`
    动作不需要知道按下了哪个键——它只需要知道它确实发生了；只是最初按下了键。这使得这部分逻辑相当简单：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `SpaceTruckerSplashScreen.update` function, where the `actionProcessor.update`
    function is invoked, is, in turn, called during `SpaceTruckerApplication.Render`,
    but only if it is the currently active screen.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SpaceTruckerSplashScreen.update` 函数中，调用了 `actionProcessor.update` 函数，反过来，在
    `SpaceTruckerApplication.Render` 中调用，但仅当它是当前活动屏幕时。
- en: '![Figure 5.10 – All four components of the input system'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 输入系统的所有四个组件'
- en: '](img/Figure_5.10_B17266.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10](img/Figure_5.10_B17266.jpg)'
- en: Figure 5.10 – All four components of the input system
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 输入系统的所有四个组件
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Glancing back through the previous pages in this chapter, it might be easy to
    think that we haven’t accomplished a whole lot, but never sell yourself short
    – the things we’ve covered in this chapter aren’t the most straightforward to
    understand or wrap your brain around! Constructing and orchestrating the sequencing
    of `SplashScreen` starts to ramp up the complexity of our code, not counting the
    mental whiplash induced by pivoting from that to input in the space of a page.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章前面的页面，可能会觉得我们并没有完成太多，但不要低估自己——本章中我们讨论的内容并不容易理解或掌握！构建和编排 `SplashScreen` 的顺序开始增加我们代码的复杂性，不计页面上从那转向输入所引起的心理冲击。
- en: As stated earlier and not redundantly stated again now, entire thick textbooks
    can and have been written on the topic of input handling, something we’re trying
    to cram into a mere fraction of that. Not only that, but we are now able to approach
    future features with a much clearer picture of how all of the non-game-specific
    tasks are to be managed and handled.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，并且现在不再重复，关于输入处理的主题可以写整整厚厚的教科书，而我们试图将其压缩到那部分的一小部分。不仅如此，我们现在能够以更清晰的画面来处理未来的功能，了解所有非游戏特定任务的管理和处理方式。
- en: That statement could be expanded to cover this and the other chapters in this
    section as well – we’ve gotten much of the supporting application in place now,
    which leaves us far more attention to focus on the topics in our next section!
    In section two, we’ll build the gameplay mechanics, set up lighting and materials,
    and much, much more.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 该陈述可以扩展到涵盖本节中的这一章和其他章节——我们现在已经建立了大部分支持应用程序，这让我们有更多精力关注下一节中的主题！在第二节中，我们将构建游戏机制，设置光照和材质，以及更多更多。
- en: Extended Topics
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题
- en: 'Where to start? There are simply so many interesting things and possibilities
    to explore! Here are just a few ideas for things you can do to further your learning
    and enhance `SplashScreen`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从哪里开始？有如此多的有趣事物和可能性可以探索！以下是一些你可以做的事情来进一步学习和增强 `SplashScreen`：
- en: Add a camera animation to the beginning portion that has the camera moving and
    rotating along a path in such a way that the `billboard` panel grows in apparent
    size at about the same rate as the volume of the music rises
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始部分添加相机动画，使相机沿着路径移动和旋转，这样`广告牌`面板的可见尺寸将以大约与音乐音量上升相同的速率增长
- en: Add background environmental effects to the Scene, similar to what we did with
    the Main Menu and the Procedural Starfield texture
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向场景添加背景环境效果，类似于我们在主菜单和程序星系纹理中所做的那样
- en: Replace the final static image with a mesh, texture, material, or something
    else
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将最终静态图像替换为网格、纹理、材质或其他内容
- en: 'The input system is also a great source of ideas. Here are a few to consider:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 输入系统也是一个很好的灵感来源。以下是一些可以考虑的点：
- en: 'Implement support for your favorite gamepad or joystick device. Use this testing
    site to see the various inputs and values emitted by your device: [https://luser.github.io/gamepadtest/](https://luser.github.io/gamepadtest/)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现对您最喜欢的游戏手柄或摇杆设备的支持。使用此测试网站查看您的设备发出的各种输入和值：[https://luser.github.io/gamepadtest/](https://luser.github.io/gamepadtest/)
- en: Modify the input system to allow for multiple simultaneously connected users
    – that is, local multiplayer
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改输入系统以允许多个同时连接的用户——即本地多人游戏
- en: Expose the joystick sensitivity settings to the application so that they can
    be edited in-game by the player
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将摇杆灵敏度设置暴露给应用程序，以便玩家可以在游戏中编辑
- en: 'Part 2: Constructing the Game'
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：构建游戏
- en: 'In this second part of the book, we will build on the foundations of the first
    part to implement the primary components that comprise **Space-Truckers: The Video
    Game**. The pace picks up, as there’s far more material to cover than there is
    space to contain it.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第二部分，我们将基于第一部分的基础来实施构成**《太空卡车手：视频游戏》**的主要组件。随着内容的增多，速度加快，因为要涵盖的材料远多于容纳的空间。
- en: 'This section comprises the following chapters:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 6*](B17266_06_Final_AM.xhtml#_idTextAnchor120), *Implementing the
    Game Mechanics*'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B17266_06_Final_AM.xhtml#_idTextAnchor120), *实现游戏机制*'
- en: '[*Chapter 7*](B17266_07_Final_AM.xhtml#_idTextAnchor142), *Processing Route
    Data*'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B17266_07_Final_AM.xhtml#_idTextAnchor142), *处理路线数据*'
- en: '[*Chapter 8*](B17266_08_Final_AM.xhtml#_idTextAnchor166), *Building the Driving
    Game*'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B17266_08_Final_AM.xhtml#_idTextAnchor166), *构建驾驶游戏*'
- en: '[*Chapter 9*](B17266_09_Final_AM.xhtml#_idTextAnchor186), *Calculating and
    Displaying Scoring Results*'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B17266_09_Final_AM.xhtml#_idTextAnchor186), *计算和显示得分结果*'
- en: '[*Chapter 10*](B17266_10_Final_AM.xhtml#_idTextAnchor207), *Improving the Environment
    with Lighting and Materials*'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B17266_10_Final_AM.xhtml#_idTextAnchor207), *通过照明和材质改善环境*'
