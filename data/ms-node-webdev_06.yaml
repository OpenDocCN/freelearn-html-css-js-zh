- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Using Node.js Streams
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 流
- en: One of the main tasks required in server-side development is transferring data,
    either reading data sent by a client or browser or writing data that must be transmitted
    or stored in some way. In this chapter, I will introduce the Node.js API for dealing
    with data sources and data destinations, known as *streams*. I will explain the
    concept behind streams, show how they are used to deal with HTTP requests, and
    explain why one common source of data – the file system – should be used with
    caution in a server-side project. *Table 6.1* puts streams in context.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端开发中需要完成的主要任务之一是传输数据，无论是读取客户端或浏览器发送的数据，还是以某种方式传输或存储的数据。在本章中，我将介绍 Node.js
    处理数据源和数据目的地的 API，称为 *流*。我将解释流背后的概念，展示如何使用流来处理 HTTP 请求，并解释为什么在服务器端项目中应谨慎使用一个常见的数据源——文件系统。*表6.1*
    将流置于上下文中。
- en: 'Table 6.1: Putting streams in context'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1：将流置于上下文中
- en: '| Question | Answer |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 答案 |'
- en: '| What are they? | Streams are used by Node.js to represent data sources or
    destinations, including HTTP requests and responses. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 它们是什么？ | 流被 Node.js 用于表示数据源或目的地，包括 HTTP 请求和响应。 |'
- en: '| Why are they useful? | Streams don’t expose the details of how data is produced
    or consumed, which allows the same code to process data from any source. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 为什么它们有用？ | 流不暴露数据产生或消费的细节，这使得相同的代码可以处理来自任何源的数据。 |'
- en: '| How are they used? | Node.js provides streams to deal with HTTP requests.
    The streams API is used to read data from the HTTP request and write data to the
    HTTP response. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 如何使用它们？ | Node.js 提供流来处理 HTTP 请求。流 API 用于从 HTTP 请求中读取数据并将数据写入 HTTP 响应。 |'
- en: '| Are there any pitfalls or limitations? | The streams API can be a little
    awkward to work with, but this can be improved with the use of third-party packages,
    which often provide more convenient methods to perform common tasks. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 有没有陷阱或限制？ | 流 API 可能有点难以处理，但使用第三方包可以改进这一点，这些包通常提供更方便的方法来执行常见任务。 |'
- en: '| Are there any alternatives? | Streams are integral to Node.js development.
    Third-party packages can simplify working with streams, but it is helpful to understand
    how streams work for when problems arise. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 有没有替代方案？ | 流对于 Node.js 开发至关重要。第三方包可以简化流的工作，但了解流的工作原理对于出现问题时是有帮助的。 |'
- en: '*Table 6.2* sums up what the chapter will cover.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*表6.2* 总结了本章将涵盖的内容。'
- en: 'Table 6.2: Chapter summary'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2：章节总结
- en: '| Problem | Solution | Listing |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 | 列表 |'
- en: '| Write data to a stream | Use the `write` or `end` methods. | 4 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 将数据写入流 | 使用 `write` 或 `end` 方法。 | 4 |'
- en: '| Set response headers | Use the `setHeader` method. | 5–7 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 设置响应头 | 使用 `setHeader` 方法。 | 5–7 |'
- en: '| Manage data buffering | Use the result from the `write` method and handle
    the `drain` event. | 8–9 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 管理数据缓冲 | 使用 `write` 方法的返回结果并处理 `drain` 事件。 | 8–9 |'
- en: '| Read data from a stream | Handle the `data` and `end` events or use an iterator.
    | 10–15 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 从流中读取数据 | 处理 `data` 和 `end` 事件或使用迭代器。 | 10–15 |'
- en: '| Connect streams | Use the `pipe` method. | 16 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 连接流 | 使用 `pipe` 方法。 | 16 |'
- en: '| Transform data | Extend the `Transform` class and use the stream object mode.
    | 17–19 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 转换数据 | 扩展 `Transform` 类并使用流对象模式。 | 17–19 |'
- en: '| Serve static files | Use the Express static middleware or use the `sendFile`
    and `download` methods. | 20–26 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 服务器端静态文件 | 使用 Express 静态中间件或使用 `sendFile` 和 `download` 方法。 | 20–26 |'
- en: '| Encode and decode data | Use the Express JSON middleware and the `json` response
    method. | 27–28 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 编码和解码数据 | 使用 Express JSON 中间件和 `json` 响应方法。 | 27–28 |'
- en: Preparing for this chapter
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备本章内容
- en: In this chapter, I will continue to use the `webapp` project created in *Chapter
    4* and modified in *Chapter 3*. To prepare for this chapter, replace the contents
    of the `server.ts` file in the `src` folder with the code shown in *Listing 6.1*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将继续使用在 *第4章* 中创建并在 *第3章* 中修改的 `webapp` 项目。为了准备本章内容，请将 `src` 文件夹中 `server.ts`
    文件的全部内容替换为 *清单6.1* 中显示的代码。
- en: '**Tip**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development)
    下载本章的示例项目——以及本书中所有其他章节的示例项目。有关如何获取帮助以运行示例的说明，请参阅 *第1章*。
- en: 'Listing 6.1: Replacing the contents of the server.Ts file in the src folder'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1：替换src文件夹中server.Ts文件的内容
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Express router filters out favicon requests and passes on all other HTTP
    GET requests to a function named `basicHandler`, which is imported from the `handler`
    module. To define the handler, replace the contents of the `handler.ts` to the
    `src` folder with the code shown in *Listing 6.2*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Express路由器过滤掉favicon请求，并将所有其他HTTP GET请求传递给一个名为`basicHandler`的函数，该函数是从`handler`模块导入的。为了定义处理程序，将`src`文件夹中的`handler.ts`文件的内容替换为*列表6.2*中显示的代码。
- en: Listing 6.2\. The contents of the handler.ts file in the src folder
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2：src文件夹中handler.ts文件的内容
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This handler uses the Node.js `IncomingMessage` and `ServerResponse` types,
    even though Express is used to route requests. I will demonstrate the enhancements
    Express provides in the *Using third-party enhancements* section, but I am going
    to start with the built-in features that Node.js provides.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用了Express进行路由请求，但此处理程序使用了Node.js的`IncomingMessage`和`ServerResponse`类型。我将在*使用第三方增强功能*部分演示Express提供的增强功能，但我会从Node.js提供的内置功能开始。
- en: Some examples in this chapter require an image file. Create the `static` folder
    and add to it an image file named `city.png`. You can use any PNG image file as
    long as you name it `city.png`, or you can download the public domain panorama
    of the New York City skyline that I used, shown in *Figure 6.1*, from the code
    repository for this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些示例需要图像文件。创建`static`文件夹，并向其中添加一个名为`city.png`的图像文件。只要将其命名为`city.png`，您可以使用任何PNG图像文件，或者您可以下载我在代码库中使用的纽约市天际线的公共领域全景图，如*图6.1*所示。
- en: '![](img/B21959_06_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_06_01.png)'
- en: 'Figure 6.1: The city.png file in the static folder'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：静态文件夹中的The city.png文件
- en: Run the command shown in *Listing 6.3* in the `webapp` folder to start the watcher
    that compiles TypeScript files and executes the JavaScript that is produced.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`webapp`文件夹中运行*列表6.3*中显示的命令以启动编译TypeScript文件并执行生成的JavaScript的监视器。
- en: 'Listing 6.3: Starting the project'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3：启动项目
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open a web browser and request `http://localhost:5000`. You will see the result
    shown in *Figure 6.2*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器并请求`http://localhost:5000`。你将看到*图6.2*中显示的结果。
- en: '![](img/B21959_06_02.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_06_02.png)'
- en: 'Figure 6.2: Running the example project'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：运行示例项目
- en: Understanding streams
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解流
- en: 'The best way to understand streams is to ignore data and think about water
    for a moment. Imagine you are in a room in which a pipe with a faucet enters through
    one wall. Your job is to build a device that will collect the water from the pipe.
    There is obviously something connected to the other end of the pipe that produces
    the water, but you are only able to see the faucet, and so the design of your
    device will be dictated by what you know: you have to create something that will
    connect to the pipe and receive the water when the faucet is turned on. Having
    such a limited view of the system you are working with may feel like a restriction,
    but the pipe can be connected to any source of water and your device works just
    as well whether the water comes from a river or a reservoir; it is all just water
    coming through the pipe via the faucet, and it is always consumed consistently.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 理解流的最佳方式是暂时忽略数据，并思考一下水。想象你在一个房间里，有一根带水龙头的水管从一堵墙上进入。你的任务是构建一个收集水管中水的设备。显然，管道的另一端连接着产生水的设备，但你只能看到水龙头，因此你的设备设计将由你所知的内容决定：你必须创建一个可以连接到管道并在水龙头打开时接收水的设备。对你正在处理的系统有如此有限的视角可能会感觉像是一种限制，但管道可以连接到任何水源，无论水来自河流还是水库，你的设备都能正常工作；它只是通过水龙头通过管道流过的水，而且总是被一致地消耗。
- en: At the other end of the pipe, the producer of the water has a pipe into which
    they pump their water. The water producer can’t see what you have attached to
    the other end of the pipe and does not know how you are going to consume the water.
    And it doesn’t matter, because all the producer has to do is push their water
    through the pipe, regardless of whether their water will be used to drive a water
    mill, fill a swimming pool, or run a shower. You can change the device attached
    to your pipe and nothing would change for the producer, who still keeps pumping
    water into the same pipe in the same way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道的另一端，水的生产者有一个管道，他们将水泵入这个管道。水生产者看不到你连接在管道另一端的东西，也不知道你将如何使用这水。这并不重要，因为水生产者只需要将他们的水通过管道推送出去，无论这些水是用来驱动水车、填满游泳池还是运行淋浴。你可以改变连接到你的管道的设备，但这并不会对生产者产生影响，他们仍然以同样的方式将水泵入同一个管道。
- en: In the world of web development, a *stream* solves the problem of distributing
    data in the same way that the pipe solves the problem of distributing water. Like
    a pipe, a stream has two ends. At one end is the data producer, also known as
    the *writer*, who puts a sequence of data values into the stream. At the other
    end is the data consumer, also known as the *reader*, who receives the sequence
    of data values from the stream. The writer and reader each have their own API
    that allows them to work with the stream, as shown in *Figure 6.3*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发的世界里，*流*解决了数据分布的问题，就像管道解决了水分布的问题一样。像管道一样，流也有两端。一端是数据生产者，也称为*写者*，他们将一系列数据值放入流中。另一端是数据消费者，也称为*读者*，他们从流中接收一系列数据值。写者和读者各自有自己的API，允许他们与流一起工作，如图6.3所示。
- en: '![](img/B21959_06_03.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_06_03.png)'
- en: 'Figure 6.3: The anatomy of a stream'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：溪流的解剖结构
- en: This arrangement has two important characteristics. The first is that the data
    arrives in the same order in which it is written, which is why streams are usually
    described as a *sequence* of data values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排有两个重要的特点。第一个特点是数据以写入时的相同顺序到达，这就是为什么流通常被描述为数据值的*序列*。
- en: The second characteristic is that the data values can be written to the stream
    over time so that the writer doesn’t have to have all the data values ready before
    the first value is written. This means that the reader can receive and start processing
    data while the writer is still preparing or computing later values in the sequence.
    This makes streams suitable for a wide range of data sources, and they also integrate
    well with the Node.js programming model, as the examples in this chapter will
    demonstrate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个特点是数据值可以随着时间的推移写入流中，这样写者就不必在写入第一个值之前准备好所有数据值。这意味着读者可以在写者仍在准备或计算序列中的后续值时接收并开始处理数据。这使得流适用于广泛的数据源，并且它们与Node.js编程模型集成良好，正如本章中的示例将展示的那样。
- en: Using Node.js streams
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js流
- en: The `streams` module contains classes that represent different kinds of streams,
    and the two most important are described in *Table 6.3*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`streams`模块包含表示不同类型流的类，其中最重要的两个在*表6.3*中描述。'
- en: 'Table 6.3: Useful stream classes'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.3：有用的流类
- en: '| Name | Description |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `Writable` | This class provides the API for writing data to a stream. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `可写` | 这个类提供了向流中写入数据的API。|'
- en: '| `Readable` | This class provides the API for reading data from a stream.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `可读` | 这个类提供了从流中读取数据的API。|'
- en: In Node.js development, one end of a stream is usually connected to something
    outside of the JavaScript environment, such as a network connection or the file
    system, and this allows data to be read and written in the same way regardless
    of where it is going to or coming from.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js开发中，流的一端通常连接到JavaScript环境之外的东西，比如网络连接或文件系统，这使得数据可以以相同的方式读取和写入，无论数据是去往还是来自何方。
- en: For web development, the most important use of streams is they are used to represent
    HTTP requests and responses. The `IncomingMessage` and `ServerResponse` classes,
    which are used to represent HTTP requests and responses, are derived from the
    `Readable` and `Writable` classes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，流的最重要用途是它们用来表示HTTP请求和响应。用于表示HTTP请求和响应的`IncomingMessage`和`ServerResponse`类是从`Readable`和`Writable`类派生出来的。
- en: Writing data to a stream
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据写入流
- en: The `Writable` class is used to write data to a stream. The most useful features
    provided by the `Writable` class are described in *Table 6.4* and explained in
    the sections that follow.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writable` 类用于将数据写入流。`Writable` 类提供的最有用的功能在 *表 6.4* 中描述，并在接下来的章节中解释。'
- en: 'Table 6.4: Useful Writable Features'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4：有用的可写功能
- en: '| Name | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `write(data, callback)` | This method writes data to the stream and invokes
    the optional callback function when the data has been flushed. Data can be expressed
    as a `string`, `Buffer`, or `Uint8Array`. For string values, an optional encoding
    can be specified.The method returns a `boolean` value that indicates whether the
    stream is able to accept further data without exceeding its buffer size, as described
    in the *Avoiding excessive data buffering* section. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `write(data, callback)` | 此方法将数据写入流，并在数据被刷新时调用可选的回调函数。数据可以表示为 `string`、`Buffer`
    或 `Uint8Array`。对于字符串值，可以指定一个可选的编码。该方法返回一个 `boolean` 值，指示流是否能够接受更多数据而不超过其缓冲区大小，如
    *避免过度数据缓冲* 部分所述。|'
- en: '| `end(data, callback)` | This method tells Node.js that no further data will
    be sent. The arguments are an optional final chunk of data to write and an optional
    callback function that will be invoked when the data is finished. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `end(data, callback)` | 此方法通知 Node.js 将不再发送数据。参数是一个可选的最终数据块，以及一个可选的回调函数，当数据完成时将被调用。|'
- en: '| `destroy(error)` | This method destroys the stream immediately, without waiting
    for any pending data to be processed. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `destroy(error)` | 此方法立即销毁流，而不等待任何挂起的数据被处理。|'
- en: '| `closed` | This property returns `true` if the stream has been closed. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `closed` | 如果流已被关闭，此属性返回 `true`。|'
- en: '| `destroyed` | This property returns `true` if the `destroy` method has been
    called. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `destroyed` | 如果调用了 `destroy` 方法，此属性返回 `true`。|'
- en: '| `writable` | This property returns `true` if the stream can be written to,
    meaning that the stream has not ended, encountered an error, or been destroyed.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `writable` | 如果流可以写入，则此属性返回 `true`，这意味着流尚未结束，未遇到错误或被销毁。|'
- en: '| `writableEnded` | This property returns `true` if the `end` method has been
    called. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `writableEnded` | 如果调用了 `end` 方法，此属性返回 `true`。|'
- en: '| `writableHighWaterMark` | This property returns the size of the data buffer
    in bytes. The `write` method will return `false` when the amount of buffered data
    exceeds this amount. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `writableHighWaterMark` | 此属性返回数据缓冲区的大小（以字节为单位）。当缓冲的数据量超过此值时，`write` 方法将返回
    `false`。|'
- en: '| `errored` | This property returns `true` if the stream has encountered an
    error. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `errored` | 如果流遇到错误，此属性返回 `true`。|'
- en: The `Writable` class also emits events, the most useful of which are described
    in *Table 6.5*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writable` 类也会发出事件，其中最有用的将在 *表 6.5* 中描述。'
- en: 'Table 6.5: Useful Writable Events'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.5：有用的可写事件
- en: '| Name | Description |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `close` | This event is emitted when the stream is closed. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `close` | 当流被关闭时，会发出此事件。|'
- en: '| `drain` | This event is emitted when the stream can accept data without buffering.
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `drain` | 当流可以无缓冲地接受数据时，会发出此事件。|'
- en: '| `error` | This event is emitted when an error occurs. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `error` | 当发生错误时，会发出此事件。|'
- en: '| `finish` | This event is emitted when the `end` method is called and all
    of the data in the stream has been processed. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `finish` | 当调用 `end` 方法并且流中的所有数据都已处理时，会发出此事件。|'
- en: The basic approach to using a writable stream is to call the `write` method
    until all of the data has been sent to the stream, and then call the `end` method,
    as shown in *Listing 6.4*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可写流的基本方法是在所有数据都发送到流中之前调用 `write` 方法，然后调用 `end` 方法，如 *列表 6.4* 所示。
- en: 'Listing 6.4: Writing Data in the handler.ts File in the src Folder'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4：在 src 文件夹中的 handler.ts 文件中写入数据
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the changes, allow Node.js to restart, and then request `http://localhost:5000`.
    The handler will write its data to the response stream, producing the result shown
    in *Figure 6.4*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改，允许 Node.js 重新启动，然后请求 `http://localhost:5000`。处理程序将将其数据写入响应流，产生 *图 6.4*
    中所示的结果。
- en: '![](img/B21959_06_04.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_06_04.png)'
- en: 'Figure 6.4: Writing data to an HTTP response stream'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：将数据写入 HTTP 响应流
- en: It is easy to think of the endpoint of the stream as being a straight pipe to
    the ultimate recipient of the data, which is the web browser in this case, but
    that’s rarely the case. The endpoint for most streams is the part of the Node.js
    API that interfaces with the operating system, in this case, the code that deals
    with the operating system’s network stack to send and receive data. This indirect
    relationship leads to important considerations, as described in the sections that
    follow.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 容易将流端点想象成一条直通最终数据接收者的管道，在这个例子中是网络浏览器，但这种情况很少见。大多数流的端点是 Node.js API 与操作系统交互的部分，在这种情况下，是处理操作系统网络栈以发送和接收数据的代码。这种间接关系导致了一些重要的考虑因素，如下文所述。
- en: Understanding stream enhancements
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解流增强
- en: Some streams are enhanced to ease development, which means that the data you
    write to the stream won’t always be the data that is received at the other end.
    In the case of HTTP responses, for example, the Node.js HTTP API aids development
    by ensuring that all responses conform to the basic requirements of the HTTP protocol,
    even when the programmer doesn’t explicitly use the features provided to set the
    status code and headers. To see the content that the example in *Listing 6.4*
    writes to the stream, open a new command prompt and run the Linux command shown
    in *Listing 6.5*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流被增强以简化开发，这意味着你写入流的数据不一定总是接收端接收到的数据。例如，在 HTTP 响应的情况下，Node.js HTTP API 通过确保所有响应都符合
    HTTP 协议的基本要求来帮助开发，即使程序员没有明确使用提供来设置状态码和头部的功能。要查看 *列表 6.4* 中的示例写入流的内容，请打开一个新的命令提示符并运行
    *列表 6.5* 中显示的 Linux 命令。
- en: 'Listing 6.5: Making an HTTP Request (Linux)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5：在 Linux 中发送 HTTP 请求
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you are a Windows user, use PowerShell to run the command shown in *Listing
    6.6* instead.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名 Windows 用户，请使用 PowerShell 运行 *列表 6.6* 中显示的命令。
- en: 'Listing 6.6: Making an HTTP Request (Windows)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6：在 Windows 中发送 HTTP 请求
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These commands make it easy to see the entire response sent by Node.js. The
    code in *Listing 6.4* uses just the `write` and `end` methods, but the HTTP response
    will be like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令可以轻松显示 Node.js 发送的整个响应。*列表 6.4* 中的代码仅使用了 `write` 和 `end` 方法，但 HTTP 响应将如下所示：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Node.js HTTP API makes sure the response is legal HTTP by adding an HTTP
    version number, a status code and message, and a minimal set of headers. This
    is a useful feature, and it helps illustrate the fact that you cannot assume that
    the data you write to a stream will be the data that arrives at the other end.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js HTTP API 确保响应是合法的 HTTP，通过添加 HTTP 版本号、状态码和消息以及最小的一组头部。这是一个有用的功能，它有助于说明你不能假设你写入流的数据就是到达另一端的数据。
- en: The `ServerResponse` class demonstrates another kind of stream enhancement,
    which is methods or properties that write content to the stream for you, as shown
    in *Listing 6.7*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerResponse` 类展示了另一种流增强方式，即为你提供写入流内容的方法或属性，如 *列表 6.7* 所示。'
- en: 'Listing 6.7: Using a Stream Enhancement Method in the handler.ts File in the
    src Folder'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7：在 src 文件夹的 handler.ts 文件中使用流增强方法
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Behind the scenes, the `ServerResponse` class merges the arguments passed to
    the `setHeader` method with the default content used for responses. The `ServerResponse`
    class is derived from `Writable` and implements the methods and properties described
    in *Table 6.4*, but the enhancements make it easier to write content to the stream
    that is specific to HTTP requests, like setting a header in the response. If you
    run the commands shown in *Listing 6.6* or *Listing 6.7* again, you will see the
    effect of calling the `setHeader` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`ServerResponse` 类将传递给 `setHeader` 方法的参数与用于响应的默认内容合并。`ServerResponse` 类从
    `Writable` 派生，并实现了 *表 6.4* 中描述的方法和属性，但增强功能使得向特定于 HTTP 请求的流写入内容（如设置响应中的标题）变得更加容易。如果你再次运行
    *列表 6.6* 或 *列表 6.7* 中显示的命令，你将看到调用 `setHeader` 方法的效果：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Avoiding excessive data buffering
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免过度数据缓冲
- en: Writable streams are created with a buffer in which data is stored before it
    is processed. The buffer is a way of improving performance, by allowing the producer
    of data to write data to the stream in bursts faster than the stream endpoint
    can process them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可写流在创建时带有一个缓冲区，数据在处理之前存储在其中。缓冲区是一种提高性能的方式，允许数据生产者以比流端点处理速度更快的爆发方式将数据写入流。
- en: Each time the stream processes a chunk of data, it is said to have *flushed*
    the data. When all of the data in the stream’s buffer has been processed, the
    stream buffer is said to have been *drained*. The amount of data that can be stored
    in the buffer is known as the *high-water mark*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每次流处理一块数据时，我们说它已经*清空*了数据。当流缓冲区中的所有数据都被处理完毕时，我们说流缓冲区已经被*清空*。可以存储在缓冲区中的数据量被称为*高水位标记*。
- en: A writable stream will always accept data, even if it has to increase the size
    of its buffer, but this is undesirable because it increases the demand for memory
    that can be required for an extended period while the stream flushes the data
    it contains.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可写流始终接受数据，即使它必须增加其缓冲区的大小，但这是不理想的，因为它会增加在流清空其包含的数据期间可能需要的内存需求。
- en: The ideal approach is to write data to a stream until its buffer is full and
    then wait until that data is flushed before further data is written. To help achieve
    this goal, the `write` method returns a `boolean` value that indicates whether
    the stream can receive more data without expanding its buffer beyond its target
    high-water mark.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的方法是向流写入数据，直到其缓冲区满，然后等待该数据被清空后再写入更多数据。为了帮助实现这一目标，`write`方法返回一个`boolean`值，表示流是否可以在不超出其目标高水位标记的情况下接收更多数据。
- en: '*Listing 6.8* uses the value returned by the `write` method to indicate when
    the stream buffer has reached capacity.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6.8*使用`write`方法返回的值来指示流缓冲区何时达到容量。'
- en: 'Listing 6.8: Checking Stream Capacity in the handler.ts File in the src Folder'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8：在src文件夹中的handler.ts文件中检查流容量
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You may need to increase the maximum value used by the `for` loop, but for
    my development PC, rapidly writing 10,000 messages to the stream will reliably
    reach the stream limits. Use a browser to request `http://localhost:5000`, and
    you will see messages like these produced by the Node.js console:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要增加`for`循环使用的最大值，但对我来说，快速向流写入10,000条消息将可靠地达到流限制。使用浏览器请求`http://localhost:5000`，你将看到Node.js控制台产生如下消息：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Writable streams emit the `drain` event when their buffers have been drained,
    at which point more data can be written. In *Listing 6.9*, data is written to
    the HTTP response stream until the `write` method returns `false` and then stops
    writing until the `drain` event is received. (If you want to know when an individual
    chunk of data is flushed, then you can pass a callback function to the stream’s
    `write` method.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可写流在其缓冲区被清空时发出`drain`事件，此时可以写入更多数据。在*列表6.9*中，数据被写入HTTP响应流，直到`write`方法返回`false`，然后停止写入，直到接收到`drain`事件。（如果你想知道单个数据块何时被清空，则可以将回调函数传递给流的`write`方法。）
- en: 'Listing 6.9: Avoiding Excessive Data Buffering in the handler.ts File in the
    src Folder'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9：在src文件夹中的handler.ts文件中避免过多的数据缓冲
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `writeData` function enters a `do...while` loop that writes data to the
    stream until the `write` method returns `false`. The `once` method is used to
    register a handler that will be invoked once when the `drain` event is emitted,
    and which invokes the `writeData` function to resume writing. Once all of the
    data has been written, the `end` method is called to finalize the stream.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeData`函数进入一个`do...while`循环，将数据写入流，直到`write`方法返回`false`。使用`once`方法注册一个处理程序，该处理程序将在`drain`事件触发时被调用，并调用`writeData`函数以恢复写入。一旦所有数据都已写入，将调用`end`方法以最终化流。'
- en: '**Avoiding the Early End Pitfall**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免提前结束陷阱**'
- en: 'A common mistake – and one that I make regularly – is to put the call to the
    `end` method outside of the callback functions that write the data, like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误——而且我经常犯的错误——是将对`end`方法的调用放在写入数据的回调函数之外，如下所示：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The outcome can differ but is usually an error because the callback will invoke
    the `write` method after the stream has been closed, or not all the data will
    be written to the stream because the `drain` event won’t be emitted. To avoid
    this mistake, ensure that the `end` method is invoked within the callback function
    once the data has been written.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能会有所不同，但通常是一个错误，因为回调将在流关闭后调用`write`方法，或者由于`drain`事件不会触发，所以不会将所有数据写入流。为了避免这种错误，确保在数据写入后，在回调函数中调用`end`方法。
- en: 'Use a browser to request `http://localhost:5000`, and you will see Node.js
    console messages that show the writing stops as the buffer reaches capacity, resuming
    once the buffer is drained:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求`http://localhost:5000`，你将看到Node.js控制台消息显示，当缓冲区达到容量时写入停止，一旦缓冲区被清空，写入将恢复：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Reading data from a stream
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从流中读取数据
- en: The most important source of data in a web application comes from HTTP request
    bodies. The example project needs a little preparation so that the client-side
    code can make an HTTP request with a body. Add a file named `index.html` to the
    `static` folder with the content shown in *Listing 6.10*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序中数据的最重要来源是 HTTP 请求体。示例项目需要做一些准备工作，以便客户端代码可以带有请求体的 HTTP 请求。将名为 `index.html`
    的文件添加到 `static` 文件夹中，其内容如 *列表 6.10* 所示。
- en: 'Listing 6.10: The Contents of the index.html File in the static Folder'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10：static 文件夹中 index.html 文件的内容
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a simple HTML document that contains some JavaScript code. I’ll make
    improvements later in the chapter, including separating the JavaScript and HTML
    content into separate files, but this is enough to get started. The JavaScript
    code in *Listing 6.10* uses the browser’s Fetch API to send an HTTP POST request
    with a body that contains 1,000 lines of text. *Listing 6.11* updates the existing
    request handler so that it responds with the contents of the HTML file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含一些 JavaScript 代码的简单 HTML 文档。我将在本章后面进行改进，包括将 JavaScript 和 HTML 内容分别放入单独的文件中，但这对开始来说已经足够了。*列表
    6.10* 中的 JavaScript 代码使用浏览器的 Fetch API 发送包含 1,000 行文本的 HTTP POST 请求。*列表 6.11*
    更新现有的请求处理器，使其以 HTML 文件的内容作为响应。
- en: 'Listing 6.11: Updating the Handlers in the handler.ts File in the src Folder'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.11：在 src 文件夹的 handler.ts 文件中更新处理器
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I use the `readFileSync` function to perform a blocking read of the `index.html`
    file, which is simple but is not the best way to read files, as I explain later
    in this chapter. To create a new handler that will be used to read the data sent
    by the browser, add a file named `readHandler.ts` to the `src` folder with the
    contents shown in *Listing 6.12*. For the moment, this handler is a placeholder
    that ends the response without producing any content.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `readFileSync` 函数对 `index.html` 文件进行阻塞读取，这很简单，但正如我在本章后面解释的那样，这不是读取文件的最佳方式。为了创建一个将用于读取浏览器发送的数据的新处理器，将名为
    `readHandler.ts` 的文件添加到 `src` 文件夹中，其内容如 *列表 6.12* 所示。目前，此处理器是一个占位符，在响应结束时不会产生任何内容。
- en: 'Listing 6.12: The Contents of the readHandler.ts File in the src Folder'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12：src 文件夹中 readHandler.ts 文件的内容
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6.13* completes the preparation by adding a route that matches POST
    requests and sends them to the new handler.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6.13* 通过添加一个匹配 POST 请求并将它们发送到新处理器的路由来完成准备工作。'
- en: 'Listing 6.13: Adding a Route in the server.ts File in the src Folder'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.13：在 src 文件夹的 server.ts 文件中添加路由
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Use a browser to request `http://localhost:5000`, and you will see the button
    defined by the HTML document. Click the button, and the browser will send an HTTP
    POST request and display the status message from the response it receives, as
    shown in *Figure 6.5*. The content presented by the browser is completely unstyled,
    but this is enough for now.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求 `http://localhost:5000`，你将看到由 HTML 文档定义的按钮。点击按钮，浏览器将发送 HTTP POST 请求并显示从响应中接收到的状态消息，如图
    *图 6.5* 所示。浏览器呈现的内容完全未加样式，但这对目前来说已经足够了。
- en: '![](img/B21959_06_05.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_06_05.png)'
- en: 'Figure 6.5: Sending an HTTP POST request'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：发送 HTTP POST 请求
- en: Understanding the Readable class
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Readable 类
- en: The `Readable` class is used to read data from a stream. *Table 6.6* describes
    the most useful `Readable` features.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Readable` 类用于从流中读取数据。*表 6.6* 描述了 `Readable` 类最有用的功能。'
- en: '*Table 6.6*: Useful Readable Features'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 6.6*：有用的 Readable 功能'
- en: '| Name | Description |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `pause()` | Calling this method tells the stream to temporarily stop emitting
    the `data` event. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `pause()` | 调用此方法会指示流暂时停止发出 `data` 事件。|'
- en: '| `resume()` | Calling this method tells the stream to resume emitting the
    `data` event. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `resume()` | 调用此方法会指示流恢复发出 `data` 事件。|'
- en: '| `isPaused()` | This method returns `true` if the stream’s `data` events have
    been paused. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `isPaused()` | 如果流的 `data` 事件已被暂停，则此方法返回 `true`。|'
- en: '| `pipe(writable)` | This method is used to transfer the stream’s data to a
    `Writable`. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `pipe(writable)` | 此方法用于将流的数据传输到 `Writable`。|'
- en: '| `destroy(error)` | This method destroys the stream immediately, without waiting
    for any pending data to be processed. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `destroy(error)` | 此方法立即销毁流，而不等待任何挂起的数据被处理。|'
- en: '| `closed` | This property returns `true` if the stream has been closed. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `closed` | 如果流已被关闭，则此属性返回 `true`。|'
- en: '| `destroyed` | This property returns `true` if the `destroy` method has been
    called. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `destroyed` | 如果已调用 `destroy` 方法，则此属性返回 `true`。|'
- en: '| `errored` | This property returns `true` if the stream has encountered an
    error. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `errored` | 如果流遇到错误，则此属性返回 `true`。 |'
- en: The `Readable` class also emits events, the most useful of which are described
    in *Table 6.7*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Readable` 类也会触发事件，其中最有用的描述在 *表 6.7* 中。'
- en: 'Table 6.7: Useful Readable Events'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.7：有用的 Readable 事件
- en: '| Name | Description |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `data` | This event is emitted when the stream is in flowing mode and provides
    access to the data in the stream. See the *Reading Data with events* section for
    details. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `data` | 当流处于流动模式且提供对流中数据的访问时触发此事件。有关详细信息，请参阅 *使用事件读取数据* 部分。 |'
- en: '| `end` | This event is emitted when there is no more data to be read from
    the stream. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `end` | 当没有更多数据可从流中读取时触发此事件。 |'
- en: '| `close` | This event is emitted when the stream is closed. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `close` | 当流关闭时触发此事件。 |'
- en: '| `pause` | This event is emitted when data reading is paused by calling the
    `pause` method. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `pause` | 当调用 `pause` 方法暂停数据读取时触发此事件。 |'
- en: '| `resume` | This event is emitted when data reading is restarted by calling
    the `resume` method. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `resume` | 当调用 `resume` 方法重新启动数据读取时触发此事件。 |'
- en: '| `error` | This event is triggered if there is an error reading data from
    the stream. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `error` | 如果从流中读取数据时发生错误，则触发此事件。 |'
- en: Reading data with events
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事件读取数据
- en: Data can be read from the stream using events, as shown in *Listing 6.14*, where
    a callback function is used to process data as it becomes available.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用事件从流中读取数据，如 *清单 6.14* 所示，其中使用回调函数处理数据。
- en: 'Listing 6.14: Reading Data in the readHandler.ts File in the src Folder'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6.14：在 src 文件夹中的 readHandler.ts 文件中读取数据
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `data` event is emitted when data is available to be read from the stream
    and is available for processing by the callback function used to handle the event.
    The data is passed to the callback function as a `Buffer`, which represents an
    array of unsigned bytes, unless the `setEncoding` method has been used to specify
    character encoding, in which case the data is expressed as a `string`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当从流中读取到可读数据时，会触发 `data` 事件，并且该事件可用于处理回调函数。数据作为 `Buffer` 传递给回调函数，它表示无符号字节的数组，除非已使用
    `setEncoding` 方法指定字符编码，在这种情况下，数据以 `string` 的形式表示。
- en: This example sets the character encoding to UTF-8 so that the callback function
    for the `data` event will receive `string` values, which are then written out
    using the `console.log` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将字符编码设置为 UTF-8，以便 `data` 事件的回调函数将接收 `string` 类型的值，然后使用 `console.log` 方法将其写入。
- en: 'The `end` event is emitted when all of the data has been read from the stream.
    To avoid a variation of the early-end pitfall I described earlier, I call the
    response’s `end` method only when the readable stream’s `end` method is emitted.
    Use a browser to request `http://localhost:5000` and click the **Send Request**
    button, and you will see a sequence of Node.js console messages as the data is
    read from the stream:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当从流中读取所有数据时，会触发 `end` 事件。为了避免我之前描述的早期结束陷阱的变体，我仅在可读流的 `end` 方法触发时调用响应的 `end`
    方法。使用浏览器请求 `http://localhost:5000` 并点击 **发送请求** 按钮，你将看到一系列 Node.js 控制台消息，因为数据正从流中读取：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The JavaScript main thread ensures that `data` events are processed sequentially,
    but the basic idea is that data is read and processed as quickly as possible,
    such that the `data` event will be emitted as soon as possible once data is available
    to be read.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 主线程确保 `data` 事件按顺序处理，但基本思想是尽可能快地读取和处理数据，以便一旦有可读数据，就会尽快触发 `data` 事件。
- en: Reading data with an iterator
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用迭代器读取数据
- en: Instances of the `Readable` class can be used as a source of data in a `for`
    loop, which can provide a more familiar way to read data from a stream, as shown
    in *Listing 6.15*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Readable` 类的实例可以用作 `for` 循环中的数据源，这可以提供一种更熟悉的方式来从流中读取数据，如 *清单 6.15* 所示。'
- en: 'Listing 6.15: Reading Data in a Loop in the readHandler.ts File in the src
    Folder'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6.15：在 src 文件夹中的 readHandler.ts 文件中循环读取数据
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `async` and `await` keywords must be used as shown in the example, but the
    result is that the `for` loop reads data from the stream until it is all consumed.
    This example produces the same output as *Listing 6.14*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 关键字必须按照示例所示使用，但结果是 `for` 循环会从流中读取数据，直到全部消耗完毕。此示例产生的输出与 *清单
    6.14* 相同。'
- en: Piping data to a writable stream
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据管道传输到可写流
- en: The `pipe` method is used to connect a `Readable` stream to a `Writeable` stream,
    ensuring that all of the data is read from the `Readable` and written to the `Writable`
    without further intervention, as shown in *Listing 6.16*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pipe` 方法将一个 `Readable` 流连接到一个 `Writeable` 流，确保所有数据都从 `Readable` 流中读取，并写入到
    `Writeable` 流中，无需进一步干预，如 *列表 6.16* 所示。
- en: 'Listing 6.16: Piping Data into the readHandler.ts File in the src Folder'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.16：在 src 文件夹中的 readHandler.ts 文件中将数据管道传输到
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is the simplest way to transfer data between streams, and the `end` method
    is called automatically on the `Writeable` stream once all of the data has been
    transferred. Use a browser to request `http://localhost:5000` and click the **Send
    Request** button. The data that is sent in the HTTP request is piped to the HTTP
    response and displayed in the browser window, as shown in *Figure 6.6*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是传输数据流之间最简单的方法，一旦所有数据传输完成，`Writeable` 流会自动调用 `end` 方法。使用浏览器请求 `http://localhost:5000`
    并点击 **发送请求** 按钮。HTTP 请求中发送的数据会被管道传输到 HTTP 响应中，并在浏览器窗口中显示，如 *图 6.6* 所示。
- en: '![](img/B21959_06_06.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_06_06.png)'
- en: 'Figure 6.6: Piping data'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：管道数据
- en: Transforming data
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据转换
- en: The `Transform` class is used to create objects, known as *transformers*, that
    receive data from a `Readable` stream, process it in some way, and then pass it
    on. Transformers are applied to streams with the `pipe` method, as shown in *Listing
    6.17*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Transform` 类创建对象，称为 *transformers*，它们从 `Readable` 流接收数据，以某种方式处理它，然后传递出去。Transformers
    通过 `pipe` 方法应用于流，如 *列表 6.17* 所示。
- en: 'Listing 6.17: Creating a Transformer in the readHandler.ts File in the src
    Folder'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.17：在 src 文件夹中的 readHandler.ts 文件中创建 Transformer
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The argument to the `Transform` constructor is an object whose `transform`
    property value is a function that will be invoked when there is data to process.
    The function receives three arguments: a chunk of data to process, which can be
    of any data type, a string encoding type, and a callback function that is used
    to pass on the transformed data. In this example, the data that is received is
    converted to a string on which the `toLowerCase` method is called. The result
    is passed to the callback function, whose arguments are an object that represents
    any error that has occurred and the transformed data.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform` 构造函数的参数是一个对象，其 `transform` 属性值是一个函数，当有数据要处理时会被调用。该函数接收三个参数：要处理的数据块，可以是任何数据类型，一个字符串编码类型，以及一个回调函数，用于传递转换后的数据。在这个例子中，接收到的数据被转换成字符串，然后调用
    `toLowerCase` 方法。结果传递给回调函数，其参数是一个表示已发生任何错误的对象和转换后的数据。'
- en: 'The transformer is applied with the `pipe` method and, in this case, is chained
    so that the data read from the HTTP request is transformed and then written to
    the HTTP response. Note that a new `Transform` object must be created for every
    request, like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Transformer 通过 `pipe` 方法应用，在这种情况下，数据链被连接起来，以便从 HTTP 请求中读取的数据被转换，然后写入到 HTTP 响应中。请注意，必须为每个请求创建一个新的
    `Transform` 对象，如下所示：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Use a browser to request `http://localhost:5000`, and click on the **Send Request**
    button. The content displayed by the browser, which comes from the HTTP response
    body, is all lowercase, as shown in *Figure 6.7*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求 `http://localhost:5000`，并点击 **发送请求** 按钮。浏览器显示的内容，来自 HTTP 响应体，都是小写，如
    *图 6.7* 所示。
- en: '![](img/B21959_06_07.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_06_07.png)'
- en: 'Figure 6.7: Using a simple transformer'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：使用简单的 transformer
- en: Using object mode
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象模式
- en: The streams created by the Node.js API, such as the ones used for HTTP requests
    or files, work only on strings and byte arrays. This isn’t always convenient,
    and so some streams, including transformers, can use *object mode*, which allows
    objects to be read or written. To prepare for this example, *Listing 6.18* updates
    the JavaScript code contained within the static HTML file to send a request containing
    an array of JSON-formatted objects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js API 创建的流，如用于 HTTP 请求或文件的流，仅适用于字符串和字节数组。这并不总是方便的，因此一些流，包括 transformers，可以使用
    *对象模式*，允许读取或写入对象。为了准备这个例子，*列表 6.18* 更新了静态 HTML 文件中包含的 JavaScript 代码，以发送包含 JSON
    格式对象的请求。
- en: 'Listing 6.18: Sending a JSON Request Body in the index.html File in the static
    Folder'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.18：在静态文件夹中的 index.html 文件中发送 JSON 请求体
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The data sent by the client can still be read as a string or a byte array, but
    a transform can be used to convert the request payload into a JavaScript object
    or convert a JavaScript object into a string or byte array, known as *object mode*.
    Two `Transform` constructor configuration settings are used to tell Node.js how
    a transformer will behave, as described in *Table 6.8*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送的数据仍然可以以字符串或字节数组的形式读取，但可以使用转换器将请求数据包转换为 JavaScript 对象，或将 JavaScript 对象转换为字符串或字节数组，这被称为
    *对象模式*。使用两个 `Transform` 构造函数配置设置来告诉 Node.js 转换器将如何行为，如 *表 6.8* 所述。
- en: 'Table 6.8: The Transform Constructor Configuration Settings'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.8：Transform 构造函数配置设置
- en: '| Name | Description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `readableObjectMode` | When set to `true`, the transformer will consume string/byte
    data and produce an object. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `readableObjectMode` | 当设置为 `true` 时，转换器将消费字符串/字节数据并产生一个对象。 |'
- en: '| `writableObjectMode` | When set to `true`, the transformer will consume an
    object and produce string/byte data. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `writableObjectMode` | 当设置为 `true` 时，转换器将消费一个对象并产生字符串/字节数据。 |'
- en: '*Listing 6.19* shows a transformer that sets the `readableObjectMode` setting
    to `true`, which means that it will read string data from the HTTP request payload
    but produce a JavaScript object when its data is read.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6.19* 展示了一个将 `readableObjectMode` 设置为 `true` 的转换器，这意味着它将从 HTTP 请求有效载荷中读取字符串数据，但在读取数据时产生一个
    JavaScript 对象。'
- en: 'Listing 6.19: Parsing JSON in the readHandler.ts File in the src Folder'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.19：在 src 文件夹中的 readHandler.ts 文件中解析 JSON
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the HTTP request has a `Content-Type` header that indicates the payload is
    JSON, then the transformer is used to parse the data, which is received by the
    request handler using the `data` event. The parsed payload is checked to see if
    it is an array, and if it is, then its length is used to generate a response.
    Use a browser to request `http://localhost:5000` (or make sure to reload the browser
    so that the changes in *Listing 6.18* take effect), click the **Send Request**
    button, and you will see the response shown in *Figure 6.8*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 请求有一个 `Content-Type` 头部指示有效载荷是 JSON，那么转换器将用于解析数据，该数据是通过 `data` 事件由请求处理器接收的。解析后的有效载荷将被检查以确定它是否是一个数组，如果是，则使用其长度来生成响应。使用浏览器请求
    `http://localhost:5000`（或确保重新加载浏览器，以便 *列表 6.18* 中的更改生效），点击 **发送请求** 按钮，你将看到 *图
    6.8* 中显示的响应。
- en: '![](img/B21959_06_08.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_06_08.png)'
- en: 'Figure 6.8: Using a transformer in object mode'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：在对象模式下使用转换器
- en: Using third-party enhancements
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方增强功能
- en: In the sections that follow, I describe useful enhancements provided by the
    Express package to deal with streams and tasks that are related to HTTP. Express
    isn’t the only package that provides these kinds of features, but it is a good
    default choice for new projects and gives you a foundation from which to compare
    alternatives.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我描述了 Express 包提供的有用增强功能，用于处理流和与 HTTP 相关的任务。Express 不是唯一提供这些功能的包，但对于新项目来说是一个好的默认选择，并为你提供了一个比较替代方案的基础。
- en: Working with files
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件处理
- en: One of the most important tasks for a web server is to respond to requests for
    files, which provide browsers with the HTML, JavaScript, and other static content
    required by the client-side part of the application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Web 服务器来说，最重要的任务之一是响应对文件的请求，这些请求为客户端应用程序的客户端部分提供所需的 HTML、JavaScript 和其他静态内容。
- en: Node.js provides a comprehensive API to deal with files in the `fs` module,
    and it has support for reading and writing streams, along with convenience features
    that read or write complete files, such as the `readFileSync` function I used
    to read the contents of an HTML file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 在 `fs` 模块中提供了一个全面的 API 来处理文件，并且它支持读取和写入流，还包括一些便利的功能，例如 `readFileSync`
    函数，我使用它来读取 HTML 文件的內容。
- en: The reason I have not described the API in any detail is that working directly
    with files within a web server project is incredibly dangerous and should be avoided
    whenever possible. There is a huge scope to create malicious requests whose paths
    attempt to access files outside of the expected locations, for example. And, through
    personal experience, I have learned not to let clients create or modify files
    on the server under any circumstances.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有详细描述 API 的原因是因为在 Web 服务器项目中直接处理文件非常危险，应尽可能避免。存在很大的风险创建恶意请求，其路径试图访问预期位置之外的文件。通过个人经验，我了解到在任何情况下都不应让客户端在服务器上创建或修改文件。
- en: I have worked on too many projects where malicious requests have been able to
    overwrite system files or simply overwhelm servers by writing so much data that
    storage space is exhausted.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与过许多项目，在这些项目中，恶意请求能够覆盖系统文件，或者通过写入大量数据来简单地压倒服务器，导致存储空间耗尽。
- en: The best way to deal with files is to use a well-tested package, rather than
    write custom code, and it is for this reason that I have not described the features
    of the `fs` module.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件的最佳方式是使用经过良好测试的包，而不是编写自定义代码，这就是为什么我没有描述`fs`模块的功能。
- en: '**Note**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If you decide to ignore my warning, then you can find details of the `fs` module
    and the features it provides at [https://nodejs.org/dist/latest-v20.x/docs/api/fs.html](https://nodejs.org/dist/latest-v20.x/docs/api/fs.html).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定忽略我的警告，你可以在[https://nodejs.org/dist/latest-v20.x/docs/api/fs.html](https://nodejs.org/dist/latest-v20.x/docs/api/fs.html)找到`fs`模块及其提供的详细功能的说明。
- en: The Express package has integrated support to serve requests for files. To prepare,
    add a file named `client.js` to the `static` folder with the content shown in
    *Listing 6.20*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Express包集成了对文件请求的支持。为了准备，将名为`client.js`的文件添加到`static`文件夹中，其内容如*列表6.20*所示。
- en: 'Listing 6.20: The Contents of the client.js File in the static Folder'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.20：静态文件夹中client.js文件的内容
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is the same JavaScript code used in earlier examples but put into a separate
    file, which is the typical way of distributing JavaScript to clients. *Listing
    6.21* updates the HTML file to link to the new JavaScript file, and it also includes
    the image file that was added to the project at the start of the chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这与早期示例中使用的相同JavaScript代码，但被放入了单独的文件中，这是向客户端分发JavaScript的典型方式。*列表6.21*更新了HTML文件，以链接到新的JavaScript文件，并且还包括了在本章开头添加到项目中的图像文件。
- en: 'Listing 6.21: Changing Content in the index.html File in the static Folder'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.21：在静态文件夹中的index.html文件中更改内容
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Having prepared the content, the next step is to configure Express to serve
    the files. Express comes with support for middleware components, which just means
    request handlers that can inspect and intercept all the HTTP requests the server
    receives. Middleware components are set up with the `use` method, and *Listing
    6.22* sets up the middleware component that Express provides to serve files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好内容后，下一步是配置Express以提供文件服务。Express自带对中间件组件的支持，这意味着可以检查和拦截服务器接收到的所有HTTP请求的处理程序。中间件组件通过`use`方法设置，*列表6.22*设置了Express提供的用于提供文件的中间件组件。
- en: 'Listing 6.22: Adding Support for Static Files in the server.ts File in the
    src Folder'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.22：在src文件夹中的server.ts文件中添加对静态文件的支持
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `express` object, which is the default export from the `express` module,
    defines a method named `static` that creates the middleware component that serves
    static files. The argument to the `static` method is the directory that contains
    the files, which is also named `static`. The result is a request handler that
    can be registered with the `Express.use` method.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`express`对象，它是`express`模块的默认导出，定义了一个名为`static`的方法，该方法创建用于提供静态文件的中间件组件。`static`方法的参数是包含文件的目录，也命名为`static`。结果是可以通过`Express.use`方法注册的请求处理程序。'
- en: The middleware component will attempt to match request URLs to files in the
    `static` directory. The name of the directory that contains the files is omitted
    from the URLs, so a request for `http://localhost:5000/client.js`, for example,
    will be handled by returning the contents of the `client.js` file in the `static`
    folder.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件组件将尝试将请求URL与`static`目录中的文件匹配。包含文件的目录名称从URL中省略，因此对`http://localhost:5000/client.js`的请求将由返回`static`文件夹中`client.js`文件的內容来处理。
- en: The `static` method can accept a configuration object, but the default values
    are well-chosen and suit most projects, including using the `index.html` as the
    default for requests.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`方法可以接受一个配置对象，但默认值选择得很好，适用于大多数项目，包括将`index.html`作为请求的默认值。'
- en: '**Tip**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: If you need to change the settings, you can see the options at [https://expressjs.com/en/4x/api.html#express.static](https://expressjs.com/en/4x/api.html#express.static).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更改设置，你可以在[https://expressjs.com/en/4x/api.html#express.static](https://expressjs.com/en/4x/api.html#express.static)查看选项。
- en: The middleware component sets the response headers to help the client process
    the contents of the files that are used. This includes setting the `Content-Length`
    header to specify the amount of data the file contains, and the `Content-Type`
    header to specify the type of data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件组件设置响应头以帮助客户端处理使用的文件内容。这包括设置 `Content-Length` 头以指定文件包含的数据量，以及 `Content-Type`
    头以指定数据类型。
- en: Notice that I can remove some of the existing handlers from the example. The
    handler for `favicon.ico` requests is no longer required because the new middleware
    will automatically generate “not found” responses when requests ask for files
    that don’t exist. The catch-all route is no longer required because the `static`
    middleware responds to requests with the contents of the `index.html` file. Use
    a browser to request `http://localhost:5000`, and you will see the response shown
    in *Figure 6.9*, which also shows the data types that the browser has received.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我可以从示例中移除一些现有的处理器。`favicon.ico` 请求的处理器不再需要，因为新的中间件将在请求不存在文件时自动生成“未找到”的响应。通配符路由也不再需要，因为
    `static` 中间件会对请求响应以 `index.html` 文件的内容。使用浏览器请求 `http://localhost:5000`，你将看到 *图
    6.9* 中显示的响应，它还显示了浏览器接收到的数据类型。
- en: '![](img/B21959_06_09.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21959_06_09.png](img/B21959_06_09.png)'
- en: 'Figure 6.9: Using the Express static middleware'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '图 6.9: 使用 Express 静态中间件'
- en: Serving files from client-side packages
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从客户端包提供文件
- en: One source of static files is packages that are added to the Node.js project,
    but whose files are intended for consumption by browsers (or other HTTP clients).
    A good example is the Bootstrap CSS package, which contains CSS stylesheets and
    JavaScript files that are used to style the HTML content displayed by browsers.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件的一个来源是添加到 Node.js 项目中，但其文件旨在由浏览器（或其他 HTTP 客户端）消费的包。一个很好的例子是 Bootstrap CSS
    包，它包含用于为浏览器显示的 HTML 内容添加样式的 CSS 样式表和 JavaScript 文件。
- en: If you are using a client-side framework such as Angular or React, these CSS
    and JavaScript files will be incorporated into a single compressed file as part
    of the project build process.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Angular 或 React 等客户端框架，这些 CSS 和 JavaScript 文件将在项目构建过程中作为单个压缩文件合并。
- en: For projects that don’t use these frameworks, the simplest way to make the files
    available is to set up additional instances of the static file middleware. To
    prepare, run the command shown in *Listing 6.23* in the `webapp` folder to add
    the Bootstrap package to the example project.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不使用这些框架的项目，使文件可用的最简单方法是设置静态文件中间件的额外实例。为了准备，请在 `webapp` 文件夹中运行 *列表 6.23* 中显示的命令，将
    Bootstrap 包添加到示例项目中。
- en: 'Listing 6.23: Adding a Package to the Example Project'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6.23: 将包添加到示例项目'
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 6.24* configures Express to serve files from the package directory.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6.24* 配置 Express 从包目录中提供文件。'
- en: Listing 6.24\. Adding Middleware in the server.ts File in the src Folder
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.24\. 在 src 文件夹的 server.ts 文件中添加中间件
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Some knowledge of the packages you are using is required. In the case of the
    Bootstrap package, I know that the files used by clients are in the `dist` folder,
    and so this is the folder that I specified when setting up the middleware clients.
    The final step is to add a reference to a Bootstrap stylesheet and apply the styles
    it contains, as shown in *Listing 6.25*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 需要了解你正在使用的包的一些知识。在 Bootstrap 包的情况下，我知道客户端使用的文件位于 `dist` 文件夹中，因此这是我在设置中间件客户端时指定的文件夹。最后一步是添加对
    Bootstrap 样式表的引用并应用其包含的样式，如 *列表 6.25* 所示。
- en: Listing 6.25\. Adding a Stylesheet Reference in the index.html File in the static
    Folder
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.25\. 在 static 文件夹的 index.html 文件中添加样式表引用
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `bootstrap.min.css` file contains the styles I want to use, which are applied
    by adding the `button` element to classes. Use a browser to request `http://localhost:5000`,
    and you will see the effect of the styles, as shown in *Figure 6.10*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`bootstrap.min.css` 文件包含我想要使用的样式，这些样式通过向类中添加 `button` 元素来应用。使用浏览器请求 `http://localhost:5000`，你将看到样式的效果，如
    *图 6.10* 所示。'
- en: '**Note**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: See [https://getbootstrap.com](https://getbootstrap.com) for details of the
    features the Bootstrap package provides, some of which I use in later chapters.
    There are other CSS packages available if you can’t get along with Bootstrap.
    A popular alternative is Tailwind ([https://tailwindcss.com](https://tailwindcss.com)),
    but a quick web search will present you with a long list of alternatives to consider.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Bootstrap 包提供的功能详情，请参阅 [https://getbootstrap.com](https://getbootstrap.com)，其中一些我在后面的章节中使用。如果您无法使用
    Bootstrap，还有其他 CSS 包可用。一个流行的替代方案是 Tailwind ([https://tailwindcss.com](https://tailwindcss.com))，但快速网络搜索将向您展示一个长长的可供考虑的替代方案列表。
- en: '![](img/B21959_06_10.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_06_10.png)'
- en: 'Figure 6.10: Using static content from a third-party package'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10：使用第三方包的静态内容
- en: Sending and downloading files
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送和下载文件
- en: The `Response` class, through which Express provides `ServerResponse` enhancements,
    defines the methods described in *Table 6.9* to deal with files directly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 类，通过它 Express 提供了 `ServerResponse` 的增强功能，定义了 *表 6.9* 中描述的方法来直接处理文件。'
- en: 'Table 6.9: Useful Response Methods for Files'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.9：文件有用的响应方法
- en: '| Name | Description |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `sendFile(path, config)` | This method sends the contents of the specified
    file. The response `Content-Type` header is set based on the file extension. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `sendFile(path, config)` | 此方法发送指定文件的內容。响应 `Content-Type` 头基于文件扩展名设置。|'
- en: '| `download(path)` | This method sends the contents of the specified file such
    that most browsers will prompt the user to save the file. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `download(path)` | 此方法发送指定文件的內容，使得大多数浏览器会提示用户保存文件。|'
- en: The `sendFile` and `download` methods are useful because they provide solutions
    to problems that cannot be solved using the `static` middleware. *Listing 6.26*
    creates simple routes that use these methods.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendFile` 和 `download` 方法很有用，因为它们提供了使用 `static` 中间件无法解决的问题的解决方案。*列表 6.26*
    创建了使用这些方法的简单路由。'
- en: 'Listing 6.26: Adding Routes in the server.ts File in the src Folder'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.26：在 src 文件夹的 server.ts 文件中添加路由
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `sendFile` method is useful when you need to respond with the content of
    a file but the request path doesn’t contain the filename. The arguments are the
    name of the file and a configuration object, whose root property specifies the
    directory that contains the file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要以文件内容作为响应，但请求路径不包含文件名时，`sendFile` 方法很有用。参数是文件名和一个配置对象，其 root 属性指定包含文件的目录。
- en: The `download` method sets the `Content-Disposition` response header, which
    causes most browsers to treat the file contents as a download that should be saved.
    Use a browser to request `http://localhost:5000/sendcity` and `http://localhost:5000/downloadcity`.
    The first URL will cause the browser to display the image in the browser window.
    The second URL will prompt the user to save the file. Both responses are shown
    in *Figure 6.11*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`download` 方法设置 `Content-Disposition` 响应头，导致大多数浏览器将文件内容视为应保存的下载。使用浏览器请求 `http://localhost:5000/sendcity`
    和 `http://localhost:5000/downloadcity`。第一个 URL 将导致浏览器在浏览器窗口中显示图片。第二个 URL 将提示用户保存文件。这两个响应都显示在
    *图 6.11* 中。'
- en: '![](img/B21959_06_11.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_06_11.png)'
- en: 'Figure 6.11: Using the file response enhancements'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11：使用文件响应增强功能
- en: Automatically decoding and encoding JSON
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动解码和编码 JSON
- en: The Express package includes a middleware component that decodes JSON response
    bodies automatically, performing the same task as the stream transformer I created
    earlier in the chapter. *Listing 6.27* enables this middleware by calling the
    `json` method defined on the default export from the `express` module.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Express 包包括一个自动解码 JSON 响应体的中间件组件，执行与本章前面创建的流转换器相同的任务。*列表 6.27* 通过调用 `express`
    模块的默认导出上定义的 `json` 方法来启用此中间件。
- en: 'Listing 6.27: Enabling JSON Middleware in the server.ts File in the src Folder'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.27：在 src 文件夹的 server.ts 文件中启用 JSON 中间件
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The middleware component must be registered before the routes that read response
    bodies so that JSON requests are parsed before they are matched to a handler.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件组件必须在读取响应体的路由之前注册，这样 JSON 请求在匹配到处理器之前就会被解析。
- en: '**Note**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `json` method can accept a configuration object that changes the way that
    JSON is parsed. The defaults are suitable for most projects, but see [https://expressjs.com/en/4x/api.html#express.json](https://expressjs.com/en/4x/api.html#express.json)
    for details of the available options.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`json` 方法可以接受一个配置对象，该对象可以改变 JSON 解析的方式。默认值适用于大多数项目，但请参阅 [https://expressjs.com/en/4x/api.html#express.json](https://expressjs.com/en/4x/api.html#express.json)
    了解可用选项的详细信息。'
- en: The `Request` class through which Express provides enhancements to the `IncomingRequest`
    class defines a `body` property, which is assigned the object created by the JSON
    middleware.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Express 提供对 `IncomingRequest` 类增强的 `Request` 类定义了一个 `body` 属性，该属性被分配给 JSON
    中间件创建的对象。
- en: The `Response` body, which provides `ServerResponse` enhancements, defines the
    `json` method, which accepts an object that is serialized to JSON and used as
    the response body.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 提供对 `ServerResponse` 增强的 `Response` 主体定义了一个 `json` 方法，该方法接受一个序列化为 JSON 的对象，并将其用作响应主体。
- en: '*Listing 6.28* updates the handler to use the `Request` class, disables the
    custom transformer, and sends a JSON response to the client.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6.28* 更新了处理程序以使用 `Request` 类，禁用了自定义转换器，并向客户端发送 JSON 响应。'
- en: 'Listing 6.28: Using the JSON Object in the readHandler.ts File in the src Folder'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.28：在`src`文件夹中的`readHandler.ts`文件中使用 JSON 对象
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Use a web browser to request `http://localhost:5000`, and click the **Send Request**
    button. The response will confirm that the JSON request body was parsed into a
    JavaScript array and the response was sent back as JSON as well, as shown in *Figure
    6.12*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络浏览器请求 `http://localhost:5000`，然后点击 **发送请求** 按钮。响应将确认 JSON 请求主体被解析为 JavaScript
    数组，并且响应也以 JSON 的形式发送，如图 *6.12* 所示。
- en: '![](img/B21959_06_12.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_06_12.png)'
- en: 'Figure 6.12: Using the Express JSON middleware'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12：使用 Express JSON 中间件
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, I described the API features that Node.js provides to read
    and write data, particularly when processing an HTTP request:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了 Node.js 提供的 API 功能，用于读取和写入数据，尤其是在处理 HTTP 请求时：
- en: Streams are used as abstract representations of sources and destinations for
    data, including HTTP requests and responses.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流被用作数据源和目的地的抽象表示，包括 HTTP 请求和响应。
- en: Data is buffered when it is written to a stream, but it is a good idea to avoid
    excessive buffering because it can exhaust system resources.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据写入流时，数据会被缓冲，但避免过度缓冲是一个好主意，因为它可能会耗尽系统资源。
- en: Data can be read from a stream by handling events or using a `for` loop.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以通过处理事件或使用`for`循环从流中读取。
- en: Data can be piped from a readable stream to a writable stream.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以从可读流管道传输到可写流。
- en: Data can be transformed as it is piped and can be between JavaScript objects
    and strings/byte arrays.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据在管道传输过程中可以被转换，并且可以是在 JavaScript 对象和字符串/字节数组之间。
- en: Node.js provides an API to work with files, but third-party packages are the
    safest way to work with files in a web server project.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 提供了一个 API 来处理文件，但第三方包是在网络服务器项目中处理文件的最安全方式。
- en: Third-party packages, such as Express, provide enhancements to the Node.js streams
    to perform common tasks, such as decoding JSON data.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方包，如 Express，提供了对 Node.js 流的增强，以执行常见任务，例如解码 JSON 数据。
- en: In the next chapter, I describe two aspects of web development in which Node.js
    works together with other components to deliver an application.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将描述 Node.js 与其他组件一起工作的两个方面，以交付应用程序。
