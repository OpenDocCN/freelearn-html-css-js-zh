- en: '*Chapter 2*: Automated Testing and Test runners'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：自动化测试和测试运行器'
- en: 'In [*Chapter 1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Getting
    started with Puppeteer*, we covered the first fundamental pillar of this book:
    browser automation and headless browsers. In this chapter, we are going to cover
    the second pillar: UI testing. We learned that Puppeteer is not just about testing,
    but that doesn''t mean that it''s not an excellent tool for the job.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第一章*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014) *使用 Puppeteer 入门*
    中，我们介绍了这本书的第一个基本支柱：浏览器自动化和无头浏览器。在本章中，我们将介绍第二个支柱：UI 测试。我们了解到 Puppeteer 不仅关于测试，但这并不意味着它不是一个出色的工具。
- en: 'In this chapter, we are going to learn the fundamentals of Testing Automation.
    We are going to see the differences between UI Testing and End-to-End testing.
    If you have tried to write tests in Node.js before, you might have come across
    some weird names: Mocha, Jest, Jasmine, AVA, or Chai. That feels quite overwhelming
    if you are not used to these tools. We are going to see which are the right tools
    for us.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习测试自动化的基础知识。我们将看到 UI 测试和端到端测试之间的区别。如果你之前尝试在 Node.js 中编写测试，你可能遇到过一些奇怪的名字：Mocha、Jest、Jasmine、AVA
    或 Chai。如果你不习惯这些工具，这会感觉相当令人不知所措。我们将看到哪些工具适合我们。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introduction to Automated Testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试简介
- en: Test runner main features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试运行器主要功能
- en: Available Test runners
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的测试运行器
- en: Creating our first test project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个测试项目
- en: Organizing our code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织我们的代码
- en: Once we understand these foundational concepts and we learn how test runners
    work, we will be able to dive deep into the Puppeteer API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了这些基础概念，并学习了测试运行器的工作原理，我们就能深入探索 Puppeteer API。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will find all the code of this chapter on the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter2` directory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 GitHub 仓库（[https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer)）的
    `Chapter2` 目录下找到本章的所有代码。
- en: Introduction to Automated Testing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试简介
- en: Testing is a fundamental task in software development. Even if you consider
    yourself a bad tester, or even a bad developer, you do some testing when you code
    your app. At the very least, you open the app to see whether it works as expected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发中的基本任务。即使你认为自己是糟糕的测试员，或者甚至糟糕的开发者，当你编写你的应用程序时，你也会进行一些测试。至少，你会打开应用程序以查看它是否按预期工作。
- en: 'Maybe you are a little bit more methodical and you have a test plan, at least
    in your mind. You know that when you code a form, you have to validate some common
    scenarios:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你稍微有点条理性，你有一个测试计划，至少在你的脑海中。你知道当你编写表单时，你必须验证一些常见的场景：
- en: Try to save a form with empty fields.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试保存一个空字段的表单。
- en: Try to save with good data.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用良好数据保存。
- en: Try to enter bad data. You might enter text in numeric fields, invalid dates,
    and so on.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试输入错误的数据。你可能会在数字字段中输入文本，无效的日期等等。
- en: More experienced developers will cover all the possible scenarios. They will
    write code based on those scenarios and then test accordingly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 经验更丰富的开发者将涵盖所有可能的场景。他们将根据这些场景编写代码，然后相应地进行测试。
- en: 'Then we get to the word that''s driving this book: we **automate** stuff. We
    want to automate our tests. We don''t want to forget any scenarios or have to
    test the same thing over and over.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们来到了这本书中推动性的词汇：我们**自动化**事物。我们希望自动化我们的测试。我们不想忘记任何场景或不得不反复测试同一件事。
- en: 'As you will notice, I haven''t mentioned **Quality Assurance** (**QA**) analysts
    yet, because I want to highlight that testing is not something relegated to the
    QA team. Those who are involved in the testing process include the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将注意到的，我还没有提到**质量保证**（**QA**）分析师，因为我想强调测试不是仅限于 QA 团队的事情。参与测试过程的人包括以下：
- en: Backend developers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端开发者
- en: Frontend developers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端开发者
- en: QA analysts
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QA 分析师
- en: Managers (product or project managers)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经理（产品或项目经理）
- en: We need to know that there are different types of tests. Some types of tests
    will be performed by developers and QA analysts. Other tests will be specific
    to either developers or QA analysts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道存在不同类型的测试。某些类型的测试将由开发人员和 QA 分析师执行。其他测试将专门针对开发人员或 QA 分析师。
- en: 'Mike Cohn, in his book *Succeeding with Agile* (Addison-Wesley Professional),
    introduced his very popular Testing Pyramid:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Mike Cohn 在他的书 *Succeeding with Agile*（Addison-Wesley Professional）中介绍了他非常受欢迎的测试金字塔：
- en: '![Mike Cohn’s Testing Pyramid'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![Mike Cohn的测试金字塔'
- en: '](img/Figure_2.01_B16113.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_2.01_B16113.jpg](img/Figure_2.01_B16113.jpg)'
- en: Mike Cohn's Testing Pyramid
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Mike Cohn的测试金字塔
- en: Although Mike's book is more than 10 years old, this pyramid is still valid.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管迈克的书籍已经超过10年了，但这个金字塔仍然有效。
- en: 'This pyramid is based on three characteristics:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个金字塔基于三个特征：
- en: Number of tests
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试数量
- en: Isolation
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立性
- en: Speed
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度
- en: 'I have only one thing against this pyramid: the word **UI**. Modern apps rely
    more and more on client code, "UI" code. Frameworks such as React, Angular, and
    Vue.js allow developers to write reusable components. Many apps now have most
    of their business rules running on the client.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我只有一件事反对这个金字塔：这个词**UI**。现代应用程序越来越依赖于客户端代码，“UI”代码。例如React、Angular和Vue.js这样的框架允许开发者编写可重用的组件。现在许多应用程序的大部分业务规则都在客户端运行。
- en: 'Frontend developers should not be limited to the top of this pyramid. They
    should be able to write unit tests and service tests for their UI code. This might
    look like a small change, but I think it''s important. With this change in the
    paradigm, we get a pyramid that looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发者不应该局限于这个金字塔的顶端。他们应该能够为他们自己的UI代码编写单元测试和服务测试。这可能看起来是一个小的变化，但我认为这很重要。随着这种范式转变，我们得到了一个看起来是这样的金字塔：
- en: '![New Pyramid'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![新金字塔'
- en: '](img/Figure_2.02_B16113.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_2.02_B16113.jpg](img/Figure_2.02_B16113.jpg)'
- en: New Pyramid
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 新金字塔
- en: Now that we have a better understanding, let's talk about the different levels
    of this pyramid.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了更好的理解，让我们来谈谈这个金字塔的不同层级。
- en: Unit tests
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are the base of the pyramid. The more business logic you cover in
    unit tests, the less ground you will need to cover in service or UI tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是金字塔的基础。你在单元测试中覆盖的业务逻辑越多，你将需要覆盖的服务或UI测试的地面就越少。
- en: As we can see in the pyramid, unit tests need to be **fast and isolated**. That
    means that a good unit test shouldn't depend on the environment or any other function.
    Sometimes this is easier said than done. For instance, if you want to test that
    the total amount of an invoice is equal to the sum of its items, you should be
    able to test that specific functionality in the code, without launching a web
    server or getting data from a database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在金字塔中可以看到的，单元测试需要**快速且独立**。这意味着一个好的单元测试不应该依赖于环境或任何其他功能。有时候说起来容易做起来难。例如，如果你想测试发票的总金额等于其项目的总和，你应该能够在代码中测试这个特定的功能，而不需要启动一个web服务器或从数据库获取数据。
- en: What roles use Unit tests?
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哪些角色使用单元测试？
- en: '**Backend developers**: For sure, Unit tests are for them. They follow the
    **Test-Driven Development** (**TDD**) process if possible. TDD is a technique
    in software development where tests are written even before any source code has
    been written. Once the tests have been written, the developer will program the
    source code to make them pass.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**后端开发者**：当然，单元测试是为他们准备的。如果可能的话，他们会遵循**测试驱动开发**（**TDD**）的过程。TDD是软件开发中的一种技术，其中测试是在编写任何源代码之前编写的。一旦编写了测试，开发者将编写源代码以使它们通过。'
- en: '**Frontend developers**: Writing unit tests was almost impossible in the past.
    If you didn''t have the right tools, you couldn''t do your job correctly. But
    now, many modern libraries support unit testing. If you use React and Redux, you
    will find that Redux has a way to write unit tests for your components (https://www.hardkoded.com/ui-testing-with-puppeteer/redux-unit-tests).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**前端开发者**：在以前，编写单元测试几乎是不可行的。如果没有合适的工具，你就不能正确地完成你的工作。但现在，许多现代库支持单元测试。如果你使用React和Redux，你会发现Redux有为你组件编写单元测试的方法（https://www.hardkoded.com/ui-testing-with-puppeteer/redux-unit-tests）。'
- en: That's not all. In the same way that backend developers need to think about
    how to make their code testable, if frontend developers, using modern frameworks,
    start creating small and testable components, **they should be able to use Puppeteer
    to write UI unit tests**. And here is where the "UI" at the top of the testing
    pyramid stops making any sense. Now we can write **UI unit tests**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部。同样地，后端开发者需要考虑如何使他们的代码可测试，如果前端开发者使用现代框架开始创建小型且可测试的组件，**他们应该能够使用Puppeteer来编写UI单元测试**。这就是为什么测试金字塔顶部的“UI”不再有任何意义。现在我们可以编写**UI单元测试**。
- en: We can run a small test, rendering a component and testing, for instance, that
    it "*renders a textbox and when I enter a value, the label below changes*," or
    "*if I pass a list of 10 items, 10 elements are rendered*."
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行一个小测试，渲染一个组件并测试，例如，它“渲染一个文本框，当我输入一个值时，下面的标签会改变”，或者“如果我传递一个包含10个项目的列表，将渲染10个元素。”
- en: '*We moved UI testing to the bottom of the testing pyramid.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将UI测试移到了测试金字塔的底部。*'
- en: '**QA Analysts** are not involved yet. Unit tests are about testing the internal
    code.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**质量分析师**目前还没有参与。单元测试是关于测试内部代码的。'
- en: How about **Managers**? If you are a developer, I believe you are going to show
    this paragraph to your boss. Managers won't write unit tests, but they need to
    know the importance of writing unit tests and investing time in them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于**经理**呢？如果你是开发者，我相信你会把这段话展示给你的老板。经理不会编写单元测试，但他们需要知道编写单元测试和投入时间的重要性。
- en: These are the four benefits you (or your boss) need to know about.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你（或你的老板）需要了解的四个好处。
- en: Unit tests show how the code works
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试展示了代码的工作方式
- en: Unit tests explain how the code works. When I review code, I start by reviewing
    unit tests. If I find unit tests saying, for instance, "*Create order should send
    email*". I could read that test first, and then, check how that rule was implemented.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试解释了代码的工作方式。当我审查代码时，我首先审查单元测试。如果我发现单元测试写着，例如，“*创建订单应该发送电子邮件*”。我可以先阅读这个测试，然后检查这个规则是如何实现的。
- en: Business Analysts or project managers could read these tests and see whether
    there are any scenarios that haven't been covered or some missing validation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 业务分析师或项目经理可以阅读这些测试，看看是否有任何未覆盖的场景或缺失的验证。
- en: Unit tests make refactoring possible
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试使重构成为可能
- en: I took a risk using the word possible. But I believe that's true. You can't
    refactor your code if you don't have unit tests backing your changes. Remember,
    refactoring is changing the implementation of your code without changing the result
    given specific inputs. Unit tests guarantee that premise.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用“可能”这个词是冒了点风险。但我相信这是真的。如果你没有单元测试来支持你的更改，你就不能重构你的代码。记住，重构是在不改变特定输入结果的情况下改变代码的实现。单元测试保证了这一点。
- en: Unit tests prevent regressions
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试防止回归
- en: '**Regression is an involuntary change in the expected behavior of an app**.
    If we have a good set of tests, they will prevent us from breaking any behavior
    of the app while we implement new features or while fixing bugs.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**回归是应用程序预期行为的不自觉变化**。如果我们有一套好的测试，它们将防止我们在实现新功能或修复错误时破坏应用程序的任何行为。'
- en: How can I make sure that some other developers won't come and break the precious
    function I just wrote? By writing unit tests. A unit test is a version of you
    in the future enforcing how a piece of code should work. "*Create an order should
    send an email*" – no one will be able to break that rule.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我如何确保其他开发者不会来破坏我刚刚编写的宝贵功能？通过编写单元测试。单元测试是你未来版本的自己，强制执行代码应该如何工作。“*创建订单应该发送电子邮件*”——没有人能够打破这个规则。
- en: When I review code, changes in unit tests are a red flag to me. I'm not saying
    that unit tests shouldn't change. But if a test changes, there must be an explanation.
    Now, the "*Create and order should send an email*" shows that the sent email count
    is 2\. Is that right? Are we sending another email? Or do we have a regression?
    Pay attention to changes in unit tests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我审查代码时，单元测试的变化对我来说是一个红旗。我并不是说单元测试不应该改变。但如果一个测试改变了，必须有解释。现在，“*创建和排序应该发送电子邮件*”显示发送的电子邮件计数为2。这是正确的吗？我们还要发送另一封电子邮件吗？或者我们遇到了回归？请注意单元测试的变化。
- en: Time to go up in the test pyramid.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔上升的时间。
- en: Service tests
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务测试
- en: 'Service tests are also known as **Integration Tests**. These tests will check
    how your code interacts with other components. When we talk about components,
    we are talking about the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 服务测试也被称为**集成测试**。这些测试将检查你的代码如何与其他组件交互。当我们谈论组件时，我们指的是以下内容：
- en: Databases
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: Other components in the app
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的其他组件
- en: External services
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部服务
- en: 'Frontend developers would also need to integrate their code with the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发者还需要将他们的代码与以下内容集成：
- en: Other UI components
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他UI组件
- en: CSS files
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS文件
- en: REST APIs
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API
- en: As we mentioned before, when we go up in the testing pyramid, tests become **slower
    and less stable**. And it's supposed to be like that. You will be connecting to
    a real database or interacting with a real REST API that would use real network
    calls. That would also mean that your tests would expect the environment to respond
    in a certain way. For instance, you would expect the database to have some set
    of data ready to be used, or a REST API to be available.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，当我们上升测试金字塔时，测试会变得**更慢且更不稳定**。这是应该的。你将连接到真实的数据库或与真实的REST API交互，这将使用真实的网络调用。这也意味着你的测试将期望环境以某种方式响应。例如，你期望数据库有一些数据集准备好使用，或者REST
    API可用。
- en: That's why the more tests you have in the unit test layer, the fewer integration
    tests you will need to code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在单元测试层有更多测试，你就不需要编写太多的集成测试。
- en: Let's take, for instance, the class that sends an email, could you code an integration
    test for that? Sure. You set up a local email server that would write emails in
    a temp folder, so after creating an order, you could check that folder and see
    whether the email server processed the email your app should have sent. But, as
    you can see, these kinds of orchestrations are harder to code than small unit
    tests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以发送电子邮件的类为例，你能为它编写一个集成测试吗？当然可以。你设置一个本地电子邮件服务器，它会将电子邮件写入一个临时文件夹，因此在你创建订单后，你可以检查那个文件夹，看看电子邮件服务器是否处理了你应用应该发送的电子邮件。但是，正如你所看到的，这类编排比小型单元测试更难编写。
- en: Why do we need integration tests? Why don't we code unit tests only?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要集成测试？为什么我们只编写单元测试而不编写集成测试？
- en: Well, you need to tests your integrations. Your code won't run in isolation.
    If you are testing the backend, you need to see how the database reacts to the
    data you are inserting, or whether a SQL query returns the data you expect.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你需要测试你的集成。你的代码不会在孤立的环境中运行。如果你正在测试后端，你需要看到数据库如何响应你插入的数据，或者一个SQL查询是否返回了你预期的数据。
- en: If you are a frontend developer, this is where you would invest most of your
    time, checking how your component interacts on a page or how the HTML being generated
    affects other elements in the DOM. You would need to test how your component is
    being rendered with a real REST endpoint, instead of using a dummy JSON file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名前端开发者，你将在这里投入大部分时间，检查你的组件如何在页面上交互，或者生成的HTML如何影响DOM中的其他元素。你需要测试你的组件如何与真实的REST端点渲染，而不是使用虚拟的JSON文件。
- en: What roles use Integration tests?
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哪些角色使用集成测试？
- en: '`CreateOrder`, I get a new `Order` object. But now, I need to test that when
    I make a `POST` request to `/orders`, an order is created in the database.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateOrder`，我得到了一个新的`Order`对象。但现在，我需要测试当我向`/orders`发送`POST`请求时，数据库中是否创建了一个订单。'
- en: '**Frontend developers** will create tests to check how all the different components
    interact with each other on a page. Again, it''s UI testing down in the testing
    pyramid.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**前端开发者**将创建测试以检查页面上所有不同的组件如何相互交互。再次强调，这是在测试金字塔中的UI测试。'
- en: '**QA Analysts** will create tests similar to the tests backend and frontend
    developers create but with a different perspective.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**质量保证分析师**将创建与后端和前端开发者创建的测试类似的测试，但视角不同。'
- en: '*Developers and QA Analysts create the same kinds of tests but with a different
    perspective.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*开发者和质量保证分析师创建相同类型的测试，但视角不同。*'
- en: Developers will create tests to back their job, so they can check whether they
    broke anything. And, as we mentioned before, they need tests to be able to refactor
    their code in the future.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者将创建测试以支持他们的工作，这样他们就可以检查是否破坏了任何东西。而且，正如我们之前提到的，他们需要测试以便将来能够重构代码。
- en: '*QA Analysts will create tests to guarantee the application quality to the
    stakeholders.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*质量保证分析师将创建测试以确保应用程序质量符合利益相关者。*'
- en: 'There is one interesting type of test that QA Analysts can implement in this
    layer: the **Visual Regression Test**. These tests are used when we want to check
    whether there was any visual change regarding the style of the app. We don''t
    want to check whether there is a button, or whether that button works. We want
    to check whether the button looks like how it was before. How can we achieve that?
    By comparing images. This technique is based on four steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 质量保证分析师可以在这一层实现一种有趣的测试类型：**视觉回归测试**。这些测试在我们想要检查应用程序样式是否发生了任何视觉变化时使用。我们不想检查是否有按钮，或者那个按钮是否工作。我们想检查按钮看起来是否和之前一样。我们如何实现这一点？通过比较图像。这种技术基于以下四个步骤：
- en: We take a screenshot as a baseline:![Baseline image
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们截取一个作为基准的屏幕截图：![基准图像
- en: '](img/Figure_2.03_B16113.jpg)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图像](img/Figure_2.03_B16113.jpg)'
- en: Baseline image
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基准图像
- en: We make a change in the code.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在代码中进行了变更。
- en: We take another screenshot:![Image after making a change
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次截取屏幕截图：![变更后的图像
- en: '](img/Figure_2.04_B16113.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图像](img/Figure_2.04_B16113.jpg)'
- en: Image after making a change
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变更后的图像
- en: 'We compare both images:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们比较这两张图像：
- en: '![Differences](img/Figure_2.05_B16113.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![差异](img/Figure_2.05_B16113.jpg)'
- en: Differences
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 差异
- en: This type of test can be quite unstable. I bet you have seen that pages sometimes
    "move" when they are loading, so you have to be very sure when the page is ready
    for a screenshot. But it is doable. Another downside is that for every error you
    get, you have to analyze whether the change was a regression (a change made by
    mistake) or we are in the presence of a **new baseline**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的测试可能相当不稳定。我敢打赌，你看到过页面在加载时有时会“移动”，所以你必须非常确定页面何时准备好截图。但这是可以做到的。另一个缺点是，对于你得到的每一个错误，你必须分析这个更改是否是回归（一个错误做出的更改）或者我们是否处于**新的基线**的存在。
- en: The role of **managers** is still important. They need to provide the tools
    and the time for developers to implement the required integration tests. They
    will also help QA Analysts to determine what the integrations to test are.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理者**的角色仍然很重要。他们需要为开发者提供实施所需集成测试的工具和时间。他们还将帮助 QA 分析师确定要测试的集成。'
- en: And so we come to the top of the pyramid, the **end-to-end** tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们来到了金字塔的顶端，**端到端**测试。
- en: End-to-end tests
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: You might also find these tests referred to as **E2E** tests. The goal of E2E
    tests is to guarantee that an application works as expected through the entire
    workflow. Most applications will have more than one workflow. That would mean
    that it will require a number of E2E tests to cover all the possible workflows
    or scenarios.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能发现这些测试被称为**E2E**测试。端到端测试的目标是确保应用程序在整个工作流程中按预期工作。大多数应用程序将会有多个工作流程。这意味着它将需要多个端到端测试来覆盖所有可能的工作流程或场景。
- en: 'Let''s take a cart app as an example. These could be our tests:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以购物车应用为例。这些可能是我们的测试：
- en: 'Unit tests:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试：
- en: a) Passing a cart object, the `AddToCart` component renders an `AddToCart` component
    renders a "View cart" link if the product is in the array.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 传递一个购物车对象，`AddToCart`组件渲染一个“查看购物车”链接，如果产品在数组中。
- en: 'Integration tests:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试：
- en: a) Go to a product page and click "Add to cart." The link changes to "View cart."
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 前往产品页面并点击“添加到购物车”。链接变为“查看购物车”。
- en: b) Go to the checkout page. After clicking on the **Checkout** button, it gets
    disabled.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 前往结账页面。点击**结账**按钮后，它会被禁用。
- en: 'One E2E test testing the cart flow:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试购物车流程的端到端测试：
- en: a) Go to a product page, click **Add to cart**, then click on **View cart**.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 前往产品页面，点击**添加到购物车**，然后点击**查看购物车**。
- en: b) You should have got to the checkout page. Click **Checkout**.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 你应该到达结账页面。点击**结账**。
- en: c) You should have been redirected to the receipt page.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 你应该被重定向到收据页面。
- en: d) The receipt should show the product added to the cart.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 收据应该显示添加到购物车的产品。
- en: e) The price should be the product price.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e) 价格应该是产品价格。
- en: We are at the top of the pyramid. That means that these will be the **slowest
    and least stable** tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处于金字塔的顶端。这意味着这将是最**慢**和最**不稳定**的测试。
- en: Why least stable? Check the workflow. Many bad things can happen there. The
    add to cart endpoint might take a little bit more than expected. The scroll to
    the **Checkout** button could have failed for just a few pixels. Your database
    might be in an unexpected state. Maybe your user already purchased that product,
    so the **Add to cart** button is not enabled.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是最不稳定的？检查工作流程。那里可能会发生许多不好的事情。添加到购物车端点可能比预期的要花更多的时间。滚动到**结账**按钮可能因为仅仅几像素的失败而失败。您的数据库可能处于意外的状态。也许用户已经购买了该产品，所以**添加到购物车**按钮没有被启用。
- en: How about roles?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于角色呢？
- en: This is the **QA Analyst's** land. This is where they need to take advantage
    of all the features Puppeteer provides to make reliable tests. But **Developers**
    play an important role, helping the QA team to do their job efficiently. As we
    are going to see in the next chapters, a developer can leave hints so that the
    QA team can find the components they need.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**质量分析师**的领域。这是他们需要利用 Puppeteer 提供的所有功能来制作可靠测试的地方。但**开发者**也扮演着重要的角色，帮助 QA
    团队高效地完成工作。正如我们将在下一章中看到的，开发者可以留下提示，以便 QA 团队能够找到他们需要的组件。
- en: I hope the picture of the pyramid makes more sense now. We need lots of small
    and isolated unit tests, many integration tests testing our pages, and finally,
    a good set of E2E tests, checking the workflow's health.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望金字塔的图片现在更清晰了。我们需要大量的小型和隔离的单元测试，许多集成测试来测试我们的页面，最后，一组良好的端到端测试，检查工作流程的健康状况。
- en: This is the famous testing pyramid, but how do we write a test? Where do we
    write them? How do we run a test?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是著名的测试金字塔，但我们如何编写测试？在哪里编写它们？我们如何运行测试？
- en: First, we need to know what we need from a test runner.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解测试运行器需要我们提供什么。
- en: Test runner features
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试运行器功能
- en: 'What would the world be like without a test runner? Let''s say you don''t know
    what a test runner is, and you want to code a unit test. Would that be possible?
    I think it would. For instance, say we have this small `Cart` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试运行器，世界会是什么样子？假设你不知道什么是测试运行器，而你想编写一个单元测试。这可能吗？我认为是可能的。例如，假设我们有一个小的`Cart`类：
- en: '[PRE0]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we want to test it, we could run some code like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想测试它，我们可以运行一些像这样的代码：
- en: '[PRE1]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A test is basically a piece of code testing our code. Will this work? Yes. Is
    this a unit test? Yes. Will this scale? Definitely not. This file will become
    massive and hard to maintain. Keeping track of what has failed would be an impossible
    task. We need a tool to help us scale and to help us keep our tests maintainable.
    We need a test runner.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 测试基本上是一段测试我们代码的代码。这会工作吗？是的。这是一个单元测试吗？是的。它会扩展吗？绝对不会。这个文件将变得巨大且难以维护。跟踪失败的任务将是不可能的。我们需要一个工具来帮助我们扩展，并帮助我们保持测试的可维护性。我们需要一个测试运行器。
- en: Before exploring possible test runners, I would like to review what we would
    expect from a test runner. What are the features we would need in a test runner?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索可能的测试运行器之前，我想回顾一下我们对测试运行器的期望。我们需要在测试运行器中具备哪些功能？
- en: Easy to learn and run
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 易于学习和运行
- en: We have a lot of things to learn. We need to learn Node and React; we even have
    to buy a book about Puppeteer. We want a test runner that is simple and easy to
    use.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多东西要学习。我们需要学习Node和React；我们甚至不得不买一本关于Puppeteer的书。我们希望有一个简单易用的测试运行器。
- en: Group tests by functionality
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按功能分组测试
- en: We want to have our tests separated by functionality, component, or workflow.
    Most test runners have a `describe` function that helps us to group tests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将测试按功能、组件或工作流程分开。大多数测试运行器都有一个`describe`函数，帮助我们分组测试。
- en: Ignore tests if needed
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如有必要，忽略测试
- en: We want to skip a test if it becomes noisy, but we don't want to remove it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试变得嘈杂，我们希望跳过测试，但我们不想删除它。
- en: Run only one test
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 只运行一个测试
- en: Being able to run only one test is extremely important while debugging. Imagine
    you have over 1,000 tests (yes, you are going to have over 1,000 tests). If you
    want to fix only one test, you wouldn't want to run all of them. You would like
    to run only the one you are working on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，能够只运行一个测试非常重要。想象一下，你有超过1,000个测试（是的，你将会有超过1,000个测试）。如果你想修复仅一个测试，你不想运行所有这些测试。你只想运行你正在工作的那个。
- en: Assertions
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断言
- en: 'Assertions are essential. An assertion is an expression to check whether the
    program we are testing worked as expected. Do you remember my `console.log` and
    `console.error` to check whether the cart worked as expected? Well, Assertions
    are way better than that. What do we want to check with Assertions? This is a
    possible list:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是必不可少的。断言是一个表达式，用于检查我们正在测试的程序是否按预期工作。你还记得我用来检查购物车是否按预期工作的`console.log`和`console.error`吗？嗯，断言比那要好得多。我们想用断言检查什么？这是一个可能的列表：
- en: Whether a value is equal to a test value.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值是否等于测试值。
- en: Whether a value is null or not null.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值是否为null或非null。
- en: Whether a string or a list contains a value. We might have a huge block of text,
    and we only want to check whether it has some string in it, or an item in an array.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串或列表是否包含一个值。我们可能有一个巨大的文本块，我们只想检查它是否包含某些字符串，或者数组中的某个项。
- en: Whether we expected something to fail, because sometimes, we would expect some
    piece of code to fail.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否预期某些东西会失败，因为有时，我们可能会预期某些代码会失败。
- en: Tools to set up and clean up the environment
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置和清理环境的工具
- en: Before starting the tests, we need our application to be in a certain state.
    For instance, in the cart test, we would like to make sure that the customer has
    not already purchased the product before starting the test.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始测试之前，我们需要确保我们的应用程序处于某种状态。例如，在购物车测试中，我们希望在开始测试之前确保客户尚未购买该产品。
- en: There are also technical setups that might need to be performed. In our case,
    we would need to have Puppeteer and a browser ready to be used before each test.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些可能需要执行的技术设置。在我们的案例中，我们需要在每个测试之前准备好Puppeteer和浏览器。
- en: Another important concept is that tests should be independent and detached from
    each other. This means that the result of one test must not affect other tests.
    This is why, very often, it is required to clean up after each or all tests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念是，测试应该是独立的，并且彼此分离。这意味着一个测试的结果不能影响其他测试。这就是为什么，在大多数情况下，需要在每个或所有测试之后进行清理。
- en: Reports
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 报告
- en: We want to see which tests passed and which tests failed. We would expect a
    test runner to at least show a good report in the terminal. It could be even better
    if we can get results in other formats, such as JSON, XML, or HTML.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想查看哪些测试通过了，哪些测试失败了。我们期望测试运行器至少在终端中显示一份良好的报告。如果我们能够以其他格式获取结果，比如JSON、XML或HTML，那就更好了。
- en: There are many other features we could mention, but these are the most important
    features we need to know about before getting started.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以提到很多其他功能，但这些是我们开始之前需要了解的最重要功能。
- en: Let's now see what the test runners available on the market that can cover the
    features we are requesting.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看市场上有哪些测试运行器能够满足我们提出的要求。
- en: Available test runners
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用的测试运行器
- en: There are many types of tennis racquets. Some racquets give you more control.
    Others give you more power. If you have just started learning how to play tennis,
    you won't feel any difference. You would if you compared a cheap racquet with
    a professional one. But you wouldn't be able to say why one is better than the
    other. You would say that it just *feels better*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 网球拍有很多种类型。有些拍子能给你更多的控制力。其他拍子能给你更多的力量。如果你刚开始学习如何打网球，你不会感觉到任何区别。如果你比较一把便宜的拍子和一把专业的拍子，你会有感觉。但你不会说出为什么一个比另一个好。你只能说它“感觉更好”。
- en: It's the same with test runners. There are test runners that offer some features.
    Other runners offer other features. But what's important for us now is to get
    a test runner that provides us with all the required features to write our automated
    tests.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器也是一样。有些测试运行器提供一些功能。其他运行器提供其他功能。但对我们来说，现在最重要的是找到一个提供所有必需功能的测试运行器，以便我们编写自动化测试。
- en: Another important thing to mention is that this book is not about "using Puppeteer
    with X." We are going to pick a test runner after this chapter, but it doesn't
    need to be the test runner for you. The idea is that you can choose what's best
    for you, or what your team is using right now. It is also probable that by the
    time you read this book, a better test runner will have become popular. You should
    be able to apply the concepts you learned from this book to that test runner.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要提到的重要事情是，这本书不是关于“使用Puppeteer与X”。在这一章之后，我们将选择一个测试运行器，但这不需要是你使用的测试运行器。想法是你可以选择最适合你的，或者你团队目前正在使用的。也有可能在你阅读这本书的时候，一个更好的测试运行器已经变得流行。你应该能够将你在本书中学到的概念应用到那个测试运行器上。
- en: These are the most common test runners in the market today.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是目前市场上最常见的测试运行器。
- en: Jest
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jest
- en: According to the Jest site ([https://jestjs.io/](https://jestjs.io/)), "*Jest
    is a delightful JavaScript Testing Framework with a focus on simplicity*." Pretty
    nice introduction. Facebook maintains this project, and it currently has over
    32,000 stars on GitHub. I'm not saying this is what makes a project a good project,
    but knowing who is behind a project and its level of community support are some
    of the things to take into consideration.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Jest网站([https://jestjs.io/](https://jestjs.io/))的介绍，“*Jest是一个简单易用的JavaScript测试框架，专注于简洁性*。”非常不错的介绍。Facebook维护这个项目，目前在GitHub上拥有超过32,000个星标。我并不是说这是使一个项目成为好项目的因素，但了解一个项目背后的团队及其社区支持水平是一些需要考虑的事情。
- en: Jest has all the features we mentioned before, such as group tests with `describe`,
    and each test is an `it` or `test` function. You can skip tests with `describe.skip`,
    `it.skip`, or `test.skip`. You can run only one test with `describe.only`, `it.only`,
    or `test.only`. You also have `beforeEach`, `afterEach`, `beforeAll`, and `afterAll`,
    to run setup and cleanup code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Jest拥有我们之前提到的所有功能，比如使用`describe`进行分组测试，每个测试都是一个`it`或`test`函数。你可以使用`describe.skip`、`it.skip`或`test.skip`来跳过测试。你可以使用`describe.only`、`it.only`或`test.only`来运行单个测试。你还有`beforeEach`、`afterEach`、`beforeAll`和`afterAll`，用于运行设置和清理代码。
- en: It also has some features that differentiate it from other runners. It has a
    **Snapshot** tool. The snapshot tool would process a React component and return
    some kind of DOM representation as JSON, which will allow us to test whether the
    DOM created by the component has changed. Is this a kind of UI test? Sure it is!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一些与其他运行器区分开来的特性。它有一个**快照**工具。快照工具会处理一个React组件，并以JSON的形式返回某种DOM表示，这将允许我们测试由组件创建的DOM是否发生了变化。这是不是一种UI测试？当然是的！
- en: Another thing to consider when evaluating a test runner is available plugins.
    For instance, there is a package called **jest-puppeteer**, which helps us integrate
    our tests with Puppeteer. You don't need to use **jest-puppeteer**. It's just
    a helper.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估测试运行器时，还需要考虑可用的插件。例如，有一个名为**jest-puppeteer**的包，它帮助我们集成测试与Puppeteer。你不需要使用**jest-puppeteer**。它只是一个辅助工具。
- en: There is also a package called **jest-image-snapshot**, maintained by American
    Express, which provides a set of tools to perform visual regression tests. In
    this case, if you want to code visual regression tests, I recommend you to use
    one of these packages. Managing all the screenshot baselines can be quite tedious.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为**jest-image-snapshot**的包，由美国运通维护，它提供了一套工具来执行视觉回归测试。在这种情况下，如果你想编写视觉回归测试，我建议你使用这些包之一。管理所有的截图基线可能相当繁琐。
- en: Mocha
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mocha
- en: Mocha is another popular framework. It is a community project with over 19,000
    stars. Something worth mentioning is that the Puppeteer team uses Mocha.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha是另一个流行的框架。它是一个拥有超过19,000颗星的社区项目。值得一提的是，Puppeteer团队使用Mocha。
- en: Mocha also has functions like Jest. It has a `describe` function to group tests.
    Tests are `it` functions. You can skip functions using `describe.skip` or `it.skip`,
    and use `describe.only` or `it.only` to run only one test. You also have `beforeEach`,
    `afterEach`, `beforeAll`, and `afterAll`, to run setup and cleanup code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha也有像Jest一样的函数。它有一个`describe`函数来分组测试。测试是`it`函数。你可以使用`describe.skip`或`it.skip`跳过函数，使用`describe.only`或`it.only`来运行单个测试。你还有`beforeEach`、`afterEach`、`beforeAll`和`afterAll`，来运行设置和清理代码。
- en: You will also find many plugins for Mocha. You will find **mocha-puppeteer**
    and **mocha-snapshots**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会发现许多针对Mocha的插件。你可以找到**mocha-puppeteer**和**mocha-snapshots**。
- en: 'A recipe you are going to see a lot on the web is Mocha + Chai. **Chai** is
    an assertion library that extends the assertions a test runner provides. It lets
    you express assertions in a pretty specific way:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你在网上会经常看到的一个食谱是Mocha + Chai。**Chai**是一个断言库，它扩展了测试运行器提供的断言。它让你能够以非常具体的方式表达断言：
- en: '[PRE2]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are many other test runners, such as Jasmine by Pivotal Labs with over
    15,000 stars, Karma by the AngularJS team with over 11,000 stars, AVA, a community
    project with over 18,000 stars, and the list goes on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的测试运行器，例如由Pivotal Labs开发的Jasmine，拥有超过15,000颗星，AngularJS团队开发的Karma，拥有超过11,000颗星，还有社区项目AVA，拥有超过18,000颗星，列表还在继续。
- en: As I mentioned at the beginning of this section, we just need a good tennis
    racquet, that is, a good test runner. When you become an expert, you will be able
    to move from one test runner to another that fits your needs. For the purpose
    of this book, we are going to use **Mocha + Chai**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本节开头提到的，我们只需要一个好的网球拍，也就是说，一个好的测试运行器。当你成为专家时，你将能够从一个测试运行器切换到适合你需求的另一个测试运行器。为了本书的目的，我们将使用**Mocha
    + Chai**。
- en: Creating our first test project
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个测试项目
- en: 'We will create a Node application in the same way we created our first app
    in [*Chapter 1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Getting started
    with Puppeteer*. We are going to create a folder called `OurFirstTestProject`
    (you will find this directory inside the `Chapter2` directory mentioned in the
    *Technical requirements* section) and then execute `npm init -y` inside that folder:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个Node应用程序，就像我们在[*第1章*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014)中创建我们的第一个应用程序一样，*使用Puppeteer入门*。我们将创建一个名为`OurFirstTestProject`的文件夹（你将在*技术要求*部分提到的`Chapter2`目录中找到这个目录），然后在那个文件夹内执行`npm
    init -y`：
- en: '[PRE3]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The response should be something like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应该是这样的：
- en: '[PRE4]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now it''s time to install the packages we are going to use:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候安装我们将要使用的包了：
- en: Puppeteer 7
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppeteer 7
- en: Mocha (any version)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha（任何版本）
- en: Chai (any version)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chai（任何版本）
- en: 'Let''s run the following commands:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE5]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For this first demo, we are going to use the site [https://www.packtpub.com/](https://www.packtpub.com/)
    as a test case. Let's keep our test simple. We want to test that the page title
    says *Packt | Programming Books, eBooks & Videos for Developers.*
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个演示，我们将使用网站[https://www.packtpub.com/](https://www.packtpub.com/)作为测试用例。让我们保持我们的测试简单。我们想要测试页面标题是否为*Packt
    | Programming Books, eBooks & Videos for Developers*。
- en: Important Note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The site we are using for this test might have changed over time. Before testing
    this code, go to [https://www.packtpub.com/](https://www.packtpub.com/) and check
    whether the title is still the same. That's why, in the following chapters, we
    will be downloading sites locally, so we avoid these possible issues.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于此测试的网站可能已经改变。在测试此代码之前，请访问 [https://www.packtpub.com/](https://www.packtpub.com/)
    并检查标题是否仍然相同。这就是为什么在接下来的章节中，我们将下载网站到本地，以避免这些可能的问题。
- en: We mentioned that we would use `describe` to group our tests. But separating
    tests into different files will also help us to get our code organized. You can
    choose between having one or many `describe` functions per file. Let's create
    a file called `home.tests.js`. We are going to put all tests related to the home
    page there.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到我们会使用 `describe` 来分组我们的测试。但将测试分离到不同的文件中也会帮助我们整理代码。你可以选择每个文件中有一个或多个 `describe`
    函数。让我们创建一个名为 `home.tests.js` 的文件。我们将把所有与主页相关的测试放在那里。
- en: Although you can create the files anywhere you want, Mocha grabs all the tests
    in the `test` folder by default, so we will to create the `test` folder and then
    create the `home.test.js` file inside that folder.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在任何你想的地方创建文件，但 Mocha 默认会抓取 `test` 文件夹中的所有测试，所以我们将创建一个 `test` 文件夹，然后在其中创建
    `home.test.js` 文件。
- en: 'We are going to have the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会有以下内容：
- en: '`home.tests.js` with the home tests'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home.tests.js` 包含主页测试'
- en: A `describe` function with the header tests
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有标题测试的 `describe` 函数
- en: An `it` function testing *"Title should have Packt name"*
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试 `"Title should have Packt name"` 的 `it` 函数。
- en: Another `it` function testing *"Title mention the word Books"*
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个测试 `"Title mention the word Books"` 的 `it` 函数。
- en: 'The structure should look like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结构应该看起来像这样：
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s unpack this code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码：
- en: We are importing Puppeteer in line 1.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在第 1 行导入了 Puppeteer。
- en: Lines 2 are 3 are about importing the different types of assertion styles `expect`
    is not being called with parentheses whereas `should` is. We don't need to know
    why now. But, just to be clear, that's not a mistake.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第 2 行和第 3 行是关于导入不同类型的断言样式，`expect` 没有使用括号，而 `should` 使用了。我们现在不需要知道为什么。但为了清楚起见，这不是一个错误。
- en: How about Mocha? Are we missing Mocha? Well, Mocha is the test runner. It will
    be the executable we will call later in `package.json`. We don't need it in our
    code.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么 Mocha 呢？我们遗漏了 Mocha 吗？嗯，Mocha 是测试运行器。它将是我们在 `package.json` 中稍后要调用的可执行文件。我们不需要在我们的代码中使用它。
- en: 'It''s interesting to see that both `describe` and `it` are just simple functions
    that take two arguments: a string and a function. Can you pass a function as an
    argument? Yes, you can!'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很有趣地看到，`describe` 和 `it` 都只是接受两个参数的简单函数：一个字符串和一个函数。你能将一个函数作为参数传递吗？是的，你可以！
- en: The functions we are passing to the `it` functions are `async`. We can't use
    the `await` keyword in functions that are not marked as `async`. Remember that
    Puppeteer relies a lot on async programming.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们传递给 `it` 函数的函数是 `async`。我们无法在未标记为 `async` 的函数中使用 `await` 关键字。记住，Puppeteer
    很大程度上依赖于异步编程。
- en: 'Now we need to launch a browser and set up everything these tests need to work.
    We could do something like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要启动一个浏览器并设置所有这些测试需要运行的环境。我们可以这样做：
- en: '[PRE7]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't try to learn the Puppeteer API now. We are going to explain how all of
    these commands work in [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050),
    *Navigating through a website*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要尝试学习 Puppeteer API。我们将解释所有这些命令是如何在 [*第 3 章*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050)
    *浏览网站* 中工作的。
- en: 'This code will run perfectly. However, there are two things that could do with
    optimization:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将完美运行。然而，有两件事可以进行优化：
- en: We would be repeating the same code over and over.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们会一遍又一遍地重复相同的代码。
- en: If something fails in the middle of the test, the browser won't get closed,
    leaving lots of open browsers.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试过程中出现失败，浏览器不会关闭，留下很多打开的浏览器。
- en: 'To avoid these problems, we can use `before`, `after`, `beforeEach`, and `afterEach`.
    If we add these functions to our tests, this would be the execution order:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，我们可以使用 `before`、`after`、`beforeEach` 和 `afterEach`。如果我们将这些函数添加到我们的测试中，这将是我们执行的顺序：
- en: '`before`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before`'
- en: '`beforeEach`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach`'
- en: '`it(''Title should have Packt name'')`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it(''Title should have Packt name'')`'
- en: '`afterEach`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach`'
- en: '`beforeEach`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach`'
- en: '`it(''Title should mention Books'')`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it(''Title should mention Books'')`'
- en: '`afterEach`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach`'
- en: '`after`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after`'
- en: 'It''s not a rule of thumb, but we can do something like this in our case:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个规则，但我们可以在这种情况下这样做：
- en: '`before`: Launch the browser.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`before`：启动浏览器。'
- en: '`beforeEach`: Open a page and navigate to the URL.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beforeEach`：打开一个页面并导航到 URL。'
- en: Run the test.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: '`afterEach`: Close the page.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`afterEach`: 关闭页面。'
- en: '`after`: Close the browser.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`after`: 关闭浏览器。'
- en: 'These **hooks**, which is what Mocha calls these functions, would look like
    this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些**钩子**，这就是Mocha称这些函数的方式，看起来是这样的：
- en: '[PRE8]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One thing to mention here is that we could do what''s called `await` the result
    of `page.close()` or `browser.close()`. So, we could do this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要提到的一点是，我们可以执行所谓的`await` `page.close()`或`browser.close()`的结果。所以，我们可以这样做：
- en: '[PRE9]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's not something I love doing because if something fails, you would like
    to know where and why. But as this is just cleanup code for a test, it's not production
    code, we can afford that risk.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我喜欢做的事情，因为如果某处失败，你希望知道在哪里以及为什么。但既然这只是测试的清理代码，不是生产代码，我们可以承担这个风险。
- en: 'Now our test has a browser opened, a page with the URL we want to test read.
    We just need to test the title:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试已经打开了一个浏览器，读取了我们想要测试的URL的页面。我们只需要测试标题：
- en: '[PRE10]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I used two different styles here.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了两种不同的风格。
- en: In the first case, I'm assigning the result of the `title` async function to
    a variable, and then using `should.contain` to check whether the title contains
    the word *"Packt"*. In the second case, I just evaluated `((await page.title())`.
    I added some extra parentheses there for clarification. You won't see them in
    the final example.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我将`title`异步函数的结果赋值给一个变量，然后使用`should.contain`来检查标题是否包含单词*"Packt"*。在第二种情况下，我只是评估了`((await
    page.title())`。我在那里添加了一些额外的括号以供说明。你不会在最终的示例中看到它们。
- en: 'The second difference is that in the first case, I''m using the **should**
    style, whereas in the second case, I''m using the **expect** style. The result
    will be the same. It''s just about which style you feel more comfortable with
    or feels more natural to you. There is even a third style: **assert**.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是，在第一种情况下，我使用的是**should**风格，而在第二种情况下，我使用的是**expect**风格。结果将是相同的。这仅仅关乎哪种风格让你感觉更舒适，或者对你来说更自然。甚至还有一个第三种风格：**assert**。
- en: 'We have everything we need to run our tests. Remember how `npm init` created
    a `package.json` file for us? It''s time to use it. Let''s set the `test` command.
    You should have something like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了运行测试所需的一切。还记得`npm init`为我们创建了一个`package.json`文件吗？现在是时候使用它了。让我们设置`test`命令。你应该有类似这样的内容：
- en: '[PRE11]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need to tell `npm` to run `npm test`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉`npm`运行`npm test`：
- en: '[PRE12]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Time to run our tests! Let''s run `npm test` in the terminal:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行我们的测试了！在终端中运行`npm test`：
- en: '[PRE13]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And we should have our first error:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会有第一个错误：
- en: '[PRE14]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s bad, but not that bad. Mocha validates by default that our tests should
    take less than 2,000 ms. That sounds OK for an isolated unit test. But UI tests
    might take longer than 2 seconds. That doesn''t mean that UI tests shouldn''t
    have a timeout. `--timeout` command-line argument to the launch setting we set
    up in the `package.config` file. I think 30 seconds could be a reasonable timeout.
    As it expects the value in milliseconds, it should be `30000`. Let''s make that
    change in our `package.config` file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这很糟糕，但还不算太糟糕。Mocha默认会验证我们的测试应该少于2,000毫秒。对于一个独立的单元测试来说，这听起来是合理的。但UI测试可能需要超过2秒的时间。这并不意味着UI测试不应该有超时。在`package.config`文件中设置的启动设置中，我们设置了`--timeout`命令行参数。我认为30秒可以是一个合理的超时时间。因为它期望的值是毫秒，所以应该是`30000`。让我们在`package.config`文件中做出这个更改：
- en: '[PRE15]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The command-line argument is not the only way to set up the timeout. You can
    call `this.Timeout (30000)` inside the `describe` function or configure the timeout
    using a config file ([https://mochajs.org/#configuring-mocha-nodejs](https://mochajs.org/#configuring-mocha-nodejs)).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数不是设置超时的唯一方式。你可以在`describe`函数内部调用`this.Timeout (30000)`，或者使用配置文件配置超时（[https://mochajs.org/#configuring-mocha-nodejs](https://mochajs.org/#configuring-mocha-nodejs)）。
- en: 'Once we set up the timeout, we can try our tests again by running `npm test`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了超时，我们可以通过再次运行`npm test`来尝试我们的测试：
- en: '![Test Result'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![测试结果'
- en: '](img/Figure_2.06_B16113.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.06_B16113.jpg](img/Figure_2.06_B16113.jpg)'
- en: Test Result
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果
- en: 'Mocha not only ran our tests but also printed a pretty decent report. We have
    there all the tests Mocha ran, the final result, and the elapsed time. Here is
    where many test runners offer different options. For instance, Mocha has a `--reporter`
    flag. If you go to https://mochajs.org/, you will see all the available reporters.
    We could use the `list` reporter, which shows the elapsed time of each test. We
    can add it to our `package.config` file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha不仅运行了我们的测试，还打印了一份相当不错的报告。在这里我们可以看到Mocha运行的所有测试、最终结果和耗时。这里提供了许多测试运行器的不同选项。例如，Mocha有一个`--reporter`标志。如果你访问https://mochajs.org/，你会看到所有可用的报告器。我们可以使用`list`报告器，它显示了每个测试的耗时。我们可以在`package.config`文件中添加它：
- en: '[PRE16]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this change, we can get a better report:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，我们可以得到更好的报告：
- en: '![Test Result using the list reporter'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用列表报告器的测试结果'
- en: '](img/Figure_2.07_B16113.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.07_B16113.jpg'
- en: Test Result using the list reporter
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表报告器的测试结果
- en: This project looks fine. If you had only a few tests, this would be enough.
    But if we are going to have lots of tests using many pages, this code won't scale.
    We need to organize our code so that we can be more productive and reuse more
    code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目看起来不错。如果你只有几个测试，这已经足够了。但如果我们将要使用许多页面进行大量测试，这段代码就无法扩展。我们需要组织我们的代码，以便我们更高效，并且可以重用更多代码。
- en: Organizing our code
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织我们的代码
- en: 'Our first test was quite simple: we were just checking the page title. But
    let''s take a look at the home page:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项测试相当简单：我们只是检查页面标题。但让我们看看首页：
- en: '![Packtpub home page'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![Packtpub首页'
- en: '](img/Figure_2.08_B16113.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.08_B16113.jpg'
- en: Packtpub home page
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Packtpub首页
- en: 'There are many actions we would like to test there:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望测试那里有许多操作：
- en: Search for an existing book.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索现有书籍。
- en: Search for a non-existing book.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索不存在的书籍。
- en: Check the cart when it is empty.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当购物车为空时检查。
- en: Check the cart when we add a product.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们添加产品时检查购物车。
- en: 'Let''s take, for example, *Search tests*. We would be doing the same steps
    every time:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以*搜索测试*为例。我们每次都会做同样的步骤：
- en: Click on the search box.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击搜索框。
- en: Enter the text.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入文本。
- en: Click on the search button.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击搜索按钮。
- en: We would be doing the same thing over and over in all our search tests. Sometimes
    there is a misconception that, as the test code is not production code, the code
    can be a mess. So, people go and copy/paste their tests over and over, duplicating
    code and hardcoding values. That ends up with hard-to-maintain tests. When tests
    are hard to maintain, they tend to be pushed down the priority list. Developers
    lose, QA analysts lose, and in the end, clients lose.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在所有的搜索测试中重复做同样的事情。有时有一种误解，即测试代码不是生产代码，所以代码可以很乱。因此，人们会一遍又一遍地复制粘贴测试，重复代码并硬编码值。这最终导致难以维护的测试。当测试难以维护时，它们往往会降低优先级。开发者失去了，质量保证分析师失去了，最终，客户也失去了。
- en: 'We are going to see two techniques to improve our test code: the **Page Object
    Model** (**POM**) and the test data config.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到两种改进测试代码的技术：**页面对象模型**（**POM**）和测试数据配置。
- en: Introducing the Page Object Model
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍页面对象模型
- en: The POM is a design pattern that will help us separate our test code from the
    implementation of the interaction our tests will perform.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: POM是一种设计模式，它将帮助我们分离测试代码和测试将执行的交互实现。
- en: Let's build our `HomePageModel` together. What are the possible interactions
    on that page?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一起构建我们的`HomePageModel`。该页面上可能有哪些交互？
- en: '**Go** (to the page)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前往**（到页面）'
- en: '**Get page title**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取页面标题**'
- en: '**Search**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**'
- en: '**Sign In**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录**'
- en: '**View Cart**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看购物车**'
- en: '**Go to Checkout**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前往结账**'
- en: '**Subscribe**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅**'
- en: 'Well done! We just created our first Page Model. This is how it will look:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们刚刚创建了我们的第一个页面模型。这就是它的样子：
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s focus on the two first functions: the `go` function, which will navigate
    to the home page, and the `title` function, which will return the page title.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注前两个函数：`go`函数，它将导航到首页，以及`title`函数，它将返回页面标题。
- en: 'We will reuse a lot of code here. If we want to start using this model, we
    would need to do two things: implement the title fetching here and pass a Puppeteer
    page to this model:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里重用大量代码。如果我们想开始使用这个模型，我们需要做两件事：在这里实现标题获取，并将Puppeteer页面传递给这个模型：
- en: '[PRE18]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now it''s a matter of importing this class into our tests using `require`.
    I will put this class into a **POM** (**Page Object Model**) folder inside the
    test folder. Once we create the file, we import it:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是将这个类导入我们的测试中，使用`require`。我将把这个类放入测试文件夹内的**POM**（**页面对象模型**）文件夹中。一旦我们创建了文件，我们就导入它：
- en: '[PRE19]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We declare a variable inside the describe:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在describe内部声明一个变量：
- en: '[PRE20]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We create an instance of this class in the `beforeEach` hook:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`beforeEach`钩子中创建这个类的实例：
- en: '[PRE21]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And now, we simply replace the `page.title` we are using with `homePageModel.title`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需简单地用`homePageModel.title`替换我们正在使用的`page.title`：
- en: '[PRE22]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As I mentioned earlier in the chapter, UI tests help us see whether our refactoring
    broke our code. Let''s run `npm test` again to confirm that we didn''t break anything:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前在本章中提到的，UI测试帮助我们查看重构是否破坏了我们的代码。让我们再次运行`npm test`以确认我们没有破坏任何东西：
- en: '![Test result after the first refactor'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![第一次重构后的测试结果'
- en: '](img/Figure_2.09_B16113.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.09_B16113.jpg'
- en: Test result after the first refactor
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次重构后的测试结果
- en: 'There''s only one thing left to do so that we can be proud of our first project.
    We need to get rid of our hardcoded values. We only wrote two tests, and we have
    three hardcoded values: the site URL and the `Packt` and the `Books` words.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一一件事是我们可以为之自豪的第一个项目。我们需要消除我们的硬编码值。我们只写了两个测试，但我们有三个硬编码值：网站 URL 以及`Packt`和`Books`这两个词。
- en: For these tests, we can leave these hardcoded values. But what if you have different
    environments? You would need to make the URL dynamic. What if your site were a
    generic e-commerce site? The brand name would depend on the test you are navigating.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些测试，我们可以保留这些硬编码的值。但如果你有不同的环境呢？你需要使 URL 动态。如果你的网站是一个通用的电子商务网站呢？品牌名称将取决于你正在导航的测试。
- en: 'There are many other use cases:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他用例：
- en: Test users and passwords
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用户和密码
- en: Product to test
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要测试的产品
- en: Keywords to use
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用的关键词
- en: 'We can create a `config.js` file with all the environment settings and return
    only the one we get on an environment variable. If not set, we return the local
    version:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`config.js`文件，包含所有环境设置，并只返回我们在环境变量中获取的设置。如果没有设置，我们返回本地版本：
- en: '[PRE23]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this looks a little bit scary, don''t worry, it''s not that complex:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来有点令人畏惧，不要担心，它并不那么复杂：
- en: 'It returns an object with three properties: `local`, `test`, and `prod`.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回一个包含三个属性的对象：`local`、`test`和`prod`。
- en: 'In JavaScript, you can access a property by using `object.property` or by treating
    the object as a dictionary: `object[''local'']`.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，你可以通过使用`object.property`或将对象视为字典：`object['local']`来访问属性。
- en: '`process.env` allows us to read environment variables. We won''t be using environment
    variables in this book, but I wanted to show you the final solution.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process.env`允许我们读取环境变量。在这本书中，我们不会使用环境变量，但我想要展示最终的解决方案。'
- en: Finally, we are going to return only the `local`, `test`, or `prod` property
    based on the `TESTENV` variable or `'local'` if the environment variable was not
    set.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将根据`TESTENV`变量返回`local`、`test`或`prod`属性，如果没有设置环境变量，则返回`'local'`。
- en: 'I bet that by now, you will know that we will be able to access this object
    using a `require` call:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，到现在为止，你已经知道我们可以使用`require`调用访问这个对象：
- en: '[PRE24]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And from there, start using the `config` variable instead of hardcoded values.
    We would also need to pass this config to the page model because we have a hardcoded
    URL there.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，使用`config`变量而不是硬编码的值。我们还需要将此配置传递给页面模型，因为我们那里有一个硬编码的 URL。
- en: 'After making all these changes, this is what our tests should look like:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行所有这些更改后，我们的测试应该看起来像这样：
- en: '[PRE25]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we remove all the unused functions, our final page model would look like
    this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除所有未使用的函数，我们的最终页面模型将看起来像这样：
- en: '[PRE26]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we didn't need to implement complex design patterns to make
    our tests reusable and easy to maintain. I think it's time to get started with
    our tests, which we will do in [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050),
    *Navigating through a website*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们不需要实现复杂的设计模式来使我们的测试可重用且易于维护。我认为是时候开始我们的测试了，我们将在[*第3章*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050)“浏览网站”中这样做。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started with the foundations of automated testing. Mike
    Cohn's pyramid helped us to understand the different types of tests. We also gave
    this pyramid a new look, showing how it should be used from a Frontend developer
    perspective. We also made it clear that both developers and QA analysts are part
    of this pyramid, but with different perspectives.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从自动化测试的基础开始。Mike Cohn 的金字塔帮助我们理解了不同类型的测试。我们还为这个金字塔赋予了一个新的外观，展示了从前端开发者角度应该如何使用它。我们还明确指出，开发人员和
    QA 分析师都是这个金字塔的一部分，但有不同的视角。
- en: In the second part of the chapter, we got more practical, and we looked into
    test runners. A learning point here is that we used Mocha as a test runner, but
    everything you learned in this chapter should be possible with any test runner;
    that is, we used Mocha, but we could have used any other test runner.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们变得更加实用，并探讨了测试运行器。这里的一个学习点是，我们使用了 Mocha 作为测试运行器，但本章中你学到的所有内容都应适用于任何测试运行器；也就是说，我们使用了
    Mocha，但我们可以使用任何其他测试运行器。
- en: We use many Puppeteer APIs in our tests. In the next chapter, we are going to
    dive deep into these APIs and see how we can use Puppeteer in different scenarios.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们使用了许多 Puppeteer API。在下一章中，我们将深入探讨这些 API，并看看我们如何在不同的场景中使用 Puppeteer。
