- en: Chapter 3. Garbage Collection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。垃圾收集
- en: When writing applications, managing the available memory is boring and difficult.
    When the application gets complex, it's easy to start leaking memory. Many programming
    languages have automatic memory management, helping the developer to forget about
    this management by means of a **Garbage** **Collector** (**GC**). The GC is only
    a part of this memory management, but it's the most important one and is responsible
    for reclaiming memory that is no longer in use (garbage), by periodically looking
    at disposed referenced objects and freeing the memory associated with them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写应用程序时，管理可用内存是乏味且困难的。当应用程序变得复杂时，很容易开始泄漏内存。许多编程语言都具有自动内存管理，通过**垃圾收集器**（**GC**）帮助开发人员忘记这种管理。GC只是这种内存管理的一部分，但它是最重要的部分，负责定期查看已处理的引用对象并释放与其关联的内存。
- en: The most common technique used by GC is monitoring reference counting. This
    means that GC, for each object, holds the number (count) of other objects that
    reference it. When an object has no references to it, it can be collected, which
    means that it can be disposed and its memory freed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: GC最常用的技术是监视引用计数。这意味着对于每个对象，GC都保存引用它的其他对象的数量（计数）。当一个对象没有引用时，它可以被收集，这意味着它可以被处理并且其内存被释放。
- en: In V8, the Node.js engine, this reference counting is not constantly checked.
    Instead, it's periodically scanned, and this task is called a cycle. Usually,
    this cycle is not atomic which means that the program will pause execution while
    this cycle is running. Also, just to keep this reference counting, GC needs memory.
    This means a memory overhead on your program besides the memory used by the program.
    Also, because the language is dynamic and objects can change type, memory sometimes
    is not used in the most efficient way. Recall the previous chapter about development
    patterns for a more efficient memory usage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在V8中，Node.js引擎中，这种引用计数并不是不断检查的。相反，它会定期扫描，这个任务被称为一个循环。通常，这个循环不是原子的，这意味着程序在运行此循环时会暂停执行。此外，为了保持这种引用计数，GC需要内存。这意味着除了程序使用的内存之外，程序还需要内存开销。此外，由于语言是动态的，对象可以改变类型，因此内存有时并不以最有效的方式使用。回顾前一章关于更有效地使用内存的开发模式。
- en: Automatic memory management
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动内存管理
- en: GC tremendously simplifies language usage, giving developers more time to focus
    on other aspects of the application. Also, it can reduce, although not completely
    remove, a type of error called memory leaks, which haunt long-lived applications
    and services. However, there's a performance penalty associated with its periodic
    task. It can be noticed, or not, depending on how much memory is used and disposed
    in short periods of time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GC极大地简化了语言的使用，使开发人员有更多的时间专注于应用程序的其他方面。此外，它可以减少一种称为内存泄漏的错误，尽管不能完全消除，这种错误会困扰长时间运行的应用程序和服务。然而，与其定期任务相关的性能惩罚。这可能会被注意到，也可能不会，这取决于在短时间内使用和处理多少内存。
- en: 'By moving memory management out of the developer, Node.js removes or substantially
    reduces a few types of bugs:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将内存管理移出开发人员，Node.js消除或大大减少了一些类型的错误：
- en: '**Dangling pointer bugs**: These occur when memory is freed but still there
    are one or more pointers referencing that the memory blocks. If the memory is
    reassigned, these pointers can cause unpredictable behavior if used to change
    blocks from other parts of the program. You would have, in this case, more than
    two places in the application changing the same memory block. This is a particularly
    difficult bug to find.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬空指针错误：当内存被释放但仍然有一个或多个指针引用该内存块时发生。如果重新分配内存，这些指针可能会导致不可预测的行为，如果用于更改程序其他部分的块。在这种情况下，应用程序中有两个以上的位置更改相同的内存块。这是一个特别难以找到的错误。
- en: '**Double free bugs**: These occur when memory is freed once and then freed
    again. In between, it might have been reallocated and used by another part of
    the application, destroying access to a reused block. This is similar to the previous
    memory, where two places manage the same block, but in this case, one is trying
    to use it and the other will just wipe the data.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重释放错误：当内存被释放一次，然后再次被释放时发生。在此期间，它可能已被重新分配并被应用程序的另一部分使用，破坏了对重复使用的块的访问。这类似于前一个内存，其中两个位置管理相同的块，但在这种情况下，一个位置试图使用它，另一个位置只会擦除数据。
- en: '**Memory leaks**: These occur when objects are dereferenced before being freed.
    This happens when a program allocates memory, uses it, and then disposes the reference
    to that memory before explicitly freeing it. This type of bug can leave to memory
    exhaustion if this behavior occurs repeatedly, especially on long-lived services.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存泄漏：当对象在被释放之前被取消引用时发生。当程序分配内存，使用它，然后在显式释放之前取消对该内存的引用时，就会发生这种情况。如果这种行为反复发生，特别是在长时间运行的服务上，这种类型的错误可能导致内存耗尽。
- en: '**Buffer overflows**: These occur when trying to write more information than
    the space allocated to the task. This is quite common when, for example, a program
    allocates a memory block somewhere after it needs more space than the memory it
    allocated, and fails to detect and reallocate the required space. This bug can
    halt the application or service.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区溢出：当尝试写入的信息超过任务分配的空间时发生。例如，当程序在需要比分配的内存块更多的空间时分配内存块的某个地方，但未能检测并重新分配所需的空间时，这种情况很常见。这种错误可能会使应用程序或服务停止。
- en: On the other hand, moving memory management away from the developer removes
    a great deal of control over memory usage and how it's managed. GC will consume
    resources when looking at the memory being used and deciding what and when to
    free unreferenced objects, creating unpredictable pauses during your application
    execution. Also, the time at which the GC starts doing its job may be unpredictable
    and out of your control, which can introduce unpredictable performance penalties
    over times when your program is in need of resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，将内存管理移出开发人员的控制会大大减少对内存使用和管理方式的控制。当GC查看正在使用的内存并决定何时释放未引用的对象时，会消耗资源，在应用程序执行期间创建不可预测的暂停。此外，GC开始执行其工作的时间可能是不可预测的，并且超出您的控制范围，这可能会在您的程序需要资源时引入不可预测的性能惩罚。
- en: This is the case of Node.js, but since it uses V8, which exposes a `gc()` method
    under the `--expose_gc` flag, you can manually force its use. You cannot decide
    when it will run, but you can force it to run more often if you think it's best.
    You can also tweak some of GC's behavior. To find out more run the `--v8-options`
    node.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Node.js的情况，但由于它使用V8，在`--expose_gc`标志下暴露了一个`gc()`方法，您可以手动强制使用它。您无法决定它何时运行，但如果您认为这样做是最好的，可以强制它更频繁地运行。您还可以调整一些GC的行为。要了解更多信息，请运行`--v8-options`节点。
- en: There's no way of blocking its use, so you can just make it run more often,
    perhaps reducing its footprint. The GC's cost is proportional to the number of
    referencing objects, so if you use this method after substantially reducing referenced
    objects, you can keep your application lean and reduce the GC penalty later.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法阻止其使用，因此您只能使其更频繁地运行，可能减少其占用空间。GC的成本与引用对象的数量成正比，因此如果在大大减少引用对象后使用此方法，您可以使应用程序保持精简，并在以后减少GC的惩罚。
- en: '![Automatic memory management](img/4183_03_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![自动内存管理](img/4183_03_01.jpg)'
- en: 'Figure 1: GC memory graph'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：GC内存图
- en: Memory organization
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存组织
- en: Think of memory as a mesh of elements, usually primitives (numbers and strings)
    and objects (hash tables). It can be represented as a graph of interconnected
    points. Memory can be used to hold object information or to reference other objects.
    You can look at this interconnection as a graph where leafs are elements that
    hold information and the other nodes are references to other nodes (in Figure
    1, nodes **1**, **3**, **6**, and **9** are leafs).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存视为通常是基本元素（数字和字符串）和对象（哈希表）的网格。它可以被表示为相互连接的点的图。内存可以用来保存对象信息或引用其他对象。您可以将这种相互连接视为叶子节点是保存信息的元素，其他节点是对其他节点的引用（在图1中，节点1、3、6和9是叶子节点）。
- en: When working with V8, there's some terminology you may find useful to better
    understand V8 Inspector or Chrome Developer Tools. The memory used by the object
    itself is called **shallow size**. It's used to store its immediate value, and
    usually, only strings and arrays can have a significant size.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用V8时，有一些术语可能对您更好地理解V8检查器或Chrome开发者工具有用。对象本身使用的内存称为**浅大小**。它用于存储其直接值，通常只有字符串和数组可以具有显着的大小。
- en: 'There is also the distance column, which is the smallest graph distance from
    a root node to the node itself. A root note is a node from where references start
    pointing other nodes. In Figure 2 it would be node **2** as there''s no arrow
    pointing to **2** and everything on the graph starts on node **2**. In Inspectors,
    you''ll see another term in **Profiles** called **Retained size**. This is the
    size that will be freed once the object is deleted. It is at least the size of
    the object plus the size of the referenced objects, which will also be freed immediately
    since they will also get unreferenced. Confusing? Let''s see an example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个距离列，它是从根节点到节点本身的最小图距离。根节点是从那里引用开始指向其他节点的节点。在图2中，它将是节点2，因为没有箭头指向2，图上的一切都从节点2开始。在检查器中，您会看到**Profiles**中的另一个术语称为**保留大小**。这是一旦对象被删除将被释放的大小。它至少是对象本身的大小加上引用对象的大小，这些引用对象也将立即被释放，因为它们也将被取消引用。令人困惑？让我们看一个例子：
- en: '![Memory organization](img/4183_03_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![内存组织](img/4183_03_02.jpg)'
- en: 'Figure 2: GC-marked nodes before sweep'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：清扫前的GC标记节点
- en: In the preceding diagram you see that node **2** is the root node in the graph,
    as there's no node referencing (pointing to) it. This node references node **5**
    and node **11**. If the reference to node **11** is removed, then there's no path
    from node **2** (and the rest of the left part of the graph) to get to nodes **8**
    and **1**. These nodes are part of the retained size of node **11** as they're
    useless without it. When node **11** is removed, they'll be removed too.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，您可以看到节点2是图中的根节点，因为没有节点引用（指向）它。该节点引用节点5和节点11。如果对节点11的引用被移除，那么从节点2（以及图的左侧的其余部分）到节点8和1就没有路径了。这些节点是节点11的保留大小的一部分，因为它们在没有节点11的情况下是无用的。当节点11被移除时，它们也将被移除。
- en: Memory leaks
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: A memory leak is a continuous loss of available memory, and it occurs when a
    program repeatedly fails to release the memory that it's no longer using. Node.js
    applications can suffer from this issue indirectly because of the GC. It's usually
    not the GC's fault, but is caused by some object destruction that is not taking
    place when it should, and this is not that difficult when you're using an event-driven
    architecture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏是可用内存持续丢失，当程序反复未能释放不再使用的内存时发生。Node.js应用程序可能间接受到这个问题的影响，因为GC。通常不是GC的错，而是由于一些对象销毁没有在应该发生时发生，当您使用事件驱动的架构时，这并不难。
- en: Leaks haunt every developer as soon as their application hits medium size. As
    soon as your program starts having more interactions with external elements like
    other programs or clients, or when your program complexity grows, you start leaking
    memory. This happens when, for some reason, you're not dereferencing a no-longer-useful
    object of your application. If the GC finds that the object is still referenced
    by other objects, even if it's no longer useful to your application, it will remain
    in the heap and will be moved to a place called **old space**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 泄漏问题困扰着每个开发者，一旦他们的应用程序达到中等规模。一旦你的程序开始与其他程序或客户端等外部元素有更多的交互，或者当你的程序复杂度增加时，就会开始出现内存泄漏。当你的应用程序中有一个不再有用的对象没有被取消引用时，就会发生这种情况。如果垃圾回收器发现该对象仍然被其他对象引用，即使它对你的应用程序不再有用，它仍将保留在堆中，并将被移动到一个称为“旧空间”的地方。
- en: Usually, objects live for a very long period of time (since the beginning of
    the application) or for a very short period of time (serving a specific client).
    The V8 GC is designed to take advantage of these two most common types of objects.
    GC cycles usually clean these short-lived objects, and if it thinks that these
    objects are still useful (that is, when it survives more than one or two GC cycles),
    it will move them to a bigger zone, where it will start to accumulate garbage.
    When this zone gets bigger, the GC cycle duration gets bigger too and you'll start
    noticing some stalls (complete breaks in the application) for a second, or even
    a few seconds. If this happens, it means you're already late at analyzing your
    application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对象的生存周期很长（自应用程序开始以来）或者很短（为特定客户端提供服务）。V8 GC被设计用来利用这两种最常见的对象类型。GC周期通常会清理这些短寿命对象，如果它认为这些对象仍然有用（也就是说，当它经历了一两个GC周期后），它会将它们移动到一个更大的区域，开始积累垃圾。当这个区域变大时，GC周期的持续时间也会变长，你会开始注意到应用程序会出现一秒钟甚至几秒钟的停顿。如果发生这种情况，这意味着你已经迟了分析你的应用程序。
- en: For a large memory limit, such as the default 1 GB limit of V8, if you're not
    monitoring your application, you'll probably notice leaks when your application
    starts stalling for a second, and after that, it's a few more seconds before it
    just stops because of that memory limit. GC cycles become very CPU intensive for
    large object collections, so you should really monitor GC memory management and,
    if possible, avoid greater memory usage.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像V8的默认1GB限制这样的大内存限制，如果你不监控你的应用程序，当你的应用程序开始停顿一秒钟时，你可能会注意到泄漏，之后，它还会再过几秒钟才会因为内存限制而停止。对于大对象集合，GC周期变得非常消耗CPU，所以你应该真正监控GC内存管理，并尽可能避免更大的内存使用。
- en: Event emitters
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件发射器
- en: 'Since Node.js uses event emitters, there''s a question that should be in your
    head right now. Since GC can only sweep objects that are unreferenced, this means
    that event emitters will not be collected after you attach event listeners to
    them:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node.js使用事件发射器，现在你脑海中应该有一个问题。由于GC只能清除未被引用的对象，这意味着在你将事件监听器附加到事件发射器后，事件发射器将不会被收集：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is just an example of an echo server. In this example, GC
    will never collect `server`, which is good in this case since that's the main
    object of the program. In other cases, you might have such situations where your
    emitters won't get swept because of references to listeners. Most importantly,
    event callbacks are functions—extended objects in JavaScript—and won't get swept
    either.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只是一个回声服务器的示例。在这个例子中，GC永远不会收集`server`，在这种情况下这是好事，因为这是程序的主要对象。在其他情况下，你可能会遇到这样的情况，你的发射器不会被清除，因为有对监听器的引用。最重要的是，事件回调是函数——JavaScript中的扩展对象——也不会被清除。
- en: Take a closer look at the previous example. Imagine that for each client (socket),
    you had more complex code with some private protocol. To simplify it, you use
    the Adapter pattern and create an abstraction to access each client. This abstraction
    could be an event emitter as a means to decouple it from other parts of the application.
    While your client keeps connected, any event listeners that don't explicitly unlisten
    events will not get garbage collected even if they are not supposed to exist anymore
    (this is true even if you null them). And if your connection gets stuck and doesn't
    time out (for example, a mobile connection), you'll collect a good pack of zombie
    connections for a while.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下前面的例子。想象一下，对于每个客户端（套接字），你有更复杂的代码和一些私有协议。为了简化，你使用适配器模式创建一个抽象来访问每个客户端。这个抽象可以是一个事件发射器，作为一种手段来将其与应用程序的其他部分解耦。当你的客户端保持连接时，任何没有明确取消事件监听的事件监听器都不会被垃圾回收，即使它们不应该再存在（即使你将它们设置为null也是如此）。如果你的连接卡住了，而且没有超时（例如移动连接），你将会收集一大堆僵尸连接一段时间。
- en: Referencing objects
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用对象
- en: 'The main goal of GC is to identify trashed memory. This refers to the memory
    blocks that you''re your application no longer uses, usually because your code
    no longer references them. Once identified, this memory can be reused or freed
    to the operating system:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: GC的主要目标是识别被丢弃的内存。这指的是你的应用程序不再使用的内存块，通常是因为你的代码不再引用它们。一旦识别出来，这些内存可以被重用或释放给操作系统：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, although both `bar` and `baz` are local variables
    for the function (because of JavaScript function scoping), `baz` will be deference
    after `return` but `bar` won''t, and it will not be freed until you completely
    deference it. This might look obvious, but if your application grows and you start
    using external modules that you don''t know how they work internally, you might
    get more dangling references than you expect:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，尽管`bar`和`baz`都是函数的局部变量（因为JavaScript函数作用域），`baz`在`return`后会被取消引用，但`bar`不会，直到你完全取消引用它。这可能看起来很明显，但如果你的应用程序增长，并且你开始使用你不知道内部工作方式的外部模块，你可能会得到比预期更多的悬空引用：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now imagine you call the `foo` function and ignore the returned object. You
    might think that it''ll get unreferenced, but there''s no guarantee of that because
    of what `doSomething` might have done. It might have held a reference to `bar`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，您调用`foo`函数并忽略返回的对象。您可能会认为它会变得未引用，但由于`doSomething`可能已经做了一些事情，这并没有保证。它可能已经保持了对`bar`的引用。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now imagine you don't need to return the bar variable, and so you null it after
    you no longer need it, destroying the reference. That's better, right? No! If
    the `doSomething` function holds a reference to `bar`, there's nothing you can
    do outside `doSomething` to dereference it completely.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，您不需要返回`bar`变量，因此在不再需要它之后将其置空，销毁引用。这样就更好了，对吗？不！如果`doSomething`函数保持对`bar`的引用，那么在`doSomething`之外，您无法完全取消引用它。
- en: Even worse than this is the fact that the function can create a circular reference
    by creating a property that references itself in `bar`. But GC is clever enough
    to figure out when the rest of your application no longer uses an object. It depends
    on how complex your code is. Remember that if there is a doubt (that is, it's
    still referenced somewhere and can still be used), GC will not sweep the object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，函数可以通过在`bar`中创建一个引用自身的属性来创建循环引用。但GC足够聪明，可以判断应用程序的其他部分何时不再使用对象。这取决于您的代码有多复杂。请记住，如果存在疑问（即仍然在某处被引用并且仍然可以使用），GC将不会扫描该对象。
- en: In each cycle of its job, GC pauses V8 execution in what is called stop-the-world,
    knowing exactly where all objects are in the memory and what references exist.
    If there are too many references, GC will process only part of the object heap,
    minimizing the impact of the pause. The following image shows how V8 scans the
    memory objects, marks unreferenced ones (first row, in red), sweeps them from
    list (second row) and then compacts the list by removing empty spaces between
    objects (third row)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在其工作的每个周期中，GC会在所谓的停止-世界中暂停V8执行，确切地知道内存中所有对象的位置和存在的引用。如果引用太多，GC将只处理对象堆的一部分，最小化暂停的影响。下图显示了V8如何扫描内存对象，标记未引用的对象（第一行，红色），从列表中清除它们（第二行），然后通过删除对象之间的空白来压缩列表（第三行）。
- en: '![Referencing objects](img/4183_03_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![引用对象](img/4183_03_03.jpg)'
- en: 'The previous V8 GC generation had two algorithms for cleaning the old space:
    mark-sweep and mark-compact. In both the algorithms, GC went through the stack
    and marked reachable (referenced) objects. After that, it could use mark-sweep
    to just sweep the objects that weren''t reachable by freeing their memory, or
    use mark-compact to reallocate and compress the memory used. Both the algorithms
    worked at the page level. The problem with these two algorithms was that they
    introduced significant pauses in medium sized applications.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的V8 GC代有两种用于清理旧空间的算法：标记-扫描和标记-压缩。在这两种算法中，GC遍历堆栈并标记可达（引用）的对象。之后，它可以使用标记-扫描来释放未被引用的对象的内存，或者使用标记-压缩来重新分配和压缩所使用的内存。这两种算法都在页面级别上工作。这两种算法的问题在于它们会在中等大小的应用程序中引入显著的暂停。
- en: '![Referencing objects](img/4183_03_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![引用对象](img/4183_03_04.jpg)'
- en: In 2012, Google introduced an improvement that significantly reduced pauses
    in garbage collection cycles. It introduced incremental marking to avoid traversing
    a possibly huge zone. Instead, GC just goes through part of the zone to do the
    marking, making the pause smaller. Instead of a big pause, GC makes more pauses
    but small ones. But the improvement does not end here. After marking, GC does
    what is called a **lazy sweep**. Since GC knows exactly which objects are referenced
    and which are not (because of the previous mark step), it can now free the memory
    of the unreferenced ones (sweep). But it doesn't need to do that right away. Instead,
    it just sweeps on an as-needed basis. After sweeping them all, GC starts a new
    mark cycle again.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年，谷歌推出了一项改进，显著减少了垃圾收集周期中的暂停。它引入了增量标记以避免遍历可能巨大的区域。相反，GC只需通过区域的一部分进行标记，使暂停时间更短。GC不再产生大的暂停，而是产生更多但更小的暂停。但改进并不止于此。标记后，GC进行所谓的**懒惰扫描**。由于GC确切地知道哪些对象被引用，哪些没有（因为之前的标记步骤），它现在可以释放未引用对象的内存（扫描）。但它不需要立即这样做。相反，它只在需要时进行扫描。在扫描完所有对象后，GC再次开始新的标记周期。
- en: GC is fast as long as your program is kept lean and simple. Don't create a monolithic
    monster and then look for a way of raising the memory limit of V8\. On a 64-bit
    machine, you can almost double the 1 GB limit, but that's not the solution. You
    should really split your application. Even so, if you're thinking about changing
    the limit, the option in the node executable you're looking for is `--max-stack-size`
    (in bytes).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只要程序保持精简和简单，GC就会很快。不要创建一个庞大的怪物，然后寻找提高V8内存限制的方法。在64位机器上，您可以将1GB限制几乎翻倍，但这并不是解决方案。您真的应该拆分应用程序。即使如此，如果您考虑更改限制，您要寻找的是`--max-stack-size`（以字节为单位）这个选项。
- en: Object representation
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象表示
- en: 'In V8, there are three primitive types: numbers, booleans and strings. Numbers
    have two forms: SMall Integers (SMI), which are 31-bit signed integers, or normal
    objects in situations such as doubles (big numbers) or numbers with extended properties.
    Strings also have two forms: one is inside the heap, and the other is outside
    the heap, with a wrapper object on the heap as a pointer to it.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在V8中，有三种原始类型：数字、布尔值和字符串。数字有两种形式：SMall Integers（SMI），它们是31位有符号整数，或者在诸如双精度（大数字）或具有扩展属性的数字的情况下是普通对象。字符串也有两种形式：一种在堆内，另一种在堆外，堆内有一个包装对象作为指针指向它。
- en: There are also other objects such as arrays, which are objects with a magic
    length property, and native objects, which are not in the heap itself (they're
    wrapped like some strings) and are therefore not managed or swept by GC.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他对象，比如数组，它们是带有魔术长度属性的对象，以及本机对象，它们不在堆本身中（它们像某些字符串一样被包装），因此不受GC管理或扫描。
- en: Object heaps
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象堆
- en: 'GC stores objects in an object heap. The heap is divided into two main zones:
    new space and old space for—you guessed it—new objects and old objects respectively.
    New space is where objects are created and old space is where objects are moved
    to if they survive one or more GC cycles. Since GC is not constantly working,
    between cycles, objects can be created and they can be destroyed (and dereferenced)
    a few moments later. This is the most common object behavior, so GC usually sweeps
    them efficiently. Other objects live longer, and so they will survive cycles since
    they keep being referenced and used. This is where memory leaks can show up.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GC将对象存储在对象堆中。堆分为两个主要区域：新空间和旧空间，分别用于新对象和旧对象。新空间是对象创建的地方，旧空间是对象在一个或多个GC周期后移动到的地方。由于GC不是持续工作的，因此在周期之间，对象可以被创建，也可以在几分钟后被销毁（和取消引用）。这是最常见的对象行为，因此GC通常会有效地扫描它们。其他对象的生存周期更长，因此它们将在周期中存活，因为它们一直被引用和使用。这就是内存泄漏可能出现的地方。
- en: These two spaces are designed with different goals in mind. The new space is
    smaller than the old one and is designed to be fast, meaningful, and analyzed
    by the GC very quickly. The old space is larger and contains objects moved there
    after a cycle. This old space can grow to a very large size, from a couple of
    megabytes to a gigabyte. This design takes advantage of the common behavior that
    most objects have a short lifetime and so live only on the new space, which is
    smaller and faster to manage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个空间的设计目标不同。新空间比旧空间小，旨在快速、有意义，并且可以被GC快速分析。旧空间更大，包含在周期后移动到那里的对象。这个旧空间可以增长到非常大的大小，从几兆字节到一千兆字节。这种设计利用了大多数对象寿命短的常见行为，因此只存在于较小且更快的新空间中。
- en: Each space is composed of pages, contiguous blocks of memory that hold objects.
    Each page has a couple of headers on top and a bitmap telling GC what parts of
    the page the objects use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个空间由页面组成，页面是连续的内存块，用于存储对象。每个页面顶部有一些头部和一个位图，告诉GC页面的哪些部分被对象使用。
- en: This separation of objects and movement from one space to the other introduces
    some problems. One is, obviously, reallocation. Another is the need to know whether
    the references to an object in the new space are only in the old space. This is
    a possible situation and should prevent the object from being cleaned, but this
    would force GC to scan the old space to figure it out, breaking the speed of this
    architecture. To avoid this, GC maintains a list of references from the old space
    to the new space. This is another memory overhead but it's faster to scan this
    list. It's usually small since it's relatively rare to have this kind of reference.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对象之间的分离和从一个空间到另一个空间的移动引入了一些问题。一个问题显而易见，即重新分配。另一个问题是需要知道新空间中对对象的引用是否只存在于旧空间中。这是一种可能的情况，应该阻止对象被清理，但这会迫使GC扫描旧空间以弄清楚，从而破坏了这种架构的速度。为了避免这种情况，GC维护了从旧空间到新空间的引用列表。这是另一个内存开销，但扫描这个列表更快。通常很小，因为这种引用相对罕见。
- en: The new space is small, and it's cheap to create new objects since it's just
    a matter of incrementing a pointer in the already reserved memory. When this new
    space gets full, a minor cycle is triggered to collect any dead objects and reclaim
    the space, avoiding the use of more space. If an object survives two minor cycles,
    it is moved to the old space.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 新空间很小，创建新对象很便宜，因为只是在已经保留的内存中增加指针。当这个新空间满了时，将触发一个次要周期来收集任何死对象并回收空间，避免使用更多空间。如果一个对象经历了两个次要周期，它将被移动到旧空间。
- en: In the old space, objects are swept in a major cycle that is less frequent than
    the minor one in the new space. This major cycle can get triggered when a certain
    amount of memory is reached in this space or after a more prolonged period of
    time. This cycle is less frequent and can stall the application for a little longer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧空间中，对象在主要周期中进行扫描，这个周期比新空间中的次要周期频率低。当达到该空间的一定内存量或经过更长时间后，可以触发这个主要周期。这个周期的频率较低，可能会导致应用程序停顿更长时间。
- en: Heap snapshots
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆快照
- en: V8 allows you to get a heap snapshot to analyze memory distribution across objects.
    It allows you to see what objects your code uses, how many of each are used, and
    how the application uses them if you request heap snapshot dumps over time. There
    are several ways of collecting a heap snapshot, and we'll look at some of them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: V8允许您获取堆快照，以分析对象之间的内存分配。它允许您查看代码使用的对象，每个对象的使用数量以及应用程序如何在一段时间内使用它们，如果您请求堆快照转储。有几种收集堆快照的方法，我们将看一些。
- en: 'Let''s create a small leaking program and analyze it with the `node-inspector`
    module. Open a terminal and install node inspector globally (`-g`) so that you
    can use it anywhere in your machine. In the following example, we''re using `sudo`
    since global modules usually reside in a restricted area:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小的泄漏程序，并使用`node-inspector`模块进行分析。打开一个终端并全局安装node inspector（`-g`），这样您就可以在机器的任何地方使用它。在下面的例子中，我们使用`sudo`，因为全局模块通常驻留在受限制的区域中：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The inspector needs to compile some modules, so you''ll need a compiler. If
    it installs correctly, you''ll see a list of installed dependencies and you can
    now start it. Once it''s running, there''s no need to restart it while you change
    and restart your program. Just start it now with no parameters and leave it in
    a terminal tab:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器需要编译一些模块，因此您需要一个编译器。如果安装正确，您将看到已安装的依赖项列表，现在可以启动它。一旦它运行起来，您就无需在更改和重新启动程序时重新启动它。只需现在不带参数启动它，并将其留在终端选项卡中：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see something similar to the following console output. You can see
    that I''m using version `0.10.0`, but you might get a different version. For the
    purpose of the example, it''s not actually critical that you use the same version.
    Depending on the version you use, the output may vary. In this case, it is something
    similar to this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下控制台输出。您可以看到我正在使用版本`0.10.0`，但您可能会得到不同的版本。在这个例子中，实际上使用相同的版本并不是很重要。根据您使用的版本，输出可能会有所不同。在这种情况下，它与以下内容类似：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open your web browser and head to the page indicated in the output. Now let''s
    create a program called `leaky`. The purpose of this program will be to leak memory
    intentionally. Create a folder and inside install the V8 profiler:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的网络浏览器，转到输出中指示的页面。现在让我们创建一个名为`leaky`的程序。这个程序的目的是故意泄漏内存。创建一个文件夹，并在其中安装V8分析器：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Be aware that this module can also need a compiler. Now, in the same folder,
    create a file called `leaky.js` with the following content:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个模块也可能需要一个编译器。现在，在同一个文件夹中，创建一个名为`leaky.js`的文件，内容如下：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The program can be confusing, but the idea is to blind GC from seeing that
    we''re forcing it not to garbage-collect objects, and so, leak memory. If you
    look more closely, you will see that `leakObject` gets redefined with a function
    that outputs it if called, but the way it references it makes GC unaware of our
    awful goal. Be aware that when running this program, you''ll starve the memory
    quite quickly, perhaps in the order of 100 megabytes per second. Run this with
    debug turned on:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序可能会让人困惑，但是想法是让GC无法看到我们强制它不回收对象，从而泄漏内存。如果您仔细观察，您会发现`leakObject`被重新定义为一个在调用时输出它的函数，但它引用的方式使GC不知道我们可怕的目标。请注意，运行此程序时，您将很快耗尽内存，可能每秒耗费100兆字节。以调试模式运行此程序：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now head over to the web page you just opened, click on **Refresh**, go to
    the **Profiles** tab on the page, choose **Take Heap Snapshot**, and click on
    the **Take Snapshot** button, as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到您刚刚打开的网页，单击**刷新**，转到页面上的**Profiles**选项卡，选择**Take Heap Snapshot**，然后单击**Take
    Snapshot**按钮，如下所示：
- en: '![Heap snapshots](img/4183_03_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![堆快照](img/4183_03_05.jpg)'
- en: Wait a minute and hit that button again. You'll see snapshots appearing on the
    left sidebar and you'll notice that they don't have the same size. They're growing
    and it's GC leaking our nonsense program. You can easily notice this if you select
    the last snapshot and choose to compare it with the first one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 等一分钟，然后再次点击该按钮。您会看到快照出现在左侧边栏，并且您会注意到它们的大小不一样。它们在增长，而且GC正在泄漏我们的无意义程序。如果您选择最后一个快照并选择与第一个快照进行比较，您很容易注意到这一点。
- en: You'll see that there's a delta change in both size and the new objects. A positive
    delta means that more objects were created than destroyed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到大小和新对象的变化。正增量意味着创建的对象比销毁的对象多。
- en: '![Heap snapshots](img/4183_03_06.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![堆快照](img/4183_03_06.jpg)'
- en: You can see in the preceding screenshot what the inspector looks like when showing
    a snapshot. There's a list of constructors or base objects. In this case, since
    we're comparing **Snapshot 3** with **Snapshot 1**, there are columns that show
    how many objects were created and deleted as well as how much memory was allocated
    and freed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在上面的截图中看到检查器显示快照时的样子。有一个构造函数或基本对象的列表。在这种情况下，由于我们正在比较**快照3**和**快照1**，所以有显示创建和删除的对象数量以及分配和释放的内存量的列。
- en: 'Another useful method for detecting memory leaks is recording object allocations
    over time. Using this very inspector, restart the program, head to **Profiles**,
    choose **Record Heap Allocations** and hit **Start**, as shown in this screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 检测内存泄漏的另一个有用方法是记录随时间的对象分配。使用这个检查器，重新启动程序，转到**Profiles**，选择**Record Heap Allocations**，然后点击**Start**，如此截图所示：
- en: '![Heap snapshots](img/4183_03_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![堆快照](img/4183_03_07.jpg)'
- en: The inspector will start recording. It will stop when you click on the red circle
    in the top-left corner. You'll see a growing timeline and a bar chart for allocations
    for every minor cycle. If you wait a bit, you'll see major cycles and object reallocations
    (from new zones to old zones).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器将开始记录。当您单击左上角的红色圆圈时，它将停止。您将看到一个不断增长的时间线和每个次要周期的分配条形图。如果等一会儿，您会看到主要周期和对象重新分配（从新区到旧区）。
- en: '![Heap snapshots](img/4183_03_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![堆快照](img/4183_03_08.jpg)'
- en: After stopping, you can select a period of time by clicking on a start point
    and dragging it to the end point. You'll see only the allocations in that period,
    not all the objects. You can save the snapshot for later analysis or comparison.
    In this specific example, you can see how memory is quickly being consumed every
    second.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 停止后，您可以通过单击起点并将其拖动到终点来选择一段时间。您将只看到该时期的分配情况，而不是所有对象。您可以保存快照以供以后分析或比较。在这个特定的例子中，您可以看到内存如何每秒快速消耗。
- en: '![Heap snapshots](img/4183_03_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![堆快照](img/4183_03_09.jpg)'
- en: You can click and expand the objects list to look at every object. If you're
    looking for a particular object, you can use the filter at the top. In this example,
    you can open the (string) group and you'll see there are several instances like
    `********…` that we created in our program.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以单击并展开对象列表以查看每个对象。如果您正在寻找特定对象，可以使用顶部的过滤器。在这个例子中，您可以打开（字符串）组，您会看到我们在程序中创建的像`********…`这样的几个实例。
- en: '![Heap snapshots](img/4183_03_10.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![堆快照](img/4183_03_10.jpg)'
- en: Using `v8-profiler` allows you to do more than just debug with `node-inspector`.
    You can, for example, take snapshots of your code and analyze it—maybe compare
    it with previous snapshots—or serialize and save it for later analysis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`v8-profiler`不仅可以与`node-inspector`一起进行调试。例如，您可以对代码进行快照并进行分析，也许与以前的快照进行比较，或者将其序列化并保存以供以后分析。
- en: 'For example, taking the previous program example into consideration, we can
    periodically check how many nodes are there in our stack:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑前面的程序示例，我们可以定期检查我们的堆栈中有多少个节点：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you run this new version, you might get an output similar to the following.
    This is a proof that objects are surviving GC cycles and leaking memory:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行这个新版本，您可能会得到类似以下的输出。这证明了对象在GC周期中存活并泄漏内存：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is just an example. If you monitor your application and the memory keeps
    growing over time while it is idle (not doing anything), it is a reason to analyze
    further. The first-class citizens (so-called classes, for people coming from other
    object-oriented languages) will appear in the constructor list of the snapshots
    of your application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子。如果你监视你的应用程序，而它在空闲时内存不断增长，这是需要进一步分析的原因。第一类公民（对于来自其他面向对象语言的人来说，所谓的类）将出现在应用程序快照的构造函数列表中。
- en: There are other modules you can use to analyze and monitor your Node.js program
    memory and garbage collector. The `heapdump` module is another simple module that
    can help you just dump a heap snapshot every now and then to disk. Keep in mind
    that these snapshots are synchronous, so your program will pause for a moment
    if the heap is large.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他模块可以用来分析和监控你的Node.js程序的内存和垃圾回收器。`heapdump`模块是另一个简单的模块，可以帮助你定期将堆快照转储到磁盘上。请记住，这些快照是同步的，所以如果堆很大，你的程序会暂停一会儿。
- en: 'To use it, just install it like the other modules previously installed:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，只需像之前安装其他模块一样安装它：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then change your program to use it. Here''s an example of a program that takes
    a snapshot to disk every minute. This is not a real or good use case, but perhaps
    a hourly snapshot with some kind of disposable script to avoid filling your disk
    might not be a bad idea:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后改变你的程序来使用它。这是一个每分钟将快照保存到磁盘的程序示例。这不是一个真实或好的用例，但也许每小时拍摄一次快照，并使用某种一次性脚本来避免填满你的磁盘可能不是一个坏主意：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The name of the file is the Unix date in milliseconds, so you will always know
    when it was taken. Run it and wait for at least one snapshot to be written to
    disk. In this case, you don't need to enable `debug` in the node (`--debug`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的名称是Unix毫秒日期，所以你会始终知道它是何时被拍摄的。运行它，等待至少一个快照被写入磁盘。在这种情况下，你不需要在节点中启用`debug`（`--debug`）。
- en: You kept `node-inspector` running on the terminal, right? If not, please do
    it. Then go to its web page, as you did before, and refresh the page.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你保持`node-inspector`在终端上运行了吗？如果没有，请运行它。然后像之前一样，去它的网页，刷新页面。
- en: '![Heap snapshots](img/4183_03_11.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![堆快照](img/4183_03_11.jpg)'
- en: Now, instead of choosing **Take Snapshot**, just click on the **Load** button
    and choose the snapshots from your disk. This is another approach—an offline one—and
    it is usually more useful since you're usually not running your code in debug
    mode and looking at it live in v8-inspector. Also, `node-inspector` will restart
    the interface when your program stops, so you need to save your snapshots before
    restarting node-inspector.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不要选择**Take Snapshot**，只需点击**Load**按钮，然后选择来自磁盘的快照。这是另一种方法——离线方法——通常更有用，因为你通常不会以调试模式运行你的代码，并且在v8-inspector中实时查看它。此外，当你的程序停止时，`node-inspector`会重新启动界面，所以你需要在重新启动`node-inspector`之前保存你的快照。
- en: 'If you have a memory leak you know of and you are able to reproduce it by just
    stressing it, you can use this approach and perhaps add a little twist to the
    execution of the program by activating GC trace lines for every action. You can
    then see when GC is sweeping or marking. The following is an example of what you''ll
    see if you monitor the GC actions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道有内存泄漏，并且能够通过压力来重现它，你可以使用这种方法，也许在执行程序时添加一点变化，通过激活每个动作的GC跟踪行。然后你可以看到GC何时在清扫或标记。以下是一个例子，如果你监视GC动作，你会看到的：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Part of the previous output was truncated for clarity. The number *26503* is
    the process ID of the program in this example. You can see when the action took
    place and how long it took at the end of each trace line. You can also see the
    actions (`Scavenge` and `Mark-sweep`) and the memory evolution for each cycle.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，前面的输出部分被截断了。数字*26503*是本例程序的进程ID。你可以看到动作发生的时间以及每条跟踪线的末尾花费的时间。你还可以看到每个周期的动作（`Scavenge`和`Mark-sweep`）以及内存的演变。
- en: For a running application, It's not feasible to have —trace-gc enabled (as in
    the previous command), and you should think of an approach that works for your
    architecture. One of the options is using `heapdump`, scheduling a snapshot every
    hour or so, and saving the last 10 or 20 snapshot. When using this approach, you
    should at least look at the last snapshot and compare it with the previous one
    to see how your application evolves over time. You might find slow memory leaks
    or very fast memory leaks. For the fast ones, you should be able to record heap
    allocations and rapidly stop leaks. For slow ones, it's harder to spot it, and
    only over very long periods are you able to compare changes and find the ghosts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行中的应用程序，启用`--trace-gc`（如前面的命令）是不可行的，你应该考虑一个适合你的架构的方法。其中一个选项是使用`heapdump`，每小时安排一个快照，并保存最后的10或20个快照。使用这种方法时，你至少应该查看最后一个快照，并将其与上一个快照进行比较，以了解你的应用程序随时间的演变。你可能会发现慢速内存泄漏或非常快速的内存泄漏。对于快速的内存泄漏，你应该能够记录堆分配并迅速停止泄漏。对于慢速的内存泄漏，很难发现它，只有在非常长的时间内才能比较变化并找到问题。
- en: There's also another useful module that can help you spot leaks, which is called
    `memwatch`. This module will look for heap size changes, and when it finds that
    the heap size is constantly growing, it will emit a leak event (the irony). It
    also has a nice stats event with information on GC cycles.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个有用的模块可以帮助你发现泄漏，它叫做`memwatch`。这个模块会寻找堆大小的变化，当它发现堆大小不断增长时，它会发出一个泄漏事件（讽刺）。它还有一个带有GC周期信息的漂亮的统计事件。
- en: 'Let''s change our initial program to use this module instead of any profilers
    or inspectors. Yes, it doesn''t need them, and it doesn''t even need you to enable
    node debug. First, let''s install it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们最初的程序改成使用这个模块，而不是任何分析器或检查器。是的，它不需要它们，甚至不需要你启用节点调试。首先，让我们安装它：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let''s change our program to something similar to this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把我们的程序改成类似于这样的东西：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now simply run the program. Let it run for a few seconds and you''ll see something
    similar to this example output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需运行程序。让它运行几秒钟，你会看到类似于这个例子输出：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You will notice GC cycles occurring very often. This is because of our program
    behavior. GC adapts to rapid heap changes and triggers cycles more often. If you
    change the memory leak call period to 5 seconds or more, you will have to wait
    much longer to see cycles and leaks.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到GC周期经常发生。这是因为我们程序的行为。GC会适应快速的堆变化，并更频繁地触发周期。如果你将内存泄漏调用周期更改为5秒或更长时间，你将不得不等待更长时间才能看到周期和泄漏。
- en: The `memwatch` module works by checking heap changes after GC sweeps and compacts
    it, so it won't trigger a leak just because your application is using memory,
    but because you're using it and not disposing it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`memwatch`模块通过在GC扫描和压缩后检查堆变化来工作，因此它不会仅仅因为你的应用程序使用内存就触发泄漏，而是因为你使用了内存而没有处理它。'
- en: 'Another very useful feature of this module is the ability to help you compare
    heap snapshots. You do this by explicitly telling the module that you want a `heapdiff`.
    At this moment, the module snapshots heap, waits for your call to snapshot again,
    and compares it. After that, it will give you an object showing the totals before
    and after and the changes to each snapshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的另一个非常有用的功能是帮助你比较堆快照。你可以通过显式告诉模块你想要一个`heapdiff`来实现这一点。此时，模块会对堆进行快照，等待你再次对堆进行快照，并进行比较。之后，它会给你一个对象，显示之前和之后的总数以及每个快照的变化：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the program. After that, you''ll get an output similar to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序。之后，你会得到类似以下的输出：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you look at the `change.details` array, you'll notice that you have a list
    of constructors that have changed between heaps. If you have a leak occurring
    between the snapshots, it will be in one of those items. In our case, it's the
    string constructor since we're leaking string variables.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看`change.details`数组，你会注意到你有一个在堆之间发生变化的构造函数列表。如果在快照之间发生泄漏，它将在其中的某个项目中。在我们的情况下，它是字符串构造函数，因为我们正在泄漏字符串变量。
- en: With or without any of these modules, you should definitely monitor memory usage
    and growth. Rapid memory leaks will starve your resources and leave your clients
    unhappy. For high-load applications, you should create stress tests to be able
    to detect leaks before the application goes into production.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否使用这些模块，你都应该监控内存使用和增长。快速的内存泄漏会耗尽你的资源，让你的客户感到不满。对于高负载的应用程序，你应该创建压力测试，以便在应用程序投入生产之前能够检测到泄漏。
- en: Third-party management
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方管理
- en: 'In the spirit of dividing your application into smaller components, sometimes
    it might be a better idea to move some objects and manipulations to external services,
    which are sometimes optimized for specific workloads and object formats. Explore
    some of these servers before starting to manipulate large object structures:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用程序划分为较小组件的精神下，有时将一些对象和操作移动到外部服务可能是一个更好的主意，这些服务有时针对特定的工作负载和对象格式进行了优化。在开始操作大型对象结构之前，先探索一些这样的服务器：
- en: Memcached for key/values and Redis for lists, sets, and hash tables
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Memcached用于键/值，Redis用于列表、集合和哈希表
- en: MongoDB if you want to run JavaScript on the data, and ElasticSearch for interesting
    features, such as data timeout or hierarchical elements (documents inside documents)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想在数据上运行JavaScript，可以使用MongoDB，如果你需要一些有趣的功能，比如数据超时或分层元素（文档内的文档），可以使用ElasticSearch
- en: HBase if you need some complex map/reduce code, and Hypertable if you need a
    lightweight version of that code
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要一些复杂的map/reduce代码，可以使用HBase，如果你需要该代码的轻量级版本，可以使用Hypertable
- en: OrientDB if you need a graph database, and Riak to store large binary data
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要图形数据库，可以使用OrientDB，如果需要存储大型二进制数据，可以使用Riak
- en: Your application is usually running on memory, so if it fails and stops, the
    memory used is lost and your precious data can be lost too. Using an external
    service to handle the data (and sometimes manipulate it) can greatly reduce your
    memory footprint. Moreover, these services usually allow you to access concurrently,
    enabling you to split the data manipulation effort for several instances of your
    application or tool.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序通常在内存中运行，所以如果它失败并停止，使用的内存就会丢失，你宝贵的数据也可能会丢失。使用外部服务来处理数据（有时还可以操作数据）可以大大减少你的内存占用。此外，这些服务通常允许你并发访问，使你能够将数据操作工作分配给应用程序或工具的多个实例。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You now see that the garbage collector task is not all that easy, but it certainly
    does a very good job managing memory automatically. You can help it a lot, especially
    if you are writing applications with performance in mind. Preventing the GC old
    space from growing is necessary to avoid long GC cycles. Otherwise, it can pause
    your application and sometimes force your services to restart. Every time you
    create a new variable, you allocate memory and inch closer to a new GC cycle.
    Even after understanding how memory is managed, you sometimes need to inspect
    your memory usage behavior. The cleanest way is by collecting snapshot heaps of
    the memory stack and analyzing using the V8 inspector or other similar pieces
    of software. The interface is self-explanatory, and leaks will show up simply
    if you sort the object list by shallow size, retained size, or reference counting.
    But before creating an application with a huge memory footprint, take a look at
    databases, whether relational or not, as this will help you store and manipulate
    the data, avoiding the need to do it yourself using the language. Remember that
    JavaScript was not designed to create computationally intensive tasks. If you
    still need to perform more intensive tasks, you might want to instrument the code
    to analyze and improve it so that you can achieve optimal performance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到垃圾收集器的任务并不那么容易，但它确实非常擅长自动管理内存。您可以在很大程度上帮助它，特别是如果您正在编写性能优化的应用程序。防止GC老年代空间增长是必要的，以避免长时间的GC周期。否则，它可能会暂停您的应用程序，有时甚至会强制您的服务重新启动。每次创建新变量时，都会分配内存并接近新的GC周期。即使了解了内存是如何管理的，有时您仍需要检查内存使用行为。最干净的方法是通过收集内存堆的快照，并使用V8检查器或其他类似的软件进行分析。界面是不言自明的，如果您按浅层大小、保留大小或引用计数对对象列表进行排序，泄漏将会简单地显示出来。但在创建具有巨大内存占用的应用程序之前，先看看数据库，无论是关系型还是非关系型，这将帮助您存储和操作数据，避免使用语言自己来做。请记住，JavaScript并不是为了创建计算密集型任务而设计的。如果您仍然需要执行更多的密集任务，您可能需要对代码进行仪器化分析和改进，以便实现最佳性能。
- en: In the next chapter, we will see what profiling is, what the benefits of doing
    it are, some available analysis tools, and how to understand results and upgrade
    your code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到什么是性能分析，做性能分析的好处是什么，一些可用的分析工具，以及如何理解结果并升级您的代码。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID为bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他用途均需获得版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止，并违反适用法律。保留所有权利。
