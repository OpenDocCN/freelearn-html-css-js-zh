- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: The setValue Wrapper – Entering Text and Dynamic Data Replacement
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`setValue` 包装器 – 输入文本和动态数据替换'
- en: In this chapter, we’re going to adapt the functionality from the `click()` method
    in the earlier chapter and extend it to the `setValue()` method. In addition,
    the wrapper method introduces multiple approaches to clear the field before entering
    the data. This chapter shows you how to implement a dynamic data tag replacement
    as an enhancement. This is the focal point where data can be prevented from becoming
    stale. For example, a test might require a future or past date. Lastly, we will
    look at detecting a password field and masking it with the `setPassword()` function.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将适应之前章节中 `click()` 方法的功能，并将其扩展到 `setValue()` 方法。此外，包装器方法引入了在输入数据之前清除字段的多种方法。本章将向您展示如何实现动态数据标签替换作为增强功能。这是数据防止过时的焦点。例如，一个测试可能需要一个未来的或过去的日期。最后，我们将查看检测密码字段并使用
    `setPassword()` 函数对其进行屏蔽。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a `setValue` Wrapper
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `setValue` 包装器
- en: Normalizing the element class description from plain English
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从普通英语规范化元素类描述
- en: Alternative ways to clear a field and enter data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除字段并输入数据的替代方法
- en: Dynamically replacing `<Today>` tags with a date
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态替换 `<Today>` 标签为日期
- en: Masking sensitive credential data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏敏感凭证数据
- en: 'First, some housekeeping is in order. In the last chapter, we introduced class
    switching for our button. We will do the same thing for our input fields and upcoming
    lists and text elements. While we can deduce the type of element being passed
    to the `getValidElement()` method, we can just as easily pass the type directly
    from the wrapper:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一些家务要做。在上一个章节中，我们介绍了按钮的类切换。我们将对输入字段以及即将到来的列表和文本元素做同样的事情。虽然我们可以推断出传递给 `getValidElement()`
    方法的元素类型，但我们也可以直接从包装器中传递类型：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This means we can optimize the code for speed by skipping the code that extracts
    the `element` class, by explicitly stating the element type:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以通过跳过提取 `element` 类的代码来优化代码的速度，通过明确地指定元素类型：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, the explicit `field` string will not match the implicit string type
    of `//input`. To resolve this, we will add a method that will change generic descriptors
    such as `field` or `item` to a suitable class string such as `//input` and “`//li`”.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，显式的 `field` 字符串将不会匹配 `//input` 的隐式字符串类型。为了解决这个问题，我们将添加一个方法，将像 `field` 或
    `item` 这样的通用描述符转换为合适的类字符串，例如 `//input` 和 “`//li`”。 '
- en: Normalizing the element type
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范化元素类型
- en: 'This is where we will write a method to normalize all the explicit strings.
    Here, `link` becomes `//a`, `button` becomes `//button`, and so on. Your framework
    can continue to expand with many other element types as needed. The following
    function, `normalizeElementType()`, will take a plain English description of the
    element and translate it into a common `xPath` equivalent. Note that `field` and
    `input` become the same class, while an empty class description becomes a locator
    for all elements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将编写一个方法来规范化所有显式字符串的地方。在这里，`link` 变为 `//a`，`button` 变为 `//button`，依此类推。您的框架可以根据需要继续扩展许多其他元素类型。以下函数
    `normalizeElementType()` 将将元素的普通英语描述转换为常见的 `xPath` 等效值。请注意，`field` 和 `input` 变为相同的类，而空的类描述成为所有元素的定位符：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are a couple of items of note in this function. The first is the pessimistic
    nature of the function, which assumes the locator string passed was empty or `null`.
    `elementText` is initialized to `//*` to return all the elements in the first
    line. This means we assume at some point that a value might get passed a string
    that is yet to be implemented – for example, `list`. For documentation, we output
    the name of the unknown string as a warning to the console log.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，有几个值得注意的点。首先，该函数具有悲观性质，它假设传递的定位字符串为空或 `null`。`elementText` 被初始化为 `//*`
    以返回第一行中的所有元素。这意味着我们假设在某个时刻可能会传递一个尚未实现的字符串，例如 `list`。为了文档记录，我们将未知字符串的名称作为警告输出到控制台日志。
- en: Second, we change the element to match all values rather than stopping the test.
    We want the framework to try its best to get to the endpoint without incurring
    more maintenance time. However, it does give a warning that we should be as descriptive
    as possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将元素更改为匹配所有值而不是停止测试。我们希望框架尽可能多地尝试到达终点，而不增加更多的维护时间。然而，它确实给出了一个警告，我们应该尽可能详细地描述。
- en: 'Because we are now supporting unknown element types, we will add a generic
    locator to the `getValidElement()` function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在支持未知元素类型，我们将向 `getValidElement()` 函数添加一个通用定位器：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we normalize text, we take common English descriptors and replace them
    with `xpath` element or CSS string locator equivalents. However, that’s not just
    applicable in the class. This same concept is leveraged in many attributes as
    well. Let’s take a moment to look at a link before we move on to input fields.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们规范化文本时，我们将常见的英语描述符替换为 `xpath` 元素或 CSS 字符串定位符等价物。然而，这不仅仅适用于类。这个相同的概念也被用于许多属性中。在我们继续到输入字段之前，让我们花一点时间看看一个链接。
- en: 'Normalizing text can be seen in XPath locators to allow us to find elements
    that have embedded carriage returns and extraneous transient white space. In this
    example, the “Embedded Carriage Return” web page element has extra spaces and
    a carriage return:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化文本可以在 XPath 定位器中看到，使我们能够找到包含嵌入的回车和多余的临时空白空间的元素。在这个例子中，“嵌入回车”网页元素有额外的空格和回车：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/B19395_06_1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19395_06_1.jpg)'
- en: 'This means that this xPath won’t work to recognize the link:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个 xPath 无法识别链接：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/B19395_06_2.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19395_06_2.jpg)'
- en: 'However, we can normalize the text with the `normalize-space()` node to remove
    carriage return `<br>` breaks and even stray white space:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用 `normalize-space()` 节点来规范化文本，以删除回车 `<br>` 换行符以及多余的空白：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/B19395_06_3.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19395_06_3.jpg)'
- en: Now that we have yet another tool in our utility belt, we can write locators
    that can find elements with extra spaces and line breaks, reducing the maintenance
    time should these be cleaned up by the developers. Let’s take this to the next
    level with input elements and the `setValue` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们又有了工具箱中的另一个工具，我们可以编写可以找到包含额外空格和换行符的元素的定位器，如果这些元素被开发者清理，这将减少维护时间。让我们通过输入元素和
    `setValue` 方法将这一概念提升到下一个层次。
- en: Adding the setValue() method wrapper
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 setValue() 方法包装器
- en: 'We begin by adding a new wrapper to our `helpers` file that we will extend
    with several checks, before performing the intrinsic `setValue()` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 `helpers` 文件中添加一个新的包装器，我们将扩展它以执行几个检查，然后再执行内建的 `setValue()` 方法：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we are ready to begin to enhance the data population aspect of our framework.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始增强我们框架的数据填充方面。
- en: Is this trip really necessary?
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这趟旅行真的有必要吗？
- en: 'The first thing to do is to check whether any of the following code must be
    executed at all. There is no reason to find and replace a state element with a
    valid one if we don’t have any text to enter. So, we will first check whether
    any data has been passed to be entered:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的就是检查以下代码是否必须执行。如果没有文本要输入，我们没有理由找到并替换一个有效的状态元素。因此，我们将首先检查是否已传递任何数据以进行输入：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function has three actions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有三个动作：
- en: If the text is not null and not empty, the code continues to execute the rest
    of the method.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本不是 null 且不为空，代码将继续执行方法的其余部分。
- en: If the text was an empty string it returns `true`, meaning the test can continue.
    This is useful, as we might be populating an entire page, but not every field
    takes a value. We could be searching by any combination of last name, zip code,
    and state. This allows for a page method design that has every input field but
    only interacts with the elements that receive some data.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本为空字符串，则返回 `true`，意味着测试可以继续。这很有用，因为我们可能正在填充整个页面，但并非每个字段都需要值。我们可能通过姓氏、邮编和州的任意组合进行搜索。这允许我们设计一个页面方法，它具有所有输入字段，但仅与接收某些数据的元素交互。
- en: A null value is a special situation. It’s a clue that something is amiss. As
    superheroes, we always want to collect clues to identify the usual suspect who
    is committing the crime. If the clue is in the form of a riddle, we might check
    with the local asylum to see whether the cell adorned with question marks still
    holds an inmate.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值是一个特殊情况。它是一个表明有问题的线索。作为超级英雄，我们总是想收集线索来识别通常的嫌疑人，他们正在犯罪。如果线索是以谜语的形式出现的，我们可能会与当地的精神病院联系，看看是否还有囚犯被关在带有问号的牢房里。
- en: In this case, a NULL value usually shows that the value was returned from a
    query that found nothing. We send a warning to the console and return `false`
    as the status. Just like with an empty value, it skips the rest of the function.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，NULL 值通常表明查询返回了空值。我们向控制台发送警告，并返回 `false` 作为状态。就像空值一样，它跳过函数的其余部分。
- en: With the input data confirmed, we will take a second step and add the ability
    to keep our data fresh.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 确认输入数据后，我们将采取第二步，并添加保持数据新鲜的能力。
- en: Coal into diamonds – replacing dynamic data tags
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 煤炭变成钻石——替换动态数据标签
- en: A very common task in test automation is to populate a field with the current
    date. Now, we don’t want to be changing the date every single day manually, so
    we want something dynamic that provides us with that functionality. If we’re clever,
    that functionality can return the current, past, or future date. Even the date
    format could be modified. This is where the techniques of embedded dynamic data
    tags come into play.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化中的一个非常常见的任务是使用当前日期填充字段。现在，我们不想每天手动更改日期，所以我们想要一个动态的功能来提供这种功能。如果我们足够聪明，这个功能可以返回当前、过去或未来的日期。甚至日期格式也可以修改。这就是嵌入式动态数据标签技术发挥作用的地方。
- en: Dynamic data tags are a way to keep data that changes at a regular cadence fresh.
    It might be the current day of the week, a unique order number that was created
    by a batch job that needs completion, or a future business date excluding weekends
    and holidays.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数据标签是一种保持定期变化的数据新鲜的方式。这可能是一周中的当前日期，一个由需要完成的批处理作业创建的唯一顺序号，或者一个排除周末和假期的未来业务日期。
- en: 'There are many applications that will be unique to each individual project.
    In this case, we will provide a simple example of the most common data replacement
    – replacing a tag name, `"Today is: <today>"`, with the current date (i.e., `"Today`
    `is 6/21/2023`).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '每个项目都有许多独特应用。在这种情况下，我们将提供一个最常见的数据替换的简单示例——将标签名`"Today is: <today>"`替换为当前日期（即`"Today
    is 6/21/2023"`）。'
- en: 'However, we won’t stop there. We will also offset the date by any amount of
    days for a future date:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会止步于此。我们还将对未来的日期进行任意天数的日期偏移：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, we can do it for a past date:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以为过去日期进行操作：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we want to have the ability to change the formatting:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望有改变格式的功能：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The basic format of this `<today>` tag gets replaced with a past or future
    date, with the custom `replaceTags()` function. Next, we add the function that
    detects these tags in every string passed through `setValueAdv()`. This will handle
    all sorts of tags:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`<today>`标签的基本格式将被替换为过去或未来的日期，使用自定义的`replaceTags()`函数。接下来，我们添加一个函数，该函数检测通过`setValueAdv()`传递的每个字符串中的这些标签。这将处理所有类型的标签：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We use a bit of dark magic called a regular expression, which identifies strings
    encased in square brackets and extracts them:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一种名为正则表达式的暗黑魔法，它可以识别括号内的字符串并将其提取出来：
- en: '`/`: This is the start delimiter for the regular expression.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：这是正则表达式的开始分隔符。'
- en: '`\<`: This matches the opening angle bracket, `<`, in the text.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<`：这匹配文本中的打开尖括号`<`。'
- en: '`(.*?)`: This is a capturing group that matches any character (represented
    by the dot, `.` ) zero or more times (represented by `*?`) until it encounters
    the next character in the regular expression (in this case, the closing angle
    bracket >). `?` makes the `*` quantifier lazy, meaning it will match as few characters
    as possible to satisfy the regex pattern.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(.*?)`：这是一个捕获组，匹配任意字符（由点`.`表示）零次或多次（由`*?`表示），直到遇到正则表达式中的下一个字符（在这种情况下，关闭的尖括号`>`）。`?`使`*`量词懒惰，意味着它将尽可能少地匹配字符以满足正则表达式模式。'
- en: '`\>`: This matches the closing angle bracket, `>`, in the text.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>`：这匹配文本中的关闭尖括号`>`。'
- en: '`/`: This is the end delimiter for the regular expression.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：这是正则表达式的结束分隔符。'
- en: 'It is possible that multiple tags might need to be replaced in the string.
    So, we will loop through all of them. Tag identification is case-insensitive,
    meaning `<today>` and `<TODAY>` are equivalent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要在字符串中替换多个标签。因此，我们将遍历所有标签。标签识别不区分大小写，意味着`<today>`和`<TODAY>`是等效的：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `switch` statement matches the first part of the tag extension to multiple
    tags in the future. In this case, our first match will be a tag that starts with
    `<today` and splits out `+` or `-` with the following value to offset the date:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`switch`语句匹配标签扩展的第一部分，与未来的多个标签相匹配。在这种情况下，我们的第一次匹配将是一个以`<today`开头的标签，并通过后面的值来偏移日期：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have the `tag` string. Now, we split the date format, if it exists, to transform
    the date at the end of the function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了`tag`字符串。现在，如果存在日期格式，我们将对其进行分割以转换函数末尾的日期：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another regular expression here extracts the days to offset the date:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个正则表达式用于提取偏移日期的天数：
- en: '`/` : This is the start delimiter for the regular expression.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：这是正则表达式的开始分隔符。'
- en: '`[+-]` : This matches either the `+` or `-` character in the text. The square
    brackets denote a character class, which means that the regular expression will
    match any one of the characters inside the brackets.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[+-]`：这匹配文本中的`+`或`-`字符。方括号表示字符类，这意味着正则表达式将匹配方括号内任意一个字符。'
- en: '`(\d+)`: This is a capturing group that matches one or more digits (represented
    by `\d`) in the text). The parentheses surrounding `\d+` capture the matched digits
    as a group. The `+` quantifier means that the regular expression will match one
    or more digits.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(\d+)`：这是一个捕获组，匹配文本中的一或多个数字（由`\d`表示）。括号围绕`\d+`将匹配的数字作为一个组捕获。`+`量词意味着正则表达式将匹配一个或多个数字。'
- en: '`/`: This is the end delimiter for the regular expression.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：这是正则表达式的结束分隔符。'
- en: 'The next action is to determine whether there is an offset by a number of days
    to a past or future date:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个动作是确定是否存在对过去或未来日期的偏移天数：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we replace the tag in the string with a function that gets the current
    date offset and custom format:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用函数替换字符串中的标签，该函数获取当前日期的偏移量和自定义格式：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This loop continues until all the tags have been replaced. If any tags are
    discovered and replaced, the new text is output to the console for logging:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会一直持续到所有标签都被替换。如果发现并替换了任何标签，新的文本将被输出到控制台进行记录：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have the ability to extract dynamic date tags, we need to process
    the offset date and formatting with the `getToday()` function. The default, today’s
    date, is empty, and the date format is `MM-dd-yyyy` if the format argument is
    blank.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了提取动态日期标签的能力，我们需要使用`getToday()`函数来处理偏移日期和格式。默认情况下，即今天的日期为空，如果格式参数为空，则日期格式为`MM-dd-yyyy`。
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here is our super-secret serum. This code will produce the date based on the
    format passed in. Why write loads of code to support all date formats, from 2-digit
    or 4-digit years and `0` leading dates to a European format, when `Date.toLocalDateString`
    can do it all for us in just these few lines of code?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的超级秘密配方。这段代码将根据传入的格式生成日期。为什么需要写大量的代码来支持所有日期格式，从两位数或四位数的年份和`0`前导日期到欧洲格式，当`Date.toLocalDateString`可以在这么少的代码行中为我们完成所有这些呢？
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our dynamic date tag extractor and formatter are complete! The next trick is
    to populate it in a field. And, as you might guess, there is more than one way
    to do this – the slow way and the fast way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的动态日期标签提取器和格式化器已经完成！下一个技巧是将它填充到字段中。正如你可能猜到的，有不止一种方法可以做到这一点——慢速和快速的方法。
- en: Injecting versus typing text into a field
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向字段中注入文本与输入文本
- en: 'We may want to override the intrinsic `setValue()` command to populate a field:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要覆盖内置的`setValue()`命令来填充字段：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The reason is that injecting a value into an element may not necessarily kick
    off any additional JavaScript code behind the element. This might also skip some
    formatting that the developers added when we inject the data. Alternatively, we
    could use `addValue()`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是向元素注入值不一定能触发元素背后的任何附加JavaScript代码。这也可能跳过我们在注入数据时开发者添加的一些格式。或者，我们可以使用`addValue()`：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we might be appending text into a field that already has text. What we
    want is a function that will first clear the field, if populated, and then type
    just as a user would – letter by letter followed by the *Tab* key to move out
    of the field.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可能正在向已经包含文本的字段中追加文本。我们想要的函数是首先清除字段（如果已填充），然后像用户一样逐字输入，之后按*Tab*键移出字段。
- en: This can be accomplished in our framework in two ways.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在我们的框架中以两种方式实现。
- en: First, we set the focus on the element and sending keystrokes through the `browser.keys()`
    method. Second, we send keys to the element directly with its `AddValue()` method.
    This would be a backup approach being slightly slower. Regardless of the tool
    used, sometimes an element just does not receive the text correctly when entered
    at a high typing speed. So, the `AddValue` approach would be a backup to ensure
    fields get populated accurately.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将焦点设置在元素上，并通过`browser.keys()`方法发送按键。其次，我们直接使用元素的`AddValue()`方法发送按键。这将是一个备选方案，速度稍慢。无论使用什么工具，有时在高速输入时，元素可能无法正确接收输入的文本。因此，`AddValue`方法将作为备选方案，以确保字段能够准确填充。
- en: 'Let’s begin with the first approach, using the `browser.keys` method to send
    text to the element, with a focus on speed. This is carried out by setting focus
    on the element with a click:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一种方法开始，使用`browser.keys`方法将文本发送到元素，并专注于速度。这是通过点击元素来设置焦点来实现的：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The element now has focus, and thanks to the highlight, we can see which element
    will take the input. We should check whether the field needs to be cleared.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 元素现在具有焦点，多亏了高亮显示，我们可以看到哪个元素将接收输入。我们应该检查该字段是否需要清除。
- en: Checking whether the field is pre-populated for speed
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查字段是否预填充以提高速度
- en: 'Next, we will clear the field if it has any pre-existing text. The basic way
    to do this is with the `clear()` method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果字段有任何预存文本，我们将清除该字段。执行此操作的基本方法是使用`clear()`方法：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'An alternative way to clear the field can also be done by issuing a `Meta-a`
    command to select all the text. The selected text is cleared by sending the backspace
    ASCII key code from the browser:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过发出`Meta-a`命令来选择所有文本来清除字段，从而提供另一种清除字段的方法。通过从浏览器发送回车ASCII键码来清除选定的文本：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we will type the text passed to the wrapper into the field from the browser:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把传递给包装器的文本输入到浏览器中的字段：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Faster is not always better. If you find the speed of WebdriverIO typing text
    is causing issues, you can control how quickly text is typed with this alternative
    code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更快并不总是更好。如果你发现WebdriverIO输入文本的速度导致问题，你可以使用以下替代代码来控制文本输入的速度：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the text is entered, the field can be activated by typing the *Tab* key:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入文本，可以通过按*Tab*键来激活字段：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'While the *Tab* key is universal to activate an element, sometimes the *Enter*
    key is needed instead:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*Tab*键可以用来激活元素，但有时需要使用*Enter*键：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, are we about to send our password to the console for everyone to see?
    It’s a bad day in the city when a supervillain is able to take the hero’s supercharged
    crime-fighting vehicle for a joyride. Let’s make that less likely to happen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们是不是要发送我们的密码到控制台，让每个人都能看到？当超级反派能够驾驶英雄的超能犯罪战斗车辆进行欢乐驾驶时，这就是城市里糟糕的一天。让我们让这种情况发生的可能性降低。
- en: Behind the mask – SetValuePassword() to keep data secure
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面具背后 – `SetValuePassword()`方法以保持数据安全
- en: 'Superheroes wear a mask to protect family and friends. In test automation,
    we need to protect our sensitive data such as passwords. In this method, we take
    the extra step to be sure our passwords are not displayed in the console and report
    output by replacing most of the string with asterisks (`Password" = "Pa****rd`).
    However, if the root cause of our issues is that a password expired, we might
    want to have a small clue. So, we need to mask just a part of our credentials:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 超级英雄戴面具是为了保护家人和朋友。在测试自动化中，我们需要保护我们的敏感数据，如密码。在这个方法中，我们采取额外步骤确保我们的密码不会显示在控制台和报告输出中，通过将大多数字符串替换为星号（`Password"
    = "Pa****rd"））。然而，如果我们的问题的根本原因是密码已过期，我们可能希望有一个小线索。因此，我们需要屏蔽我们的凭证的一部分：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is an example of the original password and the value returned:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是原始密码和返回值的示例：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Detecting and masking passwords in your output
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在输出中检测和屏蔽密码
- en: 'The next step is to detect a field that might be a password and then scrub
    the data that’s being passed to it. We’ll send the password to the field but output
    a scrubbed version of the data to our results. First, let’s get a scrubbed version
    of the text:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检测可能为密码的字段，然后清除传递给它的数据。我们将密码发送到字段，但将数据的一个清洗版本输出到我们的结果中。首先，让我们获取文本的清洗版本：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will get the field element name and check whether it includes the
    `ssword` string pattern. This makes it likely that we will scrub any field that
    has the `password` or `Password` string. This is provided by a custom `getFieldName()`
    helper method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将获取字段元素名称并检查它是否包含`ssword`字符串模式。这使我们很可能会清洗任何包含`password`或`Password`字符串的字段。这是由自定义的`getFieldName()`辅助方法提供的：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You might be wondering, why not create a generic method called `getElementName()`
    to return the name of any element? The reason is that the properties and prioritizations
    can be different, depending on whether we are seeking an input field, a button,
    a list, or other elements. This allows us to optimize the code execution based
    on the element type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，为什么不创建一个名为`getElementName()`的通用方法来返回任何元素的名称？原因是属性和优先级可能因我们是在寻找输入字段、按钮、列表或其他元素而有所不同。这使我们能够根据元素类型优化代码执行。
- en: Putting it all together
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容组合在一起
- en: 'Now that we’ve got all the custom-made parts, let’s put together our superpowered
    method. These methods will return a success value of `true` or `false`. We ensure
    that we have a valid element from the earlier chapter. We will replace tags such
    as the date with a future or past offset. We will detect whether the field is
    a password and mask our value output accordingly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有定制的部件，让我们组装我们的超级方法。这些方法将返回成功值`true`或`false`。我们确保我们有一个来自前面章节的有效元素。我们将用未来的或过去的偏移量替换日期等标签。我们将检测字段是否是密码，并相应地屏蔽我们的值输出：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following is an example of the masked credentials in our output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们输出中屏蔽凭证的示例：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are a lot of other features we could implement to customize the data input
    of our fields. We could use the same technique to inject SQL statements to always
    pull a valid order number for a search. Strings of random `Corporate Lorem Ipsum`
    filler words could be populated to check exact field length boundaries. Text with
    vulgar words could be tested to make sure they get flagged and notification emails
    are sent to test accounts. Take a few minutes to think about all the types of
    dynamic and special data that might be available to test against with an automated
    framework.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现许多其他功能来定制字段的输入数据。我们可以使用相同的技巧注入SQL语句，以确保始终检索有效的订单号进行搜索。可以填充随机的`Corporate
    Lorem Ipsum`填充词字符串来检查精确的字段长度边界。带有粗俗语言的文本可以用来测试它们是否会被标记，并发送通知电子邮件到测试账户。花几分钟时间思考一下所有可能通过自动化框架进行测试的动态和特殊数据类型。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added all sorts of custom-made gadgets to our `setValueAdv()`
    method. This method delivers a result indicating the success or failure of `true`
    or `false`. We conducted a background check to ensure that we had a valid element.
    Our approach involved wielding the power of time travel by replacing date-related
    tags with the present, future, or past date offset. We also kept security in mind
    and made sure to mask our output value when the field in question was a likely
    credential input.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向我们的`setValueAdv()`方法添加了各种定制的设备。此方法提供一个结果，指示成功或失败，值为`true`或`false`。我们进行了背景检查，以确保我们有一个有效的元素。我们的方法涉及使用时间旅行的力量，通过用现在、未来或过去的日期偏移量替换与日期相关的标签。我们还考虑了安全性，并确保在相关字段可能是凭证输入时屏蔽我们的输出值。
- en: Next, we will supercharge the `Select()` method with lists and comboboxes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用列表和组合框来超级增强`Select()`方法。
