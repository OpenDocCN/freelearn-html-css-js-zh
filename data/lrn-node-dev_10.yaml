- en: Testing the Node Applications – Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Node应用程序-第1部分
- en: In this chapter, we'll look at how we can test our code to make sure it's working
    as expected. Now, if you've ever set up test cases for other languages, then you
    know how hard it can be to get started. You have to set up the actual test infrastructure.
    Then you have to write your individual test cases. Every time I didn't test an
    application, it was because the setup process and the tools available to me were
    such a burden. Then you dig around for information online and you get really simple
    examples, but not examples for testing real-world things like asynchronous code.
    We'll be doing all of that in this chapter. I'll give you a very simple setup
    for testing and writing your test cases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下如何测试我们的代码，以确保它按预期工作。现在，如果您曾经为其他语言设置过测试用例，那么您就知道开始可能有多么困难。您必须设置实际的测试基础设施。然后您必须编写您的各个测试用例。每次我没有测试一个应用程序，都是因为设置过程和可用工具对我来说是如此繁重。然后您在网上搜索信息，您会得到一些非常简单的例子，但不是用于测试异步代码等真实世界事物的例子。我们将在本章中做所有这些。我将为您提供一个非常简单的测试设置和编写测试用例。
- en: We'll look at the best tools available so you'll actually be excited to write
    those test cases and see all of those green checkmarks. We'll be testing from
    here on out as well, so let's dive in looking at how we can test some code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会看一下最好的可用工具，这样你就会真正兴奋地编写这些测试用例，并看到所有那些绿色的勾号。从现在开始我们也会进行测试，所以让我们深入研究一下如何测试一些代码。
- en: Basic testing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本测试
- en: In this section, you'll create your very first test case so that you can test
    whether your code is working as expected. By adding automatic testing to our project,
    we'll be able to verify that a function does what it says it'll do. If we make
    a function that's supposed to add two numbers together, we can automatically verify
    it's doing that. And if we have a function that's supposed to fetch a user from
    the database, we can make sure it's doing that as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将创建您的第一个测试用例，以便测试您的代码是否按预期工作。通过将自动测试添加到我们的项目中，我们将能够验证函数是否按其所说的那样工作。如果我们创建一个应该将两个数字相加的函数，我们可以自动验证它是否正在执行这个操作。如果我们有一个应该从数据库中获取用户的函数，我们也可以确保它正在执行这个操作。
- en: Now to get started in this section, we'll look at the very basics of setting
    up a testing suite inside a Node.js project. We'll be testing a real-world function.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在本节中开始，我们将看一下在Node.js项目中设置测试套件的基础知识。我们将测试一个真实世界的函数。
- en: Installing the testing module
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装测试模块
- en: 'In order to get started, we will make a directory to store our code for this
    chapter. We''ll make one on the desktop using `mkdir` and we''ll call this directory
    `node-tests`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将创建一个目录来存储本章的代码。我们将在桌面上使用`mkdir`创建一个目录，并将其命名为`node-tests`：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we''ll change directory inside it using `cd`, so we can go ahead and run
    `npm init`. We''ll be installing modules and this will require a `package.json`
    file:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用`cd`更改其中的目录，这样我们就可以运行`npm init`。我们将安装模块，这将需要一个`package.json`文件：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](img/584340e3-28e2-4603-a985-6fa4ec7f1654.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/584340e3-28e2-4603-a985-6fa4ec7f1654.png)'
- en: 'We''ll run `npm init` using the default values for everything, simply hitting
    *enter* throughout every single step:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用默认值运行`npm init`，在每一步中只需简单地按下*enter*：
- en: '![](img/2276dd53-3b2e-41ad-ab4b-b70728616f3c.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2276dd53-3b2e-41ad-ab4b-b70728616f3c.png)'
- en: Now once that `package.json` file is generated, we can open up the directory
    inside Atom. It's on the desktop and it's called `node-tests`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一旦生成了`package.json`文件，我们就可以在Atom中打开该目录。它在桌面上，名为`node-tests`。
- en: From here, we're ready to actually define a function we want to test. The goal
    in this section is to learn how to set up testing for a Node project, so the actual
    functions we'll be testing are going to be pretty trivial, but it will help illustrate
    exactly how to set up our tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们准备实际定义我们想要测试的函数。本节的目标是学习如何为Node项目设置测试，因此我们将要测试的实际函数将会相当琐碎，但这将帮助说明如何设置我们的测试。
- en: Testing a Node project
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试一个Node项目
- en: 'To get started, let''s make a fake module. This module will have some functions
    and we''ll test those functions. In the root of the project, we''ll create a brand
    new directory and I''ll call this directory `utils`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始制作一个虚假模块。这个模块将有一些函数，我们将测试这些函数。在项目的根目录中，我们将创建一个全新的目录，我将把这个目录命名为`utils`：
- en: '![](img/91f6a6aa-0422-4de1-b593-62b42deb4787.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91f6a6aa-0422-4de1-b593-62b42deb4787.png)'
- en: 'We can assume this will store some utility functions, such as adding a number
    to another number, or stripping out whitespaces from a string, anything kind of
    hodge-podge that doesn''t really belong to any specific location. We''ll make
    a new file in the `utils` folder called `utils.js`, and this is a similar pattern
    to what we did when we created the `weather` and `location` directories in our
    weather app in the previous chapter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设这将存储一些实用函数，比如将一个数字加到另一个数字上，或者从字符串中去除空格，任何不属于任何特定位置的混杂物。我们将在`utils`文件夹中创建一个名为`utils.js`的新文件，这与我们在上一章中创建`weather`和`location`目录时所做的类似模式：
- en: '![](img/503f66d8-7558-4525-9aec-8c92b0a1bb99.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/503f66d8-7558-4525-9aec-8c92b0a1bb99.png)'
- en: You're probably wondering why we have a folder and a file with the same name.
    This will be clear when we start testing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么我们有一个同名的文件夹和文件。当我们开始测试时，这将变得清晰。
- en: 'Now before we can write our first test case to make sure something works, we
    need something to test. I''ll make a very basic function that takes two numbers
    and adds them together. We''ll create an adder function as shown in the following
    code block:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们可以编写我们的第一个测试用例来确保某些东西工作之前，我们需要有东西来测试。我将创建一个非常基本的函数，它接受两个数字并将它们相加。我们将创建一个如下所示的加法器函数：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This arrow function (`=>`) will take two arguments, `a` and `b`, and inside
    the function, we''ll return the value `a + b`. Nothing too complex here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个箭头函数(`=>`)将接受两个参数`a`和`b`，在函数内部，我们将返回值`a + b`。这里没有太复杂的东西：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now since we just have one expression inside our arrow function (`=>`) and
    we want to return it, we can actually use the arrow function (`=>`) expression
    syntax, which lets us add our expression as shown in the following code, `a +
    b`, and it''ll be implicitly returned:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们在箭头函数(`=>`)内只有一个表达式，并且我们想要返回它，我们实际上可以使用箭头函数(`=>`)表达式语法，这使我们可以添加我们的表达式，如下面的代码所示，`a
    + b`，它将被隐式返回：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's no need to explicitly add a `return` keyword on to the function. Now
    that we have `utils.js` ready to go, let's explore testing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数上不需要显式添加`return`关键字。现在我们已经准备好`utils.js`，让我们来探索测试。
- en: We'll be using a framework called Mocha in order to set up our test suite. This
    will let us configure our individual test cases and also run all of our test files.
    This will be really important for creating and running tests. The goal here is
    to make testing simple and we'll use Mocha to do just that. Now that we have a
    file and a function we actually want to test, let's explore how to create and
    run a test suite.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为Mocha的框架来设置我们的测试套件。这将让我们配置我们的单个测试用例，并运行所有的测试文件。这对于创建和运行测试非常重要。我们的目标是使测试变得简单，我们将使用Mocha来实现这一点。现在我们有了一个文件和一个我们真正想要测试的函数，让我们来探索如何创建和运行测试套件。
- en: Mocha – the testing framework
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mocha - 测试框架
- en: 'We''ll be doing the testing using the super popular testing framework Mocha,
    which you can find at [mochajs.org](https://mochajs.org/). This is a fantastic
    framework for creating and running test suites. It''s super popular and their
    page has all the information you''d ever want to know about setting it up, configuring
    it, and all the cool bells and whistles it has included:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用超级流行的测试框架Mocha进行测试，您可以在[mochajs.org](https://mochajs.org/)找到它。这是一个创建和运行测试套件的绝佳框架。它非常受欢迎，他们的页面上包含了有关设置、配置以及所有酷炫功能的所有信息：
- en: '![](img/8ef865ef-3a75-4f15-bce3-cc3dd95785f5.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ef865ef-3a75-4f15-bce3-cc3dd95785f5.png)'
- en: 'If you scroll down on this page, you''ll be able to see a table of contents:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此页面上滚动，您将能够看到目录：
- en: '![](img/fa505fff-2c7e-46bb-ad6e-43d622059cd7.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa505fff-2c7e-46bb-ad6e-43d622059cd7.png)'
- en: Here you can explore everything Mocha has to offer. We'll be covering most of
    it in this chapter, but for anything we don't cover, I do want to make you aware
    you can always learn about it on this page.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以探索Mocha提供的所有功能。我们将在本章中涵盖大部分内容，但对于我们未涵盖的任何内容，我希望您知道您可以在此页面上了解到。
- en: 'Now that we''ve explored the Mocha documentation page, let''s install it and
    start using it. Inside the Terminal, we''ll install Mocha. First up, let''s clear
    the Terminal output. Then we''ll install it using the `npm install` command. When
    you use `npm install`, you can also use the shortcut `npm i`. This has the exact
    same effect. I''ll use `npm i` with `mocha`, specifying the version `@3.0.0`.
    This is the most recent version of the library as of this filming:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了Mocha文档页面，让我们安装它并开始使用它。在终端中，我们将安装Mocha。首先，让我们清除终端输出。然后我们将使用`npm install`命令进行安装。当您使用`npm
    install`时，您也可以使用快捷方式`npm i`。这具有完全相同的效果。我将使用`npm i`与`mocha`，指定版本`@3.0.0`。这是拍摄时的最新版本：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we do want to save this into the `package.json` file. Previously, we've
    used the `save` flag, but we'll talk about a new flag, called `save-dev`. The
    `save-dev` flag is will save this package for development purposes only—and that's
    exactly what Mocha will be for. We don't actually need Mocha to run our app on
    a service like Heroku. We just need Mocha locally on our machine to test our code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们确实希望将其保存到`package.json`文件中。以前，我们使用了`save`标志，但我们将讨论一个新标志，称为`save-dev`。`save-dev`标志将仅为开发目的保存此软件包
    - 这正是Mocha的用途。我们实际上不需要Mocha在像Heroku这样的服务上运行我们的应用程序。我们只需要在本地机器上使用Mocha来测试我们的代码。 '
- en: 'When you use the `save-dev` flag, it installs the module much the same way:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`save-dev`标志时，它会以相同的方式安装模块：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/d3d4bba5-1689-45b2-a839-d163e8cd6131.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3d4bba5-1689-45b2-a839-d163e8cd6131.png)'
- en: 'But if you explore `package.json`, you''ll see things are a little different.
    Inside our `package.json` file, instead of a dependencies attribute, we have a
    `devDependencies` attribute:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您查看`package.json`，您会发现情况有所不同。在我们的`package.json`文件中，我们有一个`devDependencies`属性，而不是一个dependencies属性：
- en: '![](img/732a982a-a748-4705-9bad-ce655510abc2.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/732a982a-a748-4705-9bad-ce655510abc2.png)'
- en: In there we have Mocha, with the version number as the value. The `devDependencies`
    are fantastic because they're not going to be installed on Heroku, but they will
    be installed locally. This will keep the Heroku boot times really, really quick.
    It won't need to install modules that it's not going to actually need. We'll be
    installing both `devDependencies` and `dependencies` in most of our projects from
    here on out.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有Mocha，版本号作为值。`devDependencies`非常棒，因为它们不会安装在Heroku上，但它们将在本地安装。这将使Heroku的启动时间非常快。它不需要安装实际上不需要的模块。从现在开始，我们将在大多数项目中同时安装`devDependencies`和`dependencies`。
- en: Creating a test file for the add function
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为add函数创建一个测试文件
- en: 'Now that we have Mocha installed, we can go ahead and create a test file. In
    the `utils` folder, we''ll make a new file called `utils.test.js`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Mocha，我们可以继续创建一个测试文件。在`utils`文件夹中，我们将创建一个名为`utils.test.js`的新文件：
- en: '![](img/a48c09b3-f218-4fb9-925f-47c9b04e15bb.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a48c09b3-f218-4fb9-925f-47c9b04e15bb.png)'
- en: This file will store our test cases. We'll not store our test cases in `utils.js`.
    This will be our application code. Instead, we'll make a file called `utils.test.js`.
    When we use this `test.js` extension, we're basically telling our app that this
    will store our test cases. When Mocha goes through our app looking for tests to
    run, it should run any file with this extension.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件将存储我们的测试用例。我们不会将测试用例存储在`utils.js`中。这将是我们的应用程序代码。相反，我们将创建一个名为`utils.test.js`的文件。当我们使用这个`test.js`扩展名时，我们基本上告诉我们的应用程序，这将存储我们的测试用例。当Mocha在我们的应用程序中寻找要运行的测试时，它应该运行任何具有此扩展名的文件。
- en: 'Now we have a test file, the only thing left to do is create a test case. A
    test case is a function that runs some code, and if things go well, great, the
    test is considered to have passed. And if things do not go well, the test is considered
    to have failed. We can create a new test case, using `it`. It is a function provided
    by Mocha. We''ll be running our project test files through Mocha, so there''s
    no reason to import it or do anything like that. We simply call it just like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个测试文件，唯一剩下的事情就是创建一个测试用例。测试用例是运行一些代码的函数，如果一切顺利，测试被认为是通过的。如果事情不顺利，测试被认为是失败的。我们可以使用`it`创建一个新的测试用例。这是Mocha提供的一个函数。我们将通过Mocha运行我们的项目测试文件，所以没有理由导入它或做任何类似的事情。我们只需要像这样调用它：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now it lets us define a new test case and it takes two arguments. These are:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它让我们定义一个新的测试用例，并且它需要两个参数。这些是：
- en: The first argument is a string
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个字符串
- en: The second argument is a function
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个函数
- en: 'First up, we''ll have a string description of what exactly the test is doing.
    If we''re testing that the adder function works, we might have something like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将有一个关于测试具体做什么的字符串描述。如果我们正在测试加法函数是否有效，我们可能会有类似以下的内容：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice here that it plays into the sentence. It should read like this, `it should
    add two numbers`; describes exactly what the test will verify. This is called
    **behavior-driven development**, or **BDD**, and that's the principles that Mocha
    was built on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里与句子相符。它应该读起来像这样，`it should add two numbers`；准确描述了测试将验证的内容。这被称为**行为驱动开发**，或**BDD**，这是Mocha构建的原则。
- en: 'Now that we''ve set up the test string, the next thing to do is add a function
    as the second argument:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了测试字符串，下一步是将一个函数添加为第二个参数：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Inside this function, we''ll add the code that tests that the add function
    works as expected. This means it will probably call `add` and check that the value
    that comes back is the appropriate value given the two numbers passed in. That
    means we do need to import the `util.js` file up at the top. We''ll create a constant,
    call `utils`, setting it equal to the return result from requiring utils. We''re
    using `./` since we will be requiring a local file. It''s in the same directory
    so I can simply type `utils` without the `js` extension as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们将添加测试add函数是否按预期工作的代码。这意味着它可能会调用`add`并检查返回的值是否是给定的两个数字的适当值。这意味着我们确实需要在顶部导入`util.js`文件。我们将创建一个常量，称为`utils`，将其设置为从`utils`中获取的返回结果。我们使用`./`，因为我们将要求一个本地文件。它在同一个目录中，所以我可以简单地输入`utils`而不需要`js`扩展名，如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have the utils library loaded in, inside the callback we can call
    it. Let''s make a variable to store the return results. We''ll call this one results.
    And we''ll set it equal to `utils.add` passing in two numbers. Let''s use something
    like `33` and `11`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了utils库，在回调函数内部我们可以调用它。让我们创建一个变量来存储返回的结果。我们将称之为results。然后我们将它设置为`utils.add`，传入两个数字。让我们使用类似`33`和`11`的数字：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We would expect it to get `44` back. Now at this point, we do have some code
    inside of our test suites so we run it. We'll do that by configuring that test
    script we looked at in the previous chapter inside a `package.json`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望得到`44`。现在在这一点上，我们的测试套件内确实有一些代码，所以我们运行它。我们将通过在`package.json`中配置我们在上一章中看到的测试脚本来实现这一点。
- en: 'Currently, the test script simply prints a message to the screen saying that
    no tests exist. What we''ll do instead is call Mocha. As shown in the following
    code, we''ll be calling Mocha, passing in as the one and only argument the actual
    files we want to test. We can use a globbing pattern to specify multiple files.
    In this case, we''ll be using `**` to look in every single directory. We''re looking
    for a file called `utils.test.js`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，测试脚本只是简单地在屏幕上打印一条消息，说没有测试存在。我们要做的是调用Mocha。如下面的代码所示，我们将调用Mocha，将我们想要测试的实际文件作为唯一的参数传递进去。我们可以使用通配符模式来指定多个文件。在这种情况下，我们将使用`**`来查找每个目录中的文件。我们正在寻找一个名为`utils.test.js`的文件：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now this is a very specific pattern. It''s not going to be particularly useful.
    Instead, we can swap out the file name with a star as well. Now we''re looking
    for any file on the project that has a file name ending in `.test.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个非常具体的模式。这不会特别有用。相反，我们也可以用星号替换文件名。现在我们正在寻找项目中以`.test.js`结尾的任何文件：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And this is exactly what we want. From here, we can run our test suite by saving
    `package.json` and moving to the Terminal. We''ll use the `clear` command to clear
    the Terminal output and then we can run our `test` script using command shown
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的。从这里，我们可以通过保存`package.json`并转到终端来运行我们的测试套件。我们将使用`clear`命令来清除终端输出，然后我们可以运行我们的`test`脚本，使用如下所示的命令：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we run this, we''ll execute that Mocha command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们将执行那个Mocha命令：
- en: '![](img/a3119576-d86c-4ad2-834f-c55d42ee1617.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3119576-d86c-4ad2-834f-c55d42ee1617.png)'
- en: It'll go off. It'll fetch all of our test files. It'll run all of them and print
    the results on the screen inside Terminal as shown in the preceding screenshot.
    Here we can see we have a green checkmark next to our test, `should add two numbers`.
    Next, we have a little summary, one passing test, and it happened in 8 milliseconds.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它会触发。它将获取我们所有的测试文件。它将运行所有这些文件，并在终端内打印结果，就像前面的截图中显示的那样。在这里，我们可以看到我们的测试旁边有一个绿色的勾号，`should
    add two numbers`。接下来，我们有一个小结，一个通过的测试，在8毫秒内完成。
- en: 'Now in our case, we don''t actually assert anything about the number that comes
    back. It could be 700 and we wouldn''t care. The test will always pass. To make
    a test fail what we have to do is throw an error. That means we can throw a new
    error and we pass into the constructor function whatever message we want to use
    as the error as shown in the following code block. In this case, I could say something
    like `Value not correct`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的情况下，我们实际上并没有断言关于返回的数字的任何内容。它可以是700，我们也不在乎。测试将始终通过。要使测试失败，我们需要抛出一个错误。这意味着我们可以抛出一个新的错误，并将我们想要用作错误的消息传递给构造函数，如下面的代码块所示。在这种情况下，我可以说类似`值不正确`的内容：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now with this in place, I can save the test file and rerun things from the
    Terminal by rerunning `npm test`, and when we do that now we have 0 tests passing
    and we have 1 test failing:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这个，我可以保存测试文件，并从终端重新运行测试，通过重新运行`npm test`，现在我们有0个通过的测试和1个失败的测试：
- en: '![](img/6e79b1dd-204b-4b42-8ef9-cd2f4eedebf7.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e79b1dd-204b-4b42-8ef9-cd2f4eedebf7.png)'
- en: Next we can see the one test is should add two numbers, and we get our error
    message, Value not correct. When we throw a new error, the test fails and that's
    exactly what we want to do for add.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到一个测试是应该添加两个数字，我们得到了我们的错误消息，值不正确。当我们抛出一个新的错误时，测试失败了，这正是我们想要为`add`做的。
- en: Creating the if condition for the test
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试创建if条件
- en: 'Now, we''ll create an `if` statement for the test. If the response value is
    not equal to `44`, that means we have a problem on our hands and we''ll throw
    an error:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为测试创建一个`if`语句。如果响应值不等于`44`，那意味着我们有麻烦了，我们将抛出一个错误：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside the `if` condition, we can throw a new error and we''ll use a template
    string as our message string because I do want to use the value that comes back
    in the error message. I''ll say `Expected 44, but got`, then I''ll inject the
    actual value, whatever happens to come back:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`条件内部，我们可以抛出一个新的错误，我们将使用模板字符串作为我们的消息字符串，因为我确实想要在错误消息中使用返回的值。我会说`Expected
    44, but got`，然后我会注入实际的值，无论发生什么：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now in our case, everything will line up great. But what if the `add` method
    wasn''t working correctly? Let''s simulate this by simply tacking on another addition,
    adding on something like `22` in `utils.js`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的情况下，一切都会很顺利。但是如果`add`方法没有正确工作会怎么样呢？让我们通过简单地添加另一个加法来模拟这种情况，在`utils.js`中添加上类似`22`的东西：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I''ll save the file, rerun the test suite:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我会保存文件，重新运行测试套件：
- en: '![](img/fc218425-26d3-4080-b0c2-449f70e511e4.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc218425-26d3-4080-b0c2-449f70e511e4.png)'
- en: 'Now we get an error message: Expected 44, but got 66\. This error message is
    fantastic. It lets us know that something is going wrong with the test and it
    even tells us exactly what we got back and what we expected. This will let us
    go into the `add` function, look for errors, and hopefully fix them.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了一个错误消息：期望得到44，但得到了66。这个错误消息很棒。它让我们知道测试出了问题，甚至告诉我们确切得到了什么，以及我们期望得到了什么。这将让我们进入`add`函数，寻找错误，并希望修复它们。
- en: Creating test cases doesn't need to be something super complex. In this case,
    we have a simple test case that tests a simple function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建测试用例不需要非常复杂。在这种情况下，我们有一个简单的测试用例，测试一个简单的函数。
- en: Testing the squaring a number function
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试平方函数
- en: 'Now, we''ll create a new function that squares a number and returns the result.
    We''ll define that in the `utils.js` file using `module.exports.square`. We''ll
    set that equal to an arrow function (`=>`) that takes in one number, `x`, and
    we''ll return `x` times `x`, `x * x`, just like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个新的函数，它对一个数字进行平方并返回结果。我们将在`utils.js`文件中定义，使用`module.exports.square`。我们将把它设置为一个箭头函数(`=>`)，它接受一个数字`x`，然后我们返回`x`乘以`x`，`x
    * x`，就像这样：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we have this brand new function square and we''ll create a new test case
    that makes sure `square` works as expected. In `utils.test.js`, next to the `if`
    condition for `add` function, we''ll call the `it` function again:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个全新的`square`函数，我们将创建一个新的测试用例，确保`square`按预期工作。在`utils.test.js`中，在`add`函数的`if`条件旁边，我们将再次调用`it`函数：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside the `it` function, we''ll add our two arguments, the string, and the
    callback function. Inside the string, we''ll create our message, `should square
    a number`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`it`函数内部，我们将添加我们的两个参数，字符串和回调函数。在字符串内部，我们将创建我们的消息，`should square a number`：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And inside the callback function, we can actually go ahead and call `square`.
    Now we do want to create a variable to store the result so we can check that the
    result is what we expect it to be. Then we can call `utils.square` passing in
    a number. I''ll go with `3` in this case, which means I should expect 9 to come
    back:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数内部，我们实际上可以继续调用`square`。现在我们确实想要创建一个变量来存储结果，以便我们可以检查结果是否符合预期。然后我们可以调用`utils.square`传入一个数字。在这种情况下，我会选择`3`，这意味着我应该期望返回`9`：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the next line, we can have an `if` statement, if the result does not equal
    `9`, then we''ll throw a message because things went wrong:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们可以有一个`if`语句，如果结果不等于`9`，那么我们会抛出一个消息，因为事情出错了：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can throw an error using `throw new Error`, passing in whatever message
    we like. We can use a regular string, but I always prefer using a template string
    so we can inject values easily. I''ll say something like `Expected 9, but got`,
    followed by the value that''s not correct; in this case, that''s stored in the
    response variable:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`throw new Error`抛出错误，传入任何我们喜欢的消息。我们可以使用普通字符串，但我总是更喜欢使用模板字符串，这样我们可以轻松地注入值。我会说类似于`Expected
    9, but got`，后面跟着不正确的值；在这种情况下，这个值存储在响应变量中：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now I can save this test case and run the test suite from the Terminal. Using
    the up arrow key and the *enter* key, we can rerun the last command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以保存这个测试用例，并从终端运行测试套件。使用上箭头键和*enter*键，我们可以重新运行上一个命令：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](img/f9f81971-f62f-4d66-b24b-28de4fbf9eef.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9f81971-f62f-4d66-b24b-28de4fbf9eef.png)'
- en: We get two tests passing, should add two numbers and should square a number
    both have checkmarks next to them. And we ran both tests in just 14 milliseconds,
    which is fantastic.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了两个通过的测试，应该添加两个数字和应该对一个数字进行平方都有对号。而且我们只用了14毫秒运行了两个测试，这太棒了。
- en: 'Now the next thing, we want to do is mess up the `square` function to make
    sure our test fails when the number is not correct. I''ll add `1` on to the result
    in `utils.js`, which will cause the test to fail:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一件事，我们想要做的是搞砸`square`函数，以确保当数字不正确时我们的测试失败。我会在`utils.js`中的结果上加`1`，这将导致测试失败：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then we can rerun things from the Terminal and we should see the error message:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以从终端重新运行测试，我们应该会看到错误消息：
- en: '![](img/d97536cd-561d-4137-87b2-e23a7c65b50a.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d97536cd-561d-4137-87b2-e23a7c65b50a.png)'
- en: We get Expected 9, but got 10\. This is fantastic. We now have a test suite
    capable of testing both the `add` function and the `square` function. I'll remove
    that `+ 1`, and we are done.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了预期的9，但得到了10。这太棒了。我们现在有一个能够测试`add`函数和`square`函数的测试套件。我将删除那个`+ 1`，然后我们就完成了。
- en: We now have a very, very basic test suite that we can execute with Mocha. Currently,
    we have two tests and to create those tests we used the `it` method provided by
    Mocha. In the upcoming sections, we'll be exploring more methods that Mocha gives
    us and we'll also be looking at better ways to do our assertions. Instead of manually
    creating them, we'll be using an assertion library to help with the heavy lifting.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个非常非常基本的测试套件，我们可以使用Mocha执行。目前，我们有两个测试，并且为了创建这些测试，我们使用了Mocha提供的`it`方法。在接下来的部分中，我们将探索Mocha给我们的更多方法，并且我们还将寻找更好的方法来进行断言。我们将使用一个断言库来帮助完成繁重的工作，而不是手动创建它们。
- en: Autorestarting the tests
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动重新启动测试
- en: 'Before we write more test cases, let''s see an automatic way to rerun our test
    suite when we change either our test code or our application code. We''ll be doing
    that with `nodemon`. Now, previously we used `nodemon` like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写更多测试用例之前，让我们看一种自动重新运行测试套件的方法，当我们更改测试代码或应用程序代码时。我们将使用`nodemon`来实现这一点。现在，我们之前是这样使用`nodemon`的：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We would type `nodemon` and we would pass in a file like `app.js`. Whenever
    any code in our app changed, it would rerun the `app.js` file as a Node application.
    What we can actually do is specify any command in the world we want to run when
    our files change. This means we can rerun `npm test` when the files change.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输入`nodemon`，然后传入一个文件，如`app.js`。每当我们应用程序中的任何代码更改时，它将重新运行`app.js`文件作为Node应用程序。实际上，我们可以指定我们想要在文件更改时运行的世界上的任何命令。这意味着我们可以在文件更改时重新运行`npm
    test`。
- en: 'To do this, we''ll use the `exec` flag. This flag tells `nodemon` that we''ll
    specify a command to run, and it might not necessarily be a Node file. As shown
    in the following command, we can specify that command. It''ll be `''npm test''`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用`exec`标志。此标志告诉`nodemon`我们将指定要运行的命令，它可能不一定是一个Node文件。如下命令所示，我们可以指定该命令。它将是`'npm
    test'`：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you are using Windows, remember to use double quotes in place of single quotes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Windows，请记住使用双引号代替单引号。
- en: 'With this in place, we can now run the `nodemon` command. It''ll kick off for
    the first time running our test suite:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`nodemon`命令。它将首次运行我们的测试套件：
- en: '![](img/52e75c77-16e7-4be1-bc90-2ce1e09df52b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52e75c77-16e7-4be1-bc90-2ce1e09df52b.png)'
- en: 'Here we see we have two tests passing. Let''s go ahead into the app `utils.js`
    and make a change to one of the functions, so it fails. We''ll add `3` or `4`
    onto the result for `add`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到有两个测试通过。让我们继续进入应用程序`utils.js`，并对其中一个函数进行更改，以便它失败。我们将为`add`的结果添加`3`或`4`：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It automatically restarts over here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它会自动重新启动：
- en: '![](img/81443c9b-d50d-4ae9-a1ed-25ef54e1b1df.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81443c9b-d50d-4ae9-a1ed-25ef54e1b1df.png)'
- en: And now we see that we have a test suite where one test passes and one tests
    fails. I can always go ahead and undo that error we added, save the file, and
    the test suite will automatically rerun.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到我们有一个测试套件，其中一个测试通过，一个测试失败。我可以随时撤消我们添加的错误，保存文件，测试套件将自动重新运行。
- en: This will make testing your application that much easier. You won't have to
    switch to the Terminal and rerun the `npm test` command every time we make a change
    to our application. Now we have a command that we can run, we'll shut down `nodemon`
    and use the up arrow key to show it again.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使测试应用程序变得更加容易。每当我们对应用程序进行更改时，我们就不必切换到终端并重新运行`npm test`命令。现在我们有一个可以运行的命令，我们将关闭`nodemon`并使用上箭头键再次显示它。
- en: And we can actually move this into a script inside of `package.json`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以将其移入`package.json`中的一个脚本。
- en: 'Inside `package.json` we''ll make a new script right after the test script.
    Now we''ve used the `start` script and the `test` script—these are built-in—we''ll
    create a custom one called `test-watch`, and we can run the `test-watch` script
    to kick things off. Inside of `test-watch`, we''ll have the exact same command
    we ran from Terminal. That means we''ll be rounding `nodemon`. We''ll be using
    the `exec` flag and inside of quotes, we''ll be running `npm test`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中，我们将在测试脚本之后创建一个新的脚本。现在我们已经使用了`start`脚本和`test`脚本-这些是内置的-我们将创建一个名为`test-watch`的自定义脚本，并且我们可以运行`test-watch`脚本来启动。在`test-watch`中，我们将使用与终端中运行的完全相同的命令。这意味着我们将会使用`nodemon`。我们将使用`exec`标志，并在引号内运行`npm
    test`：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we have this in place, we can run the script from the Terminal as opposed
    to having to type out this command every single time we want to start up the autotest
    suite.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这个，我们可以从终端运行脚本，而不是每次启动自动测试套件时都要输入这个命令。
- en: 'The script we have inside `package.json` currently will work on macOS and Linux.
    It''ll also work on Heroku, which uses Linux. But it will not work on Windows.
    The following script will:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前在`package.json`中拥有的脚本将在macOS和Linux上运行。它也将在使用Linux的Heroku上运行。但它在Windows上不起作用。以下脚本将起作用：
- en: '`"test-watch": "nodemon --exec \"npm test\""`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`"test-watch": "nodemon --exec \"npm test\""`.'
- en: As you can see here, we're escaping the quotes surrounding `npm test` and we're
    using double quotes, which as we know are the only quotes supported by Windows.
    This script will remove any errors you're seeing, something like npm cannot be
    found, which you will get if you wrap `npm tests` in single quotes and run the
    script on Windows. So use the above script for cross-OS compatibility.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在转义围绕`npm test`的引号，并且我们正在使用双引号，正如我们所知，这是Windows支持的唯一引号。此脚本将消除您看到的任何错误，例如找不到npm，如果您将`npm
    tests`用单引号括起来并在Windows上运行脚本时会出现。因此，请使用上述脚本以实现跨操作系统的兼容性。
- en: 'To run a script with a custom name, such as `test-watch`, in the Terminal all
    we need to do is run `npm run` followed by the script name, `test-watch`, as shown
    in the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要在终端中运行具有自定义名称的脚本，例如`test-watch`，我们只需要运行`npm run`，然后是脚本名称`test-watch`，如下命令所示：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If I do this, it will start things off. We''ll get our test suite and it''s
    still waiting for changes, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我这样做，它会启动。我们将得到我们的测试套件，它仍在等待变化，如下所示：
- en: '![](img/9abb5b25-aa06-48bc-b910-8b07bcfd103c.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9abb5b25-aa06-48bc-b910-8b07bcfd103c.png)'
- en: Now, every time you start the test suite you can simply use `npm run test-watch`.
    That'll start up the `test-watch` script, which starts up `nodemon`. Every time
    a change happens in your project, it'll rerun `npm test`, showing the results
    of the test suite to the screen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你启动测试套件，你可以简单地使用`npm run test-watch`。这将启动`test-watch`脚本，它会启动`nodemon`。每当你的项目发生变化，它都会重新运行`npm
    test`，并将测试套件的结果显示在屏幕上。
- en: Now that we have a way to automatically restart our test suite, let's go ahead
    and get back into the specifics of testing in Node.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种自动重新启动测试套件的方法，让我们继续深入了解在Node中进行测试的具体内容。
- en: Using assertion libraries in testing Node modules
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试Node模块中使用断言库
- en: 'In the previous sections, we made two test cases to verify that `utils.add`
    and our `utils.square` method work as expected. We did that using an `if` condition,
    that is, if the value was not `44` that means something went wrong and we threw
    an error. In this section, we''ll learn how to use an assertion library, which
    will take care of all of the `if` condition in `utils.test.js` code for us:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们制作了两个测试用例来验证`utils.add`和我们的`utils.square`方法是否按预期工作。我们使用了一个`if`条件来做到这一点，也就是说，如果值不是`44`，那就意味着出了问题，我们就会抛出一个错误。在本节中，我们将学习如何使用一个断言库，它将为我们处理`utils.test.js`代码中的所有`if`条件：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Because when we add more and more tests, the code will end up looking pretty
    similar and there's no reason to keep rewriting it. Assertion libraries let us
    make assertions about values, whether it's about their type, the value itself,
    whether an array contains an element, all sorts of things like that. They really
    are fantastic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当我们添加越来越多的测试时，代码最终会变得非常相似，没有理由一直重写它。断言库让我们可以对值进行断言，无论是关于它们的类型，值本身，还是数组是否包含元素，诸如此类的各种事情。它们真的很棒。
- en: 'The one we''ll be using is called expect. You can find it by going to Google
    and googling `mjackson expect`. And this is the result we''re looking for:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的是expect。你可以通过谷歌搜索`mjackson expect`来找到它。这就是我们要找的结果：
- en: '![](img/db8fec07-660e-4fe8-aaed-8f51c493f29c.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db8fec07-660e-4fe8-aaed-8f51c493f29c.png)'
- en: 'It''s mjackson''s repository, expect. It is a fantastic and super popular assertion
    library. This library will let us pass in a value and make some assertions about
    it. On this page, we scroll down past the introduction and the installation we
    can get down to an example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是mjackson的存储库，expect。这是一个很棒而且非常受欢迎的断言库。这个库让我们可以传递一个值并对其进行一些断言。在这个页面上，我们可以在介绍和安装之后滚动到一个例子：
- en: '![](img/728344df-44fe-4c2e-b48f-77d20eaf4672.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/728344df-44fe-4c2e-b48f-77d20eaf4672.png)'
- en: 'As shown in the preceding screenshot, we have our Assertions header and we
    have our first assertion, `toExist`. This will verify that a value exists. In
    the next line, we have an example, we pass in a string to `expect`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们有我们的断言标题和我们的第一个断言，`toExist`。这将验证一个值是否存在。在下一行，我们有一个例子，我们将一个字符串传递给`expect`：
- en: '![](img/5fb080fa-90b3-4c74-856d-41b77619b2cd.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fb080fa-90b3-4c74-856d-41b77619b2cd.png)'
- en: 'This is the value we want to make some assertions about. In the context of
    our application, that would be the response variable in the `utils.test.js`, shown
    here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要对其进行一些断言的值。在我们的应用程序上下文中，这将是`utils.test.js`中的响应变量，如下所示：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We want to assert that it is equal to `44`. After we call `expect`, we can
    start chaining on some assertion calls. In the assertion example, next we check
    if it does exist:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要断言它是否等于`44`。在我们调用`expect`之后，我们可以开始链接一些断言调用。在下一个断言示例中，我们检查它是否存在：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This would not throw an error because a string is indeed truthy inside JavaScript.
    If we passed in something like `undefined`, which is not `truthy`, `toExist` would
    fail. It would throw an error and the test case would not pass. Using these assertions,
    we can make it really, really easy to check the values in our tests without having
    to write all of that code ourselves.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会抛出错误，因为在JavaScript中，字符串确实是真值。如果我们传入一些不是`真值`的东西，比如`undefined`，`toExist`会失败。它会抛出一个错误，测试用例不会通过。使用这些断言，我们可以非常轻松地检查测试中的值，而不必自己编写所有的代码。
- en: Exploring assertion libraries
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索断言库
- en: 'Let''s go ahead and start exploring the assertion libraries. First up, let''s
    install the module inside the Terminal by running `npm install`. The module name
    itself is called expect and we''ll grab the most recent version, `@1.20.2`. Once
    again, we''ll be using the `save-dev` flag like we did with Mocha. Because we
    do indeed want to save this dependency in `package.json`, but it''s a `dev` dependency,
    it''s not required for the application to run whether it''s on Heroku or some
    other service:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续开始探索断言库。首先，让我们在终端中运行`npm install`来安装模块。模块名本身叫做expect，我们将获取最新版本`@1.20.2`。我们将再次使用`save-dev`标志，就像我们在Mocha中所做的那样。因为我们确实希望将这个依赖保存在`package.json`中，但它是一个`dev`依赖，不管是在Heroku还是其他服务上运行，都不是必需的：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `expect` library has been donated to a different organization. The latest
    version, which is v21.1.0 is not compatible with the backward version we are using
    here that is 1.20.2. What I like you to do is install the 1.20.2 version in the
    section that will make sure, you'll use in next several sections.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect`库已经捐赠给了另一个组织。最新版本是v21.1.0，与我们在这里使用的旧版本1.20.2不兼容。我希望你安装1.20.2版本，以确保在接下来的几节中使用。'
- en: Let's go ahead and install this dependency.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续安装这个依赖。
- en: '![](img/b511a1be-49e1-48ed-a0f9-3a2124c7d558.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b511a1be-49e1-48ed-a0f9-3a2124c7d558.png)'
- en: 'Then we can move to the application, and check out the `package.json` file,
    as shown in the following screenshot, it looks great:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以转到应用程序，查看`package.json`文件，如下截图所示，看起来很棒：
- en: '![](img/d77c03b2-9944-4f4e-a3cd-313fb6fcf88c.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d77c03b2-9944-4f4e-a3cd-313fb6fcf88c.png)'
- en: 'We have both expect and Mocha. Now, inside our `utils.test` file, we can kick
    things off by loading in the library and making our first assertions using expect.
    Up at the very top of the file, we''ll load in the library, creating a constant
    called `expect` and `require(''expect'')`, just like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们既有expect，又有Mocha。现在，在我们的`utils.test`文件中，我们可以通过加载库并使用expect进行第一次断言来启动。在文件的顶部，我们将加载库，创建一个名为`expect`的常量，并`require('expect')`，就像这样：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can get started by swapping out the `if` condition in the `utils.test.js`
    code with a call to `expect` instead:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用`expect`来替换`utils.test.js`代码中的`if`条件：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you saw in the example on assertion/expect page, we''ll start all our assertions
    by calling `expect` as a function passing in the value we want to make assertions
    about. In this case, that is the `res` variable:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在断言/expect页面上的示例中看到的，我们将通过调用`expect`作为一个函数来开始所有的断言，传入我们想要进行断言的值。在这种情况下，那就是`res`变量：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we can assert all sorts of things. In this case, we want to assert that
    the value is equal to `44`. We''ll make our assertion `toBe`. On the documentation
    page, it looks like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以断言各种事情。在这种情况下，我们想要断言该值等于`44`。我们将使用我们的断言`toBe`。在文档页面上，它看起来是这样的：
- en: '![](img/07986522-41a9-488c-a795-be6e3f87be25.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07986522-41a9-488c-a795-be6e3f87be25.png)'
- en: 'This asserts that a value equals another value and that''s exactly what we
    want. We assert that our value passed into expect equals another value using `toBe`,
    passing that value in as the first argument. Back inside Atom, we can go ahead
    and use this assertion, `.toBe`, and we''re expecting the result variable to be
    the number `44`, just like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这断言一个值等于另一个值，这正是我们想要的。我们断言传入expect的值等于另一个值，使用`toBe`，将该值作为第一个参数传入。回到Atom中，我们可以使用这个断言`.toBe`，我们期望结果变量是数字`44`，就像这样：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we have our test case and it should work exactly as it did with the `if`
    condition.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的测试用例，它应该与`if`条件一样正常工作。
- en: 'To prove it does work, let''s move into the Terminal and use the `clear` command
    to clear the Terminal output. Now we can run that `test-watch` script as shown
    in the following command line:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明它确实有效，让我们进入终端并使用`clear`命令来清除终端输出。现在我们可以运行`test-watch`脚本，如下命令所示：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![](img/e72bdf9c-5f95-4901-8a10-3a4233c84b58.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e72bdf9c-5f95-4901-8a10-3a4233c84b58.png)'
- en: 'As shown in the preceding code output, we get our two tests passing just like
    they did before. Now we were to change `44` to some other value that would throw
    an error like `40`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码输出所示，我们的两个测试都通过了，就像以前一样。现在，如果我们将`44`更改为像`40`这样的其他值，那么会抛出错误：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We save the file, and we''ll get an error and the `expect` library will generate
    useful error messages for us:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存文件，然后会得到一个错误，`expect`库将为我们生成有用的错误消息：
- en: '![](img/06d5d04c-a118-49b5-9667-36c1cba16ae3.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06d5d04c-a118-49b5-9667-36c1cba16ae3.png)'
- en: It's saying that we Expected 44 to be 40\. Clearly that's not the case, so an
    error gets thrown. I'll change this back to `44`, save the file, and all of our
    tests will pass.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它说我们预期44是40。显然这不是这样，所以会抛出一个错误。我将把它改回`44`，保存文件，所有的测试都会通过。
- en: Chaining multiple assertions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接多个断言
- en: 'Now we can also chain together multiple assertions. For example, we could assert
    that the value that comes back from `add` is a number. This can be done using
    another assertion. So let''s head into the docs and take a look. Inside Chrome,
    we''ll scroll down through the assertion docs list. There are a lot of methods.
    We''ll be exploring some of them. In this case, we''re looking for `toBeA`, the
    method that takes a string:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也可以链接多个断言。例如，我们可以断言从`add`返回的值是一个数字。这可以使用另一个断言来完成。所以让我们进入文档看一看。在Chrome中，我们将浏览断言文档列表。有很多方法。我们将探索其中一些。在这种情况下，我们正在寻找`toBeA`，这个方法接受一个字符串：
- en: '![](img/72f449b0-2275-49a4-b133-aeb0a0b2aa54.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72f449b0-2275-49a4-b133-aeb0a0b2aa54.png)'
- en: 'This takes the string type and it uses the `typeof` operator to assert that
    the value is of a certain type. Here we''re expecting `2` to be a number. We can
    do that exact same thing over in our code. Inside Atom, right after `toBe`, we
    can chain on another call, `toBeA`, followed by the type. This could be something
    like a string, it could be something like an object, or in our case, it could
    be a number, just like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用字符串类型，并使用`typeof`运算符来断言该值是某种类型。在这里，我们期望`2`是一个数字。我们可以在我们的代码中做完全相同的事情。在Atom中，在`toBe`之后，我们可以链接另一个调用`toBeA`，然后是类型。这可能是字符串，也可能是对象，或者在我们的情况下，可能是一个数字，就像这样：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We''ll open up the Terminal so we can see the results. It''s currently hidden.
    Save the file. Our tests will rerun and we can see they''re both passing:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打开终端，这样我们就可以看到结果。它目前是隐藏的。保存文件。我们的测试将重新运行，我们可以看到它们都通过了：
- en: '![](img/9c4f3131-3392-4529-b3f5-08f8ae8a8513.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c4f3131-3392-4529-b3f5-08f8ae8a8513.png)'
- en: 'Let''s use a different type, something that was going to cause the test to
    fail for example string:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个不同的类型，例如会导致测试失败的字符串：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We would then get an error message, Expected 44 to be a string:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会得到一个错误消息，预期44是一个字符串：
- en: '![](img/148b632f-b576-400e-86d7-7674d0c50863.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/148b632f-b576-400e-86d7-7674d0c50863.png)'
- en: This is really useful. It'll help us clean up our errors really quickly. Let's
    change the code back to number and we are good to go.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很有用。它将帮助我们快速清理错误。让我们把代码改回数字，然后就可以开始了。
- en: Multiple assertions for the square function
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于square函数的多个断言
- en: 'Now we''d like to do the same thing for our tests for square a number function.
    We''ll use `expect` to assert that the response is indeed the number `9` and that
    the type is a number. We''ll use these same two assertions we do with the `add`
    function. First, we need to do to delete the current square `if` condition code,
    since we will not be using that anymore. As shown in the following code, we''ll
    make some expectations about the `res` variable. We''ll expect it to be the number
    `9`, just like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想为我们的平方数函数的测试做同样的事情。我们将使用`expect`来断言响应确实是数字`9`，并且类型是一个数字。我们将使用与`add`函数相同的这两个断言。首先，我们需要删除当前的平方`if`条件代码，因为我们将不再使用它。如下所示，我们将对`res`变量做一些期望。我们期望它是数字`9`，就像这样：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll save the file and make sure the test passes, and it does indeed pass:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保存文件并确保测试通过，它确实通过了：
- en: '![](img/7b487bf1-d06d-434b-a50b-8f9c765b1ac0.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b487bf1-d06d-434b-a50b-8f9c765b1ac0.png)'
- en: 'Now, we''ll assert the type using `toBeA`. Here, we''re checking that the type
    of the return value from the `square` method is a number:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`toBeA`来断言类型。在这里，我们正在检查`square`方法的返回值类型是否为数字：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we save the file, we get both of our tests still passing, which is fantastic:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存文件时，我们仍然通过了我们的两个测试，这太棒了：
- en: '![](img/7b72f471-5ee4-4ee0-bf06-c9a76ac72b6c.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b72f471-5ee4-4ee0-bf06-c9a76ac72b6c.png)'
- en: Now this is just a small test as to what `expect` can do. Let's create a bogus
    test case that will explore a few more ways we can use `expect`. We'll not be
    testing an actual function. We'll just play around with some assertions inside
    of the it callback.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这只是一个关于`expect`能做什么的小测试。让我们创建一个虚假测试用例，探索一些我们可以使用`expect`的更多方式。我们将不会测试一个实际的函数。我们只是在`it`回调内部玩一些断言。
- en: Exploring usage of expect with bogus test
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索使用expect进行虚假测试
- en: 'To create the bogus test, we''ll make a new test using the `it` callback function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建虚假测试，我们将使用`it`回调函数创建一个新的测试：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can put whatever we want in here, it''s not too important. And we''ll pass
    in an arrow function (`=>`) as our callback function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里放任何我们想要的东西，这并不太重要。我们将传入一个箭头函数(`=>`)作为我们的回调函数：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now as we''ve seen already, one of the most fundamental assertions you''ll
    make is you''re just going to check for equality. We want to check if something
    like the response variable equals something else, like the number `44`. Inside
    `expect`, we can also do the opposite. We can expect that a value like `12` does
    not equal, using `toNotBe`. And then we can assert that it doesn''t equal some
    other value, like `11`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正如我们已经看到的，你将做的最基本的断言之一就是检查是否相等。我们想要检查类似响应变量是否等于其他东西，比如数字`44`。在`expect`内部，我们也可以做相反的事情。我们可以期望一个值像`12`不等于，使用`toNotBe`。然后我们可以断言它不等于其他值，比如`11`：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The two aren''t equal, so when we save the file over in the Terminal, all three
    tests should be passing:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 两者不相等，所以当我们在终端中保存文件时，所有三个测试都应该通过：
- en: '![](img/870d8673-50d1-4c10-8a66-f07723443dc4.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/870d8673-50d1-4c10-8a66-f07723443dc4.png)'
- en: 'If I set that equal to the same value, it''ll not work as expected:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将其设置为相同的值，它将无法按预期工作：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We''ll get an error, Expected 12 to not be 12:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到一个错误，预期12不等于12：
- en: '![](img/9cc4d4d4-50a6-40ce-9c22-8e3c5e3abf73.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cc4d4d4-50a6-40ce-9c22-8e3c5e3abf73.png)'
- en: Now `toBe` and `toNotBe` work great for numbers, strings, and Booleans, but
    if you're trying to compare arrays or objects, they will not work as expected
    and we can prove this.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`toBe`和`toNotBe`对于数字、字符串和布尔值效果很好，但是如果你试图比较数组或对象，它们将无法按预期工作，我们可以证明这一点。
- en: Using toBe and toNotBe to compare array/objects
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用toBe和toNotBe比较数组/对象
- en: 'We''ll start with removing the current code by commenting it out. We''ll leave
    it around so we use it later:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从注释掉当前代码开始。我们将保留它，以便稍后使用：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''ll `expect` an object with the `name` property set to `Andrew`, `toBe`,
    and we''ll assert that it is another object where the name property is equal to
    `Andrew`, just like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`expect`一个具有`name`属性设置为`Andrew`的对象，`toBe`，并且我们将断言它是另一个具有name属性等于`Andrew`的对象，就像这样：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ll use `toBe`, just like we did with `number`, checking if it is the same
    as another object where name equals `Andrew`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`toBe`，就像我们用`number`一样，检查它是否与另一个name等于`Andrew`的对象相同：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now when we save this, you might think the test will pass, but it doesn''t:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们保存这个文件时，你可能会认为测试会通过，但它并没有：
- en: '![](img/57f7879d-4325-48a3-8fb6-66d5fce52a11.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57f7879d-4325-48a3-8fb6-66d5fce52a11.png)'
- en: As shown in the preceding output, we see that we expected the two names to be
    equal. When objects are compared for equality using the triple equals, which is
    what `toBe` uses, they'll not be the same because it's trying to see if they're
    the exact same object, and they're not. We've created two separate objects with
    the same properties.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，我们看到我们期望这两个名称相等。当使用三重等号进行对象比较时，也就是`toBe`使用的方式，它们不会相同，因为它试图看它们是否是完全相同的对象，而它们不是。我们创建了两个具有相同属性的单独对象。
- en: Using the toEqual and toNotEqual assertions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用toEqual和toNotEqual断言
- en: 'To check if the two names are equal, we''ll have to use something different.
    It''s called `toEqual` as shown here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查这两个名称是否相等，我们将不得不使用不同的东西。它被称为`toEqual`，如下所示：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we save the file now, this will work. It''ll rip into the object properties,
    making sure they have the same ones:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在保存文件，这将起作用。它将深入对象属性，确保它们具有相同的属性：
- en: '![](img/d0b3cc75-0879-4062-9987-aef09129e358.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0b3cc75-0879-4062-9987-aef09129e358.png)'
- en: 'The same thing goes for `toNotEqual`. This checks if two objects are not equal.
    To check this, we''ll go ahead and change the first object to have a lowercase
    a in `andrew`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`toNotEqual`也是一样的。这检查两个对象是否不相等。为了检查这一点，我们将继续并将第一个对象更改为`andrew`中的小写a：'
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, the test passes. They are not equal:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试通过了。它们不相等：
- en: '![](img/51524f8b-6f39-41df-a287-bae020478cf9.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51524f8b-6f39-41df-a287-bae020478cf9.png)'
- en: This is how we do equality with our objects and arrays. Now another really useful
    thing we have is `toInclude`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何对我们的对象和数组进行相等性比较的方式。现在我们还有一个非常有用的东西，那就是`toInclude`。
- en: Using toInclude and toExclude
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用toInclude和toExclude
- en: The `toInclude` assertion checks if an array or an object includes some things.
    Now if it's an array, we can check if it includes a certain item in the array.
    If it's an object, we can check if it includes certain properties. Let's run through
    an example of that.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`toInclude`断言检查数组或对象是否包含一些东西。如果是数组，我们可以检查数组中是否包含某个项目。如果是对象，我们可以检查对象是否包含某些属性。让我们通过一个例子来运行一下。'
- en: 'We''ll `expect` that an array with the numbers `2`, `3`, and `4` inside the
    `it` callback has the number `5` inside and we can do that using `toInclude`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在`it`回调中有一个包含数字`2`、`3`和`4`的数组包含数字`5`，我们可以使用`toInclude`来做到这一点：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `toInclude` assertion takes the item. In this case, we''ll check if the
    array has `5` inside. Now clearly it doesn''t, so this test will fail:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`toInclude`断言接受项目。在这种情况下，我们将检查数组中是否包含`5`。现在显然它没有，所以这个测试将失败：'
- en: '![](img/be047123-f90a-43e9-9bfd-353d07cf9a68.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be047123-f90a-43e9-9bfd-353d07cf9a68.png)'
- en: 'We get the message, Expected [ 2, 3, 4] to include 5\. That does not exist.
    Now we change this to a number that does exist, for example `2`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到消息，期望[ 2, 3, 4]包括5。那不存在。现在我们把这个改成一个存在的数字，比如`2`：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We''ll rerun the test suite and everything will work as expected:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新运行测试套件，一切都将按预期工作：
- en: '![](img/7a4a5f75-7093-4d79-ae04-57d0e31a12fb.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a4a5f75-7093-4d79-ae04-57d0e31a12fb.png)'
- en: 'Now, along with `toInclude`, we have `toExclude` like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除了`toInclude`，我们还有`toExclude`，就像这样：
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will check if something does not exist, for example the number `1`, which
    is not in the array. If we run this assertion, the test passes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检查某些东西是否不存在，例如数字`1`，它不在数组中。如果我们运行这个断言，测试通过：
- en: '![](img/76187806-132d-4519-9569-5e31fe3216ed.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76187806-132d-4519-9569-5e31fe3216ed.png)'
- en: 'The same two methods, `toInclude` and `toExclude`, work with objects as well.
    We can play with that right on the next line. I''ll `expect` that the following
    object has something on it:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的两种方法，`toInclude`和`toExclude`，也适用于对象。我们可以在下一行直接使用。我期望以下对象有一些东西：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s go ahead and create an object that has a few properties. These are:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个具有一些属性的对象。这些是：
- en: '`name`: We''ll set it equal to any name, let''s say `Andrew`.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：我们将把它设置为任何名字，比如`Andrew`。'
- en: '`age`: We''ll set that equal to age, say `25`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age`：我们将把它设置为年龄，比如`25`。'
- en: '`location`: We''ll set that equal to any location, for example `Philadelphia`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`：我们将把它设置为任何位置，例如`Philadelphia`。'
- en: 'This will look like the following code block:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将看起来像以下的代码块：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now let''s say we want to make some assertions about particular properties,
    not necessarily the entire object. We can use `toInclude` to assert that the object
    has some properties and that those property values equals the value we pass in:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想对特定属性做一些断言，而不一定是整个对象。我们可以使用`toInclude`来断言对象是否具有某些属性，并且这些属性的值等于我们传入的值：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For example, the `age` property. Let''s say we only care about the age. We
    can assert that the object has an `age` property equal to `25` by typing the following
    code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`age`属性。假设我们只关心年龄。我们可以断言对象具有一个等于`25`的`age`属性，方法是输入以下代码：
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It doesn''t matter that there''s a `name` property. The `name` property could
    be any value. That is irrelevant in this assertion. Now let''s use the value,
    `23`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`属性无关紧要。`name`属性可以是任何值。这在这个断言中是无关紧要的。现在让我们使用值`23`：'
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This test will fail as shown here since the value is not correct:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于值不正确，这个测试将失败：
- en: '![](img/eb2f5516-e01c-49e7-9ffd-db74c5328603.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb2f5516-e01c-49e7-9ffd-db74c5328603.png)'
- en: We expected the `age` property to be `23`, but it was indeed `25`, so the test
    fails. The same thing goes with the `toExclude` assertion.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望`age`属性是`23`，但实际上是`25`，所以测试失败。`toExclude`断言也是一样的。
- en: 'Here we can save our test files. This checks if the object does not have a
    property age equal to `23`. It does indeed not have that, so the test passes:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以保存我们的测试文件。这检查对象是否没有一个等于`23`的属性age。它确实没有，所以测试通过：
- en: '![](img/917b02e0-062b-4e65-bb6b-338229c4ec58.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/917b02e0-062b-4e65-bb6b-338229c4ec58.png)'
- en: This is just a quick taste as to what expect can do. For a full list of features,
    I recommend diving through the documentation. There's a ton of other assertions
    you can use, things like checking if a number is greater than another number,
    if a number is less than or equal to another number, all sorts of math-related
    operations are included as well.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对expect能做什么的一个快速了解。关于功能的完整列表，我建议浏览文档。还有很多其他断言可以使用，比如检查一个数字是否大于另一个数字，一个数字是否小于或等于另一个数字，还包括各种与数学相关的操作。
- en: Testing the setName method
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试setName方法
- en: 'Now let''s wrap up this section with some more testing. Over in `utils.js`,
    we can make a new function, one that we''ll be testing, `module.exports.setName`.
    The `setName` function is will take two arguments. It''ll take a `user` object,
    some fictitious user object with some generic properties, and it''ll take `fullName`
    as a string:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一些更多的测试来结束这一节。在`utils.js`中，我们可以创建一个新的函数，一个我们将要测试的函数，`module.exports.setName`。`setName`函数将接受两个参数。它将接受一个`user`对象，一个具有一些通用属性的虚构用户对象，它将接受一个字符串`fullName`：
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The job of `setName` will be to rip apart `fullName` into two parts—the first
    name and the last name—by splitting it on the space. We'll set the two properties,
    first name and last name, and return the `user` object. We'll fill out the function
    then we'll write the test case.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`setName`的工作将是将`fullName`分成两部分——名字和姓氏——通过在空格上分割它。我们将设置两个属性，名字和姓氏，并返回`user`对象。我们将填写函数，然后编写测试用例。'
- en: 'The first thing we''ll do is split the name into a `names` array, `var names`
    will be that array:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将名字分割成一个`names`数组，`var names`将是那个数组：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'It''ll have two values, assuming there''s only one space inside of the name.
    We''re assuming someone types their first name, hits a space, and types their
    last name. We''ll set this equal to `fullName.split` and we''ll split on the space.
    So I''ll pass in an empty string with a space inside it as the value to split:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 它将有两个值，假设名称中只有一个空格。我们假设有人输入他们的名字，敲击空格，然后输入他们的姓氏。我们将把这个设置为`fullName.split`，然后我们将在空格上分割。所以我将传入一个包含空格的空字符串作为分割的值：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now we have a `names` array where the first item is the `firstName` and the
    last item is the `lastName`. So we can start updating the `user` object. `user.firstName`
    will equal the first item in the `names` array and we''ll grab the index of `0`,
    which is the first item. We''ll do something similar for last name, `user.lastName`
    equals the second item from the `names` array:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`names`数组，其中第一项是`firstName`，最后一项是`lastName`。所以我们可以开始更新`user`对象。`user.firstName`将等于`names`数组中的第一项，我们将获取索引`0`，这是第一项。我们将对`lastName`做类似的操作，`user.lastName`等于`names`数组的第二项：
- en: '[PRE66]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now we''re all done, we have the names set, and we can return the `user` object
    `using return` user, just like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了，我们已经设置了名称，并且我们可以返回`user`对象，就像这样使用`return` user：
- en: '[PRE67]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inside the `utils.test` file, we can now kick things off. First, we''ll comment
    out our `it(''should expect some values'')` handler:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils.test`文件中，我们现在可以开始。首先，我们将注释掉我们的`it('should expect some values')`处理程序：
- en: '[PRE68]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is pretty great for documentation. You can always explore it later if you
    forget how things work. We'll create a new test that should verify first and last
    names are set.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于文档来说非常棒。如果您忘记了事情是如何工作的，您随时可以稍后探索它。我们将创建一个新的测试，应该验证名字和姓氏是否已设置。
- en: We'll create a `user` object. On that `user` object, we want to set some properties
    such as `age` and `location`. Then we'll pass the variable `user` into the `setName`
    method. That'll be the first argument defined in the `utils.js` file. We'll pass
    in a string. The string with `firstName` followed by a space followed by `lastName`.
    Then we'll get the result back and we'll make some assertions about it. We want
    to assert the returning object includes using the `toInclude` assertion.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`user`对象。在该`user`对象上，我们想设置一些属性，如`age`和`location`。然后我们将变量`user`传递给`setName`方法。这将是`utils.js`文件中定义的第一个参数。我们将传入一个字符串。这个字符串是`firstName`后面跟着一个空格，然后是`lastName`。然后我们将得到结果，并对其进行一些断言。我们想要断言返回的对象是否包含使用`toInclude`断言。
- en: 'As shown in the following code, we''ll call it to make the new test case. We''ll
    be testing:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的代码，我们将调用它来创建新的测试用例。我们将测试：
- en: '[PRE69]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Inside `it`, we can now provide our second argument, which will be our callback
    function. Let''s set that to an arrow function (`=>`) and now we can make the
    `user` object:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在`it`中，我们现在可以提供我们的第二个参数，这将是我们的回调函数。让我们将其设置为箭头函数(`=>`)，现在我们可以创建`user`对象：
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `user` object will have a few properties. Let''s add something like `location`,
    setting that equal to `Philadelphia`, and then set an `age` property, setting
    that equal to `25`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`user`对象将有一些属性。让我们添加一些像`location`的东西，将其设置为`Philadelphia`，然后设置一个`age`属性，将其设置为`25`：'
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now we''ll call the method we defined over in `utils.js`, the `setName` method.
    We''ll do that on the next line, creating a variable called `res` to store the
    response. Then we''ll set that equal to `utils.setName` passing in the two arguments,
    the `user` object and `fullName`, `Andrew Mead`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将调用我们在`utils.js`中定义的方法，即`setName`方法。我们将在下一行执行这个操作，创建一个名为`res`的变量来存储响应。然后我们将把它设置为`utils.setName`，传入两个参数，即`user`对象和`fullName`，`Andrew
    Mead`：
- en: '[PRE72]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now at this point, the result should be what we expect. We should have the `firstName`
    and `lastName` properties. We should have the `location` property and the `age`
    property.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这一点上，结果应该是我们期望的。我们应该有`firstName`和`lastName`属性。我们应该有`location`属性和`age`属性。
- en: 'Now if you know a lot about JavaScript, you might know that objects are passed
    by reference, so the `user` variable has actually been updated as well. That is
    expected. Both `user` and `res` will have the exact same value. We can actually
    go ahead and prove that using an assertion. We''ll `expect` that `user` equals
    using `toEqual` the `res`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您对JavaScript了解很多，您可能知道对象是按引用传递的，因此`user`变量实际上也已经更新了。这是预期的。`user`和`res`将具有完全相同的值。我们实际上可以继续使用断言来证明这一点。我们将`expect`
    `user`等于`res`使用`toEqual`：
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Inside Terminal, we can see the test does indeed pass:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们可以看到测试确实通过了：
- en: '![](img/40134642-c54b-48fa-b144-c17a57ca1977.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40134642-c54b-48fa-b144-c17a57ca1977.png)'
- en: 'Let''s delete `expect(user).toEqual(res);`. Now, we want check if the `user`
    object or the `res` object includes certain properties. We''ll check using `expect`
    that the `res` variable has some properties using `toInclude`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除`expect(user).toEqual(res);`。现在，我们想要检查`user`对象或`res`对象是否包含某些属性。我们将使用`expect`来检查`res`变量是否具有某些属性，使用`toInclude`：
- en: '[PRE74]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The properties we''re looking for are `firstName` equal to what we would expect
    that to be, `Andrew`, and `lastName` equal to `Mead`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查找的属性是`firstName`等于我们期望的值，即`Andrew`，以及`lastName`等于`Mead`：
- en: '[PRE75]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'These are the assertions that should be made in order to verify that `setName`
    is working as expected. If I save the file, the `test` suite reruns and we do
    indeed get the passing tests as shown here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是应该进行的断言，以验证`setName`是否按预期工作。如果我保存文件，`test`套件将重新运行，我们确实得到了通过的测试，如下所示：
- en: '![](img/da39513e-fd35-4ed0-a94a-7bc08925cbb0.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da39513e-fd35-4ed0-a94a-7bc08925cbb0.png)'
- en: We have three of them and it took just 10 milliseconds to run.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个，只用了10毫秒来运行。
- en: And with this in place, we now have an assertion library for our `test` suite.
    That's fantastic because writing test cases just got way easier, and the whole
    goal of the chapter is to make testing approachable and easy.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在为我们的`test`套件创建了一个断言库。这太棒了，因为编写测试用例变得更加容易，整个章节的目标是使测试变得易于接近和简单。
- en: In the next section, we'll start looking at how we can test more complex asynchronous
    functions.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始看如何测试更复杂的异步函数。
- en: The asynchronous testing
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步测试
- en: In this section, you'll learn how to test asynchronous functions. The process
    of testing asynchronous functions isn't that different from synchronous ones,
    like what we've done already, but it is a little different so it justifies its
    own section.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将学习如何测试异步函数。测试异步函数的过程与测试同步函数并没有太大不同，就像我们已经做过的那样，但是有一点不同，所以它有自己的部分。
- en: Creating the asyncAdd function using the setTimeout object
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用setTimeout对象创建asyncAdd函数
- en: 'To kick things off, we''ll make a fake `async` function using `setTimeout`
    to simulate a delay inside `utils.js`. Just below where we make our `add` function,
    let''s make one called `asyncAdd`. It''ll essentially have the same features,
    but it''ll use `setTimeout` and it''ll have a callback to simulate a delay. Now
    in the real world, this delay might be a database request or an HTTP request.
    We''ll be dealing with that in the following chapters. For now though, let''s
    add `module.exports.asyncAdd`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`setTimeout`创建一个虚拟的`async`函数，以模拟`utils.js`中的延迟。就在我们创建`add`函数的下面，让我们创建一个叫做`asyncAdd`的函数。它基本上具有相同的特性，但它将使用`setTimeout`，并且它将有一个回调来模拟延迟。现在在现实世界中，这种延迟可能是数据库请求或HTTP请求。我们将在接下来的章节中处理这个问题。不过，现在让我们添加`module.exports.asyncAdd`：
- en: '[PRE76]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This will take three arguments, as opposed to the two the `add` function took,
    `a`, `b`, and `callback`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要三个参数，而不是`add`函数所需的两个参数，`a`，`b`和`callback`：
- en: '[PRE77]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This is what''s going to make the function asynchronous. Eventually, once the
    `setTimeout` is up, we''ll call the callback with the sum, whether it''s one plus
    three being four, or five plus nine being fourteen. Next up, we can put the arrow
    in arrow function (`=>`) and open and close our curly braces:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使函数异步的原因。最终，一旦`setTimeout`结束，我们将调用回调函数并传递总和，无论是1加3得到4，还是5加9得到14。接下来，我们可以在箭头函数（`=>`）中放置箭头并打开和关闭大括号：
- en: '[PRE78]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Inside the arrow function (`=>`), as mentioned, we''ll be using `setTimeout`
    to create the delay. We''ll pass in a callback and we''ll pass in our `setTimeout`.
    Let''s go with 1 second in this case:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，在箭头函数（`=>`）中，我们将使用`setTimeout`来创建延迟。我们将传递一个回调和我们的`setTimeout`。在这种情况下，我们将使用1秒：
- en: '[PRE79]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, by default, if our tests take longer than 2 seconds, Mocha will assume
    that is not what we wanted and it''ll fail. That''s why we''re using 1 second
    in this case. Inside our callback, we can call the actual `callback` argument
    with the sum `a + b`, just like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果我们的测试时间超过2秒，Mocha将认为这不是我们想要的，它将失败。这就是为什么我们在这种情况下使用1秒的原因。在我们的回调中，我们可以调用实际的`callback`参数，使用和`b`的和`a`，就像这样：
- en: '[PRE80]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We now have an `asyncAdd` function and we can start writing a test for it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`asyncAdd`函数，我们可以开始为它编写测试了。
- en: Writing the test for the asyncAdd function
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为asyncAdd函数编写测试
- en: 'Inside of the `utils.test` file, just under our previous test for `utils.add`,
    we''ll add a new one for `asyncAdd`. The test setup will look really similar.
    We will be calling `it` and passing in a string as the first argument and a callback
    as the second argument. Then we''ll add our callback, just like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils.test`文件中，就在我们之前对`utils.add`的测试下面，我们将为`asyncAdd`添加一个新的测试。测试设置看起来非常相似。我们将调用`it`并传递一个字符串作为第一个参数，传递一个回调作为第二个参数。然后我们将添加我们的回调，就像这样：
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Inside the callback, we can get started calling `utils.asyncAdd`. We''ll call
    it using `utils.asyncAdd` and we''ll pass in those three arguments. We''ll use
    `4` and `3`, which should result in `7`. And we''ll provide the callback function,
    which should get called with that value, the value being `7`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中，我们可以开始调用`utils.asyncAdd`。我们将使用`utils.asyncAdd`调用它，并传入这三个参数。我们将使用`4`和`3`，这应该得到`7`。我们将提供回调函数，它应该被调用并传递该值，该值为`7`：
- en: '[PRE82]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Inside the callback arguments, we would expect something like `sum` to come
    back:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调参数中，我们期望像`sum`这样的东西返回：
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Making assertion for the asyncAdd function
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对asyncAdd函数进行断言
- en: 'Now we can start making some assertions about that `sum` variable using the
    `expect` object. We can pass it into `expect` to make our assertions, and these
    assertions aren''t going to be new. It''s stuff we''ve already done. We''ll `expect`
    that the `sum` variable equals, using `toBe`, the number `7`. Then we''ll check
    that it''s a number, using `toBeA`, inside quotes, `number`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始对`sum`变量进行一些断言，使用`expect`对象。我们可以将它传递给`expect`来进行我们的断言，这些断言并不是新的。这是我们已经做过的事情。我们将`expect`
    `sum`变量等于数字`7`，使用`toBe`，然后我们将检查它是否是一个数字，使用`toBeA`，在引号内，`number`：
- en: '[PRE84]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now obviously if it is equal to `7` that means it is a number, but we're using
    both just to simulate exactly how chaining will work inside of our expect calls.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果它等于`7`，那就意味着它是一个数字，但我们两者都使用只是为了模拟我们的期望调用内部链式调用的工作原理。
- en: 'Now that we have our assertions in place, let''s save the file and run our
    test and see what happens. We''ll run it from Terminal, `npm run test-watch` to
    start up our `nodemon` watching script:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的断言已经就位，让我们保存文件并运行测试，看看会发生什么。我们将从终端运行它，`npm run test-watch`来启动我们的`nodemon`监视脚本：
- en: '[PRE85]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now our tests will run and the test does indeed pass:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试将运行，测试确实通过了：
- en: '![](img/7a5061b7-3cbd-41cd-9253-c2c8d0a81782.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a5061b7-3cbd-41cd-9253-c2c8d0a81782.png)'
- en: 'The only problem is that it''s passing for the wrong reasons. If we change
    `7` to `10` and save the file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是它通过了错误的原因。如果我们将`7`更改为`10`并保存文件：
- en: '[PRE86]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In this case, the test is still going to pass. Right here, you see we have
    four tests passing:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，测试仍然会通过。在这里，您可以看到我们有四个测试通过：
- en: '![](img/5ef4f4cd-2e72-43a1-aaa9-b21931ccd1d3.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ef4f4cd-2e72-43a1-aaa9-b21931ccd1d3.png)'
- en: Adding the done argument
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加done参数
- en: Now the reason this test is passing is not because the assertion in `utils.test.js`
    is valid. It's passing because we have an asynchronous action that takes 1 second.
    This function will return before the `async` callback gets fired. When I say function
    returning, I'm referring to the `callback` function, the second argument to `it`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个测试通过的原因不是因为`utils.test.js`中的断言是有效的。它通过是因为我们有一个需要1秒的异步操作。这个函数将在`async`回调被触发之前返回。当我说函数返回时，我指的是`callback`函数，即`it`的第二个参数。
- en: 'This is when Mocha thinks your test is done. This means that these assertions
    never run. The Mocha output has already said our test passes before this callback
    ever gets fired. What we need to do is tell Mocha this will be an asynchronous
    test that''ll take time. To do this, all we do is we provide an argument inside
    the callback function we pass to it. We''ll call this one `done`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Mocha认为你的测试已经完成的时候。这意味着这些断言永远不会运行。Mocha输出已经说我们的测试通过了，然后才会触发这个回调。我们需要做的是告诉Mocha这将是一个需要时间的异步测试。为了做到这一点，我们只需在传递给它的回调函数内提供一个参数。我们将称之为`done`：
- en: '[PRE87]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'When we have the `done` argument specified, Mocha knows that means we have
    an asynchronous test and it''ll not finish processing this test until `done` gets
    called. This means we can call `done` after our assertions:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们指定了`done`参数时，Mocha知道这意味着我们有一个异步测试，并且它不会完成处理此测试，直到调用`done`。这意味着我们可以在断言之后调用`done`：
- en: '[PRE88]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: With this in place, our test will now run. The function will return right after
    it calls `async.Add`, but that's OK because we have `done` specified. About a
    second later, our callback function will fire. Inside the `asyncAdd` callback
    function, we'll make our assertions. This time the assertions will matter because
    we have `done` and we haven't called it yet. After the assertions we call done,
    this tells Mocha that we're all done with the test. It can go ahead and process
    the result, letting us know whether it passed or failed. This will fix that error.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的测试现在将运行。函数在调用`async.Add`后将立即返回，但这没关系，因为我们已经指定了`done`。大约一秒钟后，我们的回调函数将触发。在`asyncAdd`回调函数内部，我们将进行断言。这次断言将很重要，因为我们有`done`，而且我们还没有调用它。在断言之后，我们调用done，这告诉Mocha我们已经完成了测试。它可以继续处理结果，让我们知道它是通过还是失败。这将修复那个错误。
- en: 'If I save the file in this state, it''ll rerun the tests and we''ll see that
    our test should `async.Add` two numbers will indeed fail. Inside Terminal, let''s
    open up the error message, we have Expected 7 to be 10:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我保存文件在这个状态下，它将重新运行测试，我们将看到我们的测试应该`async.Add`两个数字确实失败。在终端中，让我们打开错误消息，我们预期的是7是10：
- en: '![](img/858b39b4-9141-4f4f-85d0-db38d9be3d0d.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/858b39b4-9141-4f4f-85d0-db38d9be3d0d.png)'
- en: This is exactly what we thought would happen the first time around when we didn't
    use `done`, but as we can see, we do need to use `done` when we're doing something
    asynchronous inside of our tests.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们第一次没有使用`done`时认为会发生的情况，但正如我们所看到的，当我们在测试中进行异步操作时，我们确实需要使用`done`。
- en: 'Now we can change this expectation back to `7`, save the file:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将这个期望改回`7`，保存文件：
- en: '[PRE89]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This time around things should work as expected after 1 second delay as it
    runs this test:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次事情应该按预期工作，1秒延迟后运行此测试：
- en: '![](img/752973ad-70d3-4cf5-a5ea-d9694f49feeb.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/752973ad-70d3-4cf5-a5ea-d9694f49feeb.png)'
- en: It can't report right away because it has to wait for done to get called. Notice
    that our total test time is now about a second. We can see that we have four tests
    passing. Mocha also warns us when a test takes a long time because it assumes
    that's not expected. Nothing inside Node, even a database or HTTP request, should
    take even close to a second, so it's essentially letting us know that there's
    probably an error somewhere inside of your function—it's taking a really, really
    long time to process. In our case though, the one second delay was clearly set
    up inside of `utils` so there's no need to worry about that warning.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 它不能立即报告，因为它必须等待done被调用。请注意，我们的总测试时间现在大约是一秒。我们可以看到我们有四个测试通过。Mocha还在测试花费很长时间时警告我们，因为它认为这是不正常的。即使是Node中的任何东西，甚至是数据库或HTTP请求，也不应该花费接近一秒的时间，所以它基本上是在告诉我们，你的函数中可能有错误——它花费了非常非常长的时间来处理。但在我们的情况下，一秒的延迟显然是在`utils`中清楚地设置的，所以不需要担心那个警告。
- en: With this in place, we now have a test for our very first asynchronous method.
    All we had to do is add a `done` as an argument and call it once we were done
    making our assertions.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有了我们的第一个异步方法的测试。我们所要做的就是添加一个`done`作为参数，并在完成断言后调用它。
- en: The asynchronous testing for the square function
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`square`函数的异步测试'
- en: Now let's create an asynchronous version of the `square` method as we did with
    the synchronous one. In order to get started, we'll define the function first
    and then we'll worry about writing that test.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`square`方法的异步版本，就像我们用同步方法一样。为了开始，我们将首先定义函数，然后我们将担心编写测试。
- en: Creating the async square function
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建异步平方函数
- en: 'Inside the `utils` file, we can get started next to the `square` method creating
    a new one called `asyncSquare`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils`文件中，我们可以在`square`方法旁边开始创建一个名为`asyncSquare`的新方法：
- en: '[PRE90]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'It''ll take two arguments: the original argument which we called `x`, and the
    `callback` function that''ll get called after our 1-second delay:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 它将需要两个参数：我们称之为`x`的原始参数，以及在1秒延迟后将被调用的`callback`函数：
- en: '[PRE91]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Then we can finish up the arrow function (`=>`) and we can start working on
    the body of `asyncSquare`. It''ll look pretty similar to the `asyncAdd` one. We''ll
    call `setTimeout` passing in a callback and a delay. In this case, the delay will
    be the same; we''ll go with 1 second:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以完成箭头函数(`=>`)，然后开始编写`asyncSquare`的主体。它看起来与`asyncAdd`很相似。我们将调用`setTimeout`传递一个回调和一个延迟。在这种情况下，延迟将是相同的；我们将使用1秒：
- en: '[PRE92]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now we can actually call the callback. This will trigger the `callback` function
    that got passed in and we''ll pass in the value `x` times `x`, which will properly
    square the number passed in place of `x`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实际调用回调。这将触发传入的`callback`函数，并且我们将传入值`x`乘以`x`，这将正确地平方替代`x`的数字：
- en: '[PRE93]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Writing test for asyncSquare
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写`asyncSquare`的测试
- en: 'Now inside the `test` file, things are indeed passing, but we haven''t added
    a test for the `asyncSquare` function so let''s do that. Inside the `utils.test`
    file, the next thing you needed to do was call `it`. Next to `it` for testing
    the `asyncAdd` function, let''s call `it` to make a new test for this `asyncSquare`
    function:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`test`文件中，事情确实通过了，但我们还没有为`asyncSquare`函数添加测试，所以让我们这样做。在`utils.test`文件中，您需要做的下一件事是调用`it`。在测试`asyncAdd`函数旁边，让我们调用`it`来为这个`asyncSquare`函数创建一个新的测试：
- en: '[PRE94]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Next up, we''ll provide the callback function that''ll get called when the
    test actually executes. And since we are testing an `async` function, we''ll put
    `done` in the callback function as shown here:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提供回调函数，当测试实际执行时将调用该函数。由于我们正在测试一个`async`函数，我们将在回调函数中放置`done`，如下所示：
- en: '[PRE95]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This will tell Mocha to wait until `done` is called to decide whether or not
    the test passed. Next, we can now call `utils.asyncSquare` passing in a number
    of our choice. We''ll use `5`. Next up, we can pass in a callback:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Mocha等到调用`done`后才决定测试是否通过。接下来，我们现在可以调用`utils.asyncSquare`，传入我们选择的一个数字。我们将使用`5`。接下来，我们可以传入一个回调函数：
- en: '[PRE96]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This will get the final result. In the arrow function (`=>`), we''ll create
    a variable to store that result:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到最终结果。在箭头函数（`=>`）中，我们将创建一个变量来存储该结果：
- en: '[PRE97]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Now that we have this in place, we can start making our assertions.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个，我们可以开始进行断言。
- en: Making assertions for the asyncSquare function
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`asyncSquare`函数进行断言
- en: 'The assertions will be done using the `expect` library. We''ll make some assertions
    about the `res` variable. We''ll assert that it equals, using `toBe`, the number
    `25`, which is `5` times `5`. We''ll also use `toBeA` to assert something about
    the type of the value:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 断言将使用`expect`库完成。我们将对`res`变量进行一些断言。我们将使用`toBe`断言它等于数字`25`，即`5`乘以`5`。我们还将使用`toBeA`来断言关于值类型的一些内容：
- en: '[PRE98]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In this case, we want to make sure that the `square` is indeed a number, as
    opposed to a Boolean, string, or object. With this in place, we do need to call
    `done` and then save the file:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望确保`square`确实是一个数字，而不是布尔值、字符串或对象。有了这个，我们确实需要调用`done`，然后保存文件：
- en: '[PRE99]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Remember, if you don''t call `done`, your test will never finish. You might
    find that every once in a while you''ll get an error like this inside the Terminal:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您不调用`done`，您的测试将永远不会完成。您可能会发现偶尔会在终端内出现这样的错误：
- en: '![](img/b050421f-a3c1-451c-bf59-a522f76a0edd.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b050421f-a3c1-451c-bf59-a522f76a0edd.png)'
- en: 'You''re getting an error timeout, the 2,000 milliseconds has exceeded. This
    is when Mocha cuts off your test. If you see this, this usually means two things:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您收到了一个错误超时，超过了2,000毫秒。这是Mocha中断您的测试。如果您看到这个，通常意味着两件事：
- en: You have an `async` function that never actually calls the callback, so you're
    call to done never gets fired.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个`async`函数，实际上从未调用回调函数，因此您对`done`的调用从未被触发。
- en: You just never called `done`.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你从未调用过`done`。
- en: If you see this message, it usually means there's a small typo somewhere in
    the `async` function. To overcome this, either fix things in the method (`utils.js`)
    by making sure the callback is called, or fix things in the test (`utils.test.js`)
    by calling `done`, and when you save the file you should now see all of your tests
    are passing.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到此消息，通常意味着`async`函数中某处有小错误。要克服这一点，要么通过确保调用回调来修复方法（`utils.js`）中的问题，要么通过调用`done`来修复测试（`utils.test.js`）中的问题，然后保存文件，您现在应该看到所有测试都通过了。
- en: 'In our case, we have 5 tests passing and it took 2 seconds to do that. This
    is fantastic:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，有5个测试通过，用了2秒钟。这太棒了：
- en: '![](img/80634d18-e725-4f62-9bbc-0c7b819f8df0.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80634d18-e725-4f62-9bbc-0c7b819f8df0.png)'
- en: We now have a way to test synchronous functions and asynchronous functions.
    This will make testing a lot more flexible. It'll let us test essentially everything
    inside of our applications.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了测试同步函数和异步函数的方法。这将使测试更加灵活。它将让我们测试应用程序中的几乎所有内容。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked into testing the synchronous and asynchronous functions.
    We looked into basic testing. We explored the testing framework, Mocha. Then,
    we look into using assertion libraries in testing Node modules.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了同步和异步函数的测试。我们研究了基本测试。我们探索了测试框架Mocha。然后，我们研究了在测试Node模块中使用断言库。
- en: In the next chapter, we'll look at how we can test our Express apps.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何测试我们的Express应用程序。
