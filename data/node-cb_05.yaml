- en: 'Chapter 5. Transcending AJAX: Using WebSockets'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。超越AJAX：使用WebSocket
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a WebSocket server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建WebSocket服务器
- en: Seamless fallbacking with `socket.io`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`socket.io`实现无缝回退
- en: Callbacks over `socket.io` transport
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`socket.io`传输的回调
- en: Creating a real-time widget
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建实时小部件
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: HTTP was not made for the kind of real-time web applications that many developers
    are creating today. As a result, all sorts of workarounds have been discovered
    to mimic the idea of bi-directional, uninterrupted communication between servers
    and clients.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP并不适用于许多开发人员今天创建的实时网络应用程序。因此，已经发现了各种各样的解决方法来模拟服务器和客户端之间的双向，不间断的通信的想法。
- en: WebSockets don't mimic this behavior, they provide it. A WebSocket works by
    stripping down an HTTP connection so it becomes a persistent TCP-like exchange,
    thus removing all the overhead and restrictions HTTP introduces.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket不会模仿这种行为，它们提供了这种行为。WebSocket通过剥离HTTP连接来工作，使其成为持久的类似TCP的交换，从而消除了HTTP引入的所有开销和限制。
- en: The HTTP connection is stripped (or rather upgraded) when both the browser and
    server support WebSockets. The browser discovers this by communicating with the
    server via GET headers. Only newer browsers (IE10+, Google Chrome 14, Safari 5,
    Firefox 6) support WebSockets.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器和服务器都支持WebSocket时，HTTP连接被剥离（或升级）。浏览器通过GET标头与服务器通信来发现这一点。只有较新的浏览器（IE10+，Google
    Chrome 14，Safari 5，Firefox 6）支持WebSocket。
- en: WebSockets is a new protocol. JavaScript combined with the Node framework is
    often versatile and low level enough to implement protocols from scratch, or failing
    that C/C++ modules can be written to handle more obscure or revolutionary logic.
    Thankfully, there's no need to write our own protocol implementation, the open
    source community has already provided.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是一个新协议。JavaScript与Node框架通常足够灵活和低级，可以从头开始实现协议，或者无法实现的话，可以编写C/C++模块来处理更晦涩或革命性的逻辑。幸运的是，我们不需要编写自己的协议实现，开源社区已经提供了。
- en: In this chapter, we will be using some third-party modules to explore some of
    the potential of the powerful combination of Node and WebSockets.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一些第三方模块来探索Node和WebSocket强大组合的潜力。
- en: Creating a WebSocket server
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建WebSocket服务器
- en: For this task, we will use the non-core `websocket` module to create a pure
    WebSocket server that will receive and respond to WebSocket requests from the
    browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们将使用非核心的`websocket`模块来创建一个纯WebSocket服务器，该服务器将接收并响应来自浏览器的WebSocket请求。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We''ll create a new folder for our project which will hold two files: `server.js`
    and `client.html. server.js`. They provide the server-side websocket functionality
    and serve up the `client.html` file. For the server-side WebSocket functionality,
    we also need to install the `websocket` module:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的项目创建一个新文件夹，其中将包含两个文件：`server.js`和`client.html. server.js`。它们提供了服务器端的websocket功能并提供`client.html`文件。对于服务器端的WebSocket功能，我们还需要安装`websocket`模块：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the `websocket` module, see [https://www.github.com/Worlize/WebSocket-Node](https://www.github.com/Worlize/WebSocket-Node).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`websocket`模块的更多信息，请参见[https://www.github.com/Worlize/WebSocket-Node](https://www.github.com/Worlize/WebSocket-Node)。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A WebSocket is an HTTP upgrade. As such, WebSocket servers run on top of HTTP
    servers. So we''ll require the `http` and `websocket` servers, plus we''ll also
    load our `client.html` file (which we''ll be creating soon) and the `url` module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是HTTP升级。因此，WebSocket服务器在HTTP服务器之上运行。因此，我们将需要`http`和`websocket`服务器，另外我们还将加载我们的`client.html`文件（我们将很快创建）和`url`模块：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let''s create the HTTP server, and supply it to a new WebSocket server:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建HTTP服务器，并将其提供给一个新的WebSocket服务器：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We bind our HTTP server to port 8080 because binding to ports lower than 1000
    takes root access. This means our script would have to be executed with root privileges
    which is a bad idea. See[Chapter 10](ch10.html "Chapter 10. Taking It Live"),
    *Taking It Live*, for more information and how to bind to the HTTP port (80) safely.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的HTTP服务器绑定到端口8080，因为绑定到低于1000的端口需要root访问权限。这意味着我们的脚本必须以root权限执行，这是一个坏主意。有关如何安全地绑定到HTTP端口（80）的更多信息，请参见[第10章](ch10.html
    "第10章。搞定它")，*搞定它*。
- en: We've also created a new array, called `accept`. We use this inside the WebSocket
    server to restrict which originating sites can connect. For our example, we only
    allow connections from localhost or 127.0.0.1\. If we were hosting live we would
    include any domains pointing to our server in the `accept` array.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个新的数组，称为`accept`。我们在WebSocket服务器内部使用它来限制哪些起始站点可以连接。在我们的示例中，我们只允许来自localhost或127.0.0.1的连接。如果我们正在进行实时主机，我们将在`accept`数组中包括指向我们服务器的任何域。
- en: 'Now that we have our `webSocketServer` instance, we can listen to its `request`
    event and respond accordingly:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`webSocketServer`实例，我们可以侦听其`request`事件并做出相应的响应：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our `request` event callback, we conditionally accept the request, then listen
    for the `message` and `close` events, responding with **WebSockets!** if the message
    from the client is `Hello`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`request`事件回调中，我们有条件地接受请求，然后监听`message`和`close`事件，如果来自客户端的消息是`Hello`，则用**WebSockets!**做出响应。
- en: 'Now for the client, we''ll place the following HTML structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于客户端，我们将放置以下HTML结构：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And the content of our `script` tags should look as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`script`标签的内容应如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we initialize our server with `node server.js`, then direct our (WebSocket-compliant)
    browser to `http://localhost:8080`, type `Hello` in the textbox, and click on
    **Send**. The terminal console will output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`node server.js`初始化我们的服务器，然后将我们的（支持WebSocket的）浏览器指向`http://localhost:8080`，在文本框中输入`Hello`，然后单击**发送**。终端控制台将输出：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And our browser will show that **Hello** was sent and **WebSockets!** was received,
    as shown in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器将显示**Hello**已发送和**WebSockets!**已接收，如下面的屏幕截图所示：
- en: '![How to do it...](img/7188_05_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/7188_05_01.jpg)'
- en: We could use our textbox to send any string we like to our server, but only
    **Hello** will gain a response.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的文本框发送任何我们想要的字符串到我们的服务器，但只有**Hello**会得到响应。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In `server.js`, when we require the `websocket` module's `server` method, we
    load a constructor function into `WSServer`, (which is why we capitalized the
    first letter). We initialize `WSServer` using `new` and pass in our `plainHttpServer`
    which transforms it into a WebSocket-enabled server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中，当我们需要`websocket`模块的`server`方法时，我们将构造函数加载到`WSServer`中（这就是为什么我们将第一个字母大写）。我们使用`new`初始化`WSServer`，并传入我们的`plainHttpServer`，将其转换为一个启用了WebSocket的服务器。
- en: The HTTP server will still serve normal HTTP requests, but when it receives
    a WebSocket connection handshake the `webSocketServer` kicks into action to establish
    a persistent connection to the client.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器仍然会提供普通的HTTP请求，但当它接收到WebSocket连接握手时，`webSocketServer`会开始建立与客户端的持久连接。
- en: As soon as the `client.html` file is loaded in the browser (served by the HTTP
    server in `server.js)` and the inline script is executed, the WebSocket upgrade
    request is made to the server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`client.html`文件在浏览器中加载（由`server.js`中的HTTP服务器提供），并且内联脚本被执行，WebSocket升级请求就会发送到服务器。
- en: When the server receives this WebSocket upgrade request, `webSocketServer` emits
    a `request` event, which we scrutinize with our `accept` array before deciding
    whether we will respond.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器收到WebSocket升级请求时，`webSocketServer`会触发一个`request`事件，我们会使用我们的`accept`数组来仔细检查，然后决定是否响应。
- en: Our `accept` array holds a whitelist of hosts we'll allow to interface with
    our WebSocket server. We gain some security by only allowing known sources to
    use our WebSocket server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`accept`数组保存了一个白名单，允许与我们的WebSocket服务器进行接口交互的主机。只允许已知来源使用我们的WebSocket服务器，我们可以获得一些安全性。
- en: Inside the `webSocketServer request` event, `request.origin` is parsed with
    `url.parse` to retrieve the host name section of the `origin` URL. If the host
    name isn't found in our `accept` whitelist we call `request.reject`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`webSocketServer request`事件中，使用`url.parse`解析`request.origin`以检索`origin` URL的主机名部分。如果在我们的`accept`白名单中找不到主机名，我们就调用`request.reject`。
- en: If our originating host passes, we create a `websocket` variable from `request.accept`.
    The first parameter of `request.accept` allows us to define a custom sub-protocol.
    We could create an array of websockets using multiple `request.accepts` with different
    sub-protocols which represent different behaviors. When initiating our client,
    we would pass an additional argument containing that sub-protocol (for example,
    `new WebSocket("ws://localhost:8080", 'myCustomProtocol'))`. However, we pass
    in `null`, such functionality isn't required for our purposes. The second parameter
    allows us to inform `request.accept` of the host we wish to allow (there is also
    a third that can be used for passing cookies).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的源主机通过了，我们就从`request.accept`创建一个`websocket`变量。`request.accept`的第一个参数允许我们定义一个自定义子协议。我们可以使用多个具有不同子协议的`request.accepts`创建一个WebSocket数组，这些子协议代表不同的行为。在初始化客户端时，我们将传递一个包含该子协议的额外参数（例如，`new
    WebSocket("ws://localhost:8080", 'myCustomProtocol')`）。但是，我们传递`null`，因为对于我们的目的，不需要这样的功能。第二个参数允许我们通知`request.accept`我们希望允许的主机（还有第三个参数可用于传递cookie）。
- en: For each message received from the client, `WebSocket` emits a `message` event.
    This is where we log the received data to the `console` and check whether the
    incoming message is `Hello`. If it is, we use the `WebSocket.send` method to respond
    to the client with **WebSockets!**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从客户端接收的每条消息，`WebSocket`都会发出一个`message`事件。这是我们将接收到的数据记录到`console`并检查传入消息是否为`Hello`的地方。如果是，我们使用`WebSocket.send`方法向客户端回复**WebSockets!**。
- en: Finally, we listen for the `close` event, to inform `console` that the connection
    has been terminated.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们监听`close`事件，通知`console`连接已经被终止。
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: WebSockets have so much potential for efficient, low latency real-time web apps,
    but compatibility can be a challenge. Let's look at some other uses for WebSockets,
    plus a tip on getting WebSockets to work in Firefox.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets对于高效、低延迟的实时Web应用有很大潜力，但兼容性可能是一个挑战。让我们看看WebSockets的其他用途，以及让WebSockets在Firefox中工作的技巧。
- en: Supporting older Firefox browsers
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持旧版Firefox浏览器
- en: Firefox versions 6 to 11 do support WebSockets. However, they use a vendor prefix
    so our `client.html` will not work on these Firefox versions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox 6到11版本支持WebSockets。但是，它们使用供应商前缀，因此我们的`client.html`将无法在这些Firefox版本上运行。
- en: 'To fix this, we simply prepend the following to the script in our `client.html`
    file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们只需在`client.html`文件中的脚本前面添加以下内容：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the `WebSocket` API does not exist, we try `MozWebSocket`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`WebSocket` API不存在，我们尝试`MozWebSocket`。
- en: Creating a node-based WebSocket client
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基于Node的WebSocket客户端
- en: The `websocket` module also allows us to create a WebSocket client. We may wish
    to interface Node with a pre-existing WebSocket server, which is primarily for
    browser clients (if not, we are better off creating a simple TCP server. See [Chapter
    8](ch08.html "Chapter 8. Integrating Network Paradigms"), *Integrating Network
    Paradigms).*
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`websocket`模块还允许我们创建一个WebSocket客户端。我们可能希望将Node与现有的WebSocket服务器进行接口，这主要是为浏览器客户端（如果不是，最好创建一个简单的TCP服务器。参见[第8章](ch08.html
    "第8章。集成网络范式")，*集成网络范式*）。'
- en: So let's implement the same functionality in `client.html` using Node. We'll
    create a new file in the same directory, calling it `client.js:`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在`client.html`中使用Node实现相同的功能。我们将在同一目录中创建一个新文件，命名为`client.js`：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For brevity, we've simply hardcoded our `msg` variable, though we could have
    used `process.stdin` or `process.argv` to input a custom message. We initialize
    a new client with the `websocket` module's `client` method. Then we immediately
    begin to listen for the `connect` and `connectFailed` events.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们只是简单地将我们的`msg`变量硬编码，尽管我们可以使用`process.stdin`或`process.argv`来输入自定义消息。我们使用`websocket`模块的`client`方法初始化一个新的客户端。然后我们立即开始监听`connect`和`connectFailed`事件。
- en: After the two `on` methods, we chain the `connect` method. The first parameter
    is our WebSocket server, the second is the protocol (remember, we have a `null`
    protocol for `request.accept` in our recipe), and the third defines the `request.origin`
    value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个`on`方法之后，我们链接`connect`方法。第一个参数是我们的WebSocket服务器，第二个是协议（记住，在我们的配方中，对于`request.accept`，我们有一个空协议），第三个定义了`request.origin`的值。
- en: Origin protection is designed to prevent an attack that only works from browsers.
    So although we can manufacture origins outside of the browser, it doesn't pose
    the same threat. The biggest threat is from a JavaScript injection attack into
    a high traffic site, that could cause a large amount of unauthorized connections
    from an unintended origin resulting in **Denial of Service**. See [Chapter 7](ch07.html
    "Chapter 7. Implementing Security, Encryption, and Authentication"), *Implementing
    Security, Encryption, and Authentication.*
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 来源保护旨在防止仅从浏览器中起作用的攻击。因此，尽管我们可以在浏览器之外制造来源，但它并不构成同样的威胁。最大的威胁来自于对高流量站点进行JavaScript注入攻击，这可能导致大量未经授权的连接来自意外来源，从而导致**拒绝服务**。请参阅[第7章](ch07.html
    "第7章。实施安全、加密和认证"), *实施安全、加密和认证*。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Seamless fallbacking with socket.io* discussed in this chapter'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用socket.io进行无缝回退*'
- en: '*Serving static files* [Chapter 1](ch01.html "Chapter 1. Making a Web Server"),
    Making a Web Server'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供静态文件* [第1章](ch01.html "第1章。创建Web服务器"), 创建Web服务器'
- en: Seamless fallbacking with socket.io
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用socket.io进行无缝回退
- en: Older browsers don't support WebSockets. So in order to provide a similar experience,
    we need to fall back to various browser/plugin-specific techniques to emulate
    WebSocket functionality to the best of the deprecated browser's ability.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版浏览器不支持WebSocket。因此，为了提供类似的体验，我们需要回退到各种浏览器/插件特定的技术，以模拟WebSocket功能，以最大程度地利用已弃用浏览器的能力。
- en: Naturally, this is a mine field, requiring hours of browser testing and in some
    cases highly specific knowledge of proprietary protocols (for example, IE's `Active
    X htmlfile` object).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个雷区，需要数小时的浏览器测试，有时还需要对专有协议（例如IE的`Active X htmlfile`对象）有高度具体的了解。
- en: '`socket.io` provides a WebSocket-like API to the server and client to create
    the best-case real-time experience across a wide variety of browsers, including
    old (IE 5.5+) and mobile (iOS Safari, Android) browsers.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`为服务器和客户端提供了类似WebSocket的API，以在各种浏览器中（包括旧版IE 5.5+和移动端iOS Safari、Android浏览器）创建最佳实时体验。'
- en: On top of this, it also provides convenience features, such as disconnection
    discovery allowing for auto reconnects, custom events, namespacing, calling callbacks
    across the wire (see the next recipe *Callbacks over socket.io transport)*, as
    well as others.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，它还提供了便利功能，比如断开连接发现，允许自动重新连接，自定义事件，命名空间，通过网络调用回调（参见下一个配方*通过socket.io传输回调*），以及其他功能。
- en: In this recipe, we will re-implement the previous task for a high compatibility
    WebSocket-type application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将重新实现先前的任务，以实现高兼容性的WebSocket类型应用程序。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll create a new folder with new `client.html` and `server.js` files. We''ll
    also install the `socket.io` module:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的文件夹，其中包含新的`client.html`和`server.js`文件。我们还将安装`socket.io`模块：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Like the `websocket` module, `socket.io` can attach to an HTTP server (though
    it isn''t a necessity with `socket.io)`. Let''s create the `http` server and load
    `client.html`. In `server.js` we write:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与`websocket`模块一样，`socket.io`可以附加到HTTP服务器（尽管对于`socket.io`来说并不是必需的）。让我们创建`http`服务器并加载`client.html`。在`server.js`中，我们写道：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now for the `socket.io` part (still in `server.js):`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`socket.io`部分（仍在`server.js`中）：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That''s the server, so let''s make our `client.html` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是服务器端，现在让我们创建我们的`client.html`文件：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The final product is essentially the same as the previous recipe, except it
    will also work seamlessly in older browsers that aren't WebSocket compatible.
    We type `Hello`, press the **Send** button, and the server says **socket.io!**
    back.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最终产品基本上与上一个配方相同，只是它还可以在不兼容WebSocket的旧浏览器中无缝运行。我们输入“Hello”，按下**发送**按钮，服务器回复**socket.io!**。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Instead of passing the HTTP server in a options object, we simply pass it to
    a `listen` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再将HTTP服务器传递给选项对象，而是简单地将其传递给`listen`方法。
- en: We use `io.set` to define our origins whitelist and `socket.io` does the grunt
    work for us.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`io.set`来定义我们的来源白名单，`socket.io`为我们完成了繁重的工作。
- en: Next, we listen for the `connection` event on `io.sockets`, which provides us
    with a `socket` to the client (much like `request.accept` generates our `WebSocket`
    connection in the previous recipe).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们监听`io.sockets`上的`connection`事件，这为我们提供了一个客户端的`socket`（就像`request.accept`在上一个配方中生成了我们的`WebSocket`连接一样）。
- en: Inside `connection`, we listen for the `message` event on `socket`, checking
    that the incoming `msg` is `Hello`. If it is we respond with `socket.io!`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`connection`中，我们监听`socket`上的`message`事件，检查传入的`msg`是否为`Hello`。如果是，我们会回复`socket.io!`。
- en: When `socket.io` is initialized, it begins to serve the client-side code over
    HTTP. So in our `client.html` file we load the `socket.io.js` client script from
    `/socket.io/socket.io.js`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当`socket.io`初始化时，它开始通过HTTP提供客户端代码。因此，在我们的`client.html`文件中，我们从`/socket.io/socket.io.js`加载`socket.io.js`客户端脚本。
- en: The client-side `socket.io.js` provides a global `io` object. By calling its
    `connect` method with our server's address, we acquire the relevant `socket`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的`socket.io.js`提供了一个全局的`io`对象。通过调用它的`connect`方法并提供我们服务器的地址，我们可以获得相关的`socket`。
- en: We send our `Hello msg` to the server, and say we have done so via the `#output
    div` element.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向服务器发送我们的“Hello msg”，并通过“#output div”元素告诉服务器我们已经这样做了。
- en: When the server receives `Hello` it replies `socket.io!`, which triggers our
    `message` event callback on the client side.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器收到“Hello”时，它会回复“socket.io!”，这会触发客户端的“message”事件回调。
- en: Now we have the `msg` parameter (different to our `msg Hello` variable) containing
    the message from the server, so we output it to our `#output div` element.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`msg`参数（与我们的`msg Hello`变量不同），其中包含来自服务器的消息，因此我们将其输出到我们的`#output div`元素。
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`socket.io` builds upon the standard WebSocket API. Let''s explore some of
    the additional functionality of `socket.io`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`建立在标准的WebSocket API之上。让我们探索一些`socket.io`的附加功能。'
- en: Custom events
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义事件
- en: '`socket.io` allows us to define our own events, other than `message, connect`,
    and `disconnect`. We listen to custom events after the same fashion (using `on)`,
    but initiate them using the `emit` method.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`允许我们定义自己的事件，而不仅仅是`message, connect`和`disconnect`。我们以相同的方式监听自定义事件（使用`on`），但使用`emit`方法来初始化它们。'
- en: Let's `emit` a custom event from the server to the client, then respond to the
    client by emitting another custom event back to the server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从服务器向客户端`emit`一个自定义事件，然后通过向服务器发出另一个自定义事件来响应客户端。
- en: We can use the same code as in our recipe, the only parts we'll change are the
    contents of the `connection` event listener callback in `server.js` (which we'll
    copy as `custom_events_server.js)` and the `connect` event handler in `client.html`
    (which we'll copy as `custom_events_client.html)`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与我们的配方相同的代码，我们将更改的唯一部分是`server.js`中`connection`事件监听器回调的内容（我们将其复制为`custom_events_server.js`）和`client.html`中`connect`事件处理程序的内容（我们将其复制为`custom_events_client.html`）。
- en: 'So for our server code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的服务器代码：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our server emits a `hello` event saying `socket.io!` to the newly connected
    client and listens out for a `helloback` event from the client.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器发出一个`hello`事件，向新连接的客户端发送`socket.io!`，并等待来自客户端的`helloback`事件。
- en: 'So we modify the JavaScript in `custom_events_client.html` accordingly:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们相应地修改`custom_events_client.html`中的JavaScript：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we receive a `hello` event, we log to our `#output div` (which will say
    `Hello socket.io!)` and `emit` a `helloback` event to the server, passing the
    client as the intended `from` parameter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到`hello`事件时，我们记录到我们的`#output div`（其中将显示`Hello socket.io!`），并向服务器`emit`一个`helloback`事件，将客户端作为预期的`from`参数传递。
- en: Namespaces
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'With `socket.io`, we can describe namespaces, or routes, and then access them
    as a URL through `io.connect` on the client:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`socket.io`，我们可以描述命名空间或路由，然后在客户端通过`io.connect`访问它们的URL：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A **namespace** allows us to create different scopes while sharing the same
    context. In `socket.io`, namespaces are used as a way to share a single WebSocket
    (or other transport) connection for multiple purposes. See [http://en.wikipedia.org/wiki/Namespace](http://en.wikipedia.org/wiki/Namespace)
    and [http://en.wikipedia.org/wiki/Namespace_(computer_science)](http://en.wikipedia.org/wiki/Namespace_(computer_science)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间**允许我们在共享相同上下文的同时创建不同的范围。在`socket.io`中，命名空间用作为多个目的共享单个WebSocket（或其他传输）连接的一种方式。请参阅[http://en.wikipedia.org/wiki/Namespace](http://en.wikipedia.org/wiki/Namespace)和[http://en.wikipedia.org/wiki/Namespace_(computer_science)](http://en.wikipedia.org/wiki/Namespace_(computer_science))。'
- en: Using a series of `io.connect`, calls we are able to define multiple WebSocket
    routes. However, this won't create multiple connections to our server. `socket.io`
    multiplexes (or combines) them as one connection and manages the namespacing logic
    internally on the server, which is far less expensive.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一系列`io.connect`调用，我们能够定义多个WebSocket路由。但是，这不会创建多个连接到我们的服务器。`socket.io`将它们多路复用（或组合）为一个连接，并在服务器内部管理命名空间逻辑，这样成本就会低得多。
- en: We'll demonstrate namespacing by upgrading the code from the recipe *Transferring
    data between browser and server via AJAX* discussed In [Chapter 3](ch03.html "Chapter 3. Working
    with Data Serialization"), *Working with Data Serialization*, to a `socket.io-based`
    app.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将代码从第3章“使用AJAX在浏览器和服务器之间传输数据”中讨论的*数据序列化*的配方升级为基于`socket.io`的应用程序来演示命名空间。
- en: First, let's create a folder, call it `namespacing`, and copy the original `index.html,
    server.js, buildXml.js`, and `profiles.js` files into it. `Profiles.js` and `buildXml.js`
    are support files, so we can leave those alone.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个文件夹，称之为`namespacing`，并将原始的`index.html, server.js, buildXml.js`和`profiles.js`文件复制到其中。`Profiles.js`和`buildXml.js`是支持文件，所以我们可以不管它们。
- en: 'We can strip down our `server.js` file, taking out everything to do with `routes`
    and `mimes` and reducing the `http.createServer` callback to it''s last `response.end`
    line. We no longer need the path module, so we''ll remove that, and finally wrap
    our server in the `socket.io listen` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简化我们的`server.js`文件，删除与`routes`和`mimes`有关的所有内容，并将`http.createServer`回调减少到其最后的`response.end`行。我们不再需要path模块，因此我们将删除它，并最终将我们的服务器包装在`socket.io
    listen`方法中：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To declare our namespaces with their connection handlers we use `of` as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明我们的命名空间及其连接处理程序，我们使用`of`如下：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In our `index.html` file we include `socket.io.js`, and connect to the namespaces:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`index.html`文件中，我们包括`socket.io.js`，并连接到命名空间：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once connected, the server emits a `profiles` event with an array of `profile_names`,
    our client picks it up and processes it. Our client emits custom `profile` events
    to the relevant namespace, and each namespace socket listens for a `profile` event
    from the server, handling it according to its format (which is determined by namespace).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接，服务器将使用`profile_names`数组发出`profiles`事件，我们的客户端接收并处理它。我们的客户端向相关命名空间发出自定义`profile`事件，并且每个命名空间套接字都会监听来自服务器的`profile`事件，并根据其格式进行处理（由命名空间确定）。
- en: Namespaces allow us to separate our concerns, without having to use multiple
    `socket.io` clients (thanks to multiplexing). In similar fashion to the sub-protocol
    concept in WebSockets, we can restrict certain behaviors to certain namespaces
    giving us more readable code, and easing the mental complexity involved in a multifaceted
    real-time web app.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间允许我们分离关注点，而无需使用多个`socket.io`客户端（由于多路复用）。与WebSocket中的子协议概念类似，我们可以将某些行为限制在某些命名空间中，从而使我们的代码更易读，并减轻多方面实时Web应用程序中涉及的心理复杂性。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating a WebSocket server* discussed in this chapter'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的创建WebSocket服务器*'
- en: '*Callbacks over socket.io transport* discussed in this chapter'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的通过socket.io传输回调*'
- en: '*Creating a real-time widget* discussed in this chapter'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的创建实时小部件*'
- en: Callbacks over socket.io transport
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过socket.io传输回调
- en: With `socket.io` we can execute a callback function over WebSockets (or a relevant
    fallback). The function is defined client side, yet called server side (and vice
    versa). This can be a very powerful way to share processing resources and functionality
    between clients and servers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`socket.io`，我们可以通过WebSockets（或相关的回退）执行回调函数。该函数在客户端定义，但在服务器端调用（反之亦然）。这可以是在客户端和服务器之间共享处理资源和功能的非常强大的方式。
- en: In this recipe, we'll create a way for the server to call a client-side function
    that squares a number, and for the client to call a server-side function that
    sends Base64 encoding ([http://en.wikipedia.org/wiki/Base64](http://en.wikipedia.org/wiki/Base64))
    of a sentence back to the client.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一种让服务器调用客户端函数的方法，该函数可以对一个数字进行平方，并且让客户端调用一个将句子的Base64编码（[http://en.wikipedia.org/wiki/Base64](http://en.wikipedia.org/wiki/Base64)）发送回客户端的服务器端函数。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We simply need to create a new folder with new `client.html` and `server.js`
    files.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要创建一个新文件夹，其中包括新的`client.html`和`server.js`文件。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: On our server, as before, we load our `http` module and the `client.html` file,
    create our HTTP server, attach `socket.io`, and set the `origins` policy.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的服务器上，与以前一样，我们加载我们的`http`模块和`client.html`文件，创建我们的HTTP服务器，附加`socket.io`，并设置`origins`策略。
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, in our `connection` event handler, we listen for the custom event `give
    me a number` from the client, and `emit` a custom event `give me a sentence` from
    the server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的`connection`事件处理程序中，我们监听来自客户端的自定义事件`give me a number`，并从服务器`emit`一个自定义事件`give
    me a sentence`。
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our `client.html` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`client.html`文件中：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Immediately upon connection, both the server and client `emit` a custom `socket.io`
    event to each other.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后立即，服务器和客户端都会相互`emit`一个自定义的`socket.io`事件。
- en: For custom `socket.io` events, see the *There's more..*. section of the previous
    recipe *Seamless fallbacking with socket.io*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有关自定义`socket.io`事件，请参阅上一个配方*与socket.io无缝回退*的*还有更多..*部分。
- en: For both the client and server, when we pass a function as the second parameter
    of `emit, socket.io` creates a special parameter (`cb`) in the corresponding event
    listener's callback. `cb` is not, in this case, the actual function (if it was,
    it would simply run in the context from which it was called), but an internal
    `socket.io` function which passes the arguments back to the `emit` method on the
    other side of the wire. `emit` then passes these arguments into its callback,
    thus executing the function in local context.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端和服务器，当我们将函数作为`emit, socket.io`的第二个参数传递时，`socket.io`会在相应的事件监听器的回调中创建一个特殊的参数（`cb`）。在这种情况下，`cb`不是实际的函数（如果是，它将在调用它的上下文中简单运行），而是一个内部的`socket.io`函数，它将参数传递回到电线的另一侧的`emit`方法。然后`emit`将这些参数传递给它的回调函数，从而在本地上下文中执行函数。
- en: We know that the functions run in their own context. If the server-side `give
    me a sentence` callback was executed on the client, it would fail because there
    is no `Buffer` object in browsers. If the `give me a number` ran on the server,
    it would fail since there is no DOM (Document Object Model) in Node (that is,
    there is no HTML, hence no `document` object and no `document.getElementById`
    method).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这些函数在自己的上下文中运行。如果服务器端的`give me a sentence`回调在客户端上执行，它将失败，因为浏览器中没有`Buffer`对象。如果`give
    me a number`在服务器上运行，它将失败，因为Node中没有DOM（文档对象模型）（也就是说，没有HTML，因此没有`document`对象和`document.getElementById`方法）。
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`socket.io` can be a great basis for even higher-level specializing frameworks.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`可以成为更高级专业化框架的良好基础。'
- en: Shared functions with Nowjs
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Nowjs共享函数
- en: 'Nowjs extrapolates the `socket.io` callback feature into an even simpler API,
    allowing us to share functions via a global `now` object on the client and the
    `everyone.now` object on the server. Let''s get the `now` module:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Nowjs将`socket.io`的回调功能推断为更简单的API，允许我们通过客户端上的全局`now`对象和服务器上的`everyone.now`对象共享函数。让我们获取`now`模块：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Setting up Nowjs is eerily familiar:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Nowjs让人不寒而栗：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `clientHtml` file loads `now_client.html` instead, in place of `io` we have
    `everyone`, and rather than calling `listen` we call `initialize`. Everything
    else so far is the same (except, of course, requiring `now` instead of `socket.io)`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`clientHtml`文件加载`now_client.html`，而不是`io`，我们有`everyone`，而不是调用`listen`，我们调用`initialize`。到目前为止，其他一切都是一样的（当然，需要`now`而不是`socket.io`）。'
- en: We'll re-implement our recipe using `now`, to finish off the server we put.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`now`重新实现我们的配方，以完成我们放置的服务器。
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s save our server as `now_server.js`, and in `now_client.html` we write
    the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将服务器保存为`now_server.js`，在`now_client.html`中编写以下代码：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: NowJS makes function sharing trivial. On the server, we simply set up our `base64`
    method on `everyone.now`, which makes `base64` available to all clients.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: NowJS使函数共享变得微不足道。在服务器端，我们只需在`everyone.now`上设置我们的`base64`方法，这样`base64`就可以在所有客户端上使用。
- en: Then we listen for the `connect` event, when it occurs we call `this.now.square`.
    In this context `this` is the socket to our client, so `this.now.square` calls
    the `now.square` method contained in `now_client.html`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们监听`connect`事件，当它发生时，我们调用`this.now.square`。在这个上下文中，`this`是我们客户端的socket，所以`this.now.square`调用`now_client.html`中包含的`now.square`方法。
- en: In our client, instead of loading `socket.io.js`, we include `now.js` whose
    route is exposed at server initialization. This provides us with the global `now`
    object, on which we set our `square` function method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的客户端中，我们不是加载`socket.io.js`，而是包含`now.js`，其路由在服务器初始化时公开。这为我们提供了全局的`now`对象，我们在其中设置我们的`square`函数方法。
- en: Once a connection is established (detected using `now.ready)`, we call `now.base64`
    using a callback to pull the data from the server to the client.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接（使用`now.ready`检测），我们使用回调调用`now.base64`从服务器到客户端拉取数据。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Seamless fallbacking with socket.io* discussed in this chapter'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与socket.io无缝回退*在本章中讨论'
- en: '*Creating a real time widget* discussed in this chapter'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论创建实时小部件*'
- en: '*Browser-server transmission via AJAX discussed in* [Chapter 3](ch03.html "Chapter 3. Working
    with Data Serialization"), *Working with Data Serialization*'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过AJAX进行浏览器-服务器传输在* [第3章](ch03.html "第3章。与数据序列化一起工作") *中讨论，与数据序列化一起工作*'
- en: Creating a real-time widget
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个实时小部件
- en: The configuration options and well thought out methods of socket.io make for
    a highly versatile library. Let's explore the dexterity of `socket.io` by making
    a real-time widget that can be placed on any website and instantly interface with
    a remote `socket.io` server to begin providing a constantly updated total of all
    users currently on site. We'll name it the `Live Online Counter (loc` for short).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: socket.io的配置选项和深思熟虑的方法使其成为一个非常灵活的库。让我们通过制作一个实时小部件来探索`socket.io`的灵活性，该小部件可以放置在任何网站上，并立即与远程`socket.io`服务器进行接口，以开始提供当前网站上所有用户的不断更新的总数。我们将其命名为“实时在线计数器（loc）”。
- en: Our widget is for easy user consumption and should require very little knowledge
    to get working, so we want a very simple interface. Loading our widget through
    a `script` tag, and then initializing the widget with a prefabricated `init` method
    would be ideal (this allows us to pre-define properties before initialization
    if necessary).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小部件是为了方便用户使用，应该需要非常少的知识才能使其工作，因此我们希望有一个非常简单的接口。通过`script`标签加载我们的小部件，然后使用预制的`init`方法初始化小部件将是理想的（这样我们可以在初始化之前预定义属性，如果有必要的话）。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We''ll need to create a new folder with some new files: `widget_server.js,
    widget_client.js, server.js`, and `index.html`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的文件夹，其中包含一些新文件：`widget_server.js，widget_client.js，server.js`和`index.html`。
- en: Before we start let's also get the `socket.io-client` module from `npm`. We'll
    be using this to build our custom `socket.io` client-side code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们还从`npm`获取`socket.io-client`模块。我们将使用它来构建我们的自定义`socket.io`客户端代码。
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create `index.html` to define the kind of interface we want as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`index.html`来定义我们想要的界面类型，如下所示：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We want to expose a route to `/loc/widget_server.js` which contains our loc
    widget. Behind the scenes, our widget will be held in `widget_client.js`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望向`/loc/widget_server.js`公开一个路由，其中包含我们的loc小部件。在幕后，我们的小部件将保存在`widget_client.js`中。
- en: 'So let''s make it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们做一下：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We need to test our widget from multiple domains, so we'll just implement a
    quick HTTP server (`server.js`) to serve `index.html` so we can access it by `http://127.0.0.1:8080`
    and `http://localhost:8080`, this gives us our multiple domains.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从多个域测试我们的小部件，因此我们将实现一个快速的HTTP服务器（`server.js`）来提供`index.html`，以便我们可以通过`http://127.0.0.1:8080`和`http://localhost:8080`访问它，这样我们就可以获得多个域。
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, the server for our widget, in `widget_server.js` we write:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的小部件服务器，在`widget_server.js`中编写：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To test we need two terminals, in one we execute:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们需要两个终端，在一个终端中执行：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the other we execute:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中执行：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we point our browser to `http://localhost:8080`, open a new tab or window
    and navigate to `http://localhost:8080`. Again we will see the counter rise by
    one. If we close either window, it will drop by one. We can also navigate to `http://127.0.0.1:8080`
    to emulate a separate origin. The counter at this address is independent from
    the counter at `http://localhost:8080`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将浏览器指向`http://localhost:8080`，打开一个新的标签页或窗口并导航到`http://localhost:8080`。同样，我们将看到计数器增加一个。如果我们关闭任一窗口，它将减少一个。我们还可以导航到`http://127.0.0.1:8080`以模拟一个独立的来源。该地址上的计数器与`http://localhost:8080`上的计数器是独立的。
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`widget_server.js` is the powerhouse of this recipe. We start by requiring
    `socket.io` and calling the `listen` method. Instead of passing it as an `httpServer`
    instance as in the prior tasks, we pass it the port number `8081`. It helps if
    we think of `ws://localhost:8081` as a remote server that many client widgets
    connect to.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`widget_server.js`是这个配方的核心。我们首先需要`socket.io`并调用`listen`方法。与之前的任务不同，我们不是将其作为`httpServer`实例传递，而是将其传递给端口号`8081`。如果我们将`ws://localhost:8081`视为许多客户端小部件连接到的远程服务器，这将有所帮助。'
- en: The next requirement is `socket.io-client`, which we load into our `sioclient`
    variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要求是`socket.io-client`，我们将其加载到我们的`sioclient`变量中。
- en: Through `sioclient` we can access the `sioclient.builder` method to generate
    a `socket.io.js` file. This concatenated to `widgetScript` to effectively create
    a single JavaScript file containing `socket.io.js` and `widget_client.js`. We
    name the HTTP route to this file `widget.js`. When joining the `socket.io.js`
    file to our `widgetScript`, we place a semicolon in between to ensure the scripts
    don't interfere with each other.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`sioclient`，我们可以访问`sioclient.builder`方法来生成一个`socket.io.js`文件。将其连接到`widgetScript`以有效地创建一个包含`socket.io.js`和`widget_client.js`的单个JavaScript文件。我们将HTTP路由命名为此文件`widget.js`。将`socket.io.js`文件连接到我们的`widgetScript`时，我们在两者之间放置一个分号，以确保脚本不会相互干扰。
- en: We pass two arguments to the `builder` method, the first is an array of transports.
    These are the various methods for creating the real-time effect (for example WebSockets,
    AJAX (xhr) polling). The earlier a transport appears in the array the more preferred
    it is. The array is generated with the `transports` method. Since we haven't set
    any transports during configuration, the default transports array is supplied.
    The second argument is a callback. Here we can grab the generated `socket.io.js`
    file via the `siojs` parameter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`builder`方法传递了两个参数，第一个是传输数组。这些是创建实时效果的各种方法（例如WebSockets，AJAX（xhr）轮询）。数组中较早出现的传输方法更受青睐。数组是使用`transports`方法生成的。由于我们在配置期间没有设置任何传输，因此提供了默认传输数组。第二个参数是回调。在这里，我们可以通过`siojs`参数获取生成的`socket.io.js`文件。
- en: Our widget is purely a JavaScript affair, for plugging in to any HTML page on
    any site. `socket.io` has an internal HTTP server used for supplying JavaScript
    client-side files. Instead of creating an HTTP server to provide our client widget
    code, we use `io.static.add` (once we have our generated `socket.io.js)` to push
    a new route onto the internal HTTP server of `socket.io`. The second argument
    of `io.static.add` is a callback function, which in turn has a function passed
    to it named `callback`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小部件纯粹是JavaScript的事务，可以插入到任何网站的任何HTML页面中。`socket.io`有一个内部HTTP服务器用于提供JavaScript客户端文件。我们使用`io.static.add`（一旦我们有了生成的`socket.io.js`）将一个新的路由推送到`socket.io`的内部HTTP服务器上，而不是创建一个HTTP服务器来提供我们的客户端小部件代码。`io.static.add`的第二个参数是一个回调函数，其中又有一个传递给它的函数名为`callback`。
- en: '`callback` is part of `socket.io`, it adds the content to the newly defined
    route. The first argument can point to a literal file, but we are dynamically
    generating the code, so we pass `null`. To the second parameter we pass `siojs`
    with `widgetScript` into a `Buffer` and our route is created.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback`是`socket.io`的一部分，它将内容添加到新定义的路由。第一个参数可以指向一个文字文件，但我们正在动态生成代码，所以我们传递`null`。对于第二个参数，我们将`siojs`与`widgetScript`传递给`Buffer`，然后创建我们的路由。'
- en: By altering the `resource` property to change the route to the internal HTTP
    server routes of `socket.io, io.set` helps us to brand our widget. As a result,
    our combined `widget.js` route won't appear at `/socket.io/widget.js` anymore,
    instead it will be at `/loc/widget.js`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改`resource`属性以更改到`socket.io`的内部HTTP服务器路由的路由，`io.set`帮助我们为我们的小部件进行品牌推广。因此，我们的组合`widget.js`路由将不再出现在`/socket.io/widget.js`，而是将出现在`/loc/widget.js`。
- en: In order to connect to our configured static resource route from the client,
    we have to pass in an `options` object to `io.connect` in `widget_client.js`.
    Notice the absence of a slash prefix. A slash prefix is mandatory server side
    but for the client it is mandatorily omitted.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从客户端连接到我们配置的静态资源路由，我们必须在`widget_client.js`中向`io.connect`传递一个`options`对象。请注意斜杠前缀的缺失。斜杠前缀在服务器端是强制性的，但对于客户端来说是必须省略的。
- en: Now the stage is set for the actual socket action. We wait for a connection
    by listening for the `connection` event on `io.sockets`. Inside the event handler
    we use a few as yet undiscussed `socket.io` qualities.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在舞台已经为实际的套接字操作做好了准备。我们通过在`io.sockets`上监听`connection`事件来等待连接。在事件处理程序内部，我们使用了一些尚未讨论的`socket.io`特性。
- en: A WebSocket is formed when a client initiates a handshake request over HTTP
    and the server responds affirmatively. `socket.handshake` contains the properties
    of the handshake.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发起HTTP握手请求并且服务器肯定地响应时，WebSocket就形成了。`socket.handshake`包含握手的属性。
- en: '`socket.handshake.xdomain` tells us whether the handshake was initiated from
    the same server. We will check for a cross-server handshake before retrieving
    the `hostname` of `socket.handshake.headers.origin`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.handshake.xdomain`告诉我们握手是否是从同一服务器发起的。在检索`socket.handshake.headers.origin`的`hostname`之前，我们将检查跨服务器握手。'
- en: The origin of a same domain handshake is either `null` or `undefined` (depending
    on whether it's a local file handshake or localhost handshake). The latter causes
    `url.parse` to choke and the former isn't ideal. So for same domain handshakes
    we simply set our `origin` variable to `local`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 相同域名握手的来源要么是`null`，要么是`undefined`（取决于它是本地文件握手还是本地主机握手）。后者会导致`url.parse`出错，而前者则不理想。因此，对于相同域名握手，我们只需将我们的`origin`变量设置为`local`。
- en: We extract (and simplify) the `origin` because it allows us to distinguish between
    websites that use widget, enabling site-specific counts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取（并简化）`origin`，因为它允许我们区分使用小部件的网站，从而实现特定于网站的计数。
- en: To keep count, we use our `totals` object and add a property for every new `origin`
    with an initial value of `0`. On each connection, we add `1` to `totals[origin]`
    listening to our `socket` for the `disconnect` event where we minus one from `totals[origin]`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计数，我们使用我们的`totals`对象，并为每个新的`origin`添加一个初始值为`0`的属性。在每次连接时，我们将`1`添加到`totals[origin]`，并监听我们的`socket`以获取`disconnect`事件，从`totals[origin]`中减去`1`。
- en: If these values were exclusively for server use, our solution would be complete.
    However, we need a way to communicate total connections to the client, but only
    for the site they are on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些值仅用于服务器使用，我们的解决方案将是完整的。但是，我们需要一种方法来向客户端通信总连接数，但仅限于他们所在的网站。
- en: '`socket.io` has a handy new feature since `socket.io` version 7, which allows
    us to group sockets into rooms by using the `socket.join` method. We cause each
    socket to join a room named after its `origin`, then we use the `io.sockets.to(origin).emit`
    method to instruct `socket.io` to only `emit` to sockets belonging to the originating
    `sites` room.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`自版本7以来有一个方便的新功能，它允许我们使用`socket.join`方法将套接字分组到房间中。我们让每个套接字加入以其`origin`命名的房间，然后我们使用`io.sockets.to(origin).emit`方法指示`socket.io`只向属于原始`sites`房间的套接字`emit`。'
- en: In both the `io.sockets connection` event and the `socket disconnect` event,
    we `emit` our specific `totals` to corresponding sockets to update each client
    with the total amount of connections to the site the user is on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`io.sockets connection`事件和`socket disconnect`事件中，我们向相应的套接字`emit`我们特定的`totals`，以便更新每个客户端连接到用户所在网站的总连接数。
- en: '`widget_client.js` simply creates a `div` called `#_loc` and updates it with
    any new `totals` it receives from `widget_server.js`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`widget_client.js`简单地创建一个名为`#_loc`的`div`，并使用它更新从`widget_server.js`接收到的任何新的`totals`。'
- en: There's more...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's look at how our app could be made more scalable as well as another use
    for WebSockets.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使我们的应用程序更具可扩展性，以及WebSocket的另一个用途。
- en: Preparing for scalability
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为可扩展性做准备
- en: If we were to serve thousands of websites, we would need scalable memory storage,
    and Redis would be a perfect fit. It operates in memory but also allows us to
    scale across multiple servers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要为成千上万的网站提供服务，我们需要可扩展的内存存储，Redis将是一个完美的选择。它在内存中运行，但也允许我们跨多个服务器进行扩展。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll need Redis installed, along with the `redis` module. For more information
    see [Chapter 4](ch04.html "Chapter 4. Interfacing with Databases"),Interfacing
    with Databases
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装 Redis，以及 `redis` 模块。更多信息请参见[第4章](ch04.html "第4章。与数据库交互")，与数据库交互
- en: 'We''ll alter our `totals` variable so it contains a Redis client instead of
    a JavaScript object:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的 `totals` 变量，使其包含一个 Redis 客户端而不是一个 JavaScript 对象：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we modify our `connection` event handler like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们修改我们的 `connection` 事件处理程序如下：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Instead of adding one to `totals[origin]`, we use the Redis `INCR` command to
    increment a Redis key named after `origin`. Redis automatically creates the key
    if it doesn't exist. When a client disconnects, we do the reverse and readjust
    `totals` using `DECR.`
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再将 `totals[origin]` 加一，而是使用 Redis 的 `INCR` 命令来增加一个名为 `origin` 的 Redis 键。如果键不存在，Redis
    会自动创建它。当客户端断开连接时，我们会执行相反的操作，并使用 `DECR` 调整 `totals`。
- en: WebSockets as a development tool
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WebSockets 作为开发工具
- en: When developing a website, we often change something small in our editor, upload
    our file (if necessary), refresh the browser, and wait to see the results. What
    if the browser would refresh automatically whenever we saved any file relevant
    to our site? We can achieve this with `fs.watch` and WebSockets. `fs.watch` monitors
    a directory, executing a callback whenever a change to any files in the folder
    occurs (but it doesn't monitor sub-folders).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发网站时，我们经常在编辑器中更改一些小东西，上传我们的文件（如果需要），刷新浏览器，然后等待看到结果。如果浏览器在我们保存与网站相关的任何文件时自动刷新会怎么样？我们可以通过
    `fs.watch` 和 WebSockets 实现这一点。`fs.watch` 监视一个目录，在文件夹中的任何文件发生更改时执行回调（但它不监视子文件夹）。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`fs.watch` is operating system dependent. To date, `fs.watch` has also been
    historically buggy (mostly under Mac OS X). Therefore until further advancements,
    `fs.watch` is suited purely to development environments rather than production
    (you can monitor how `fs.watch` is doing by viewing the open and closed issues
    here: [https://github.com/joyent/node/issues/search?q=fs.watch)](https://github.com/joyent/node/issues/search?q=fs.watch)).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.watch` 是依赖于操作系统的。到目前为止，`fs.watch` 也一直存在着历史性的 bug（主要是在 Mac OS X 下）。因此，在进一步改进之前，`fs.watch`
    更适合于开发环境而不是生产环境（您可以通过查看这里的已打开和已关闭的问题来监视 `fs.watch` 的运行情况：[https://github.com/joyent/node/issues/search?q=fs.watch)](https://github.com/joyent/node/issues/search?q=fs.watch)）。'
- en: Our development tool could be used alongside any framework, from PHP to static
    files. For a general server, let's take the recipe *Serving static files* from[Chapter
    1](ch01.html "Chapter 1. Making a Web Server"), *Making a Web Server*, to test
    our tool out on. We'll copy the files (including the `content` folder) from that
    recipe into a new folder, which we can name `watcher`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发工具可以与任何框架一起使用，从 PHP 到静态文件。对于一个通用的服务器，让我们从[第1章](ch01.html "第1章。制作Web服务器")中的
    *提供静态文件* 这个配方中测试我们的工具。我们将文件（包括 `content` 文件夹）从该配方复制到一个新文件夹中，我们可以将其命名为 `watcher`。
- en: For the server counterpart of our tool, we'll make `watcher.js:`
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们工具的服务器端对应部分，我们将创建 `watcher.js`：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Most of this code is familiar. We make a `socket.io` server (on a different
    port to avoid clashing), generate a concatenated `socket.io.js` plus client-side
    `watcher` code file, and add it to the static resources of `socket.io`. Since
    this is a quick tool for our own development uses, our client-side code is written
    as a string to the `watcher` variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码大部分都很熟悉。我们创建了一个 `socket.io` 服务器（在不同的端口上以避免冲突），生成了一个连接的 `socket.io.js` 加上客户端
    `watcher` 代码文件，并将其添加到 `socket.io` 的静态资源中。由于这是我们自己开发使用的一个快速工具，我们的客户端代码被写成一个字符串赋值给
    `watcher` 变量。
- en: The last piece of code calls the `fs.watch` method, where the callback receives
    the event name (`e`) and the filename (`f`).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码调用了 `fs.watch` 方法，其中回调接收事件名称（`e`）和文件名（`f`）。
- en: We check that the filename isn't a hidden dotfile. During a save event some
    file systems or editors will change hidden files in the directory, thus triggering
    multiple callbacks sending several messages at high speed, which can cause issues
    for the browser.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查文件名是否不是隐藏的点文件。在保存事件期间，一些文件系统或编辑器会更改目录中的隐藏文件，从而触发多个回调，发送多个消息，速度很快，这可能会对浏览器造成问题。
- en: To use it, we simply place it as a script within every page served (probably
    using server-side templating). However, for demonstration purposes, we simply
    place the following code into `content/index.html:`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们只需将其放置在每个页面中作为脚本（可能使用服务器端模板）。然而，为了演示目的，我们只需将以下代码放入 `content/index.html`
    中：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once we fire up `server.js` and `watcher.js`, we can point our browser to `http://localhost:8080`
    and see the familiar excited **Yay!** from[Chapter 1](ch01.html "Chapter 1. Making
    a Web Server"), *Making a Web Server*. Any changes we make and save (either to
    `index.html, styles.css, script.js`, or the addition of new files) will be almost
    instantly reflected in the browser. The first change we can make is to rid ourselves
    of the alert box in `script.js` so changes can be seen fluidly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动了 `server.js` 和 `watcher.js`，我们就可以将浏览器指向 `http://localhost:8080`，并从[第1章](ch01.html
    "第1章。制作Web服务器")中看到熟悉的激动人心的 **Yay!**。我们所做的任何更改和保存（无论是对 `index.html, styles.css,
    script.js` 进行更改，还是添加新文件）几乎会立即在浏览器中反映出来。我们可以做的第一个更改是摆脱 `script.js` 中的警报框，以便更流畅地看到更改。
- en: See also
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Creating a WebSocket server* discussed in this chapter'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 WebSocket 服务器* 在本章中讨论'
- en: '*Seamless fallbacking with socket.io* discussed in this chapter'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 socket.io 实现无缝回退* 在本章中讨论'
- en: '*Storing and retrieving data with Redis* discussed In [Chapter 4](ch04.html
    "Chapter 4. Interfacing with Databases"),Interfacing with Databases'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Redis 存储和检索数据* 在[第4章](ch04.html "第4章。与数据库交互")中讨论'
