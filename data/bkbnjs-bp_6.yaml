- en: Chapter 6. Building a Podcast Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。构建播客应用
- en: In this chapter, there will be an interesting twist. All the applications we
    have built so far have been pretty heavy on the client code, but rather light
    on the server. The truth is, the web applications you're going to build aren't
    always going to be this way. Often, you'll have to perform a lot of heavy lifting
    on the backend as well as on the frontend; and the application we're going to
    build here will be this way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，会有一个有趣的转折。我们迄今为止构建的所有应用在客户端代码方面都很重，但在服务器端却很轻。事实是，你将要构建的 Web 应用程序并不总是这样的。通常，你既需要在后端也需要在客户端进行大量的工作；而我们在这里将要构建的应用程序就是这样。
- en: 'So, in this chapter, we''ll focus on the following ideas:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将关注以下想法：
- en: Building an application that is both server- and client-intensive
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建既注重服务器端又注重客户端的应用程序
- en: Duplicating some of Marionette's functionality, without using Marionette
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制一些 Marionette 的功能，而不使用 Marionette
- en: Parsing and simplifying a data file before storing it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储之前解析和简化数据文件
- en: What are we building?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在建造什么？
- en: 'In this chapter, we''ll be building a podcast-listening application. As you
    probably know, a podcast feed is very similar to a regular blog''s RSS feed. The
    primary difference is what the fields are; so, even though we''re building a basic
    podcast **catcher**, a lot of it could go towards building a regular RSS reader.
    So, here''s what we will have: people can make accounts for our application, and
    then subscribe to podcast feeds. We''ll load in all existing episodes, and users
    can listen to them and see the show notes and links right in our app. Each time
    a user opens the application, each of the podcasts they subscribe to will be checked
    for new episodes. They''ll be able to listen to episodes, or just mark them as
    listened to.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个播客收听应用。如您所知，播客源与常规博客的 RSS 源非常相似。主要区别在于字段；因此，尽管我们正在构建一个基本的播客 **捕获器**，但其中很多可以用于构建常规的
    RSS 阅读器。所以，我们将拥有以下内容：人们可以为我们的应用创建账户，然后订阅播客源。我们将加载所有现有剧集，用户可以在我们的应用中收听它们，并查看节目笔记和链接。每次用户打开应用程序时，他们订阅的每个播客都会检查是否有新剧集。他们可以收听剧集，或者只是标记为已收听。
- en: 'Here''s a look at the completed project:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看完成的项目：
- en: '![What are we building?](img/6997OS_06_04.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![我们在建造什么？](img/6997OS_06_04.jpg)'
- en: It doesn't sound or look like a lot, maybe, but there's a lot to do, so let's
    get started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 也许听起来或看起来并不多，但还有很多工作要做，让我们开始吧。
- en: Building user accounts
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户账户
- en: 'We''ll start with user accounts. You''ll remember that in [Chapter 2](ch02.html
    "Chapter 2. Building a Photo-sharing Application"), *Building a Photo-sharing
    Application*, when we built the photo sharing application, we created a `signin.js`
    file; we''ll want to use that here. We can set this up by following these steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从用户账户开始。您会记得，在 [第 2 章](ch02.html "第 2 章。构建照片分享应用")，*构建照片分享应用* 中，当我们构建照片分享应用时，我们创建了一个
    `signin.js` 文件；我们在这里也会用到它。我们可以通过以下步骤来设置：
- en: 'Copy the template directory to create a new project, and then copy the `signin.js`
    file into the new directory. You''ll want to add the following line to the top
    of the `server.js` file:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模板目录复制以创建一个新的项目，然后将 `signin.js` 文件复制到新目录中。您需要在 `server.js` 文件的顶部添加以下行：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, as you might recall, this requires a few more Node.js packages. Go ahead
    and install `passport`, `passport-local`, and `bcrypt` by using the following
    command in the terminal:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如您所回忆的那样，这需要安装一些额外的 Node.js 包。请在终端中使用以下命令安装 `passport`、`passport-local` 和
    `bcrypt`：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `bcrypt` and `passport-local` packages are used in the `sigin.js` file,
    but we require `passport` in the `server.js` file; we''ll also create the `users`
    database, as you can see here:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bcrypt` 和 `passport-local` 包在 `sigin.js` 文件中使用，但在 `server.js` 文件中我们需要引入 `passport`；我们还将创建
    `users` 数据库，如下所示：'
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we need to make sure our express application is configured for this.
    Here''s the complete `configure` block that we saw in our photo sharing application:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要确保我们的 express 应用程序已配置好以支持这一点。这是我们之前在照片分享应用中看到的完整的 `configure` 块：
- en: '[PRE3]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we configure `passport` to use the methods that we have in our `signin.js`
    file:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们配置 `passport` 以使用我们在 `signin.js` 文件中的方法：
- en: '[PRE4]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to create the routes for logging in, logging out, and making user accounts.
    If the user is getting the `/login` route, we''ll render the `login.ejs` (coming
    soon) file. Once they enter a username and password, the results will be saved
    to the `/login` route with the help of the POST request, where authentication
    will occur. Then, to log out at `/logout`, we''ll call the `logout` method that
    `passport` has added to the request object, and redirect back to the root. So,
    here are the routes:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建登录、登出和创建用户账户的路线。如果用户正在获取`/login`路由，我们将渲染`login.ejs`（即将推出）文件。一旦他们输入用户名和密码，结果将通过POST请求保存到`/login`路由，其中将进行身份验证。然后，要在`/logout`登出，我们将调用`passport`添加到请求对象中的`logout`方法，并重定向回根路由。因此，以下是这些路由：
- en: '[PRE5]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last route related to user accounts is the `/create` route; this is the
    route that will be used to create new accounts. It''s a lot of code, but it''s
    pretty basic. We create an attributes object with the username and hashed password.
    Then, we check to see if the user exists. If they do, we go back to the root route.
    Otherwise, we''ll create the user account and redirect to the root route, the
    difference being that we are now logged in. The following is the code for the
    `/create` route:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与用户账户相关的最后一个路由是`/create`路由；这是用于创建新账户的路由。代码很多，但非常基础。我们创建一个包含用户名和散列密码的属性对象。然后，我们检查用户是否存在。如果存在，我们将返回根路由。否则，我们将创建用户账户并重定向到根路由，区别在于我们现在已登录。以下是为`/create`路由的代码：
- en: '[PRE6]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The final flare for this portion is the `login.ejs` file, in the `views` directory.
    As you'll see, from all the extra classes and wrapping elements, we will use Twitter
    Bootstrap again. However, this time, we'll not use the default version. You can
    go to Bootswatch ([http://bootswatch.com](http://bootswatch.com)) to find other
    themes based on Bootstrap; all the same classes, but different styling. This way,
    you can choose any theme from Bootswatch that you'd like and get a different skin
    to your application, but you don't need to change the HTML code at all. I'm going
    to choose the Simplex theme ([http://bootswatch.com/simplex](http://bootswatch.com/simplex)),
    but you can choose a different one if you prefer. Download the CSS file and add
    it to the `public` directory. As you can see from the following template, we'll
    also have our own style sheet, `style.css` of the `public` directory, for a few
    customizations. We'll add to this file later.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此部分的最后一击是`login.ejs`文件，位于`views`目录中。正如您将看到的，我们将再次使用Twitter Bootstrap的所有额外类和包装元素。然而，这次，我们将不使用默认版本。您可以去Bootswatch（[http://bootswatch.com](http://bootswatch.com)）找到基于Bootstrap的其他主题；所有相同的类，但不同的样式。这样，您可以从Bootswatch中选择您喜欢的任何主题，并为您的应用程序获得不同的外观，但您不需要更改任何HTML代码。我将选择Simplex主题（[http://bootswatch.com/simplex](http://bootswatch.com/simplex)），但如果您更喜欢，您可以选择不同的一个。下载CSS文件并将其添加到`public`目录中。正如以下模板所示，我们还将有自己的样式表，即`public`目录中的`style.css`，进行一些自定义。我们稍后会添加到这个文件中。
- en: 'Here''s what should go inside the `login.ejs` file:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是`login.ejs`文件中应该包含的内容：
- en: '[PRE7]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next step is the root/catch-all route. If a user is logged in, we''ll render
    the `index.ejs` file; otherwise, we''ll have to redirect to `/login`. This is
    a good first version of the root route; if the `req.user` value is not set, we''ll
    redirect to the login page. Otherwise, we''ll render the index template. Here''s
    the code for this route:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是根/通配符路由。如果用户已登录，我们将渲染`index.ejs`文件；否则，我们必须重定向到`/login`。这是根路由的一个很好的初始版本；如果`req.user`值未设置，我们将重定向到登录页面。否则，我们将渲染索引模板。以下是此路由的代码：
- en: '[PRE8]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Subscribing to and storing podcasts
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅和存储播客
- en: This application is a little different from our previous applications in terms
    of the data that we need to store. Before, we've always stored only data that
    we get from the user. This time, a user is only going to give us a URL—the path
    to a podcast feed—and we have to get all the data from that. Then, later, we need
    to check that same source for updates. This requires a lot more work on our part.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的应用程序相比，这个应用程序在需要存储的数据方面略有不同。以前，我们总是只存储从用户那里获得的数据。这次，用户将只给我们一个URL——播客源路径——我们必须从那里获取所有数据。然后，稍后，我们需要检查相同的源以获取更新。这需要我们做更多的工作。
- en: 'You might be thinking about how we''re going to get this podcast data. Of course,
    there are only two places from which we can pull in this data: the client and
    the server. Both are possible; however, things will go a lot more smoothly if
    we choose to get this data on the server side. Here''s why: to prepare the data
    on the client side would require us to first get the feed (which is a little more
    than simple, because it''s a cross-domain request); then, we have to parse that
    to get the podcast and episode data we need, before sending the data back to the
    server for storage. This could take a rather long time, especially if the podcast
    has many episodes. If the user closes the application during this process, all
    or part of the data will be lost, and things could get messy. It''s much better
    to do all that work on the server side, where the processing can continue even
    if the user closes their browser tab. So, we will focus on data processing next.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想我们如何获取这些播客数据。当然，我们只能从两个地方获取这些数据：客户端和服务器。两者都是可能的；然而，如果我们选择在服务器端获取这些数据，事情将会更加顺利。原因如下：在客户端准备数据需要我们首先获取源（这比简单的请求要复杂一些，因为它是跨域请求）；然后，我们必须解析它以获取所需的播客和剧集数据，然后再将数据发送回服务器进行存储。这可能需要相当长的时间，尤其是如果播客有很多剧集的话。如果用户在处理过程中关闭了应用程序，所有或部分数据将会丢失，事情可能会变得一团糟。在服务器端做所有这些工作会更好，因为即使用户关闭了浏览器标签，处理也可以继续。所以，我们将重点关注数据处理。
- en: Now, there's going to be a fair bit of code involved in getting the podcast
    data, so we're going to create a custom Node.js module especially to work with
    podcasts. So, create a `podcasts.js` file in the project directory, and let's
    get started.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，获取播客数据将涉及相当多的代码，因此我们将创建一个专门的 Node.js 模块来处理播客。所以，在项目目录中创建一个 `podcasts.js`
    文件，然后我们开始吧。
- en: 'First off, there are two other Node.js packages that we are going to use in
    this module:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在本模块中使用另外两个 Node.js 包：
- en: '**xml2js** ([https://www.npmjs.org/package/xml2js](https://www.npmjs.org/package/xml2js))
    will allow us to convert the podcast feed XML into JSON; it really won''t be pretty
    JSON, but it will be usable.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**xml2js** ([https://www.npmjs.org/package/xml2js](https://www.npmjs.org/package/xml2js))
    将允许我们将播客源 XML 转换为 JSON；这不会是一个很漂亮的 JSON，但它将是可用的。'
- en: '**q** ([https://www.npmjs.org/package/q](https://www.npmjs.org/package/q))
    is an asynchronous promises library.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**q** ([https://www.npmjs.org/package/q](https://www.npmjs.org/package/q))
    是一个异步承诺库。'
- en: 'So, install these two packages by executing this command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过执行以下命令来安装这两个包：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you haven''t worked with promises before, you can think about them like
    this: often in JavaScript, you''ll pass a callback to a function call so that
    the function can be run after some data is ready; a **promise** is an object that
    encapsulates that expected data. You can pass that promise object around and add
    multiple callbacks to it, all of which will be run when the data is ready. You
    can even add callbacks after the data is ready (of course, those will be run right
    away). For a really good introduction and explanation of promises, I recommend
    you check out the great article *JavaScript Promises ... In Wicked Detail* by
    Matt Greer ([http://mattgreer.org/articles/promises-in-wicked-detail/](http://mattgreer.org/articles/promises-in-wicked-detail/)).
    It will explain their benefits and how to use them.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过承诺（promises），你可以这样理解：在 JavaScript 中，你通常会在函数调用时传递一个回调函数，以便在数据准备就绪后运行该函数；**承诺**是一个封装预期数据的对象。你可以传递这个承诺对象，并对其添加多个回调函数，所有这些回调函数将在数据就绪时运行。你甚至可以在数据就绪后添加回调函数（当然，这些会立即运行）。对于承诺的详细介绍和解释，我推荐你阅读
    Matt Greer 的优秀文章 *JavaScript Promises ... In Wicked Detail* ([http://mattgreer.org/articles/promises-in-wicked-detail/](http://mattgreer.org/articles/promises-in-wicked-detail/))。它将解释它们的优点以及如何使用它们。
- en: 'In the `podcasts.js` file, we''ll require the following libraries:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `podcasts.js` 文件中，我们需要引入以下库：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We require the native-to-Node.js `http` library so that we can make a request
    for the podcast feed file. Also, we will create two Bourne databases here: one
    for podcasts, and the other for episodes. We won''t even need to access these
    databases from the `server.js` file.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 Node.js 的原生 `http` 库，以便我们可以请求播客源文件。此外，我们还将创建两个 Bourne 数据库：一个用于播客，另一个用于剧集。我们甚至不需要从
    `server.js` 文件中访问这些数据库。
- en: 'The following is the first method we''ll write for getting the actual feed
    file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要编写的第一个获取实际源文件的函数：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The method takes a URL and passes it to the `http.get` method. The callback
    we give to that method gets a response object. We can listen for the `data` event
    on that object and concatenate the data into a string, which we''ll name `xml`.
    Then, when the request is finished (signaled by the `end` event), we use the XML
    string to resolve the `deferred` object we create at the top of the method. At
    the end of the method, we return the `promise` object for our `deferred` object.
    Now, we can use this method as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接收一个 URL 并将其传递给 `http.get` 方法。我们提供给该方法的回调函数会接收到一个响应对象。我们可以在该对象上监听 `data`
    事件，并将数据连接成一个字符串，我们将其命名为 `xml`。然后，当请求完成时（由 `end` 事件表示），我们使用 XML 字符串解析方法中创建的 `deferred`
    对象。方法结束时，我们返回 `deferred` 对象的 `promise` 对象。现在，我们可以像以下代码所示使用这个方法：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `promise` object we return has a `then` method. The value that we pass
    to the `deferred` object''s `resolve` method will be passed as a parameter to
    the function we pass to the `then` method when the request is complete. So this
    is how we get the XML data for a podcast. Now, we need to convert it to JSON and
    get the values that we want. The `parse` function looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回的 `promise` 对象有一个 `then` 方法。我们传递给 `deferred` 对象的 `resolve` 方法的值将被作为参数传递给我们在请求完成后传递给
    `then` 方法的函数。因此，这就是我们获取播客的 XML 数据的方式。现在，我们需要将其转换为 JSON 并获取我们想要的值。`parse` 函数看起来是这样的：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `parse` function takes the XML input. We pass the XML input to the `parseString`
    function from `xml2js` to convert it to JSON. Then, we can start pulling the data
    we want out of the result. Unfortunately, `xml2js` doesn't give us a very clean
    JSON structure to work with; almost every value is an array, but most only have
    a single value in them. That's why we get the first element of an array in every
    case. Where the element has attributes instead of child elements, `xml2js` uses
    a property named `$`. Once we get the general information about the podcast and
    the data for each episode, we put them into an object that goes to resolving another
    promise.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse` 函数接收 XML 输入。我们将 XML 输入传递给 `xml2js` 的 `parseString` 函数以将其转换为 JSON。然后，我们可以开始从结果中提取我们想要的数据。不幸的是，`xml2js`
    并没有给我们一个很干净的 JSON 结构来工作；几乎每个值都是一个数组，但大多数只有一个值。这就是为什么我们在每种情况下都获取数组的第一元素。当元素有属性而不是子元素时，`xml2js`
    使用一个名为 `$` 的属性。一旦我们获取了关于播客的一般信息和每个剧集的数据，我们将它们放入一个对象中，该对象将用于解决另一个承诺。'
- en: With these two methods in place, we can now create a `Podcast` constructor function
    as a handy wrapper that is used to manage an individual podcast. This constructor
    function will need to work in two ways to be most useful in our `server.js` file.
    If we pass it a URL, it will assume we're creating a new podcast record, and will
    get and store the data. However, if we pass it a number, if will assume that the
    number is the ID of an already-stored podcast, and get that out of the database.
    Since storing and fetching this data will be asynchronous operations, we'll use
    promises to wait for the right time to act.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这两个方法，我们可以创建一个 `Podcast` 构造函数，作为一个方便的包装器来管理单个播客。这个构造函数需要以两种方式工作，以便在
    `server.js` 文件中最为有用。如果我们传递给它一个 URL，它将假设我们正在创建一个新的播客记录，并将获取并存储数据。然而，如果我们传递给它一个数字，它将假设这个数字是已存储播客的
    ID，并从数据库中获取该播客。由于存储和获取这些数据将是异步操作，我们将使用承诺来等待合适的行动时机。
- en: 'So, the `Podcast` constructor is a rather large function; we''ll take it piece
    by piece. We will start with the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Podcast` 构造函数是一个相当大的函数；我们将逐部分进行解析。我们将从以下代码开始：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `feed` parameter will be either the URL or the ID, as we discussed earlier.
    The `userId` parameter will be the ID of the user who is subscribing to this podcast.
    Then, we''ll create two deferred objects called `info` and `episodes`. We assign
    their promises as properties of the object we will create with this function so
    that we can use them when they are ready. We''ll also create a `ready` property;
    this is another promise object that will resolve when all the promises we pass
    it in an array are resolved. This makes for a nice convenient way to do something
    when both the `info` and `episodes` promises are ready. You can see this in the
    following code, which is the next part of the `Podcast` function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`feed`参数将是之前讨论过的URL或ID。`userId`参数将是订阅此播客的用户的ID。然后，我们将创建两个延迟对象，分别称为`info`和`episodes`。我们将它们的承诺作为我们将使用此函数创建的对象的属性，以便在它们准备好时使用。我们还将创建一个`ready`属性；这是一个承诺对象，当我们将它传递到数组中的所有承诺都解决时，它将解决。这为在`info`和`episodes`承诺都准备好时做某事提供了一个方便的方法。您可以在以下代码中看到这一点，这是`Podcast`函数的下一部分：'
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the type of the parameter `feed` is a string, we know that we're creating
    a new podcast record. We'll get and parse the feed, using the methods we created
    earlier. Then, we add the feed URL and the `userId` parameter to the `info` property
    of the data we get back. This `info` property is now ready to be stored in the
    database. We'll store it in `pcdb`, the podcasts' database. In the callback for
    that, we'll resolve the `info` deferred object, because the `info` property has
    now been stored (this means our podcast record has an ID in our database).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`feed`参数的类型是字符串，我们知道我们正在创建一个新的播客记录。我们将获取并解析该源，使用我们之前创建的方法。然后，我们将源URL和`userId`参数添加到我们获取的数据的`info`属性中。现在这个`info`属性已经准备好存储在数据库中。我们将它在`pcdb`播客数据库中存储。在回调中，我们将解决`info`延迟对象，因为`info`属性现在已经存储（这意味着我们的播客记录在我们的数据库中有一个ID）。
- en: One of the beautiful things about promises is that we can have multiple `then`
    calls to them. So, even though we created the `this.info` promise to be used outside
    the podcast object, we can wait for its resolution inside as well. That's the
    next step. When the `info` promise resolves, we need to store the episodes. You
    can see why it's important to wait until the podcast record is stored; we need
    to add the podcast's ID as the `podcastID` property to each episode object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的一个美妙之处在于我们可以对它们有多个`then`调用。因此，尽管我们创建了`this.info`承诺用于播客对象外部，我们也可以在内部等待其解决。这是下一步。当`info`承诺解决时，我们需要存储这些剧集。您可以看到为什么等待播客记录存储很重要；我们需要将播客的ID作为`podcastID`属性添加到每个剧集对象中。
- en: Once we have done that, we can insert all the records into the `episodes` database,
    and then use them to resolve the `episodes` promise.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，我们可以将所有记录插入到`episodes`数据库中，然后使用它们来解决`episodes`承诺。
- en: 'Here''s what we do if the `feed` parameter isn''t a string:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`feed`参数不是一个字符串，我们这样做：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the `feed` parameter is not a string, then we have created this podcast record
    previously, and we need to find it. We start by finding the podcast by that ID,
    and resolve the `info` promise. Then, we find all the episodes with that `podcastID`
    property and use them to resolve the `episodes` promise. Believe it or not, that's
    all we need to do for our `Podcast` constructor.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`feed`参数不是一个字符串，那么我们之前已经创建了此播客记录，我们需要找到它。我们首先通过该ID找到播客，并解决`info`承诺。然后，我们找到所有具有该`podcastID`属性的剧集，并使用它们来解决`episodes`承诺。信不信由你，这就是我们为`Podcast`构造函数需要做的全部。
- en: 'Next, we''ll need to be able to check the feed for new episodes. So for this,
    we''ll need an `update` method. This method is a little long and involved, and
    it actually doesn''t do anything too complex. Here''s the outer shell:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要能够检查源以获取新剧集。为此，我们需要一个`update`方法。这个方法有点长且复杂，实际上并没有做太多复杂的事情。以下是外部结构：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We wait for our `this.ready` promise to be resolved; as you'll recall, this
    means that we're waiting for both `info` and `episodes` to be resolved. This promise
    has a `spread` method, which will spread the resolved values for these promises
    out so that each one is received as an individual parameter. As you can see, these
    are the `info` and `oldEpisodes` parameters. Then, we create the `resolve` function,
    which we'll use in several places inside this method. This function will simply
    find all the episodes for this podcast and resolve the deferred with them. So,
    the promise for the `update` method will return all the episodes for this podcast,
    not just the new ones.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待 `this.ready` 的承诺被解决；如您所回忆的，这意味着我们正在等待 `info` 和 `episodes` 都被解决。这个承诺有一个
    `spread` 方法，它将把这些承诺解决后的值展开，使得每个值都作为一个单独的参数被接收。如您所见，这些是 `info` 和 `oldEpisodes`
    参数。然后，我们创建一个 `resolve` 函数，我们将在这个方法内部的好几个地方使用它。这个函数将简单地找到这个播客的所有剧集，并用它们来解决延迟。因此，`update`
    方法的承诺将返回这个播客的所有剧集，而不仅仅是新的剧集。
- en: Now, we'll call this `update` method every time a user loads the applications.
    However, most podcasts update about once a week, so there's no need to check for
    new episodes every time they load the page. So, we'll check once a day. When we
    subscribe to a podcast, we set the `lastUpdated` property to the current date
    and time as a Unix timestamp, using the unary plus operator (the single plus sign
    at the beginning, which is a shortcut for converting a `Date` object to a timestamp.
    Here, we get the current timestamp subtract to get the difference. If there is
    a difference of more than 86,400,000 (that's the number of milliseconds in a day),
    it means that we haven't updated this podcast in the last day, so we'll proceed
    with the update. Otherwise, we'll call resolve, which will just use the current
    episodes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在用户每次加载应用程序时调用这个 `update` 方法。然而，大多数播客大约每周更新一次，所以每次加载页面时检查新剧集是没有必要的。因此，我们将每天检查一次。当我们订阅一个播客时，我们使用一元加运算符（开始处的单个加号，它是将
    `Date` 对象转换为时间戳的快捷方式）将 `lastUpdated` 属性设置为当前日期和时间作为 Unix 时间戳。在这里，我们获取当前时间戳减去以获取差异。如果差异超过
    86,400,000（这是一天中的毫秒数），这意味着我们过去一天没有更新这个播客，所以我们将进行更新。否则，我们将调用 resolve，它将只使用当前的剧集。
- en: 'So, what if we want to do the update? The following code goes in place of the
    `// update the podcast` comment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想进行更新呢？以下代码将替换 `// update the podcast` 注释：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we begin by getting and parsing the XML feed. Then, we check
    to see whether the list of retrieved episodes is greater than the list of current
    episodes. If it is so, we know we have new episodes to store. The next part is
    to figure out what episodes these are. We start by getting just the titles from
    the currently stored episodes, and put that in `oldTitles`. The next step is to
    find all the episodes with titles that aren't in this array; we just use the array's
    `filter` method. Then, we can insert all the remaining ones into the episodes
    database, and call the `resolve` method. If there aren't any new episodes, we'll
    call the `resolve` method anyway. The last step is to update the `lastUpdated`
    property on the podcast record.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们首先获取并解析 XML 提要。然后，我们检查检索到的剧集列表是否大于当前剧集列表。如果是这样，我们知道我们有新的剧集需要存储。下一步是确定这些剧集是什么。我们首先从当前存储的剧集获取标题，并将它们放入
    `oldTitles`。下一步是找到所有标题不在该数组中的剧集；我们只是使用数组的 `filter` 方法。然后，我们可以将所有剩余的剧集插入到剧集数据库中，并调用
    `resolve` 方法。如果没有新的剧集，我们仍然会调用 `resolve` 方法。最后一步是更新播客记录上的 `lastUpdated` 属性。
- en: 'That''s all we need for the `Podcast` class. However, since we expect users
    to subscribe to more than one podcast, let''s make a simple `Podcasts` class to
    contain that behavior:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Podcast` 类，我们需要的就这些了。然而，由于我们预计用户会订阅多个播客，让我们创建一个简单的 `Podcasts` 类来包含这种行为：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we create a `Podcasts` instance, we'll pass it the ID of the user. Then,
    the `all` method will return a promise for all of that user's podcasts, and the
    `get` method will return a single podcast instance. The `updateEpisode` method
    is just a quick way to update a single episode; we'll only be using this to mark
    an episode as listened to. Finally, in a true Node.js module form, we end by exporting
    the `Podcasts` class. That's all we'll need to be able to access from the `server.js`
    file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个`Podcasts`实例时，我们将传递用户的ID。然后，`all`方法将返回一个包含该用户所有播客的promise，而`get`方法将返回单个播客实例。`updateEpisode`方法是一个快速更新单个剧集的方法；我们只会使用这个来标记剧集已收听。最后，在真正的Node.js模块形式中，我们通过导出`Podcasts`类来结束。这就是我们从`server.js`文件中需要访问的所有内容。
- en: 'Speaking of the `server.js` file, let''s go back there for a moment. First,
    pull in your `podcasts.js` file using the following line of code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 说到`server.js`文件，让我们暂时回到那里。首先，使用以下代码行引入你的`podcasts.js`文件：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, in the catch-all route, we want to get the podcasts for the current user.
    Here''s the completed version of that route:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在通配符路由中，我们想要获取当前用户的播客。这是该路由的完成版本：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the user is logged in, we can create a property on the user object `podcasts`.
    This is a new `Podcasts` object, which receives the user ID as the parameter.
    Then, we get the users' podcasts and send these records to the `index.ejs` file,
    along with the username we were sending previously.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已登录，我们可以在用户对象上创建一个`podcasts`属性。这是一个新的`Podcasts`对象，它接收用户ID作为参数。然后，我们获取用户的播客并将这些记录发送到`index.ejs`文件，包括我们之前发送的用户名。
- en: Preparing index.ejs
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备`index.ejs`
- en: 'We''ve already created the `login.ejs` template, which will be displayed before
    a user is logged in. Once the user is logged in, we''ll render the `index.ejs`
    file. Here''s what we''ll start with:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`login.ejs`模板，它将在用户登录之前显示。一旦用户登录，我们将渲染`index.ejs`文件。这是我们开始的地方：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we''ve done in previous applications, we''ll be putting all our content
    inside the `<div id=''#main''>` element. This time, however, we''ll give it a
    Bootstrap class: `container-fluid`. It''s pretty amazing how, just by applying
    the right Bootstrap classes, our application becomes reasonably responsive; we
    don''t have to do any extra work. This time, we start with a bit of content in
    the main `<div>` element. There will be three columns in our application: the
    first will list the podcasts, the second will list the episodes for a selected
    podcast, and the third will show the details of an individual episode.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的应用程序中所做的那样，我们将把所有内容都放在`<div id='#main'>`元素内。这次，然而，我们将给它一个Bootstrap类：`container-fluid`。非常神奇的是，仅仅通过应用正确的Bootstrap类，我们的应用程序就变得相当响应；我们不需要做任何额外的工作。这次，我们在主要的`<div>`元素中开始添加一些内容。我们的应用程序将有三个列：第一个将列出播客，第二个将列出所选播客的剧集，第三个将显示单个剧集的详细信息。
- en: 'At the bottom, we''ll pull in all our script tags; besides the defaults (jQuery,
    Underscore, and Backbone), we''ve got the JavaScript components of Bootstrap.
    This is necessary for the navigation we add later. Then, we have our own three
    files: `models.js`, `views.js`, and `router.js`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，我们将引入所有的脚本标签；除了默认的（jQuery、Underscore和Backbone）之外，我们还有Bootstrap的JavaScript组件。这对于我们稍后添加的导航是必要的。然后，我们有我们自己的三个文件：`models.js`、`views.js`和`router.js`。
- en: Creating our models and collections
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的模型和集合
- en: 'We''ll start with the `models.js` file. There are two types of data we''re
    going to be displaying here: podcasts and episodes. So, we''ll have a model and
    collection for each of these. Let''s start with episodes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`models.js`文件开始。这里我们将展示两种类型的数据：播客和剧集。因此，我们将为每种类型创建一个模型和集合。让我们从剧集开始：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our model class is called `Episode`; we give it a root URL and a `listen` method.
    The `listen` method will mark the episode as listened to, by setting the `listened`
    property to true and saving the update to the server. You'll recall that, by default,
    we set `listened` to `false` for every episode when subscribing to the podcast.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型类被命名为`Episode`；我们给它一个根URL和一个`listen`方法。`listen`方法将通过将`listened`属性设置为true并将更新保存到服务器来标记剧集已收听。你可能还记得，当我们订阅播客时，我们默认将每个剧集的`listened`设置为`false`。
- en: Then, the collection class is called `Episodes`. A collection of episodes will
    need to be associated with a podcast, so we'll get that `podcast` instance from
    the `options` object passed to the `initialize` method. Also, notice that we're
    setting a `url` method on the collection. Often, you'll set a `url` method on
    either the model class or the collection class, but not both. However, we'll need
    two different URLs here. The collection URL will be used to get all the episodes
    of a podcast. The model URL will be used when we mark an episode as listened to.
    The final portion of the collection class is the `comparator`. We want our episodes
    to show up in the right order, with the newest episodes at the top of the list,
    so we'll use the publishing dates as our comparison. Normally, we'd subtract value
    A from value B, but by reversing that, we can get the most recent episode at the
    top.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，集合类被命名为 `Episodes`。一个集合的剧集需要与一个播客相关联，因此我们将从传递给 `initialize` 方法的 `options`
    对象中获取那个 `podcast` 实例。注意，我们在集合上设置了一个 `url` 方法。通常，你会在模型类或集合类上设置一个 `url` 方法，但不会同时设置两个。然而，我们在这里需要两个不同的
    URL。集合 URL 将用于获取播客的所有剧集。模型 URL 将在我们标记剧集为已听时使用。集合类的最后一部分是 `comparator`。我们希望我们的剧集以正确的顺序显示，最新剧集位于列表顶部，因此我们将使用发布日期作为比较。通常，我们会从值
    B 减去值 A，但通过反转这个顺序，我们可以将最新剧集放在顶部。
- en: 'The podcast classes are even simpler, as you can see from the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 播客类甚至更简单，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Podcast` model class's `episodes` method is rather interesting. As we already
    saw, each `Podcast` instance will have a related `Episodes` collection. This method
    will return that collection. What we're doing in this one-line method is returning
    the `this.episodes` property if it exists. If it doesn't, we'll create it, assign
    it, and return it, all in one.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Podcast` 模型类的 `episodes` 方法相当有趣。正如我们之前看到的，每个 `Podcast` 实例都将有一个相关的 `Episodes`
    集合。这个方法将返回那个集合。我们在这一行方法中所做的是，如果存在，则返回 `this.episodes` 属性。如果不存在，我们将创建它、分配它并返回它，所有这些都在一行中完成。'
- en: Building the navigation
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建导航
- en: 'Now, we''re ready to start building our user interface; we can do this by performing
    the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始构建我们的用户界面；我们可以通过执行以下步骤来完成：
- en: 'Open the `views.js` file from the public directory. We''ll start with some
    helper code. You''re familiar with the first part, but the `tmpl` function is
    new. It''s just a small helper function that we''ll use to get our templates.
    We''ll use this method for almost every view. Here''s the code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开公共目录下的 `views.js` 文件。我们将从一些辅助代码开始。你对第一部分很熟悉，但 `tmpl` 函数是新的。它只是一个小的辅助函数，我们将用它来获取我们的模板。我们将使用这个方法为几乎每一个视图。以下是代码：
- en: '[PRE25]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Funnily enough, we''re not going to use the `tmpl` function for the first view;
    the first view is the navigation view. Instead of creating a `template` property
    and choosing a `tagName` property, we''re setting the `el` property. We make this
    property a selector for an element that already exists on the page, and that element
    will become the element for this view. When we click on the **Add Podcast** link,
    we''ll want to display a form. To display this form, we''ll navigate to the `/podcasts/new`
    route. This is the whole class:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很有趣，我们不会为第一个视图使用 `tmpl` 函数；第一个视图是导航视图。我们不是创建一个 `template` 属性并选择一个 `tagName`
    属性，而是设置 `el` 属性。我们使这个属性成为页面上已存在元素的选择器，这个元素将成为这个视图的元素。当我们点击 **添加播客** 链接时，我们希望显示一个表单。要显示这个表单，我们将导航到
    `/podcasts/new` 路由。这是整个类的代码：
- en: '[PRE26]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we need to create the element with the ID `navbar`, as this view is expecting.
    A lot of this is just for Bootstrap, but you can see that we have the **Add Podcast**
    and **Log Out** links. Its code is given as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建具有 ID `navbar` 的元素，因为这个视图期望它。其中很多只是为了 Bootstrap，但你可以看到我们有 **添加播客**
    和 **登出** 链接。其代码如下：
- en: '[PRE27]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since this is already on the page, we don''t have to insert it at any point;
    we''ll just instantiate the router in the class. We''ll do this soon, but the
    screenshot is a sneak peek to what it will look like when we do so:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这已经在页面上，我们不需要在任何地方插入它；我们只需在类中实例化路由器。我们很快就会这样做，但截图是提前看看我们这样做后的样子：
- en: '![Building the navigation](img/6997OS_06_05.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![构建导航](img/6997OS_06_05.jpg)'
- en: 'One more thing: this navigation bar will be fixed to the top of the screen,
    so we need to push everything else down a bit so that none of the content is hidden
    behind it before the user scrolls. It''s very simple; open your `style.css` file
    from the `public` directory, and add the following line of code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再说一件事：这个导航栏将固定在屏幕顶部，所以我们需要将其他所有内容向下推一点，这样在用户滚动之前，内容就不会被隐藏在其后面。这非常简单；从 `public`
    目录打开你的 `style.css` 文件，并添加以下代码行：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Displaying podcasts
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示播客
- en: 'The next step will be to display the list of podcasts that the user is subscribed
    to. We start with the `PodcastListView` class, which will display the collection.
    Here''s that class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是显示用户订阅的播客列表。我们从 `PodcastListView` 类开始，它将显示集合。以下是该类：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For Bootstrap, we''ll add the `list-group` class to the view''s element. In
    the `initialize` method, we''ll check the `options` object for a `current` value.
    If the user has clicked on one of the podcasts in the list to display the episodes,
    we''ll want to highlight that podcast, so `current` will be the ID of the selected
    podcast (if one is selected). Then, we''ll also listen to for new additions to
    the collection we''re displaying. If one is added, we''ll call the `render` method
    again. The `render` method looks for a few different scenarios. If the collection
    is empty (which it will be, at first), we''ll just display **No Podcasts**. Otherwise,
    we''ll clear the element and render each model using the `renderItem` method.
    The `renderItem` method sets a `current` property on each model; if this model
    is the current one, it will be `true`; otherwise, it will be `false`. Then, we''ll
    create a new `PodcastListItemView` instance, render it, and append it to the element.
    Now, we''re ready for this view; this is its code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Bootstrap，我们将 `list-group` 类添加到视图的元素中。在 `initialize` 方法中，我们将检查 `options`
    对象中的 `current` 值。如果用户点击列表中的某个播客以显示剧集，我们将想要突出显示该播客，因此 `current` 将是所选播客的 ID（如果已选择）。然后，我们还将监听显示的集合中的新添加项。如果添加了新项，我们将再次调用
    `render` 方法。`render` 方法会查找几种不同的场景。如果集合为空（最初将是这种情况），我们将只显示 **没有播客**。否则，我们将清除元素并使用
    `renderItem` 方法渲染每个模型。`renderItem` 方法在每个模型上设置一个 `current` 属性；如果这个模型是当前的，它将是 `true`；否则，它将是
    `false`。然后，我们将创建一个新的 `PodcastListItemView` 实例，渲染它并将其附加到元素上。现在，我们准备好这个视图；这是它的代码：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The element for this view is an anchor tag with the `list-group-item` class.
    We get the `podcastItem` template, which is fairly simple. Add the following code
    to the `index.ejs` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图的元素是一个带有 `list-group-item` 类的锚标签。我们获取 `podcastItem` 模板，它相当简单。将以下代码添加到 `index.ejs`
    文件中：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this `initialize` method, we''ll get the episodes collection for this podcast
    model and listen for the `count` event; when it occurs, we''ll call the `displayCount`
    method. But before we write that method, we''ll render the view. First, we''ll
    render the template. Then, we''ll set the `href` property on this element (remember,
    it''s an anchor); this will be the URL for the podcast instance. If this is the
    current podcast, we''ll add the active class to the element. Finally, we''ll call
    the `displayCount` method. Here''s that method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `initialize` 方法中，我们将获取这个播客模型的剧集集合并监听 `count` 事件；当它发生时，我们将调用 `displayCount`
    方法。但在我们编写该方法之前，我们将渲染视图。首先，我们将渲染模板。然后，我们将设置此元素的 `href` 属性（记住，它是一个锚点）；这将是为播客实例的
    URL。如果是当前播客，我们将向元素添加活动类。最后，我们将调用 `displayCount` 方法。以下是该方法：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this method, we get the episodes collection for the podcast and fetch the
    data from the server. When it arrives, we pluck the value of the `listened` property
    from each episode model; this will be an array of Boolean values. Then, we filter
    out all the `true` values, so we only have the `false` values left. The length
    of the resulting array is the number of podcasts that have not been listened to.
    Then, we put that number into the badge element of our template.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们获取播客的剧集集合并从服务器获取数据。当数据到达时，我们从每个剧集模型中提取 `listened` 属性的值；这将是一个布尔值数组。然后，我们过滤掉所有
    `true` 值，这样我们只剩下 `false` 值。结果数组的长度是尚未收听的播客数量。然后，我们将那个数字放入模板的徽章元素中。
- en: One last thing; if you haven't seen the `.bind(this)` trick before, this just
    keeps the value of `this` inside the function the same as it is outside the function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点；如果你之前没有见过 `.bind(this)` 的技巧，这个技巧只是保持函数内部 `this` 的值与函数外部相同。
- en: 'Finally, have a look at the `events` property. When this view''s element is
    clicked on, we''ll redirect to the model''s URL, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看看`events`属性。当这个视图的元素被点击时，我们将重定向到模型的URL，如下所示：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating a layout
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建布局
- en: 'With these views in place, we''re almost ready to start the router. Open the
    `router.js` file from the `public` directory. Now, in the previous chapter, we
    were using Marionette, and it gave us regions and layouts to manage where our
    views went. We don''t have them now, but since they were so useful, why don''t
    we make them ourselves? We can create it with the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些视图就绪后，我们几乎准备好开始路由器了。打开`public`目录中的`router.js`文件。现在，在上一章中，我们使用了Marionette，它为我们提供了区域和布局来管理我们的视图去哪里。我们现在没有它们，但既然它们非常有用，为什么不自己创建它们呢？我们可以用以下代码创建它：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When we create a region, we'll pass it a selector. Then, the `show` method will
    take one or more views. If we pass only a single view, we'll wrap it in an array.
    Then, we'll loop and append each view to the element. Notice that we're calling
    the `render` method and getting the element for the views here, so we only have
    to pass the view instance to this method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个区域时，我们将传递一个选择器。然后，`show`方法将接受一个或多个视图。如果我们只传递一个视图，我们将将其包裹在一个数组中。然后，我们将循环并将每个视图附加到元素上。请注意，我们在这里调用`render`方法并获取视图的元素，所以我们只需要将视图实例传递给此方法。
- en: 'If duplicating regions was easy, creating your own layout will be a piece of
    cake; we will create our layout by using the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果复制区域很容易，创建自己的布局将变得轻而易举；我们将使用以下代码来创建我们的布局：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Beginning the router
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始路由器
- en: 'Now, we are ready to start the router. The following is our `Router` code for
    the `router.js` file; we can start with this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好开始路由器了。以下是我们`router.js`文件的`Router`代码；我们可以从这里开始：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the router is created, we'll accept a `podcasts` collection. We'll also
    create our `NavView` instance; remember, since the elements for this are already
    on the page, we don't have to append them. We're ready to take the root route
    with the `index` method; when that happens, we'll use our `layout.podcasts` region
    to show a `PodcastListView` instance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器创建时，我们将接受一个`podcasts`集合。我们还将创建我们的`NavView`实例；记住，因为这个元素已经在页面上，所以我们不需要附加它们。我们准备好使用`index`方法接受根路由；当发生这种情况时，我们将使用我们的`layout.podcasts`区域来显示一个`PodcastListView`实例。
- en: 'To use this router, let''s add another script tag to the `index.ejs` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个路由器，让我们向`index.ejs`文件添加另一个脚本标签：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Subscribing to new podcasts
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅新播客
- en: 'We have all the functionality we need to display podcasts; now, let''s create
    a form to be used when subscribing to new podcasts. As we determined earlier,
    in our `Podcast` module, all we need to get from the user is the podcast feed
    URL. So, let''s create our `NewPodcastView` class. First, here''s the template
    for this view:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了显示播客所需的所有功能；现在，让我们创建一个用于订阅新播客的表单。正如我们之前确定的，在我们的`Podcast`模块中，我们只需要从用户那里获取播客源URL。因此，让我们创建我们的`NewPodcastView`类。首先，这是这个视图的模板：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, it''s a simple form with a text input and a button. With this
    in place, we can now write the actual view:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个简单的表单，包含一个文本输入和一个按钮。有了这个，我们现在可以编写实际的视图：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We'll give the element a `list-group-item` class and get the template. The rendering
    is very simple, and we're listening for a click on the button. When that happens,
    we'll get the feed from the field and replace the form with the text **Loading**.
    Then, we create a new podcast in the collection of podcasts that we'll associate
    with this view. The only property we need is the feed. Now, remember that our
    `PodcastListView` class will be listening for new models added to this collection.
    However, we need it to wait until the data has been stored in the server, so it
    has an ID and episodes to count. So, we'll add the `wait` option to this create
    call. Also, upon the successful completion of this request, we'll call this view's
    `remove` method to remove it from the UI. Finally, we'll navigate back to the
    home route (not triggering it, notice, because there's no need; we've just removed
    the form).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给元素添加一个`list-group-item`类并获取模板。渲染非常简单，我们正在监听按钮的点击。当发生这种情况时，我们将从字段获取源并替换表单为文本**加载中**。然后，我们在与这个视图关联的播客集合中创建一个新的播客。我们需要的唯一属性是源。现在，记住我们的`PodcastListView`类将监听添加到这个集合中的新模型。然而，我们需要它等待数据已存储在服务器上，以便它有一个ID和可以计数的剧集。因此，我们将添加`wait`选项到这个创建调用中。此外，在请求成功完成后，我们将调用这个视图的`remove`方法来从UI中移除它。最后，我们将导航回主页路由（不会触发它，请注意，因为没有必要；我们只是移除了表单）。
- en: 'We''re adding the `loading` class to the view''s element while the data is
    being fetched on the server. Open the `style.css` file from the `public` directory,
    and add the following styling:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器正在获取数据时，我们在视图的元素上添加 `loading` 类。打开 `public` 目录中的 `style.css` 文件，并添加以下样式：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We use a bit of CSS3 here; the element will pulse from red to white while the
    server is doing its work. Note that I'm using the standard CSS3 syntax here. At
    the time of writing this book, however, some browsers still require proprietary
    prefixes, so you'll have to add the code for the browsers you want to support.
    Of course, there are plenty of tools to assist you with this; Compass ([http://compass-style.org/](http://compass-style.org/))
    is a good place to start.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一些 CSS3；当服务器正在工作时，元素将从红色脉冲到白色。请注意，我正在使用标准的 CSS3 语法。然而，在撰写本书时，一些浏览器仍然需要专有前缀，因此您必须为要支持的浏览器添加代码。当然，有许多工具可以帮助您完成这项工作；Compass
    ([http://compass-style.org/](http://compass-style.org/)) 是一个很好的起点。
- en: 'Now, we''ll update the router with the route for adding a podcast. First, add
    the route to the route objects using the following line of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更新路由器以添加播客的路由。首先，使用以下代码行将路由添加到路由对象中：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we need to write the `newPodcast` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要编写 `newPodcast` 方法：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It's pretty simple; like we do in the `index` method, we'll create and render
    a new `PodcastListView` instance. However, we keep a reference to the view and
    append our form to it; this way, the form will be displayed like another item
    in the list.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；就像我们在 `index` 方法中所做的那样，我们将创建并渲染一个新的 `PodcastListView` 实例。然而，我们保留对视图的引用，并将我们的表单附加到它上；这样，表单就会像列表中的另一个条目一样显示。
- en: 'The last step in subscribing to podcasts is the server code. We need to manage
    the POST request that will occur when the user saves a new feed. In the `server.js`
    file, add the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅播客的最后一步是服务器代码。我们需要管理当用户保存新的源时发生的 POST 请求。在 `server.js` 文件中，添加以下代码：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can use the user''s `podcasts` object to get the new podcast by its feed.
    We wait until the `info` promise is ready, and send the data back to the client.
    Now, we can successfully subscribe to podcast. Give it a try; start up the application,
    create a user account, and subscribe to a few podcasts. The result should be similar
    to the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用用户的 `podcasts` 对象通过源获取新的播客。我们等待 `info` promise 准备就绪，并将数据发送回客户端。现在，我们可以成功订阅播客。试试看；启动应用程序，创建用户账户，并订阅几个播客。结果应该类似于以下截图：
- en: '![Subscribing to new podcasts](img/6997OS_06_01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![订阅新的播客](img/6997OS_06_01.jpg)'
- en: Displaying the list of episodes
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示剧集列表
- en: 'Now that we can subscribe to podcasts, let''s work on displaying the list of
    them. We have the `Episode` model and the `Episodes` collection. We''ll start
    with the collection view `EpisodesView`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够订阅播客了，让我们来显示播客列表。我们有 `Episode` 模型和 `Episodes` 集合。我们将从集合视图 `EpisodesView`
    开始：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once again, this element will have the class `list-group`. You'll notice that
    in the `initialize` method, we expect `region` as one of the `options` object's
    properties. Keep this in mind, and we'll use it later.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个元素将具有类 `list-group`。你会在 `initialize` 方法中注意到，我们期望 `region` 是 `options`
    对象属性之一。请记住这一点，我们稍后会用到它。
- en: 'In the `render` method, we loop over the collection and display an `EpisodeListItemView`
    instance. Notice that we pass `region` along; that''s where we''ll need it. Let''s
    create this class next:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `render` 方法中，我们遍历集合并显示一个 `EpisodeListItemView` 实例。请注意，我们传递了 `region`；那里我们需要它。让我们接下来创建这个类：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we've done with our previous list item view, we'll give this one the class
    `list-group-item`. There's no template here; we'll just set the title of this
    model as the text for the element. Then, if this episode has not been listened
    to, we'll add a class to highlight it, marking it as such. In the `initialize`
    method, notice that we're listening for a change to the `listened` property. When
    that change occurs, we'll call the `markAsListened` method, which will remove
    that class so that the view is no longer highlighted.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的列表项视图中所做的那样，我们将给这个元素赋予类 `list-group-item`。这里没有模板；我们只需将这个模型的标题设置为元素的文本。然后，如果这个剧集尚未收听，我们将添加一个类来突出显示它，标记为已收听。在
    `initialize` 方法中，请注意我们正在监听 `listened` 属性的变化。当这个变化发生时，我们将调用 `markAsListened` 方法，这将移除该类，使视图不再突出显示。
- en: The last method is `displayEpisode`, which will call the region's `show` method,
    passing it an `EpisodeView` instance for the model that this view is displaying.
    This won't just be a title, as we're showing here; it will be the entire model.
    This is why we're passing the region along. Since we're not changing the URL,
    we have to change the content of the page right here. So, that's what we do.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法是`displayEpisode`，它将调用区域的`show`方法，传递一个`EpisodeView`实例作为这个视图显示的模型。这不仅仅是一个标题，因为我们在这里展示的；它将是整个模型。这就是我们传递区域的原因。由于我们没有改变URL，我们必须在这里改变页面的内容。所以，这就是我们做的。
- en: 'There''s one more piece for the list of episodes: a toolbar above it. There''s
    only one tool: **Mark All As Listened**, which is a simple button. Its code is
    as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的剧集还有一个部分：它上面的工具栏。只有一个工具：**标记所有为已听**，这是一个简单的按钮。它的代码如下：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Again, we start with the `className` property; the `render` method is very simple.
    In the `events` property, we wait for a click on the `#mark` button. When that
    happens, we call the `mark` function, which will loop over the collection and
    mark them all as listened to. Then, we trigger the `count` event on the collection;
    we listen for this event to occur in the `PodcastListItemView` class, where we'll
    update the podcast count.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们从`className`属性开始；`render`方法非常简单。在`events`属性中，我们等待点击`#mark`按钮。当发生这种情况时，我们调用`mark`函数，它将遍历集合并将它们全部标记为已听。然后，我们在集合上触发`count`事件；我们在`PodcastListItemView`类中监听这个事件的发生，我们将更新播客计数。
- en: 'Notice that one of the classes we''re using is the `btn-tools` class. This
    is one of our own creations, and it''s very simple; it just gives our tool bar
    a little more breathing room on the bottom:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的类之一是`btn-tools`类。这是我们自己的创造之一，非常简单；它只是让工具栏底部有更多的空间：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The last step for this is the server component for marking an episode as listened
    to. Here''s the route to add to the `server.js` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的最后一步是为标记剧集为已听的服务器组件。这是要添加到`server.js`文件的路线：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we''re ready to show our list of episodes. In the router of the `router.js`
    file, add the following route:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好显示我们的剧集列表。在`router.js`文件的router中，添加以下路由：
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now for that `podcast` method, here''s its code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看那个`podcast`方法，这是它的代码：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We first render the podcast list, because it's possible that this page will
    be loaded directly. Notice that this time we're setting the `current` option so
    that it will be highlighted in the list. Then, we get the episodes for that podcast
    from the server. Next, in the `episodes` region, we show the views `EpisodesToolsView`
    and `EpisodesView`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先渲染播客列表，因为有可能这个页面会直接加载。注意，这次我们设置了`current`选项，以便它在列表中突出显示。然后，我们从服务器获取该播客的剧集。接下来，在`episodes`区域，我们显示`EpisodesToolsView`和`EpisodesView`视图。
- en: 'To get the episodes from the server, via `episodes.fetch()`, we need another
    server route, as shown in the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器获取剧集，通过`episodes.fetch()`，我们需要另一个服务器路由，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We'll get the `Podcast` object, and then call the `update` method to check for
    new episodes. When that returns, we'll send them to the client as JSON.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获取`Podcast`对象，然后调用`update`方法来检查是否有新剧集。当返回时，我们将它们作为JSON发送到客户端。
- en: 'With this in place, we can now view a list of episodes, as shown in the following
    screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里设置好之后，我们现在可以查看剧集列表，如下面的截图所示：
- en: '![Displaying the list of episodes](img/6997OS_06_02.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![显示剧集列表](img/6997OS_06_02.jpg)'
- en: Now, all that's left is displaying individual podcast episodes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下要做的就是显示单个播客剧集。
- en: Displaying episodes
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示剧集
- en: 'Individual episodes will be displayed in the `EpisodeView` class. Let''s start
    with the template:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 单个剧集将在`EpisodeView`类中显示。让我们从模板开始：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We start with some tools at the top: a **Mark As Listened** button. Then, we
    show the details for the episode: title, duration, and date. Next comes the `audio`
    element; this makes it really easy for users to listen to the podcast right in
    our application. In our case, we only have a single audio source; however, you''ll
    often want to add multiple sources in different formats (MP3, OGG, and so on)
    when using the `audio` element, for maximum browser and OS coverage. Underneath
    the `audio` element, we''ll display the description, which will be the show notes
    for that episode. Here''s the class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从顶部的工具开始：一个**标记为已听**按钮。然后，我们显示剧集的详细信息：标题、时长和日期。接下来是`audio`元素；这使得用户能够在我们的应用程序中直接收听播客变得非常容易。在我们的例子中，我们只有一个音频源；然而，当使用`audio`元素时，你通常会想添加多个不同格式的源（MP3、OGG等），以实现最大的浏览器和操作系统覆盖。在`audio`元素下方，我们将显示描述，这将是对该剧集的节目笔记。以下是类名：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Most of this view is the standard view code; we get the template, and we render
    the template with the model data. We also have a `listen` method, which will be
    called when the user clicks on the **Mark As Listened** button. The one difference
    is that we can't use the `events` property to listen for the `play` event on the
    `audio` element because of the way the `audio` element events works with Backbone.
    So, we get the element and use the `addEventListener` method to listen for that
    event.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图的大部分是标准的视图代码；我们获取模板，并用模型数据渲染模板。我们还有一个`listen`方法，当用户点击**标记为已听**按钮时会被调用。唯一的区别是我们不能使用`events`属性来监听`audio`元素上的`play`事件，因为`audio`元素事件与Backbone的工作方式有关。因此，我们获取元素并使用`addEventListener`方法来监听该事件。
- en: 'This is the last piece. Now, you should be able to view and play episodes of
    the podcast. It looks like what is shown in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一部分。现在，你应该能够查看和播放播客的剧集。它看起来就像以下截图所示：
- en: '![Displaying episodes](img/6997OS_06_03.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![显示剧集](img/6997OS_06_03.jpg)'
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This brings us to the end of this chapter. A lot of what we did in this chapter
    was already familiar to you from previous applications, but there were a few nuggets
    that you shouldn't ignore. The main aspect is the strong server component. It
    is easy to forget that a Backbone application will always have the server code
    behind it, and often that code will be much more than a main template being rendered
    and a bunch of routes that shuttle JSON back and forth. There's often significant
    logic, data handling, and other details that will be taken care of on the server.
    As we saw, it's often possible to perform this logic on either the client or the
    server—we could have captured the RSS feed and processed it in either position.
    When building your own applications, it's important to make good decisions about
    where processes take place. It's often much quicker to do something on the client
    (no request/response to wait for), but you'll probably have more power and ability
    on the server, so the time delay might be negligible. The decision will be different
    for every situation, and there often won't be a single right choice.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章的内容。在本章中，我们做的大部分事情你可能已经从之前的实践中熟悉了，但也有一些要点你不应该忽视。主要方面是强大的服务器组件。很容易忘记Backbone应用程序后面总是有服务器代码，而且通常这些代码会远不止渲染一个主模板和传递JSON数据的一堆路由。通常会有大量的逻辑、数据处理和其他细节需要在服务器上处理。正如我们所看到的，通常可以在客户端或服务器上执行这些逻辑——我们可以在任何一个位置捕获RSS源并处理它。当你构建自己的应用程序时，关于在哪里执行过程做出良好的决策是很重要的。在客户端执行某事通常要快得多（无需等待请求/响应），但在服务器上你可能拥有更多的能力和权限，所以时间延迟可能可以忽略不计。每个情况的决定都会不同，而且通常不会有唯一的正确选择。
- en: The other interesting thing we did was recreate some of Marionette's behavior.
    This serves as another reminder that Backbone is just JavaScript, and there's
    no reason you can't write your own code to make it easier for you. There's no
    need to do anything fancy; as we saw, something as simple as our regions and layout
    can really clean up your router.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的另一件有趣的事情是重新创建了一些Marionette的行为。这再次提醒我们，Backbone只是JavaScript，没有理由你不能编写自己的代码来让它更容易使用。没有必要做任何花哨的事情；正如我们所看到的，像我们的区域和布局这样简单的东西真的可以清理你的路由器。
- en: Only one chapter left, and that's where we'll have some fun and build a game.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下最后一章了，我们将有一些乐趣并构建一个游戏。
