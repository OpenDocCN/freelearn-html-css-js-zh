- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: 'It''s time for a more advanced topic. You''re ready! We are going to deal with
    the topic of asynchronous code and some options for multitasking with code. This
    concept is called concurrency. Don''t worry if you find this chapter a bit of
    a struggle; this is programming in JavaScript at a high level. These are the topics
    we''ll be dealing with:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候讨论一个更高级的话题了。你已经准备好了！我们将处理异步代码和代码多任务处理的选项。这个概念被称为并发。如果你觉得这一章有点困难，不要担心；这是在JavaScript中进行的编程，是高级编程。我们将处理以下主题：
- en: Concurrency
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Callbacks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调
- en: Promises
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promise
- en: '`async`/`await`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`/`await`'
- en: Event loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环
- en: Yes, this is tough, but understanding how to leverage concurrency can really
    enhance the performance of your program by speeding up the process, which is more
    than enough reason to dive into this advanced topic!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这很困难，但理解如何利用并发确实可以通过加快处理速度来提高程序的性能，这足以让我们深入这个高级话题！
- en: 'Note: exercise, project, and self-check quiz answers can be found in the *Appendix*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：练习、项目和自我检查测验的答案可以在*附录*中找到。
- en: Introducing concurrency
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍并发
- en: '**Concurrency** is whenever things are happening "at the same time" or *in
    parallel*. To give a non-code example, let''s talk about managing my household.
    When I come home on a Friday night, I have a series of tasks: the kids need to
    eat, to shower, and to be brought to bed, the laundry needs to be folded and laundry
    needs to be put in the machine, and to be fair, a lot more, but this is enough
    to illustrate the example.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是指事物“同时”或*并行*发生。为了给出一个非代码的例子，让我们来谈谈管理我的家庭。当我在周五晚上回家时，我有一系列的任务：孩子们需要吃饭、洗澡，然后被带到床上，衣服需要叠好，洗衣机需要放衣服，而且公平地说，还有很多其他事情，但这些都足以说明例子。'
- en: 'If I were to do this without being able to do multiple things at once, it would
    be a very tough night and get very late. I would first make dinner—put a pizza
    in the oven and wait next to it—feed the kids, shower them afterward, then bring
    them to bed, and then fold the laundry afterward, turn the machine on again, and
    wait until it''s done. Luckily, I can multitask, so it looks more like this: I
    put the pizza in the oven, in the meantime, I turn the washing machine on and
    maybe fold a few pieces of laundry, then I feed the kids, do the rest of the laundry
    while they shower, and I''m done a lot quicker.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我不能同时做很多事情，这将是一个非常艰难的夜晚，而且会非常晚。我首先会做晚饭——把披萨放进烤箱并站在旁边等待——喂孩子吃饭，然后给他们洗澡，然后把他们带到床上，然后叠衣服，再次打开机器，等待它完成。幸运的是，我能够多任务处理，所以看起来更像是这样：我把披萨放进烤箱，同时，我打开洗衣机并可能叠几件衣服，然后我喂孩子吃饭，在他们洗澡的时候做剩下的衣服，我很快就完成了。
- en: This is the same for your computer and the applications that you use. If it
    weren't able to do multiple things at the same time, you would probably be very
    annoyed. You wouldn't be able to check your mail while you are writing code, you
    wouldn't be able to listen to music while writing code, and a lot more. This is
    your computer switching between different tasks. The same thing can happen at
    the application level. For example, we can do a call to some API and not wait
    for the reply but do something useful in the meantime instead. We can do so using
    the concept of **concurrency**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于你的电脑和你使用的应用程序。如果它不能同时做很多事情，你可能会非常烦恼。你不可能在写代码的同时检查邮件，你不可能在写代码的同时听音乐，还有很多其他事情。这是你的电脑在不同任务之间切换。同样的事情也可以在应用层面上发生。例如，我们可以调用某个API，而不等待回复，而是在此期间做些有用的事情。我们可以使用**并发**的概念来实现这一点。
- en: 'There are three strategies in JavaScript that you''ll need to know of when
    working with concurrency: **callbacks**, **Promises**, and the **async** and **await**
    keywords.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理并发时，JavaScript中有三种策略你需要了解：**回调**、**Promise**以及**async**和**await**关键字。
- en: Callbacks
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: '**Callbacks** are the first thing we should understand when we are talking
    about concurrency. The good news is that the `callback` principle is not too hard
    to understand. It is just a function that takes another function as an argument,
    which is then called when the rest of the initial function has finished. In other
    words, it''s just a function calling a function, like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调**是我们讨论并发时应该首先理解的东西。好消息是，`回调`原则并不难理解。它只是一个接受另一个函数作为参数的函数，当初始函数的其余部分完成时，这个函数会被调用。换句话说，它只是一个函数调用另一个函数，就像这样：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is an example of the `callback` principle actually doing something:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个`回调`原则实际应用的例子：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two functions here: `judge()` and `getGrade()`. We call the function
    `getGrade()` with two arguments: `85` and the function `judge()`. Note that when
    calling the function as an argument, we do not include the parantheses. The `judge()`
    function gets stored in a `callback`. After determining the grade, the function
    that is stored in a callback (`judge()` in this case) gets called with the grade.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个函数：`judge()` 和 `getGrade()`。我们用两个参数调用 `getGrade()` 函数：`85` 和函数 `judge()`。注意，在将函数作为参数调用时，我们不包括括号。`judge()`
    函数被存储在 `callback` 中。在确定成绩后，存储在回调中的函数（在本例中为 `judge()`）会带着成绩被调用。
- en: This could also be another function that does something more useful than judging,
    for example, sending a certain email based on test results. If we wanted that,
    we actually wouldn't need to change the `getGrade()` function; we just need to
    write a new function to do this and call `getGrade()` with the new function as
    a second argument.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以是另一个比判断更有用的函数，例如，根据测试结果发送特定的电子邮件。如果我们想要这样做，实际上我们不需要更改 `getGrade()` 函数；我们只需要编写一个新的函数来做这件事，并用这个新函数作为第二个参数调用
    `getGrade()`。
- en: You might be very disappointed right now, because this is not too exciting.
    Callbacks become really valuable in an asynchronous context, for example, when
    one function is still waiting for the results of a call to the database before
    calling the `callback` function that is going to process the data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能非常失望，因为这不是很令人兴奋。在异步上下文中，回调变得非常有价值，例如，当一个函数在调用数据库并调用将要处理数据的 `callback` 函数之前仍在等待数据库的调用结果时。
- en: 'Some JavaScript built-in functions work with this callback principle, for example,
    the `setTimeOut()` and `setInterval()` functions. They will take a function that
    is executed after a certain time in the case of a timeout and every certain amount
    of time for the specified interval. We have seen these already, but just as a
    reminder:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 JavaScript 内置函数使用这种回调原则，例如，`setTimeOut()` 和 `setInterval()` 函数。在超时的情况下，它们将执行一个在特定时间后执行的函数，对于指定的间隔，每隔一定时间执行一次。我们已经看到这些了，但只是为了提醒：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The functions that are inserted as arguments are called callbacks here. Understanding
    concurrency really starts with callbacks, but multiple nested callbacks make code
    difficult to read.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数插入的函数在这里被称为回调。真正理解并发性其实是从回调开始的，但是多层嵌套的回调会使代码难以阅读。
- en: When this is all written as one function with anonymous functions inside, this
    gets very indented as well. We call this **callback hell** or the **Christmas
    tree problem** (because the code gets nested so much, it looks like a Christmas
    tree on its side).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些都被写成一个函数，并且内部包含匿名函数时，这个函数的缩进也会很多。我们称之为 **回调地狱** 或 **圣诞树问题**（因为代码嵌套得如此之多，看起来像侧放的圣诞树）。
- en: Callbacks are a great concept, but they can create ugly code very fast. There
    is often a better solution, we promise.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是一个很好的概念，但它们可以快速创建出丑陋的代码。通常有一个更好的解决方案，我们保证。
- en: Practice exercise 13.1
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.1
- en: This exercise will demonstrate how to use a callback function, creating a way
    to pass a value from one function to another by invoking a callback function.
    We will create a greeting callback using a full name in a string.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将演示如何使用回调函数，通过调用回调函数创建一种从函数传递值到另一个函数的方法。我们将使用一个字符串中的全名创建一个问候回调。
- en: Create a function named `greet()` that takes one argument, `fullName`. That
    argument should be an array. Output the items of the array into the console interpolated
    into a greeting message string.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `greet()` 的函数，它接受一个参数 `fullName`。该参数应该是一个数组。将数组的项输出到控制台，并插入到问候消息字符串中。
- en: 'Create a second function that has two arguments: the first one is a string
    for the user''s full name, and the second is the `callback` function.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个函数，它有两个参数：第一个是一个字符串，用于用户的完整名称，第二个是 `callback` 函数。
- en: Split the string into an array using the `split()` method.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `split()` 方法将字符串拆分成一个数组。
- en: Send the full-name array to the `greet()` function created in the first step.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将全名数组发送到第一步中创建的 `greet()` 函数。
- en: Invoke the process of the `callback` function.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `callback` 函数的过程。
- en: Promises
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises
- en: With **Promises**, we can organize the sequence of our code in a slightly easier-to-maintain
    way. A Promise is a special object that connects code that needs to produce a
    result and the code that needs to use this result in the next step.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Promises**，我们可以以稍微更容易维护的方式组织代码的顺序。Promise 是一个特殊的对象，它连接需要产生结果的代码和需要使用这个结果的下一步代码。
- en: When we create a Promise, we give it a function. In the following example, we
    use a convention that we have seen a lot; we are creating a function on the spot.
    So, inside the argument list we are defining the function, often done using arrow
    functions as well. This function needs two parameters, and these parameters are
    callbacks. We have called them `resolve` and `reject` here.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个 Promise 时，我们给它一个函数。在下面的例子中，我们使用了一个我们经常看到的约定；我们现场创建一个函数。所以，在参数列表中，我们定义了这个函数，通常也使用箭头函数。这个函数需要两个参数，这些参数是回调函数。我们在这里称它们为
    `resolve` 和 `reject`。
- en: You can call these parameters anything you want, but `resolve` or `res` and
    `reject` or `rej` are most common.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意命名这些参数，但 `resolve` 或 `res` 和 `reject` 或 `rej` 是最常见的。
- en: When `resolve()` is called, the Promise is presumed to be successful and whatever
    is between the arrows is returned and used as input for the `then` method on the
    `Promise` object. If `reject()` is called, the `Promise` failed and the `catch()`
    method on the `Promise` object (if present) is executed with the argument of the
    `reject()` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `resolve()` 时，假设 Promise 是成功的，并且箭头之间的任何内容都会返回并用作 Promise 对象上 `then()` 方法的输入。如果调用
    `reject()`，则 Promise 失败，并且如果存在，Promise 对象上的 `catch()` 方法会使用 `reject()` 函数的参数执行。
- en: 'This is a lot of information that can be hard to understand at first, so here
    is an example of a Promise to help you:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一大堆信息，一开始可能难以理解，所以这里有一个 Promise 的例子来帮助你：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We first create a Promise. When creating a `Promise`, we don't know what the
    value of the Promise is going to be. This value is whatever is sent as an argument
    to the resolve function. It is a sort of placeholder.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 Promise。在创建 `Promise` 时，我们不知道 `Promise` 的值将是什么。这个值就是发送给解析函数的参数。它是一种占位符。
- en: 'So when we call then on the Promise, we basically say: figure out what the
    value of the Promise is, and when you know, execute one function if the Promise
    was resolved or a different function if it was rejected. When a Promise is neither
    resolved nor rejected, we say that the Promise is pending.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们对 Promise 调用 `then()` 时，我们基本上是在说：找出 Promise 的值，当你知道时，如果 Promise 被解析，则执行一个函数，如果被拒绝，则执行不同的函数。当一个
    Promise 既没有被解析也没有被拒绝时，我们说这个 Promise 是挂起的。
- en: '`then()` is a Promise itself, so when it returns we can use the result for
    the next `then()` instance. This means we can chain the `then()` instances, which
    can look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`then()` 本身也是一个 Promise，所以当它返回时，我们可以使用结果作为下一个 `then()` 实例的输入。这意味着我们可以链式调用 `then()`
    实例，这可以看起来像这样：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will log:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The resolve functions are implemented with an arrow function. The `return`
    statement is the `value` input for the next function. You can see that the last
    block is a `catch()` function. If any of the functions were to result in a rejection
    and the Promise were therefore rejected, this `catch()` block would be executed
    and print whatever the `reject()` function sent to the `catch()` method. For example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 解析函数是用箭头函数实现的。`return` 语句是下一个函数的 `value` 输入。你可以看到最后一个块是一个 `catch()` 函数。如果任何一个函数导致拒绝，并且因此
    Promise 被拒绝，那么这个 `catch()` 块就会被执行，并打印出 `reject()` 函数发送给 `catch()` 方法的任何内容。例如：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will just log `oops…` because the first Promise was rejected instead of
    resolved. This is great for creating asynchronous processes that need to wait
    till another process is complete. We can try to do a certain set of actions and
    when something goes wrong, use a `catch()` method to deal with it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只记录 `oops…`，因为第一个 Promise 被拒绝而不是解析。这对于创建需要等待另一个过程完成的异步过程非常有用。我们可以尝试执行一组特定的操作，如果出现问题，可以使用
    `catch()` 方法来处理。
- en: Practice exercise 13.2
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习第 13.2 节的练习题
- en: In this exercise, you will create a counter that will output the values in sequence
    using Promises.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个计数器，它将使用 Promise 按顺序输出值。
- en: Set up a Promise that resolves with a value of `Start Counting`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个以 `Start Counting` 为值的 Promise。
- en: Create a function named `counter()` that has one argument that gets the value
    and outputs it into the console.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `counter()` 的函数，该函数有一个参数，用于获取值并将其输出到控制台。
- en: 'Set up the next function in the Promise with four `then()` instances, which
    should output a value into the counter function, and return a value which will
    provide input for the subsequent `then()` instance. The returned values should
    be `one`, then `two`, then `three`. The screen output in the console should be
    the following:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用四个 `then()` 实例设置 Promise 的下一个函数，这些实例应该将值输出到计数器函数中，并返回一个值，该值将为后续的 `then()`
    实例提供输入。返回的值应该是 `one`，然后是 `two`，然后是 `three`。控制台屏幕输出应该是以下内容：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: async and await
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async 和 await
- en: We have just seen the `Promise` syntax. With the `async` keyword, we can make
    a function return a Promise. This makes the Promises nicer to read and look a
    lot like synchronous (non-concurrent) code. We can use this Promise just like
    we learned in the previous section, or we can use the more powerful `await` keyword
    to wait until the Promise is done. `await` only works in an asynchronous function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了 `Promise` 语法。使用 `async` 关键字，我们可以让一个函数返回一个 Promise。这使得 Promise 更易于阅读，看起来很像同步（非并发）代码。我们可以像上一节学的那样使用这个
    Promise，或者我们可以使用更强大的 `await` 关键字来等待 Promise 完成。`await` 只在异步函数中有效。
- en: 'In an asynchronous context, we can await other Promises as well, as can be
    seen in this example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步上下文中，我们也可以等待其他 Promise，如下例所示：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Can you figure out what this code does? We call the asynchronous function `talk()`
    three times in a row with no break. Each of these function calls is awaiting the
    `saySomething()` function. The `saySomething()` function contains a new Promise
    that is being resolved with a `setTimeout()` function that waits two seconds before
    resolving with the value of `something` plus `x`. So after two seconds, the three
    functions are done at the same time (or so it seems to the human eye).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你能弄清楚这段代码做了什么吗？我们连续三次调用异步函数 `talk()`，没有中断。每次函数调用都在等待 `saySomething()` 函数。`saySomething()`
    函数包含一个新 Promise，它通过 `setTimeout()` 函数在两秒后解析为 `something` 加 `x` 的值。所以两秒后，三个函数同时完成（或者对人类眼睛来说是这样的）。
- en: 'If the `talk()` function were not asynchronous, it would throw a `SyntaxError`
    because of the `await` keyword. `await` is only valid in asynchronous functions,
    so `talk()` must be asynchronous. Without the `async` and the `await` in this
    example, it would store the result of the function `saySomething()`, a pending
    `Promise`, in words and log that once for every function call:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `talk()` 函数不是异步的，它会因为 `await` 关键字而抛出 `SyntaxError`。`await` 只在异步函数中有效，所以 `talk()`
    必须是异步的。如果没有这个例子中的 `async` 和 `await`，它将把函数 `saySomething()` 的结果，一个挂起的 `Promise`，以文字形式存储，并且每次函数调用时都记录一次：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have now seen the basic building blocks of concurrency. This should prepare
    you for working with concurrency in real life. Concurrency really is an advanced
    topic; debugging it is troublesome, but it is really worth while in terms of performance
    when applied at the right moment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了并发的基石。这应该为你在现实生活中处理并发做好准备。并发确实是一个高级话题；调试它可能会有些麻烦，但正确应用时在性能方面确实值得。
- en: Practice exercise 13.3
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.3
- en: This exercise will demonstrate how to use `await` to wait on a `Promise` inside
    an `async` function. Using `await` and `async`, create a counter with `timeout()`,
    and increment a global counter value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将演示如何使用 `await` 在 `async` 函数中等待一个 `Promise`。使用 `await` 和 `async` 创建一个带有
    `timeout()` 的计数器，并增加全局计数器值。
- en: Create a global value for a counter.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为计数器创建一个全局值。
- en: Create a function that takes one argument. Return the result of a new Promise,
    setting a `setTimeout()` function that will contain the resolve instance.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，它接受一个参数。返回一个新 Promise 的结果，设置一个 `setTimeout()` 函数，该函数将包含解析实例。
- en: Increment the counter within `setTimeout()`, adding one every second. Resolve
    the Promise with the value of the counter and the value of the variable that was
    in the function argument.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setTimeout()` 中增加计数器的值，每秒增加一。用计数器的值和函数参数中的变量值解析 Promise。
- en: Create an asynchronous function that outputs into the console the value of the
    global counter and the value of the argument of the function.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个异步函数，将全局计数器的值和函数参数的值输出到控制台。
- en: Create a variable to capture the returned resolve value from the `await` function.
    Output that result into the console.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来捕获 `await` 函数返回的解析值。将结果输出到控制台。
- en: Create a loop to iterate 10 times, incrementing the value and invoking the `async`
    function, passing the value of the increment variable as the parameter in the
    function.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环，迭代 10 次，增加值并调用 `async` 函数，将增量变量的值作为参数传递给函数。
- en: 'The results should look like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像以下这样：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Event loop
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环
- en: We would like to end this chapter by explaining how JavaScript handles asynchrony
    and concurrency under the hood. JavaScript is a single-threaded language. A thread
    in this context means a *path of execution*. If there is only a single path, this
    means that tasks will have to wait for one another and only one thing can happen
    at a time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望以解释JavaScript在底层如何处理异步和并发来结束本章。JavaScript是一种单线程语言。在这个上下文中，线程意味着一个**执行路径**。如果只有一个路径，这意味着任务将不得不相互等待，并且一次只能发生一件事情。
- en: This single executor is the **event loop**. It's a process that executes the
    actual work. You may wonder about this, because you've just learned about concurrency
    and doing things asynchronously and at the same time. Well, even though JavaScript
    is single-threaded, it doesn't mean that it cannot outsource some tasks and wait
    for them to come back. This is exactly how JavaScript manages to do things in
    a multithreaded manner.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单一的执行器是**事件循环**。这是一个执行实际工作的进程。你可能对此感到疑惑，因为你刚刚学习了并发和异步同时执行事情。好吧，尽管JavaScript是单线程的，但这并不意味着它不能外包一些任务并等待它们返回。这正是JavaScript能够以多线程方式执行事情的原因。
- en: Call stack and callback queue
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用栈和回调队列
- en: JavaScript works with a **call stack**, and all the actions that it has to execute
    are queued up here. The event loop is a process that is constantly monitoring
    this call stack, and whenever there are tasks to do, the event loop does them
    one by one. The tasks on top get executed first.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用**调用栈**，它必须执行的所有操作都排队在这里。事件循环是一个不断监控这个调用栈的进程，每当有任务要做时，事件循环就会逐个执行。最上面的任务先执行。
- en: 'Here''s a tiny script:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小脚本：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here's a visualization of the call stack and event loop for this script.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此脚本的调用栈和事件循环的可视化。
- en: '![Application'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![应用程序'
- en: Description automatically generated](img/B16682_13_01.png)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_13_01.png)
- en: 'Figure 13.1: Visualization of the event loop and the call stack'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：事件循环和调用栈的可视化
- en: 'No multithreading is going on here. But it is here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有多线程在进行。但是它在这里：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `setTimeout()` task gets outsourced to the browser''s web API (more on
    APIs in *Chapter 15*, *Next Steps*). When it''s done, this appears in a special
    place: the **callback queue**. When the call stack is empty (and only then!),
    the event loop will check the callback queue for work to do. If there are any
    callbacks waiting, they''ll be executed, one by one. After every action, the event
    loop will check the call stack for work first.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`任务被外包给浏览器的Web API（关于API的更多内容请见*第15章*，*下一步*）。当它完成时，这会出现在一个特殊的地方：**回调队列**。当调用栈为空（并且只有在这种情况下！）时，事件循环会检查回调队列以查找要执行的工作。如果有任何等待的回调，它们将逐个执行。在每次操作之后，事件循环都会首先检查调用栈上的工作。'
- en: 'Here''s a visualization of the situation with the outsourcing of `setTimeout()`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`setTimeout()`外包情况下的可视化：
- en: '![Shape, square'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状，正方形'
- en: Description automatically generated](img/B16682_13_02.png)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_13_02.png)
- en: 'Figure 13.2: Visualization of the setTimeout being outsourced'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：`setTimeout`外包的可视化
- en: 'When `setTimeout()` expires, the event loop will have done whatever was on
    the **call stack** already, and will check the callback queue and execute any
    tasks on there:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当`setTimeout()`到期时，事件循环将完成调用栈上的所有工作，并检查回调队列，并执行那里的任何任务：
- en: '![Shape, square'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状，正方形'
- en: Description automatically generated](img/B16682_13_03.png)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_13_03.png)
- en: 'Figure 13.3: Visualization of the task on the callback queue'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：回调队列上的任务的可视化
- en: 'And this is what it will output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它将输出的内容：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's see if you read the above text well. What do you think will happen when
    we set the timer to `0`, like here?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否很好地阅读了上面的文本。你认为当我们将计时器设置为`0`时会发生什么，就像这里一样？
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will output the exact same thing. `setTimeout()` will also be outsourced
    when the timer is at `0`. The callback is placed in the callback queue right away,
    but the event loop won't even check the callback queue until the callstack is
    empty. So it will still print `Sorry I'm late` after `9`, even though the timer
    is at `0`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出完全相同的内容。当计时器为`0`时，`setTimeout()`也将被外包。回调立即放入回调队列，但事件循环甚至不会检查回调队列，直到调用栈为空。所以它仍然会在`9`之后打印`Sorry
    I'm late`，尽管计时器为`0`。
- en: Chapter project
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节项目
- en: Password checker
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码检查器
- en: Using an array of allowed passwords, this exercise will create an application
    to check if one of these password string values exists in an array that lists
    all the accepted passwords. Set a Promise to check if the password is valid, and
    upon the result either resolve with the status of true or reject with the status
    of false. Return the check results.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用允许密码的数组，这个练习将创建一个应用程序来检查这些密码字符串值是否存在于一个列出所有接受密码的数组中。设置一个Promise来检查密码是否有效，并根据结果以状态为true解析或以状态为false拒绝。返回检查结果。
- en: Create an array of allowed passwords.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个允许密码的数组。
- en: Create a login function that will check if the argument is a value that is included
    in the passwords array. You can use `indexof()` or the `includes()` method to
    check the array for a value and return a Boolean value of the result.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个登录函数，该函数将检查参数是否是包含在密码数组中的值。您可以使用`indexOf()`或`includes()`方法检查数组中的值并返回结果的布尔值。
- en: The `includes()` method is an array method that can check whether a certain
    value is included among the items in the array. It will return a Boolean value
    depending on the result.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`includes()`方法是一个数组方法，可以检查某个值是否包含在数组中的项中。它将根据结果返回一个布尔值。'
- en: Add a function that returns a Promise. Using `resolve` and `reject`, return
    a JavaScript object with the Boolean of `true` or `false` to indicate the password
    validity status.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个返回Promise的函数。使用`resolve`和`reject`，返回一个JavaScript对象，其中包含布尔值`true`或`false`以指示密码的有效性状态。
- en: Create a function that checks the password, sending it to the login function,
    and using `then()` and `catch()`, outputs the result of either the rejected password
    or the resolved password.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个检查密码的函数，将密码发送到登录函数，并使用`then()`和`catch()`输出拒绝的密码或解析的密码的结果。
- en: Send several passwords, some within the array, others not, to the checker function.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向检查函数发送几个密码，一些在数组中，一些不在。
- en: Self-check quiz
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我检查测验
- en: 'Fix the error in the following code to use the `callback` function:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复以下代码中的错误以使用`callback`函数：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Write down the result of the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录以下代码的结果：
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What line(s) of code need to be added to the preceding function so that there
    is always a result after the function runs that ensures the word `done` is output
    into the console?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要添加哪些代码行到前面的函数中，以确保函数运行后始终有一个结果，该结果确保单词`done`输出到控制台？
- en: 'Update the below code to make the function return a Promise:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新以下代码，使函数返回一个Promise：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've discussed concurrency. Concurrency enables our code to
    do multiple things at the same time and we can determine the order of things using
    callbacks, Promises, and the `async` and `await` keywords. Implementing these
    in your applications and pages will improve the user experience a lot! Users are
    quite demanding nowadays; if a website isn't loading fast enough, they bounce
    (go back to, for example, Google). Concurrency helps to deliver results faster.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了并发。并发使我们的代码能够同时做很多事情，我们可以使用回调、Promise以及`async`和`await`关键字来确定事情的顺序。在您的应用程序和页面上实现这些功能将大大提高用户体验！现在的用户需求很高；如果一个网站加载不够快，他们会跳转（例如，回到Google）。并发有助于更快地交付结果。
- en: The next two chapters are about using JavaScript for modern web development
    and will be dealing with HTML5 and JavaScript and modern JavaScript frameworks
    that are real game-changers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两章将介绍使用JavaScript进行现代Web开发，并将涉及HTML5、JavaScript以及现代JavaScript框架，这些框架是真正的变革者。
