- en: Controllers and View Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器和视图模型
- en: Up until this point, the controllers we wrote for our application were extremely
    basic. They were started with the simple task of sending text responses to the
    client. In the preceding chapter, we updated the controllers so that they render
    an HTML view and send the HTML code to the client instead of a simple text response.
    The primary job of a controller is to act as an entity which holds the logic that
    makes all of the necessary decisions to properly render a response to the client.
    In our case, this means retrieving and/or generating the data necessary for a
    page to appear completely.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 直到目前为止，我们为应用程序编写的控制器非常基础。它们最初只是发送文本响应给客户端的简单任务。在前一章中，我们更新了控制器，使它们呈现HTML视图，并将HTML代码发送给客户端，而不是简单的文本响应。控制器的主要工作是作为一个实体，其中包含使所有必要决定以正确呈现响应给客户端的逻辑。在我们的情况下，这意味着检索和/或生成页面完全显示所需的数据。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Modifying the controllers so that they generate a data model and pass it to
    a view
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改控制器，以便它们生成数据模型并将其传递给视图
- en: Including logic to support uploading and saving image files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括支持上传和保存图像文件的逻辑
- en: Updating the controllers to actually render dynamic HTML
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新控制器以实际呈现动态HTML
- en: Including helpers for the partials that generate the website statistics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括为生成网站统计数据的部分添加辅助程序
- en: Iterating on the UI to include improved usability via jQuery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过迭代UI来改进可用性，使用jQuery
- en: Controllers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: A **controller** can be defined as an entity that will be responsible for manipulating
    models and initiating the View render process with the data received from the
    corresponding models. In the code we have developed so far, we can see that the
    express router instance is used to tie functions to a corresponding route. These
    functions are nothing but controllers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**可以被定义为一个实体，负责操作模型并使用从相应模型接收到的数据启动视图渲染过程。在我们迄今为止开发的代码中，我们可以看到express路由器实例被用来将函数绑定到相应的路由。这些函数就是控制器。'
- en: 'For every route that we create in our router, the following two parameters
    are necessary:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的路由器中创建的每个路由，都需要以下两个参数：
- en: The first parameter is the string for the route itself, which is `/images/:image_id`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是路由本身的字符串，即`/images/:image_id`
- en: The second parameter is a controller function that will be executed when that
    route is accessed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是在访问该路由时将执行的控制器函数
- en: For any route that has anything to do with images, we rely on the image controller.
    Likewise, any route that has anything to do with the home page relies on the home
    controller, and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何与图像有关的路由，我们依赖于图像控制器。同样，任何与主页有关的路由都依赖于主页控制器，依此类推。
- en: The steps we will take to define our controllers in our app are purely organizational
    and based on personal preference. We created our controllers as modules so that
    our router isn't a big, long, convoluted mess of spaghetti code. We could have
    just as easily kept all of the logic contained in our controllers as functions
    directly within the routes themselves, but this would have been an organizational
    mess and made way for a very hard-to-read code to be maintained later on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中定义控制器的步骤纯粹是组织性的，并基于个人偏好。我们将控制器创建为模块，以便我们的路由器不会成为一个冗长混乱的代码堆。我们本可以将所有逻辑直接包含在路由中的函数中，但这样会导致组织混乱，并且后期维护起来会非常难读。
- en: 'As our sample app is fairly small, we currently have only two controllers:
    home and image. It is the responsibility of these controllers to build the appropriate
    View models for our HTML pages and to render the actual pages also. Any logic
    that is required to execute per page and build the View model will be done so
    via our controllers.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的示例应用程序相当小，目前只有两个控制器：主页和图像。这些控制器的责任是为我们的HTML页面构建适当的视图模型，并实际呈现页面。任何需要执行每个页面并构建视图模型的逻辑都将通过我们的控制器完成。
- en: View models
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模型
- en: Given that there is a single HTML View in our app, we will need to attach data
    to that page so that the template that is being rendered can be included in such
    a way that the dynamic areas of the page are replaced with the real content. To
    do this, we will need to generate a View model. During the rendering, the template
    engine will parse the template itself and look for a special syntax that indicates
    that specific sections should be replaced with values from the View model itself
    at runtime. We saw examples of this when we explored the Handlebars template framework
    in the preceding chapter. Think of this as a fancy runtime find and replace of
    your HTML templates--finding variables and replacing them with values stored in
    the View model sent to the template.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们的应用程序中只有一个HTML视图，我们需要将数据附加到该页面，以便渲染的模板可以以这样的方式包含，即页面的动态区域被真实内容替换。为此，我们需要生成一个视图模型。在渲染过程中，模板引擎将解析模板本身，并寻找特殊的语法，指示特定部分应在运行时用视图模型中的值替换。我们在前一章中探索Handlebars模板框架时看到了这样的例子。可以将其视为HTML模板的一个花哨的运行时查找和替换--查找变量并用视图模型中存储的值替换它们。
- en: This process happens at the server, and the result is only sent as a response
    to the HTTP request that our application receives.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程发生在服务器端，结果只作为应用程序接收到的HTTP请求的响应发送。
- en: A View model is typically just a single JavaScript object that can be passed
    to the template. The template contains all of the necessary logic we will need
    to properly render the page. It is the task of the templating engine to produce
    the corresponding HTML by processing the templates with the associated models.
    The View model for a page will typically contain all of the data necessary to
    render the content-specific portions of that page. Using our application as an
    example, the View model for a specific image's page might contain the title of
    the image, its description, the information necessary to display the image, and
    various stats, such as number of likes, Views, and a collection of comments. A
    View model can be as simple or as complex as you like.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型通常只是一个可以传递给模板的JavaScript对象。模板包含了我们渲染页面所需的所有必要逻辑。模板引擎的任务是通过处理与相关模型关联的模板来生成相应的HTML。页面的视图模型通常包含渲染该页面的特定内容部分所需的所有数据。以我们的应用程序为例，特定图片页面的视图模型可能包含图片的标题、描述、显示图片所需的信息，以及各种统计数据，如点赞数、浏览量和评论集合。视图模型可以简单也可以复杂。
- en: The term View model is used here to refer to the data form of the model, which
    will be tied to the template while rendering the HTML via any templating framework.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用术语视图模型来指代模型的数据形式，它将与模板绑定，通过任何模板框架呈现HTML。
- en: Updating the home controller
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新主页控制器
- en: 'If you take a look at our current home controller (`controllers/home.js`),
    you can see that the index function barely has any code in it whatsoever:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看一下我们当前的主页控制器（`controllers/home.js`），您会发现`index`函数几乎没有任何代码：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing we want to do is build a basic View model using sample data
    so that we can see our View model at work. Replace that single `res.render` call
    with the following updated code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是使用示例数据构建一个基本的视图模型，以便我们可以看到我们的视图模型在工作。用以下更新后的代码替换那个单独的`res.render`调用：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we built a basic JavaScript collection of objects. The
    constant we declared is called `ViewModel`, but the name of this constant doesn't
    actually matter and can be whatever you want. The `const ViewModel` is an object
    that contains a single property called `images`, which is in itself an array.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们构建了一个基本的JavaScript对象集合。我们声明的常量称为`ViewModel`，但实际上这个常量的名称并不重要，可以是任何你想要的。`const
    ViewModel`是一个包含一个名为`images`的属性的对象，`images`本身是一个数组。
- en: The `images` array contains four sample images, each with a few basic properties--the
    most obvious properties were decided when deciding what kind of information we
    wanted per image. Each image in the collection has a `uniqueId`, `title`, `description`,
    `filename`, `Views`, `likes count`, and a `timestamp` property.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`images`数组包含四张示例图片，每张图片都有一些基本属性--最明显的属性是在决定我们想要每张图片的哪种信息时决定的。集合中的每张图片都有一个`uniqueId`、`title`、`description`、`filename`、`Views`、`likes
    count`和`timestamp`属性。'
- en: Once we set up our `ViewModel`, we simply pass it as the second parameter to
    the `res.render` call. Doing this while rendering a `View` makes the data in it
    available to the View itself. Now, if you recall from some of the template code
    we wrote for the home `index.Handlebars` View, we had a `{{#each images}}` loop
    that iterated through each image in the image collection of the View model passed
    to the template. Taking another look at our View model we created, we see that
    it only has a single property named `images`. The HTML code inside the Handlebars
    loop will then specifically reference the `uniqueId`, `filename`, and `title`
    properties for each image in the `images` array.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好我们的`ViewModel`后，我们只需将其作为`res.render`调用的第二个参数传递。在渲染`View`时这样做可以使其中的数据对`View`本身可用。现在，如果您回忆一下我们为主页`index.Handlebars`视图编写的一些模板代码，我们有一个`{{#each
    images}}`循环，遍历了传递给模板的视图模型的图片集合中的每张图片。再次查看我们创建的视图模型，我们看到它只有一个名为`images`的属性。Handlebars循环内的HTML代码将明确引用`images`数组中每张图片的`uniqueId`、`filename`和`title`属性。
- en: 'Save the changes to the home controller, launch your app again, and navigate
    to [http://localhost:3300](http://localhost:3300). You should see the four images
    that now appear on the home page in the Newest Images section (although, as you
    can see in the following screenshot, the images are still broken, as we didn''t
    actually create any image files):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改到主控制器，再次启动您的应用程序，并导航到[http://localhost:3300](http://localhost:3300)。您应该在最新图片部分看到现在出现在主页上的四张图片（尽管，正如您在下面的截图中所看到的，这些图片仍然是损坏的，因为我们实际上并没有创建任何图片文件）：
- en: '![](img/8cbdbd36-5f4e-41d5-8c49-0c9851f5f86c.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cbdbd36-5f4e-41d5-8c49-0c9851f5f86c.png)'
- en: The home page has a fairly simple controller and View model, and you might have
    noted that the sidebar is still completely empty. We'll cover the sidebar a little
    later in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 主页有一个相当简单的控制器和视图模型，您可能已经注意到侧边栏仍然完全空白。我们将在本章稍后讨论侧边栏。
- en: Updating the image controller
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新图片控制器
- en: Let's create the controller and View model for the image page. The controller
    for the image will be a little more complex, as we'll write the logic to handle
    the uploading and saving of the image files via the form on the home page.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为图片页面创建控制器和视图模型。图片的控制器会更复杂一些，因为我们将编写处理通过主页表单上传和保存图片文件的逻辑。
- en: Displaying an image
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示图片
- en: The `index` function in the image controller will look almost identical to the
    `index` function from the home controller. The only difference is that instead
    of generating an array of `images`, we will build a `ViewModel` for a single image.
    However, the `ViewModel` for this image will have a little more information than
    the one from the home page since we are building a page that renders a more detailed
    view of an image (versus the thumbnail collection on the home page). The most
    noteworthy inclusion is that of a comments array for the image.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图片控制器中的`index`函数看起来几乎与主页控制器中的`index`函数相同。唯一的区别是，我们不是生成一个`images`数组，而是为单个图片构建一个`ViewModel`。然而，这个图片的`ViewModel`将比主页上的更详细，因为我们正在构建一个更详细的图片视图页面（而不是主页上的缩略图集合）。最值得注意的是图片的评论数组。
- en: 'Taking another look at the original `index` function in our `controllers/image.js`
    file, we can see the simple existing `res.render` line of code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看我们的`controllers/image.js`文件中原始的`index`函数，我们可以看到简单的现有`res.render`代码行：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We want to replace this line with a `ViewModel` and an updated `res.render`
    statement using the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用以下代码替换这行，使用一个`ViewModel`和一个更新后的`res.render`语句：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we declare a new `ViewModel` constant again--this time with an `image`
    property that contains the properties for the single image. In addition to the
    `image` property, there is also a `comments` property, which is an array of `comment`
    objects. You can see that each comment has various properties specific to a comment
    for each image. This JavaScript object is actually a pretty good preview of what
    our real data will wind up looking like once we include logic to connect our app
    to MongoDB.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次声明一个新的`ViewModel`常量--这次有一个包含单个图片属性的`image`属性。除了`image`属性之外，还有一个`comments`属性，它是一个`comment`对象的数组。你可以看到每个评论都有特定于每张图片的评论的各种属性。这个JavaScript对象实际上是我们的真实数据一旦包含了连接我们的应用程序到MongoDB的逻辑后最终会看起来的一个相当不错的预览。
- en: After we build our sample `image` object and its collection of comments, we
    pass that to our `res.render` call, thus sending this new `ViewModel` directly
    to our image's Handlebars template. Again, if you review the HTML code in the
    `image.Handlebars` file, you can see where each property of the `ViewModel` is
    being displayed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了我们的示例`image`对象及其评论集合之后，我们将其传递给我们的`res.render`调用，从而直接将这个新的`ViewModel`发送到我们图片的Handlebars模板。同样，如果你查看`image.Handlebars`文件中的HTML代码，你可以看到`ViewModel`的每个属性在哪里显示。
- en: 'Again, let''s run the application and make sure that our image page appears
    properly:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序，确保我们的图片页面显示正常：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the app is running and you've launched it in your browser, click on any
    of the images that are listed in the Newest Images section of the home page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序运行并在浏览器中启动，点击主页上最新图片部分列出的任何一张图片。
- en: 'This should take you to an individual image page where you will see something
    like the page shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该带你到一个单独的图片页面，你会看到类似以下截图所示的页面：
- en: '![](img/b1d1fc03-f03c-4d4d-9842-084b65b95815.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1d1fc03-f03c-4d4d-9842-084b65b95815.png)'
- en: Note that Title, Description, Likes, Views, and timestamp (converted to a different
    format for user readability) are all now appearing on the page. In addition, you
    can see a few comments listed near the image as well!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标题、描述、喜欢、浏览次数和时间戳（转换为用户可读的不同格式）现在都出现在页面上。此外，你还可以看到图片附近列出了一些评论！
- en: Uploading an image
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传图片
- en: The next feature we will need to implement in our image controller is the logic
    to handle when a user submits an image Upload Image on the home page. Even though
    the form is on the home page of our app, we decided to house the logic to handle
    uploading within our image controller because logically, this makes the most sense
    (since this feature primarily has to do with images, and not the home page per
    se). This was purely a personal decision, and you can house the logic wherever
    you please.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要在我们的图片控制器中实现的下一个功能是处理用户在主页上提交图片上传的逻辑。即使表单在我们应用的主页上，我们决定将处理上传的逻辑放在图片控制器中，因为从逻辑上讲，这是最合理的（因为这个功能主要与图片有关，而不是特定于主页）。这纯粹是个人决定，你可以将逻辑放在任何你喜欢的地方。
- en: You should note that the HTML for the form on the home page has its action set
    to `/images`, and its method is `post`. This perfectly matches the route we set
    up previously, where we listen for a `post` to the `/images` route and call the
    image controller's `create` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到主页上表单的HTML的动作设置为`/images`，方法是`post`。这与我们之前设置的路由完全匹配，我们监听`/images`路由的`post`，并调用图片控制器的`create`函数。
- en: 'The `create` function in our image controller will have a few key responsibilities:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图片控制器中的`create`函数将有一些关键的责任：
- en: It should generate a unique filename for the image, which will also act as an
    identifier
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该为图片生成一个唯一的文件名，这也将作为标识符
- en: It should save the uploaded file to the `filesystem` and ensure that it is an
    `image` file
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该将上传的文件保存到`文件系统`，并确保它是一个`图片`文件
- en: Finally, it should redirect the control to the `image/image_id` route once its
    task is complete, to display the actual image
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一旦任务完成，它应该将控制重定向到`image/image_id`路由，以显示实际的图片
- en: As we will work with the `filesystem` in this function, we will need to include
    a few modules from the Node.js core set of modules, specifically the `filesystem`
    (fs) and the `path` (path) modules.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在这个函数中使用`文件系统`，我们需要包含一些来自Node.js核心模块的模块，特别是`文件系统`（fs）和`路径`（path）模块。
- en: 'Before we begin adding the necessary code for the Upload Image section, we
    will need a small fix to be applied on the configuration of the application. Further,
    we will need to add an extra module in the configure file to support the file
    uploads, namely `multer`. Add it as a dependency to our application using the
    following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为上传图片部分添加必要的代码之前，我们需要对应用程序的配置进行一些小修复。此外，我们还需要在配置文件中添加一个额外的模块来支持文件上传，即`multer`。使用以下命令将其作为应用程序的依赖项添加到我们的应用程序中：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, go to the configuration file that is `server/configure.js` and `require`
    it via:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到配置文件`server/configure.js`并通过`require`引入它：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can place this under the initially required modules in the file. Then,
    insert the following snippet under the Handlebars engine method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此放在文件中最初需要的模块下。然后，在Handlebars引擎方法下插入以下片段：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, our upload actions will work fine, as expected.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的上传操作将正常工作，如预期的那样。
- en: 'Let''s begin by first editing the `controllers/image.js` file and inserting
    the two new require statements at the very top of the file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先编辑`controllers/image.js`文件，并在文件顶部插入两个新的require语句：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, take the `create` function''s original code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，获取`create`函数的原始代码：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace this original code with the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换原始代码：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we created a function called `saveImage` and executed it immediately after
    we declared it. This might look a little odd, but the reason for this will become
    clear when we implement database calls in the following chapter. The main reason
    is that we will call `saveImage` repeatedly to ensure that the unique identifier
    we generated is in fact unique and doesn't already exist in the database as a
    previously saved image's identifier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`saveImage`的函数，并在声明后立即执行它。这可能看起来有点奇怪，但原因将在下一章中实现数据库调用时变得清晰。主要原因是我们将重复调用`saveImage`，以确保我们生成的唯一标识符实际上是唯一的，并且在数据库中不存在作为先前保存的图像标识符。
- en: 'Let''s review a breakdown of the code that will be inserted in the `saveImage`
    function (replacing the `// to do...` comment). I will cover each line of code
    for this function and then give you the entire block of code at the end:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来审查将插入`saveImage`函数中的代码的细分（替换`// to do...`注释）。我将为这个函数的每一行代码进行解释，然后在最后给出整个代码块：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will need to generate a random, six-digit alphanumeric string to represent
    a unique identifier for an image. This identifier will work in a similar fashion
    to other websites that provide short URLs for unique links (for example, *bit.ly*).
    To do this, we will first provide a string of possible characters that can be
    used while generating the random string:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要生成一个随机的六位字母数字字符串，以表示图像的唯一标识符。这个标识符将类似于其他提供唯一链接的网站（例如*bit.ly*）的短链接。为此，我们首先提供一个可能字符的字符串，用于生成随机字符串：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, loop-over for six times and randomly pull out a single character from
    our string of possible characters, appending it in each cycle. By the end of this
    `for` loop, we should have a string that consists of six random letters and/or
    numbers, for example, `a8bd73`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，循环六次，并从可能字符的字符串中随机选择一个字符，在每个循环中将其附加。在这个`for`循环结束时，我们应该有一个由六个随机字母和/或数字组成的字符串，例如`a8bd73`：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we declare three constants: where our uploaded files will be stored temporarily,
    the file extension of the file that was uploaded (for instance, `.png`, `.jpg`,
    and so on), and a destination where the uploaded image should ultimately reside.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了三个常量：我们上传的文件将被临时存储的位置，上传的文件的文件扩展名（例如`.png`，`.jpg`等），以及上传的图像应最终驻留的目的地。
- en: 'For both the latter variables, we will use the path node module, which works
    great while dealing with filenames and paths and getting information from a file
    (such as a file extension). Next, we will move the image from its temporary upload
    path to its final destination:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后两个变量，我们将使用path节点模块，该模块在处理文件名和路径以及从文件中获取信息（例如文件扩展名）时非常有效。接下来，我们将把图像从临时上传路径移动到最终目的地：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code performs some validation. Specifically, it conducts checks
    to make sure that the uploaded file extension matches a list of allowable extensions,
    namely known image file types. If a valid image file was uploaded, it is moved
    from the `temp` folder via the `filesystem`''s `rename` function. Note how the
    `filesystem` (fs) `rename` function takes three parameters: the original file,
    the new file, and a `callback` function.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码执行了一些验证。具体来说，它进行了检查，以确保上传的文件扩展名与允许的扩展名列表匹配，即已知的图像文件类型。如果上传了有效的图像文件，它将通过`filesystem`的`rename`函数从`temp`文件夹中移动。请注意，`filesystem`（fs）`rename`函数接受三个参数：原始文件，新文件和`callback`函数。
- en: The `callback` function is executed once the `rename` is complete. If the node
    doesn't work this way (always relying on `callback` functions), it's quite likely
    that your code will execute immediately following the execution of the `rename`
    function and try to work against a file that doesn't exist yet (that is, the `rename`
    function doesn't even finish doing its work). Using a `callback` function, we
    effectively tell the node that once the `rename` of the file is finished and the
    file is ready and placed where it should be, then it can execute the code in the
    `callback` function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback`函数在`rename`完成后执行。如果节点不是这样工作的（总是依赖于`callback`函数），那么很可能您的代码将在`rename`函数执行后立即执行，并尝试针对尚不存在的文件进行操作（即`rename`函数甚至没有完成其工作）。使用`callback`函数，我们有效地告诉节点，一旦文件的`rename`完成并且文件准备好并放置在应该放置的位置，那么它可以执行`callback`函数中的代码。'
- en: The `else` condition that follow handles the situation when the uploaded file
    was invalid (that is, not an image), so we call the `unlink` function of the fs
    module, which will delete the original file (from the `temp` directory it was
    uploaded to) and then send a simple `JSON 500` with an error message.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的`else`条件处理了上传的文件无效的情况（即不是图像），因此我们调用fs模块的`unlink`函数，该函数将删除原始文件（从上传到的`temp`目录）然后发送一个简单的`JSON
    500`带有错误消息。
- en: 'Here is the complete `saveImage` function (again, the following code will replace
    `// to do...` from earlier):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的`saveImage`函数（再次，以下代码将替换之前的`// to do...`）：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this new code in place, we can now successfully upload an image file via
    the form on the home page. Give it a try by launching the app and opening it in
    a browser. Once there, click on the Browse button in the main form, and select
    an `image` file from your computer. If successful, the `image` file should exist
    within the `public/upload` folder of your project with a new random filename.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个新代码，我们现在可以通过主页上的表单成功上传图像文件。启动应用程序并在浏览器中打开它，然后尝试一下。在那里，点击主表单中的浏览按钮，然后从计算机中选择一个“image”文件。如果成功，该“image”文件应该存在于项目的“public/upload”文件夹中，并带有一个新的随机文件名。
- en: Ensure that you have the `public/upload` folders created in your project, or
    you will get runtime errors when you attempt to write files to a location that
    doesn't exist. The write permissions might need to be set on the folder, depending
    on your OS and security access.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在项目中创建了“public/upload”文件夹，否则在尝试将文件写入不存在的位置时会出现运行时错误。根据您的操作系统和安全访问权限，可能需要在文件夹上设置写入权限。
- en: After the upload form completes and the `create` controller function does its
    work, it will redirect you to the individual image page for the image that was
    uploaded.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上传表单完成并且“create”控制器函数完成其工作后，它将重定向您到已上传图像的个别图像页面。
- en: Helpers for reusable code
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用代码的辅助程序
- en: So far, each of the pages that we have rendered display their `ViewModel` data
    perfectly, but that pesky sidebar still remains blank. We will fix this by creating
    a few modules for the sidebar content by implementing them as helper modules.
    These helper modules will be used repeatedly by various parts of our application
    and don't necessarily belong to the `controller` folder or the `server` folder.
    So, we'll just create a new home called `helpers` and store these modules there.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们渲染的每个页面都完美地显示它们的“ViewModel”数据，但是那个讨厌的侧边栏仍然是空白的。我们将通过将它们实现为辅助模块来解决这个问题，为侧边栏内容创建一些模块。这些辅助模块将被我们应用程序的各个部分重复使用，并不一定属于“controller”文件夹或“server”文件夹。因此，我们将创建一个名为“helpers”的新主目录，并将这些模块存储在那里。
- en: As we are just loading temporary fixture data into our `ViewModels`, the data
    we set up in the `helpers` and the `controllers` will all be replaced with actual
    live data once we implement MongoDB; we will do this in the next chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只是将临时装置数据加载到我们的“ViewModels”中，一旦我们实现MongoDB，我们在“helpers”和“controllers”中设置的数据都将被实际的实时数据替换；我们将在下一章中实现这一点。
- en: The sidebar module
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边栏模块
- en: First, we will create a module for the entire sidebar. This module will be responsible
    for calling multiple other modules to populate `ViewModel` for each section of
    the sidebar. As we will be populating each page's own `ViewModel` with data specifically
    for the sidebar, the sidebar module's function will accept that original `ViewModel`
    as a parameter. This is so that we can append data to the existing `ViewModel`
    for each page.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为整个侧边栏创建一个模块。这个模块将负责调用多个其他模块来填充每个侧边栏部分的“ViewModel”。由于我们将为每个页面的自己的“ViewModel”填充特定于侧边栏的数据，因此侧边栏模块的函数将接受原始的“ViewModel”作为参数。这样我们就可以为每个页面的现有“ViewModel”附加数据。
- en: Here, we will be appending a sidebar property (which is a JavaScript object)
    that contains properties for each of the sections of the sidebar.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将附加一个侧边栏属性（这是一个JavaScript对象），其中包含侧边栏各个部分的属性。
- en: 'To get started, first create a file named `helpers/sidebar.js`, and insert
    the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为“helpers/sidebar.js”的文件，并插入以下代码：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, you can see that you first required a module for each
    section of the sidebar. The existing `ViewModel` for any given page that displays
    the sidebar is the first parameter of the function. We added a sidebar property
    to `ViewModel` and set values for each property by calling the module for each
    section of the sidebar. Finally, we executed a `callback` that was passed in as
    the second parameter to the sidebar module. This `callback` is an anonymous function
    that we will use to execute the rendering of the HTML page.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到您首先需要为侧边栏的每个部分创建一个模块。显示侧边栏的任何给定页面的现有“ViewModel”是函数的第一个参数。我们向“ViewModel”添加了一个侧边栏属性，并通过调用每个侧边栏部分的模块为每个属性设置了值。最后，我们执行了作为侧边栏模块的第二个参数传递的“callback”。这个“callback”是一个匿名函数，我们将用它来执行HTML页面的渲染。
- en: Let's update the home and image controllers to include a call to the sidebar
    module, as well as to defer rendering the HTML template for each page to the `callback`
    for the sidebar module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新主页和图像控制器，包括调用侧边栏模块，并将每个页面的HTML模板的渲染推迟到侧边栏模块的“callback”中。
- en: 'Edit `controllers/home.js` and consider the following line of code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑“controllers/home.js”，考虑以下代码行：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Replace it with this new block of code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个新的代码块替换它：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Make the exact same changes to the `controllers/image.js` file, replacing `index`
    with `image`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对“controllers/image.js”文件进行完全相同的更改，将“index”替换为“image”：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Again, note how we executed the sidebar module and passed the existing `ViewModel`
    as the first parameter and a basic anonymous function as a `callback` for the
    second parameter. What we did was wait to render the HTML for the View until after
    the `sidebar` completed populating `ViewModel`. This is because of the asynchronous
    nature of Node.js. Suppose that we wrote the code in the following way instead:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们执行了侧边栏模块，并将现有的“ViewModel”作为第一个参数传递，并将一个基本的匿名函数作为第二个参数的“callback”。我们等待渲染HTML视图，直到“sidebar”完成填充“ViewModel”。这是因为Node.js的异步特性。假设我们以以下方式编写代码：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, it''s quite likely that the `res.render` statement will execute before
    `sidebar` has even finished doing any work. This will become very important once
    we introduce MongoDB in the next chapter. Additionally, as we are now using the
    `sidebar` module in each controller, ensure that you `require` it at the top of
    both controllers by including the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，很可能“res.render”语句会在“sidebar”甚至完成任何工作之前执行。一旦我们在下一章中引入MongoDB，这将变得非常重要。另外，由于我们现在在每个控制器中使用“sidebar”模块，请确保在两个控制器的顶部“require”它，包括以下代码：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that our `sidebar` module is complete, and it's being called from both controllers,
    let's complete the `sidebar` by creating each of the submodules that are required.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的“侧边栏”模块已经完成，并且从两个控制器中调用，让我们通过创建所需的每个子模块来完成“侧边栏”。
- en: The stats module
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计模块
- en: The stats module will display a few random pieces of statistics about our app.
    Specifically, it will show the count for the total number of `images`, `comments`,
    `Views`, and `likes` for the entire website.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 统计模块将显示有关我们应用程序的一些随机统计信息。具体来说，它将显示整个网站的“图片”、“评论”、“浏览量”和“喜欢”总数。
- en: 'Create the `helpers/stats.js` file and insert the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建“helpers/stats.js”文件，并插入以下代码：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This module is pretty basic, and all it does is create a standard JavaScript
    object with a few properties for the various stats, each set initially to 0.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块非常基础，它所做的就是创建一个标准的JavaScript对象，其中包含一些属性用于各种统计信息，每个属性最初都设置为0。
- en: The images module
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片模块
- en: The `images` module is responsible for returning various collections of images.
    Initially, we will create a `popular` function that will be used to return a collection
    of the most popular images on the website. Initially, this collection will simply
    be an array of `image` objects with the sample fixture data present.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: “图片”模块负责返回各种图片集合。最初，我们将创建一个“热门”函数，用于返回网站上最受欢迎的图片集合。最初，这个集合将只是一个包含示例固定数据的“图片”对象数组。
- en: 'Create the `helpers/images.js` file, and insert the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建“helpers/images.js”文件，并插入以下代码：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The comments module
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评论模块
- en: Similar to the image's `helper` module, the `comments` module will return a
    collection of the newest comments posted to the site. An idea of particular interest
    is that each comment also has an image attached to it, so that the actual image
    for each comment can be displayed as a thumbnail when displaying the list of comments
    (otherwise, we lose context when we see a random list of comments with no related
    image).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与图片的“辅助”模块类似，“评论”模块将返回最新发布到网站的评论集合。一个特别感兴趣的想法是每条评论也附有一张图片，这样在显示评论列表时可以显示每条评论的实际图片作为缩略图（否则，当我们看到一系列没有相关图片的评论时，我们会失去上下文）。
- en: 'Create the `helpers/comments.js` file, and insert the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建“helpers/comments.js”文件，并插入以下代码：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, this is just a basic JavaScript array of objects with a few properties
    for each comment, one of which is an actual image and its properties (the `image`
    property should look familiar, since it's the same as one of the items in the
    image's `helper` module).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这只是一个基本的JavaScript对象数组，每个评论都有一些属性，其中之一是实际图片及其属性（“图片”属性应该看起来很熟悉，因为它与图片的“辅助”模块中的项目相同）。
- en: Testing the sidebar implementation
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试侧边栏实现
- en: Now that our `sidebar` module is completed along with its dependent submodules
    for the various `stats`, `images`, and `comments`, it's time to give our application
    another test run. Launch the node server, and open the application in your browser.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的“侧边栏”模块已经完成，以及它的依赖子模块“统计”、“图片”和“评论”，是时候再次测试我们的应用程序了。启动节点服务器，并在浏览器中打开应用程序。
- en: You should now see the `sidebar`, complete with content, on both the home page
    and the image landing page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该在主页和图片着陆页上看到带有内容的“侧边栏”。
- en: Iterating on the UI
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对UI进行迭代
- en: Now that we have our application working fairly well and can actually interact
    with it, it's time to step back and take a look at some of the areas we might
    be able to improve.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序运行得相当不错，实际上可以与之交互，是时候退后一步，看看我们可能改进的一些方面了。
- en: One area is the Post Comment form on the image page. I don't think it's necessary
    that this form is always visible, but instead it should be made available only
    when someone actually wants to post a comment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个领域是图片页面上的发表评论表单。我认为这个表单总是可见并不是必要的，而是应该只在有人想要发表评论时才可用。
- en: Additionally, I'd love the Like button to not have to post a full form submission
    to the server and cause the entire page to reload (just as the form on the home
    page does when it uploads an image). We will use jQuery to submit an AJAX call
    to the server to handle the likes and send and retrieve data in real time without
    ever reloading the page.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我希望“喜欢”按钮不必向服务器提交完整的表单并导致整个页面重新加载（就像主页上上传图片时的表单一样）。我们将使用jQuery向服务器提交AJAX调用来处理喜欢，并实时发送和检索数据，而无需重新加载页面。
- en: To make these tweaks, we will need to introduce a small amount of JavaScript
    on the page to add a little interactivity. To make things even easier, we'll use
    the popular jQuery JavaScript library to make creating interactive features a
    breeze.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这些调整，我们需要在页面上引入少量JavaScript以增加一些交互性。为了使事情变得更容易，我们将使用流行的jQuery JavaScript库来轻松创建交互功能。
- en: The jQuery has been around for a number of years and has been explosively popular
    in frontend development. It allows you to manipulate the **Document Object Model**
    (**DOM**), that is, the HTML structure of any page, extremely easily, which you
    will see in the next section. You can learn more about jQuery at [http://jquery.com](http://jquery.com).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery已经存在多年，并在前端开发中爆炸性流行。它允许您非常轻松地操纵**文档对象模型**（**DOM**），即任何页面的HTML结构，您将在下一节中看到。您可以在[http://jquery.com](http://jquery.com)了解更多关于jQuery的信息。
- en: 'You might not have noticed, but in the HTML code that was provided for the
    `main.Handlebars` layout file, jQuery was already included as an external `script`
    tag (referencing jQuery hosted on a CDN). Additionally, a local `scripts.js` tag
    is also included, where we will put our custom jQuery JavaScript code for the
    changes we will make to the UI. When you look at the very bottom of `main.Handlebars`,
    you can see the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能没有注意到，在为“main.Handlebars”布局文件提供的HTML代码中，已经包含了作为外部“script”标签的jQuery（引用托管在CDN上的jQuery）。此外，还包括了一个本地的“scripts.js”标签，我们将在其中放置我们自定义的jQuery
    JavaScript代码，用于对UI进行的更改。当您查看“main.Handlebars”的最底部时，您可以看到以下代码：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first script tag points to Google's code **Content Delivery Network** (**CDN**),
    which means that we don't have to worry about hosting that file with our code.
    The second file, however, is our own file, so we will need to make sure that exists.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本标签指向谷歌的**内容交付网络**（**CDN**），这意味着我们不必担心将该文件与我们的代码一起托管。然而，第二个文件是我们自己的文件，因此我们需要确保它存在。
- en: CDN is a means of delivering a file from a globally distributed network of caching
    servers. What this means, generally speaking, is that files that are very commonly
    downloaded by web visitors (such as jQuery) can be loaded much quicker via a regionally
    closer download source as well as improved caching. If multiple websites use the
    same CDN URL to host jQuery, for example, it stands to reason that a visitor to
    your website might have already downloaded jQuery when visiting a previous unrelated
    website. Therefore, your website will load that much quicker.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: CDN是一种从全球分布的缓存服务器网络中传递文件的方法。一般来说，这意味着通过区域性更近的下载源以及改进的缓存，网页访问者经常下载的文件（如jQuery）可以更快地加载。如果多个网站使用相同的CDN
    URL来托管jQuery，例如，那么有理由认为访问您网站的访问者在访问以前的不相关网站时可能已经下载了jQuery。因此，您的网站将加载得更快。
- en: 'Create the `public/js/scripts.js` file, and insert the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`public/js/scripts.js`文件，并插入以下代码：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is a standard code block that you''ll see almost every time anyone uses
    jQuery. What this code does is execute an anonymous function within the `$()`
    jQuery wrapper, which is shorthand for writing the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的代码块，几乎每次有人使用jQuery时都会看到。这段代码执行了一个匿名函数，该函数位于`$()` jQuery包装器内，这是写下面代码的简写：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code basically means that the `callback` function will wait until
    the page is fully loaded and ready before executing. This is important because
    we don't want to apply UI event handlers and/or effects to DOM elements that don't
    actually exist yet because the page is still loading. This is also another reason
    why the script tags in the `main.Handlebars` layout file are the last lines of
    the page; it is so that they are the last to load, ensuring that the document
    has already been fully downloaded and is ready to be manipulated.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码基本上意味着`callback`函数将在页面完全加载和准备好之前等待执行。这很重要，因为我们不希望将UI事件处理程序和/或效果应用于实际上尚不存在的DOM元素，因为页面仍在加载。这也是为什么`main.Handlebars`布局文件中的脚本标签是页面的最后一行的另一个原因；这样它们就是最后加载的，确保文档已经完全下载并准备好被操作。
- en: 'First, let''s address the `post-comment` functionality. We want to hide the
    comment form by default, and then display it only when a user clicks on the Post
    Comment button under an image (to the right of the Like button). Insert the following
    code inside the `callback` function where the `// to do...` comment exists:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们解决`post-comment`功能。我们希望默认隐藏评论表单，然后仅在用户点击图像下的“发布评论”按钮时显示它（在“喜欢”按钮右侧）。在`callback`函数中插入以下代码，该函数存在`//
    to do...`注释处：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first line of code executes the `hide` function on the HTML div that has
    a `post-comment` ID. We then immediately apply an event handler to the HTML button
    with a `btn-comment` ID. The event handler we apply is for `onClick`, because
    we want it to execute the anonymous function we provided whenever a user clicks
    on that button. That function simply prevents the default behavior (the default
    behavior for that particular element; in this case, a button) and then calls the
    show jQuery function, which reveals the `post-comment` div that was previously
    hidden. The `event.preventDefault()` part is important because if we didn't include
    it, the action of clicking on the button would do what a browser expects it to
    do and try to execute our custom JavaScript function at the same time. If we didn't
    include this, it's likely that our UI would behave in ways that are less than
    ideal. A good example of this is that if you want to override the default behavior
    of a standard HTML link, you can assign an `onClick` event handler and do whatever
    you want. However, if you don't perform `event.preventDefault()`, the browser
    will send the user to the HREF for that link, regardless of what your code is
    trying to do.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码在具有`post-comment` ID的HTML div上执行`hide`函数。然后，我们立即在具有`btn-comment` ID的HTML按钮上应用事件处理程序。我们应用的事件处理程序是`onClick`，因为我们希望它在用户点击该按钮时执行我们提供的匿名函数。该函数简单地阻止默认行为（特定元素的默认行为；在本例中是按钮）然后调用显示jQuery函数，该函数显示先前隐藏的`post-comment`
    div。`event.preventDefault()`部分很重要，因为如果我们不包括它，点击按钮的操作将执行浏览器期望执行的操作，并尝试同时执行我们的自定义JavaScript函数。如果我们不包括这个，很可能我们的UI会表现得不太理想。一个很好的例子是，如果您想要覆盖标准HTML链接的默认行为，您可以分配一个`onClick`事件处理程序并做任何您想做的事情。但是，如果您不执行`event.preventDefault()`，浏览器将发送用户到该链接的HREF，而不管您的代码试图做什么。
- en: 'Now, let''s add some code to handle the Like button functionality. We will
    add an event handler for the button, the same way we did for the Post Comment
    button, using jQuery''s `.on` function. After the code that you added previously,
    insert this additional block of code inside the `ready` statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些代码来处理“喜欢”按钮的功能。我们将为按钮添加一个事件处理程序，方式与我们为“发布评论”按钮做的方式相同，使用jQuery的`.on`函数。在您之前添加的代码之后，将以下附加代码块插入`ready`语句内：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code attaches an `onClick` event handler to the `btn-like` button.
    The event handler first retrieves the `data(''id'')` attribute from the Like button
    (assigned via the `image.Handlebars` HTML template code and `ViewModel`) and then
    performs a jQuery AJAX post to the `/images/:image_id/like` route. Recall the
    following line from our Node `server/routes.js` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将一个`onClick`事件处理程序附加到`btn-like`按钮。事件处理程序首先从“喜欢”按钮中检索`data('id')`属性（通过`image.Handlebars`
    HTML模板代码和`ViewModel`分配），然后执行jQuery AJAX post到`/images/:image_id/like`路由。回想一下我们Node
    `server/routes.js`文件中的以下行：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once that AJAX call is done, another anonymous `callback` function will be executed
    that will change the text of the HTML element with a `likes-count` class and replace
    it with the data that was returned from the AJAX call--in this case, the updated
    total count of likes (typically, it would be whatever it was previously plus one).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了该AJAX调用，将执行另一个匿名的“回调”函数，该函数将更改具有“likes-count”类的HTML元素的文本，并用从AJAX调用返回的数据替换它--在这种情况下，喜欢的总数已更新（通常情况下，它将是之前的总数加一）。
- en: 'In order to test this functionality, we will need to implement some fixture
    data in our `like` function inside the `image` controller. Edit `controllers/image.js`,
    and within the `like` function, replace the existing `res.send` function call
    with the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个功能，我们需要在“image”控制器的“like”函数中实现一些固定数据。编辑“controllers/image.js”，在“like”函数内，用以下代码替换现有的“res.send”函数调用：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All this code does is return JSON to the client with a simple object that contains
    a single likes property with a value of `1`. In the next chapter, when we introduce
    MongoDB to the app, we'll update this code to actually increase the count of likes
    and return the true value for the liked image.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这段代码做的就是向客户端返回JSON，其中包含一个带有值为“1”的likes属性的简单对象。在下一章中，当我们向应用程序引入MongoDB时，我们将更新此代码，以实际增加喜欢的数量并返回所喜欢的图像的真实值。
- en: With all of those changes in place, you should be able to relaunch the node
    server and open the website in your browser. Click on any image on the home page
    to view the image page and then click on the Like button to see it change from
    `0` to `1`. Don't forget to check out the fancy new Post Comment button too; clicking
    on this should reveal the comment form.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些变化，您应该能够重新启动节点服务器并在浏览器中打开网站。单击主页上的任何图像以查看图像页面，然后单击“喜欢”按钮，以将其从“0”更改为“1”。不要忘记查看新的“发布评论”按钮；单击此按钮应该会显示评论表单。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At the beginning of this chapter, we had some basic HTML pages that appeared
    in a browser via our application, but they contained no content and no logic whatsoever.
    We implemented the logic for each of our controllers and discussed the ViewModel
    and how to populate pages with content.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，我们有一些基本的HTML页面通过我们的应用程序显示在浏览器中，但它们没有任何内容和逻辑。我们实现了每个控制器的逻辑，并讨论了ViewModel以及如何填充页面内容。
- en: In addition to displaying content on our pages via a ViewModel, we also implemented
    the code to handle uploading and saving image files to the local `filesystem`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过ViewModel在我们的页面上显示内容之外，我们还实现了处理上传和保存图像文件到本地文件系统的代码。
- en: We tweaked the UI slightly to include some subtle enhancements using jQuery
    by revealing the comment form and used AJAX to track likes instead of relying
    on a full page postback.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微调整了UI，使用jQuery包含了一些微妙的增强功能，通过显示评论表单，并使用AJAX来跟踪喜欢，而不是依赖完整的页面回发。
- en: Now that the groundwork has been laid for our ViewModels and controllers, let's
    tie it all together using MongoDB and start working with real data. In the next
    chapter, we will update the controllers once again, this time implementing the
    logic to read from and save data to our MongoDB server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为我们的ViewModels和controllers奠定了基础，让我们使用MongoDB将它们全部联系在一起，并开始使用真实数据。在下一章中，我们将再次更新controllers，这次实现从MongoDB服务器读取和保存数据的逻辑。
