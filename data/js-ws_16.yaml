- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: About
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于
- en: This section is included to assist the students to perform the activities present
    in the book. It includes detailed steps that are to be performed by the students
    to complete and achieve the objectives of the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含的内容旨在帮助学生执行书中提到的活动。它包括学生为完成和实现本书目标而需要执行的详细步骤。
- en: 'Chapter 1: Getting to Know JavaScript'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：了解 JavaScript
- en: 'Activity 1.01: Creating an Alert Box Popup in the Web Browser'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 1.01：在网页浏览器中创建一个警告框弹出
- en: Solution
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Press *F12* to open the developer tools that are integrated within it. If this
    doesn''t work, a right-click may expose a prompt so that you can do this as well:![Figure
    1.18: Choosing Inspect in Google Chrome'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *F12* 打开集成在其内的开发者工具。如果不起作用，右键点击可能会弹出一个提示，让你也能这样做：![图 1.18：在 Google Chrome
    中选择“检查”
- en: '](img/C14377_01_18.jpg)'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_01_18.jpg)'
- en: 'Figure 1.18: Choosing Inspect in Google Chrome'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.18：在 Google Chrome 中选择“检查”
- en: 'The developer tools may default to the console. If not, there is likely to
    be a `Console` tab you can click on to activate it. The console allows you to
    write JavaScript code directly within the web browser itself:![Figure 1.19: The
    Developer Tools Console tab in Google Chrome'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者工具默认可能是控制台。如果不是，可能有一个可以点击的 `Console` 选项卡来激活它。控制台允许你在网页浏览器中直接编写 JavaScript
    代码：![图 1.19：Google Chrome 中的开发者工具控制台选项卡
- en: '](img/C14377_01_19.jpg)'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_01_19.jpg)'
- en: 'Figure 1.19: The Developer Tools Console tab in Google Chrome'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.19：Google Chrome 中的开发者工具控制台选项卡
- en: 'Within the console, write the following command:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中，输入以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Hit *Return*/*Enter* to execute the code. The code will execute within the browser
    environment.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Return*/*Enter* 执行代码。代码将在浏览器环境中执行。
- en: 'You should see an alert appear in the browser viewport displaying your message,
    as shown here:'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在浏览器视口中看到一个弹出的警告框显示你的消息，如图所示：
- en: '![Figure 1.20: An alert appears with our message'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.20：出现带有我们消息的警告'
- en: '](img/C14377_01_20.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_01_20.jpg)'
- en: 'Figure 1.20: An alert appears with our message'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20：出现带有我们消息的警告
- en: What does that code do? It declares a variable, using the `var` keyword, with
    the `greeting` identifier on the first line. As part of this same line of code,
    we then use the `=` assignment operator to assign a `'Hello from JavaScript!'`
    text string value to our variable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了什么？它在第一行使用 `var` 关键字声明了一个名为 `greeting` 的变量。作为同一行代码的一部分，我们使用 `=` 赋值运算符将一个
    `'Hello from JavaScript!'` 文本字符串值赋给我们的变量。
- en: On the second line, we use the `alert()` function and pass in our `greeting`
    identifier as an argument. The result is that the web browser displays an alert
    overlay with the text value applied to the identifier we passed in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们使用 `alert()` 函数并将我们的 `greeting` 标识符作为参数传递。结果是，网页浏览器显示了一个带有我们传递给标识符的文本值的警告叠加层。
- en: 'Chapter 2: Working with JavaScript'
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章：使用 JavaScript
- en: 'Activity 2.01: Adding and Modifying an Item to/in the To-Do List'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 2.01：向待办事项列表中添加和修改项
- en: Solution
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Create the HTML file yourself and paste in the HTML code to get started:![Figure
    2.28: The initial to-do list''s appearance'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 HTML 文件并粘贴 HTML 代码以开始：![图 2.28：待办事项列表的初始外观
- en: '](img/C14377_02_28.jpg)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_02_28.jpg)'
- en: 'Figure 2.28: The initial to-do list''s appearance'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.28：待办事项列表的初始外观
- en: 'The first thing we need to do is assign an ID to our list in order to identify
    it via code. To do this, add an `id` attribute to the `ol` element and give it
    a value of `todo-list`. With that complete, we can then address this element directly
    with JavaScript:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要为我们的列表分配一个 ID，以便通过代码来识别它。为此，将一个 `id` 属性添加到 `ol` 元素中，并给它赋值为 `todo-list`。完成这些后，我们就可以直接使用
    JavaScript 来引用这个元素：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using a bit of JavaScript code, we can now create a new variable named `parentContainer`.
    This will refer to the ordered list container element that holds all of our list
    items. We''ll use the ID we assigned in the previous step to address this element
    directly via the use of the `getElementById()` method:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一些 JavaScript 代码，我们现在可以创建一个名为 `parentContainer` 的新变量。这将引用包含所有列表项的有序列表容器元素。我们将使用之前步骤中分配的
    ID，通过 `getElementById()` 方法直接引用这个元素：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a new HTML `<li>` list item element via JavaScript. Right now, the element
    only exists in memory since we have to add it to a visual container. It also has
    no text content associated with it:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 JavaScript 创建一个新的 HTML `<li>` 列表项元素。目前，这个元素只存在于内存中，因为我们必须将其添加到一个可视容器中。它也没有与它关联的文本内容：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s populate the list item with a data value. Set the `innerText` of
    our `newItem` node to a string. The value of that string can be whatever you like,
    but it should fit within the concept of a to-do list:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用数据值填充列表项。将`newItem`节点的`innerText`设置为字符串。该字符串的值可以是任何您喜欢的，但它应该符合待办事项列表的概念：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that the new HTML element has been created and populated with text, we
    can add it to the visual document by appending it to a chosen parent container
    that already exists:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在新的HTML元素已经创建并填充了文本，我们可以通过将其附加到已存在的父容器中将其添加到视觉文档中：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We then need to add an extra line of JavaScript below all the others that currently
    exist within our `<script>` tag to modify the element''s appearance. We will reference
    the last child element within our ordered list and change the `style` attribute
    to add a CSS color rule. You can set the actual color of the text to whatever
    you like—I''m going to use `crimson`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在所有其他现有的`<script>`标签下方添加一行额外的JavaScript代码来修改元素的外观。我们将引用有序列表中的最后一个子元素，并将`style`属性更改为添加CSS颜色规则。您可以将文本的实际颜色设置为任何您喜欢的颜色——我将使用`crimson`：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, to verify the execution order through code, add the following line of
    JavaScript directly underneath the initial declaration of `parentContainer`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了通过代码验证执行顺序，直接在`parentContainer`的初始声明下方添加以下JavaScript行：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, add the following line right before the closing `<script>` tag:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在关闭`<script>`标签之前添加以下行：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With that completed, refresh your browser view and a seventh item should appear
    on your list. Do keep an eye on the developer tools console to verify the execution
    order of our code! Not only will the new item be added to the existing ordered
    list, but it will also display with crimson text instead of the usual white:![Figure
    2.29: A list item has been added to our to-do list and styled in crimson'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，刷新您的浏览器视图，您的列表中应该会出现第七个项目。请务必关注开发者工具控制台以验证代码的执行顺序！不仅新项目将被添加到现有的有序列表中，而且它还将以深红色文本而不是通常的白色显示：![图2.29：已将一个列表项添加到我们的待办事项列表中并使用深红色进行了样式设置
- en: '](img/C14377_02_29.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_02_29.jpg)'
- en: 'Figure 2.29: A list item has been added to our to-do list and styled in crimson'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.29：已将一个列表项添加到我们的待办事项列表中，并使用深红色进行了样式设置
- en: 'The complete code will be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码如下：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is just a simple example of how JavaScript can have a direct influence
    over other aspects of the environment it is run with.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的例子，说明了JavaScript如何直接影响其运行环境的其他方面。
- en: 'Chapter 3: Programming Fundamentals'
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：编程基础
- en: 'Activity 3.01: The To-Do List Shuffle Program'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动3.01：待办事项列表洗牌程序
- en: Solution
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'All the coding is done in the `activity.js` file. Add the code after the comment
    shown in each step. Create the array of `todo` items:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有编码都在`activity.js`文件中完成。在每个步骤中添加显示的注释后的代码。创建待办事项的数组：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Examine the `ol` element in the HTML document file called `activity.html` and
    notice that it has an `id` attribute with the value of `todo-list`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查名为`activity.html`的HTML文档文件中的`ol`元素，注意它有一个值为`todo-list`的`id`属性：
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can create an object variable, referencing the `ol` element using the `document.getElementById`
    method:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以创建一个对象变量，使用`document.getElementById`方法引用`ol`元素：
- en: '[PRE12]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, write a function that accepts a list element object and an array of values.
    The function removes the `li` elements from the list element and then loops through
    the array, creating new `li` elements for each value in the array:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编写一个函数，该函数接受一个列表元素对象和一个值数组。该函数从列表元素中删除`li`元素，然后遍历数组，为数组中的每个值创建新的`li`元素：
- en: '[PRE13]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first line uses the `innerHTML` property to remove all the contents of the
    list element object. The `for` loop iterates through the array. The first line
    in the `for` loop creates an `li` element object named `liEle`. The next line
    uses the `liEle` object's `addChild` method to append a text node to the `liEle`
    object. The `document.createTextNode` method provides the item in the array as
    a proper node object. The last line appends the `liEle` object to the `listEle`
    object.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一行使用`innerHTML`属性删除列表元素对象的全部内容。`for`循环遍历数组。`for`循环中的第一行创建了一个名为`liEle`的`li`元素对象。下一行使用`liEle`对象的`addChild`方法将文本节点附加到`liEle`对象上。`document.createTextNode`方法提供了数组中的项作为适当的节点对象。最后一行将`liEle`对象附加到`listEle`对象上。
- en: 'The final step is to call the function:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是调用该函数：
- en: '[PRE14]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function will execute when the `activity.js` file is loaded.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数将在`activity.js`文件加载时执行。
- en: 'Save the `activity.js` file and reload the `activity.html` file in the web
    browser. It should appear as follows:![Figure 3.24: activity.js and activity.html
    file output'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `activity.js` 文件并在网络浏览器中重新加载 `activity.html` 文件。它应该如下所示：![图 3.24：activity.js
    和 activity.html 文件输出
- en: '](img/C14377_03_24.jpg)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_03_24.jpg)'
- en: 'Figure 3.24: `activity.js` and `activity.html` file output'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.24：`activity.js` 和 `activity.html` 文件输出
- en: 'Examine the `button` element in the HTML document file called `activity.html`
    and notice that it has an `id` attribute with the value of `shuffle-button`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查名为 `activity.html` 的 HTML 文档文件中的 `button` 元素，注意它有一个值为 `shuffle-button` 的 `id`
    属性：
- en: '[PRE15]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can create an object variable referencing the `button` element by using
    the `document.getElementById` method:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用 `document.getElementById` 方法创建一个对象变量来引用 `button` 元素：
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, you need to listen for click events and call a function that will handle
    the event. The `shuffleButtonEle` object''s `addEventListener` method can do that
    for you. The first argument is the name of the event, and the second argument
    is the name of the function:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要监听点击事件并调用一个处理该事件的函数。`shuffleButtonEle` 对象的 `addEventListener` 方法可以为你完成这个任务。第一个参数是事件名称，第二个参数是函数名称：
- en: '[PRE17]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we need to write the `shuffleButtonClicked` function:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要编写 `shuffleButtonClicked` 函数：
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only line of code is used to call the `replaceListElements` function. The
    first argument is the `todoEle` object for the `ol` element. The second argument
    is the `getNewShuffledArray` function, which is using the `todoList` array as
    an argument. The `getNewShuffledArray` function returns an array that's been shuffled.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的唯一一行用于调用 `replaceListElements` 函数。第一个参数是 `ol` 元素的 `todoEle` 对象。第二个参数是 `getNewShuffledArray`
    函数，它使用 `todoList` 数组作为参数。`getNewShuffledArray` 函数返回一个已打乱顺序的数组。
- en: Save the `activity.js` file and reload the `activity.html` file in the web browser.
    Then, click the Shuffle button to see the list change.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `activity.js` 文件并在网络浏览器中重新加载 `activity.html` 文件。然后，点击 Shuffle 按钮，以查看列表的变化。
- en: 'Take a moment to examine the comments in the `getNewShuffledArray` function
    to see how it works. It shuffles the array elements, and appears as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 花点时间检查 `getNewShuffledArray` 函数中的注释，看看它是如何工作的。它打乱数组元素，看起来如下：
- en: '[PRE19]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, make a copy of `sourceArray` and set the index to make a swap, starting
    with the last:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，复制 `sourceArray` 并设置索引以进行交换，从最后一个开始：
- en: '[PRE20]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create an index to make a swap with `swapIndex` and swap the value of `swapIndex`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个索引与 `swapIndex` 交换，并交换 `swapIndex` 的值：
- en: '[PRE21]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a `while` loop called `swapIndex` that''s not equal to `0` and pick
    an index to swap with the current index from `0` to the current `swapIndex`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `swapIndex` 的 `while` 循环，其值不等于 `0`，并从 `0` 到当前的 `swapIndex` 选择一个索引进行交换：
- en: '[PRE22]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, reduce `swapIndex` by `1` and make a copy of the `swapIndex` value. Then,
    replace the `swapIndex` value with the `swapWithIndex` value, and replace the
    `swapWithIndex` value with the `temporaryValue` value:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `swapIndex` 减少到 `1` 并复制 `swapIndex` 的值。然后，将 `swapIndex` 的值替换为 `swapWithIndex`
    的值，并将 `swapWithIndex` 的值替换为 `temporaryValue` 的值：
- en: '[PRE23]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The shuffled To-Do list will look similar to something as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 打乱的 To-Do 列表看起来可能如下所示：
- en: '![Figure 3.25: Shuffled list 1](img/C14377_03_25.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.25：打乱列表 1](img/C14377_03_25.jpg)'
- en: 'Figure 3.25: Shuffled list 1'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25：打乱列表 1
- en: 'Another example of a shuffled To-Do list is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个打乱 To-Do 列表的例子如下：
- en: '![Figure 3.26: Shuffled list 2](img/C14377_03_26.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.26：打乱列表 2](img/C14377_03_26.jpg)'
- en: 'Figure 3.26: Shuffled list 2'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26：打乱列表 2
- en: 'Chapter 4: JavaScript Libraries and Frameworks'
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：JavaScript 库和框架
- en: 'Activity 4.01: Adding an Animation to the Todo List Application'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 4.01：为 Todo 列表应用程序添加动画
- en: 'Solution:'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案：
- en: Go to [cdnjs.com](http://cdnjs.com) and get the jQuery CDN URL.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [cdnjs.com](http://cdnjs.com) 获取 jQuery CDN URL。
- en: 'Load the library into the head tag of your existing Todo-List-HTML using a
    script tag. This will allow you to use jQuery within your code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将库通过脚本标签加载到现有的 Todo-List-HTML 的 head 标签中。这将允许你在代码中使用 jQuery：
- en: '[PRE24]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside `activity.js`, you need to change the `todoEle` variable. Change it
    to a jQuery element:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `activity.js` 中，你需要更改 `todoEle` 变量。将其更改为 jQuery 元素：
- en: '[PRE25]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Inside the `replaceListElements` function, you can now use functions on the
    `todoEle` element that jQuery provides you with.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `replaceListElements` 函数内部，你现在可以使用 jQuery 提供的函数在 `todoEle` 元素上使用。
- en: 'Hide and clear what''s inside the element using the necessary jQuery functions:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用必要的 jQuery 函数隐藏并清除元素内部的内容：
- en: '[PRE26]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inside the for loop, create the `liEle` list item element, set the text contest,
    and append it to the `listEle` list element:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在for循环内部，创建`liEle`列表项元素，设置文本内容，并将其附加到`listEle`列表元素上：
- en: '[PRE27]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, slowly fade in the new sorted todo list, that is, `listEle`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，缓慢淡入新的排序后的待办事项列表，即`listEle`：
- en: '[PRE28]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, open the HTML in your browser and click the Shuffle button. The todo list
    should fade out, shuffle, and fade in again:![Figure 4.17: Output Image'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的浏览器中打开HTML文件，并点击“Shuffle”按钮。待办事项列表应该淡出、打乱顺序，然后再次淡入：![图4.17：输出图像
- en: '](img/C14377_04_17.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_04_17.jpg)'
- en: '[PRE29]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside the `replaceListElements` function, you can now use Velocity to hide
    (by setting opacity to 0) the list element, `listEle`, and then empty the elements
    inside of it:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`replaceListElements`函数内部，现在可以使用Velocity将列表元素`listEle`隐藏（通过设置不透明度为0），然后清空其内部元素：
- en: '[PRE30]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To fade the list element back in, animate `listEle` using Velocity and set
    the opacity to `1`. Set the code after the for loop:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将列表元素淡入，使用Velocity对`listEle`进行动画处理，并将不透明度设置为`1`。在for循环之后设置代码：
- en: '[PRE31]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, open the HTML in your browser and click the *Shuffle* button. The `todo`
    list should fade out, shuffle, and fade in again.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的浏览器中打开HTML文件，并点击*Shuffle*按钮。`todo`列表应该淡出、打乱顺序，然后再次淡入。
- en: Finally, using the Anime method, go to [cdnjs.com](http://cdnjs.com) and get
    the `Anime.js` CDN URL. It will appear the same as the previous output.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用Anime方法，前往[courseds.com](http://cdnjs.com)并获取`Anime.js`的CDN URL。它将看起来与之前的输出相同。
- en: 'Load the library into the head tag of your existing Todo-List-HTML using a
    script tag. This will allow you to use `Anime.js` within your code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用script标签将库加载到现有的Todo-List-HTML的head标签中。这将允许您在代码中使用`Anime.js`：
- en: '[PRE32]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside the `replaceListElements` function, you can now use `Anime.js` to move
    (by using translateX = -1000) the list element, `listEle`, out of view and then
    empty the elements inside of it:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`replaceListElements`函数内部，现在可以使用`Anime.js`通过设置`translateX = -1000`将列表元素`listEle`移出视图，然后清空其内部元素：
- en: '[PRE33]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To show the newly shuffled todo list, use `Anime.js` to animate the `listEle`
    list element back into view (by using translateX = 0). Do so inside a timeout
    to ensure that the shuffling has been done already:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示新打乱的待办事项列表，使用`Anime.js`对`listEle`列表元素进行动画处理，使其回到视图（通过使用`translateX = 0`）。在超时内这样做，以确保打乱操作已经完成：
- en: '[PRE34]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, open the HTML in your browser and click the *Shuffle* button. The `todo`
    list should fade out, shuffle, and fade in again. It will appear the same as the
    previous output.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的浏览器中打开HTML文件，并点击*Shuffle*按钮。`todo`列表应该淡出、打乱顺序，然后再次淡入。它将看起来与之前的输出相同。
- en: 'Chapter 5: Beyond the Fundamentals'
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：超越基础
- en: 'Activity 5.01: Simple Number Comparison'
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.01：简单的数字比较
- en: Solution
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解答
- en: 'Create the function signature:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数签名：
- en: '[PRE35]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Copy the function arguments to a variable. This should be a new Array instance:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数参数复制到一个变量中。这应该是一个新的Array实例：
- en: '[PRE36]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Sum all the values of the arguments and store them in a variable:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有参数的值相加，并将它们存储在一个变量中：
- en: '[PRE37]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Remember to convert the grade values into a Number instance so that they can
    be correctly added together.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得将成绩值转换为Number实例，以便它们可以正确相加。
- en: 'Get the average of the sum and store it in a variable:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算总和的平均值并将其存储在一个变量中：
- en: '[PRE38]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using the average, calculate the student''s grade and return it. This can simply
    be a list of conditionals:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用平均值计算学生的成绩并返回。这可以简单地是一个条件列表：
- en: '[PRE39]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output will be visible as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 5.26: Activity 5.01 output'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.26：活动5.01输出'
- en: '](img/C14377_05_26.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_26.jpg)'
- en: 'Figure 5.26: Activity 5.01 output'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26：活动5.01输出
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The final condition will always be true if the others have failed, so the condition
    itself can be skipped. Each condition will not be evaluated if the previous condition
    has been returned from the function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他条件失败，最终条件始终为真，因此可以跳过条件本身。如果上一个条件已经从函数返回，则不会评估每个条件。
- en: 'Activity 5.02: Creating a TODO Model'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.02：创建TODO模型
- en: Solution
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解答
- en: 'The first step is to declare the state. It must be declared outside of any
    function so that it exists between function calls:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是声明状态。它必须在任何函数之外声明，以便在函数调用之间存在：
- en: '[PRE40]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, create the helper function that will be used to find a TODO by `id` from
    the `state` array. To do this, simply look through the array and return the index
    once it''s been found. If it isn''t found and the end of the array is reached,
    then return `-1` to denote that no TODO with the specific `id` exists:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个辅助函数，该函数将用于从 `state` 数组中通过 `id` 查找 TODO。为此，只需遍历数组，一旦找到就返回索引。如果没有找到并且到达数组的末尾，则返回
    `-1` 以表示不存在具有特定 `id` 的 TODO：
- en: '[PRE41]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, create the function as described in the description of this activity:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建描述中所述的函数：
- en: '[PRE42]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The function will need to act differently, depending on the value of `action`.
    When modifying the data successfully, it should return the new state. First, handle
    adding a new TODO to the state for the `CREATE` action:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数的行为将根据 `action` 的值而有所不同。在成功修改数据时，它应该返回新的状态。首先，处理 `CREATE` 动作向状态中添加新的 TODO：
- en: '[PRE43]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Remember that the data needs to be written to the console with `console.log`.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，需要使用 `console.log` 将数据写入控制台。
- en: 'Next, handle the `REMOVE` functionality. This will utilize the `modelFindIndex`
    function to locate the `TODO` to remove:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，处理 `REMOVE` 功能。这将利用 `modelFindIndex` 函数定位要删除的 `TODO`：
- en: '[PRE44]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, handle the `MODIFY` functionality. This step is a little more complex
    as the original data needs to be changed without changing the object reference:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，处理 `MODIFY` 功能。这一步稍微复杂一些，因为需要在不更改对象引用的情况下更改原始数据：
- en: '[PRE45]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Chapter 6: Understanding Core Concepts'
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：理解核心概念
- en: 'Activity 6.01: Making Changes to the Model'
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第6.01：对模型进行更改
- en: 'Solution:'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案：
- en: The page the form is in has an area to display messages. The form itself contains
    the title `textfield` and a description for the `textarea` field.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表单所在的页面有一个区域用于显示消息。表单本身包含标题 `textfield` 和 `textarea` 字段的描述。
- en: The page loads in the model code from the previous chapter, but also a new script,
    which will be created shortly. The `body` tag has an in-page event handler assigned
    to its `onload` event, which will be included in the `create_todos.js` file.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 页面加载了上一章中的模型代码，但也包含了一个新脚本，该脚本将很快被创建。`body` 标签被分配了一个页面事件处理程序，该处理程序将包含在 `create_todos.js`
    文件中。
- en: 'In order to use the model''s module with events, you will need to extend it
    by providing an event handler for each action type. Add the following code to
    the bottom of the `model.js` file:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使用具有事件的模型模块，您需要通过为每个动作类型提供事件处理程序来扩展它。将以下代码添加到 `model.js` 文件的底部：
- en: '[PRE46]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the `create_todos.js` file, add the `loadHandler` function:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `create_todos.js` 文件中，添加 `loadHandler` 函数：
- en: '[PRE47]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This function will initialize the model and set up any necessary event handlers.
    As you can see, it assigns the `CHANGED` event to the `changedHandler` function.
    Let's create that next.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数将初始化模型并设置任何必要的处理程序。如您所见，它将 `CHANGED` 事件分配给 `changedHandler` 函数。让我们接下来创建它。
- en: '`changedHandler` is a simple affair. It simply waits for the `CHANGED` event
    to be raised and then updates the notifications area when it does:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`changedHandler` 是一件简单的事情。它只是等待 `CHANGED` 事件被触发，然后在它发生时更新通知区域：'
- en: '[PRE48]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`changedHandler` clears the notifications area after three seconds to keep
    things clean.'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`changedHandler` 在三秒后将通知区域清除，以保持整洁。'
- en: 'Finally, you need to add the `createHandler` function, which handles the form''s
    submission:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您需要添加 `createHandler` 函数，该函数处理表单的提交：
- en: '[PRE49]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The majority of this code simply ensures that values are supplied to the form
    before submission and will alert the user if this is not the case.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码的主要作用是在提交表单之前确保提供了值，如果没有提供，则会提醒用户。
- en: 'Now, give the application a spin. If all goes well, notifications should momentarily
    show when submitting the form, with different messages depending on whether the
    fields were populated. As an example, open the browser console and simply enter
    the following:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用程序。如果一切顺利，在提交表单时应该会短暂显示通知，具体消息取决于字段是否已填充。例如，打开浏览器控制台并简单地输入以下内容：
- en: '[PRE50]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You should see the submitted `TODO` objects presented there, like so:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该会看到提交的 `TODO` 对象在这里展示，如下所示：
- en: '![Figure 6.28: TODO submission form'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.28：待办事项提交表单'
- en: '](img/C14377_06_27.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_06_27.jpg](img/C14377_06_27.jpg)'
- en: 'Figure 6.28: TODO submission form'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28：待办事项提交表单
- en: Working with events provides a powerful means to keep your applications simple.
    What's more, it also empowers abstraction, allowing scripts to send data without
    them needing to know which other areas of your application are interested in those
    events. This promotes clean design and easier maintenance of your code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件提供了一种强大的方法来保持你的应用程序简单。更重要的是，它还赋予了抽象能力，允许脚本发送数据，而无需知道应用程序的其他哪些区域对这些事件感兴趣。这促进了代码的整洁设计和易于维护。
- en: 'Chapter 7: Popping the Hood'
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：揭开盖子
- en: 'Activity 7.01: Finding out the Number of Stack Frames'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.01：找出栈帧的数量
- en: Solution
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The function that establishes the call stack''s limit is as follows:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立调用栈限制的函数如下：
- en: var frameCount = 0;
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var frameCount = 0;
- en: '[PRE51]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The solution starts out with the `frameCount` variable being initialized with
    the value `0`. The `stackOverflow()` function is declared, which will add 1 to
    the `frameCount` variable and then call itself, thus causing a stack overflow.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决方案从将`frameCount`变量初始化为`0`开始。声明了`stackOverflow()`函数，该函数将`frameCount`变量的值增加1，然后调用自身，从而引发栈溢出。
- en: Now, `setTimout()` function is initiated, which will log the value of `frameCount`
    to the console after a minimum of 500 milliseconds. Now, call the `stackOverflow()`
    function.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，启动`setTimout()`函数，该函数将在至少500毫秒后将`frameCount`的值记录到控制台。现在，调用`stackOverflow()`函数。
- en: '[PRE52]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This takes the `console.log` function out of the main execution thread, allowing
    it to be called after the stack overflow error is thrown:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将`console.log`函数从主执行线程中移除，允许它在抛出栈溢出错误后调用：
- en: '![Figure 7.22: Showing the solution and number of stack frames being pushed
    before a stack overflow is triggered'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.22：显示解决方案和触发栈溢出之前推入的栈帧数量'
- en: '](img/C14377_07_22.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_07_22.jpg)'
- en: 'Figure 7.22: Showing the solution and number of stack frames being pushed before
    a stack overflow is triggered'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22：显示解决方案和触发栈溢出之前推入的栈帧数量
- en: 'Chapter 8: Browser APIs'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：浏览器API
- en: 'Activity 8.01: Creating a Simple Fractal'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01：创建一个简单的分形
- en: Solution
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'We initialize the canvas and context as we did previously, but this time we
    add a point variable that we initialize with the coordinates of the center of
    the canvas:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化画布和上下文，就像之前做的那样，但这次我们添加了一个点变量，并用画布中心的坐标初始化它：
- en: '[PRE53]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we begin a new path and move the point to the coordinates that were assigned
    to the point variable:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们开始一个新的路径，并将点移动到分配给点变量的坐标：
- en: '[PRE54]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We declare `i`, which we will use as a multiplier to tell the function how
    long a line should be. We also declare two constants to hold the values for a
    margin between the fractal that we''re drawing and the edge of the canvas, as
    well as a multiplier, which is used to increase the line length that is drawn.
    Then, we start a while loop, which will keep going while the point remains inside
    the canvas'' bounds (plus the margin on each side):'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明`i`，我们将使用它作为乘数来告诉函数线条应该有多长。我们还声明了两个常量来保存分形与画布边缘之间的边距值以及一个乘数，该乘数用于增加绘制的线条长度。然后，我们开始一个while循环，该循环将在点保持在画布边界内（加上每边的边距）时继续进行：
- en: '[PRE55]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Inside the while loop, the values inside the point array are increased or decreased,
    depending on which direction the line is being drawn and depending on the value
    of `i`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在while循环内部，根据线条的绘制方向和`i`的值，增加或减少点数组中的值：
- en: '[PRE56]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, the lineTo function is called with the values in the point variable.
    Every other time a line is drawn, `i` is incremented. This means that the line''s
    length doubles after each second drawing of a line. You could also increase `i`
    each time a line is drawn, and the result would be greater spacing between the
    lines:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用点变量中的值调用lineTo函数。每次绘制线条时，`i`都会增加。这意味着线条的长度在每次绘制线条后都会加倍。你也可以在每次绘制线条时增加`i`，这样线条之间的间隔就会更大：
- en: '[PRE57]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, when the while loop''s termination condition is met (when the point
    reaches within 5 pixels of one of the edges of the canvas), the stroke() method
    of the context is called to add a stroke to the lines we''ve described:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当while循环的终止条件满足时（当点达到画布边缘的5像素以内时），上下文的stroke()方法被调用，为描述的线条添加描边：
- en: '[PRE58]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are many more methods available in the Canvas API, and many possibilities
    for their use. You can draw complicated patterns, pictures, and graphs, and animate
    anything you draw. You should explore the Canvas API in more depth to find out
    what it can do.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Canvas API 中有更多可用方法，以及许多使用它们的可能性。你可以绘制复杂的图案、图片和图表，并使你绘制的任何东西都动起来。你应该更深入地探索 Canvas
    API，以了解它能做什么。
- en: 'Activity 8.02: Playing Sound and Controlling Frequency Using Two Oscillators'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.02：使用两个振荡器播放声音和控制频率
- en: Solution
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Initialize an audio context and a volume node:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个音频上下文和一个音量节点：
- en: '[PRE59]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a gain node and connect it to the context''s destination:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个增益节点并将其连接到上下文的输出：
- en: '[PRE60]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Initialize two oscillators (one for each coordinate of the cursor):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化两个振荡器（一个用于光标的每个坐标）：
- en: '[PRE61]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Set the oscillator types (feel free to use any types you like), connect them
    to the volume node, and call their start() methods:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置振荡器类型（你可以自由使用你喜欢的任何类型），将它们连接到音量节点，并调用它们的 start() 方法：
- en: '[PRE62]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create an event listener that listens for the `mousemove` event on the `document`
    and set the oscillators'' frequencies based on the cursor''s position:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个事件监听器，监听 `document` 上的 `mousemove` 事件，并根据光标的位置设置振荡器的频率：
- en: '[PRE63]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The callback function that''s passed to the event listener assigns the cursor''s
    x and y values to the two oscillator nodes'' frequency values every time the ''mousemove''
    event is fired. This is a simple solution: it inherently limits the upper-frequency
    values for each oscillator depending on the width and height of the browser window.
    This is fine as a demonstration, but a better implementation would assign the
    same arbitrary upper-frequency value at the right-most and bottom-most parts of
    the document, no matter its dimensions.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给事件监听器的回调函数在每次 'mousemove' 事件触发时将光标的 x 和 y 值分配给两个振荡器节点的频率值。这是一个简单的解决方案：它本质上限制了每个振荡器的最高频率值，这取决于浏览器窗口的宽度和高度。这对于演示来说是可以的，但更好的实现方式是在文档的最右侧和最下侧分配相同的任意最高频率值，无论其尺寸如何。
- en: 'Activity 8.03: Audio Visualization'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.03：音频可视化
- en: Solution
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Create a simple HTML file with a link to a JavaScript file called scripts.js
    (or anything you want to call it), with a <canvas> element in the body and with
    an ID of canvas in the DevTools console:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的 HTML 文件，其中包含对名为 scripts.js（或你想要命名的任何名称）的 JavaScript 文件的链接，在 body 中包含一个
    <canvas> 元素，并在 DevTools 控制台中具有 ID 为 canvas：
- en: '[PRE64]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the scripts.js file, we will add an event listener on the document listening
    for a click event. As we saw in the *Audio API* section of this chapter, in many
    modern browsers, audio is disabled until the user has interacted with the page,
    so waiting for the click event is an easy way to make sure we don''t get any errors
    in this regard:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 scripts.js 文件中，我们将在文档上添加一个事件监听器，监听点击事件。正如我们在本章的 *音频 API* 部分所看到的，在许多现代浏览器中，音频在用户与页面交互之前是禁用的，所以等待点击事件是一个简单的方法来确保我们在这方面不会遇到任何错误：
- en: '[PRE65]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We then get hold of the canvas element, create a canvas context, set the canvas''
    width and height, and get its center x/y coordinates. We also instantiate a variable
    that will hold the Y value of the mouse''s position:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取 canvas 元素，创建一个 canvas 上下文，设置 canvas 的宽度和高度，并获取其中心 x/y 坐标。我们还实例化一个将保存鼠标位置
    Y 值的变量：
- en: '[PRE66]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, we will create an audio context, a gain node, an oscillator node, and
    an analyzer node. We connect the oscillator to the volume node and the analyzer
    node, and then connect the volume node to the audio context''s destination:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个音频上下文、一个增益节点、一个振荡器节点和一个分析器节点。我们将振荡器连接到音量节点和分析器节点，然后将音量节点连接到音频上下文的输出：
- en: '[PRE67]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we listen for mousemove events, and in the callback function for the
    event, we assign the cursor''s X position to the oscillator''s frequency value
    and the cursor''s Y position to the mouseY variable. This means that the cursor''s
    X position will control the frequency of the oscillation. We''ll see what the
    mouseY variable is used for shortly:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们监听鼠标移动事件，并在事件回调函数中，将光标的 X 位置分配给振荡器的频率值，将光标的 Y 位置分配给 mouseY 变量。这意味着光标的
    X 位置将控制振荡的频率。我们很快就会看到 mouseY 变量是用来做什么的：
- en: '[PRE68]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we come to the meat of the application. We call the draw() function. This
    function tells the browser that we want to draw a frame of an animation, and by
    proving the draw() function as the callback, it repeats this function once for
    each time the page is rendered:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们来到了应用程序的核心部分。我们调用 draw() 函数。这个函数告诉浏览器我们想要绘制动画的一帧，并通过将 draw() 函数作为回调，它在每次页面渲染时重复这个函数一次：
- en: '[PRE69]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, we get the waveform data from the analyzer, which is copied to the waveform
    array. Then, we clear the canvas from any previous stroke() methods and begin
    a new path:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从分析仪获取波形数据，并将其复制到波形数组中。然后，我们清除画布上的任何先前stroke()方法，并开始一个新的路径：
- en: '[PRE70]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we come to looping through the waveform array. For each item in the array
    (which represents points of the waveform), we will plot a small section of a circle.
    The circle will be divided into as many sections as there are items in the array.
    Each section has a radius of half the width of the canvas, minus the mouse''s
    Y position, plus the current chunk of the waveform''s amplitude (multiplied by
    an arbitrary number, that is, 15). The result of this could be a negative number
    if the mouse is more than halfway across the screen, so we wrap the whole thing
    in Math.abs(), which returns the absolute value (no negatives!) of a number:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们来遍历波形数组。对于数组中的每个项目（代表波形点），我们将绘制圆的小部分。圆将被分成与数组中项目数量一样多的部分。每个部分的半径是画布宽度的一半减去鼠标的Y位置，加上当前波形块振幅的当前块（乘以一个任意数，即15）。如果鼠标在屏幕的一半以上，结果可能是一个负数，所以我们用Math.abs()将整个包裹起来，它返回一个数字的绝对值（没有负数）：
- en: '[PRE71]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, we need to set the start angle and end angle of the arc in radians. A
    whole circle is 2*π radians, but we''re dividing the circle into as many arcs
    as there are items in the waveform array. Therefore, we can calculate the starting
    angle as ((2 / waveform.length) * i) *π, where waveforms.length is how many items
    there are and i is the current chunk of the waveform/our circle we''re on. We
    just add 1 to i for the end angle as each chunk''s end angle is the same as the
    next one''s starting angle:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置圆弧的起始角度和结束角度（以弧度为单位）。整个圆是2*π弧度，但我们将圆分成与波形数组中项目数量一样多的弧。因此，我们可以计算出起始角度为((2
    / waveform.length) * i) *π，其中waveforms.length是项目数量，i是当前波形/我们的圆的部分。我们只需将i加1，即为结束角度，因为每个块的最后角度与下一个块的起始角度相同：
- en: '[PRE72]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: let endAngle = ((2 / waveform.length) * i) * Math.PI;
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let endAngle = ((2 / waveform.length) * i) * Math.PI;
- en: 'After all that is done, and we call the arc() method of the canvas context,
    we can call the stroke() method to add a stroke to all the arcs we just plotted:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成所有这些，并调用画布上下文的arc()方法之后，我们可以调用stroke()方法来为刚刚绘制的所有弧添加描边：
- en: '[PRE73]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Put that all together, run it, and click on the page: we should get a very
    nice oscillating circle, whose diameter increases with the cursor''s y-position,
    and the oscillation of which matches the sound of the sine wave coming from the
    speakers. This, incidentally, can be controlled with the cursor''s x-position.
    Big fun:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，运行它，然后点击页面：我们应该得到一个非常漂亮的振荡圆，其直径随着光标的y位置增加，其振荡与扬声器发出的正弦波声音相匹配。顺便说一下，这可以通过光标的x位置来控制。非常有趣：
- en: '[PRE74]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Chapter 9: Working with Node.js'
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章：使用Node.js
- en: 'Activity 9.01: Create a Web Application to Upload, Store, and Save Image Details'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动九.01：创建一个用于上传、存储和保存图像详情的Web应用程序
- en: Solution
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Let''s first go through the directory structure and define the folders to upload
    the images:![Figure 9.22: Directory structure for this activity'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先通过目录结构，并定义上传图像的文件夹：![图9.22：此活动的目录结构
- en: '](img/C14377_09_22.jpg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_09_22.jpg)'
- en: 'Figure 9.22: Directory structure for this activity'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.22：此活动的目录结构
- en: As you can see, in this project you will try to upload images in the `public/images`
    directory. This directory must be present at the root of the project and the current
    user should have read and write access to this directory. By default, you will
    get both the permissions to this directory.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，在这个项目中，您将尝试在`public/images`目录中上传图像。此目录必须位于项目的根目录，并且当前用户应具有对此目录的读写权限。默认情况下，您将获得对此目录的权限。
- en: Note
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The source code will only contain two files (`app.js` and `package.json`). All
    the other files shown in the `images` directory in the preceding figure will not
    be present there. Once you start uploading files, you will see all the uploaded
    images there.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 源代码将只包含两个文件（`app.js`和`package.json`）。在前面的图中显示的`images`目录中的所有其他文件将不会存在。一旦您开始上传文件，您将看到所有上传的图像在那里。
- en: Before proceeding further, be sure to create a `public/images` directory in
    the root of this project that relates to `app.js` and `package.json`. The currently
    logged-in user of your machine must have the permissions to add files in this
    directory.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在继续之前，请确保在与此项目的`app.js`和`package.json`相关的项目根目录中创建一个`public/images`目录。您的机器当前登录用户必须具有在此目录中添加文件的权限。
- en: 'The first step is to import all the dependencies:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是导入所有依赖项：
- en: '[PRE75]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then let''s configure `morgan` to log each of our request details in the console.
    You can use `morgan` as a middleware:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后让我们配置 `morgan` 以在控制台中记录每个请求的详细信息。您可以将 `morgan` 作为中间件使用：
- en: '[PRE76]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now let''s configure the database. In this project, you will use a `MySQL`
    database:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们配置数据库。在这个项目中，您将使用 `MySQL` 数据库：
- en: '[PRE77]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Make sure you pass the credentials of the user you created earlier while going
    through the *Setting Up Databases* section.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保在通过 *设置数据库* 部分时传递您之前创建的用户凭据。
- en: 'When your application has established a database connection, it''s time to
    install `multer` by executing the following command through the terminal in the
    root of the project:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的应用程序建立数据库连接时，是时候通过项目根目录中的终端执行以下命令来安装 `multer` 了：
- en: '[PRE78]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, let''s configure `multer` by adding the code from the `app.js` file:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加 `app.js` 文件中的代码来配置 `multer`：
- en: '[PRE79]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This code will set the destination where all files will be uploaded, which is
    `public/images`, and you are also changing the `filename` after upload to avoid
    issues with duplicate filenames.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将设置所有文件上传的目的地，即 `public/images`，并且在上传后更改 `filename` 以避免重复文件名的问题。
- en: 'Now let''s configure some routes in your application:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们配置您应用程序中的某些路由：
- en: '[PRE80]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The last step is to start the server:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是启动服务器：
- en: '[PRE81]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'That''s it. The server is now up and running. The final thing is to send a
    request to upload the image on the server. For this, we will use Postman (the
    Chrome extension) as our client:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样。服务器现在已启动并运行。最后一件事是向服务器发送上传图片的请求。为此，我们将使用 Postman（Chrome 扩展）作为我们的客户端：
- en: '![Figure 9.23: API response in Postman'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.23：Postman 中的 API 响应'
- en: '](img/C14377_09_23.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_09_23.jpg)'
- en: 'Figure 9.23: API response in Postman'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23：Postman 中的 API 响应
- en: 'Chapter 10: Accessing External Resources'
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：访问外部资源
- en: 'Activity 10.01: Implement REST Service Calls Using Various Techniques'
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 10.01：使用各种技术实现 REST 服务调用
- en: 'Solution:'
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解答：
- en: 'Use `$.ajax()` with `method: ''post''` and `dataType: ''json''`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用 `$.ajax()` 并设置 `method: ''post''` 和 `dataType: ''json''`：'
- en: '[PRE82]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Enclose your data fields in an object, `{}`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象 `{}` 中封装您的数据字段：
- en: '[PRE83]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Create a `success` function to output the expected values:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `success` 函数以输出预期的值：
- en: '[PRE84]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The boilerplate HTML is omitted and left as an exercise for you. The preceding
    code would result in something like the following in the JavaScript Console in
    Google Chrome. (All the solutions presented have similar output):'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 省略了样板 HTML，并将其留作您的练习。前面的代码在 Google Chrome 的 JavaScript 控制台中会产生类似以下的内容。（所有提供的解决方案都有类似的输出）：
- en: '![Figure 10.17: JavaScript Console output'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.17：JavaScript 控制台输出'
- en: '](img/C14377_10_17.jpg)'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_10_17.jpg)'
- en: 'Figure 10.17: JavaScript Console output'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.17：JavaScript 控制台输出
- en: 'Now, let''s get the same output using the `$.post()` method and using the file
    `solution_using_jquery_post.html`:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `$.post()` 方法以及文件 `solution_using_jquery_post.html` 来获取相同的输出。
- en: '[PRE85]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Enclose your data fields in an object, `{}`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象 `{}` 中封装您的数据字段：
- en: '[PRE86]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create a `success` function to output the expected values:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `success` 函数以输出预期的值：
- en: '[PRE87]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'As the last parameter to `$.post()`, use the `''json''` value to indicate the
    expected JSON return type:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 `$.post()` 的最后一个参数，使用 `'json'` 值来指示预期的 JSON 返回类型：
- en: '[PRE88]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The output will be the same as is shown in *Figure 10.17*.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将与 *图 10.17* 中显示的相同。
- en: 'Finally, create a new `XMLHttpRequest` object:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个新的 `XMLHttpRequest` 对象：
- en: '[PRE89]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Call `open(''POST'')`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `open('POST')`：
- en: '[PRE90]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Set the `Content-type` and `Accept` request headers to the appropriate values:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Content-type` 和 `Accept` 请求头设置为适当的值：
- en: '[PRE91]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a function for `onreadystatechange` that checks for a status code of
    `201 (Created)` and parses the JSON data with `JSON.parse()`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `onreadystatechange` 创建一个函数，检查状态码为 `201 (已创建)` 并使用 `JSON.parse()` 解析 JSON
    数据：
- en: '[PRE92]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Call `JSON.stringify()` on the input data to convert it to JSON format:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入数据上调用 `JSON.stringify()` 以将其转换为 JSON 格式：
- en: '[PRE93]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Send the JSON data when calling `send()`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `send()` 时发送 JSON 数据：
- en: '[PRE94]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The output will be the same as is shown in *Figure 10.17*.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将与 *图 10.17* 中显示的相同。
- en: 'Chapter 11: Creating Clean and Maintainable Code'
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章：创建干净且易于维护的代码
- en: 'Activity 11.01: Expanding Phone Number Matching Patterns to Accept Multiple
    Formats'
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01：扩展电话号码匹配模式以接受多种格式
- en: 'Solution:'
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解答：
- en: Observe that only the characters at the beginning of each pattern differ, but
    the last characters, `XXX-XXXX`, are the same in both patterns.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到每个模式的开头字符不同，但两种模式中的最后字符 `XXX-XXXX` 是相同的。
- en: 'For the differing characters, for our regex to match either format correctly,
    you can specify the regex snippets that correspond to each format as alternate
    expressions of an alternation. Recall that alternations take the form of (`expression1|expression2)`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于不同的字符，为了使我们的正则表达式正确匹配两种格式，你可以指定与每种格式对应的正则表达式片段，作为交替表达式的替代表达式。回想一下，交替表达式具有
    (`expression1|expression2`) 的形式：
- en: '[PRE95]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Combine it with the rest of the original regex to get the complete regex:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其与原始正则表达式的其余部分结合，以获得完整的正则表达式：
- en: '[PRE96]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Remember that the original regex, `\d{3}-\d{4}`, matches `XXX-XXXX,` which is
    the same for both patterns. We only needed the alternation for the beginning parts
    of each pattern that differed. The `^` and `$` characters also enforce that there
    are no other characters before or after the acceptable ones.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，原始正则表达式 `\d{3}-\d{4}` 匹配 `XXX-XXXX`，这在两种模式中都是相同的。我们只需要交替每个模式的不同部分。`^` 和 `$`
    字符还强制执行没有其他字符在可接受字符之前或之后。
- en: Now, when you replace this correct regex into our tool, only the first two test
    strings match ( as expected)
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当你将这个正确的正则表达式替换到我们的工具中时，只有前两个测试字符串匹配（正如预期的那样）
- en: '![Figure 11.23: After using the correct regex, only the first two test strings
    match (as expected)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.23：使用正确的正则表达式后，只有前两个测试字符串匹配（正如预期的那样）]'
- en: '](img/C14377_11_23.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_11_23.jpg)'
- en: 'Figure 11.23: After using the correct regex, only the first two test strings
    match (as expected)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23：使用正确的正则表达式后，只有前两个测试字符串匹配（正如预期的那样）
- en: In *Exercise 11.01, The Effect of the g Flag*, and this activity, we created
    regex expressions to accept US number formats. We will now modify the regex to
    accept non-US number formats.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *练习 11.01，g 标志的影响* 和此活动中，我们创建了接受美国号码格式的正则表达式。现在，我们将修改正则表达式以接受非美国号码格式。
- en: 'Activity 11.02: Expanding Phone Number Matching Patterns to Accept a Particular
    Format'
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.02：扩展电话号码匹配模式以接受特定格式
- en: 'Solution:'
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'Construct the regex for the `+XXX` pattern (where between 1-3 digits are acceptable):'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建用于 `+XXX` 模式的正则表达式（其中1-3位数字是可接受的）：
- en: '[PRE97]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We need two things here:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里我们需要两件事：
- en: The first `+` needs to be escaped due to it being a special character.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个 `+` 需要转义，因为它是一个特殊字符。
- en: Notice the parenthesis with `?` after it. This specifies that whole expression
    within the parenthesis can occur 0 or 1 times. In other words, the characters
    in the expression are optional. The `\d{1,3}` expression is a range quantifier
    requiring between 1 and 3 digits.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意后面的 `?` 后面的括号。这指定了括号内的整个表达式可以发生0次或1次。换句话说，表达式中的字符是可选的。`\d{1,3}` 表达式是一个范围量词，需要1到3位数字。
- en: 'By prepending this to the regex from the previous activity, the whole regex
    is now as follows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将其添加到前面的活动中的正则表达式之前，整个正则表达式现在如下所示：
- en: '[PRE98]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: See the previous activity for a full description of the latter parts of the
    regex.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅前面的活动，以了解正则表达式后部分的完整描述。
- en: 'To kick it up one more notch, here are some of the changes we can make to the
    regex that allows us to use space or dot characters as digit separators rather
    than only dashes:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了再提高一个层次，以下是一些我们可以对正则表达式进行的更改，允许我们使用空格或点字符作为数字分隔符，而不是仅使用破折号：
- en: '[PRE99]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Activity 11.03: Refactoring to Clean Code'
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.03：重构为简洁代码
- en: 'Solution:'
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案：
- en: Note
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are many ways the code could be refactored. The following solution represents
    one way, along with explanatory comments.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以通过多种方式进行重构。以下解决方案代表了一种方式，并附有解释性注释。
- en: Use the `activity_solution.html` file. The HTML code remains the same as the
    original code. Only the contents of the `<script>` section are replaced.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `activity_solution.html` 文件。HTML 代码与原始代码相同。只有 `<script>` 部分的内文被替换。
- en: 'We start refactoring the code by creating a function called `processForm()`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过创建一个名为 `processForm()` 的函数开始重构代码：
- en: '[PRE100]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The original code had one very long method that did all the form field processing,
    validations, and calculations. The new code creates new methods for different
    concerns. These methods are short and mostly focused on just one task.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原始代码有一个非常长的函数，它处理了所有表单字段处理、验证和计算。新代码为不同的关注点创建了新的方法。这些方法简短，主要专注于单一任务。
- en: 'The code reads like a narrative story with paragraphs and sentences in mostly
    plain English. It is easy to see the logic and flow just by reading it, and there''s
    not much clutter: reset the errors and results, get the form fields, validate
    the fields and show errors (if any), do the calculation, and display the results.
    The gory details of each of these are contained within other methods.'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码读起来像是一个叙事故事，段落和句子主要是用普通的英语写的。仅通过阅读它，就可以很容易地看到逻辑和流程，而且没有太多杂乱：重置错误和结果，获取表单字段，验证字段并显示错误（如果有），进行计算，并显示结果。每个这些的详细信息都包含在其他方法中。
- en: 'We will also create a function called `resetErrorsAndResults()`. By the name
    and implementation, it is easy to tell what the purpose of this function is, and
    the function is limited to just that specific purpose:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建一个名为 `resetErrorsAndResults()` 的函数。根据名称和实现，很容易判断这个函数的目的是什么，并且这个函数仅限于这个特定目的：
- en: '[PRE101]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'For the next refactoring, we have decided to create a class that holds form
    field values and performs validations:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个重构，我们决定创建一个类来保存表单字段值并执行验证：
- en: '[PRE102]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Validation methods are simple and only return a string with an error message
    if the regex test fails. Displaying error messages is a separate concern (unlike
    the original code, which combined the concerns). It contains a constructor where
    the form field values are passed in rather than us having to get the values directly
    from the form, thus allowing the class and validations to be tested independently
    of the form itself.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证方法简单，如果正则表达式测试失败，则仅返回一个包含错误信息的字符串。显示错误信息是一个独立的问题（与原始代码不同，原始代码将这些问题合并在一起）。它包含一个构造函数，其中表单字段的值被传递进来，而不是我们需要直接从表单中获取这些值，从而允许类和验证独立于表单本身进行测试。
- en: 'Next, we create a function called `getFormFields()`. This function is limited
    to getting the values from the form and creating an instance of the `FormFields`
    class:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 `getFormFields()` 的函数。这个函数仅限于从表单中获取值并创建 `FormFields` 类的实例：
- en: '[PRE103]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: These methods have no side effects as they facilitate testing. This is because
    the return values are always predicable for a given set of input parameters.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法没有副作用，因为它们便于测试。这是因为对于给定的一组输入参数，返回值总是可预测的。
- en: 'The `displayError()` and `displayResult()` functions are straightforward and
    do just one thing:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`displayError()` 和 `displayResult()` 函数简单，只做一件事：'
- en: '[PRE104]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The `switch` statement in the original code was just screaming out "refactor
    me" to separate functions for each case! We will refactor this so that it uses
    an associative array called `calculateFunctions`. The key of each entry in the
    array is `workerType` and the user that's selected from the radio buttons, along
    with a reference to the function that contains the corresponding calculation logic
    for the value. These are minimal comments since the method, object, and variable
    names are self-documenting.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原始代码中的 `switch` 语句正大声疾呼“重构我”，以便为每个情况分离出函数！我们将重构它，使其使用一个名为 `calculateFunctions`
    的关联数组。数组中每个条目的键是 `workerType`，以及从单选按钮中选定的用户，以及包含相应计算逻辑的函数的引用。这些注释是最小的，因为方法、对象和变量名都是自文档化的。
- en: 'Also, the `calculateStandardWorkerPay()`, `calculateNoOvertimeWorkerPay()`,
    and `calculateDoubleOvertimeWorkerPay()` functions take the same two parameters
    and have the same return value definition, so they could be called abstractly
    in `doCalculation()`:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`calculateStandardWorkerPay()`、`calculateNoOvertimeWorkerPay()` 和 `calculateDoubleOvertimeWorkerPay()`
    函数接受相同的两个参数，并且具有相同的返回值定义，因此它们可以在 `doCalculation()` 中抽象地调用：
- en: '[PRE105]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In a real application, you may consider using one of the many available validation
    frameworks rather than rolling your own. For calculation purposes, this implementation
    chose to use functions in an associative array. One alternative to consider is
    creating a class hierarchy where subclasses implement or override a calculation
    method in a base class.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你可能考虑使用许多可用的验证框架之一，而不是自己编写。为了计算目的，这个实现选择使用关联数组中的函数。可以考虑的一个替代方案是创建一个类层次结构，其中子类在基类中实现或覆盖一个计算方法。
- en: 'Chapter 12: Using Next-Generation JavaScript'
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章：使用下一代 JavaScript
- en: 'Activity 12.01: Creating a Project to Recognize and Compile TypeScript Files'
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 12.01：创建一个用于识别和编译 TypeScript 文件的项目
- en: 'Solution:'
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'The first step is to create a new project directory, then `cd` into it, and
    initialize it for npm:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个新的项目目录，然后使用 `cd` 命令进入该目录，并使用 npm 初始化它：
- en: '[PRE106]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Next, install Parcel as a global library:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，全局安装 Parcel 库：
- en: '[PRE107]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now, you will need to install TypeScript, which you can also save as a global
    library:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要安装TypeScript，你也可以将其保存为全局库：
- en: '[PRE108]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'To generate the configuration for TypeScript, you simply need to call the TypeScript
    CLI tool, `tsc`, and pass it the `--init` flag:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成TypeScript的配置，你只需调用TypeScript CLI工具`tsc`，并传递`--init`标志：
- en: '[PRE109]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'If all went well, you should be presented with a message such as the following:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到一个类似以下的消息：
- en: '[PRE110]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: You should also find a new `tsconfig.json` file in the root of your project
    folder.
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还应该在项目文件夹的根目录中找到一个名为`tsconfig.json`的新文件。
- en: 'Next, create a directory called `src` and place an `index.ts` file within it.
    Add the following code as the file''s content:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`src`的目录，并在其中放置一个`index.ts`文件。将以下代码作为文件的内容添加进去：
- en: '[PRE111]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'With everything in place, update the `package.json` file to include the following
    script:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切准备就绪后，更新`package.json`文件以包含以下脚本：
- en: '[PRE112]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Finally, run the script by invoking the `npm` executable:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过调用`npm`可执行文件来运行脚本：
- en: '[PRE113]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: You should see a successful `Built` message output onscreen, as well as the
    expected `dist` folder containing transpiled `js` files in the project root.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在屏幕上看到一个成功的`Built`消息输出，以及包含在项目根目录中的预期`dist`文件夹，其中包含转换后的`js`文件。
- en: 'Chapter 13: JavaScript Programming Paradigms'
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章：JavaScript编程范式
- en: 'Activity 13.01: Creating a Calculator App'
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.01：创建计算器应用程序
- en: Solution
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create an empty file and call it `procedural.js`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空文件，并将其命名为`procedural.js`。
- en: 'Initialize an array that will maintain the history of function calls:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个数组，它将维护函数调用的历史记录：
- en: '[PRE114]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now, create simple addition, subtraction, multiplication, division, and power
    functions:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建简单的加法、减法、乘法、除法和幂函数：
- en: '[PRE115]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Create a `history` function, which will maintain the history of function calls:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`history`函数，它将维护函数调用的历史记录：
- en: '[PRE116]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now, print the `history`:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打印`history`：
- en: '[PRE117]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The output of this code will be as follows:'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码的输出结果如下：
- en: '![Figure 13.15: Output with the procedural approach'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图13.15：过程式方法的输出'
- en: '](img/C14377_14_151.jpg)'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14377_14_151.jpg]'
- en: 'Figure 13.15: Output with the procedural approach'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.15：过程式方法的输出
- en: 'Now, create a class and call it `calculator`:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个类，并将其命名为`calculator`：
- en: '[PRE118]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Then, initialize a `historyList` array, which will maintain the history of
    all function calls:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，初始化一个`historyList`数组，它将维护所有函数调用的历史记录：
- en: '[PRE119]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, create simple `add`, `subtract`, `multiply`, `divide`, and `pow` methods:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建简单的`add`、`subtract`、`multiply`、`divide`和`pow`方法：
- en: '[PRE120]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Add one more method, which will show the history of the operations:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个额外的函数，它将显示操作的历史记录：
- en: '[PRE121]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Lastly, create an instance of this class and call its method with simple numbers
    to perform mathematical operations:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建这个类的实例，并用简单的数字调用其方法以执行数学运算：
- en: '[PRE122]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'To check its history, call the `history` method of the `calculator` class:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查其历史记录，调用`calculator`类的`history`方法：
- en: '[PRE123]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The output of this code will be as follows:'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码的输出结果如下：
- en: '![Figure 13.16: Output with the object-oriented approach'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.16：面向对象方法的输出'
- en: '](img/C14377_14_161.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_14_161.jpg]'
- en: 'Figure 13.16: Output with the object-oriented approach'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16：面向对象方法的输出
- en: 'Chapter 14: Understanding Functional Programming'
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章：理解函数式编程
- en: 'Activity 14.01: Blackjack Card Functions'
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动14.01：黑杰克牌函数
- en: 'Solution:'
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'In the `blackjack/start.html` file, find the opening script tag and add some
    functions for defining the elements of a deck and creating an ordered deck:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`blackjack/start.html`文件中，找到打开的脚本标签，并添加一些定义牌元素和创建有序牌组的函数：
- en: '[PRE124]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Below this code, define how to create a deck by adding the core functional
    programming methods:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码下方，定义如何通过添加核心函数式编程方法来创建一副牌：
- en: '[PRE125]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Next, add the functions for shuffling a deck, as we did in *Exercise 14.09:
    Using the pipe Method to Create a Card Shuffling Function*:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加洗牌函数，就像我们在*练习14.09：使用管道方法创建洗牌函数*中做的那样：
- en: '[PRE126]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Now, we will add functions for drawing a card, getting the sum of a player''s
    cards, checking whether a hand is over 21 points, and checking whether the game
    is over:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加抽牌、计算玩家牌的总和、检查手牌是否超过21点以及检查游戏是否结束的函数：
- en: '[PRE127]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Next, we need to add a way to update the visual display and the cards shown
    to the user. One way this can be done is as follows:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一种更新视觉显示和向用户显示的牌的方法。以下是一种实现方式：
- en: '[PRE128]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The next part of the visual display is the status display, which tells the
    user the sum of their hand and whether the game is over. The implementation that
    will be used in this solution consists of the two functions shown in the following
    code:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个视觉显示部分是状态显示，它告诉用户他们的手牌总和以及游戏是否结束。在这个解决方案中将要使用的实现包括以下代码中显示的两个函数：
- en: '[PRE129]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now, we''re going to add functions for each action a user can take, such as
    `play`, `stay`, and `hit`. We will call these handlers:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为用户可以采取的每个动作添加函数，例如 `play`、`stay` 和 `hit`。我们将调用这些处理程序：
- en: '[PRE130]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'You may have noticed that, in the solution steps, there are some variables
    that haven''t been defined. We''ve saved these for a section at the end that includes
    all non-purely functional code:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在解决方案步骤中，有一些变量尚未定义。我们将这些保存到了一个包含所有非纯函数代码的末尾部分：
- en: '[PRE131]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We now have almost a completely working game. All we need to do is set the
    state and call that to tell the game to start:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在几乎有一个完全工作的游戏。我们只需要设置状态并调用它来告诉游戏开始：
- en: '[PRE132]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'With these steps done, you should now be able to open the HTML file in a browser
    and have a running version of the game, as shown in the following screenshot:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你现在应该能够在一个浏览器中打开 HTML 文件，并运行游戏的版本，如下面的截图所示：
- en: '![Figure 14.17: Screenshot of the Blackjack game'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.17：Blackjack 游戏截图]'
- en: '](img/C14377_15_17.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.17：Blackjack 游戏的截图](img/C14377_15_17.jpg)'
- en: 'Figure 14.17: Screenshot of the Blackjack game'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.17：Blackjack 游戏截图]'
- en: If you're unsure about whether you followed the solution steps correctly, feel
    free to take a look at the `blackjack/solution.html` file and compare it with
    your own implementation.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定是否正确地遵循了解决方案步骤，请随意查看 `blackjack/solution.html` 文件，并将其与你的实现进行比较。
- en: 'Chapter 15: Asynchronous Tasks'
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章：异步任务
- en: 'Activity 15.01: Refactoring Promise Code to await/async Syntax'
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 15.01：将 Promise 代码重构为 await/async 语法
- en: Solution
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here''s one implementation of equivalent code that uses `async/await`:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 `async/await` 的一种等效代码实现：
- en: 'Define the promise variables as follows:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式定义 promise 变量：
- en: '[PRE133]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'It would not have been correct to place the `await` keyword in the initial
    block when calling each function like this:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用每个函数时，将 `await` 关键字放置在初始块中是不正确的：
- en: '[PRE134]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This is because each of the use cases has a different timeout defined. If you
    used `await` when calling `use1()`, it would have caused a delay of 3 seconds
    until it completed before `use2()` was even initiated, which is not what you want.
    Rather, our desire is for all three use cases to trigger one right after the other
    with no delay, so they execute concurrently.
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为每个用例都有一个不同的超时定义。如果你在调用 `use1()` 时使用了 `await`，它会在 `use2()` 甚至开始之前造成 3 秒的延迟，这并不是你想要的。相反，我们的愿望是所有三个用例都一个接一个地触发，没有任何延迟，以便它们并发执行。
- en: 'You then have the three `await` keywords:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有三个 `await` 关键字：
- en: '[PRE135]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'It made sense to refactor each case into its own asynchronous functions: `use1()`,
    `use2()`, and `use3()`. The `async` keyword indicates that these functions are
    asynchronous ones (you could have used inline `async` functions, but this would
    have made for rather confusing and awkward syntax):'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个情况重构为其自己的异步函数：`use1()`、`use2()` 和 `use3()`。`async` 关键字表示这些函数是异步的（你也可以使用内联
    `async` 函数，但这会使语法变得相当混乱和尴尬）：
- en: '[PRE136]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In this activity, the order in which you wait for promises does not matter.
    Even though `await use1` will end up waiting 3 seconds, by the time `await use2`
    and `await use3` are called, both of those promises would have already been completed
    a second or two before, so they would just move on right away.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你等待 promises 的顺序并不重要。尽管 `await use1` 最终会等待 3 秒，但在调用 `await use2` 和 `await
    use3` 的时候，这两个 promises 已经在前一两秒内完成了，所以它们会立即继续执行。
- en: 'Activity 15.02: Further Simplifying Promise Code to Remove Function Parameters'
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 15.02：进一步简化 Promise 代码以删除函数参数
- en: Solution
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here''s one possible implementation. The two functions are very similar and
    have been refactored using two different styles for demonstration purposes. However,
    it is perfectly acceptable to solve the challenge using one or the other technique
    for both of the functions:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是可能的一种实现。这两个函数非常相似，为了演示目的，使用了两种不同的风格进行重构。然而，使用其中一种技术来解决这两个函数的挑战是完全可接受的：
- en: 'In technique #1, refactor `getTeamsInLeague` so that it now only takes one
    parameter, `(leagueName)`, rather than two parameters that are actually needed
    to determine the full result `(leagueData, leagueName)`. The other parameter is
    deferred until later:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在技术 #1 中，重构 `getTeamsInLeague`，使其现在只接受一个参数 `(leagueName)`，而不是两个参数来确定完整的结果 `(leagueData,
    leagueName)`。另一个参数被延迟到以后：'
- en: '[PRE137]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'In technique #1, instead of returning the promise from `myFetch` directly,
    you return another curried function that takes `leagueData` as its parameter (the
    parameter you deferred in the last step). It is only a partially applied function
    at this point:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在技术 #1 中，你并不是直接从 `myFetch` 返回承诺，而是返回另一个以 `leagueData` 作为其参数的柯里化函数（你在最后一步中延迟的参数）。在这个阶段，它只是一个部分应用过的函数：'
- en: '[PRE138]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Technique #2 is really the same idea, but uses a function variable and multiple
    levels of arrow functions rather than a regular function:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '技术编号 #2 实际上是一个相同的概念，但它使用函数变量和多层箭头函数，而不是常规函数：'
- en: '[PRE139]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Finally, when `getTeamsInLeague(LEAGUE_NAME)` is invoked in the `then()` clause,
    the function returned above would be fully applied, with the resolved value from
    the previous promise passed in as the implied `leagueData` parameter:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当在 `then()` 子句中调用 `getTeamsInLeague(LEAGUE_NAME)` 时，上面返回的函数会被完全应用，上一个承诺解析出的值作为隐含的
    `leagueData` 参数传入：
- en: '[PRE140]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'To perhaps make this plainer, let''s consider this as if it were written with
    `async/await` syntax. Refer to the following code. On the second line, the process
    when calling `getTeamsInLeague(LEAGUE_NAME)` is incomplete at that point and returns
    another function to complete it. Only when calling this partially applied function
    on the third line would you finally have the desired result:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了可能使这更清晰，让我们假设这是用 `async/await` 语法编写的。参考以下代码。在第二行，调用 `getTeamsInLeague(LEAGUE_NAME)`
    的过程在那个点是不完整的，并返回另一个函数来完成它。只有当你在第三行调用这个部分应用过的函数时，你才会最终得到期望的结果：
- en: '[PRE141]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
