- en: Chapter 11. Coding and Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。编码和设计模式
- en: Now that you know all about the objects in JavaScript, mastered prototypes and
    inheritance, and seen some practical examples of using browser-specific objects,
    let's move forward, or rather, move a level up. Let's take a look at some common
    JavaScript patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了JavaScript中的所有对象，掌握了原型和继承，也看到了一些使用浏览器特定对象的实际例子，让我们继续前进，或者说，提升一个层次。让我们来看看一些常见的JavaScript模式。
- en: But first, what's a pattern? In short, a pattern is a good solution to a common
    problem. Codifying the solution into a pattern makes it repeatable as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，什么是模式？简而言之，模式是针对常见问题的良好解决方案。将解决方案编纂成模式使其可重复。
- en: Sometimes, when you're facing a new programming problem, you may recognize right
    away that you've previously solved another, suspiciously similar problem. In such
    cases, it's worth isolating this class of problems and searching for a common
    solution. A pattern is a proven and reusable solution (or an approach to a solution)
    to a class of problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你面对一个新的编程问题时，你可能会立刻意识到你之前已经解决过另一个类似的问题。在这种情况下，值得隔离这类问题并寻找一个共同的解决方案。模式是对一类问题的经过验证的可重复解决方案（或解决方案的方法）。
- en: There are cases where a pattern is nothing more than an idea or a name. Sometimes,
    just using a name helps you think more clearly about a problem. Also, when working
    with other developers in a team, it's much easier to communicate when everybody
    uses the same terminology to discuss a problem or a solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，模式可能仅仅是一个想法或一个名称。有时，仅仅使用一个名称就能帮助你更清晰地思考问题。此外，当与团队中的其他开发者一起工作时，如果每个人都使用相同的术语来讨论问题或解决方案，沟通会更容易。
- en: Other times, you may come across a unique problem that doesn't look like anything
    you've seen before and doesn't readily fit into a known pattern. Blindly applying
    a pattern just for the sake of using a pattern, is not a good idea. It's preferable
    to not use any known pattern than to try to tweak your problem so that it fits
    an existing solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到一个独特的问题，它看起来不像你之前见过的任何东西，也不容易适应已知的模式。盲目地应用模式只是为了使用模式，这不是一个好主意。与其尝试调整你的问题以适应现有的解决方案，不如不使用任何已知的模式。
- en: 'This chapter talks about two types of patterns, which are as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论两种类型的模式，如下所示：
- en: '**Coding patterns**: These are mostly JavaScript-specific best practices'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码模式**：这些主要是JavaScript特定的最佳实践'
- en: '**Design patterns**: These are language-independent patterns, popularized by
    the famous *Gang of Four* book'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计模式**：这些是语言无关的模式，由著名的*四人帮*书籍推广'
- en: Coding patterns
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码模式
- en: 'Let''s start with some patterns that reflect JavaScript''s unique features.
    Some patterns aim to help you organize your code, for example, namespacing; others
    are related to improving performance, such as lazy definitions and init-time branching;
    and some make up for missing features, such as private properties. The patterns
    discussed in this section include the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些反映JavaScript独特特性的模式开始。有些模式旨在帮助你组织代码，例如命名空间；其他与提高性能相关，如懒定义和初始化时分支；还有一些是为了弥补缺失的功能，如私有属性。本节讨论的模式包括以下主题：
- en: Separating behavior
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离行为
- en: Namespaces
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Init-time branching
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化时分支
- en: Lazy definition
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒定义
- en: Configuration objects
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置对象
- en: Private variables and methods
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有变量和方法
- en: Privileged methods
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权方法
- en: Private functions as public methods
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将私有函数作为公共方法
- en: Immediate functions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即函数
- en: Chaining
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链式调用
- en: JSON
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: Separating behavior
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离行为
- en: 'As discussed previously, the three building blocks of a web page are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，网页的三个构建块如下：
- en: Content (HTML)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容（HTML）
- en: Presentation (CSS)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示（CSS）
- en: Behavior (JavaScript)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为（JavaScript）
- en: Content
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容
- en: HTML is the content of the web page, the actual text. Ideally, the content should
    be marked-up using the least amount of HTML tags that sufficiently describe the
    semantic meaning of that content. For example, if you're working on a navigation
    menu, it's a good idea to use the `<ul>` and `<li>` tags as a navigation menu
    is in essence, just a list of links.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: HTML是网页的内容，即实际文本。理想情况下，内容应该使用尽可能少的HTML标签进行标记，以充分描述该内容的语义意义。例如，如果你正在制作导航菜单，使用`<ul>`和`<li>`标签作为导航菜单是一个好主意，因为导航菜单本质上只是一个链接列表。
- en: 'Your content (HTML) should be free from any formatting elements. Visual formatting
    belongs to the presentation layer and should be achieved through the use of **CSS**
    (**Cascading Style Sheets**). This means the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你的内容（HTML）应该不包含任何格式化元素。视觉格式化属于表现层，应该通过使用**CSS**（**层叠样式表**）来实现。这意味着以下内容：
- en: The style attribute of HTML tags should not be used, if possible.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，不应使用HTML标签的`style`属性。
- en: Presentational HTML tags such as `<font>` should not be used at all.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应当完全不使用如`<font>`之类的表现性HTML标签。
- en: Tags should be used for their semantic meaning, not because of how browsers
    render them by default. For instance, developers sometimes use a `<div>` tag where
    a `<p>` would be more appropriate. It's also favorable to use `<strong>` and `<em>`
    instead of `<b>` and `<i>` as the latter describe the visual presentation rather
    than the meaning.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签应该用于它们的语义意义，而不是因为浏览器默认如何渲染它们。例如，开发者有时会在更适合使用`<p>`标签的地方使用`<div>`标签。使用`<strong>`和`<em>`代替`<b>`和`<i>`也是有益的，因为后者描述的是视觉表现而不是意义。
- en: Presentation
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表现性
- en: A good approach to keep presentation out of the content is to reset or nullify
    all browser defaults, for example, using `reset.css` from the Yahoo! UI library.
    This way, the browser's default rendering won't distract you from consciously
    thinking about the proper semantic tags to use.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将表现性内容从内容中分离的一个好方法是重置或取消所有浏览器默认设置，例如，使用Yahoo! UI库中的`reset.css`。这样，浏览器默认的渲染不会分散你对于正确语义标签的思考。
- en: Behavior
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行为
- en: The third component of a web page is the behavior. Behavior should be kept separate
    from both the content and the presentation. It is usually added by using JavaScript
    that is isolated to `<script>` tags, and preferably contained in external files.
    This means not using any inline attributes, such as `onclick`, `onmouseover`,
    and so on. Instead, you can use the `addEventListener`/`attachEvent` methods from
    the previous chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的第三个组成部分是行为。行为应该与内容和表现性内容保持分离。通常是通过使用隔离到`<script>`标签中的JavaScript来添加的，并且最好包含在外部文件中。这意味着不要使用任何内联属性，例如`onclick`、`onmouseover`等。相反，你可以使用上一章中提到的`addEventListener`/`attachEvent`方法。
- en: 'The best strategy to separate behavior from content is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将行为与内容分离的最佳策略如下：
- en: Minimize the number of `<script>` tags
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化`<script>`标签的数量
- en: Avoid inline event handlers
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用内联事件处理器
- en: Do not use CSS expressions
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用CSS表达式
- en: Toward the end of your content, when you are ready to close the `<body>` tag,
    insert a single `external.js` file
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的内容末尾，当你准备好关闭`<body>`标签时，插入一个单独的`external.js`文件
- en: Example of separating behavior
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分离行为的示例
- en: 'Let''s say you have a search form on a page, and you want to validate the form
    with JavaScript. So, you go ahead and keep the `form` tags free from any JavaScript,
    and then immediately before closing the `</body>` tag, you insert a `<script>`
    tag that links to an external file, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个页面上的搜索表单，并且你想要使用JavaScript来验证这个表单。因此，你继续并确保`form`标签不包含任何JavaScript，然后在`</body>`标签关闭之前立即插入一个指向外部文件的`<script>`标签，如下所示：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In `behaviors.js` you attach an event listener to the submit event. In your
    listener, you can check to see if the text input field was left blank and, if
    so, stop the form from being submitted. This way, you will save a roundtrip between
    the server and the client and make the application immediately responsive.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`behaviors.js`中，你为提交事件附加了一个事件监听器。在你的监听器中，你可以检查文本输入字段是否被留空，如果是这样，就阻止表单提交。这样，你将节省服务器和客户端之间的往返，并使应用程序立即响应。
- en: 'The content of `behaviors.js` is given in the following code. It assumes that
    you''ve created your `myevent` utility from the exercise at the end of the previous
    chapter:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`behaviors.js`的内容如下所示代码。它假设你已经从上一章末尾的练习中创建了你的`myevent`实用工具：'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Asynchronous JavaScript loading
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步JavaScript加载
- en: You noticed how the script was loaded at the end of the HTML, right before closing
    the body. The reason is that JavaScript blocks the DOM construction of the page,
    and in some browsers, even downloads of the other components that follow. By moving
    the scripts to the bottom of the page, you ensure that the script is out of the
    way, and when it arrives, it simply enhances the already usable page.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了脚本是在HTML的末尾加载的，就在关闭`body`标签之前。原因是JavaScript会阻止页面DOM的构建，在某些浏览器中，甚至还会阻止后续组件的下载。通过将脚本移到页面底部，你可以确保脚本不会妨碍，当它到达时，它只是简单地增强了已经可用的页面。
- en: 'Another way to prevent external JavaScript files from blocking the page is
    to load them asynchronously. This way you can start loading them earlier. HTML5
    has the `defer` attribute for this purpose. Consider the following line of code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 防止外部JavaScript文件阻塞页面的另一种方法是异步加载它们。这样你可以更早地开始加载它们。HTML5有`defer`属性用于此目的。考虑以下代码行：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Unfortunately, the `defer` attribute is not supported by older browsers, but
    luckily, there is a solution that works across browsers, old and new. The solution
    is to create a `script` node dynamically and append it to the DOM. In other words,
    you can use a bit of inline JavaScript to load the external JavaScript file. You
    can have this script loader snippet at the top of your document so that the download
    has an early start. Take a look at the following code example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`defer`属性不被旧版浏览器支持，但幸运的是，有一个适用于新旧浏览器的解决方案。该解决方案是动态创建一个`script`节点并将其附加到DOM中。换句话说，你可以使用一些内联JavaScript来加载外部JavaScript文件。你可以在文档的顶部放置这个脚本加载器代码片段，以便下载可以尽早开始。请看以下代码示例：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Namespaces
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: Global variables should be avoided in order to reduce the possibility of variable
    naming collisions. You can minimize the number of globals by namespacing your
    variables and functions. The idea is simple, you will create only one global object,
    and all your other variables and functions become properties of that object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应该避免使用全局变量，以减少变量命名冲突的可能性。你可以通过命名空间你的变量和函数来最小化全局变量的数量。这个想法很简单，你将只创建一个全局对象，而你所有的其他变量和函数都成为该对象属性的属性。
- en: An Object as a namespace
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象作为一个命名空间
- en: 'Let''s create a global object called `MYAPP`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`MYAPP`的全局对象：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, instead of having a global `myevent` utility (from the previous chapter),
    you can have it as an `event` property of the `MYAPP` object, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你不再需要全局的`myevent`实用工具（来自上一章），你可以将其作为`MYAPP`对象的`event`属性，如下所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding the methods to the `event` utility is still the same. Consider the following
    example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法添加到`event`实用工具中仍然相同。考虑以下示例：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Namespaced constructors
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间构造函数
- en: 'Using a namespace doesn''t prevent you from creating constructor functions.
    Here is how you can have a DOM utility that has an `Element` constructor, which
    allows you to create DOM elements easily:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间不会阻止你创建构造函数。以下是如何创建一个具有`Element`构造函数的DOM实用工具，这允许你轻松创建DOM元素：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, you can have a `Text` constructor to create text nodes. Consider
    the following code example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以有一个`Text`构造函数来创建文本节点。考虑以下代码示例：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the constructors to create a link at the bottom of a page can be done
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数在页面底部创建链接可以这样做：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A namespace() method
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: namespace()方法
- en: 'You can create a namespace utility that makes your life easier so that you
    can use more convenient syntax as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个命名空间实用工具，使你的生活更轻松，这样你就可以使用更方便的语法，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Instead of the more verbose syntax as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是如下更冗长的语法：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s how you can create such a `namespace()` method. First, you will create
    an array by splitting the input string using the period (`.`) as a separator.
    Then, for every element in the new array, you will add a property to your global
    object, if one doesn''t already exist, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何创建这样的`namespace()`方法的。首先，你将通过使用点（`.`）作为分隔符来分割输入字符串创建一个数组。然后，对于新数组中的每个元素，你将向你的全局对象添加一个属性，如果尚未存在，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Testing the new method is done as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 测试新方法如下：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result of the preceding code is the same as if you did the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果与以下操作相同：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Init-time branching
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化时分支
- en: In the previous chapter, you noticed that sometimes, different browsers have
    different implementations for the same or similar functionalities. In such cases,
    you will need to branch your code, depending on what's supported by the browser
    currently executing your script. Depending on your program, this branching can
    happen far too often and, as a result, may slow down the script execution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你注意到有时，不同的浏览器对相同或类似功能有不同的实现。在这种情况下，你需要根据当前执行脚本的浏览器支持的内容来分支你的代码。根据你的程序，这种分支可能会发生得太频繁，从而导致脚本执行速度变慢。
- en: You can mitigate this problem by branching some parts of the code during initialization,
    when the script loads, rather than during runtime. Building upon the ability to
    define functions dynamically, you can branch and define the same function with
    a different body, depending on the browser. Let's see how.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在初始化期间，即脚本加载时而不是在运行时，对代码的一些部分进行分支来减轻这个问题。基于能够动态定义函数的能力，你可以根据浏览器进行分支，并使用不同的主体定义相同的函数。让我们看看如何做。
- en: 'First, let''s define a namespace and placeholder method for the `event` utility:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为`event`实用工具定义一个命名空间和占位符方法：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At this point, the methods to add or remove a listener are not implemented.
    Based on the results from feature sniffing, these methods can be defined differently,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，添加或删除监听器的方法尚未实现。根据功能嗅探的结果，这些方法可以定义得不同，如下所示：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After this script executes, you have the `addListener()` and `removeListener()`
    methods defined in a browser-dependent way. Now, every time you invoke one of
    these methods, there's no more feature-sniffing, and it results in less work and
    faster execution.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本执行之后，你将定义了浏览器依赖的`addListener()`和`removeListener()`方法。现在，每次调用这些方法之一时，就不再进行功能嗅探，这导致工作量减少，执行速度更快。
- en: One thing to watch out for when sniffing features is not to assume too much
    after checking for one feature. In the previous example, this rule is broken because
    the code only checks for `addEventListener` support, but then defines both `addListener()`
    and `removeListener()`. In this case, it's probably safe to assume that if a browser
    implements `addEventListener()`, it also implements `removeEventListener()`. However,
    imagine what happens if a browser implements `stopPropagation()` but not `preventDefault()`,
    and you haven't checked for these individually. You have assumed that because
    `addEventListener()` is not defined, the browser must be an old IE and write your
    code using your knowledge and assumptions of how IE works. Remember that all of
    your knowledge is based on the way a certain browser works today, but not necessarily
    the way it will work tomorrow. So, to avoid many rewrites of your code as new
    browser versions are shipped, it's best to individually check for features you
    intend to use and don't generalize on what a certain browser supports.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在嗅探功能时要留意的一点是，在检查了一个功能之后不要假设太多。在之前的例子中，这条规则被违反了，因为代码只检查了`addEventListener`的支持，但随后定义了`addListener()`和`removeListener()`。在这种情况下，假设如果浏览器实现了`addEventListener()`，它也实现了`removeEventListener()`可能是安全的。然而，想象一下如果浏览器实现了`stopPropagation()`但没有实现`preventDefault()`，而你没有单独检查这些功能会发生什么。你假设因为`addEventListener()`未定义，浏览器必须是旧IE，并使用你对IE如何工作的知识和假设来编写代码。记住，你所有的知识都是基于今天某个浏览器的工作方式，但不一定是明天的工作方式。因此，为了避免在新浏览器版本发布时多次重写代码，最好单独检查你打算使用的功能，不要对某个浏览器支持的功能进行泛化。
- en: Lazy definition
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒定义
- en: The lazy definition pattern is similar to the previous init-time branching pattern.
    The difference is that the branching happens only when the function is called
    for the first time. When the function is called, it redefines itself with the
    best implementation. Unlike the init-time branching, where the if happens once,
    during loading, here it may not happen at all, in cases when the function is never
    called. The lazy definition also makes the initialization process lighter as there's
    no init-time branching work to be done.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 懒定义模式与之前的初始化时分支模式类似。不同之处在于分支仅在函数第一次被调用时发生。当函数被调用时，它会用最佳实现重新定义自己。与初始化时分支不同，那里的if只发生一次，在加载期间，这里可能根本不会发生，在函数从未被调用的情况下。懒定义还使得初始化过程更轻量，因为没有初始化时分支的工作要做。
- en: 'Let''s see an example that illustrates this via the definition of an `addListener()`
    function. The function is first defined with a generic body. It checks which functionality
    is supported by the browser when it''s called for the first time and then redefines
    itself using the most suitable implementation. At the end of the first call, the
    function calls itself, so that the actual event attaching is performed. The next
    time you call the same function, it will be defined with its new body and be ready
    for use, so no further branching is necessary. The following is the code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`addListener()`函数的定义来举例说明这一点。该函数首先定义了一个通用的主体。它在第一次被调用时检查浏览器支持哪些功能，然后使用最合适的实现重新定义自己。在第一次调用结束时，函数会调用自己，以便执行实际的事件附加。下次你调用同一个函数时，它将使用新的主体定义并准备好使用，因此不需要进一步的分支。以下是一个代码片段：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Configuration object
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置对象
- en: This pattern is convenient when you have a function or method that accepts a
    lot of optional parameters. It's up to you to decide how many constitutes a lot.
    But generally, a function with more than three parameters is not convenient to
    call, because you have to remember the order of the parameters, and it is even
    more inconvenient when some of the parameters are optional.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个接受很多可选参数的函数或方法时，这种模式很方便。由你决定多少构成“很多”。但通常，具有三个以上参数的函数不太方便调用，因为你必须记住参数的顺序，而当一些参数是可选的时候，这甚至更加不方便。
- en: 'Instead of having many parameters, you can use one parameter and make it an
    object. The properties of the object are the actual parameters. This is suitable
    to pass configuration options because these tend to be numerous and optional (with
    smart defaults). The beauty of using a single object as opposed to multiple parameters
    is described as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是有很多参数，你可以使用一个参数并将其作为一个对象。对象属性是实际参数。这适合传递配置选项，因为这些通常数量众多且可选（具有智能默认值）。使用单个对象而不是多个参数的优点如下所述：
- en: The order doesn't matter
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序无关紧要
- en: You can easily skip parameters that you don't want to set
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以轻松跳过你不想设置的参数
- en: It's easy to add more optional configuration attributes
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多可选配置属性很容易
- en: It makes the code more readable because the configuration object's properties
    are present in the calling code along with their names
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得代码更易于阅读，因为配置对象的属性及其名称都出现在调用代码中
- en: 'Imagine you have some sort of UI widget constructor you use to create fancy
    buttons. It accepts the text to put inside the button (the `value` attribute of
    the `<input>` tag) and an optional parameter of the `type` of button. For simplicity,
    let''s say the fancy button takes the same configuration as a regular button.
    Take a look at the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一种UI小部件构造函数，用于创建花哨的按钮。它接受要放在按钮内的文本（`<input>`标签的`value`属性）和按钮的`type`类型的可选参数。为了简单起见，让我们假设花哨按钮的配置与普通按钮相同。看看以下代码：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using the constructor is simple; you just give it a string. Then, you can add
    the new button to the body of the document as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数很简单；你只需给它一个字符串。然后，你可以将新按钮添加到文档的主体中如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is all well and works fine, but then you decide you also want to be able
    to set some of the style properties of the button, such as colors and fonts. You
    can end up with a definition like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很顺利，工作得很好，但后来你决定你还想能够设置一些按钮的样式属性，例如颜色和字体。你可能会得到以下定义：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, using the constructor can become a little inconvenient, especially when
    you want to set the third and fifth parameter, but not the second or the fourth.
    Consider the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用构造函数可能会变得有点不方便，尤其是当你想设置第三个和第五个参数，但不设置第二个或第四个参数时。考虑以下示例：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A better approach is to use one `config` object parameter for all the settings.
    The function definition can become something like the following code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用一个`config`对象参数来设置所有设置。函数定义可以变成以下代码片段：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using the constructor is shown as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数的示例如下：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another usage example is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用法示例如下：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, it's easy to set only some of the parameters and to switch around
    their order. In addition, the code is friendlier and easier to understand when
    you see the names of the parameters at the same place where you call the method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，很容易只设置一些参数并改变它们的顺序。此外，当你看到参数的名称与调用方法的位置相同时，代码更友好且易于理解。
- en: A drawback of this pattern is the same as its strength. It's trivial to keep
    adding more parameters, which means trivial to abuse the technique. Once you have
    an excuse to add to this free-for-all bag of properties, you will find it tempting
    to keep adding some that are not entirely optional, or some that are dependent
    on other properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的缺点与它的优点相同。很容易继续添加更多参数，这意味着很容易滥用这项技术。一旦你找到了添加到这个免费属性袋中的理由，你会发现继续添加一些非完全可选的或依赖于其他属性的属性很有诱惑力。
- en: As a rule of thumb, all these properties should be independent and optional.
    If you have to check all possible combinations inside your function ("oh, A is
    set, but A is only used if B is also set"), this is a recipe for a large function
    body, which quickly becomes confusing and difficult, if not impossible, to test,
    because of all the combinations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项经验法则，所有这些属性应该是独立的和可选的。如果你必须在函数内部检查所有可能的组合（“哦，A 已经设置，但只有在 B 也设置的情况下才会使用 A”），这将是大型函数体的配方，这会很快变得令人困惑，难以测试，如果不是不可能的话，因为所有这些组合。
- en: Private properties and methods
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有属性和方法
- en: 'JavaScript doesn''t have the notion of access modifiers, which set the privileges
    of the properties in an object. Other languages often have access modifiers, as
    follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 没有访问修饰符的概念，它不会设置对象中属性的权限。其他语言通常有访问修饰符，如下所示：
- en: '`Public`: All users of an object can access these properties or methods'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`公共`：对象的所有用户都可以访问这些属性或方法'
- en: '`Private`: Only the object itself can access these properties'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`私有`：只有对象本身可以访问这些属性'
- en: '`Protected`: Only objects inheriting the object in question can access these
    properties'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`受保护`：只有继承该对象的子对象可以访问这些属性'
- en: JavaScript doesn't have a special syntax to denote private properties or methods,
    but as discussed in [Chapter 3](ch03.html "Chapter 3. Functions"), *Functions*,
    you can use local variables and methods inside a function and achieve the same
    level of protection.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 没有特殊的语法来表示私有属性或方法，但如 [第 3 章](ch03.html "第 3 章。函数") 中所讨论的，*函数*，你可以在函数内部使用局部变量和方法，达到相同级别的保护。
- en: 'Continuing with the example of the `FancyButton` constructor, you can have
    local variable styles that contains all the defaults, and a local `setStyle()`
    function. These are invisible to the code outside of the constructor. Here''s
    how `FancyButton` can make use of the local private properties:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以 `FancyButton` 构造函数为例，你可以拥有包含所有默认值的局部变量样式，以及一个局部的 `setStyle()` 函数。这些对构造函数外部的代码来说是不可见的。以下是
    `FancyButton` 如何利用局部私有属性的方式：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this implementation, `styles` is a private property and `setStyle()` is a
    private method. The constructor uses them internally (and they can access anything
    inside the constructor), but they are not available to code outside of the function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，`styles` 是一个私有属性，`setStyle()` 是一个私有方法。构造函数内部使用它们（并且它们可以访问构造函数内部的所有内容），但它们对函数外部的代码不可用。
- en: Privileged methods
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特权方法
- en: Privileged methods (this term was coined by Douglas Crockford) are normal public
    methods that can access private methods or properties. They can act like a bridge
    in making some of the private functionality accessible, but in a controlled manner,
    wrapped in a privileged method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 特权方法（这个术语是由 Douglas Crockford 提出的）是正常的公共方法，可以访问私有方法或属性。它们可以像桥梁一样在受控的方式下使一些私有功能可访问，但仍然通过特权方法进行封装。
- en: Private functions as public methods
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将私有函数作为公共方法
- en: Let's say you've defined a function that you absolutely need to keep intact,
    so you make it private. However, you also want to provide access to the same function,
    so that outside code can also benefit from it. In this case, you can assign the
    private function to a publicly available property.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你定义了一个你绝对需要保持完整的函数，因此你将其设置为私有。然而，你仍然希望提供对该函数的访问，以便外部代码也能从中受益。在这种情况下，你可以将私有函数分配给一个公开可用的属性。
- en: 'Let''s define `_setStyle()` and `_getStyle()` as private functions, but then
    assign them to the public `setStyle()` and `getStyle()`, consider the following
    example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义 `_setStyle()` 和 `_getStyle()` 作为私有函数，然后将它们分配给公共的 `setStyle()` 和 `getStyle()`，以下是一个示例：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, when you call `MYAPP.dom.setStyle()`, it invokes the private `_setStyle()`
    function. You can also overwrite `setStyle()` from the outside as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用 `MYAPP.dom.setStyle()` 时，它将调用私有 `_setStyle()` 函数。你还可以如下从外部覆盖 `setStyle()`：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, the result is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果是如下所示：
- en: '`MYAPP.dom.setStyle` points to the new function'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYAPP.dom.setStyle` 指向新的函数'
- en: '`MYAPP.dom.yetAnother` still points to `_setStyle()`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYAPP.dom.yetAnother` 仍然指向 `_setStyle()`'
- en: '`_setStyle()` is always available when any other internal code relies on it
    to be working as intended, regardless of the outside code'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_setStyle()`始终可用，当任何其他内部代码依赖于它按预期工作，而不管外部代码如何'
- en: When you expose something private, keep in mind that objects (functions and
    arrays are objects too) are passed by reference and, therefore, can be modified
    from the outside.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你公开某些私有内容时，请记住对象（函数和数组也是对象）是通过引用传递的，因此可以从外部修改。
- en: Immediate functions
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立即函数
- en: 'Another pattern that helps you keep the global namespace clean is to wrap your
    code in an anonymous function and execute that function immediately. This way,
    any variables inside the function are local, as long as you use the `var` statement,
    and are destroyed when the function returns, if they aren''t part of a closure.
    This pattern was discussed in more detail in [Chapter 3](ch03.html "Chapter 3. Functions"),
    *Functions*. Take a look at the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种帮助你保持全局命名空间清洁的模式是将你的代码包裹在一个匿名函数中并立即执行该函数。这样，只要使用`var`语句，函数内的任何变量都是局部的，当函数返回时，如果它们不是闭包的一部分，就会被销毁。这种模式在[第3章](ch03.html
    "第3章。函数")*函数*中进行了更详细的讨论。看看以下代码：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This pattern is especially suitable for on-off initialization task, performed
    when the script loads.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式特别适合在脚本加载时执行的开关初始化任务。
- en: 'The immediate self-executing function pattern can be extended to create and
    return objects. If the creation of these objects is more complicated and involves
    some initialization work, then you can do this in the first part of the self-executable
    function and return a single object that can access and benefit from any private
    properties at the top portion, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 立即自执行的函数模式可以扩展为创建和返回对象。如果这些对象的创建更复杂且涉及一些初始化工作，那么你可以在自执行函数的第一部分完成这些工作，并返回一个可以访问和利用顶部部分任何私有属性的单个对象，如下所示：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Modules
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: Combining several of the previous patterns gives you a new pattern, commonly
    referred to as a module pattern. The concept of modules in programming is convenient
    as it allows you to code separate pieces or libraries and combine them as needed,
    just like pieces of a puzzle.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面几种模式结合起来，可以得到一种新的模式，通常称为模块模式。在编程中，模块的概念很方便，因为它允许你编写独立的片段或库，并根据需要将它们组合起来，就像拼图一样。
- en: 'The module pattern includes the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式包括以下内容：
- en: Namespaces to reduce naming conflicts among modules
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间用于减少模块之间的命名冲突
- en: An immediate function to provide a private scope and initialization
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供私有作用域和初始化的即时函数
- en: Private properties and methods
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有属性和方法
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ES5 doesn't have a built-in concept of modules. There is the module specification
    from [http://www.commonjs.org](http://www.commonjs.org), which defines a `require()`
    function and an exports object. ES6, however, supports modules. [Chapter 8](ch08.html
    "Chapter 8. Classes and Modules"), Classes and Modules has covered modules in
    detail.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ES5没有内置的模块概念。有来自[http://www.commonjs.org](http://www.commonjs.org)的模块规范，它定义了一个`require()`函数和一个exports对象。然而，ES6支持模块。[第8章](ch08.html
    "第8章。类和模块")详细介绍了模块。
- en: 'Returning an object that has the public API of the module as follows:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回具有模块公共API的对象，如下所示：
- en: '[PRE30]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And, you can use the module in the following way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用模块如下所示：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Chaining
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链式
- en: Chaining is a pattern that allows you to invoke multiple methods on one line
    as if the methods are the links in a chain. This is convenient when calling several
    related methods. You invoke the next method on the result of the previous without
    the use of an intermediate variable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 链式是一种模式，允许你在一行中调用多个方法，就像链中的链接一样。当调用多个相关方法时，这很方便。你可以在前一个方法的结果上调用下一个方法，而不需要使用中间变量。
- en: 'Say you''ve created a constructor that helps you work with DOM elements. The
    code to create a new `<span>` tag that is added to the `<body>` tag can look something
    like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你创建了一个构造函数，帮助你处理DOM元素。创建一个新`<span>`标签并将其添加到`<body>`标签的代码可能看起来像以下这样：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you know, constructors return the object referred to as `this` keyword that
    they create. You can make your methods, such as `setText()` and `setStyle()`,
    also return `this` keyword, which allows you to call the next method on the instance
    returned by the previous one. This way, you can chain method calls, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，构造函数通过`this`关键字返回它们创建的对象。你可以让你的方法，例如`setText()`和`setStyle()`，也返回`this`关键字，这允许你在前一个方法返回的实例上调用下一个方法。这样，你可以链式调用方法，如下所示：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You don''t even need the `obj` variable if you don''t plan on using it after
    the new element has been added to the tree, so the code looks like the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在将新元素添加到树中后不打算使用 `obj` 变量，那么您甚至不需要这个变量，代码看起来如下所示：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A drawback of this pattern is that it makes it a little harder to debug when
    an error occurs somewhere in a long chain, and you don't know which link is to
    blame because they are all on the same line.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的缺点是，当错误发生在长链中的某个地方，而您不知道哪个环节是问题所在，因为它们都在同一行时，这会使调试变得稍微困难一些。
- en: JSON
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON
- en: Let's wrap up the coding patterns section of this chapter with a few words about
    JSON. JSON is not technically a coding pattern, but you can say that using it
    is a good pattern.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用关于 JSON 的几句话来总结本章的编码模式部分。JSON 严格来说不是一种编码模式，但可以说使用它是良好的模式。
- en: 'JSON is a popular lightweight format to exchange data. It''s often preferred
    over XML when using `XMLHttpRequest()` to retrieve data from the server. There''s
    nothing specifically interesting about **JSON** other than the fact that it''s
    extremely convenient. The JSON format consists of data defined using object and
    array literals. Here is an example of a JSON string that your server can respond
    with after an `XHR` request:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是一种流行的轻量级数据交换格式。在用 `XMLHttpRequest()` 从服务器获取数据时，它通常比 XML 更受欢迎。除了它极其方便之外，**JSON**
    没有什么特别有趣的地方。JSON 格式由使用对象和数组字面量定义的数据组成。以下是一个 JSON 字符串的示例，您的服务器可以在 `XHR` 请求后响应：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'An XML equivalent of this will be something like the following piece of code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于这个的 XML 将类似于以下代码片段：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'First, you can see how JSON is lighter in terms of the number of bytes. However,
    the main benefit is not the smaller byte size, but the fact that it''s trivial
    to work with JSON in JavaScript. Let''s say, you''ve made an `XHR` request and
    have received a JSON string in the `responseText` property of the `XHR` object.
    You can convert this string of data into a working JavaScript object by simply
    using `eval()`. Consider the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以看到 JSON 在字节数量上更轻。然而，主要的好处不是更小的字节大小，而是它在 JavaScript 中处理 JSON 的简单性。假设，您已经发出了一个
    `XHR` 请求，并在 `XHR` 对象的 `responseText` 属性中收到了一个 JSON 字符串。您可以通过简单地使用 `eval()` 将这串数据转换为可工作的
    JavaScript 对象。考虑以下示例：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, you can access the data in `obj` as object properties as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过以下方式将 `obj` 中的数据作为对象属性访问：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The problem is that `eval()` is insecure, so it''s best if you use the JSON
    object to parse the JSON data (a fallback for older browsers is available at [http://json.org/](http://json.org/)).
    Creating an object from a JSON string is still trivial as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 `eval()` 是不安全的，因此最好使用 JSON 对象来解析 JSON 数据（对于旧浏览器，[http://json.org/](http://json.org/)
    提供了备选方案）。从 JSON 字符串创建对象仍然很简单，如下所示：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To do the opposite, that is, to convert an object to a JSON string, you can
    use the `stringify()` method, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要做相反的操作，即把对象转换为 JSON 字符串，您可以使用 `stringify()` 方法，如下所示：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Due to its simplicity, JSON has quickly become popular as a language-independent
    format to exchange data, and you can easily produce JSON on the server side using
    your preferred language. In PHP, for example, there are the `json_encode()` and
    `json_decode()` functions that let you serialize a PHP array or object into a
    JSON string, and vice versa.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性，JSON 很快成为了一种流行的、与语言无关的数据交换格式，您可以使用您喜欢的语言轻松地在服务器端生成 JSON。例如，在 PHP 中，有
    `json_encode()` 和 `json_decode()` 函数，可以让您将 PHP 数组或对象序列化为 JSON 字符串，反之亦然。
- en: Higher order functions
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Functional programming was confined to a limited set of languages so far. With
    more languages adding features to support functional programming, interest in
    the area is gaining momentum. JavaScript is evolving to support common features
    of functional programming. You will gradually see a lot of code written in this
    style. It is important to understand the functional programming style, even if
    you don't feel inclined just yet to use it in your code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程到目前为止仅限于有限的语言集合。随着更多语言添加支持函数式编程的功能，该领域的兴趣正在增长。JavaScript 正在演变以支持函数式编程的常见特性。你将逐渐看到大量以这种风格编写的代码。即使你现在还没有打算在代码中使用它，理解函数式编程风格也很重要。
- en: 'Higher order functions are one of the important mainstays of functional programing.
    Higher order function is a function that does at least one of the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是函数式编程的重要支柱之一。高阶函数是指至少执行以下操作之一的函数：
- en: Takes one or more functions as arguments
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个或多个函数作为参数
- en: Returns a function as a result
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数作为结果
- en: As functions are first class objects in JavaScript, passing and returning functions
    to and from a function is a pretty routine affair. Callbacks are higher order
    functions. Let's take a look at how we can take these two principles together
    and write a higher order function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数在JavaScript中是一等对象，因此将函数传递给函数并从函数返回函数是一件相当常规的事情。回调函数是高阶函数。让我们看看如何将这两个原则结合起来，编写一个高阶函数。
- en: Let's write a `filter` function; this function filters out values from an array
    based on a criteria determined by a function. This function takes two arguments-a
    function, which returns a Boolean value, `true` for keeping this element.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`filter`函数；这个函数根据一个函数确定的准则从数组中过滤出值。这个函数接受两个参数——一个函数，它返回一个布尔值，`true`表示保留该元素。
- en: 'For example, with this function, we are filtering all odd values from an array.
    Consider the following lines of code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用这个函数，我们正在过滤数组中的所有奇数。考虑以下代码行：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are passing an anonymous function to the `filter` function as the first argument.
    This function returns a Boolean based on a condition that checks if the element
    is odd or even.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个匿名函数传递给`filter`函数作为第一个参数。这个函数根据一个条件返回布尔值，该条件检查元素是奇数还是偶数。
- en: This is an example of one of the several higher order functions added to ECMAScript
    5\. The point we are trying to make here is that you will increasingly see similar
    patterns of usage in JavaScript. You must first understand how higher order functions
    work and later, once you are comfortable with the concept, try to incorporate
    them in your code as well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是ECMAScript 5中添加的几个高阶函数之一。我们在这里试图说明的是，你将越来越多地在JavaScript中看到类似的用法模式。你必须首先理解高阶函数是如何工作的，然后，一旦你对这个概念感到舒适，尝试在你的代码中融入它们。
- en: 'With ES6 function syntax changes, it is even more elegant to write higher order
    functions. Let''s take a small example in ES5 and see how that translates into
    its ES6 equivalent:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 随着ES6函数语法的改变，编写高阶函数变得更加优雅。让我们以ES5中的一个简单例子来看一下它是如何转换为ES6等价的：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `add` function takes `x` and returns a function that takes `y` as an argument
    and then returns value of expression `y+x`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`函数接受`x`并返回一个函数，该函数接受`y`作为参数，然后返回表达式`y+x`的值。'
- en: 'When we looked at arrow functions, we discussed that arrow functions return
    results of a single expression implicitly. So, the preceding function can be turned
    into an arrow function by making the body of the arrow function another arrow
    function. Take a look at the following example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看箭头函数时，我们讨论了箭头函数隐式返回单个表达式的结果。因此，前面的函数可以通过将箭头函数的主体变成另一个箭头函数来转换为箭头函数。看看下面的例子：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we have an outer function, `x =>` [inner function with `x` as argument],
    and we have an inner function, `y => y+x`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个外部函数`x =>` [以`x`为参数的内部函数]，以及一个内部函数`y => y+x`。
- en: This introduction will help you get familiar with the increasing usage of higher
    order functions, and their increased importance in JavaScript.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇介绍将帮助你熟悉高阶函数日益增加的使用，以及它们在JavaScript中的重要性日益增加。
- en: Design patterns
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: 'The second part of this chapter presents a JavaScript approach to a subset
    of the design patterns introduced by *Design Patterns: Elements of Reusable Object-Oriented
    Software*, an influential book most commonly referred to as the *Book of Four*,
    the *Gang of Four*, or *GoF* (after its four authors). The patterns discussed
    in the *GoF* book are divided into the three following groups:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分介绍了JavaScript对由影响深远的书籍《设计模式：可复用面向对象软件元素》中介绍的设计模式子集的方法，这本书通常被称为**四书**、**四人帮**或**GoF**（根据其四位作者命名）。在GoF书中讨论的模式分为以下三个组：
- en: Creational patterns that deal with how objects are created (instantiated)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理对象创建（实例化）的**创建模式**
- en: Structural patterns that describe how different objects can be composed in order
    to provide new functionality
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述不同对象如何组合以提供新功能的**结构模式**
- en: Behavioral patterns that describe ways for objects to communicate with each
    other
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述对象之间通信方式的**行为模式**
- en: There are 23 patterns in the *Book of Four*, and more patterns have been identified
    since the book's publication. It's way beyond the scope of this book to discuss
    all of them, so the remainder of the chapter demonstrates only four, along with
    examples of their implementation in JavaScript. Remember that the patterns are
    more about interfaces and relationships rather than implementation. Once you have
    an understanding of a design pattern, it's often not difficult to implement it,
    especially in a dynamic language such as JavaScript.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在《四书》中，有23种模式，自该书出版以来，已经识别出更多模式。讨论所有这些模式超出了本书的范围，因此本章的剩余部分仅演示四种，以及它们在JavaScript中的实现示例。记住，这些模式更多地关于接口和关系，而不是实现。一旦你理解了一个设计模式，通常实现它并不困难，尤其是在像JavaScript这样的动态语言中。
- en: 'The patterns discussed through the rest of the chapter are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章其余部分讨论的模式如下：
- en: Singleton
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Factory
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂
- en: Decorator
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Observer
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Singleton pattern
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: Singleton is a creational design pattern, meaning that its focus is on creating
    objects. It helps you when you want to make sure there is only one object of a
    given kind or class. In a classical language, this would mean that an instance
    of a class is only created once, and any subsequent attempts to create new objects
    of the same class would return the original instance.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是一种创建型设计模式，这意味着它的重点是创建对象。当你想要确保只有一个给定种类或类的对象时，它很有帮助。在经典语言中，这意味着类的实例只创建一次，任何随后的尝试创建相同类的新的对象都会返回原始实例。
- en: In JavaScript, because there are no classes, a singleton is the default and
    most natural pattern. Every object is a singleton object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，因为没有类，单例是默认且最自然的模式。每个对象都是单例对象。
- en: 'The most basic implementation of the singleton in JavaScript is the object
    literal. Take a look at the following line of code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中最基本的单例实现是对象字面量。看看以下代码行：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That was easy, right?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，对吧？
- en: Singleton 2 pattern
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例2模式
- en: 'If you want to use a class-like syntax and still implement the singleton pattern,
    things become a bit more interesting. Let''s say, you have a constructor called
    `Logger()`, and you want to be able to do something like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用类似类的语法并仍然实现单例模式，事情会变得有点更有趣。假设你有一个名为`Logger()`的构造函数，你想要能够做以下类似的事情：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The idea is that, although you use `new`, only one instance needs to be created,
    and this instance is then returned in consecutive calls.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，尽管你使用了`new`，但只需要创建一个实例，然后在连续调用中返回这个实例。
- en: Global variable
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'One approach is to use a global variable to store the single instance. Your
    constructor could look like the following code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是用全局变量来存储单个实例。你的构造函数可能看起来像以下代码片段：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Using this constructor gives the expected result, which is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个构造函数会得到预期的结果，如下所示：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The drawback is, obviously, the use of a global variable. It can be overwritten
    at any time, even accidentally, and you can lose the instance. The opposite, your
    global variable overwriting someone else's is also possible.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，缺点是使用全局变量。它可以在任何时候被覆盖，甚至可能是意外地，你可能会丢失实例。相反，你的全局变量覆盖了别人的也是可能的。
- en: Property of the constructor
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数的属性
- en: 'As you know, functions are objects and they have properties. You can assign
    the single instance to a property of the constructor function, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，函数是对象，并且它们有属性。你可以将单例分配给构造函数的属性，如下所示：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you write `var a = new Logger()`, `a` points to the newly created `Logger.single_instance`
    property. A subsequent `var b = new Logger()` call results in `b` pointing to
    the same `Logger.single_instance` property, which is exactly what you want.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你写下`var a = new Logger()`，`a`指向新创建的`Logger.single_instance`属性。随后的`var b =
    new Logger()`调用会导致`b`指向同一个`Logger.single_instance`属性，这正是你想要的。
- en: This approach certainly solves the global namespace issue because no global
    variables are created. The only drawback is that the property of the `Logger`
    constructor is publicly visible, so it can be overwritten at any time. In such
    cases, the single instance can be lost or modified. Of course, you can only provide
    so much protection against fellow programmers shooting themselves in the foot.
    After all, if someone can mess with the single-instance property, they can mess
    up the `Logger` constructor directly as well.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实解决了全局命名空间问题，因为没有创建全局变量。唯一的缺点是`Logger`构造函数的属性是公开可见的，因此可以被随时覆盖。在这种情况下，单例可能会丢失或被修改。当然，你可以提供一定程度的保护来防止其他程序员自己给自己挖坑。毕竟，如果有人可以篡改单例属性，他们也可以直接篡改`Logger`构造函数。
- en: In a private property
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在私有属性中
- en: The solution to the problem of overwriting the publicly visible property is
    not to use a public property, but a private one. You already know how to protect
    variables with a closure, so as an exercise, you can implement this approach to
    the singleton pattern.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 解决公开可见属性被覆盖问题的方法不是使用公开属性，而是使用私有属性。你已经知道如何使用闭包来保护变量，所以作为一个练习，你可以将这种方法应用到单例模式中。
- en: Factory pattern
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The factory is another creational design pattern, as it deals with creating
    objects. The factory can help you when you have similar types of objects and you
    don't know in advance which one you want to use. Based on user input or other
    criteria, your code determines the type of object it needs on the fly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是另一种创建型设计模式，因为它涉及到对象的创建。当你有相似类型的对象，但事先不知道要使用哪一个时，工厂模式可以帮助你。根据用户输入或其他标准，你的代码可以动态确定所需的类型对象。
- en: 'Let''s say you have three different constructors that implement similar functionality.
    All the objects they create take a URL but do different things with it. One creates
    a text DOM node; the second creates a link; and the third, an image, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有三个不同的构造函数实现了类似的功能。它们创建的对象都接受一个URL，但对其的处理方式不同。一个创建文本DOM节点；第二个创建链接；第三个创建图像，如下所示：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Using the three different constructors is exactly the same-pass the `url` variable
    and call the `insert()` method, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个不同的构造函数完全相同——传递`url`变量并调用`insert()`方法，如下所示：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Imagine your program doesn''t know in advance which type of object is required.
    The user decides, during runtime, by clicking on a button for example. If `type`
    contains the required type of object, you''ll need to use an `if` or a `switch`
    statement, and write something like the following piece of code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的程序事先并不知道需要哪种类型的对象。用户在运行时通过点击按钮等方式来决定。如果`type`包含所需的类型对象，你需要使用`if`或`switch`语句，并编写如下代码片段：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This works fine; however, if you have a lot of constructors, the code becomes
    too lengthy and hard to maintain. Also, if you are creating a library or a framework
    that allows extensions or plugins, you don't even know the exact names of all
    the constructor functions in advance. In such cases, it's convenient to have a
    factory function that takes care of creating an object of the dynamically determined
    type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是可行的；然而，如果你有很多构造函数，代码会变得过长且难以维护。此外，如果你正在创建一个允许扩展或插件的库或框架，你甚至事先不知道所有构造函数的确切名称。在这种情况下，有一个负责创建动态确定类型对象的工厂函数是非常方便的。
- en: 'Let''s add a factory method to the `MYAPP.dom` utility:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`MYAPP.dom`实用工具中添加一个工厂方法：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, you can replace the three `if` functions with the simpler code, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将三个`if`函数替换为更简单的代码，如下所示：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The example `factory()` method in the previous code was simple; however, in
    a real-life scenario, you'd want to do some validation against the type value
    (for example, check if `MYAPP.dom[type]` exists) and optionally do some set up
    work common to all object types (for example, set up the URL all constructors
    use).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中的`factory()`方法很简单；然而，在实际场景中，你可能想要对类型值进行一些验证（例如，检查`MYAPP.dom[type]`是否存在）并可选地进行一些对所有对象类型都通用的设置工作（例如，设置所有构造函数使用的URL）。
- en: Decorator pattern
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: 'The decorator design pattern is a structural pattern; it doesn''t have much
    to do with how objects are created, but rather how their functionality is extended.
    Instead of using inheritance, where you extend in a linear way (parent-child-grandchild),
    you can have one base object and a pool of different decorator objects that provide
    extra functionality. Your program can pick and choose which decorators it wants,
    and in which order. For a different program or code path, you may have a different
    set of requirements and pick different decorators out of the same pool. Take a
    look at the following code snippet to see how the usage part of the decorator
    pattern can be implemented:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式是一种结构型模式；它与对象的创建方式关系不大，而是与如何扩展其功能有关。你不需要使用继承，在线性方式（父-子-孙）中扩展，你可以有一个基本对象和一个提供额外功能的装饰器对象池。你的程序可以选择它想要的装饰器，以及它们的顺序。对于不同的程序或代码路径，你可能有不同的要求，并从同一个池中挑选不同的装饰器。看看下面的代码片段，了解装饰器模式的用法部分是如何实现的：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can see how you can start with a simple object that has a `doSomething()`
    method. Then, you can pick one of the decorator objects you have lying around
    and which can be identified by name. All decorators provide a `doSomething()`
    method that first calls the same method of the previous decorator and then proceeds
    with its own code. Every time you add a decorator, you overwrite the base `obj`
    with an improved version of it. In the end, when you are finished adding decorators,
    you call `doSomething()`. As a result, all of the `doSomething()` methods of all
    the decorators are executed in sequence. Let's see an example.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到你可以从一个简单的具有`doSomething()`方法的对象开始。然后，你可以选择你拥有的一个装饰器对象，它可以被名称识别。所有装饰器都提供了一个`doSomething()`方法，该方法首先调用前一个装饰器的相同方法，然后继续执行自己的代码。每次添加装饰器时，你都会用改进后的版本覆盖基础`obj`。最后，当你完成添加装饰器后，你调用`doSomething()`。结果，所有装饰器的`doSomething()`方法都按顺序执行。让我们看看一个例子。
- en: Decorating a christmas tree
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰圣诞树
- en: 'Let''s illustrate the decorator pattern with an example of decorating a Christmas
    tree. You can start with the `decorate()` method as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个装饰圣诞树的例子来说明装饰器模式。你可以从`decorate()`方法开始，如下所示：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let''s implement a `getDecorator()` method that adds extra decorators.
    The decorators will be implemented as constructor functions, and they''ll all
    inherit from the base `tree` object as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个`getDecorator()`方法，该方法添加额外的装饰器。装饰器将被实现为构造函数，并且它们都将从基本`tree`对象继承，如下所示：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s create the first decorator, `RedBalls()`, as a property of `tree`,
    in order to keep the global namespace cleaner. The red ball objects also provide
    a `decorate()` method, but they make sure they call their parent''s `decorate()`
    first. For example, take a look at the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建第一个装饰器`RedBalls()`，作为`tree`的一个属性，以保持全局命名空间更干净。红色球对象也提供了一个`decorate()`方法，但它们确保首先调用父对象的`decorate()`方法。例如，看看下面的代码：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Similarly, implement `BlueBalls()` and `Angel()` decorators as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，按照以下方式实现`BlueBalls()`和`Angel()`装饰器：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, let''s add all of the decorators to the base object, as shown in the following
    code snippet:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将所有装饰器添加到基本对象中，如下面的代码片段所示：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, run the `decorate()` method as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下方式运行`decorate()`方法：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This single call results in the following alerts, specifically in this order:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这单个调用会导致以下警报，具体顺序如下：
- en: Make sure the tree won't fall.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保树不会倒下。
- en: Add the blue balls.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加蓝色球。
- en: Add an angel at the top.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部添加一个天使。
- en: Add some red balls.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些红色球。
- en: As you see, this functionality allows you to have as many decorators as you
    like, and to choose and combine them in any way you like.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种功能允许你拥有你想要的任何数量的装饰器，并以任何你喜欢的方式选择和组合它们。
- en: Observer pattern
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'The observer pattern, also known as the **subscriber-publisher** pattern, is
    a behavioral pattern, which means that it deals with how different objects interact
    and communicate with each other. When implementing the observer pattern, you have
    the following objects:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式，也称为**订阅者-发布者**模式，是一种行为型模式，这意味着它处理不同对象如何相互交互和通信。在实现观察者模式时，你有以下对象：
- en: One or more publisher objects that announce when they do something important.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个发布者对象，在它们做重要的事情时宣布。
- en: One or more subscribers tuned in to one or more publishers. They listen to what
    the publishers announce and then act appropriately.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个订阅者调入了一个或多个发布者。他们倾听发布者宣布的内容，然后采取适当的行动。
- en: The observer pattern may look familiar to you. It sounds similar to the browser
    events discussed in the previous chapter, and rightly so, because the browser
    events are one example application of this pattern. The browser is the publisher;
    it announces the fact that an event, such as a `click`, has happened. Your event
    listener functions that are subscribed to listen to this type of event will be
    notified when it happens. The browser-publisher sends an event object to all of
    the subscribers. In your custom implementations, you can send any type of data
    you find appropriate.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式可能对您来说很熟悉。它听起来与上一章中讨论的浏览器事件很相似，这是有道理的，因为浏览器事件是这个模式的一个示例应用。浏览器是发布者；它宣布一个事件，如
    `click` 已经发生的事实。当此类事件发生时，您订阅的用于监听此类事件的监听器函数将会收到通知。浏览器发布者向所有订阅者发送事件对象。在您的自定义实现中，您可以发送您认为合适的任何类型的数据。
- en: 'There are two subtypes of the observer pattern: push and pull. Push is where
    the publishers are responsible to notify each subscriber, and pull is where the
    subscribers monitor for changes in a publisher''s state.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式有两种子类型：推送和拉取。推送是发布者负责通知每个订阅者的情况，而拉取是订阅者监控发布者状态变化的情况。
- en: 'Let''s take a look at an example implementation of the push model. Let''s keep
    the observer-related code in a separate object and then use this object as a mix-in,
    adding its functionality to any other object that decides to be a publisher. In
    this way, any object can become a publisher and any function can become a subscriber.
    The observer object will have the following properties and methods:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看推送模型的一个示例实现。让我们将观察者相关的代码放在一个单独的对象中，然后使用这个对象作为混合对象，将其功能添加到任何决定成为发布者的其他对象中。这样，任何对象都可以成为发布者，任何函数都可以成为订阅者。观察者对象将具有以下属性和方法：
- en: An array of `subscribers` that are just callback functions
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个仅包含回调函数的 `subscribers` 数组
- en: The `addSubscriber()`and `removeSubscriber()` methods that add to, and remove
    from, the `subscribers` collection
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSubscriber()` 和 `removeSubscriber()` 方法，分别向 `subscribers` 集合添加和从中删除'
- en: A `publish()` method that takes data and calls all subscribers, passing the
    data to them
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `publish()` 方法，它接受数据并调用所有订阅者，将数据传递给他们
- en: A `make()` method that takes any object and turns it into a publisher by adding
    all of the methods mentioned previously to it
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `make()` 方法，它接受任何对象并将其转换为发布者，通过向其添加之前提到的所有方法来实现
- en: 'Here''s the observer mix-in object that contains all the subscription-related
    methods and can be used to turn any object into a publisher:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含所有订阅相关方法的观察者混合对象，可以用来将任何对象转换为发布者：
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let''s create some publishers. A publisher can be any object and its only
    duty is to call the `publish()` method whenever something important occurs. Here''s
    a `blogger` object that calls `publish()` every time a new blog posting is ready:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一些发布者。发布者可以是任何对象，它的唯一职责是在发生重要事件时调用 `publish()` 方法。以下是一个 `blogger` 对象，每次有新的博客文章准备就绪时都会调用
    `publish()`：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Another object can be the LA Times newspaper that calls `publish()` when a
    new newspaper issue is out. Consider the following lines of code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对象可以是洛杉矶时报报纸，当有新的报纸发行时调用 `publish()`。考虑以下代码行：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can turn these objects into publishers as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些对象转换为发布者，如下所示：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, let''s have the following two simple objects, `jack` and `jill`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑以下两个简单的对象，`jack` 和 `jill`：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `jack` and `jill` objects can subscribe to the `blogger` object by providing
    the callback methods they want to call when something is published, as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`jack` 和 `jill` 对象可以通过提供它们希望在发布时调用的回调方法来订阅 `blogger` 对象，如下所示：'
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'What happens now, when the `blogger` object writes a new post? The result is
    that `jack` and `jill` will get notified:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当 `blogger` 对象撰写新文章时会发生什么？结果是 `jack` 和 `jill` 将会收到通知：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'At any time, `jill` may decide to cancel her subscription. Then, when writing
    another blog post, the unsubscribed object is no longer notified. Consider the
    following code snippet:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，`jill` 都可以决定取消她的订阅。然后，在撰写另一篇博客文章时，未订阅的对象将不再收到通知。考虑以下代码片段：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `jill` object may decide to subscribe to LA Times, as an object can be
    a subscriber to many publishers, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`jill` 对象可能会决定订阅洛杉矶时报，因为一个对象可以是多个发布者的订阅者，如下所示：'
- en: '[PRE69]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, when LA Times publishes a new issue, `jill` gets notified and `jill.gossip()`
    is executed, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当洛杉矶时报发布新的一期时，`jill` 会收到通知，并执行 `jill.gossip()`，如下所示：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about common JavaScript coding patterns and learned
    how to make your programs cleaner, faster, and better at working with other programs
    and libraries. Then, you saw a discussion and sample implementations of a handful
    of the design patterns from the *Book of Four*. You can see how JavaScript is
    a fully featured dynamic programming language, and that implementing classical
    patterns in a dynamic loosely typed language is pretty easy. The patterns are,
    in general, a large topic, and you can join the author of this book in a further
    discussion of the JavaScript patterns at [JSPatterns.com](http://www.jspatterns.com/),
    or take a look at the *JavaScript Patterns* book. The next chapter focuses on
    testing and debugging methodologies.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了常见的 JavaScript 编程模式，并了解了如何让你的程序更加整洁、快速，并且更好地与其他程序和库协同工作。然后，你看到了关于《四书》中一些设计模式的讨论和示例实现。你可以看到
    JavaScript 是一个功能齐全的动态编程语言，在动态弱类型语言中实现经典模式相当容易。这些模式通常是一个大主题，你可以加入本书作者的行列，在 [JSPatterns.com](http://www.jspatterns.com/)
    上进一步讨论 JavaScript 模式，或者查看《JavaScript Patterns》这本书。下一章将重点介绍测试和调试方法。
