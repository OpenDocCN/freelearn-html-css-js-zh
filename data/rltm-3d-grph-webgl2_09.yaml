- en: Putting It All Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: In the previous chapter, we covered framebuffers, renderbuffers, and the steps
    required to interact with a 3D application using picking. In this chapter, we
    will bring together all of the concepts we've learned so far to build a 3D virtual
    car showroom. In the development of this demo application, we will use models,
    lights, cameras, animation, colors, textures, and more. We will also learn how
    to integrate these elements with a simple yet effective graphical user interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了帧缓冲区、渲染缓冲区以及使用拾取与3D应用程序交互所需的步骤。在本章中，我们将结合我们迄今为止所学到的所有概念来构建一个3D虚拟汽车展厅。在开发这个演示应用程序的过程中，我们将使用模型、光源、相机、动画、颜色、纹理等。我们还将学习如何将这些元素与一个简单而有效的图形用户界面集成。
- en: 'In this chapter, you will learn to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Put together all of the architecture we've developed throughout this book
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合本书中我们开发的所有架构
- en: Create a 3D virtual car showroom application using our architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的架构创建一个3D虚拟汽车展厅应用程序
- en: Import car models from Blender into a WebGL scene
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Blender中的汽车模型导入WebGL场景
- en: Set up several light sources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置多个光源
- en: Create robust shaders to handle multiple materials
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建健壮的着色器以处理多种材质
- en: Learn about the OBJ and MTL file formats
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解OBJ和MTL文件格式
- en: Program the camera to fly through the scene
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程相机以飞越场景
- en: Creating a WebGL Application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建WebGL应用程序
- en: At this point, we've covered the basic topics required to create a WebGL application.
    These topics have been implemented in the framework that we've iteratively built
    throughout this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了创建WebGL应用程序所需的基本主题。这些主题在我们这本书中通过迭代构建的框架中得到了实现。
- en: In [Chapter 1](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml), *Getting Started*,
    we introduced WebGL and learned how to use it in our browser. We learned that
    the WebGL context behaves as a state machine. As a result, we can query the different
    state variables using `gl.getParameter`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml)“入门”，我们介绍了WebGL以及如何在浏览器中使用它。我们了解到WebGL上下文的行为像一个状态机。因此，我们可以使用`gl.getParameter`查询不同的状态变量。
- en: Then, we studied how objects in a WebGL scene are defined by vertices. We saw
    how we can use indices to label vertices so that the WebGL rendering pipeline
    can quickly rasterize to render an object. We studied the functions that manipulate
    buffers and the two main functions to render primitives: `drawArrays` (no indices)
    and `drawElements` (with indices). We learned about using JSON to represent geometries
    and how we can download models from a web server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了WebGL场景中的对象是如何由顶点定义的。我们看到了如何使用索引来标记顶点，以便WebGL渲染管线可以快速光栅化以渲染对象。我们研究了操作缓冲区的函数以及渲染原语的两个主要函数：`drawArrays`（无索引）和`drawElements`（有索引）。我们还学习了如何使用JSON表示几何形状，以及如何从网络服务器下载模型。
- en: Next, we studied how to illuminate our 3D scene. We learned about normal vectors,
    the physics of light reflection, and the 3D math required to implement illumination.
    We also learned how to implement different lighting models using shaders in ESSL.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了如何照亮我们的3D场景。我们学习了法线向量、光的反射物理以及实现光照所需的3D数学。我们还学习了如何使用ESSL中的着色器实现不同的光照模型。
- en: Then*, *we implemented our own custom cameras since WebGL does not have cameras.
    We studied the Camera matrix and demonstrated how it's actually the inverse of
    the Model-View matrix. In other words, rotation, translation, and scaling in world
    space produces the inverse operations in camera space.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于WebGL没有相机，我们实现了自己的自定义相机。我们研究了相机矩阵，并展示了它实际上是模型-视图矩阵的逆。换句话说，世界空间中的旋转、平移和缩放在相机空间中产生逆操作。
- en: Following cameras and matrices, we covered the basics of animation. We discussed
    useful techniques for animations, such as the matrix stack with `push` and `pop`
    operations to represent local and global transformations, and we analyzed how
    to establish an animation cycle that is independent of the rendering cycle. Our
    animations covered different types of interpolation techniques, with examples
    showcasing various animation styles.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了相机和矩阵之后，我们介绍了动画的基础知识。我们讨论了动画的有用技术，例如使用`push`和`pop`操作表示局部和全局变换的矩阵栈，并分析了如何建立一个独立于渲染周期的动画周期。我们的动画涵盖了不同类型的插值技术，并通过展示各种动画风格的示例。
- en: Then, we investigated color representation with WebGL and how we can use colors
    in objects, lights, and the overall scene. In doing so, we also studied blending
    and the creation of translucent and transparent effects. After colors and blending,
    we covered textures for adding more detail to our scene. Then, we saw how users
    can interact with our 3D application with picking.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了使用WebGL进行颜色表示以及如何在对象、灯光和整个场景中使用颜色。在这个过程中，我们还研究了混合以及创建半透明和透明效果。在颜色和混合之后，我们讨论了纹理，以为我们的场景添加更多细节。然后，我们看到了用户如何通过拾取与我们的3D应用程序交互。
- en: In this chapter, we will leverage all of these concepts to create an impressive
    3D application. Reasonably enough, we will use all of the components we have developed
    so far. Let's quickly review them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用所有这些概念来创建一个令人印象深刻的3D应用程序。合乎逻辑的是，我们将使用我们迄今为止开发的所有组件。让我们快速回顾一下。
- en: Architectural Review
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建筑评论
- en: 'The following components are present in the architecture that has been built
    throughout this book:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下组件存在于本书中构建的架构中：
- en: '`Axis.js`: Auxiliary object that represents the center of the scene with visual
    helpers.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Axis.js`: 代表场景中心的辅助对象，带有视觉辅助工具。'
- en: '`Camera.js`: Contains a camera representation from the two types of camera
    we have developed: orbiting and tracking.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Camera.js`: 包含两种我们开发的相机表示：环绕和跟踪。'
- en: '`Clock.js`: A requestAnimationFrame-based timer to synchronize our entire application
    from a single source of truth.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clock.js`: 基于requestAnimationFrame的计时器，用于从单一真相源同步我们的整个应用程序。'
- en: '`Controls.js`: Listens for mouse and keyboard events on the HTML5 `canvas`.
    It interprets these events and then transforms them into camera actions.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Controls.js`: 监听HTML5 `canvas`上的鼠标和键盘事件。它解释这些事件并将它们转换为相机动作。'
- en: '`EventEmitter.js`: A simple class that provides a pub-sub approach for managing
    interactions between components in our application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventEmitter.js`: 一个简单的类，提供了一种pub-sub方法来管理我们应用程序中组件之间的交互。'
- en: '`Floor.js`: Auxiliary object that appears like a rectangular mesh and provides
    the floor reference for the scene.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Floor.js`: 类似于矩形网格的辅助对象，为场景提供地板参考。'
- en: '`Light.js`: Simplifies the creation and managing of lights in the scene.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Light.js`: 简化了场景中灯光的创建和管理。'
- en: '`Picker.js`: Provides color-based object picking.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Picker.js`: 提供基于颜色的对象拾取。'
- en: '`Program.js`: Composes the functions that handle programs, shaders, and the
    mapping between JavaScript values and ESSL uniforms.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program.js`: 组合处理程序、着色器和JavaScript值与ESSL统一变量之间映射的函数。'
- en: '`Scene.js`: Contains a list of objects to be rendered by WebGL.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scene.js`: 包含WebGL将要渲染的对象列表。'
- en: '`Texture.js`: A class for the creation and managing of WebGL textures.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Texture.js`: 用于创建和管理WebGL纹理的类。'
- en: '`Transforms.js`: Contains the matrices discussed in this book, that is, the
    Model-View matrix, the Camera matrix, the uProjectionMatrix, and the Normal matrix.
    It implements the matrix stack with the `push` and `pop` operations.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transforms.js`: 包含本书中讨论的矩阵，即模型-视图矩阵、相机矩阵、u投影矩阵和法线矩阵。它通过`push`和`pop`操作实现了矩阵堆栈。'
- en: '`utils.js`: Contains auxiliary functions, such as `getGLContext`, which helps
    create a WebGL context for a given HTML5 `canvas`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`utils.js`: 包含辅助函数，例如`getGLContext`，它有助于为给定的HTML5 `canvas`创建WebGL上下文。'
- en: 'Application hook functions, which are as follows:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用钩子函数，如下所示：
- en: '`init`: This function initializes the application and is only called when the
    document has loaded via `window.onload = init;`.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`: 此函数初始化应用程序，并且仅在文档通过`window.onload = init;`加载时调用。'
- en: '`configure`: This function creates and configures dependencies, such as the
    program, cameras, lights, and so on.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure`: 此函数创建和配置依赖项，例如程序、相机、灯光等。'
- en: '`load`: This function requests objects from the web server by calling `scene.load`.
    We can also add locally generated geometry (such as the `Floor`) by calling `scene.add`.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`: 此函数通过调用`scene.load`从网络服务器请求对象。我们还可以通过调用`scene.add`添加本地生成的几何形状（例如`Floor`）。'
- en: '`draw`: This function is called when the rendering timer goes off. Here, we
    retrieve objects from the `scene` and render them appropriately by ensuring their
    location (for example, applying local transforms using the matrix stack) and their
    properties (for example, passing the respective uniforms to the `program`).'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw`: 当渲染计时器响起时调用此函数。在这里，我们从`scene`检索对象，并通过确保它们的位置（例如，使用矩阵堆栈应用局部变换）和它们的属性（例如，将相应的统一变量传递给`program`）来适当地渲染它们。'
- en: Now, let's bring all of these concepts together and create a 3D virtual car
    showroom.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些概念结合起来，创建一个3D虚拟汽车展厅。
- en: 'Time for Action: 3D Virtual Car Showroom'
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：3D虚拟汽车展厅
- en: 'Leveraging the WebGL skills and infrastructure code we have developed thus
    far, we will create an application that visualizes different 3D car models. The
    final result will look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们迄今为止开发的WebGL技能和基础设施代码，我们将创建一个可视化不同3D汽车模型的程序。最终结果将看起来像这样：
- en: '![](img/6108a8ab-27d9-45e3-b67c-6825b27431f7.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6108a8ab-27d9-45e3-b67c-6825b27431f7.png)'
- en: First, we'll start by defining the **graphical user interface (GUI**) of our
    application. Then, we'll add WebGL support by creating a `canvas` element and
    obtaining a WebGL context. After obtaining a valid WebGL context, we will define
    and implement the vertex and fragment shader using ESSL. Then, we will implement
    the three functions that hook into the life cycle of our application: `configure`, `load`,
    and `draw`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义我们应用程序的**图形用户界面（GUI**）。然后，我们将通过创建一个`canvas`元素并获取一个WebGL上下文来添加WebGL支持。在获取有效的WebGL上下文后，我们将使用ESSL定义和实现顶点和片段着色器。然后，我们将实现三个钩子到我们应用程序生命周期的函数：`configure`、`load`和`draw`。
- en: Before we get started, let's consider some of the fundamentals of our virtual
    showroom application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们考虑一下我们虚拟展厅应用的一些基本原理。
- en: Complexity of the Models
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型的复杂性
- en: Real-world applications are, generally, much more complex than PoC (proof of
    concept) demos. This is especially true with 3D applications, since 3D assets,
    such as models, are much more complex than simple spheres, cones, and other primitive
    geometric figures. Models in large 3D applications tend to have lots of vertices
    with complicated configurations that provide the level of detail and realism users
    expect. Apart from the pure geometrical representation of these models, they often
    come with several textures. As expected, creating geometries and textures *manually* with
    JSON files is nothing short of daunting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用通常比概念验证（Proof of Concept，PoC）演示要复杂得多。这一点在3D应用中尤其如此，因为3D资产，如模型，比简单的球体、圆锥体和其他原始几何图形要复杂得多。大型3D应用中的模型往往具有大量顶点和复杂的配置，以提供用户期望的细节和真实感。除了这些模型的纯几何表示外，它们通常还包含几个纹理。正如预期的那样，使用JSON文件手动创建几何形状和纹理是相当令人畏惧的。
- en: Fortunately, we can use various industry proved 3D design software to create
    and import models into a WebGL scene. For our 3D virtual car showroom, we will
    use models that have been created with **Blender**, a widely used, open source
    3D tool.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用各种经过行业验证的3D设计软件来创建和将模型导入WebGL场景。对于我们的3D虚拟汽车展厅，我们将使用用**Blender**创建的模型，这是一个广泛使用的开源3D工具。
- en: Blender
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Blender
- en: Blender is an open source 3D computer graphics software that allows you to create
    animations, games, and other interactive applications. Blender provides numerous
    features so that you can create complex models. You can check out the official
    Blender website for more information: [https://www.blender.org](https://www.blender.org/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Blender是一个开源的3D计算机图形软件，允许你创建动画、游戏和其他交互式应用程序。Blender提供了众多功能，以便你可以创建复杂模型。你可以查看Blender的官方网站获取更多信息：[https://www.blender.org](https://www.blender.org/)。
- en: We will use Blender to import car models into our WebGL scene. First, we will
    export the models to an intermediary file format called **OBJ** and then parse
    them into consumable JSON files. We will cover more on these concepts later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Blender将汽车模型导入我们的WebGL场景。首先，我们将模型导出为一种称为**OBJ**的中间文件格式，然后解析成可消费的JSON文件。我们将在稍后详细介绍这些概念。
- en: Shader Quality
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器质量
- en: Since we will be using complex models, such as cars, we'll need to develop shaders
    that can render the different materials of our models. This should be relatively
    simple, since the shaders we've developed already handle diffuse, specular, and
    ambient components for materials. In Blender, we will select the option to export
    materials when generating the OBJ files. Blender will then generate a second file
    known as the **Material Template Library** (**MTL**). For the best results, our
    shaders will use Phong shading and Phong lighting, with support for multiple lights.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用复杂的模型，如汽车，我们需要开发能够渲染我们模型不同材质的着色器。这应该相对简单，因为我们开发的着色器已经处理了材质的漫反射、镜面反射和环境反射组件。在Blender中，我们将选择在生成OBJ文件时导出材质的选项。然后，Blender将生成一个名为**材质模板库（Material
    Template Library，MTL**）的第二个文件。为了获得最佳效果，我们的着色器将使用Phong着色和Phong光照，并支持多个光源。
- en: Network Delays and Bandwidth Consumption
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络延迟和带宽消耗
- en: When it comes to WebGL applications with large 3D assets, we generally download
    geometries and textures from a web server. As expected, this can take some time
    depending on the quality of the network connection and the amount of data that
    needs to be transferred. There are, however, several strategies for optimizing
    this process, such as compression and 3D asset optimizations, which will be covered
    in a later chapter. We will use AJAX to provide users with a great user experience
    by downloading these large assets in the background.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到具有大量3D资源的WebGL应用时，我们通常从网络服务器下载几何形状和纹理。正如预期的那样，这可能会花费一些时间，具体取决于网络连接的质量和需要传输的数据量。然而，有几种策略可以优化这个过程，例如压缩和3D资源优化，这些将在后面的章节中介绍。我们将使用AJAX在后台下载这些大型资源，为用户提供良好的用户体验。
- en: With these considerations in mind, let's get started.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，让我们开始吧。
- en: Designing Our GUI
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的GUI
- en: 'We will define a very simple layout for our application. First, we will define
    our HTML document and include all of the necessary dependencies:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的应用定义一个非常简单的布局。首先，我们将定义我们的HTML文档并包含所有必要的依赖项：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, we''ve included the following libraries that are required for
    our application:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经包含了以下对于我们的应用所必需的库：
- en: '`normalize.css`: A set of styles that makes browsers render all elements more
    consistently'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`normalize.css`：一组使浏览器更一致地渲染所有元素的样式'
- en: '`dat.gui.js`: A lightweight graphical user interface for changing variables
    in JavaScript'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dat.gui.js`：一个用于在JavaScript中更改变量的轻量级图形用户界面'
- en: '`gl-matrix.js`: A JavaScript matrix and vector library for high performance
    applications'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl-matrix.js`：一个用于高性能应用的JavaScript矩阵和向量库'
- en: Now that we've included the required libraries, we will include the various
    components we've covered throughout this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经包含了所需的库，我们将包含本书中涵盖的各种组件。
- en: Adding canvas Support
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加canvas支持
- en: 'Now that we have the shell for our application, let''s add the `canvas` that''s
    required for our WebGL application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们应用的框架，让我们添加我们WebGL应用所需的`canvas`：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `canvas` element with the `webgl-canvas` ID goes between the `body` of our
    HTML document.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`webgl-canvas` ID的`canvas`元素位于我们的HTML文档的`body`之间。
- en: Adding Shader Scripts
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加着色器脚本
- en: 'Next, let''s include the two shaders that we''ll need for our application by
    using the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过以下代码将我们应用所需的两个着色器包含进来：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These `scripts` are placed inside the `head` of our document.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`scripts`被放置在我们的文档的`head`中。
- en: Adding WebGL Support
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加WebGL支持
- en: 'Now that we have the basic boilerplate for our application, let''s initialize
    our WebGL application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们应用的基本模板，让我们初始化我们的WebGL应用：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This `script` tag goes after the shader scripts to ensure that we can reference
    them as needed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`script`标签放在着色器脚本之后，以确保我们可以在需要时引用它们。
- en: 'Let''s cover this code in detail:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细介绍一下这段代码：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to define the various global variables that we''ll be setting and using
    throughout the application. As in all of our previous exercises, we need to define
    the entry point for the application. We do this with the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义将在整个应用中设置和使用的一些全局变量。就像我们之前的所有练习一样，我们需要定义应用的入口点。我们通过以下代码来完成这项工作：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `init` function is called once our document has loaded via `window.onload`.
    In the `init` function, we set up our application by calling `configure` and using
    the `clock` instance to call `draw` on every `tick`—that is, every `requestAnimationFrame`
    call:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`函数在文档通过`window.onload`加载后调用。在`init`函数中，我们通过调用`configure`和使用`clock`实例在每次`tick`（即每次`requestAnimationFrame`调用）上调用`draw`来设置我们的应用。这意味着每次`requestAnimationFrame`调用都会绘制一次。'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We initialize and set our `canvas` with the ID of `webgl-canvas`. Then, we
    pass the `canvas` instance to our utility function for full screen and auto resizing
    capabilities. This function is useful because it automatically updates the size
    of the `canvas` to the available window space without hardcoding the size of the
    `canvas`. Then, we initialize `gl`, `scene`, `clock`, and `program` using the
    provided shaders. Finally, we set the `gl` context with the basic configurations,
    such as a clear color, depth testing, and blending functions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化并设置具有ID `webgl-canvas` 的 `canvas`。然后，我们将`canvas`实例传递给我们的实用函数，以实现全屏和自动调整大小功能。这个函数很有用，因为它会自动更新`canvas`的大小以适应可用的窗口空间，而不需要硬编码`canvas`的大小。然后，我们使用提供的着色器初始化并设置`gl`、`scene`、`clock`和`program`。最后，我们使用基本配置设置`gl`上下文，例如清除颜色、深度测试和混合函数：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `draw` function is simple, as it simply sets the viewport and clears the
    `canvas`. You can find this source code inside the `ch09_scaffolding.html` file
    for this book.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`函数很简单，因为它只是设置视口并清除`canvas`。你可以在本书的`ch09_scaffolding.html`文件中找到此源代码。'
- en: 'Now, if you run `ch09_scaffolding.html` in your browser, you will see that
    the `canvas` resizes according to the size of the browser, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在你的浏览器中运行`ch09_scaffolding.html`，你会看到`canvas`根据浏览器的大小进行缩放，如下所示：
- en: '![](img/051f60b1-b25d-42d8-b850-5006343b2158.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/051f60b1-b25d-42d8-b850-5006343b2158.png)'
- en: Implementing the Shaders
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现着色器
- en: With our shaders, we will implement **Phong shading** and the **Phong reflection** model.
    Remember that Phong shading interpolates vertex normals and creates a normal for
    every fragment–the processing happens in the fragment shader. The Phong reflection
    model describes illumination as the addition of ambient, diffuse, and specular
    interaction of the object with the light sources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的着色器，我们将实现**冯·卡门着色**和**冯·卡门反射**模型。记住，冯·卡门着色插值顶点法线并为每个片段创建一个法线——处理发生在片段着色器中。冯·卡门反射模型描述了光照为对象与光源的漫反射、反射和镜面反射的加和。
- en: 'To be consistent with the Material Template Library (MTL) format, we’ll follow
    some typical conventions to set out uniform names that refer to material properties:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与材质模板库（MTL）格式保持一致，我们将遵循一些典型约定来设置指向材质属性的统一名称：
- en: '| **Material** **Uniform** | **Description** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **材质** **统一** | **描述** |'
- en: '| `uKa` | Ambient property. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `uKa` | 环境属性。|'
- en: '| `uKd` | Diffuse property. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `uKd` | 漫反射属性。|'
- en: '| `uKs` | Specular property. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `uKs` | 镜面属性。|'
- en: '| `uNi` | Optical density. We will not use this feature, but you will see it
    in the MTL file. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `uNi` | 光学密度。我们不会使用此功能，但你将在MTL文件中看到它。|'
- en: '| `uNs` | Specular exponent. A high exponent results in a tight, concentrated
    highlight. `Ns` values normally range from `0` to `1000`. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `uNs` | 镜面指数。高指数会导致紧密、集中的高光。`Ns`值通常在`0`到`1000`之间。|'
- en: '| `uD` | Transparency (alpha channel). |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `uD` | 透明度（alpha通道）。|'
- en: '| `uIllum` | Determines the illumination model for the object being rendered.
    Unlike previous chapters where we had one model for all objects, we let objects
    describe their reflective properties.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '| `uIllum` | 确定渲染对象的照明模型。与之前章节中所有对象使用一个模型不同，我们让对象描述它们的反射属性。'
- en: 'According to the MTL file format specification, **illum** can be any of the
    following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根据MTL文件格式规范，**illum**可以是以下任何一种：
- en: Color on and Ambient off.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色开启和环境关闭。
- en: Color on and Ambient on.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色开启和环境开启。
- en: Highlight on.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高亮开启。
- en: Reflection on and Ray trace on.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射开启和光线追踪开启。
- en: 'Transparency: Glass on, Reflection: Ray trace on.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明度：玻璃开启，反射：光线追踪开启。
- en: 'Reflection: Fresnel on and Ray trace on.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射：菲涅耳开启和光线追踪开启。
- en: 'Transparency: Refraction on, Reflection: Fresnel off and Ray trace on.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明度：折射开启，反射：菲涅耳关闭和光线追踪开启。
- en: 'Transparency: Refraction on, Reflection: Fresnel on and Ray trace on.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明度：折射开启，反射：菲涅耳开启和光线追踪开启。
- en: Reflection on and Ray trace off.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射开启和光线追踪关闭。
- en: 'Transparency: Glass on, Reflection: Ray trace off.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明度：玻璃开启，反射：光线追踪关闭。
- en: Casts shadows onto invisible surfaces.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不可见表面上投射阴影。
- en: '|'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '**The Wavefro**nt .obj** file**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wavefront .obj**文件**'
- en: For more information on OBJ and MTL file specifications, please refer to the
    following link: [https://en.wikipedia.org/wiki/Wavefront_.obj_file](https://en.wikipedia.org/wiki/Wavefront_.obj_file).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于OBJ和MTL文件规范的更多信息，请参阅以下链接：[https://en.wikipedia.org/wiki/Wavefront_.obj_file](https://en.wikipedia.org/wiki/Wavefront_.obj_file)。
- en: 'Our shaders will also support multiple lights by using uniform arrays, as described
    in earlier chapters. The number of lights is defined by a constant in both the
    vertex and fragment shaders:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的着色器将通过使用前面章节中描述的统一数组来支持多个光源。光源的数量由顶点和片段着色器中的常量定义：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will use the following uniform arrays to work with lights:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下统一数组来处理光源：
- en: '| **Light ****Uniform Array** | **Description** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **灯光** **统一数组** | **描述** |'
- en: '| `uLa[numLights]` | Ambient property. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `uLa[numLights]` | 环境属性。|'
- en: '| `uLd[numLights]` | Diffuse property. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `uLd[numLights]` | 漫反射属性。|'
- en: '| `uLs[numLights]` | Specular property. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `uLs[numLights]` | 镜面属性。|'
- en: '**Source code**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码**'
- en: You can refer to `ch09_02_showroom.html` if you wish to explore the source code
    for the shaders in this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望探索本章着色器的源代码，可以参考`ch09_02_showroom.html`。
- en: 'Here''s the vertex shader:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是顶点着色器：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Along with the corresponding fragment shader:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随相应的片段着色器：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As expected, the vertex and fragment shaders borrow concepts from earlier chapters
    covered in this book, except for `uIllum`. As described earlier, the `illum` property
    determines the illumination model for the object being rendered. We could default
    to a simpler fragment shader (such as `uIllum == 2`), but a simple example has
    been provided for educational purposes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，顶点和片段着色器借鉴了本书中早期章节中的概念，除了`uIllum`。如前所述，`illum`属性决定了正在渲染的对象的照明模型。我们可以默认使用一个更简单的片段着色器（例如`uIllum
    == 2`），但为了教育目的提供了一个简单示例。
- en: Next, we will configure the three main functions that hook into the life cycle
    of our WebGL application. These are the `configure`, `load`, and `render` functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置三个主要函数，这些函数钩入我们的WebGL应用程序的生命周期。这些是`configure`、`load`和`render`函数。
- en: Setting up the Scene
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置场景
- en: 'We can set up the scene by defining some global variables for our application
    and writing the code for the `configure` function. Let''s analyze this line by
    line:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义应用程序的一些全局变量并为`configure`函数编写代码来设置场景。让我们逐行分析：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this stage, we want to set some of the WebGL properties, such as the clear
    color and the depth test. Then, we need to create a camera and set its initial
    position and orientation. We also need to create a camera controls instance so
    that we can update the position of the camera during scene interactions. Finally,
    we need to define the JavaScript variables that will be mapped to the shaders.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们想要设置一些WebGL属性，例如清除颜色和深度测试。然后，我们需要创建一个相机并设置其初始位置和方向。我们还需要创建一个相机控制实例，以便在场景交互期间更新相机的位置。最后，我们需要定义将映射到着色器的JavaScript变量。
- en: To accomplish these tasks, we will use `Camera.js`, `Controls.js`, `Program.js`,
    and `Transforms.js` from our architecture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这些任务，我们将使用我们的架构中的`Camera.js`、`Controls.js`、`Program.js`和`Transforms.js`。
- en: Configuring WebGL Properties
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置WebGL属性
- en: 'We need to initialize and configure our `canvas` and `gl` instances:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要初始化和配置我们的`canvas`和`gl`实例：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we need to initialize `scene`, `clock`, and `program`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要初始化`scene`、`clock`和`program`：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These core components are defined globally so that we can reference them throughout
    our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些核心组件被全局定义，这样我们就可以在整个应用程序中引用它们。
- en: 'Finally, we need to set the background color and the depth test properties,
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要设置背景颜色和深度测试属性，如下所示：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Setting up the Camera
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置相机
- en: 'To keep things simple, the `camera` variable will be global so that we can
    access it from the GUI controls:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，`camera`变量将是全局的，这样我们就可以从GUI控件中访问它：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating the Camera Controls
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建相机控制
- en: 'We need to instantiate a `Controls` instance that will bind mouse gestures
    to `camera` actions. The first argument is the `camera` we are controlling, and
    the second argument is a reference to our `canvas`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实例化一个`Controls`实例，该实例将鼠标手势绑定到`camera`动作。第一个参数是我们控制的`camera`，第二个参数是我们`canvas`的引用：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Scene Transforms
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景变换
- en: 'Once we have a `camera`, we can use it to create a new `Tranforms` instance,
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`camera`，我们就可以使用它来创建一个新的`Tranforms`实例，如下所示：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `transforms` variable is also declared globally, so we can use it in the
    `draw` function to retrieve the current matrix transformations and pass them to
    the shaders.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`transforms`变量也被声明为全局变量，这样我们就可以在`draw`函数中使用它来检索当前的矩阵变换并将它们传递给着色器。'
- en: Creating the Lights
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建光源
- en: 'We will create four lights by using the `Light` class from our framework with
    the following configurations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的框架中的`Light`类创建四个光源，配置如下：
- en: '![](img/b4c541c3-f8d5-47eb-ab5e-bfbf38bb8078.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4c541c3-f8d5-47eb-ab5e-bfbf38bb8078.png)'
- en: 'First, we instantiate a `LightsManager` instance to manage our lights:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化一个`LightsManager`实例来管理我们的光源：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we create four light positions for each light and iterate over each position
    to uniquely position each light:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每个光源创建四个光位置，并对每个位置进行迭代，以唯一地定位每个光源：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since every light has the same diffuse, ambient, and specular properties, we
    only set a dynamic position by using the `lightPositions` data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个光源都具有相同的漫反射、环境光和镜面反射属性，我们只需使用`lightPositions`数据设置动态位置。
- en: Mapping Program Attributes and Uniforms
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射程序属性和统一变量
- en: Next, inside the `configure` function, we map the JavaScript values to the attributes
    and uniforms inside of our shaders.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`configure`函数内部，我们将JavaScript值映射到着色器内的属性和统一变量。
- en: 'Using the program `instance` from earlier, we will set up the values to map
    attributes and uniforms to the shaders. The code looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前提到的`program`实例，我们将设置映射属性和统一变量到着色器的值。代码如下所示：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When creating shaders, make sure that the shader attributes and uniforms are
    properly mapped to JavaScript values. This mapping step allows us to refer to
    attributes and uniforms effortlessly. Check out the `setAttributeLocations` and `setUniformLocations` methods
    inside of `Program.js`, which are called by `program.load`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建着色器时，请确保着色器属性和统一变量正确映射到JavaScript值。这一映射步骤使我们能够轻松地引用属性和统一变量。查看`Program.js`中的`setAttributeLocations`和`setUniformLocations`方法，这些方法由`program.load`调用。
- en: Uniform Initialization
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一初始化
- en: 'After mapping the variables, we can initialize shader uniforms, such as lights:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射变量之后，我们可以初始化着色器统一变量，例如灯光：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The default material properties are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认材质属性如下：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, we will create a `floor` instance that we will use later. We will also
    structure the data that describes the car model that we''ll be loading later:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个`floor`实例，稍后我们将使用它。我们还将构建描述稍后要加载的汽车模型的数据库：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Although we have only described one car model here, we'll leverage this data
    format so that we can add other car models later in this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里只描述了一个汽车模型，但我们将利用这种数据格式，以便我们可以在本章的后面添加其他汽车模型。
- en: 'Here''s the final `configure` function, which you can find in the `ch09_02_showroom.html`
    source code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终的`configure`函数，您可以在`ch09_02_showroom.html`源代码中找到：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have finished setting up the scene. Next, we'll implement the `load` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了场景的设置。接下来，我们将实现`load`函数。
- en: Loading the Cars
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载汽车
- en: Inside of the `load` function, we will download some assets in the background
    that we can load into our application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`load`函数内部，我们将下载一些背景资产，以便我们可以将它们加载到我们的应用程序中。
- en: When the JSON files that describe the cars are available, we just use the `scene`
    instance to load these files. Keep in mind that it's uncommon to have ready-to-use
    JSON files. In such situations, there are specialized design tools, such as Blender,
    which can significantly help create and convert consumable models.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当描述汽车的JSON文件可用时，我们只需使用`scene`实例来加载这些文件。请注意，通常不会有现成的JSON文件。在这种情况下，有专门的设计工具，如Blender，它可以显著帮助创建和转换可消费的模型。
- en: That said, we will use the pre-built models that are available on [blendswap.org.](http://www.blendswap.org/) All
    of these models are publicly available, and are free of charge to use and distribute.
    Before we can use these models, we need to export them to an intermediate file
    format from where we can extract the geometry and material properties to create the
    appropriate JSON files. The file format we are going to use is **Wavefront OBJ**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们将使用在[blendswap.org.](http://www.blendswap.org/)上可用的预构建模型。所有这些模型都是公开可用的，并且免费使用和分发。在我们能够使用这些模型之前，我们需要将它们导出为中间文件格式，从而我们可以从中提取几何形状和材质属性以创建适当的JSON文件。我们将使用的文件格式是**Wavefront
    OBJ**。
- en: Exporting the Blender Models
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出Blender模型
- en: All of the assets for this exercise are provided in this book's source code. However,
    if you want to go through the steps of converting the models, here are the steps. For
    this exercise, we will be using Blender (v2.6).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的所有资产都包含在这本书的源代码中。但是，如果您想通过转换模型的步骤，以下是步骤。对于这个练习，我们将使用Blender（v2.6）。
- en: '**Blender** If you do not have Blender, you can download it for your operating
    system from [https://www.blender.org/download/](https://www.blender.org/download/).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blender** 如果您没有Blender，您可以从[https://www.blender.org/download/](https://www.blender.org/download/)下载适用于您的操作系统版本。'
- en: 'Once you have loaded the car into Blender, you need to export it as an OBJ
    file. To do so, go to **File** | **Export** | **Wavefront (.obj)**, as shown in
    the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将汽车模型导入到Blender中，您需要将其导出为OBJ文件。为此，请转到**文件**|**导出**|**Wavefront (.obj)**，如下面的截图所示：
- en: '![](img/6d1a3104-bd09-4bc9-beb2-917541d6e04e.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d1a3104-bd09-4bc9-beb2-917541d6e04e.png)'
- en: 'In the **Export OBJ** panel, make sure that the following options are active:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在**导出OBJ**面板中，确保以下选项处于激活状态：
- en: '**Apply Modifiers**: This will write the vertices in the scene that are the
    result of a mathematical operation instead of direct modeling. If you do not check
    this option, the model may appear incomplete in the WebGL scene.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用修改器**：这将写入场景中由数学运算产生的顶点，而不是直接建模。如果您不检查此选项，模型可能在WebGL场景中看起来不完整。'
- en: '**Write Materials**: Blender will create the matching Material Template Library
    (MTL) file. We''ll cover more on this in the following section.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入材质**：Blender将创建匹配的材质模板库（MTL）文件。我们将在下一节中详细介绍这一点。'
- en: '**Triangulate Faces**: Blender will write the indices as triangles. This is
    ideal for WebGL rendering.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三角化面**：Blender将写入索引作为三角形。这对于WebGL渲染是理想的。'
- en: '**Entity as OBJ Objects**: This configuration will identify every object in
    the Blender scene as an object in the OBJ file.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体作为OBJ对象**：此配置将识别Blender场景中的每个对象为OBJ文件中的对象。'
- en: '**Material Groups**: If an object in the Blender scene has several materials,
    for example, a car tire that can be made of aluminum and rubber, then the object
    will be subdivided into groups, one per material in the OBJ file.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材质组**：如果Blender场景中的对象有多个材质，例如，一个可以由铝和橡胶制成的汽车轮胎，那么该对象将被细分为组，每个组对应OBJ文件中的一个材质。'
- en: OBJ file. Then, click on Export. Once you have checked these export parameters,
    select the directory and name for your
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ文件。然后，点击导出。一旦检查了这些导出参数，请选择目录和文件名：
- en: Understanding the OBJ Format
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解OBJ格式
- en: 'There are several types of definitions in an OBJ file. Let''s cover them line-by-line
    with a simple example. We are going to dissect a sample `square.obj` file that
    we will export from the Blender file called `square.blend`. This file represents
    a square divided into two parts, one painted red and the other painted blue, as
    shown in the following diagram:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ文件中有几种类型的定义。让我们通过一个简单的示例逐行介绍它们。我们将剖析一个名为`square.obj`的样本文件，我们将从名为`square.blend`的Blender文件中导出它。此文件表示一个分成两部分的正方形，一部分涂成红色，另一部分涂成蓝色，如图所示：
- en: '![](img/36b9625a-a092-47cd-8aca-3a21aba8b6ab.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36b9625a-a092-47cd-8aca-3a21aba8b6ab.png)'
- en: 'When we export Blender models to an OBJ format, the resulting file normally
    starts with a comment:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将Blender模型导出为OBJ格式时，生成的文件通常以注释开始：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These are comments, and they are denoted with a hash `#` symbol at the beginning
    of the line.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是注释，并且它们在行首用哈希`#`符号表示。
- en: 'Next, we will usually find a line referring to the Material Template Library
    that this OBJ file is using. This line will begin with the keyword `mtllib`, followed
    by the name of the material''s file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通常会找到一行引用此OBJ文件使用的材质模板库。此行将以关键字`mtllib`开头，后面跟材质文件的名称：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are several ways that geometries can be grouped into entities in an OBJ
    file. We can find lines starting with the prefix `o`, followed by the object name,
    or by the prefix `g`, followed by the group name:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在OBJ文件中，几何体可以通过几种方式组合成实体。我们可以找到以前缀`o`开头的行，后面跟对象名称，或者以前缀`g`开头的行，后面跟组名称：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After object declaration, the following lines will refer to vertices, `v`,
    optionally to vertex normals, `vn`, and texture coordinates, `vt`. It’s important
    to note that vertices are shared by all groups in an object in the OBJ format.
    That is, you will not find lines referring to vertices when defining a group,
    because it''s assumed that all vertex data was defined when the object was defined:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象声明之后，接下来的行将引用顶点`v`，可选地引用顶点法线`vn`和纹理坐标`vt`。需要注意的是，在OBJ格式中，对象中的所有组共享顶点。也就是说，在定义组时，不会找到引用顶点的行，因为假设在定义对象时已经定义了所有顶点数据：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In our case, we have instructed Blender to export group materials. This means
    that each part of the object that has a different set of material properties will
    appear in the OBJ file as a group. In this example, we are defining an object
    with two groups (`squares_mesh_blue` and `squares_mesh_red`) and two corresponding
    materials (blue and red):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们指示Blender导出组材质。这意味着具有不同材质属性集的对象的每个部分都将作为组出现在OBJ文件中。在这个例子中，我们定义了一个具有两个组（`squares_mesh_blue`和`squares_mesh_red`）和两个相应的材质（蓝色和红色）的对象：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If materials are being used, the line after the group declaration will be the
    material that''s being used for that group. In this case, only the name of the
    material is required. It''s assumed that the material properties for this material
    are defined in the MTL file that was declared at the beginning of the OBJ file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了材质，则在组声明之后的行将是该组使用的材质。在这种情况下，只需要材质的名称。假设该材质的属性定义在OBJ文件开头声明的MTL文件中：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The lines that begin with the prefix `s` refer to smooth shading across polygons.
    Although mentioned here, we will not be using this definition when parsing the
    OBJ files into JSON files:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以前缀`s`开头的行指的是多边形上的平滑着色。虽然在这里提到了，但在解析OBJ文件到JSON文件时，我们不会使用这个定义：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The lines that start with `f` refer to faces. There are different ways to represent
    faces. Let's see them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以`f`开头的行指的是面。有不同方式来表示面。让我们看看它们。
- en: Vertex
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this configuration, every face element corresponds to a vertex index. Depending
    on the number of indices per face, you could have triangular, rectangular, or
    polygonal faces. However, we have instructed Blender to use triangular faces to
    create the OBJ file. Otherwise, we would need to decompose the polygons into triangles
    before we could call `drawElements`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置中，每个面元素对应一个顶点索引。根据每个面的索引数，你可能会有三角形、矩形或多边形面。然而，我们已经指示Blender使用三角形面来创建OBJ文件。否则，我们需要在调用`drawElements`之前将多边形分解成三角形。
- en: Vertex/Texture Coordinate
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点/纹理坐标
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this combination, every vertex index appears to be followed by a forward
    slash and texture coordinate index. You will normally find this combination when
    texture coordinates are defined at the object level with `vt`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种组合中，每个顶点索引似乎都跟着一个正斜杠和纹理坐标索引。通常在用`vt`在对象级别定义纹理坐标时，你会找到这种组合。
- en: Vertex/Texture Coordinate/Normal
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点/纹理坐标/法线
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here is a normal index that has been added as the third element in the configuration.
    If both texture coordinates and vertex normals are defined at the object level,
    you will most likely see this configuration at the group level.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个正常的索引，它已被添加为配置中的第三个元素。如果纹理坐标和顶点法线都在对象级别定义，你很可能会在组级别看到这种配置。
- en: Vertex//Normal
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点//法线
- en: 'There can also be cases where normals are defined but texture coordinates are
    not. In this case, the second part of the face configuration is missing:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在法线已定义但纹理坐标未定义的情况。在这种情况下，面配置的第二部分缺失：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is the case for `square.obj`, which looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`square.obj`来说，它看起来是这样的：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that faces are defined using indices. In our example, we have defined a
    square divided into two parts. Here, we can see that all of the vertices share
    the same normal, which has been identified with index `1`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，面是通过索引定义的。在我们的例子中，我们定义了一个分成两部分的正方形。在这里，我们可以看到所有顶点共享相同的法线，该法线已用索引`1`标识。
- en: 'The remaining lines in this file represent the red group:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中剩余的行代表红色组：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we mentioned previously, groups belonging to the same object share indices.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，属于同一对象的组共享索引。
- en: Parsing the OBJ Files
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析OBJ文件
- en: 'After exporting our cars into OBJ format, the next step is to parse the OBJ
    files to create JSON files that we can load into our scene. We have included the
    parser that we developed for this step in `common/models/obj-parser.py`. This
    parser has the following features:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的汽车导出为OBJ格式后，下一步是将OBJ文件解析成我们可以加载到场景中的JSON文件。我们已经在`common/models/obj-parser.py`中包含了为此步骤开发的解析器。这个解析器有以下特点：
- en: 'It''s written in Python (quite common for OBJ parsers) and can be called in
    the command line with the following format:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是用Python编写的（对于OBJ解析器来说相当常见），可以通过以下格式在命令行中调用：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Where `arg1` is the name of the OBJ file to parse and `arg2` is the name of
    the MTL. The file extension is needed in both cases. For example:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中`arg1`是解析的OBJ文件名，`arg2`是MTL文件名。两种情况下都需要文件扩展名。例如：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It creates one JSON file per OBJ group.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为每个OBJ组创建一个JSON文件。
- en: It searches into the Material Template Library (if defined) for the material
    properties for each group and adds them to the corresponding JSON file.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会在（如果已定义）材质模板库中搜索每个组的材质属性，并将它们添加到相应的JSON文件中。
- en: It will calculate the appropriate indices for each group. Remember that OBJ
    groups share indices. Since we are creating one independent WebGL object per group,
    each object needs to have indices starting with `0`. The parser takes care of
    this for you.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将为每个组计算适当的索引。请记住，OBJ组共享索引。由于我们为每个组创建一个独立的WebGL对象，每个对象都需要从`0`开始的索引。解析器会为你处理这一点。
- en: '**Python**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: If you do not have Python installed in your system, you can get it from [http://www.python.org/](http://www.python.org/) or[ https://anaconda.org/anaconda/python](https://anaconda.org/anaconda/python).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你系统上没有安装Python，你可以从[http://www.python.org/](http://www.python.org/)或[ https://anaconda.org/anaconda/python](https://anaconda.org/anaconda/python)获取。
- en: 'The following diagram summarizes the procedure needed to create JSON files
    from Blender scenes:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了从Blender场景创建JSON文件所需的程序：
- en: '![](img/5fd36821-62f5-4642-9ad0-00e36299aa13.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fd36821-62f5-4642-9ad0-00e36299aa13.png)'
- en: Loading Cars into Our WebGL Scene
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将汽车加载到我们的WebGL场景中
- en: 'Now that we have cars stored as JSON files, they are ready to be used in our
    WebGL scene. First, we have to let the user choose which car to visualize. That
    said, it''s still a good idea to load one by default. To do so, we will write
    the following code inside the `load` function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将汽车存储为JSON文件，它们就可以在我们的WebGL场景中使用。首先，我们必须让用户选择要可视化的汽车。也就是说，默认加载一辆汽车仍然是一个好主意。为此，我们将在`load`函数内部编写以下代码：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We call `goHome`, a helper function, that sets the `camera` position to a particular
    point in our scene. This is defined as a function, since we''ll later use it as
    a way to reset our `camera` location, as needed. Then, we call `loadCar`, which
    is where we supply the `key` of the car (for example, `BMW i8`) we want to load
    from the `carModelData` that we defined inside of `configure`. Let''s see what
    `loadCar` looks like:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用辅助函数`goHome`，将`camera`位置设置为我们场景中的特定点。这是因为我们稍后将其用作重置`camera`位置的方式。然后，我们调用`loadCar`，这是我们提供要加载的汽车的`key`（例如，`BMW
    i8`）的地方，我们从`configure`中定义的`carModelData`中提供。让我们看看`loadCar`的样子：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This function clears all of the objects in our `scene`, adds the already created
    `floor` instance, and extracts the necessary data from the `carModelData` object,
    such as the `path` to the model and the number of parts to load.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数清除我们`scene`中的所有对象，添加已经创建的`floor`实例，并从`carModelData`对象中提取必要的数据，例如模型的`path`和要加载的部分数量。
- en: Rendering
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: Let's take a step back and assess the big picture. We previously mentioned that,
    in our architecture, we have defined three main functions that define the life
    cycle of our WebGL application. These functions are `configure`, `load`, and `draw`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，评估整体情况。我们之前提到，在我们的架构中，我们定义了三个主要函数，这些函数定义了我们的WebGL应用程序的生命周期。这些函数是`configure`、`load`和`draw`。
- en: 'Thus far, we''ve set up the scene by writing the code for the `configure` function.
    After that, we created our JSON cars and loaded them by writing the code for the `load` function.
    Now, we will implement the code for the third function: the `draw` function.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过编写`configure`函数的代码来设置场景。之后，我们创建了我们的JSON汽车并通过编写`load`函数的代码来加载它们。现在，我们将实现第三个函数：`draw`函数。
- en: The code is pretty standard and almost identical to the `draw` functions that
    we've written in previous chapters. As the following code demonstrates, we set
    and clear the area that we are going to draw. Then, we check the camera's perspective
    and process every object in `scene`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当标准，几乎与我们在前几章中编写的`draw`函数完全相同。以下代码演示了，我们设置了将要绘制的区域，并清除该区域。然后，我们检查摄像机的视角并处理`scene`中的每个对象。
- en: One important consideration is that we need to ensure that we are correctly
    mapping the material properties defined in our JSON objects to the appropriate
    shader uniforms.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的考虑因素是我们需要确保我们正确地将JSON对象中定义的材料属性映射到适当的着色器uniform。
- en: 'Let''s start implementing the `draw` function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现`draw`函数：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we set our viewport and clear the scene, followed by applying the perspective
    update by using the `transforms` instance we initialized inside of `configure`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置我们的视口并清除场景，然后通过使用我们在`configure`中初始化的`transforms`实例应用透视更新。
- en: 'Then, we move to the objects in our scene:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向场景中的对象：
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It may be helpful to take a look at the list of uniforms that was defined in
    the earlier section on shaders. We need to make sure that all of the shader uniforms
    are paired with object attributes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 查看之前章节中定义的uniforms列表可能会有所帮助。我们需要确保所有的着色器uniform都与对象属性配对。
- en: 'The following diagram shows the process that occurs inside the `draw` function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了`draw`函数内部发生的流程：
- en: '![](img/6a1f1a48-9965-4484-a37d-50314abaa617.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a1f1a48-9965-4484-a37d-50314abaa617.png)'
- en: 'Each car part is a different JSON file. The `draw` function iterates through
    all of these parts inside the `scene`. For each part, the material properties
    are passed as uniforms to the shaders and the geometry is passed as attributes
    (reading data from the respective VBOs). Finally, the draw call (`drawElements`)
    is executed. The result looks something like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每个汽车部件都是一个不同的 JSON 文件。`draw` 函数遍历 `scene` 内的所有这些部件。对于每个部件，材质属性作为 uniform 传递给着色器，几何形状作为属性（从相应的
    VBO 中读取数据）传递。最后，执行绘制调用（`drawElements`）。结果看起来像这样：
- en: '![](img/03a50b25-f2e1-4daa-9aad-795f45a63e3c.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03a50b25-f2e1-4daa-9aad-795f45a63e3c.png)'
- en: 'Here''s the final JavaScript source code that can be found in `ch09_02_showroom.html`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以在 `ch09_02_showroom.html` 中找到的最终 JavaScript 源代码：
- en: '[PRE44]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following code is for the vertex shader:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于顶点着色器的：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following code is for the fragment shader:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于片段着色器的：
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following is the application code with the appropriate global variable
    definitions:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有适当全局变量定义的应用程序代码：
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is the configuration step:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为配置步骤：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following code is for loading the required assets:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于加载所需的资源：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following code states where we draw our scene:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了我们绘制场景的位置：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The initialization of our application after the document has loaded is performed
    with the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 文档加载后，我们使用以下代码初始化应用程序：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***What just happened?***'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We have covered a demo that uses many of the elements we've discussed throughout
    this book. We used the infrastructure code that we developed throughout the previous
    chapters and implemented the three main functions: `configure`, `load`, and `draw`.
    As we've seen, these functions define the life cycle of our application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一个演示，它使用了本书中讨论的许多元素。我们使用了之前章节中开发的代码基础设施，并实现了三个主要功能：`configure`、`load`
    和 `draw`。正如我们所见，这些函数定义了我们的应用程序的生命周期。
- en: Have a Go: Interactive Controls
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 试试看：交互式控件
- en: 'Let''s leverage **dat.GUI** to add more interactivity and customization to
    our application. Go ahead and try and add the following functionality:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用 **dat.GUI** 为我们的应用程序添加更多交互性和定制功能。请尝试添加以下功能：
- en: 'Create a dropdown so that you can select from the following car models provided
    in the `common/models/` directory: `bmw-i8`, `audi-r8`, `ford-mustang`, and `lamborghini-gallardo`.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个下拉菜单，以便您可以从 `common/models/` 目录中提供的以下汽车模型中选择：`bmw-i8`、`audi-r8`、`ford-mustang`
    和 `lamborghini-gallardo`。
- en: '**Hint** You can leverage `carModelData` to declaratively describe the car
    models and use the already created `loadCar` function with the appropriate information.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示** 您可以利用 `carModelData` 声明性地描述汽车模型，并使用已创建的 `loadCar` 函数以及适当的信息。'
- en: Create a color picker to change the color of the loaded car.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个颜色选择器来改变加载的汽车的颜色。
- en: '**Hint** By inspecting the car data files, you will find various indicators
    that signify which parts are body panels. These are described as `paintAlias`
    in `carModelData`,  which can be used to change the `Kd` property of each individual
    item in the scene.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示** 通过检查汽车数据文件，您将找到各种指示器，这些指示器表示哪些部件是车身面板。这些在 `carModelData` 中描述为 `paintAlias`，可以用来改变场景中每个单独项目的
    `Kd` 属性。'
- en: Create a slider to change the shininess of the selected car.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个滑块来改变所选汽车的亮度。
- en: '**Hint** You can use `paintAlias` once again and update the `Ks` property of
    each individual item in the scene.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示** 您可以再次使用 `paintAlias` 并更新场景中每个单独项目的 `Ks` 属性。'
- en: 'The following functionality has been implemented in `ch09_03_showroom-controls.html`,
    along with controls for each individual light, the background color, floor visibility,
    and so forth:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下功能已在 `ch09_03_showroom-controls.html` 中实现，包括每个单独的灯光、背景颜色、地板可见性等控件：
- en: '![](img/d32ccc1d-cd9d-4f90-90bc-4a8e70d2ee2f.png)`utils.configureControls`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/d32ccc1d-cd9d-4f90-90bc-4a8e70d2ee2f.png)`utils.configureControls`'
- en: The `utils.configureControls` method is a simple abstraction on top of the dat.GUI
    interface to remove repetition and provide a more declarative way for describing
    our controls widget. You can use dat.GUI directly or build upon this simple helper
    function.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`utils.configureControls` 方法是在 dat.GUI 接口之上简单抽象的一个方法，用于减少重复并提供描述我们的控件小部件的更声明性方式。您可以直接使用
    dat.GUI 或在此基础上构建这个简单的辅助函数。'
- en: Bonus
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奖励
- en: You made it! How awesome is that?! As a bonus, a few additional examples have
    been provided for you in the source code under the `ch10` directory. The bonus
    examples use the virtual car showroom as a base to showcase a few more advanced
    features for you to leverage in your future ventures in building compelling 3D
    experiences. Enjoy!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你做到了！这有多么酷？！作为奖励，我们在`ch10`目录下的源代码中为你提供了一些额外的示例。这些奖励示例以虚拟汽车展厅为基础，展示了更多高级功能，供你在未来构建引人入胜的3D体验时使用。享受吧！
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let’s summarize what we’ve learned in this chapter:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所学的内容：
- en: We've reviewed concepts, architecture, and code that has been developed throughout
    this book.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们回顾了本书中开发的概念、架构和代码。
- en: We built a 3D virtual car showroom application showcasing how all of these elements
    fit together.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们构建了一个3D虚拟汽车展厅应用，展示了所有这些元素是如何结合在一起的。
- en: We've learned that designing complex models requires specialized tools, such
    as Blender.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解到设计复杂模型需要专门的工具，例如Blender。
- en: We covered how most of the current 3D graphics formats require the definition
    of vertices, indices, normals, and texture coordinates.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了大多数当前3D图形格式都需要定义顶点、索引、法线和纹理坐标。
- en: We studied how to obtain required elements from a Blender model to parse them
    into JSON files that we can load into a WebGL scene.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何从Blender模型中获取所需元素，并将它们解析成我们可以加载到WebGL场景中的JSON文件。
- en: We learned how to add a controls widget to provide customization functionality.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何添加控件小部件以提供定制功能。
- en: In the next chapter, we will get a sneak peek at some of the advanced techniques
    commonly used in 3D computer graphic systems, including games, simulations, and
    other 3D applications. After addressing these topics, we will also learn how to
    implement them in WebGL.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将提前了解一些在3D计算机图形系统中常用的高级技术，包括游戏、模拟和其他3D应用。在讨论了这些主题之后，我们还将学习如何在WebGL中实现它们。
