- en: Chapter 2. Geometries and Meshes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 几何体和网格
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Rotating an object around its own axis
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象自身轴上旋转对象
- en: Rotating an object around a point in space
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在空间中围绕一个点旋转一个对象
- en: Informing Three.js about updates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知Three.js关于更新
- en: Working with a large number of objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与大量对象一起工作
- en: Creating geometries from height maps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从高度图创建几何体
- en: Pointing an object to another object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个对象指向另一个对象
- en: Writing text in 3D
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在3D中写入文本
- en: Rendering 3D formulas as 3D geometries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将3D公式渲染为3D几何体
- en: Extending Three.js with a custom geometry object
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义几何体对象扩展Three.js
- en: Creating a spline curve between two points
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两点之间创建样条曲线
- en: Creating and exporting a model from Blender
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Blender创建和导出模型
- en: Using OBJMTLLoader with multiple materials
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OBJMTLLoader与多个材质
- en: Applying matrix transformations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用矩阵变换
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Three.js comes with a large number of geometries that you can use out of the
    box. In this chapter, we'll show you some recipes that explain how you can transform
    these standard geometries. Besides that, we'll also show you how to create your
    own custom geometries and load geometries from external sources.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js附带了许多您可以直接使用的几何体。在本章中，我们将向您展示一些菜谱，解释您如何转换这些标准几何体。除此之外，我们还将向您展示如何创建您自己的自定义几何体以及从外部源加载几何体。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can access all of the example code within all recipes in this cookbook from
    the GitHub repository created at [https://github.com/josdirksen/threejs-cookbook](https://github.com/josdirksen/threejs-cookbook).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub仓库[https://github.com/josdirksen/threejs-cookbook](https://github.com/josdirksen/threejs-cookbook)访问本食谱中所有菜谱内的所有示例代码。
- en: Rotating an object around its own axis
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在对象自身轴上旋转对象
- en: There are many ways in which you can change the appearance of a mesh. For example,
    you can change its position, scale, or material. Often, you'll also need to change
    the rotation of `THREE.Mesh`. In this first recipe on rotation, we'll show you
    the simplest way to rotate an arbitrary mesh.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过许多方式改变网格的外观。例如，你可以改变其位置、缩放或材质。通常，你还需要改变`THREE.Mesh`的旋转。在本章关于旋转的第一个菜谱中，我们将向您展示旋转任意网格的最简单方法。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To rotate a mesh, we first need to create a scene that contains an object you
    can rotate. For this recipe, we provide an example, `02.01-rotate-around-axis.html`,
    that you can open in your browser. When you open this recipe, you''ll see something
    similar to the following screenshot in your browser:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要旋转网格，我们首先需要创建一个包含您可以旋转的对象的场景。对于这个菜谱，我们提供了一个示例，`02.01-rotate-around-axis.html`，您可以在浏览器中打开。当您打开这个菜谱时，您将在浏览器中看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_02_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_02_01.jpg)'
- en: In this demo, you can see a 3D cube slowly rotating around its axis. Using the
    control GUI in the upper-right corner, you can change the speed at which the object
    rotates.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，您可以看到一个3D立方体在其轴上缓慢旋转。使用右上角的控制GUI，您可以改变对象旋转的速度。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To rotate the cube from this example around its axis like we showed you in
    the previous screenshot, you have to take a couple of steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要像我们在上一张截图中所展示的那样，围绕轴旋转这个示例中的立方体，您必须采取几个步骤：
- en: 'For the first step in this recipe, we''ll set up the control GUI, as we''ve
    shown in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*,
    in the *Controlling the variables used in the scene* recipe, which you can see
    in the top-right corner. This time, we''ll use the following as the control object:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本菜谱的第一步中，我们将设置控制GUI，正如我们在[第一章](ch01.html "第一章. 入门")中所示，在*控制场景中使用的变量*菜谱中，您可以在右上角看到。这次，我们将使用以下作为控制对象：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With this `control` object, we''ll control the rotation around any of the three
    axes. We pass this control object to the `addControls` function:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这个`control`对象，我们将控制围绕三个轴中的任何一个轴的旋转。我们将这个控制对象传递给`addControls`函数：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now when we call the `addControls` function, we'll get the nice GUI that you
    saw in the screenshot at the beginning of this recipe.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们调用`addControls`函数时，我们将得到您在菜谱开头截图中所看到的漂亮的GUI。
- en: 'Now that we can control the rotation through the GUI, we can use these values
    to directly set the rotation of our object. In this example, we continuously update
    the `rotation` property of the mesh, so you get the nice animation you can see
    in the example. For this, we define the `render` function like this:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过GUI控制旋转，我们可以使用这些值来直接设置我们对象的旋转。在这个例子中，我们持续更新网格的`rotation`属性，所以你可以看到示例中的动画。为此，我们定义`render`函数如下：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this function, you can see that we increase the `rotation` property of the
    `THREE.Mesh` object with the value set in the control GUI. This results in the
    animation you can see in the screenshot in the *Getting ready* section. Note that
    the rotation property is of the `THREE.Vector3` type. This means that you can
    also set the property in one statement using `cube.rotation.set(x, y, z)`.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个函数中，你可以看到我们通过控制GUI中设置的值来增加`THREE.Mesh`对象的`rotation`属性。这导致了你在*准备就绪*部分中看到的动画。请注意，旋转属性是`THREE.Vector3`类型。这意味着你也可以使用一个语句来设置属性，使用`cube.rotation.set(x,
    y, z)`。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When you set the rotation property on `THREE.Mesh`, as we do in this example,
    Three.js doesn't directly calculate the new positions of the vertices of the geometry.
    If you print out these vertices to the console, you'll see that regardless of
    the `rotation` property, they will stay exactly the same. What happens is that
    when Three.js actually renders `THREE.Mesh` in the `renderer.render` function,
    it is at that exact point that its exact position and rotation is calculated.
    So when you translate, rotate, or scale `THREE.Mesh`, the underlying `THREE.Geometry`
    object stays the same.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`THREE.Mesh`上设置旋转属性，就像我们在本例中所做的那样，Three.js不会直接计算几何体的顶点的新位置。如果你将这些顶点打印到控制台，你会看到，无论`rotation`属性如何，它们都将保持完全相同。发生的情况是，当Three.js实际上在`renderer.render`函数中渲染`THREE.Mesh`时，正是那个确切的时刻，它的确切位置和旋转被计算出来。所以当你平移、旋转或缩放`THREE.Mesh`时，底层的`THREE.Geometry`对象保持不变。
- en: See also
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'There are different ways to rotate an object besides the one we showed here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在这里展示的方法之外，还有其他方法可以旋转一个对象：
- en: In the upcoming *Rotating an object around a point in space* recipe, we'll show
    you how you can rotate an object around an arbitrary point in space instead of
    its own axis, as we showed in this recipe
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在即将到来的*在空间中围绕一个点旋转一个对象*配方中，我们将向你展示如何围绕任意点在空间中旋转一个对象，而不是围绕其自身的轴，就像我们在这个配方中展示的那样。
- en: Rotating an object around a point in space
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在空间中围绕一个点旋转一个对象
- en: When you rotate an object using its rotate property, the object is rotated around
    its own center. In some scenarios, though, you might want to rotate an object
    around a different object. For instance, when modeling the solar system, you want
    to rotate the moon around the earth. In this recipe, we'll explain how you can
    set up Three.js objects in such a way that you can rotate them around one another
    or any point in space.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用旋转属性旋转一个对象时，该对象是围绕其自身的中心旋转的。然而，在某些情况下，你可能想要围绕不同的对象旋转一个对象。例如，在模拟太阳系时，你想要围绕地球旋转月球。在这个配方中，我们将解释如何设置Three.js对象，以便你可以围绕彼此或空间中的任何点旋转它们。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we''ve also provided an example you can experiment with. To
    load this example, just open `02.02-rotate-around-point-in-space.html` in a browser.
    When you open this file, you''ll see something similar to the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们还提供了一个你可以实验的示例。要加载这个示例，只需在浏览器中打开`02.02-rotate-around-point-in-space.html`。当你打开这个文件时，你会看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_02_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_02_02.jpg)'
- en: With the controls on the right-hand side, you can rotate various objects around.
    By changing the **rotationSpeedX**, **rotationSpeedY**, and **rotationSpeedZ**
    properties, you can rotate the red box around the center of the sphere.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右侧的控制，你可以旋转各种对象。通过更改**rotationSpeedX**、**rotationSpeedY**和**rotationSpeedZ**属性，你可以围绕球体的中心旋转红色盒子。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To best demonstrate the rotation of an object around another one, you should
    rotate around that object's *y* axis. To do this, change the **rotationSpeedY**
    property.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地展示围绕另一个对象旋转一个对象，你应该围绕该对象的*y*轴旋转。为此，更改**rotationSpeedY**属性。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Rotating an object around another object takes a couple of additional steps
    compared to the rotation we showed in the previous recipe:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前配方中展示的旋转相比，围绕另一个对象旋转一个对象需要额外的几个步骤：
- en: 'Let''s first create the central blue sphere you can see in the screenshot.
    This is the object that we''ll rotate the little red box around:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建截图中所看到的中心蓝色球体。这是我们将在其周围旋转小红色盒子的对象：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So far, there's nothing special in this code snippet. You can see a standard
    `THREE.Sphere` object from which we create `THREE.Mesh` and add it to the scene.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，这个代码片段中没有什么特别之处。您可以看到一个标准的 `THREE.Sphere` 对象，我们从中创建 `THREE.Mesh` 并将其添加到场景中。
- en: 'The next step is to define a separate object, which we''ll use as the pivot
    point for our box:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义一个单独的对象，我们将使用它作为盒子的支点：
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `pivotPoint` object is a `THREE.Object3D` object. This is the parent object
    of `THREE.Mesh` and can be added to a scene without a geometry or a material.
    In this recipe, however, we don't add it to the scene but add it to the sphere
    we created in step 1\. So, if the sphere rotates or changes position, this `pivotPoint`
    object will also change its position and rotation since we added it as a child
    to the sphere.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pivotPoint` 对象是一个 `THREE.Object3D` 对象。这是 `THREE.Mesh` 的父对象，可以添加到场景中而不需要几何形状或材质。然而，在这个菜谱中，我们没有将其添加到场景中，而是将其添加到我们在步骤
    1 中创建的球体中。因此，如果球体旋转或改变位置，这个 `pivotPoint` 对象的位置和旋转也会改变，因为我们将其作为子对象添加到球体中。'
- en: 'Now we can create the red box, and instead of adding it to the scene, we add
    it to the `pivotPoint` object we just created:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建红色盒子，而不是将其添加到场景中，我们将其添加到我们刚刚创建的 `pivotPoint` 对象中：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we can rotate `pivotPoint` and the cube will follow the rotation of `pivotPoint`.
    For this recipe, we do this by updating the `rotation` property of `pivotPoint`
    in the `render` function:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以旋转 `pivotPoint`，立方体将跟随 `pivotPoint` 的旋转。对于这个菜谱，我们通过在 `render` 函数中更新 `pivotPoint`
    的 `rotation` 属性来实现这一点：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you create `THREE.Mesh` in Three.js, you normally just add it to `THREE.Scene`
    and position it individually. In this recipe, however, we've made use of the `THREE.Mesh`
    feature, which extends from `THREE.Object3D` itself and can also contain children.
    So when the parent object is rotated, this will also affect the children.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Three.js 中创建 `THREE.Mesh` 时，你通常只是将其添加到 `THREE.Scene` 并单独定位它。然而，在这个菜谱中，我们利用了
    `THREE.Mesh` 功能，它从 `THREE.Object3D` 本身扩展而来，也可以包含子对象。因此，当父对象旋转时，这也会影响子对象。
- en: 'A really interesting aspect of using the approach explained in this recipe
    is that we can now do a couple of interesting things:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个菜谱中解释的方法的一个非常有趣的方面是，我们现在可以做几件有趣的事情：
- en: We can rotate the box itself by updating the `cube.rotation` property like we
    did in the *Rotating an object around its own axis* recipe
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过更新 `cube.rotation` 属性来旋转盒子本身，就像我们在 *绕自身轴旋转对象* 菜谱中所做的那样
- en: We can also rotate the box around the sphere by changing the rotation property
    of the sphere, as we added `pivotPoint` as a child of the sphere mesh
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以通过更改球体的旋转属性来围绕球体旋转盒子，因为我们已经将 `pivotPoint` 添加为球体网格的子对象
- en: We can even combine everything, we can rotate `pivotPoint`, `sphereMesh`, and
    `cube`—all separately—and create very interesting effects
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们甚至可以将所有这些结合起来，我们可以分别旋转 `pivotPoint`、`sphereMesh` 和 `cube`——所有这些——并创建非常有趣的效果
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this recipe, we''ve used the fact that we can add children to meshes as
    a way to rotate an object around another object. However, after reading the following
    recipes, you will learn more about this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了可以将子对象添加到网格的事实，作为绕另一个对象旋转对象的方法。然而，在阅读以下菜谱之后，你将了解更多关于这一点：
- en: In the *Rotating an object around its own axis* recipe, we showed you how you
    can rotate an object around its own axis
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *绕自身轴旋转对象* 的菜谱中，我们向您展示了如何使对象绕其自身轴旋转
- en: Informing Three.js about updates
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知 Three.js 关于更新
- en: 'If you''ve worked a bit longer with Three.js, you''ll probably have noticed
    that sometimes, it seems that changes you make to a certain geometry doesn''t
    always result in a change onscreen. This is because for performance reasons, Three.js
    caches some objects (such as the vertices and faces of a geometry) and doesn''t
    automatically detect updates. For these kinds of changes, you''ll have to explicitly
    inform Three.js that something has changed. In this recipe, we''ll show you what
    properties of a geometry are cached and require explicit notification to Three.js
    to be updated. These properties are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用 Three.js 工作了更长一段时间，你可能已经注意到，有时你对某些几何形状所做的更改似乎并不会总是导致屏幕上的变化。这是因为出于性能原因，Three.js
    缓存了一些对象（例如几何形状的顶点和面）并且不会自动检测更新。对于这类更改，你必须明确通知 Three.js 有所变化。在这个菜谱中，我们将向您展示哪些几何形状的属性被缓存并且需要明确通知
    Three.js 以进行更新。这些属性包括：
- en: '`geometry.vertices`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometry.vertices`'
- en: '`geometry.faces`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometry.faces`'
- en: '`geometry.morphTargets`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometry.morphTargets`'
- en: '`geometry.faceVertexUvs`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometry.faceVertexUvs`'
- en: '`geometry.faces[i].normal` and `geometry.vertices[i].normal`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometry.faces[i].normal` 和 `geometry.vertices[i].normal`'
- en: '`geometry.faces[i].color` and `geometry.vertices[i].color`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometry.faces[i].color` 和 `geometry.vertices[i].color`'
- en: '`geometry.vertices[i].tangent`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometry.vertices[i].tangent`'
- en: '`geometry.lineDistances`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometry.lineDistances`'
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'An example is available that allows you to change two properties that require
    an explicit update: face colors and vertex positions. If you open up the `02.04-update-stuff.html`
    example in your browser, you''ll see something similar to the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个示例允许你更改需要显式更新的两个属性：面颜色和顶点位置。如果你在你的浏览器中打开 `02.04-update-stuff.html` 示例，你会看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_02_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_02_03.jpg)'
- en: With the menu in the top-right section, you can change two properties of this
    geometry. With the **changeColors** button, you can set the colors of each individual
    face to a random color, and with **changeVertices**, you change the position of
    each vertex of this cube. To apply these changes, you have to push the **setUpdateColors**
    button or the **setUpdateVertices** button, respectively.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用右上角的菜单，你可以更改这个几何体的两个属性。使用 **changeColors** 按钮，你可以将每个单独面的颜色设置为随机颜色，使用 **changeVertices**，你改变这个立方体每个顶点的位置。要应用这些更改，你必须按下
    **setUpdateColors** 按钮或 **setUpdateVertices** 按钮。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'There are a number of properties where you have to explicitly tell Three.js
    about the update. This recipe will show you how to inform Three.js about all possible
    changes. Depending on the change you''re making, you can jump in at any step of
    the recipe:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多属性中，你必须明确地告诉 Three.js 关于更新的信息。这个食谱将向你展示如何通知 Three.js 关于所有可能的更改。根据你进行的更改，你可以在食谱的任何步骤中跳入：
- en: Firstly, if you want to add vertices or change the values of an individual vertex
    of a geometry, you can use the `geometry.vertices` property. Once you've added
    or changed an element, you need to set the `geometry.verticesNeedUpdate` property
    to `true`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果你想添加顶点或更改几何体单个顶点的值，你可以使用 `geometry.vertices` 属性。一旦你添加或更改了一个元素，你需要将 `geometry.verticesNeedUpdate`
    属性设置为 `true`。
- en: Following this, you might want the face definition within a geometry to be cached
    as well, which will require you to use the `geometry.faces` property. This means
    that when you add `THREE.Face` or update one of the existing properties, you need
    to set `geometry.elementsNeedUpdate` to `true`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，你可能还想缓存几何体内部的面的定义，这需要你使用 `geometry.faces` 属性。这意味着当你添加 `THREE.Face` 或更新现有属性时，你需要将
    `geometry.elementsNeedUpdate` 设置为 `true`。
- en: You might then want to morph targets that can be used to create animations,
    where one set of vertices morph into another set of vertices. This will require
    the `geometry.morphTargets` property. To do this, when you add a new morph target
    or update an existing one, you need to set `geometry.morphTargetsNeedUpdate` to
    `true`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可能想使用可以创建动画的变形目标，其中一个顶点集变形为另一个顶点集。这需要 `geometry.morphTargets` 属性。为了做到这一点，当你添加一个新的变形目标或更新现有的一个时，你需要将
    `geometry.morphTargetsNeedUpdate` 设置为 `true`。
- en: Then, the next step would be to add `geometry.faceVertexUvs`. With this property,
    you define how textures are mapped onto the geometry. If you add or change elements
    in this array, you need to set the `geometry.uvsNeedUpdate` property to `true`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，下一步将是添加 `geometry.faceVertexUvs`。使用这个属性，你定义了纹理如何映射到几何体上。如果你在这个数组中添加或更改元素，你需要将
    `geometry.uvsNeedUpdate` 属性设置为 `true`。
- en: You might also want to change the vertices or faces' normals by changing the
    `geometry.faces[i].normal` and `geometry.vertices[i].normal` properties. When
    you do this, you have to set `geometry.normalsNeedUpdate` to `true` to inform
    Three.js about this. Besides the normal, there is also a `geometry.vertices[i].tangent`
    property. This property is used to calculate shadows and also calculate when textures
    are rendered. If you make manual changes, you have to set `geometry.tangentsNeedUpdate`
    to `true`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还想通过更改 `geometry.faces[i].normal` 和 `geometry.vertices[i].normal` 属性来更改顶点或面的法线。当你这样做时，你必须将
    `geometry.normalsNeedUpdate` 设置为 `true` 以通知 Three.js。除了法线之外，还有一个 `geometry.vertices[i].tangent`
    属性。这个属性用于计算阴影，并计算纹理渲染的时间。如果你进行手动更改，你必须将 `geometry.tangentsNeedUpdate` 设置为 `true`。
- en: 'Next, you can define individual colors on the vertices or the faces. You do
    this by setting these color properties: `geometry.faces[i].color` and `geometry.vertices[i].color`.
    Once you''ve made changes to these properties, you have to set `geometry.colorsNeedUpdate`
    to `true`.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以在顶点或面上定义单个颜色。你通过设置这些颜色属性来完成此操作：`geometry.faces[i].color`和`geometry.vertices[i].color`。一旦你修改了这些属性，你必须将`geometry.colorsNeedUpdate`设置为`true`。
- en: 'As a final step, you can choose to change textures and materials during runtime.
    When you want to change one of these properties of a material, you need to set
    `material.needsUpdate` to `true`: texture, fog, vertex colors, skinning, morphing,
    shadow map, alpha test, uniforms, and lights. If you want to update the data behind
    a texture, you need to set the `texture.needsUpdate` flag to `true`.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，你可以在运行时选择更改纹理和材质。当你想要更改材质的其中一个属性时，你需要将`material.needsUpdate`设置为`true`：纹理、雾、顶点颜色、蒙皮、变形、阴影贴图、alpha测试、统一变量和灯光。如果你想更新纹理背后的数据，你需要将`texture.needsUpdate`标志设置为`true`。
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As a summary, steps 1 to 7 apply to geometries and any resulting Three.js objects
    that are based on geometries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为总结，步骤1到7适用于几何体以及基于几何体的任何Three.js对象。
- en: To get the most performance out of your 3D scene, Three.js caches certain properties
    and values that usually don't change. Especially when working with the WebGL renderer,
    a lot of performance is gained by caching all these values. When you set one of
    these flags to true, Three.js knows, very specifically, which part it needs to
    update.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从你的3D场景中获得最佳性能，Three.js缓存了一些通常不会改变的性质和值。特别是在使用WebGL渲染器时，通过缓存所有这些值可以获得很多性能提升。当你将这些标志之一设置为true时，Three.js会非常具体地知道它需要更新哪一部分。
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: There are recipes within this book that are similar to this. If you look at
    the source code for the *Applying matrix transformations* recipe, you can see
    that we've used the `verticesNeedUpdate` property after we applied some matrix
    transformations to the geometry.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中有一些与这类似的食谱。如果你查看*应用矩阵变换*食谱的源代码，你可以看到我们在对几何体应用了一些矩阵变换之后使用了`verticesNeedUpdate`属性。
- en: Working with a large number of objects
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理大量对象
- en: If you have scenes with large numbers of objects, you will start noticing some
    performance issues. Each of the meshes you create and add to the scene will need
    to be managed by Three.js, which will cause slowdowns when you're working with
    thousands of objects. In this recipe, we'll show you how to merge objects together
    to improve performance.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多对象的场景，你将开始注意到一些性能问题。你创建并添加到场景中的每个网格都需要由Three.js管理，当你处理成千上万的对象时，这会导致速度减慢。在这个食谱中，我们将向你展示如何合并对象以提高性能。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: There are no additional libraries or resources required to merge objects together.
    We've prepared an example that shows you the difference in performance when using
    separate objects compared to a merged object. When you open up the `02.05-handle-large-number-of-object.html`
    example, you can experiment with the different approaches.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 合并对象不需要额外的库或资源。我们准备了一个示例，展示了使用单独的对象与合并对象相比在性能上的差异。当你打开`02.05-handle-large-number-of-object.html`示例时，你可以尝试不同的方法。
- en: 'You will see something similar to the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下截图的类似内容：
- en: '![Getting ready](img/1182OS_02_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_02_04.jpg)'
- en: In the preceding screenshot, you can see that with a merged object approach,
    we still get 60 fps when working with 120,000 objects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到，在使用合并对象的方法时，我们在处理120,000个对象时仍然能够达到60 fps。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Merging objects in Three.js is very easy. The following code snippet shows
    you how to merge the objects from the previous example together. The important
    step here is to create a new `THREE.Geometry()` object named `mergedGeometry`
    and then create a large number of `BoxGeometry` objects, as shown in the highlighted
    code sections:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中合并对象非常简单。以下代码片段展示了如何将前一个示例中的对象合并在一起。这里的重要步骤是创建一个新的`THREE.Geometry()`对象，命名为`mergedGeometry`，然后创建大量`BoxGeometry`对象，如高亮代码部分所示：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We merge each `cubeGeometry` object into the `mergedGeometry` object by calling
    the `merge` function. The result is a single geometry that we use to create `THREE.Mesh`,
    which we add to the scene.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`merge`函数将每个`cubeGeometry`对象合并到`mergedGeometry`对象中。结果是单个几何体，我们用它来创建`THREE.Mesh`，并将其添加到场景中。
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you call the `merge` function on a geometry (let''s call it `merged`)
    and pass in the geometry to be merged (let''s call this one `toBeMerged`), Three.js
    takes the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在几何体（我们称之为 `merged`）上调用 `merge` 函数并传入要合并的几何体（我们称之为 `toBeMerged`）时，Three.js
    会执行以下步骤：
- en: First, Three.js clones all the vertices from the `toBeMerged` geometry and adds
    them to the vertices array of the `merged` geometry.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，Three.js 从 `toBeMerged` 几何体中克隆所有顶点并将它们添加到 `merged` 几何体的顶点数组中。
- en: Next, it walks through the faces from the `toBeMerged` geometry and creates
    new faces in the `merged` geometry, copying the original normal and colors.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它会遍历 `toBeMerged` 几何体中的面，并在 `merged` 几何体中创建新的面，复制原始的法线和颜色。
- en: As a final step, it copies the `uv` mapping from `toBeMerged` into the `uv`
    mapping of the `merged` geometry.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，它将 `toBeMerged` 的 `uv` 映射复制到 `merged` 几何体的 `uv` 映射中。
- en: The result is a single geometry that, when added to the scene, looks like multiple
    geometries.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个单一的几何体，当添加到场景中时，看起来像多个几何体。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The main issue with this approach is that it gets harder to color, style, animate,
    and transform the objects that are merged together independently. For Three.js,
    after the merge, it counts as a single object. It is, however, possible to apply
    specific materials to each face. We show you how to do this in the *Using separate
    materials for faces* recipe in [Chapter 4](ch04.html "Chapter 4. Materials and
    Textures"), *Materials and Textures*.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法的主要问题是，独立合并的对象着色、样式、动画和变换变得更加困难。对于 Three.js 来说，合并后，它被视为一个单独的对象。然而，可以将特定的材质应用到每个面上。我们将在第
    4 章“材料和纹理”中的*使用单独的材质为面着色*配方中向你展示如何做这件事。
- en: Creating geometries from height maps
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从高度图中创建几何体
- en: With Three.js, it is easy to create your own geometries. For this recipe, we're
    going to show you how to create your own geometry based on a terrain height map.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Three.js，创建自己的几何体非常容易。对于这个配方，我们将向你展示如何根据地形高度图创建自己的几何体。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To convert a height map into a 3D geometry, we first need to have a height
    map. In the source files provided with this book, you can find a height map for
    a portion of the Grand Canyon. The following image shows you what this looks like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要将高度图转换为 3D 几何体，我们首先需要一个高度图。在这本书提供的源文件中，你可以找到一个 Grand Canyon 部分的高度图。以下图像显示了它的样子：
- en: '![Getting ready](img/1182OS_02_05.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_02_05.jpg)'
- en: 'If you''re familiar with the Grand Canyon, you''ll probably recognize the distinct
    shape. The final result we''ll have at the end of this recipe can be viewed by
    opening up the `02.06-create-terrain-from-heightmap.html` file in your browser.
    You''ll see something similar to the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉大峡谷（Grand Canyon），你可能会认出其独特的形状。本配方结束时的最终结果可以通过在浏览器中打开 `02.06-create-terrain-from-heightmap.html`
    文件来查看。你将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_02_06.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_02_06.jpg)'
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a heightmap-based geometry, you need to perform these steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建基于高度图（heightmap）的几何体，你需要执行以下步骤：
- en: 'Before we look at the required Three.js code, we first need to load the image
    and set some properties that determine the final size and height of the geometry.
    This can be done by adding the following code snippet and loading the image by
    setting the `img.src` property to the location of our height map. Once the image
    is loaded, the `img.onload` function will be called, where we convert the image
    data to `THREE.Geometry`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们查看所需的 Three.js 代码之前，我们首先需要加载图像并设置一些属性，这些属性决定了几何体的最终大小和高度。这可以通过添加以下代码片段并设置
    `img.src` 属性为我们的高度图位置来完成。一旦图像加载，`img.onload` 函数将被调用，在那里我们将图像数据转换为 `THREE.Geometry`：
- en: '[PRE8]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the image is loaded in the `onload` function, we need the value of each
    pixel and convert it to `THREE.Vector3`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦图像在 `onload` 函数中加载，我们需要每个像素的值并将其转换为 `THREE.Vector3`：
- en: '[PRE9]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see in this code snippet, we process each of the image pixels, and
    based on the pixel value, we create `THREE.Vector3`, which we add to the vertices
    array of our custom geometry.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如此代码片段所示，我们处理图像的每个像素，并根据像素值创建 `THREE.Vector3`，并将其添加到我们自定义几何体的顶点数组中。
- en: 'Now that we''ve defined the vertices, the next step is to use these vertices
    to create faces:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了顶点，下一步是使用这些顶点来创建面：
- en: '[PRE10]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, each set of four vertices is converted into two `THREE.Face3`
    elements and added to the `faces` array.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，每一组四个顶点被转换成两个 `THREE.Face3` 元素并添加到 `faces` 数组中。
- en: 'Now all we need to do is to let Three.js calculate the vertex and face normals,
    and we can create `THREE.Mesh` from this geometry and add it to the scene:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是让Three.js计算顶点和面的法线，然后我们可以从这个几何体创建`THREE.Mesh`并将其添加到场景中：
- en: '[PRE11]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you render this scene, you might need to play around with the camera position
    and the scale of the final mesh to get the correct size.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您渲染这个场景，您可能需要调整相机位置和最终网格的缩放，以获得正确的大小。
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Height maps are a way to embed the height information into an image. Each pixel
    value of the image represents the relative height measured at that point. In this
    recipe, we've processed this value, together with its *x* and *y* values, and
    converted it into a vertex. If we do this for each point, we get an exact 3D representation
    of the 2D height map. In this case, it results in a geometry that contains 512
    * 512 vertices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 高度图是将高度信息嵌入图像的一种方法。图像的每个像素值代表在该点测量的相对高度。在本食谱中，我们处理了这个值，以及它的*x*和*y*值，并将其转换为顶点。如果我们对每个点都这样做，我们就可以得到一个精确的2D高度图的3D表示。在这种情况下，它产生了一个包含512
    * 512个顶点的几何体。
- en: There's more…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'When we create a geometry from scratch, there are a few interesting things
    we can add. We can, for instance, color each individual face. This can be done
    by doing the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从零开始创建一个几何体时，我们可以添加一些有趣的东西。例如，我们可以为每个单独的面着色。这可以通过以下方式完成：
- en: 'Firstly, add the `chroma` library (you can download the source from [https://github.com/gka/chroma.js](https://github.com/gka/chroma.js)):'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加`chroma`库（您可以从[https://github.com/gka/chroma.js](https://github.com/gka/chroma.js)下载源代码）：
- en: '[PRE12]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can then create a color scale:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以创建一个颜色刻度：
- en: '[PRE13]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Set the face colors based on the height of the face:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据面的高度设置面颜色：
- en: '[PRE14]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, set `vertexColors` of the material to `THREE.FaceColors`. The result
    looks something like this:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将材质的`vertexColors`设置为`THREE.FaceColors`。结果看起来大致如下：
- en: '![There''s more…](img/1182OS_02_07.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/1182OS_02_07.jpg)'
- en: You can also apply different kinds of materials to really create a terrain-like
    effect. For more information on this, see [Chapter 4](ch04.html "Chapter 4. Materials
    and Textures"), *Materials and Textures*, on materials.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以应用不同类型的材质，以真正创建类似地形的效果。有关更多信息，请参阅[第4章](ch04.html "第4章。材质和纹理")，*材质和纹理*，关于材质的介绍。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: In this sample, we've used a height map to create a geometry. You can also use
    a heightmap as a bump map to add depth detail to a model. We show you how to do
    this in [Chapter 4](ch04.html "Chapter 4. Materials and Textures"), *Materials
    and Textures*, in the *Adding depth to a mesh with bump map* recipe.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用高度图创建了一个几何体。您还可以将高度图用作凹凸图，以向模型添加深度细节。我们将在[第4章](ch04.html "第4章。材质和纹理")，*材质和纹理*，的*使用凹凸图向网格添加深度*食谱中向您展示如何这样做。
- en: Pointing an object to another object
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一个对象指向另一个对象
- en: A common requirement for many games is that cameras and other objects follow
    each other or be aligned to one another. Three.js has standard support for this
    using the `lookAt` function. In this recipe, you'll learn how you can use the
    `lookAt` function to point an object to look at another object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏的一个常见需求是相机和其他对象相互跟随或对齐。Three.js使用`lookAt`函数提供了对此的标准支持。在本食谱中，您将学习如何使用`lookAt`函数将一个对象指向另一个对象。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The example for this recipe can be found in the sources for this book. If you
    open `02.07-point-object-to-another.html` in your browser, you see something similar
    to the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例可以在本书的源代码中找到。如果您在浏览器中打开`02.07-point-object-to-another.html`，您会看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_02_08.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_02_08.jpg)'
- en: With the menu, you can point the large blue rectangle to look at any of the
    other meshes in the scene.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用菜单，您可以将大蓝色矩形指向场景中的任何其他网格。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Creating the `lookAt` functionality is actually very simple. When you add `THREE.Mesh`
    to the scene, you can just call its `lookAt` function and point it to the position
    it should turn to. For the example provided for this recipe, this is done as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`lookAt`功能实际上非常简单。当您将`THREE.Mesh`添加到场景中时，您只需调用其`lookAt`函数并将其指向它应该转向的位置。对于本食谱提供的示例，操作如下：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So when you push the `lookAtSphere` button, the rectangle's `lookAt` function
    will be called with the sphere's position.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您点击`lookAtSphere`按钮时，矩形的`lookAt`函数将使用球体的位置被调用。
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using this code, it is very easy to line up one object with another. With the
    `lookAt` function, Three.js hides the complexity that is needed to accomplish
    this. Internally, Three.js uses matrix calculations to determine the rotation
    it needs to apply to the object to align it correctly with the object you're looking
    at. The required rotations are then set on the object (to the `rotation` property)
    and shown in the next render loop.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，将一个对象与另一个对象对齐非常容易。使用`lookAt`函数，Three.js隐藏了完成此操作所需的复杂性。内部，Three.js使用矩阵计算来确定需要应用到对象上的旋转，以正确地对齐你正在查看的对象。所需的旋转随后被设置在对象上（到`rotation`属性）并在下一个渲染循环中显示。
- en: There's more…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this example, we showed you how to align one object to another. With Three.js,
    you can use the same approach for other types of objects. You can point the camera
    to center on a specific object using `camera.lookAt(object.position)`, and you
    can also direct a light to point to a specific object using `light.lookAt(object.position)`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们向你展示了如何将一个对象对齐到另一个对象。使用Three.js，你可以用相同的方法处理其他类型的对象。你可以使用`camera.lookAt(object.position)`将相机指向一个特定的对象以使其居中，你也可以使用`light.lookAt(object.position)`将灯光指向一个特定的对象。
- en: You can also use `lookAt` to follow a moving object. Just add the `lookAt` code
    in the render loop, and the object will follow the moving object around.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`lookAt`来跟踪一个移动的对象。只需在渲染循环中添加`lookAt`代码，对象就会围绕移动的对象移动。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The `lookAt` function uses matrix calculations internally. In the last recipe
    of this chapter, *Applying matrix transformations*, we show you how you can use
    matrix calculations to accomplish other effects.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lookAt`函数在内部使用矩阵计算。在本章的最后一个配方中，*应用矩阵变换*，我们展示了你可以如何使用矩阵计算来完成其他效果。'
- en: Writing text in 3D
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在3D中编写文本
- en: A cool feature of Three.js is that it allows you to write text in 3D. With a
    couple of simple steps, you can use any text, even with font support, as a 3D
    object in your scene. This recipe shows you how to create 3D text and explains
    the different configuration options available to style the result.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js的一个酷特性是它允许你在3D中编写文本。通过几个简单的步骤，你可以使用任何文本，甚至带有字体支持，作为场景中的3D对象。这个配方展示了如何创建3D文本，并解释了可用于样式化结果的不同的配置选项。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To work with 3D text, we need to include some additional JavaScript in our
    pages. Three.js provides a number of fonts you can use, and they are provided
    as individual JavaScript files. To add all the available fonts, include the following
    scripts:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要在页面上使用3D文本，我们需要包含一些额外的JavaScript代码。Three.js提供了一些你可以使用的字体，它们以单独的JavaScript文件的形式提供。要添加所有可用的字体，请包含以下脚本：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ve already done this in the `02.09-write-text-in-3D.html` example. If you
    open this in your browser, you can play around with the various fonts and properties
    available when creating text in Three.js. When you open the specified example
    you will see something similar to the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`02.09-write-text-in-3D.html`示例中做了这个。如果你在浏览器中打开它，你可以尝试在Three.js中创建文本时使用的各种字体和属性。当你打开指定的示例时，你会看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_02_09.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_02_09.jpg)'
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Creating 3D text in Three.js is very easy. All you have to do is create `THREE.TextGeometry`
    like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中创建3D文本非常简单。你所要做的就是创建像这样的`THREE.TextGeometry`：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `text` property is the text we want to write, and `params` define how the
    text is rendered. The `params` object can have many different parameters, which
    you can look at in more detail in the *How it works…* section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`text`属性是我们想要写入的文本，而`params`定义了文本的渲染方式。`params`对象可以有许多不同的参数，你可以在*如何工作…*部分中更详细地查看。'
- en: 'In our example, however, we''ve used the following set of parameters (which
    point to the GUI in the top-right section):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的例子中，我们使用了以下参数集（它指向右上角的GUI部分）：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This geometry can then be added to the scene like any other geometry:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个几何体可以像其他任何几何体一样添加到场景中：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is one thing you need to take into account when working with `THREE.TextGeometry`
    and materials. As you can see from the code snippet, we add two material objects
    instead of one. The first material is applied to the front of rendered text, and
    the second one is applied to the side of the rendered text. If you just pass in
    one material, it is applied to both the front and the side.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `THREE.TextGeometry` 和材料时，需要考虑一件事。如代码片段所示，我们添加了两个材质对象而不是一个。第一个材质应用于渲染文本的前面，第二个材质应用于渲染文本的侧面。如果您只传递一个材质，它将应用于前面和侧面。
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As mentioned, there is a variety of different parameters:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，存在许多不同的参数：
- en: '| Parameter | Description |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `height` | The height property defines the depth of the text, in other words,
    how far the text is extruded to make it 3D. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `height` | 高度属性定义文本的深度，换句话说，文本被拉伸多远以使其成为3D。 |'
- en: '| `size` | With this property, you set the size of the final text. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `size` | 使用此属性，您设置最终文本的大小。 |'
- en: '| `curveSegments` | If a character has curves (for example, the letter *a*),
    this property defines how smooth the curves will be. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `curveSegments` | 如果字符有曲线（例如，字母 *a*），此属性定义曲线将有多平滑。 |'
- en: '| `bevelEnabled` | A bevel provides a smooth transition from the front of the
    text to the side. If you set this value to true, a bevel will be added to the
    rendered text. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `bevelEnabled` | 斜边提供了从文本前面到侧面的平滑过渡。如果您将此值设置为 `true`，则将在渲染的文本上添加斜边。 |'
- en: '| `bevelThickness` | If you''ve set `bevelEnabled` to `true`, it defines how
    deep the bevel is. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `bevelThickness` | 如果您已将 `bevelEnabled` 设置为 `true`，则定义斜边有多深。 |'
- en: '| `bevelSize` | If you''ve set `bevelEnabled` to `true`, it defines how high
    the bevel is. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `bevelSize` | 如果您已将 `bevelEnabled` 设置为 `true`，则定义斜边有多高。 |'
- en: '| `weight` | This is the weight of the font (normal or bold). |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `weight` | 这是指文字的粗细（正常或粗体）。 |'
- en: '| `font` | This is the name of the font to be used. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `font` | 这是将要使用的字体名称。 |'
- en: '| `material` | When an array of materials is provided, this should contain
    the index of the material to be used for the front. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `material` | 当提供材料数组时，此属性应包含用于前面的材料索引。 |'
- en: '| `extrudeMaterial` | When an array of materials is provided, this should contain
    the index of the materials to be used for the side. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `extrudeMaterial` | 当提供材料数组时，此属性应包含用于侧面的材料索引。 |'
- en: When you create `THREE.TextGeometry`, Three.js internally uses `THREE.ExtrudeGeometry`
    to create the 3D shapes. `THREE.ExtrudeGeometry` works by taking a 2D shape and
    extrudes it along the *Z* axis to make it 3D. To create a 2D shape from a text
    string, Three.js uses the JavaScript files that we included in the *Getting ready*
    section of this recipe. These JavaScript files, based on [http://typeface.neocracy.org/fonts.html](http://typeface.neocracy.org/fonts.html),
    allow you to render text as 2D paths, which we then can convert to 3D.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建 `THREE.TextGeometry` 时，Three.js内部使用 `THREE.ExtrudeGeometry` 来创建3D形状。`THREE.ExtrudeGeometry`
    通过沿 *Z* 轴拉伸2D形状来工作，使其成为3D。为了从文本字符串创建2D形状，Three.js使用我们在本配方的 *准备工作* 部分中包含的JavaScript文件。这些基于
    [http://typeface.neocracy.org/fonts.html](http://typeface.neocracy.org/fonts.html)
    的JavaScript文件允许您将文本渲染为2D路径，然后我们可以将其转换为3D。
- en: There's more…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: If you want to use a different font, you can convert your own fonts at [http://typeface.neocracy.org/fonts.html](http://typeface.neocracy.org/fonts.html).
    All you need to do to use these fonts is include them on your page and pass in
    the correct `name` and `style` values as parameters to `THREE.TextGeometry`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用不同的字体，您可以在 [http://typeface.neocracy.org/fonts.html](http://typeface.neocracy.org/fonts.html)
    转换自己的字体。要使用这些字体，您只需在您的页面上包含它们，并将正确的 `name` 和 `style` 值作为参数传递给 `THREE.TextGeometry`。
- en: Rendering 3D formulas as 3D geometries
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将3D公式作为3D几何体渲染
- en: Three.js offers many different ways to create geometries. You can use the standard
    Three.js objects, such as `THREE.BoxGeometry` and `THREE.SphereGeometry`, create
    geometries completely from scratch, or just load models created by external 3D
    modeling programs. In this recipe, we will show you another way to create geometries.
    This recipe shows you how to create geometries based on math formulas.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了许多不同的创建几何体方法。您可以使用标准的Three.js对象，如 `THREE.BoxGeometry` 和 `THREE.SphereGeometry`，从头开始创建几何体，或者只需加载由外部3D建模程序创建的模型。在这个配方中，我们将向您展示另一种创建几何体的方法。这个配方将向您展示如何根据数学公式创建几何体。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll be using the `THREE.ParametricGeometry` object. As this
    is available from the standard Three.js distribution, there is no need to include
    additional JavaScript files.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用`THREE.ParametricGeometry`对象。因为这个对象可以从标准的Three.js分发中获取，所以不需要包含额外的JavaScript文件。
- en: 'To see the end result of this recipe, you can look at `02.10-create-parametric-geometries.html`,
    you''ll see something similar to the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个配方的最终结果，你可以查看`02.10-create-parametric-geometries.html`，你会看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_02_10.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_02_10.jpg)'
- en: This figure shows you a *Gray's Kleinbottle*, which is rendered based on a couple
    of simple math formulas.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图形向你展示了*格雷的克莱因瓶*，它是基于几个简单的数学公式渲染的。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Generating geometries using math formulas with Three.js is very easy and only
    takes two steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数学公式通过Three.js生成几何形状非常简单，只需两步：
- en: 'The first thing we need to do is create the function that will create the geometry
    for us. This function will take two arguments: `u` and `v`. When Three.js uses
    this function to generate a geometry, it will call this function with `u` and
    `v` values, starting at `0` and ending at `1`. For each of these `u` and `v` combinations,
    this function should return a `THREE.Vector3` object, which represents a single
    vertex in the final geometry. The function that creates the figure you saw in
    the previous section is shown next:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个函数，这个函数将为我们创建几何形状。这个函数将接受两个参数：`u`和`v`。当Three.js使用这个函数来生成几何形状时，它将使用`u`和`v`的值调用这个函数，从`0`开始，到`1`结束。对于这些`u`和`v`的组合中的每一个，这个函数应该返回一个`THREE.Vector3`对象，它代表最终几何形状中的一个顶点。创建你在上一节中看到的图形的函数如下所示：
- en: '[PRE20]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can provide functions of your own as long as you return a new `THREE.Vector3`
    object for each value of `u` and `v`.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只要你为每个`u`和`v`的值返回一个新的`THREE.Vector3`对象，你就可以提供你自己的函数。
- en: 'Now that we''ve got the function that creates our geometry, we can use this
    function to create `THREE.ParametricGeometry`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了创建我们几何形状的函数，我们可以使用这个函数来创建`THREE.ParametricGeometry`：
- en: '[PRE21]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can clearly see that three arguments have been applied to the constructor
    of `THREE.ParametricObject`. This is discussed in more detail in the *How it works…*
    section.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到已经将三个参数传递给了`THREE.ParametricObject`的构造函数。这将在*如何工作…*部分中更详细地讨论。
- en: All you have to do after creating the geometry is create `THREE.Mesh` and add
    it to the scene just like any other Three.js object.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建几何形状之后，你只需要创建`THREE.Mesh`并将其添加到场景中，就像添加任何其他Three.js对象一样。
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: From step 2 in the preceding code snippet, you can see that we provide three
    arguments to the constructor of `THREE.ParametricObject`. The first one is the
    function we showed you in step 1, the second determines in how many steps we divide
    the `u` parameter, and the third one determines in how many steps we divide the
    `v` parameter. The higher the number, the more vertices will be created, and the
    smoother the final geometry will look. Note, though, that a very high amount of
    vertices has an adverse effect on performance.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段的第2步，你可以看到我们向`THREE.ParametricObject`的构造函数提供了三个参数。第一个是我们第1步中展示的函数，第二个决定了我们如何分割`u`参数的步数，第三个决定了我们如何分割`v`参数的步数。数字越高，创建的顶点就越多，最终的几何形状看起来就越平滑。不过，要注意，顶点数量过多会对性能产生不利影响。
- en: When you create `THREE.ParametricGeometry`, Three.js will call the provided
    function a number of times. The amount of times the function is called is based
    on the second and third parameters. This results in a set of `THREE.Vector3` objects,
    which are then automatically combined into faces. This results in a geometry that
    you can use just like any other geometry.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建`THREE.ParametricGeometry`时，Three.js将根据提供的参数调用该函数多次。函数被调用的次数基于第二个和第三个参数。这会产生一系列`THREE.Vector3`对象，然后这些对象自动组合成面。这会产生一个你可以像使用任何其他几何形状一样使用的几何形状。
- en: There's more…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'There are many different things you can do with these kinds of geometries than
    what is shown in this recipe. In the `02.10-create-parametric-geometries.html`
    source file, you can find a couple of other functions that create interesting-looking
    geometries such as the one shown in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个配方中展示的不同，你可以用这些类型的几何形状做很多事情。在`02.10-create-parametric-geometries.html`源文件中，你可以找到一些其他函数，这些函数可以创建看起来有趣的几何形状，如下面的截图所示：
- en: '![There''s more…](img/1182OS_02_11.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/1182OS_02_11.jpg)'
- en: Extending Three.js with a custom geometry object
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Three.js通过自定义几何对象扩展Three.js
- en: In the recipes you've seen so far, we create Three.js objects from scratch.
    We either build a new geometry from scratch with vertices and faces, or we reuse
    an existing one and configure it for our purpose. While this is good enough for
    most scenarios, it isn't the best solution when you need to maintain a large code
    base with lots of different geometries. In Three.js, you create geometries by
    just instantiating a `THREE.GeometryName` object. In this recipe, we'll show you
    how you can create a custom geometry object and instantiate it just like the other
    Three.js objects.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在你迄今为止看到的菜谱中，我们从头开始创建Three.js对象。我们或者从头开始使用顶点和面构建一个新的几何体，或者重用现有的一个并为其配置。虽然这对于大多数场景来说已经足够好了，但当需要维护一个包含大量不同几何体的庞大代码库时，这并不是最佳解决方案。在Three.js中，你通过实例化一个`THREE.GeometryName`对象来创建几何体。在这个菜谱中，我们将向你展示如何创建一个自定义几何体对象，并像其他Three.js对象一样实例化它。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The example that you can use to experiment with this recipe can be found in
    the provided sources. Open up `02.11-extend-threejs-with-custom-geometry.html`
    in your browser to see the final result, which will be similar to the following
    screenshot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用提供的源代码来实验这个菜谱的示例。在你的浏览器中打开`02.11-extend-threejs-with-custom-geometry.html`，查看最终结果，它将类似于以下屏幕截图：
- en: '![Getting ready](img/1182OS_02_12.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_02_12.jpg)'
- en: In this screenshot, you see a single rotating cube. This cube is created as
    a custom geometry and can be instantiated by using new `THREE.FixedBoxGeometry()`.
    In the upcoming section, we'll explain how to accomplish this.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，你可以看到一个单独旋转的立方体。这个立方体是一个自定义几何体，可以通过使用新的`THREE.FixedBoxGeometry()`来实例化。在接下来的部分中，我们将解释如何实现这一点。
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Extending Three.js with a custom geometry is fairly easy and only takes a couple
    of simple steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义几何体扩展Three.js相对简单，只需几个简单的步骤：
- en: 'The first thing we need to do is create a new JavaScript object that contains
    the logic and properties of our new Three.js geometry. For this recipe, we''ll
    create `FixedBoxGeometry`, which acts exactly like `THREE.BoxGeometry` but uses
    the same values for its height, width, and depth. For this recipe, we create this
    new object in the `setupCustomObject` function:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个新的JavaScript对象，它包含我们新的Three.js几何体的逻辑和属性。对于这个菜谱，我们将创建`FixedBoxGeometry`，它的工作方式与`THREE.BoxGeometry`完全相同，但使用相同的高度、宽度和深度值。在这个菜谱中，我们在`setupCustomObject`函数中创建这个新对象：
- en: '[PRE22]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this function, we define a new JavaScript object using `THREE.FixedBoxGeometry
    = function ( width, segments) {..}`. In this function, we first call the constructor
    of the parent object (`THREE.Geometry.call( this )`). This makes sure that all
    properties are correctly initialized. Next, we wrap an existing `THREE.BoxGeometry`
    object and use information from that object to set `vertices`, `faces`, and `faceVertexUvs`
    for our own custom object.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用`THREE.FixedBoxGeometry = function ( width, segments) {..}`定义了一个新的JavaScript对象。在这个函数中，我们首先调用父对象的构造函数（`THREE.Geometry.call(
    this )`）。这确保了所有属性都正确初始化。接下来，我们包装一个现有的`THREE.BoxGeometry`对象，并使用该对象的信息来设置我们自定义对象的`vertices`、`faces`和`faceVertexUvs`。
- en: Finally, we need to tell JavaScript that our `THREE.BoxGeometry` object extends
    from `THREE.Geometry`. This is done by setting a prototype property of `THREE.FixedBoxGeometry`
    to `Object.create(THREE.Geometry.prototype)`.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们需要告诉JavaScript我们的`THREE.BoxGeometry`对象继承自`THREE.Geometry`。这是通过将`THREE.FixedBoxGeometry`的原型属性设置为`Object.create(THREE.Geometry.prototype)`来实现的。
- en: 'After `setupCustomObject()` is called, we can now use the same approach to
    create this object like we do for the other Three.js-provided geometries:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`setupCustomObject()`之后，我们现在可以使用相同的方法来创建这个对象，就像我们为其他Three.js提供的几何体所做的那样：
- en: '[PRE23]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At this point, we've created a custom Three.js geometry that you can instantiate
    just like the standard geometries provided by Three.js.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经创建了一个自定义的Three.js几何体，你可以像Three.js提供的标准几何体一样实例化它。
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we use one of the standard ways JavaScript provides to create
    objects that inherit from other objects. We defined the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了JavaScript提供的一种标准方式来创建继承自其他对象的对象。我们定义了以下内容：
- en: '[PRE24]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code fragment tells JavaScript that `THREE.FixedBoxGeometry` is created,
    it inherits all the properties and functions from `THREE.Geometry`, which has
    its own constructor. This is the reason we also add the following call to our
    new object:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段告诉JavaScript `THREE.FixedBoxGeometry`被创建，它继承自`THREE.Geometry`的所有属性和函数，它有自己的构造函数。这也是为什么我们也在我们的新对象中添加了以下调用：
- en: '[PRE25]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This calls the constructor of the `THREE.Geometry` object whenever our own custom
    object is created.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在创建我们自己的自定义对象时调用 `THREE.Geometry` 对象的构造函数。
- en: There is more to prototype-based inheritance than what's explained in this short
    recipe. If you want to know more about prototype-based inheritance, the Mozilla
    guys have a great explanation on how inheritance using the prototype property
    works at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 原型继承比这个简短的菜谱中解释的还要多。如果你想了解更多关于原型继承的信息，Mozilla 团队有一个很好的解释，说明了如何使用原型属性进行继承，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain)。
- en: There's more...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we've wrapped an existing Three.js object to create our custom
    object. You can also apply this same approach for objects that are created completely
    from scratch. For instance, you can create `THREE.TerrainGeometry` from the JavaScript
    code we used in the *Creating geometries from heightmaps* recipe to create a 3D
    terrain.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们封装了一个现有的 Three.js 对象来创建我们的自定义对象。你也可以将这种方法应用于完全从头创建的对象。例如，你可以从我们在 *从高度图创建几何体*
    菜谱中使用的 JavaScript 代码创建 `THREE.TerrainGeometry` 来创建一个 3D 地形。
- en: Creating a spline curve between two points
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在两点之间创建样条曲线
- en: When you create visualizations and, for instance, want to visualize the flight
    path of an airplane, drawing a curve between the start and end point is a good
    approach. In this recipe, we'll show you how you can do this using the standard
    `THREE.TubeGeometry` object.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建可视化效果，例如，想要可视化飞机的飞行路径时，在起点和终点之间绘制曲线是一种很好的方法。在这个菜谱中，我们将向你展示如何使用标准的 `THREE.TubeGeometry`
    对象来完成这个操作。
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'When you open the example for this recipe, `02.12-create-spline-curve.html`,
    you can see a tube geometry that curves from start to end:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开这个菜谱的示例 `02.12-create-spline-curve.html` 时，你可以看到一个从起点到终点的曲线管几何形状：
- en: '![Getting ready](img/1182OS_02_13.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_02_13.jpg)'
- en: In the upcoming section, we'll explain step by step how to create this curve.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将逐步解释如何创建这条曲线。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a curved spline, like what is shown in the preceding example, we
    need to take a couple of simple steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个像前面示例中显示的弯曲样条曲线，我们需要采取几个简单的步骤：
- en: 'The first thing we need to do is define some constants for this curve:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为这条曲线定义一些常数：
- en: '[PRE26]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `numPoints` object defines how many vertices we'll use to define the curve
    and the number of segments we use when rendering the tube. The `start` vector
    defines the position where we want to start the curve, the `end` vector determines
    the end point of our curve, and finally, the `middle` vector defines the height
    and center point of our curve. If we, for instance, set `numPoints` to `5`, we
    get a different kind of curve.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`numPoints` 对象定义了我们用来定义曲线的顶点数量以及渲染管时使用的段数。`start` 向量定义了我们想要开始曲线的位置，`end` 向量决定了曲线的终点，最后，`middle`
    向量定义了曲线的高度和中心点。如果我们，例如，将 `numPoints` 设置为 `5`，我们将得到不同类型的曲线。'
- en: '![How to do it...](img/1182OS_02_14.jpg)'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1182OS_02_14.jpg)'
- en: 'Now that we''ve got the `start`, `end`, and `middle` vectors, we can use them
    to create a nice curve. For this, we can use an object provided by Three.js, called
    `THREE.QuadraticBezierCurve3`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了 `start`、`end` 和 `middle` 向量，我们可以使用它们来创建一个漂亮的曲线。为此，我们可以使用 Three.js
    提供的一个对象，称为 `THREE.QuadraticBezierCurve3`：
- en: '[PRE27]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Based on this `curveQuad`, we can now create a simple tube geometry.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于这个 `curveQuad`，我们现在可以创建一个简单的管几何体。
- en: 'To create a tube, we use `THREE.TubeGeometry` and pass in `curveQuad`, which
    we created in the previous step:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个管，我们使用 `THREE.TubeGeometry` 并传入 `curveQuad`，这是我们上一步创建的：
- en: '[PRE28]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `QuadraticBezierCurve3` object we created in this recipe has a number of
    different functions (`getTangentAt` and `getPointAt`) that determine the location
    somewhere along the path. These functions return information based on the `start`,
    `middle`, and `end` vectors passed in to the constructor. When we pass `QuadraticBezierCurve3`
    into `THREE.TubeGeometry`, `THREE.TubeGeometry` uses the `getTangentAt` function
    to determine where to position its vertices.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中我们创建的`QuadraticBezierCurve3`对象具有多个不同的函数（`getTangentAt`和`getPointAt`），这些函数决定了路径上的某个位置。这些函数根据传递给构造函数的`start`、`middle`和`end`向量返回信息。当我们把`QuadraticBezierCurve3`传递给`THREE.TubeGeometry`时，`THREE.TubeGeometry`使用`getTangentAt`函数来确定其顶点的位置。
- en: There's more…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this recipe, we used `THREE.QuadraticBezierCurve3` to create our spline.
    Three.js also provides a `THREE.CubicBezierCurve3` and `THREE.SplineCurve3` curve,
    which you can use to define these kinds of splines. You can find more information
    on the differences between a quadratic Bezier curve and a cubic Bezier curve at
    [http://stackoverflow.com/questions/18814022/what-is-the-difference-between-cubic-bezier-and-quadratic-bezier-and-their-use-c](http://stackoverflow.com/questions/18814022/what-is-the-difference-between-cubic-bezier-and-quadratic-bezier-and-their-use-c).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了`THREE.QuadraticBezierCurve3`来创建我们的样条。Three.js还提供了`THREE.CubicBezierCurve3`和`THREE.SplineCurve3`曲线，你可以使用这些曲线来定义这类样条。你可以在[http://stackoverflow.com/questions/18814022/what-is-the-difference-between-cubic-bezier-and-quadratic-bezier-and-their-use-c](http://stackoverflow.com/questions/18814022/what-is-the-difference-between-cubic-bezier-and-quadratic-bezier-and-their-use-c)上找到关于二次贝塞尔曲线和三次贝塞尔曲线之间差异的更多信息。
- en: Creating and exporting a model from Blender
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Blender创建和导出模型
- en: Blender, which you can download from [http://www.blender.org/download/](http://www.blender.org/download/),
    is a great tool to create 3D models and has excellent support for Three.js. With
    the right plugin, Blender can export models directly into Three.js' own JSON format,
    which can then easily be added to your scene.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://www.blender.org/download/](http://www.blender.org/download/)下载Blender，这是一个创建3D模型的优秀工具，并且对Three.js有很好的支持。有了合适的插件，Blender可以直接导出模型到Three.js的JSON格式，然后可以轻松地将其添加到场景中。
- en: Getting ready
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Before we can use the JSON exporter in Blender, we first need to install the
    plugin in Blender. To install the plugin, take the following steps:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用Blender中的JSON导出器之前，我们首先需要在Blender中安装这个插件。要安装插件，请按照以下步骤操作：
- en: The first thing you need to do is get the latest version of the plugin. We've
    added this to the source code of this book. You can find this plugin in the `assets/plugin`
    folder. In that directory, you'll find a single directory with the `io_mesh_threejs`
    name. To install the plugin, just copy this complete directory to the plugin location
    of Blender. As Blender is multiplatform, depending on your OS, this plugin directory
    might be stored in a different location.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是获取插件的最新版本。我们已经将它添加到本书的源代码中。你可以在`assets/plugin`文件夹中找到这个插件。在那个目录中，你会找到一个名为`io_mesh_threejs`的单个目录。要安装插件，只需将这个完整的目录复制到Blender的插件位置。由于Blender是跨平台的，根据你的操作系统，这个插件目录可能存储在不同的位置。
- en: For Windows, copy the `io_mesh_threejs` directory to `C:\Users\USERNAME\AppData\Roaming\Blender
    Foundation\Blender\2.70a\scripts\addons`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Windows系统，将`io_mesh_threejs`目录复制到`C:\Users\USERNAME\AppData\Roaming\Blender
    Foundation\Blender\2.70a\scripts\addons`。
- en: For OS X users, it depends on where you installed Blender (extracted the ZIP
    file). You should copy the `io_mesh_threejs` directory to `/location/of/extracted/zip/blender.app/Contents/MacOS/2.6X/scripts/addons`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于OS X用户，这取决于你安装Blender的位置（解压ZIP文件）。你应该将`io_mesh_threejs`目录复制到`/location/of/extracted/zip/blender.app/Contents/MacOS/2.6X/scripts/addons`。
- en: Finally, for Linux users, copy the `io_mesh_threejs` directory to `/home/USERNAME/.config/blender/2.70a/scripts/addons`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于Linux用户，将`io_mesh_threejs`目录复制到`/home/USERNAME/.config/blender/2.70a/scripts/addons`。
- en: If you've installed Blender through apt-get, you should copy the `io_mesh_threejs`
    directory to `/usr/lib/blender/scripts/addons`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你通过apt-get安装了Blender，你应该将`io_mesh_threejs`目录复制到`/usr/lib/blender/scripts/addons`。
- en: The next step is to enable the Three.js plugin. If Blender is already running,
    restart it and open **User Preferences**. You can find this by navigating to **File**
    | **User Preferences**. In the screen that opens, select the **Addons** tab, which
    lists all the plugins that are available.![Getting ready](img/1182OS_02_15.jpg)
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是启用Three.js插件。如果Blender已经运行，请重新启动它并打开**用户首选项**。你可以通过导航到**文件** | **用户首选项**来找到它。在打开的屏幕上，选择**插件**标签页，其中列出了所有可用的插件。![准备中](img/1182OS_02_15.jpg)
- en: At this point, the Three.js plugin is enabled. To make sure it stays enabled
    when you restart Blender, click on the **Save User Settings** button. Now, close
    this window and if you navigate to **File** | **Export**, you should see a Three.js
    export function as shown in the following screenshot:![Getting ready](img/1182OS_02_16.jpg)
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，Three.js插件已启用。为了确保在您重新启动Blender时它保持启用状态，请点击**保存用户设置**按钮。现在，关闭此窗口，如果您导航到**文件**
    | **导出**，您应该会看到一个Three.js导出功能，如下面的截图所示：![准备就绪](img/1182OS_02_16.jpg)
- en: Now, let's look at the rest of this recipe and see how we can export a model
    from Blender and load it in Three.js.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个配方的其余部分，看看我们如何从Blender导出一个模型并在Three.js中加载它。
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To export a model from Blender, we first have to create one. Instead of loading
    an existing one, in this recipe, we''ll create one from scratch, export it, and
    load it in Three.js:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Blender导出一个模型，我们首先必须创建一个。在本配方中，我们不会加载现有的一个，而是从头开始创建，导出，并在Three.js中加载它：
- en: To start off, when you open Blender, you'll see a cube. First, we delete this
    cube. You do this by pressing *x* and clicking on delete in the pop up.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，当您打开Blender时，您会看到一个立方体。首先，我们删除这个立方体。您可以通过按*x*并点击弹出窗口中的删除来完成此操作。
- en: Now, we'll create a simple geometry that we can export with the Three.js plugin
    we installed. For this, click on **Add** in the bottom menu and select **Monkey**,
    as shown in the following screenshot:![How to do it...](img/1182OS_02_17.jpg)
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的几何体，我们可以使用我们安装的Three.js插件将其导出。为此，在底部菜单中点击**添加**，然后选择**猴子**，如下面的截图所示：![如何做...](img/1182OS_02_17.jpg)
- en: 'Now, you should have an empty scene in Blender with monkey geometry in the
    middle:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您应该有一个在Blender中中间有猴子几何体的空场景：
- en: '![How to do it...](img/1182OS_02_18.jpg)'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/1182OS_02_18.jpg)'
- en: We can export this monkey to Three.js using the plugin we installed in the *Getting
    ready* section of this recipe. To do this, navigate to **Export** | **Three.js**
    in the **File** menu. This opens up the export dialog where you can determine
    the directory to export the model to. In this **Export** dialog, you can also
    set some additional Three.js-specific export properties, but the default properties
    usually are okay. For this recipe, we exported the model as `monkey.js`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用本配方*准备就绪*部分中安装的插件将这只猴子导出到Three.js。为此，在**文件**菜单中导航到**导出** | **Three.js**。这会打开导出对话框，您可以在其中确定将模型导出到的目录。在这个**导出**对话框中，您还可以设置一些额外的Three.js特定导出属性，但默认属性通常是可以接受的。对于这个配方，我们将模型导出为`monkey.js`。
- en: 'At this point, we''ve exported the model and can now load it with Three.js.
    To load the model, we only have to add the following JavaScript to the *Getting
    started with the WebGL renderer* recipe we showed in [Chapter 1](ch01.html "Chapter 1. Getting
    Started"), *Getting Started*:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经导出了模型，现在可以使用Three.js加载它。要加载模型，我们只需在我们在[第1章](ch01.html "第1章。入门")中展示的*使用WebGL渲染器入门*配方中添加以下JavaScript即可：
- en: '[PRE29]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result is a rotating monkey, which we created in Blender, rendered by Three.js
    as shown in the following screenshot:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个旋转的猴子，这是我们使用Blender创建的，由Three.js渲染，如下面的截图所示：
- en: '![How to do it...](img/1182OS_02_19.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1182OS_02_19.jpg)'
- en: See also
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'There are a few recipes that you will benefit from reading:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个配方您会从中受益阅读：
- en: In the *Using OBJMTLLoader with multiple materials* recipe, we use a different
    format, which we load into Three.js
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用OBJMTLLoader与多个材质*配方中，我们使用不同的格式，将其加载到Three.js中
- en: In [Chapter 7](ch07.html "Chapter 7. Animation and Physics"), *Animation and
    Physics*, where we look at animations, we'll revisit the Three.js exporter plugin
    when we're working with skeleton-based animations in the *Animating with skeletons*
    recipe.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。动画与物理")中，我们探讨了*动画与物理*，其中我们查看动画，当我们使用*使用骨骼动画*配方中的骨骼动画时，我们将重新访问Three.js导出插件。
- en: Using OBJMTLLoader with multiple materials
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OBJMTLLoader与多个材质
- en: 'Three.js provides a number of standard geometries that you can use to create
    your 3D scenes. Complex models, however, are more easily created in dedicated
    3D modeling applications such as Blender or 3ds Max. Luckily, though, Three.js
    has great support for a large number of export formats, so you can easily load
    models created in these kinds of packages. A standard that is widely supported
    is the `OBJ` format. With this format, the model is described with two different
    files: an `.obj` file that defines the geometries and an `.mtl` file that defines
    the material. In this recipe, we''ll show you the steps you need to take to successfully
    load a model using `OBJMTLLoader`, which is provided by Three.js.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了一些标准几何体，您可以使用它们来创建3D场景。然而，复杂的模型在专门的3D建模应用程序（如Blender或3ds Max）中创建更为容易。幸运的是，尽管如此，Three.js对大量导出格式提供了很好的支持，因此您可以轻松加载在这些包中创建的模型。广泛支持的标准是`OBJ`格式。使用这种格式，模型由两个不同的文件描述：一个定义几何体的`.obj`文件和一个定义材质的`.mtl`文件。在本教程中，我们将向您展示使用Three.js提供的`OBJMTLLoader`成功加载模型所需的步骤。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To load models described in the `.obj` and `.mtl` format, we need to first
    include the correct JavaScript file, as these JavaScript objects aren''t included
    in the standard Three.js JavaScript file. So, within the head section, you need
    to add the following script tags:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载`.obj`和`.mtl`格式的模型，我们首先需要包含正确的JavaScript文件，因为这些JavaScript对象不包括在标准的Three.js
    JavaScript文件中。因此，在head部分，您需要添加以下脚本标签：
- en: '[PRE30]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The model we use in this example is a Lego mini figure. In Blender, the original
    model looks like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用的模型是乐高迷你人偶。在Blender中，原始模型看起来是这样的：
- en: '![Getting ready](img/1182OS_02_20.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_02_20.jpg)'
- en: 'You can see the final model by opening up `02.14-use-objmtlloader-with-multiple-materials.html`
    in your browser. The following screenshot shows you what the renderer model looks
    like:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在浏览器中打开`02.14-use-objmtlloader-with-multiple-materials.html`来查看最终的模型。以下截图显示了渲染器模型的外观：
- en: '![Getting ready](img/1182OS_02_21.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_02_21.jpg)'
- en: Let's walk you through the steps you need to take to load such a model.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步指导您如何加载这样的模型。
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Before we load the model in Three.js, we first need to check whether the correct
    paths are defined in the `.mtl` file. So, the first thing we need to do is open
    the `.mtl` file in a text editor:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将模型加载到Three.js之前，我们首先需要检查`.mtl`文件中是否定义了正确的路径。因此，我们首先需要做的是在文本编辑器中打开`.mtl`文件：
- en: 'When you open the `.mtl` file for this example, you''ll see the following:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您打开本例的`.mtl`文件时，您会看到以下内容：
- en: '[PRE31]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This `.mtl` file defines two materials: one for the body of the mini figure
    and one for its cap. What we need to check is the `map_Kd` property. This property
    needs to contain the relative path, from where the `.obj` file is loaded to where
    Three.js can find the textures. In our example, this path is: `.../textures/Mini-tex.png`.'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`.mtl`文件定义了两种材质：一种用于迷你人偶的身体，另一种用于其帽子。我们需要检查的是`map_Kd`属性。这个属性需要包含从`.obj`文件加载的相对路径到Three.js可以找到纹理的位置。在我们的例子中，这个路径是：`.../textures/Mini-tex.png`。
- en: 'Now that we''ve made sure the `.mtl` file contains the correct references,
    we can load the model using `THREE.OBJMTLLoader`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`.mtl`文件包含正确的引用后，我们可以使用`THREE.OBJMTLLoader`加载模型：
- en: '[PRE32]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we pass both `.obj` and `.mtl` files into the `load` function.
    The final argument of this `load` function is a `callback` function. This `callback`
    function will be called when the model is done loading.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们将`.obj`和`.mtl`文件都传递给了`load`函数。这个`load`函数的最后一个参数是一个`callback`函数。当模型加载完成时，这个`callback`函数将被调用。
- en: 'At this point, you can do everything you want with the loaded model. In this
    example, we add the scaling and rotation functionality through the menu in the
    top-right section and apply these properties to the `render` function:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到这一步，您可以对加载的模型做任何您想做的事情。在本例中，我们通过右上角的菜单添加了缩放和旋转功能，并将这些属性应用到`render`函数中：
- en: '[PRE33]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `.obj` and `.mtl` file formats are well-documented formats. `OBJMTLLoader`
    parses the information from these two files and creates geometries and materials
    based on that information. It uses the `.obj` file to determine an object's geometry
    and uses information from the `.mtl` file to determine the material, which is
    `THREE.MeshLambertMaterial` in this case, to be used for each geometry.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`.obj` 和 `.mtl` 文件格式是经过良好记录的格式。`OBJMTLLoader` 解析这两个文件中的信息，并根据该信息创建几何体和材质。它使用
    `.obj` 文件来确定对象的几何形状，并使用 `.mtl` 文件中的信息来确定材质，在这个例子中是 `THREE.MeshLambertMaterial`，用于每个几何体。'
- en: Three.js then combines these together into `THREE.Mesh` objects and returns
    a single `THREE.Object3D` object that contains all the parts of the `Lego` figure,
    which you can then add to the scene.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 然后将这些组合成 `THREE.Mesh` 对象，并返回一个包含 `Lego` 图形所有部分的单个 `THREE.Object3D`
    对象，您可以将它添加到场景中。
- en: There's more…
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In this recipe, we showed you how to load objects defined in the `.obj` and
    `.mtl` format. Besides this format, Three.js also supports a wide range of other
    formats. For a good overview of the file formats supported by Three.js, refer
    to this directory on Three.js'' GitHub repository: [https://github.com/mrdoob/three.js/tree/master/examples/js/loaders](https://github.com/mrdoob/three.js/tree/master/examples/js/loaders).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们向您展示了如何加载定义在 `.obj` 和 `.mtl` 格式的对象。除了这种格式，Three.js 还支持广泛的其他格式。有关 Three.js
    支持的文件格式的良好概述，请参阅 Three.js GitHub 存储库中的此目录：[https://github.com/mrdoob/three.js/tree/master/examples/js/loaders](https://github.com/mrdoob/three.js/tree/master/examples/js/loaders)。
- en: See also
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For this recipe, we assume we have a complete model in the correct format. If
    you want to create a model from scratch, a good open source 3D modeling tool is
    Blender. The the *Creating and Exporting a model from a Blender* recipe, explains
    how to create a new model in Blender and export it so that Three.js can load it.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们假设我们有一个完整且格式正确的模型。如果您想从头开始创建模型，一个很好的开源 3D 建模工具是 Blender。在 *从 Blender
    创建和导出模型* 菜谱中，解释了如何在 Blender 中创建新模型并将其导出，以便 Three.js 可以加载它。
- en: Applying matrix transformations
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用矩阵变换
- en: In the first couple of recipes in this chapter, we used the `rotation` property
    and applied translations to get the desired rotational effect. Behind the scenes,
    Three.js uses matrix transformations to modify the shape and position of the mesh
    or the geometry. Three.js also provides the functionality to apply custom matrix
    transformations directly to a geometry or a mesh. In this recipe, we'll show you
    how you can apply your own custom matrix transformations directly to a Three.js
    object.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几个菜谱中，我们使用了 `rotation` 属性并应用平移以获得所需的旋转效果。幕后，Three.js 使用矩阵变换来修改网格或几何体的形状和位置。Three.js
    还提供了将自定义矩阵变换直接应用于几何体或网格的功能。在这个菜谱中，我们将向您展示如何将您自己的自定义矩阵变换直接应用于 Three.js 对象。
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To view this recipe in action and experiment with the various transformations,
    open the `02.15-apply-matrix-transformations.html` example in your browser. You''ll
    be presented with the following simple Three.js scene:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此菜谱的实际操作并实验各种变换，请在您的浏览器中打开 `02.15-apply-matrix-transformations.html` 示例。您将看到一个简单的
    Three.js 场景：
- en: '![Getting ready](img/1182OS_02_22.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_02_22.jpg)'
- en: In this scene, you can use the menu on the right-hand side to apply various
    transformations directly to the spinning cube. In the next section, we'll show
    you the steps you need to take to create this yourself.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，您可以使用右侧的菜单直接将各种变换应用于旋转的立方体。在下一节中，我们将向您展示创建此变换所需的步骤。
- en: How to do it...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Creating your own matrix transformation is very simple.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的矩阵变换非常简单。
- en: 'Firstly, let''s look at the code that gets called when you click on the **doTranslation**
    button:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看当您点击 **doTranslation** 按钮时调用的代码：
- en: '[PRE34]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see in the code, creating a custom matrix transformation is very
    easy and requires only the following steps.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您在代码中所见，创建自定义矩阵变换非常简单，只需要以下步骤。
- en: First, you instantiate a new `THREE.Matrix4` object and pass in the values of
    the matrix as arguments to the constructor.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您实例化一个新的 `THREE.Matrix4` 对象，并将矩阵的值作为参数传递给构造函数。
- en: Next, you use the `applyMatrix` function of either `THREE.Mesh` or `THREE.Geometry`
    to apply the transformation to that specific object.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您使用 `THREE.Mesh` 或 `THREE.Geometry` 的 `applyMatrix` 函数将该变换应用于特定对象。
- en: If you apply this on `THREE.Geometry` you have to set the `verticesNeedUpdate`
    property to `true`, as vertex changes aren't automatically propagated to the renderer
    (see the *Informing Three.js about updates* recipe).
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将此应用于 `THREE.Geometry`，你必须将 `verticesNeedUpdate` 属性设置为 `true`，因为顶点变化不会自动传播到渲染器（参见
    *通知 Three.js 关于更新* 菜谱）。
- en: How it works
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The transformations used in this recipe are based on matrix calculations. Matrix
    calculations by themselves are a rather complex subject. If you're interested
    in more information on how matrix calculations work and how they can be used for
    all different kinds of transformations, a good explanation can be found at [http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices](http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中使用的变换基于矩阵计算。矩阵计算本身是一个相当复杂的话题。如果你对矩阵计算的工作原理以及它们如何用于所有不同类型的变换感兴趣，可以在 [http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices](http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices)
    找到很好的解释。
- en: There's more…
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In the example for this chapter, you can apply a couple of transformations
    to the rotating cube. The following code snippet shows you the matrices used for
    these transformations:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，你可以对旋转的立方体应用几个变换。以下代码片段显示了这些变换所使用的矩阵：
- en: '[PRE35]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this recipe, we created the matrix transformations from scratch. Three.js,
    however, also provides some helper functions in the `Three.Matrix4` class that
    you can use to more easily create these kinds of matrices:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们从头开始创建了矩阵变换。然而，Three.js 也提供了 `Three.Matrix4` 类中的一些辅助函数，你可以使用这些函数更轻松地创建这类矩阵：
- en: '`makeTranslation(x, y, z)`: This function returns a matrix, which when applied
    to a geometry or a mesh, translates the object by the specified x, y, and z values'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeTranslation(x, y, z)`: 这个函数返回一个矩阵，当应用于几何体或网格时，通过指定的 x、y 和 z 值平移对象'
- en: '`makeRotationX(theta)`: This returns a matrix that can be used to rotate a
    mesh or geometry by a certain amount of radians along the *x* axis'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeRotationX(theta)`: 这个函数返回一个矩阵，可以用来绕 *x* 轴旋转网格或几何体一定量的弧度'
- en: '`makeRotationY(theta)`: This is the same as the previous one—this time around
    the *y* axis'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeRotationY(theta)`: 这与上一个函数相同——这次是绕 *y* 轴旋转'
- en: '`makeRotationZ(theta)`: This is the same as the previous one—this time around
    the *z* axis'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeRotationZ(theta)`: 这与上一个函数相同——这次是绕 *z* 轴旋转'
- en: '`makeRotationAxis(axis, angle)`: This returns a rotation matrix based on the
    provided axis and angle'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeRotationAxis(axis, angle)`: 这个函数返回一个基于提供的轴和角度的旋转矩阵'
- en: '`makeScale(x, y, z)`: This function returns a matrix that can be used to scale
    an object along any of the three axes'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeScale(x, y, z)`: 这个函数返回一个矩阵，可以用来沿任意三个轴缩放对象'
- en: See also
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'We''ve also used matrix transformations in other recipes in this chapter:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在本章的其他菜谱中使用了矩阵变换：
- en: In the first two recipes, *Rotating an object around its own axis* and *Rotating
    an object around a point in space*, the actual rotation is applied using a matrix
    transformation
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前两个菜谱中，*绕对象自身的轴旋转* 和 *绕空间中的点旋转对象*，实际的旋转是通过矩阵变换来应用的
- en: In the *Rotating an object around its own axis* recipe, we used the helper functions
    from the `THREE.Matrix4` object to rotate an object around its axis
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *绕对象自身的轴旋转* 菜谱中，我们使用了 `THREE.Matrix4` 对象的辅助函数来绕对象的轴旋转对象
