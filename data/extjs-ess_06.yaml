- en: Chapter 6. Combining UI Widgets into the Perfect Layout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。将UI小部件组合成完美的布局
- en: Layouts are fundamental to the appearance and usability of your application.
    UI widgets can be combined, and arranged, in any number of different configurations
    to create simple and complex application layouts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 布局对于您应用程序的外观和可用性至关重要。UI小部件可以组合和排列成无数种不同的配置，以创建简单和复杂的应用程序布局。
- en: An Ext JS widget requires a layout to manage its sizing and positioning on the
    screen. The framework has a large number of different layouts, which provide simple
    configurations and flexibility to produce applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS小部件需要一个布局来管理其在屏幕上的尺寸和位置。该框架提供了大量的不同布局，这些布局提供了简单的配置和灵活性，以生成应用程序。
- en: 'This chapter will cover the most common topics relating to layouts. These are
    as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖与布局最常见的话题。具体如下：
- en: How components fit together in layouts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件如何在布局中配合
- en: 'Examples and explanations of working with the most common layouts, namely:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对最常见布局的示例和解释，即：
- en: The border layout
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界布局
- en: The fit layout
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应布局
- en: HBox and VBox layouts
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HBox和VBox布局
- en: How to design layouts that are responsive to the user's screen size
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计对用户屏幕尺寸做出响应的布局
- en: Layouts and how they work
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局及其工作方式
- en: In Ext JS, containers have layouts that manage the sizing and positioning of
    their child components. Traditionally, a developer would apply a combination of
    CSS rules to the elements in the DOM to build the desired screen layout. Ext JS
    takes care of most of this for us, by allowing us to define a layout configuration
    in our container/component and configure the sizing and positioning with JavaScript.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS中，容器具有布局来管理其子组件的尺寸和位置。传统上，开发者会将对DOM元素应用一组CSS规则来构建所需的屏幕布局。Ext JS通过允许我们在容器/组件中定义布局配置，并使用JavaScript配置尺寸和位置来为我们处理大部分工作。
- en: By default, a container is configured with an Auto layout, which makes child
    components flow naturally at full width in much the same way DIVs do in a regular
    HTML page.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器配置了自动布局，这使得子组件在全宽范围内自然流动，与常规HTML页面中的DIV元素非常相似。
- en: The following is a list of layouts that are provided by the framework. It is
    possible, and common, to combine a number of layouts together; this is so that
    child containers or components are positioned and sized appropriately. For example,
    a tab panel (card layout) has multiple child containers, of which each may have
    different layouts. Each of these layouts has different configuration options to
    control how your app renders. By default, the Ext JS UI widgets have component
    layouts configured, which you may need to be aware of.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由框架提供的布局列表。将多个布局组合在一起是可能的，也是常见的；这样可以使子容器或组件适当地定位和调整大小。例如，标签面板（卡片布局）有多个子容器，其中每个容器可能具有不同的布局。每个布局都有不同的配置选项来控制您的应用程序如何渲染。默认情况下，Ext
    JS UI小部件已配置了组件布局，您可能需要了解这一点。
- en: '**Absolute**: Using *X* and *Y* coordinates, the absolute layout fixes the
    position of the container on screen. Overlapping is possible with this layout.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绝对布局**：使用 *X* 和 *Y* 坐标，绝对布局固定容器在屏幕上的位置。此布局允许重叠。'
- en: '**Accordion**: The accordion layout provides the ability to create an accordion
    stack of panels on screen.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手风琴布局**：手风琴布局提供在屏幕上创建手风琴式面板堆叠的能力。'
- en: '**Anchor**: This is a layout that enables anchoring of contained elements relative
    to the container''s dimensions.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锚点布局**：这是一种布局，允许将包含的元素相对于容器的尺寸进行锚定。'
- en: '**Border**: The border layout enables you to attach containers to the border
    of a central region giving you a north, south, east, and west region. This layout
    has built-in behavior for collapsing and resizing regions.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界布局**：边界布局允许您将容器附加到中央区域的边界，从而提供北、南、东和西区域。此布局具有内置的区域折叠和调整大小的行为。'
- en: '**Card**: A card layout provides a stack of containers that can be moved back
    and forth. A card layout is ideal for a wizard-style component or tabbed components.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卡片布局**：卡片布局提供一组可以前后移动的容器。卡片布局非常适合用于向导式组件或标签式组件。'
- en: '**Center**: The contents of a center layout are centered within their container.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**居中布局**：居中布局的内容在其容器内居中。'
- en: '**Column**: A column layout is ideal for presenting your interface in multiple
    columns.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列布局**：列布局非常适合以多列形式展示您的界面。'
- en: '**Fit**: A very common layout, the fit layout stretches the widget to the size
    and position of the parent container. You can only have one item in a fit layout.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fit**: 这是一个非常常见的布局，fit布局将小部件拉伸到父容器的大小和位置。fit布局中只能有一个项目。'
- en: '**HBox**: Much like the column layout, this layout presents components horizontally.
    It has some useful configurations to stretch and position child components.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HBox**: 与列布局类似，这种布局将组件水平排列。它提供了一些有用的配置来拉伸和定位子组件。'
- en: '**VBox**: Much like the HBox layout, this layout presents components vertically,
    one below the other. It has some useful configurations to stretch and position
    child components.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VBox**: 与HBox布局类似，这种布局将组件垂直排列，一个接一个。它提供了一些有用的配置来拉伸和定位子组件。'
- en: '**Table**: While tables are less popular with developers, a table layout can
    still be useful. The content in a table layout will be rendered as an HTML table.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Table**: 尽管表格在开发者中不太受欢迎，但表格布局仍然可能很有用。表格布局中的内容将被渲染为HTML表格。'
- en: How the layout system works
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局系统的工作原理
- en: As we know, it's the layout that's responsible for the sizing and positioning
    of your container's children. Correctly rendering the screen requires that all
    child components have their sizes and positions calculated so that the DOM can
    be updated. The framework does this with the `updateLayout` method. This method
    recurses fully through all child components and calculates the appropriate positions
    and sizes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，布局负责容器子组件的大小和位置。正确渲染屏幕需要所有子组件的大小和位置都被计算出来，以便更新DOM。框架通过`updateLayout`方法来完成这项工作。此方法会递归地遍历所有子组件，并计算适当的定位和大小。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For those familiar with previous versions of the framework, the `updateLayout`
    method replaced the `doLayout` method in Ext JS 4.1.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉框架先前版本的开发者，`updateLayout`方法在Ext JS 4.1中替换了`doLayout`方法。
- en: The framework automatically takes care of sizing and positioning by calling
    the `updateLayout` method. For example, when the browser window is adjusted or
    resized, or you add or remove components, the framework will do the necessary
    calculations to ensure your components appear correctly on screen.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 框架通过调用`updateLayout`方法自动处理大小和位置的调整。例如，当浏览器窗口调整或缩放，或者你添加或删除组件时，框架将执行必要的计算以确保你的组件在屏幕上正确显示。
- en: There are some circumstances when it is beneficial to call the `updateLayout`
    manually. Laying out components can be a resource-intensive task, and if you know
    you are going to make a number of updates to components, then it may be worth
    thinking about batching the layout into one. For instance, adding three components
    one after another would trigger three calls to `updateLayout` (which recurses
    through all child components). By using a `suspendLayout` flag, we can prevent
    our application from updating the DOM until we're ready. When we are ready, it's
    a simple case of switching the `suspendLayout` flag off by setting it to false
    and then manually calling the `updateLayout` method of the container.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，手动调用`updateLayout`是有益的。布局组件可能是一个资源密集型任务，如果你知道你将要对组件进行多次更新，那么考虑将布局批处理成一个可能是有价值的。例如，连续添加三个组件会触发三次对`updateLayout`的调用（它会递归遍历所有子组件）。通过使用`suspendLayout`标志，我们可以防止我们的应用程序在准备好之前更新DOM。当我们准备好时，只需将`suspendLayout`标志设置为false，然后手动调用容器的`updateLayout`方法即可。
- en: The component layout
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件布局
- en: A component also has a layout which defines how it sizes and positions its internal
    child items. Component layouts are configured using the `componentLayout` config
    option.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 组件还有一个布局，它定义了它如何定义其内部子项的大小和位置。组件布局是通过使用`componentLayout`配置选项来配置的。
- en: In most circumstances, you will not require the `componentLayout` configuration,
    unless you plan on writing custom components that have complex layout requirements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不需要`componentLayout`配置，除非你打算编写具有复杂布局要求的自定义组件。
- en: Using the border layout
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用边界布局
- en: If you are looking to create a desktop style experience with your user interface,
    then the border layout is for you.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望创建具有桌面风格的用户界面体验，那么边界布局就是你的选择。
- en: '![Using the border layout](img/3717_06_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![使用边界布局](img/3717_06_01.jpg)'
- en: The border layout is an application-oriented layout, supporting multiple nested
    panels, the ability to collapse regions by clicking on the regions' header or
    collapse icon, and the resizing of regions by clicking and dragging the splitter
    bar between them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 边框布局是一种面向应用程序的布局，支持多个嵌套面板，可以通过点击区域标题或折叠图标来折叠区域，以及通过点击和拖动区域之间的分隔条来调整区域大小。
- en: One of the building blocks of our BizDash application will be a Viewport with
    a border layout. Here, we will learn how to create a simple border layout using
    the maximum number of regions configurable (north, south, east, west, and center).
    The west and east regions will be collapsible, with the east region loading pre-collapsed.
    Resizing will be demonstrated in the south and west regions. These four borders
    will surround the center region, which regardless of your configuration, is required
    for a border layout to work.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们BizDash应用程序的构建块之一将是一个带有边框布局的视口。在这里，我们将学习如何使用可配置的最大区域数量（北部、南部、东部、西部和中心）创建一个简单的边框布局。西部和东部区域将是可折叠的，东部区域将预先折叠。我们将演示南部和西部区域的调整大小。这四个边框将围绕中心区域，无论您的配置如何，中心区域对于边框布局的正常工作都是必需的。
- en: Starting with the Viewport
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从视口开始
- en: A Viewport renders itself to the document's body and automatically consumes
    the viewable area. It represents the entire viewable browser area and automatically
    uses 100 percent of the browser window's width and height (minus address bars,
    developer tools, and so on, of course). Our Viewport will have a border layout
    to manage the size and positioning of its child containers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 视口将自身渲染到文档的`body`中，并自动消耗可视区域。它代表整个可视浏览器区域，并自动使用浏览器窗口的100%宽度和高度（当然，减去地址栏、开发者工具等）。我们的视口将使用边框布局来管理其子容器的尺寸和位置。
- en: In our application, we set the `autoCreateViewport` property in `app.js` to
    `BizDash.view.main.Main`. This automatically sets our main view container to a
    Viewport for us.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们在`app.js`中将`autoCreateViewport`属性设置为`BizDash.view.main.Main`。这会自动将我们的主要视图容器设置为视口。
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Configuring the border layout
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置边框布局
- en: 'Our main view takes the following configuration:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要视图采用以下配置：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The border layout, as the name suggests, creates a layout of components that
    border a central component. Therefore, a requirement of the border layout is that
    one item must be specified as the center.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，边框布局创建了一个围绕中心组件的组件布局。因此，边框布局的要求之一是必须指定一个项目作为中心。
- en: The center region, which you must include for a border layout to work, automatically
    expands to consume the empty space left over from the other regions in your layout.
    It does this by having a pre-defined flex value of `1` for both height and width.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 中心区域，这是为了使边框布局正常工作而必须包含的区域，会自动扩展以消耗布局中其他区域留下的空余空间。它是通过为高度和宽度都预定义了一个弹性值`1`来实现的。
- en: The north and south regions take a height or flex configuration. In our app,
    the north region has a fixed height of 100 px and the south region has a flex
    of 3\. The south and center regions' heights are calculated based on the height
    remaining in the browser window. Here, the height of the south region is just
    under a third of the height of the center. The west and east regions, instead,
    take a width or flex configuration.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 北部和南部区域采用高度或弹性配置。在我们的应用中，北部区域的高度固定为100像素，而南部区域的弹性值为3。南部和中心区域的高度是基于浏览器窗口中剩余的高度计算的。在这里，南部区域的高度略小于中心区域高度的三分之一。西部和东部区域则采用宽度或弹性配置。
- en: 'We add further functionality with `collapsed`, `collapsible`, `split`, and
    `titleCollapse` specified in the desired regions'' configuration. They do the
    following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在所需区域的配置中指定`collapsed`、`collapsible`、`split`和`titleCollapse`来添加更多功能。它们执行以下操作：
- en: '`collapsed`: If set to `true`, it means the region will start collapsed (the
    regions need to be `Ext.panel.Panel` to be collapsible)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collapsed`：如果设置为`true`，则表示该区域将开始折叠（区域需要是`Ext.panel.Panel`才能折叠）'
- en: '`collapsible`: If set to `true`, it allows the user to expand/collapse the
    panel by clicking on the toggle tool that''s added to the header'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collapsible`：如果设置为`true`，则允许用户通过点击添加到标题中的切换工具来展开/折叠面板'
- en: '`titleCollapse`: If set to `true`, it makes the panel collapse no matter where
    the user clicks on the panel''s header'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`titleCollapse`：如果设置为`true`，则无论用户在面板标题的哪个位置点击，都会使面板折叠'
- en: '`split`: If set to `true`, it makes the region resizable by allowing the users
    to click and drag the dividing bar between regions.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split`：如果设置为`true`，则允许用户通过点击和拖动区域之间的分隔条来调整区域大小。'
- en: Using the fit layout
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fit布局
- en: The fit layout in Ext JS is ideal if you want a container to expand a component
    to fill its parent. The fit layout is easy to use and requires no configuration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS中，fit布局非常适合您想要一个容器将组件扩展以填充其父容器的情况。fit布局易于使用且无需配置。
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `main` class has a border layout, but the south region requires a fit layout
    for its child panel.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`类有一个边界布局，但南区域需要fit布局来对其子面板进行配置。'
- en: The fit layout works by defining the `layout` config option as `fit` in the
    parent container. This tells Ext JS that the child item should expand to fill
    the entire space available from its parent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: fit布局通过在父容器中定义`layout`配置选项为`fit`来工作。这告诉Ext JS子项应该扩展以填充从其父项可用的整个空间。
- en: It's worth noting that the fit layout will only work for the first child item
    of the parent container. If you have multiple items defined, the first will be
    displayed (as it will expand into the remaining space of its parent) and the others
    will not be visible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，fit布局只适用于父容器的第一个子项。如果您定义了多个项，第一个将被显示（因为它会扩展到其父项的剩余空间），而其他项将不可见。
- en: Using the HBox layout
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HBox布局
- en: The HBox layout allows you to align components horizontally across a container
    in a manner similar to a column layout. However, it's a bit more advanced, as
    it lets you configure additional properties, such as the height of the columns
    as well.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: HBox布局允许您以类似于列布局的方式在容器内水平对齐组件。然而，它更为高级，因为它允许您配置额外的属性，例如列的高度等。
- en: '![Using the HBox layout](img/3717_06_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用HBox布局](img/3717_06_02.jpg)'
- en: 'Let''s create an overview widget with three columns to show events, messages,
    and notes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含三列的概览小部件来显示事件、消息和笔记：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Defining an HBox layout ensures that Ext JS horizontally positions each child
    item giving the appearance of columns in our dashboard application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个HBox布局确保Ext JS水平定位每个子项，在我们的仪表板应用程序中呈现出列的样式。
- en: 'We have configured `stretchmax` on the `align` config option, meaning that
    all child items will automatically be stretched to the height of the tallest child.
    The `align` config option controls how child items are vertically aligned in an
    HBox layout. Valid values are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`align`配置选项上配置了`stretchmax`，这意味着所有子项将自动拉伸到最高子项的高度。`align`配置选项控制子项在HBox布局中的垂直对齐方式。有效值如下：
- en: '`begin`: This is the default value. All items in the HBox layout will be vertically
    aligned to the top of the container'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin`：这是默认值。HBox布局中的所有项都将垂直对齐到容器的顶部'
- en: '`middle`: All items will be vertically aligned to the middle (or center) of
    the container'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`middle`：所有项都将垂直对齐到容器的中间（或中心）'
- en: '`stretch`: Each item will be vertically stretched to fit the height of the
    container'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretch`：每个项都将垂直拉伸以适应容器的高度'
- en: '`stretchmax`: This vertically stretches all items to the height of the largest
    item, creating a uniform look without having to individually define a height for
    each item'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretchmax`：这将垂直拉伸所有项到最大项的高度，创建一个统一的外观，而无需为每个项单独定义高度'
- en: The VBox layout has a very similar config to this layout, but the options are
    slightly different, as they are designed to control the horizontal alignment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: VBox布局与这个布局的配置非常相似，但选项略有不同，因为它们是为了控制水平对齐而设计的。
- en: 'By defining a height of 200 and configuring `align: ''stretchmax''`, all other
    panels will have their height stretched to 200 px.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '通过定义高度为200并配置`align: ''stretchmax''`，所有其他面板的高度都将拉伸到200像素。'
- en: Widths in HBox layouts
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HBox布局中的宽度
- en: 'HBoxes can have their width defined in two different ways: fixed widths and
    flex widths.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: HBox可以有宽度定义的两种方式：固定宽度和弹性宽度。
- en: Fixed width
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定宽度
- en: Child containers can have their width fixed by defining a width configuration
    in the object. Containers with a fixed width will retain their width dimensions,
    even when the browser window is resized. Therefore, they are not fluid.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 子容器可以通过在对象中定义宽度配置来固定其宽度。具有固定宽度的容器将保留其宽度尺寸，即使浏览器窗口大小调整也是如此。因此，它们不是流动的。
- en: If, however, you require your layout to be more responsive to the resizing of
    windows and so on, then it's a `flex` config that's required.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要您的布局对窗口大小调整等更加响应，那么就需要一个`flex`配置。
- en: Flex width
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹性宽度
- en: 'The `flex` config option relatively flexes the child items horizontally in
    their parent containers. For example, take a container with flex: 1 and one with
    flex: 3\. In these cases, 25 percent of the remaining parent space is given to
    the first container and 75 percent of the space is given to the other.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex`配置选项在父容器中相对地水平拉伸子项目。例如，考虑一个flex: 1的容器和一个flex: 3的容器。在这些情况下，剩余父空间的25%分配给第一个容器，75%的空间分配给另一个。'
- en: 'Flex values are calculated in the following way:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性值按以下方式计算：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Packing items together
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将项目打包在一起
- en: Another useful config option for the HBox layout is `pack`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HBox布局的另一个有用配置选项是`pack`。
- en: 'The `pack` config option controls how the child items are packed together.
    If the items do not stretch to the full width of the parent container, it''s possible
    to align them to the left, middle, or right using this option. Valid values are
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack`配置选项控制子项目如何打包在一起。如果项目没有拉伸到父容器的完整宽度，则可以使用此选项将它们对齐到左侧、中间或右侧。有效值如下：'
- en: '`start`: This is the default value. It aligns all items to the left of the
    parent container.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：这是默认值。它将所有项目对齐到父容器的左侧。'
- en: '`center`: This aligns all items to the middle of the container.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`：这将对齐所有项目到容器的中间。'
- en: '`end`: It aligns all items to the right of the container.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：它将所有项目对齐到容器的右侧。'
- en: The VBox layout contains the same `pack` config, but it is designed to configure
    the packing of child items vertically.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: VBox布局包含相同的`pack`配置，但它被设计用来配置子项目的垂直打包。
- en: Using the VBox layout
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VBox布局
- en: The VBox layout is very similar to the HBox layout. The only difference is that
    VBox allows you to align components vertically in a container. Just like the HBox
    layout, this layout is configured by setting fixed widths for its children using
    the `width` config, or by calculating the width automatically with the `flex`
    config.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: VBox布局与HBox布局非常相似。唯一的区别是VBox允许你在容器中垂直对齐组件。就像HBox布局一样，这个布局是通过设置子组件的固定宽度使用`width`配置，或者通过使用`flex`配置自动计算宽度来配置的。
- en: '![Using the VBox layout](img/3717_06_03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![使用VBox布局](img/3717_06_03.jpg)'
- en: Alignment and packing
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐和打包
- en: The VBox layout has some useful configuration options that are described here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: VBox布局有一些有用的配置选项，在此处进行描述。
- en: 'align: String'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'align: 字符串'
- en: 'The `align` config option controls how child items are horizontally aligned
    in a VBox layout. Valid values are:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`align`配置选项控制子项目在VBox布局中的水平对齐方式。有效值如下：'
- en: '`begin`: This is the default value. All items in the VBox layout are horizontally
    aligned to the left of the container and use their `width` config to define how
    wide they are.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin`：这是默认值。VBox布局中的所有项目在容器中水平对齐到左侧，并使用它们的`width`配置来定义它们的宽度。'
- en: '`middle`: All items are horizontally aligned to the middle (or center) of the
    container.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`middle`：所有项目都水平对齐到容器的中间（或中心）。'
- en: '`stretch`: Each item is horizontally stretched to fit the width of the container.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretch`：每个项目都水平拉伸以适应容器的宽度。'
- en: '`stretchmax`: This horizontally stretches all items to the width of the largest
    item, creating a uniform look without having to individually define a width for
    each item.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretchmax`：这将所有项目水平拉伸到最大项目的宽度，创建一个统一的外观，而无需为每个项目单独定义宽度。'
- en: 'pack: String'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'pack: 字符串'
- en: 'The `pack` config option controls how the child items are packed together.
    If the items do not stretch to the full height of the parent container (that is,
    have no flex values), it''s possible to align them to the top, middle, or bottom
    using this option. Valid values are:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack`配置选项控制子项目如何打包在一起。如果项目没有拉伸到父容器的完整高度（即没有flex值），则可以使用此选项将它们对齐到顶部、中间或底部。有效值如下：'
- en: '`start`: This is the default value. It aligns all items to the top of the parent
    container.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：这是默认值。它将所有项目对齐到父容器的顶部。'
- en: '`center`: This aligns all items to the middle (or center) of the container.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`：这将对齐所有项目到容器的中间（或中心）。'
- en: '`end`: This aligns all items to the bottom of the container.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：这将对齐所有项目到容器的底部。'
- en: Responsive layouts
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式布局
- en: Long gone are the days when web browsers were only found in desktop PCs and
    laptops. Nowadays, they can be found in an ever-increasing range of hardware,
    such as phones, tablets, TVs, and cars, to name a few. Since the release of the
    iPhone in 2007, a new type of web, the mobile web, has grown in popularity, and
    the expectations of users have changed. Users expect to access a web application
    and have fantastic experience, no matter how large or small their screen is.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那些只有桌面电脑和笔记本电脑上才有网络浏览器的日子已经一去不复返了。如今，它们可以在各种硬件上找到，如手机、平板电脑、电视和汽车等。自 2007 年 iPhone
    发布以来，一种新的网络类型——移动网络，已经越来越受欢迎，用户的期望也发生了变化。用户期望无论屏幕大小如何，都能访问网络应用并获得出色的体验。
- en: Until the advent of Ext JS 5, it was difficult to cater to the differing needs
    of users. Ext JS 5 has, however, adopted the popular move towards responsive design,
    giving developers a practical way of adapting the app layout, depending on the
    size and resolution of the screen presenting it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 Ext JS 5 的出现，很难满足用户的不同需求。然而，Ext JS 5 已经采纳了流行的响应式设计趋势，为开发者提供了一种根据展示屏幕的大小和分辨率来适应应用布局的实用方法。
- en: Ext.mixin.Responsive and Ext.plugin.Responsive
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ext.mixin.Responsive 和 Ext.plugin.Responsive
- en: There is a new responsive mixin and plugin that adds a `responsiveConfig` option.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个新的响应式混合和插件，它添加了一个 `responsiveConfig` 选项。
- en: 'In our border layout, we want to alter how the regions are presented, based
    on the screen orientation. Adding the `responsiveConfig` with the following *rules*
    to the main view tells the application to add the navigation panel to the north
    or west region based on the orientation of the screen:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的边框布局中，我们希望根据屏幕方向改变区域展示的方式。将以下 *规则* 的 `responsiveConfig` 添加到主视图中，告诉应用程序根据屏幕方向将导航面板添加到北部或西部区域：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, the `responsiveConfig` has two rules defined: one for landscape
    and another for portrait. When the application satisfies the rule, the config
    defined in the object of that rule will be applied to the component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`responsiveConfig` 定义了两个规则：一个用于横向，另一个用于纵向。当应用程序满足规则时，该规则对象中定义的配置将被应用到组件上：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If, for example, our screen orientation is landscape, then the framework will
    apply `region: ''west''` to the panel. This is the same as the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，如果我们的屏幕方向是横向，那么框架将 `region: ''west''` 应用到面板上。这等同于以下代码：'
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ResponsiveConfig rules
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ResponsiveConfig 规则
- en: 'We must define rules that contain a condition, or multiple conditions, based
    on which the rules will be applied. These rules can be any valid JavaScript expression,
    but the following values are considered in scope:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须定义包含条件或多个条件的规则，根据这些条件应用规则。这些规则可以是任何有效的 JavaScript 表达式，但以下值被认为是范围内的：
- en: '`landscape`: This returns true when the orientation is landscape or on a desktop
    device.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`landscape`：当方向为横向或在桌面设备上时返回 true。'
- en: '`portrait`: This returns true when the orientation is portrait but is always
    false on desktop devices.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`portrait`：当方向为纵向时返回 true，但在桌面设备上始终为 false。'
- en: '`tall`: This returns true if the height is greater than the width.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tall`：如果高度大于宽度，则返回 true。'
- en: '`wide`: This returns true if the width is greater than the height.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wide`：如果宽度大于高度，则返回 true。'
- en: '`width`: This defines the width of the Viewport.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`：这定义了视口的宽度。'
- en: '`height`: This defines the height of the Viewport.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`：这定义了视口的宽度。'
- en: The width and height are particularly useful, as these give us a way to define
    our own values in a way similar to breakpoints in media queries.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度和高度特别有用，因为这些给我们提供了一种以类似于媒体查询中的断点的方式定义我们自己的值。
- en: 'The following example shows how to create a rule that will be applied when
    a portrait device is less than 400 pixels wide:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何创建一个规则，当纵向设备宽度小于 400 像素时将应用此规则：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Throughout this chapter, we have explored in detail how to define the layout
    of our components on screen using Ext JS. We have covered:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了如何使用 Ext JS 定义屏幕上组件的布局。我们涵盖了：
- en: How the layout manager works
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局管理器是如何工作的
- en: An overview of layouts available to us
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可用的布局概述
- en: Examples of how to use the border, fit and HBox/VBox layouts
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用边框、fit 和 HBox/VBox 布局的示例
- en: Designing a responsive layout to cope with different screen sizes and device
    types
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计响应式布局以应对不同的屏幕尺寸和设备类型
- en: We will make use of all of these lessons throughout the rest of the book, as
    our example application comes to life and we start to integrate our widgets into
    it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的其余部分利用所有这些课程，因为我们的示例应用程序开始变得生动，并且我们开始将其小部件集成到其中。
- en: In the next chapter, we will demonstrate how to create common UI widgets for
    our sample application. These widgets will make use of some of the layouts we
    have seen in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将演示如何为我们的示例应用程序创建常见的UI小部件。这些小部件将利用本章中我们所学到的某些布局。
