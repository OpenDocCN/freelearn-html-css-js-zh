- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Ramping up on Babylon.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加强Babylon.js
- en: At the risk of sounding hyperbolic, **Babylon.js** (**BJS**) is nothing short
    of incredible in how fast effortless, and **fun** it can be to work with 3D graphics
    and games. Most game and graphics engines come with sizable footprints in terms
    of size and computing resource requirements, but BJS is different because it can
    run in a web browser. The BJS team has created a rich web-based tooling ecosystem
    that covers a wide range of development workflows and use cases to support developers
    and designers from many different angles. After establishing some shared vocabulary
    and reviewing some basics, we will begin our journey with the **Babylon.js Playground**
    (**PG**). After this chapter, we’ll have laid the foundations for Space-Truckers
    by creating and rendering a basic animated scene that uses the PG along with content
    from the asset library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 带着夸张的风险，**Babylon.js**（**BJS**）在如何轻松、快速且**有趣**地处理3D图形和游戏方面堪称不可思议。大多数游戏和图形引擎在大小和计算资源需求方面都有相当大的体积，但BJS不同，因为它可以在网页浏览器中运行。BJS团队创建了一个丰富的基于网页的工具生态系统，涵盖了广泛的开发生命周期和工作场景，从多个角度支持开发者和设计师。在建立一些共同词汇并复习一些基础知识之后，我们将从**Babylon.js游乐场**（**PG**）开始我们的旅程。在这一章之后，我们将通过创建和渲染一个基本的动画场景来为Space-Truckers打下基础，这个场景使用了PG以及资产库中的内容。
- en: 'In order to get from where we are to where we want to be, we’ll divide the
    work into these sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们现在所在的地方到达我们想要到达的地方，我们将工作分为以下部分：
- en: Catching up or Refreshing on Babylon.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补充或更新Babylon.js知识
- en: Building Our Scene in the Playground
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游乐场中构建我们的场景
- en: Animating Orbits
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画轨道
- en: Extended Topics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展主题
- en: Technical Requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Like most things in software, you’ll get the best results with Babylon.js. PG
    snippets requires only a web browser supporting **WebGL**, but a desktop-based
    browser is required for some BJS web-based toolsets such as the **Node Material
    Editor** (**NME**). A keyboard is highly recommended for typing code into the
    PG. With regards to browser support, while there are some exceptions around specific
    devices and platforms the latest versions of Edge, Chrome, and Firefox all support
    WebGL2, with ever-growing support for the newer WebGPU functionality. See [https://caniuse.com/webgl2](https://caniuse.com/webgl2)
    for the most up-to-date list of browser vendors supporting WebGL2.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像软件中的大多数事情一样，你将使用Babylon.js获得最佳结果。PG片段只需要一个支持**WebGL**的网页浏览器，但对于一些基于桌面的BJS网页工具集，如**节点材质编辑器**（**NME**），则需要桌面浏览器。强烈建议在PG中输入代码时使用键盘。关于浏览器支持，尽管在特定设备和平台周围有一些例外，但Edge、Chrome和Firefox的最新版本都支持WebGL2，并且对较新的WebGPU功能的支持在不断增加。有关支持WebGL2的浏览器供应商的最新列表，请参阅[https://caniuse.com/webgl2](https://caniuse.com/webgl2)。
- en: Catching up or Refreshing on Babylon.js
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补充或更新Babylon.js知识
- en: 'When starting a new project, it’s easy to get overwhelmed by the sheer number
    of different things that need to be done. Throw unfamiliar technologies or domains
    into the mix, and even the most seasoned software veteran might blanch a bit at
    the challenge. That’s an okay feeling to have! The key to overcoming and moving
    past it is both difficult and simple at the same time: you just need to find an
    atomic, well-defined task and then just do that task. After tackling a few of
    these tasks, you can take a step back to reassess things in light of what you
    now know. Most likely, you will find that the work you originally thought was
    needed isn’t.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个新的项目时，很容易被需要完成的不同事情的数量所压倒。如果再加上不熟悉的技术或领域，即使是经验丰富的软件老手在面对挑战时也可能感到有些退缩。这种感觉是可以接受的！克服并超越这种感觉的关键既困难又简单：你只需要找到一个原子化、定义明确的任务，然后只做那个任务。在完成几个这样的任务之后，你可以退一步，根据你现在的知识重新评估事情。很可能会发现，你最初认为需要做的工作其实并不需要。
- en: Whether you’re a veteran game developer exploring the possibilities of BJS or
    someone who has never programmed a game before, a strategy of starting simple
    and building iteratively can be the best way to get usable, immediate results.
    Let’s start with the basics. The following screenshot is part of the BJS 4.2 release
    content that demonstrates simply how BJS can render scenes with high visual fidelity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是探索BJS可能性的资深游戏开发者，还是从未编写过游戏的初学者，从简单开始并迭代构建可能是获得可用、即时结果的最佳方式。让我们从基础知识开始。以下截图是BJS
    4.2版本发布内容的一部分，展示了BJS如何以高视觉保真度渲染场景。
- en: '![Figure 2.1: A real-time interactive demo from the Babylon.js home page. Semi-transparent
    shadows, reflections, and refraction are clearly visible along (and inside) the
    bottle and table, just as different substances cast different shadows in the real
    world. (https://playground.babylonjs.com/#P1RZV0)](img/Figure_2.01_B17266.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：来自Babylon.js主页的实时交互式演示。在瓶子和平面（以及内部）可以看到半透明的阴影、反射和折射，就像不同物质在现实世界中投射出不同的阴影一样。（https://playground.babylonjs.com/#P1RZV0）](img/Figure_2.01_B17266.jpg)'
- en: 'Figure 2.1: A real-time interactive demo from the Babylon.js home page. Semi-transparent
    shadows, reflections, and refraction are clearly visible along (and inside) the
    bottle and table, just as different substances cast different shadows in the real
    world. ([https://playground.babylonjs.com/#P1RZV0](https://playground.babylonjs.com/#P1RZV0))'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：来自Babylon.js主页的实时交互式演示。在瓶子和平面（以及内部）可以看到半透明的阴影、反射和折射，就像不同物质在现实世界中投射出不同的阴影一样。（[https://playground.babylonjs.com/#P1RZV0](https://playground.babylonjs.com/#P1RZV0)）
- en: The Basics of BJS
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BJS的基本知识
- en: 'BJS is a WebGL-based, full-featured 3D rendering engine written in TypeScript
    and compiled to JavaScript. Although commonly accessed via a web browser, current
    versions do not require an HTML DOM or Canvas elements, meaning that it can run
    “headless” on a server. The BJS team has a very clear vision and mandate, as illustrated
    from the BJS home page ([https://www.BJS.com](https://www.BJS.com)):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: BJS是一个基于WebGL的全功能3D渲染引擎，用TypeScript编写并编译为JavaScript。尽管通常通过网页浏览器访问，但当前版本不需要HTML
    DOM或Canvas元素，这意味着它可以在服务器上“无头”运行。BJS团队有一个非常明确的目标和使命，如BJS主页所示([https://www.BJS.com](https://www.BJS.com))：
- en: “Our mission is to create one of the most powerful, beautiful, and simple Web
    rendering engines in the world. Our passion is to make it completely open and
    free for everyone. We are artists, developers, creators, and dreamers and we want
    to make it as simple as possible to enable everyone to bring their ideas to life.”
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “我们的使命是创造世界上功能最强大、最美丽、最简单的Web渲染引擎之一。我们的热情是让它对每个人完全开放和免费。我们是艺术家、开发者、创造者和梦想家，我们希望让它尽可能简单，以便每个人都能将他们的想法变为现实。”
- en: BJS supports a wide range of both input and output scenarios, from game pads
    and accelerometer-based input to single- or multiple-viewport output (e.g., VR/AR).
    A full list of the engine’s specifications is available at [https://www.babylonjs.com/specifications](https://www.babylonjs.com/specifications).
    Something that’s less obvious from the specifications is that support for WebGPU
    is limited only by the implementation of the standard by browser vendors, so if
    you read news about WebGPU support being released for a browser, you can be confident
    that BJS will be able to take full advantage of it without needing you to do anything
    at all!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: BJS支持广泛的输入和输出场景，从游戏手柄和基于加速度计的输入到单视口或多视口输出（例如，VR/AR）。该引擎的完整规格列表可在[https://www.babylonjs.com/specifications](https://www.babylonjs.com/specifications)找到。从规格中不太明显的是，对WebGPU的支持仅限于浏览器厂商对标准的实现，因此如果你看到有关浏览器发布WebGPU支持的新闻，你可以确信BJS将能够充分利用它，而无需你做任何事情！
- en: Tip
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Something I always forget to apply to when I’m working with imported assets
    being from other 3D/image editing tools such as Blender is coordinate conventions.
    The 3D coordinate system used by BJS is “left-handed,” meaning that the positive
    *y*-axis will (by default) point in the “up” direction, the positive *x*-axis
    to the “right,” and the positive *z*-axis “toward” the camera.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用来自其他3D/图像编辑工具（如Blender）导入的资产时，我总是忘记应用坐标约定。BJS使用的3D坐标系是“左手坐标系”，这意味着正*y*轴（默认情况下）指向“向上”的方向，正*x*轴指向“向右”，正*z*轴指向“相机方向”。
- en: Get Started with Getting Started
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从入门开始学习
- en: Something that will quickly become apparent to anyone browsing the documentation
    for BJS is how thorough and comprehensive that documentation is. Given the high
    quality of the Getting Started content there, it would be a pointless waste of
    precious space in this book to attempt to recreate the basic tutorial at [https://doc.babylonjs.com/start](https://doc.babylonjs.com/start).
    If this is your first time adventuring with game development, BJS, or JavaScript,
    it is *highly* recommended that you take the time to at least browse through the
    Getting Started tutorial linked earlier. Don’t worry about leaving – everything
    will still be here right as you left it when you get back!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 任何浏览BJS文档的人都会很快意识到该文档是多么的详尽和全面。鉴于入门内容的优质，本书尝试重新创建[https://doc.babylonjs.com/start](https://doc.babylonjs.com/start)中的基本教程将是毫无意义的浪费宝贵空间。如果您是第一次冒险进行游戏开发、BJS或JavaScript，强烈建议您花时间至少浏览一下前面链接的入门教程。不用担心离开——您回来时，一切都会像您离开时一样完好无损！
- en: Tools for the Toolbox
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具箱工具
- en: 'One of the advantages of being JavaScript-based is that it is very easy to
    make web-based tooling available that allows users to code and render in real
    time in a tight iteration loop. The BJS **Playground** (**PG**) is probably the
    most prominent member of the BJS toolchain, but that should not diminish the utility
    and importance of the other tools that we’re going to cover. The following table
    summarizes the various tools available and their purposes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JavaScript基础的优点之一是，它非常容易提供基于Web的工具，允许用户在紧密的迭代循环中实时编码和渲染。BJS的**游乐场**（**PG**）可能是BJS工具链中最突出的成员，但这不应减少我们将要介绍的其他工具的实用性和重要性。以下表格总结了各种工具及其用途：
- en: '![](img/Table_2.01_B17266.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.01_B17266.jpg)'
- en: Throughout this book, we’ll be making heavy use of the PG; we’ll use it to quickly
    put together a piece of code or test a concept before integrating it into our
    application code. Not to be left out, the **Inspector** (and its accompanying
    tools) is also going to see heavy usage for its powerful scene-debugging capabilities.
    Finally, the NME will be covered later in this book as we dive into the making
    of Space-Truckers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将大量使用PG；我们将用它来快速组合一段代码或测试一个概念，然后再将其集成到我们的应用程序代码中。同样，**检查器**（及其相关工具）也将因其强大的场景调试功能而得到大量使用。最后，随着我们深入到《Space-Truckers》的制作，NME将在本书的后面部分进行介绍。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The typical usage of the word **Game** in this book denotes the portion of the
    overall **Application** that is devoted to the game mechanics, logic, and loops.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，**游戏**一词的典型用法是指整个**应用程序**中专门用于游戏机制、逻辑和循环的部分。
- en: The Asset Types of BJS
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BJS的资产类型
- en: 'Many different types of files and formats are supported by BJS, either directly
    or indirectly (via exporter plugins). When selecting and/or creating assets for
    your game, it’s important to put together a production workflow that minimizes
    the amount of friction without sacrificing quality – something we’ll learn more
    about in the next chapter. Here are a few of the most commonly encountered third-party
    tools and file types that BJS supports:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: BJS支持许多不同类型的文件和格式，无论是直接还是间接（通过导出插件）。在选择和/或为您的游戏创建资产时，重要的是要制定一个生产工作流程，以最大限度地减少摩擦，同时不牺牲质量——我们将在下一章中了解更多关于这一点。以下是BJS支持的几种最常见的第三方工具和文件类型：
- en: 'Textures/Images:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理/图像：
- en: DDS (DXT1, 4bpp, and RGBA)
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDS (DXT1, 4bpp, 和 RGBA)
- en: PNG/JPEG/BMP
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PNG/JPEG/BMP
- en: TGA
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TGA
- en: HDR
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HDR
- en: '3D Models:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D模型：
- en: GLTF (preferred)
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GLTF (首选)
- en: OBJ
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OBJ
- en: STL
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL
- en: BLENDER/3DS Max/Maya (exporter plugins)
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: BLENDER/3DS Max/Maya (导出插件)
- en: 'Sounds:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音：
- en: WAV
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAV
- en: MP3
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MP3
- en: MP4
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MP4
- en: M4A
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: M4A
- en: 'Fonts:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体：
- en: TrueType
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TrueType
- en: OTT
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OTT
- en: 'More relevant to our immediate purposes, however, is the BJS **Asset Library**.
    You can see the asset categories and browse entries by category at [https://doc.babylonjs.com/toolsAndResources/assetLibraries](https://doc.babylonjs.com/toolsAndResources/assetLibraries),
    but the true power of the Asset Library comes from being able to reference and
    load them from the PG! Let’s start off our scene creation by doing just that.
    Open up your browser of choice and head to the BJS PG: [https://playground.babylonjs.com](https://playground.babylonjs.com).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对我们当前目的来说，更相关的是BJS的**资产库**。您可以在[https://doc.babylonjs.com/toolsAndResources/assetLibraries](https://doc.babylonjs.com/toolsAndResources/assetLibraries)查看资产类别并按类别浏览条目，但资产库的真正力量在于能够从PG中引用和加载它们！让我们从创建场景开始，就是这样。打开您选择的浏览器并前往BJS
    PG：[https://playground.babylonjs.com](https://playground.babylonjs.com)。
- en: Building the Playground Scene
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游乐场场景
- en: The **Babylon.js Playground** is designed around providing users with the easiest,
    shortest possible path to rendering content in the scene. Open your web browser
    of choice and navigate to [https://playground.babylonjs.com/](https://playground.babylonjs.com/)
    and you’ll see the basic outline of a snippet. This basic template snippet simply
    creates a new **scene** and a **camera** that renders it, but it’s as good a starting
    place as any!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**Babylon.js游乐场**的设计宗旨是提供用户以最简单、最短的可能路径来渲染场景中的内容。打开你选择的网页浏览器，导航到[https://playground.babylonjs.com/](https://playground.babylonjs.com/)，你将看到代码片段的基本轮廓。这个基本的模板片段简单地创建了一个新的**场景**和一个**相机**来渲染它，但这也是一个很好的起点！'
- en: On the left of the playground is the code editor and on the right the render
    canvas. The important thing to know about the playground is that each snippet
    is unique in two ways, both contained within the URL to the snippet. The characters
    after the first hash (#) symbol are the snippet’s ID, the number after the second
    hash the revision. Every time a snippet is created it is assigned a unique identifier,
    and every time that snippet is saved a new revision is created. For example, **#L92PHY#36**
    points to a sample showing multiple viewports in an FPS camera, with the current
    revision being 36\. Thus, it’s possible to step incrementally through a particular
    snippet’s revision history simply by changing the URL.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在游乐场的左侧是代码编辑器，右侧是渲染画布。关于游乐场，重要的是要知道每个片段在两个方面是独特的，这两个方面都包含在片段的URL中。第一个井号（#）符号之后的字符是片段的ID，第二个井号之后的数字是修订版本。每次创建片段时，都会分配一个唯一的标识符，每次保存该片段时，都会创建一个新的修订版本。例如，**#L92PHY#36**指向一个示例，展示了FPS相机中的多个视口，当前修订版本为36。因此，只需更改URL，就可以逐步通过特定片段的修订历史。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because we are going to be using snippets from the PG in our game though, we’re
    going to want to do a little bit of preparatory structuring so that we can easily
    and reliably transfer code between our PG snippets and the source repos (more
    on this in [*Chapter 3*](B17266_03_Final_AM.xhtml#_idTextAnchor049)*, Establishing
    the Development Workflow*). Throughout the book and in snippets, we will be using
    **ES6** syntax where possible. This gives us access to some important language
    features that we’ll be leveraging to help keep our code readable and maintainable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将在游戏中使用PG的代码片段，但我们需要做一些初步的结构化工作，以便我们可以轻松且可靠地在我们的PG片段和源代码库之间传输代码（更多内容请参阅[*第3章*](B17266_03_Final_AM.xhtml#_idTextAnchor049)*，建立开发工作流程）。在本书和代码片段中，我们将尽可能使用**ES6**语法。这使我们能够访问一些重要的语言特性，我们将利用这些特性来帮助保持我们的代码可读性和可维护性。
- en: Tip
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'ES6 recommendation: choose `let` over `var`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ES6建议：优先选择`let`而不是`var`。
- en: It’s all about hoisting and closures. Variables declared using the `var` keyword
    are valid in their declaring scopes, but also potentially in a/their containing
    scope (known as “hoisting”). Additionally, you can reference a `var` prior to
    its usage without throwing a runtime error. When a variable is declared with the
    `let` statement, it is only available in the declared scope, and it must be declared
    prior to usage; otherwise, an error will be thrown. Generally, you should prefer
    the use of `let` over `var` because it will more easily prevent and expose all-too-common-but-potentially-quite-subtle
    defects. Of course, if you aren’t going to be changing the value, you should use
    `const` over `let`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的重点都在提升（hoisting）和闭包（closures）上。使用`var`关键字声明的变量在其声明的作用域内有效，但也可能在包含的作用域（称为“提升”）内有效。此外，你可以在使用之前引用一个`var`，而不会抛出运行时错误。当一个变量使用`let`语句声明时，它只在其声明的作用域内可用，并且必须在使用之前声明；否则，将会抛出错误。通常，你应该优先使用`let`而不是`var`，因为它将更容易防止和暴露过于常见但可能相当微妙的缺陷。当然，如果你不打算更改值，你应该使用`const`而不是`let`。
- en: Establishing the AppStartScene
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立AppStartScene
- en: A new PG snippet starts with a single block of code – the `createScene` function.
    As the code comments also indicate, the `engine` and `canvas` global variables
    are available in the window’s context.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的PG片段从单个代码块开始——`createScene`函数。正如代码注释也指出的那样，`engine`和`canvas`全局变量在窗口的上下文中可用。
- en: Important Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The HTML Canvas element has been removed as a dependency in BJS 4.2+, but for
    backward compatibility reasons, methods involving the HTML Canvas element will
    still function as expected.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在BJS 4.2+中已经移除了HTML Canvas元素作为依赖项，但出于向后兼容性的原因，涉及HTML Canvas元素的方法仍然按预期工作。
- en: Modifying the createScene function
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改createScene函数
- en: 'To make the reuse of code easier, we will make a small change to the initial
    function template. Instead of putting all of the scene’s logic into the same `createScene`
    function, we’re going to subdivide the logic into atomic functions as much as
    possible. The initialization routine will be done in a new function, which will
    return an object containing the populated scene objects:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码的重用更容易，我们将对初始函数模板进行一些小的修改。我们不会将场景的所有逻辑都放入同一个`createScene`函数中，而是尽可能地将逻辑细分到原子函数中。初始化例程将在一个新函数中完成，该函数将返回一个包含已填充场景对象的对象：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A sharp observer will notice that we have not as yet implemented the `createStartScene`
    function, which is of course the next step. Its purpose is to create and initialize
    the scene and its elements – see the following list. Low-friction change is critically
    important, so to make it easier to change them later we’re going to place each
    piece of functionality into its own function (pun intended):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个敏锐的观察者会注意到我们尚未实现`createStartScene`函数，这当然是下一步。它的目的是创建和初始化场景及其元素 - 请参阅以下列表。低摩擦变化至关重要，因此为了便于以后更改，我们将每个功能部分放入其自己的函数中（有意为之）：
- en: ArcRotateCamera
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弧形旋转相机
- en: Point light
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点光源
- en: Star (sun)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星星（太阳）
- en: Skybox for background
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景天空盒
- en: Planets – four rocky and one gas giant
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行星 - 四颗岩石行星和一颗气态巨行星
- en: 'It’s time to fill out our add and populate this new function, `createStartScene`.
    First, we are creating the scene and camera, specifying some specifics before
    making calls to soon-to-be-written functions (in bold) that create their respective
    elements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候填写并填充这个新的函数`createStartScene`了。首先，我们正在创建场景和相机，在调用即将编写的函数（加粗）之前指定一些具体细节，这些函数将创建相应的元素：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To save you the effort of doing the math in your head, the `camBeta` (or, the
    latitudinal position in radians of the camera from the target) value comes out
    to around 0.785 rad - 45 degrees, between the equator and the pole of an imaginary
    circle around the target of `camDist` radius. Of course, this code won’t compile
    or run yet because we haven’t yet defined `setupEnvironment`, `createStar`, or
    `populatePlanetarySystem`. Add stub implementations for these functions to make
    sure that the code runs as expected. The resulting scene is empty, but it’s a
    good checkpoint in our progress. It’s time to fill in the stubs and make our scene
    come to life! Don’t forget to save (*Ctrl* + *S*) your snippet before continuing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省您在脑海中计算的努力，`camBeta`（或，相机相对于目标纬度的弧度值）大约为0.785弧度 - 45度，位于围绕`camDist`半径目标的想象圆的赤道和极点之间。当然，这段代码目前还不能编译或运行，因为我们还没有定义`setupEnvironment`、`createStar`或`populatePlanetarySystem`。为这些函数添加占位符实现以确保代码按预期运行。生成的场景是空的，但这是我们进度中的一个良好检查点。现在是时候填充占位符并让我们的场景活跃起来！在继续之前，别忘了保存（*Ctrl*
    + *S*）您的代码片段。
- en: Setting up the Environment
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置环境
- en: The default environment is pretty bland and dark. The primary source of lighting
    for the scene is going to be a **Point Light** positioned at the center of the
    star system, while a skybox gives the scene perspective. The texturing of the
    skybox is of particular interest, because an attractive-looking skybox tends to
    be quite large in terms of file size. We care about this because we are going
    to use this scene as a loading graphic, meaning that it needs to load and begin
    rendering as quickly as possible. Loading a large texture over an internet connection
    is unlikely to help us with that goal, so instead we will create the texture on
    the fly using the **Starfield Procedural Texture** from the Babylon.js **Procedural
    Textures Library** (see [https://doc.babylonjs.com/toolsAndResources/assetLibraries/proceduralTexturesLibrary](https://doc.babylonjs.com/toolsAndResources/assetLibraries/proceduralTexturesLibrary)
    for the full list of available procedural textures).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认环境相当单调且昏暗。场景的主要光源将是一个位于星系中心的**点光源**，而天空盒则提供了场景的透视感。天空盒的纹理特别引人注目，因为一个看起来吸引人的天空盒在文件大小方面往往相当大。我们关心这一点，因为我们打算将这个场景用作加载图形，这意味着它需要尽可能快地加载并开始渲染。通过互联网连接加载大纹理不太可能帮助我们实现这一目标，因此我们将使用Babylon.js的**程序纹理库**中的**星场程序纹理**（见[https://doc.babylonjs.com/toolsAndResources/assetLibraries/proceduralTexturesLibrary](https://doc.babylonjs.com/toolsAndResources/assetLibraries/proceduralTexturesLibrary)以获取可用的程序纹理的完整列表）即时创建纹理。
- en: Tip
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Every `darkmatter`, which controls the lacunae (voids), and `distfading`, which
    governs the sharpness or blurriness of the rendered texture. The values in the
    code listed in the following code were arrived at after trial-and-error, so experiment
    to see what you like the best!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`darkmatter`，它控制空洞（空隙），以及`distfading`，它控制渲染纹理的清晰度或模糊度。以下代码中列出的值是通过试错得到的，所以请尝试看看你最喜欢什么！
- en: '`PointLight` is, as the name implies, a source of light that radiates in a
    spherical shell from a single point in space. Because of the darkness of the scene
    and its large-ish size, the intensity of the light gets a bump before setting
    some sun-like colors for the diffuse and specular color channels. We use the `createDefaultEnvironment`
    method along with some previously defined options to create the skybox and accompanying
    background material. That method returns an `EnvironmentHelper` instance, which
    we will kindly return to the original caller of `setupEnvironment`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`PointLight`，正如其名所示，是一个从空间中的单个点向球形壳辐射光线的光源。由于场景的黑暗和其较大的尺寸，光线在设置漫射和镜面颜色通道的类似太阳的颜色之前会增强。我们使用`createDefaultEnvironment`方法以及一些之前定义的选项来创建天空盒和相关的背景材质。该方法返回一个`EnvironmentHelper`实例，我们将友好地将其返回给`setupEnvironment`的原始调用者：'
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Clicking **Run** should now show a nifty-looking starfield in a skybox you can
    pan around. If everything is working correctly, now is a good time to save your
    work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**运行**应该会显示一个在天空中可以旋转的漂亮星系。如果一切正常，现在是一个保存你工作的好时机。
- en: '![Figure 2.2 – Starfield skybox environment'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 星系天空盒环境'
- en: '](img/Figure_2.02_B17266.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.02_B17266.jpg)'
- en: Figure 2.2 – Starfield skybox environment
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 星系天空盒环境
- en: Birthing a Star
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 诞生一颗星星
- en: 'The mesh for our star is a simple sphere, but when we add the standard material
    and some color channels, the result is a single-toned, flat-appearing circle –
    not very “star-like.” We can get a more nuanced look with very little effort by
    combining an `BABYLON.Texture`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们星星的网格是一个简单的球体，但当我们添加标准材质和一些颜色通道时，结果是一个单色调、看起来平坦的圆圈——不太像“星星”。通过结合一个`BABYLON.Texture`，我们可以用很少的努力得到更细腻的外观：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Without changing the `diffuseTexture.level` value, the `emissiveColor` tends
    to either wash out the distortion or be extinguished entirely by the diffuse texture’s
    pixel values. The level, 1.8, was a product of trial-and-error (as is the case
    with many of these “magic numbers” that tend to show up during app design/game
    development). This is a good checkpoint for **saving** your progress if you haven’t
    recently.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在不改变`diffuseTexture.level`值的情况下，`emissiveColor`往往会淡化扭曲或被漫射纹理的像素值完全熄灭。这个值，1.8，是通过试错得到的（就像在应用设计/游戏开发中经常出现的许多“魔法数字”一样）。如果你最近没有保存进度，这是一个很好的检查点来保存你的工作。
- en: '![Figure 2.3 – Emissive color combined with a diffuse distortion texture'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 发射色与漫射扭曲纹理的组合'
- en: '](img/Figure_2.03_B17266.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.03_B17266.jpg)'
- en: Figure 2.3 – Emissive color combined with a diffuse distortion texture
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 发射色与漫射扭曲纹理的组合
- en: Producing Planets
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 产生行星
- en: There’s only one remaining top-level scene element that we still need to create,
    and that’s the `populatePlanetarySystem` function. The implementation for this
    is a classic example of the power of compositional software patterns – a topic
    we will be returning to later. There’s what you might think of as a central control
    logic in the form of `populatePlanetarySystems`, which is responsible for defining
    the number and unique properties of the various planetary bodies. It then asks
    another function, the new `createPlanet` method, to take care of how the actual
    object is constructed. Finally, it collects the planets into an array that it
    returns to the caller.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下唯一需要创建的顶级场景元素是`populatePlanetarySystem`函数。这个实现的经典例子是组合软件模式的强大功能——这是一个我们稍后会再次讨论的话题。有一个可能被认为是中心控制逻辑的形式，即`populatePlanetarySystems`，它负责定义各种行星体的数量和独特属性。然后它要求另一个函数，新的`createPlanet`方法，来处理实际对象的构建。最后，它将行星收集到一个数组中，并将其返回给调用者。
- en: 'We want to be able to create different types of planets with different properties,
    so in our `populatePlanetarySystems` method, we create an array of objects that
    define each planet. For the full listing of planetary data, see [https://playground.babylonjs.com/#0UYAPE#26](https://playground.babylonjs.com/%230UYAPE%2326):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够创建具有不同特性的不同类型的行星，因此在我们的`populatePlanetarySystems`方法中，我们创建了一个对象数组，用于定义每个行星。有关行星数据的完整列表，请参阅[https://playground.babylonjs.com/#0UYAPE#26](https://playground.babylonjs.com/%230UYAPE%2326)：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `posRadians` property generates a random value between 0 and 360 degrees
    (in radians), whereas the `posRadius` property specifies the distance from the
    origin the planet should reside – how far away it is from the sun. The overall
    size of the planet is determined by its `scale` factor, while the `color` property.
    We’ll cover the final property in a moment. Scaling of a scene can be tricky,
    but you can use relative scale guides to help come up with appropriate ranges
    of numbers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`posRadians`属性生成介于0到360度（以弧度为单位）之间的随机值，而`posRadius`属性指定行星应位于原点的距离——它距离太阳有多远。行星的整体大小由其`scale`因子决定，而`color`属性。我们稍后将介绍最后一个属性。场景的缩放可能很棘手，但您可以使用相对缩放指南来帮助确定适当的数字范围。'
- en: You don’t have to stick to realistic numbers – have you ever been told that
    “Space is Big. Really Big”? It is, in fact, quite too big to fit in our tiny viewport,
    so when choosing `posRadius` for the planet, it might be easier to approach coming
    up with a figure from a different direction. By looking at the orbital radius
    in terms of the relative steps between planets, we can come up with a decent-looking
    (but probably not realistically stable) system of planets. Our `starDiameter`
    is 16, giving us a radius of 8 units. Our inner-most planet, `“hg”`, needs to
    be at least 8 + 2 = 10 units to avoid intersecting the star; putting it at 14
    units seems about right. Moving to subsequent planets, by placing each planet
    around 1.5–1.8x, the orbital radius of the previous planet will give nice-looking
    results that aren’t too far from the ratios found in our own Solar System – that’s
    how you know it will be interesting!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必坚持现实数字——您是否曾经被告知“太空很大。真的很大”？事实上，它确实太大，无法适应我们的小视口，因此当选择行星的`posRadius`时，可能更容易从不同的角度来考虑数字。通过将轨道半径视为行星之间的相对步骤，我们可以得出一个看起来不错（但可能不是现实稳定）的行星系统。我们的`starDiameter`是16，给我们一个半径为8个单位。我们的最内层行星`“hg”`至少需要8
    + 2 = 10个单位，以避免与恒星相交；将其放置在14个单位似乎很合适。移动到后续行星，通过将每个行星放置在1.5–1.8倍的位置，前一个行星的轨道半径将给出看起来不错的结果，而且与我们的太阳系中找到的比率相差不远——这就是您知道它将很有趣的原因！
- en: 'This leaves us with the `rocky` property. This flag will signal our logic that
    it needs to apply a different set of textures to the `createPlanet` into the `planets`
    array before returning the populated array:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了`rocky`属性。这个标志将通知我们的逻辑，在返回填充的数组之前，需要将不同的纹理集应用到`createPlanet`函数中的`planets`数组：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The final sub-task needed to display our planetary system is to implement the
    `createPlanet` function. In this method, we do the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显示我们的行星系统所需的最终子任务是实现`createPlanet`函数。在这个方法中，我们执行以下操作：
- en: Create a new Sphere **Mesh** using the **MeshBuilder**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**MeshBuilder**创建一个新的**Mesh**球体。
- en: Create a new `diffuseColor` and `specularColor` to the passed-in `Color3` value.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为传入的`Color3`值创建一个新的`diffuseColor`和`specularColor`。
- en: Assign textures based on the value of the `rocky` flag.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`rocky`标志的值分配纹理。
- en: Assign the material to the mesh.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质分配给网格。
- en: Scale and position `planet` according to the passed-in `scale`, `posRadians`,
    and `posRadius` values.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据传入的`scale`、`posRadians`和`posRadius`值缩放和定位`planet`。
- en: 'It may not be immediately obvious, but we are also setting the material’s `specularPower`
    to zero. This is because we will otherwise get very shiny spots on our planets,
    making them look more like billiard balls than rocky or gaseous spheres. For rocky
    planets, we are pulling in both `bumpTexture` (a.k.a. a `diffuseTexture` from
    the BJS **Textures Library**. For planets with no visible surface, we use the
    distortion texture to add the appearance of cloud bands in the atmosphere:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始并不明显，但我们也将材料的`specularPower`设置为零。这是因为否则我们会在我们的行星上得到非常闪亮的斑点，使它们看起来更像台球而不是岩石或气态球体。对于岩石行星，我们正在引入`bumpTexture`（即来自BJS
    **纹理库**的`diffuseTexture`。对于没有可见表面的行星，我们使用扭曲纹理来在大气中添加云带的外观：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With that code in place, you should be able to **Run** the scene and get a most
    excellent result, showing our central star with four various-sized and colored
    planets at varying distances from the star.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码到位后，你应该能够**运行**场景，并获得一个非常好的结果，显示我们的中心恒星和四个不同大小和颜色的行星，它们与恒星的距离各不相同。
- en: '![Figure 2.4 – Star system with planets and a skybox'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.4 – Star system with planets and a skybox'
- en: '](img/Figure_2.04_B17266.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.04_B17266.jpg]'
- en: Figure 2.4 – Star system with planets and a skybox
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 带有行星和天空盒的星系
- en: '**Save** the snippet and strap in, because next, we’re going to learn two different
    ways and styles of making our planets move.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**保存**这个片段并系好安全带，因为接下来，我们将学习两种不同的方法和风格来使我们的行星移动。'
- en: Animating the Orbits
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画轨道
- en: 'BJS has many different ways of accomplishing any given task; animating objects
    in a scene is no different. Some of the different ways to animate in BJS include
    the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: BJS有许多不同的方式来完成任何给定的任务；在场景中动画化对象也不例外。在BJS中动画化的不同方法包括以下几种：
- en: Define a reusable `BABYLON.Animation` object that will interpolate specified
    properties between an array of **keyframes**.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个可重用的`BABYLON.Animation`对象，它将在一个**关键帧**数组之间插值指定的属性。
- en: Import pre-built Animations from a file – `BABYLON`, `GLTF`, `GLB`, `OBJ`, and
    so on.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中导入预构建的动画 – `BABYLON`、`GLTF`、`GLB`、`OBJ`等。
- en: Use `OnPreRenderObservable` to update object properties (e.g., position, rotation,
    color, and so on) before each frame is rendered.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`OnPreRenderObservable`在每一帧渲染之前更新对象属性（例如，位置、旋转、颜色等）。
- en: For our title screen animations, we will be using the first and third methods
    to animate the rotations and circular orbits of our little solar system, respectively.
    In later chapters, we will see more of the second.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的标题屏幕动画，我们将使用第一种和第三种方法来分别动画化我们的小小太阳系的旋转和圆形轨道。在后面的章节中，我们将看到第二种方法的应用。
- en: Putting Spin on the Star and Planets
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给星星和行星加上旋转效果
- en: The rotation of stars and planets is pretty simple, but it can serve as a good
    review of the principle and practice of keyframe animation. Since animations can
    be looped or cycled, it’s often unnecessary to need a large number of frames for
    a given animation. We’ll follow a few easy steps to add a `createSpinAnimation`
    function that returns a new **Animation** instance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 星星和行星的旋转相当简单，但它可以作为对关键帧动画原理和实践的良好复习。由于动画可以循环或循环播放，对于给定的动画通常不需要大量的帧。我们将遵循几个简单的步骤来添加一个`createSpinAnimation`函数，该函数返回一个新的**Animation**实例。
- en: 'First, we figure out what/which properties of the animation’s target will be
    changing. In this case, it is just the target node’s `rotation.y` value. We can
    say that our animation should complete a full circle (360 degrees or 2 * Pi radians)
    in 2 seconds. Next, determine how many frames the animation should comprise in
    total, the number of `Scalar.TwoPi`. This is all we need to implement the code
    to create and set the animation properties:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确定动画目标将改变哪些属性。在这种情况下，只是目标节点的`rotation.y`值。我们可以说我们的动画应该在2秒内完成一个完整的圆（360度或2
    * Pi弧度）。接下来，确定动画应包含的总帧数，即`Scalar.TwoPi`的数量。这就是我们需要实现创建和设置动画属性的代码：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `createSpinAnimation` method is called from `createStartScene` to make the
    `spinAnim` variable available to the rest of the scene’s controlling code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`createSpinAnimation`方法从`createStartScene`中被调用，以便将`spinAnim`变量提供给场景的其他控制代码。'
- en: 'Once the animation has been created, it can then be added to one or more different
    `mesh.animations` arrays. This attaches the animation to that particular `Animation`
    object has no `start` function or equivalent. That is because the Animation itself
    is agnostic of its target, allowing it to be used across any arbitrary number
    of different meshes. Starting with `star` and then looping through our `planets`
    array, we add `spinAnim` to each mesh:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 动画创建完成后，可以将其添加到一个或多个不同的`mesh.animations`数组中。这将把动画附加到特定的`Animation`对象上，该对象没有`start`函数或等效的函数。这是因为动画本身对其目标是无知的，允许它在任意数量的不同网格上使用。从`star`开始，然后遍历我们的`planets`数组，我们将`spinAnim`添加到每个网格：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To start an animation, you call the `scene.beginAnimation` function, passing
    the start frame, the end frame, and the speed parameters along with the animation
    object. We want it to loop, so we pass `true` as our final parameter to the method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始动画，你需要调用`scene.beginAnimation`函数，传递起始帧、结束帧、速度参数以及动画对象。我们希望它循环播放，所以我们将`true`作为最后一个参数传递给该方法：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the scene is run, the animation automatically starts and you can observe
    the rotation of all the bodies.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景运行时，动画会自动开始，你可以观察到所有天体的旋转。
- en: Making Orbital Motion
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作轨道运动
- en: 'Unlike the `scene.onBeforeRenderObservable`. In the context of the game engine
    loop, this is where the update logic happens. At the end of `createPlanet`, we
    will add code to attach the event listener along with additional data that tracks
    the planet’s orbital parameters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与`scene.onBeforeRenderObservable`不同。在游戏引擎循环的上下文中，这是更新逻辑发生的地方。在`createPlanet`的末尾，我们将添加代码来附加事件监听器，以及跟踪行星轨道参数的附加数据：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our `createAndStartOrbitAnimation` method needs to derive a number of values.
    Two of these, the orbital radius (`posRadius`) and the angular position (`posRadians`)
    are added to `planet` as the `orbitOptions` property.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`createAndStartOrbitAnimation`方法需要推导出许多值。其中两个，轨道半径（`posRadius`）和角位置（`posRadians`），被添加到`planet`作为`orbitOptions`属性。
- en: 'The `period` orbital is the amount of time it takes for the planet to make
    one complete revolution (360 degrees or 2 * Pi radians) and is measured in seconds.
    We want each planet to have a different period, with distant bodies taking longer
    than closer ones to complete an orbit, but we don’t want to laboriously tweak
    values until they look good. Physics – or, more specifically, Newtonian mechanics
    – gives us the equations to compute a planet’s orbital speed given its distance
    (radius) from a given massive body. Knowing the rate of position change over time,
    it’s possible to calculate the angular velocity:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`周期`轨道是行星完成一次完整公转所需的时间（360度或2 * Pi弧度）并且以秒为单位。我们希望每个行星都有一个不同的周期，远处的天体完成轨道所需的时间比近处的天体长，但我们不想不厌其烦地调整值直到它们看起来不错。物理学——或者更具体地说，牛顿力学——为我们提供了计算行星轨道速度的方程，给定其与给定大质量体的距离（半径）。知道位置随时间的变化率，可以计算出角速度：'
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Gm` constant is more or less arbitrarily chosen to ensure a smooth distribution
    of orbital velocities as the radius changes. The state variable needed is `angPos`,
    which is incremented by `w` every frame and kept within a valid range by wrapping
    the statement in a call to `Scalar.Repeat`. In general, it’s useful to think of
    the angular components of these kinematics as being counters or watch dials; incrementing
    the angular position by the angular velocity over time and computing position
    components completes the logic:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gm`常数是任意选择的，以确保随着半径的变化，轨道速度有一个平滑的分布。所需的状态变量是`angPos`，它每帧通过`w`增加，并通过调用`Scalar.Repeat`语句保持在有效范围内。一般来说，将这些运动学的角分量视为计数器或钟表指针是有用的；随着时间的推移，通过角速度增加角位置并计算位置分量来完成逻辑：'
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Returning the `preRenderObsv` object isn’t needed to make this work, but it’s
    a good practice so that we can later on cleanly dispose of the observer when it’s
    no longer needed. Now, when the scene is run, the planets all circle around the
    sun in a unique fashion. This is all looking great, but there’s one last thing
    we can do to really spice things up before we move on. Mash **Save** and let’s
    move on to the finale.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`preRenderObsv`对象不是使这工作所必需的，但这是一个好习惯，这样我们就可以在不再需要时干净地处置观察者。现在，当场景运行时，行星都以独特的方式围绕太阳旋转。这一切看起来都很棒，但在我们继续之前，我们还可以做最后一件事来真正让场景变得生动。按**保存**并继续到最后一部分。
- en: Orbit Lines
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轨迹线
- en: 'To cap off this animation, we’re going to add lines to each planet’s orbit
    using a `createAndStartOrbitAnimation` method is a good place to do this. We declare
    our `TrailMesh` and pass it `planet` to attach to along with the `circum` orbital
    (length) of the trail ribbon, also specifying that we want the trail to start
    immediately. At the same time, we also create a new material and associate it
    with the Trail Mesh:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个动画，我们将使用`createAndStartOrbitAnimation`方法来为每个行星的轨道添加线条，这是一个做这件事的好地方。我们声明我们的`TrailMesh`，并将其传递给`planet`以附加，同时指定路径带的轨道（长度）周长，并指定我们希望路径立即开始。同时，我们还创建了一个新的材质，并将其与路径网格关联：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Before adding the trail mesh, we need to force recomputation of the planet’s
    **World Matrix**; otherwise, the trail will have artifacts from the origin to
    the planet’s location. That’s it! The orbits trace out nice circles as they move,
    but it still feels as if the scene were a bit dark and washed out.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加路径网格之前，我们需要强制重新计算行星的**世界矩阵**；否则，路径将从起源到行星位置出现伪影。就是这样！随着它们的移动，轨道描绘出漂亮的圆圈，但场景仍然感觉有点暗淡。
- en: Shining up with GlowLayer
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GlowLayer发光层增强效果
- en: 'By default, BJS does not add the emissive color channel of a material to the
    lighting computations – emissive textures and colors don’t brighten up a scene.
    Making objects glow is easy; just add this line to the `createStartScene` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，BJS不会将材质的发射色通道添加到光照计算中 – 发射纹理和颜色不会使场景变亮。使物体发光很容易；只需将此行添加到`createStartScene`方法中：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unless otherwise specified, the GlowLayer will impact every mesh in the scene.
    We don’t want the planets to glow, so while we’re looping through the planets
    to animate their rotation, add the planet to the mesh exclusion list of the GlowLayer:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，否则GlowLayer将对场景中的每个网格产生影响。我们不希望行星发光，所以当我们遍历行星以动画化它们的旋转时，将行星添加到GlowLayer的网格排除列表中：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Click **Run** to view the results. If you’re not satisfied with how things look,
    you can tweak the camera altitude and angle (**beta** and **alpha** respectively),
    distance, and so on. Make sure to save the snippet in any case and enjoy the fruits
    of your labor. Once you’re done admiring your work, post your snippets on the
    boards at [https://github.com/jelster/space-truckers/discussions/21](https://github.com/jelster/space-truckers/discussions/21),
    where you can look at other folks’ creations, share, and discuss – but don’t forget
    to come back here, there’s still more work to be done!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**运行**来查看结果。如果你对结果不满意，你可以调整相机的海拔和角度（分别为**beta**和**alpha**），距离等。无论如何，请确保保存代码片段并享受你的劳动成果。一旦你欣赏完你的作品，请将你的代码片段发布在[https://github.com/jelster/space-truckers/discussions/21](https://github.com/jelster/space-truckers/discussions/21)上的板上，在那里你可以查看其他人的创作，分享和讨论
    – 但别忘了回来，还有更多工作要做！
- en: '![Figure 2.5 – Completed orbital animation with GlowLayer and Trail Meshes'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 带有GlowLayer和轨迹网格的完成轨道动画'
- en: '](img/Figure_2.05_B17266.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.05_B17266.jpg)'
- en: Figure 2.5 – Completed orbital animation with GlowLayer and Trail Meshes
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 带有GlowLayer和轨迹网格的完成轨道动画
- en: Extended Topics
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题
- en: The completed snippet meets the immediate needs of our application, but that
    doesn’t mean that there aren’t ways to improve it! The following are a few ideas
    you might pursue on your own that could enhance the scene. Join the BJS and the
    Space-Truckers community by posting and sharing your snippets over at the Space-Truckers
    Discussions board ([https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions))
    or over on the BJS forums ([https://forum.babylonjs.com/](https://forum.babylonjs.com/)).
    The discussion boards and forum aren’t just there to share your accomplishments,
    however. They’re a place where you can post questions or issues you’re encountering,
    with a thriving community that loves to help.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的代码片段满足了我们应用的即时需求，但这并不意味着没有改进它的方法！以下是一些你可能自己尝试的想法，这些想法可以增强场景。通过在Space-Truckers讨论板([https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions))或BJS论坛([https://forum.babylonjs.com/](https://forum.babylonjs.com/))上发布和分享你的代码片段来加入BJS和Space-Truckers社区。讨论板和论坛不仅是为了分享你的成就，它们还是一个你可以发布你遇到的问题或问题的场所，有一个热爱帮助的活跃社区。
- en: 'You could do the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行以下操作：
- en: Remove the helix-like appearance of the planet trails. The spin animation and
    the trail mesh are both parented to the planet. As the planet rotates, the trail
    mesh gets twisted around. One approach to fixing this could be to add a **TransformNode**
    to the scene and parent the planet to it. Keep the spin animation on the planet,
    but associate and point the **TrailMesh** and the orbital animation at the **TransformNode**.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除行星轨迹的螺旋状外观。旋转动画和轨迹网格都归行星所有。当行星旋转时，轨迹网格会被扭曲。解决这个问题的一个方法可能是向场景中添加一个**TransformNode**，并将行星归它所有。保持行星上的旋转动画，但将**TrailMesh**和轨道动画关联并指向**TransformNode**。
- en: Replace the star’s current texture with a particle system. The **ParticleHelper**
    has a **sun** effect that can bring a cool effect to the scene. The docs on this
    are at [https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper](https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper),
    where there’s also useful information on how to create your own custom **ParticleSets**.
    The easiest (and perhaps the best) option for creating custom particle systems
    is to use the NME ([https://nme.babylonjs.com/](https://nme.babylonjs.com/)) in
    **Particle** mode. The NME is to shaders as the PG is to scenes, meaning that
    just as you can save and share PG snippets, you can also save and share NME snippets.
    The difference between them in this context is that you can use NME snippets in
    the PG but not vice versa.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用粒子系统替换恒星当前纹理。**ParticleHelper**有一个**太阳**效果，可以为场景带来酷炫的效果。有关此内容的文档在[https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper](https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper)，其中还提供了有关如何创建自定义**ParticleSets**的有用信息。创建自定义粒子系统的最简单（也许是最好的）选项是使用**粒子**模式的NME
    ([https://nme.babylonjs.com/](https://nme.babylonjs.com/))。NME对于着色器来说就像PG对于场景一样，这意味着就像你可以保存和分享PG片段一样，你也可以保存和分享NME片段。它们在这个上下文中的区别在于，你可以在PG中使用NME片段，但不能反过来。
- en: Add a comet on an **inclined** orbit that brightens and shows a tail as it gets
    closer to the star on its elliptical path through the scene. An inclination simply
    means that the object includes the y axis as it “bobs” up and down through the
    orbital plane. An elliptical orbit has the same period as a circular orbit, with
    an orbital radius that’s the same as the ellipse’s **semi-major axis** (the length
    of the line dividing the ellipse along its long side), but the difference is that
    rather than having a constant velocity along its path, objects moving in an elliptical
    orbit travel fastest at their closest approach (**apopse**).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个**倾斜**轨道上添加一颗彗星，当它在其椭圆轨道通过场景中的恒星时，它会变得更亮并显示出尾巴。倾斜仅仅意味着物体包含y轴，当它“上下摆动”穿过轨道平面时。椭圆轨道具有与圆形轨道相同的周期，轨道半径与椭圆的**半长轴**（沿着椭圆长边分割椭圆的线的长度）相同，但不同之处在于，沿着其路径移动的物体在椭圆轨道上以最接近点（**近点**）的速度最快。
- en: 'Give the outer-most gas giant planet a ring system. One way to approach this
    would be to create a flat torus mesh using the MeshBuilder, and then use BJS **Parenting**
    to attach the rings to a planet. Another approach that builds on the prior would
    be to use the **Solid Particle System** (**SPS**) to generate tens or even hundreds
    of small rocks to comprise the rings. Consider it a preview of what’s coming up:
    in the next chapter, we’ll be using the SPS to create an asteroid belt.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给最外层的气态巨行星添加一个环系。一种方法是使用MeshBuilder创建一个平面环状网格，然后使用BJS的**父子关系**将环系附着到行星上。另一种基于前者的方法是使用**固体粒子系统**（**SPS**）生成数十甚至数百个小岩石来构成环系。这可以看作是即将到来的预览：在下一章中，我们将使用SPS来创建一个小行星带。
- en: Add clouds specular, terrain bump (normal) map to a rocky planet to make it
    look like real-world planets. The BJS **Asset Library** has a height map of the
    earth’s terrain along with various textures for cloud and ground effects. The
    **Materials Library** also has some interesting options to explore for making
    the planets unique and attractive – have fun!
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向一个多岩石的行星添加云的镜面反射、地形凹凸（法线）图，使其看起来像真实世界的行星。BJS的**资产库**包含了地球地形的等高图以及各种云和地面效果的纹理。**材质库**也有一些有趣的选项可以探索，以使行星独特且吸引人——享受乐趣！
- en: Make the camera pan and zoom around the system cinematically. Choose one of
    the animation methods we discussed previously, targeting the scene’s `camera`.
    Depending on your methods and plan, you may want to unset or change the camera’s
    target to be a **TransformNode**. This new, non-rendered node acts as a sort of
    “mark” that can be moved around to change the camera’s view as the position changes.
    Another option is to explore a different type of camera than the current **ArcRotateCamera**.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让摄像机以电影般的方式在系统中平移和缩放。选择我们之前讨论过的动画方法之一，针对场景的`camera`。根据你的方法和计划，你可能想要取消或更改摄像机的目标为**TransformNode**。这个新的、不可渲染的节点充当一种“标记”，可以移动以改变摄像机视图，从而改变位置。另一个选项是探索不同于当前**ArcRotateCamera**的摄像机类型。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of this chapter, we’ve refreshed and ramped ourselves up on
    BJS by creating a simple scene in the PG. We learned about different ways of animating
    a scene along with how to load textures and other assets from the BJS Asset Library.
    Hopefully, we’ve had a little bit of fun along the way, but this is just the tip
    of the iceberg when it comes to what’s in store in later chapters. If you needed
    a little bit of a refresher on BJS, hopefully this has gotten you warmed up and
    ready to go. If you’re new to BJS, then I hope this has empowered you to push
    onward to the next chapter. Coming up in the next chapter, we will begin Space-Truckers
    in earnest by setting up a local development environment along with source control
    and debugging.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们通过在PG中创建一个简单的场景来刷新和提升我们对BJS的了解。我们学习了如何以不同的方式动画化场景，以及如何从BJS资产库中加载纹理和其他资产。希望我们在旅途中有点乐趣，但这只是冰山一角，关于后续章节中将要介绍的内容。如果你需要一点BJS的复习，希望这已经让你热身并准备好继续前进。如果你是BJS的新手，那么希望这已经赋予你继续前进到下一章的信心。在下一章中，我们将认真开始Space-Truckers，通过设置本地开发环境、源代码控制和调试来着手进行。
- en: Further Reading
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The BJS documentation site contains an enormous wealth of knowledge and content.
    Here are some relevant pages from the docs that go into more detail on the topics
    covered in this chapter:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: BJS文档网站包含大量的知识和内容。以下是文档中一些相关的页面，它们更详细地介绍了本章中涉及的主题：
- en: Once you’ve gotten how to do individual Animations, read about Animation sequencing,
    grouping, and combining, starting at [https://doc.babylonjs.com/divingDeeper/animation/sequenceAnimations](https://doc.babylonjs.com/divingDeeper/animation/sequenceAnimations).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你学会了如何进行单个动画，请阅读有关动画序列、分组和组合的内容，从[这里](https://doc.babylonjs.com/divingDeeper/animation/sequenceAnimations)开始。
- en: Learn about importing different files types of assets into a scene and how loaders
    work at [https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes](https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何将不同类型的资产文件导入场景，以及加载器的工作原理，请参阅[这里](https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes)。
- en: 'The Diving Deeper: The Mesh section has details on how the GlowLayer works
    at [https://doc.babylonjs.com/divingDeeper/mesh/glowLayer](https://doc.babylonjs.com/divingDeeper/mesh/glowLayer).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探索：在[Mesh部分](https://doc.babylonjs.com/divingDeeper/mesh/glowLayer)有关于GlowLayer如何工作的详细信息。
- en: For details on the different types of cameras and their properties, see [https://doc.babylonjs.com/divingDeeper/cameras/camera_introduction](https://doc.babylonjs.com/divingDeeper/cameras/camera_introduction).
    Something that is worth mentioning is that whenever you see the docs mention `FreeCamera`,
    `TouchCamera`, or `GamepadCamera`, you should instead substitute or use `UniversalCamera`,
    as it supersedes those three, which are retained for backward compatibility reasons.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于不同类型相机及其属性的详细信息，请参阅[这里](https://doc.babylonjs.com/divingDeeper/cameras/camera_introduction)。值得一提的是，无论你在文档中看到提到`FreeCamera`、`TouchCamera`或`GamepadCamera`，你应该用`UniversalCamera`来替换或使用，因为它取代了这三个，保留它们是为了向后兼容的原因。
