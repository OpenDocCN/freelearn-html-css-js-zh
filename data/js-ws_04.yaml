- en: 4\. JavaScript Libraries and Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. JavaScript库和框架
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to use JavaScript frameworks and
    libraries to perform different tasks; demonstrate event handling with jQuery;
    use popular JavaScript Frameworks; name the do's and don'ts of using a framework;
    and build a library
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用JavaScript框架和库执行不同的任务；使用jQuery演示事件处理；使用流行的JavaScript框架；列出使用框架的注意事项和禁忌；并构建一个库
- en: In this chapter, you will learn how and when to combine your source code with
    external software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何以及何时将你的源代码与外部软件结合。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapters, you learned how to utilize conditional logic, loops,
    and the most common data structures. These form the groundwork and essentials
    for writing programs and building complex JavaScript applications. Still, building
    actual software is an inherently challenging task; focusing on only business logic
    is even more so. Therefore, as developers, we often rely on external software
    that lets us dedicate ourselves to the source code that's the most relevant to
    our product or business. This software does this by simplifying specific tasks
    and abstracting away complexity for us. Those pieces of external software are
    what we refer to as **frameworks** or **libraries**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何利用条件逻辑、循环和最常见的数据结构。这些构成了编写程序和构建复杂JavaScript应用程序的基础和要素。然而，构建实际的软件是一个固有的挑战性任务；仅仅关注业务逻辑更是如此。因此，作为开发者，我们经常依赖外部软件，使我们能够专注于与我们产品或业务最相关的源代码。这些软件通过简化特定任务和为我们抽象复杂性来实现这一点。这些外部软件组件就是我们所说的**框架**或**库**。
- en: 'The following are some of the tasks that modern JavaScript frameworks can support
    us with:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些现代JavaScript框架可以为我们提供的任务：
- en: Performance rendering of complex or dynamic single-page applications (SPAs)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂或动态单页应用程序（SPA）的性能渲染
- en: Managing ongoing dataflow between the controllers and views of client-side applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理客户端应用程序控制器和视图之间的持续数据流
- en: Creating sophisticated animations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建复杂的动画
- en: Creating with fast and straightforward server APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用快速直观的服务器API进行创建
- en: Before we dive deeper into the whys and the wherefores of using external code,
    we need to clarify what the difference is between the terms "framework" and "library."
    This will be the topic of the following section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨使用外部代码的原因和目的之前，我们需要明确“框架”和“库”这两个术语之间的区别。这将是下一节的主题。
- en: Framework versus Library
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架与库的比较
- en: 'Library describes an external collection of functions that perform a given
    task. These functions are made accessible to us as users of the library via APIs.
    One useful library is `lodash`, which can, for example, remove all duplicated
    values from an array:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 库描述了一个执行特定任务的函数的外部集合。这些函数通过API使我们这些库的用户能够访问。一个有用的库是`lodash`，例如，它可以从数组中移除所有重复的值：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Frameworks, on the other hand, are a particular form of library. They are reusable
    code frames that build the foundation of a JavaScript application. In contrast
    to libraries, which extend your code with functionality, a framework can stand
    alone and is enhanced with your source code to create an app as you like.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，框架是库的一种特定形式。它们是可重用的代码框架，为JavaScript应用程序构建基础。与扩展你代码的功能的库不同，框架可以独立存在，并通过你的源代码增强来创建你喜欢的应用程序。
- en: 'A popular framework is `Vue.js`, which we can use as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的框架是`Vue.js`，我们可以如下使用它：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, in general, there is more complexity to a framework than there
    is to a library. Nonetheless, both are equally important to software development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一般来说，框架比库更复杂。尽管如此，两者对软件开发同等重要。
- en: Despite the technical differences between libraries and frameworks, we are going
    to use those terms interchangeably. Another synonym you'll encounter in the JavaScript
    world to describe external source code is "package." One of those packages you
    may encounter in JS resources is `Vanilla.js`. We'll have a look at it in the
    next section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管库和框架之间存在技术差异，我们将会将这些术语互换使用。在JavaScript世界中，描述外部源代码的另一个同义词是“包”。在JS资源中，你可能遇到的一个这样的包是`Vanilla.js`。我们将在下一节中对其进行探讨。
- en: Vanilla.js
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vanilla.js
- en: This specific framework follows the informal convention of including the JavaScript
    file extension with the name `nameOfFramework.js`. However, vanilla.js is not
    a framework; it's not even a library. People referring to `vanilla.js` are talking
    about plain JavaScript without any external code or tooling. The name is a running
    gag within the JavaScript community because some developers and non-developers
    think we need to use a framework for everything we build. We will discuss why
    this isn't the case later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的框架遵循非正式惯例，在名称中包含JavaScript文件扩展名`nameOfFramework.js`。然而，vanilla.js不是一个框架；它甚至不是一个库。提到`vanilla.js`的人正在谈论没有外部代码或工具的纯JavaScript。这个名字在JavaScript社区中是一个流行的笑话，因为一些开发者和非开发者认为我们为构建的每一件事都需要使用框架。我们将在稍后讨论这不是原因。
- en: Popular JavaScript Frameworks
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行JavaScript框架
- en: We have just looked at lodash.js, a library that helps developers handle data
    structures; (to be used, for example, making arrays unique) and Vue.js, a framework
    for building modular and dynamic user interfaces. These are just two examples
    of quite popular and widely used JS frameworks/libraries. In addition to those,
    there is a vast and ever-growing number of external packages you can choose from.
    Each one of them is useful for solving one specialized set of problems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解了lodash.js，这是一个帮助开发者处理数据结构的库；（例如，用于创建唯一的数组）以及Vue.js，这是一个用于构建模块化和动态用户界面的框架。这些只是两个非常流行且广泛使用的JS框架/库的例子。除了这些，还有大量不断增长的第三方包可供选择。每个包都有助于解决一组特定的专业问题。
- en: A few modern and often used alternatives that support creating browser applications
    are, for instance, React.js, Vue.js, and Angular.js. Other libraries that help
    you store and manage data in your app are MobX, VueX, and Redux.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些现代且常用的替代方案，支持创建浏览器应用程序，例如React.js、Vue.js和Angular.js。其他帮助你在应用程序中存储和管理数据的库包括MobX、VueX和Redux。
- en: Again, others can transform source code so that it supports older browser engines,
    for example, **Babel**, or handle and manipulate time for you, such as moment.js.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，其他人可以将源代码转换，使其支持旧版浏览器引擎，例如**Babel**，或者为你处理和操作时间，例如moment.js。
- en: Then, there are frameworks such as Express.js or Hapi that let you create simple,
    easy-to-maintain, and performant REST APIs for Node.js.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有像Express.js或Hapi这样的框架，让你能够为Node.js创建简单、易于维护和性能良好的REST API。
- en: Some packages make building **command-line interfaces** (**CLIs**) or desktop
    applications easy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包使构建**命令行界面**（**CLIs**）或桌面应用程序变得容易。
- en: Most build and productivity tools for the JavaScript ecosystem are provided
    to the community as a library, too. Webpack, Parcel, and Gulp are a few of these
    tools.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript生态系统的构建和生产工具都作为库提供给社区。Webpack、Parcel和Gulp就是这些工具中的几个。
- en: 'Not all of the available libraries are equally popular or useful. Their popularity
    depends on a few key facts:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的库并不都是同样流行或有用。它们的流行程度取决于几个关键事实：
- en: Whether they fix a problem that bothers many developers
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否解决了许多开发者烦恼的问题
- en: How well their API is defined and structured
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的API定义和结构有多好
- en: The quality of their documentation
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的文档质量
- en: The level of performance optimization
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优化的水平
- en: Keep these in mind when crafting a package that you want to become well known.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个希望广为人知的包时，请记住这些。
- en: Everlasting jQuery
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 永恒的jQuery
- en: 'One evergreen library that has been around for over a decade is jQuery. It
    touches almost every web app in one way or another and belongs in the toolkit
    of everybody who builds browser applications:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个已经存在超过十年的常青库是jQuery。它几乎以某种方式触及了每个Web应用程序，并且属于每个构建浏览器应用程序的人的工具箱：
- en: '![Figure 4.1: jQuery documentation'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：jQuery文档](img/C14377_04_01.jpg)'
- en: '](img/C14377_04_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_04_01.jpg)'
- en: 'Figure 4.1: jQuery documentation'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：jQuery文档
- en: '**jQuery** was not the first but was definitely among the earliest JavaScript
    libraries ever to be used by developers all over the world to make their jobs
    easier. Since it was first released, a lot of maintainers and engineers have contributed
    to making jQuery what it is today – namely, a robust and essential part of the
    modern internet that offers lots of different functionalities.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**jQuery**不是第一个，但无疑是世界上第一个被开发者用来简化工作的JavaScript库之一。自从它首次发布以来，许多维护者和工程师都为使jQuery成为今天的样子做出了贡献——即现代互联网的一个强大和基本组成部分，提供了许多不同的功能。'
- en: 'jQuery provides, but is not limited to providing, the following features:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供，但不仅限于提供以下功能：
- en: DOM manipulations
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM操作
- en: Event handling
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理
- en: Animated effects and transitions
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画效果和过渡
- en: We will see how to do these things when we look at jQuery in more detail later
    in this chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章后面更详细地查看jQuery时，我们将看到如何做这些事情。
- en: Where to Find and How to Use External Code
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪里可以找到外部代码以及如何使用
- en: There are a few different approaches when it comes to including libraries in
    your program. Depending on those approaches, we get packages from different places.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在将库包含到您的程序中时，有几种不同的方法。根据这些方法，我们从不同的地方获取包。
- en: One is to copy the library's source code and to handle it as we wish. This approach
    is the most secure in the sense that we have all the control of the software and
    can customize it to fit our needs. However, by doing so, we give up compatibility
    and automated updates and patches. Most open-source projects host their code on
    GitHub or any other version control platform. Therefore, it's rather easy to access
    and fork the package's code. As soon as we download the source code, we can do
    whatever we want to get it working with our software. Possible solutions could
    be hosting it on our **cloud distribution network** (**CDN**) and accessing it
    from there or bundling it with our source code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是复制库的源代码，并按我们的意愿处理它。从安全性的角度来看，这种方法是最安全的，因为我们完全控制软件，可以将其定制以适应我们的需求。然而，这样做，我们就放弃了兼容性和自动更新和补丁。大多数开源项目将它们的代码托管在GitHub或其他版本控制平台上。因此，访问和分叉包代码相当容易。一旦我们下载了源代码，我们就可以做任何我们想做的事情，使其与我们的软件一起工作。可能的解决方案包括将其托管在我们的**云分发网络**（**CDN**）上，并从那里访问它，或者将其与我们的源代码捆绑在一起。
- en: 'Another approach is downloading the package from a CDN from the client at runtime.
    The most popular CDN to exclusively host JavaScript libraries is [cdnjs.com](http://cdnjs.com).
    It hosts thousands of libraries you can include in your markup without you having
    to worry about where to store it or how to upgrade it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在运行时从客户端下载CDN上的包。专门托管JavaScript库的最受欢迎的CDN是[courseds.com](http://cdnjs.com)。它托管了数千个库，您可以在标记中包含它们，而无需担心存储位置或如何升级：
- en: '![Figure 4.2: Downloading a package from cdnjs.com'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：从cdnjs.com下载包'
- en: '](img/C14377_04_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_04_02.jpg)'
- en: 'Figure 4.2: Downloading a package from cdnjs.com'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：从cdnjs.com下载包
- en: 'The following is an example of how you''d include Vue.js with your markup:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在您的标记中包含Vue.js的示例：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you include packages by loading them from the browser during runtime, you
    have to be aware of the order of the script tags. They're loaded from top to bottom.
    Therefore, if you switched the two script tags in the preceding example, console.log
    would print that there is no `Vue.js` loaded, even though, eventually, it will
    be.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行时从浏览器中加载包来包含它们，您必须注意脚本标签的顺序。它们是从上到下加载的。因此，如果您在先前的示例中交换了两个脚本标签，console.log将打印出没有加载`Vue.js`，尽管最终它会加载。
- en: 'The previous approach gained lots of popularity and is now by far the most
    common due to the development of the JavaScript ecosystem in recent years. It
    involves the **Node.js Package Manager** (**npm**). npm is a tool that, as its
    name suggests, takes care of JavaScript packages within the Node.js ecosystem.
    npm itself consists of three parts:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法获得了巨大的流行度，并且由于近年来JavaScript生态系统的开发，现在已经成为最常见的方法。它涉及到**Node.js包管理器**（**npm**）。npm是一个工具，正如其名称所暗示的，负责Node.js生态系统中的JavaScript包。npm本身由三个部分组成：
- en: The website [npmjs.com](http://lodash.com), for hosting all the documentation
    and package searches
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[npmjs.com](http://lodash.com)网站，用于托管所有文档和包搜索'
- en: The CLI that gets installed with `Node.js`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`Node.js`一起安装的CLI
- en: 'The registry, which is where all of the modules are stored and made installable:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储并使所有模块可安装的注册表：
- en: '![Figure 4.3: NPM website'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图4.3：NPM网站'
- en: '](img/C14377_04_03.jpg)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_04_03.jpg)'
- en: 'Figure 4.3: NPM website'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：NPM网站
- en: Using npm requires a `Node.js` version to be installed on your machine and any
    tool to bundle all your JavaScript together to make it executable in the browser.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用npm需要在您的机器上安装一个`Node.js`版本，以及任何工具来打包您所有的JavaScript代码，使其在浏览器中可执行。
- en: 'Then, all you have to do is install any module you can find on npm:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您只需安装您在npm上找到的任何模块：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command then stores the package in a particular folder, called **node_modules**.
    This folder contains all the source code of the libraries you installed, and from
    there, the bundler will join it into your application during build time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将包存储在特定文件夹中，称为**node_modules**。此文件夹包含您安装的所有库的源代码，在构建时间，打包器将它们与您的应用程序连接起来。
- en: All of the aforementioned methods to include libraries and frameworks with your
    source code are valid and have their preferred use cases. However, it's likely
    that you are going to use the latter the most as new projects are set up within
    the `Node.js` ecosystem, which is where modules and npm come from, naturally.
    Nonetheless, knowing how to use external resources without npm can come in handy
    when you want something much more comfortable and quicker than an entire project
    setup. Therefore, let's perform an exercise in which we will load a third-party
    library into our code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的所有方法都是有效的，并且各有其首选的使用场景。然而，你很可能在 `Node.js` 生态系统中设置新项目时最常使用后者，因为模块和 npm 就是从那里自然产生的。尽管如此，了解如何在没有
    npm 的情况下使用外部资源仍然很有用，当你想要比整个项目设置更舒适、更快捷时。因此，让我们进行一个练习，我们将把第三方库加载到我们的代码中。
- en: 'Exercise 4.01: Using a Third-Party Library in Your Code'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.01：在您的代码中使用第三方库
- en: 'As we''ve already discovered, using external software, namely libraries and
    frameworks, is an extremely useful skill as it can save a lot of resources and
    help you build highly functional apps. In this exercise, we are going to find
    and utilize a library ourselves. We''ll use the `lodash` library to create an
    array of unique values. Let''s get started:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所发现的，使用外部软件，即库和框架，是一项极其有用的技能，因为它可以节省大量资源并帮助您构建高度功能的应用程序。在这个练习中，我们将自己查找并使用一个库。我们将使用
    `lodash` 库来创建一个包含唯一值的数组。让我们开始吧：
- en: 'Create a new HTML file:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 HTML 文件：
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Find the CDN URL for the latest `lodash` version. To do so, navigate to `cdnjs.com`
    and search for lodash, and then copy the URL highlighted in the figure:![Figure
    4.4: Search result of lodash at cdnjs.com'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找最新版本的 `lodash` 的 CDN URL。为此，请导航到 `cdnjs.com` 并搜索 lodash，然后复制图中突出显示的 URL：![图
    4.4：cdnjs.com 上的 lodash 搜索结果
- en: '](img/C14377_04_04.jpg)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14377_04_04.jpg](img/C14377_04_04.jpg)'
- en: 'Figure 4.4: Search result of lodash at cdnjs.com'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.4：cdnjs.com 上的 lodash 搜索结果
- en: 'To look at the `lodash` documentation, navigate to [lodash.com](http://lodash.com).
    There, you can use the search bar to find the "`uniq`" function:![Figure 4.5:
    lodash.com documentation for uniq function'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看 `lodash` 文档，请导航到 [lodash.com](http://lodash.com)。在那里，你可以使用搜索栏来查找 "`uniq`"
    函数：![图 4.5：lodash.com 的 uniq 函数文档
- en: '](img/C14377_04_05.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14377_04_05.jpg](img/C14377_04_05.jpg)'
- en: 'Figure 4.5: lodash.com documentation for uniq function'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.5：lodash.com 的 uniq 函数文档
- en: 'Load the CDN URL in a script tag''s `src` attribute. To do so, paste the URL
    you previously copied in *step 2*:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签的 `src` 属性中加载 CDN URL。为此，粘贴你在 *步骤 2* 中复制的 URL：
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create another `script` tag and write JS code using *lodash* to make an array,
    `[1,5,5,2,6,7,2,1]`, that contains `unique` values:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个 `script` 标签，并使用 *lodash* 编写 JS 代码来创建一个包含 `unique` 值的数组 `[1,5,5,2,6,7,2,1]`：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open your HTML, including the JavaScript, in a browser and verify that you
    created an array with unique values inside the browser''s development tools console:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开你的 HTML，包括 JavaScript，并验证你是否在浏览器开发工具控制台中创建了一个包含唯一值的数组：
- en: '![Figure 4.6: Unique array values in the browser''s development tools console'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图 4.6：浏览器开发工具控制台中的唯一数组值'
- en: '](img/C14377_04_06.jpg)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14377_04_06.jpg](img/C14377_04_06.jpg)'
- en: 'Figure 4.6: Unique array values in the browser''s development tools console'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：浏览器开发工具控制台中的唯一数组值
- en: In this exercise, we used the *lodash* library to create an array that contains
    sole unique values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了 *lodash* 库来创建一个包含唯一值的数组。
- en: jQuery versus Vanilla.js
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery 与 Vanilla.js
- en: Earlier, in the *Everlasting jQuery* section of this chapter, we had a look
    at jQuery and how it has an exceptional standing in the JavaScript community.
    To demonstrate why libraries and frameworks, but mainly jQuery, became popular,
    we will compare it to `Vanilla.js` (plain JS).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 *永恒的 jQuery* 部分中，我们之前查看过 jQuery 以及它在 JavaScript 社区中的卓越地位。为了展示为什么库和框架，尤其是
    jQuery，变得流行，我们将将其与 `Vanilla.js`（纯 JS）进行比较。
- en: Manipulating the DOM
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作 DOM
- en: 'If we wanted to fade out and then remove one element in plain JavaScript, we
    would write verbose and less comprehensive code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在纯 JavaScript 中淡出并删除一个元素，我们将编写冗长且不够全面的代码：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On the other hand, with jQuery, we could have all this in just one line of
    understandable code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用 jQuery，我们可以在一行可理解的代码中完成所有这些操作：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Making XHR Requests
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送 XHR 请求
- en: 'A fundamental functionality of modern web pages and applications is requesting
    additional resources or data from remote servers. Every browser provides interfaces
    to execute these so-called XHR requests. Those interfaces can be used from JavaScript.
    As we can see in the following code examples, jQuery, compared to vanilla.js,
    lets us write clean and self-explanatory code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网页和应用程序的一个基本功能是从远程服务器请求额外的资源或数据。每个浏览器都提供了执行这些所谓的XHR请求的接口。这些接口可以从JavaScript中使用。正如我们可以在以下代码示例中看到，与vanilla.js相比，jQuery让我们能够编写干净且易于理解的代码：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In comparison to the preceding snippet, the code for making calls to a server
    is much clear and readable in jQuery. It is more readable in the sense that it
    is very clear and understandable regarding what exactly the function needs as
    parameters and what it is going to do. Let''s have a look at a `POST` Ajax request
    to the `/example/api` URL with a specified payload data and also a function that
    gets triggered when the request is successful:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的代码片段相比，在jQuery中调用服务器的代码更加清晰易读。它更易读，因为它非常清晰易懂，关于函数需要什么参数以及它将要做什么非常明确。让我们看看一个向`/example/api`
    URL发送的`POST` Ajax请求，带有指定的有效负载数据和当请求成功时被触发的函数：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: jQuery assigns itself to the $ variable. Hence, in the code examples,`$.functionName`
    could be replaced with `jquery.functionName`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery将自己分配给`$`变量。因此，在代码示例中，`$.functionName`可以替换为`jquery.functionName`。
- en: We could go on and show you more use cases where jQuery gets us faster to our
    goal than raw JS would. Instead, in the following exercises, we will use the library
    and gain some first-hand experience with it. Specifically, we will be writing
    code to handle a button-click event, once with jQuery and once with plain JavaScript.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续展示更多jQuery比原生JS更快达到目标的使用场景。相反，在接下来的练习中，我们将使用这个库，并从中获得一些第一手经验。具体来说，我们将编写代码来处理按钮点击事件，一次使用jQuery，一次使用纯JavaScript。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The dev tools in all modern major browsers have adapted to `$`, but only as
    a wrapper for `document.querySelector`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代主流浏览器中的开发者工具都已适应了`$`符号，但仅作为`document.querySelector`的包装器。
- en: 'Exercise 4.02: Handling Click Events with jQuery'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02：使用jQuery处理点击事件
- en: 'In this exercise, we will identify how jQuery can help us react to events that
    get propagated when the target (in our case, a button) gets clicked. Let''s get
    started:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将了解jQuery如何帮助我们响应当目标（在我们的例子中，是一个按钮）被点击时传播的事件。让我们开始吧：
- en: 'Create a new HTML file including a button tag with the ID `exampleButton`.
    This button will be our target:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的HTML文件，包括一个具有ID `exampleButton`的按钮标签。这个按钮将是我们的目标：
- en: '[PRE11]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Find the latest jQuery CDN URL on [cdnjs.com](http://cdnjs.com).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[cdnjs.com](http://cdnjs.com)上找到最新的jQuery CDN URL。
- en: 'Read the jQuery documentation for .`on()`([https://api.jquery.com/on/](https://api.jquery.com/on/))
    erytion:![Figure 4.7: JQuery.com Documentation for .on()'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读jQuery文档中的.`on()`函数([https://api.jquery.com/on/](https://api.jquery.com/on/))![图4.7：JQuery.com上的.on()函数文档]
- en: '](img/C14377_04_07.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14377_04_07.jpg](img/C14377_04_07.jpg)'
- en: 'Figure 4.7: jquery.com Documentation for .on()'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.7：JQuery.com上的.on()函数文档
- en: 'Load in the CDN URL:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载CDN URL：
- en: '[PRE12]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a script tag containing code that logs a `Hello World` message to the
    console when you click the button:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含代码的脚本标签，当点击按钮时，将`Hello World`消息记录到控制台：
- en: '[PRE13]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Make sure you place the `script` tag after the button tag.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将`script`标签放置在按钮标签之后。
- en: Open the HTML in your browser and open the dev tool console.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开HTML文件，并打开开发者工具控制台。
- en: 'Press the `Click me.` button and verify that it prints `Hello World` to the
    console:![Figure 4.8: Hello world output using jQuery click events'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`点击我`按钮，并验证它是否将`Hello World`打印到控制台：![图4.8：使用jQuery点击事件输出Hello World]
- en: '](img/C14377_04_08.jpg)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14377_04_08.jpg](img/C14377_04_08.jpg)'
- en: 'Figure 4.8: Hello world output using jQuery click events'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：使用jQuery点击事件输出Hello World
- en: In this exercise, you handled an event that got fired by the browser on a button
    click using jQuery. The handler you implemented prints `Hello World` to the browser's
    console as soon as the `click me` button is pressed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你使用jQuery处理了一个由浏览器在按钮点击时触发的事件。你实现的处理程序会在按下`点击我`按钮后立即将`Hello World`打印到浏览器的控制台。
- en: You also saw how easy it is to use a library such as jQuery to do work that,
    otherwise, you would need to do manually.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你也看到了如何轻松地使用像jQuery这样的库来完成那些否则需要手动完成的工作。
- en: Handling a click event, however, is not particularly hard to do in vanilla.js
    either, as you'll see in the next exercise.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在vanilla.js中处理点击事件也不是特别困难，你将在下一个练习中看到。
- en: 'Exercise 4.03: Handling the Same Event with Vanilla.js'
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.03：使用Vanilla.js处理相同的事件
- en: 'In contrast to the previous exercise, this one demonstrates how to create a
    handler that gets triggered on a click event using plain JavaScript. Let''s get
    started:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个练习相比，这个练习演示了如何使用纯JavaScript创建一个在点击事件上被触发的处理程序。让我们开始吧：
- en: 'Create a new HTML file that includes a button tag with the ID exampleButton:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的HTML文件，其中包含一个ID为`exampleButton`的按钮标签：
- en: '[PRE14]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a script tag containing vanilla.js code that logs a `Hello World` message
    to the dev tools console when you click the button. `addEventListener` is a vanilla
    API provided to us by the browser. It takes `eventType` and `handlerFunction`
    as parameters:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含vanilla.js代码的脚本标签，当点击按钮时，将“Hello World”消息记录到开发者工具控制台。`addEventListener`是浏览器为我们提供的原生API。它接受`eventType`和`handlerFunction`作为参数：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, make sure you place the `script` tag after the button tag.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次确保将`script`标签放在按钮标签之后。
- en: 'Open the HTML in your browser and open the dev tools console. Press the "Click
    me." button and verify that it prints "Hello World" to the console:![Figure 4.9:
    Hello World output using Vanilla.js'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开HTML文件，并打开开发者工具控制台。点击“Click me.”按钮，并验证它是否将“Hello World”打印到控制台：![图4.9：使用Vanilla.js的“Hello
    World”输出
- en: '](img/C14377_04_09.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14377_04_09.jpg]'
- en: 'Figure 4.9: Hello World output using Vanilla.js'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：使用Vanilla.js的“Hello World”输出
- en: In the previous two exercises, we added an event listener to a button. We did
    so once with the help of jQuery and the other time with no external code and instead
    used the native APIs that the browser provided us with.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个练习中，我们向一个按钮添加了事件监听器。我们使用jQuery做了一次，其他时候没有使用外部代码，而是使用了浏览器为我们提供的原生API。
- en: UI Animation Using jQuery
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jQuery进行UI动画
- en: 'In addition to the use cases for jQuery that we have seen in the code examples
    in the Manipulating the DOM and Making XHR Requests sections and in *Exercise
    4.02: Handling Click Events with jQuery*, there is another important functionality
    that `jQuery` provides us with: animating the user interface (UI).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在“操作DOM和发送XHR请求”部分的代码示例中看到的jQuery用法，以及在*练习4.02：使用jQuery处理点击事件*中，还有一个重要的功能是`jQuery`为我们提供的：用户界面（UI）动画。
- en: Animations contribute to a more engaging website and can mean that your users
    enjoy the experience of using your application more. Often reactions to user input
    are animated to highlight the fact that the interaction has been acknowledged
    or that something has changed. For example, appearing elements could be animated
    or placeholders inside of input fields. Proceed with the following exercise to
    implement the former UI animation example yourself.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 动画有助于使网站更具吸引力，并且可能意味着用户在使用你的应用程序时享受的体验更佳。通常，对用户输入的反应会被动画化，以突出显示交互已被认可或发生了变化。例如，出现的元素可以动画化，或者输入字段内的占位符可以动画化。继续以下练习，自己实现前面的UI动画示例。
- en: 'Exercise 4.04: Animating a "Peek-a-boo" on Button Click'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.04：在按钮点击时动画化“Peek-a-boo”
- en: In this exercise, you will build on the knowledge you have gained regarding
    how to handle events using jQuery. The relevant part, however, will be animating
    an element on the page.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将基于你使用jQuery处理事件的知识来构建。然而，相关部分将是动画化页面上的一个元素。
- en: 'Whenever the `"Peek…`" button is clicked, the `…a-boo` headline will show up.
    Let''s get started:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每当点击“Peek…`”按钮时，`…a-boo`标题就会显示出来。让我们开始吧：
- en: 'Create a new HTML file that includes a button tag with the ID `Peek...`, a
    headline with the ID `…a-boo`, and a `display: none` style attribute:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个新的HTML文件，其中包含一个ID为`Peek...`的按钮标签、一个ID为`…a-boo`的标题，以及`display: none`样式属性：'
- en: '[PRE16]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Load the latest `jQuery` CDN URL, from `cdnjs.com` (see *Exercise 2, Handling
    Click Events with jQuery, step 2*), inside a script tag:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签内加载最新的`jQuery` CDN URL，从`cdnjs.com`（见*练习2，使用jQuery处理点击事件，步骤2*）：
- en: '[PRE17]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a script tag containing the code to select the peek button and add an
    `onClick` event listener:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含选择peek按钮并添加`onClick`事件监听器代码的脚本标签：
- en: '[PRE18]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside the new script tag, write additional code to select the `aboo` headline
    and use the `jQuery.fadeToggle` function to animate the headline so that it''s
    fading in and fading out:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的脚本标签内，编写额外的代码来选择`aboo`标题，并使用`jQuery.fadeToggle`函数来动画化标题，使其淡入淡出：
- en: '[PRE19]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Open the HTML page in your browser and click the `peek` button.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开HTML页面，并点击`peek`按钮。
- en: 'You should see the `aboo` headline fading in and fading out whenever you click
    the `peek` button:![Figure 4.10: Animated output using the Click button'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你点击`peek`按钮时，你应该看到`aboo`标题淡入和淡出：![图4.10：使用Click按钮的动画输出
- en: '](img/C14377_04_10.jpg)'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_04_10.jpg)'
- en: 'Figure 4.10: Animated output using the Click button'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：使用Click按钮的动画输出
- en: In this exercise, you used `jQuery` to execute yet another type of task in the
    browser. Animations in UIs can be as simple as our fading example, but they can
    also be very complex when building games or creating 3D animations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你使用了`jQuery`在浏览器中执行另一种类型的任务。UI中的动画可以像我们的淡入淡出示例一样简单，但在构建游戏或创建3D动画时，它们也可以非常复杂。
- en: By now, you have an idea of what jQuery, and also other libraries or frameworks,
    can help you do. In the next section, we will explore why and when it may be wiser
    to renounce external source code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经对jQuery以及其他库或框架能帮助你做什么有了概念。在下一节中，我们将探讨为什么以及何时放弃外部源代码可能更明智。
- en: Frameworks versus Core JavaScript
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架与核心JavaScript
- en: So far, we've spoken a lot about why, how, and in what situations to use libraries.
    But we are yet to discuss when and why it would be a better idea not to rely on
    them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了很多关于为什么、如何以及在什么情况下使用库的原因。但我们还没有讨论何时以及为什么不依赖它们可能是一个更好的主意。
- en: 'First of all, all of the things that frameworks and libraries do can be done
    by ourselves. In a business context, or for the sake of development speed, however,
    we usually decide to buy them when facing the "make-or-buy" decision. But sometimes,
    we should keep in mind that adding external sources to our program or even founding
    it on top of these sources expands the amount of source code we have. Increasing
    the overall size of the necessary resources is particularly unpleasant for us
    JavaScript developers who build client-facing applications since we should be
    optimizing for delivering performance (how fast the app loads on the client).
    In general, more JavaScript code leads to the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，框架和库所能做的所有事情我们自己都可以做到。在商业环境中，或者为了提高开发速度，我们通常在面临“自制或购买”决策时选择购买。但有时，我们应该记住，将外部源代码添加到我们的程序中，甚至基于这些源代码构建，会增加我们拥有的源代码量。对于构建面向客户端的应用程序的JavaScript开发者来说，增加所需资源的整体大小尤其令人不快，因为我们应该优化性能（应用程序在客户端加载的速度）。一般来说，更多的JavaScript代码会导致以下情况：
- en: Longer download times
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更长的下载时间
- en: Longer parsing times
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更长的解析时间
- en: More delayed execution
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更晚的执行延迟
- en: Potentially blocked rendering or usability of the app
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能阻止应用程序的渲染或可用性
- en: Though we have complex optimization algorithms such as tree shaking or dead
    code elimination, which help us cope with huge bundle sizes in these cases, often,
    the better choice is to do the task at hand on our own.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有复杂的优化算法，如摇树或死代码消除，这些算法有助于我们应对这些情况下的巨大包大小，但通常，最好的选择是亲自完成手头的任务。
- en: Another aspect to consider is the security of our application. Some libraries
    or frameworks may open up attack vectors that we cannot control because we do
    not have full ownership or understanding of the involved code. However, the most
    popular libraries are concerned with the security of their packages and are also
    very fast at releasing patches for known vulnerabilities.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的方面是我们应用程序的安全性。一些库或框架可能会打开我们无法控制的攻击向量，因为我们没有完全拥有或理解涉及的代码。然而，最受欢迎的库非常关注它们包的安全性，并且对于已知漏洞的补丁发布也非常迅速。
- en: To provide an actual use case that spells out the negative impact a library
    or framework may have on our application, in the following two exercises, we will
    create a list and render it to the screen. The first one will make use of an external
    library, whereas the second one will be written in raw JavaScript.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个实际案例，说明库或框架可能对我们应用程序产生的负面影响，在接下来的两个练习中，我们将创建一个列表并将其渲染到屏幕上。第一个将使用外部库，而第二个将使用原生JavaScript编写。
- en: 'Exercise 4.05: Rendering a List of To-Dos Using React'
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.05：使用React渲染待办事项列表
- en: 'In this exercise, we''re going to display a few list tags as bullet points
    of an imaginary `todo` list. To do so, we''ll be using a massively popular library
    called `react.js` and its complementary `react-dom.js`. Let''s get started:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将显示一些列表标签作为假想`todo`列表的列表项。为此，我们将使用一个非常流行的库`react.js`及其互补的`react-dom.js`。让我们开始吧：
- en: 'Create a new empty HTML file with a head and a div tag with the `root` ID inside
    the HTML body:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML body内部创建一个带有head和具有`root` ID的div标签的新空HTML文件：
- en: '[PRE20]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Go to `cdnjs.com` and to get the latest `react.js` and `react-dom.js` CDN URLs
    and load the URLs into a script tag inside the HTML head:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `cdnjs.com` 获取最新的 `react.js` 和 `react-dom.js` CDN 网址，并将这些网址加载到 HTML 头部内的脚本标签中：
- en: '[PRE21]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use `react.js` and `react-dom` to create three list items and render them to
    the `root` `div`-element:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `react.js` 和 `react-dom` 创建三个列表项并将它们渲染到 `root` `div` 元素中：
- en: '[PRE22]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Open the HTML page inside your browser and make sure that your `todo` list items
    are displayed correctly.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器中的 HTML 页面，确保你的 `todo` 列表项正确显示。
- en: 'Open the network tab of your browser''s dev tools and have a glance at how
    many kilobytes of JavaScript was loaded:![Figure 4.11: Size of the JavaScript
    that was loaded into the Network tab'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器开发者工具的网络标签页，查看加载了多少千字节的 JavaScript：![图 4.11：加载到网络标签页中的 JavaScript 的大小
- en: '](img/C14377_04_11.jpg)'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_04_11.jpg)'
- en: 'Figure 4.11: Size of the JavaScript that was loaded into the Network tab'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：加载到网络标签页中的 JavaScript 的大小
- en: In this exercise, you learned where to find and how to use React.js. Although
    in this exercise you simply created a small, static list of To-Dos, `React.js`
    lets you create complex, dynamic UIs without you having to worry about native
    browser APIs that you would normally need to create such UIs. However, as we mentioned
    previously, using a framework also comes at a cost, measured in kilobytes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你学习了在哪里找到以及如何使用 React.js。尽管在这个练习中你只是创建了一个小型的静态待办事项列表，`React.js` 允许你创建复杂、动态的用户界面，而无需担心通常需要创建此类用户界面的原生浏览器
    API。然而，正如我们之前提到的，使用框架也有代价，以千字节来衡量。
- en: Next, you will learn how to do the same task without React. Afterward, you will
    be able to understand the kilobytes versus complexity trade-off when building
    applications.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何在不使用 React 的情况下完成相同的任务。之后，你将能够理解在构建应用程序时千字节与复杂性的权衡。
- en: 'Exercise 4.06: Rendering a List of To-Dos without a Library'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.06：不使用库渲染待办事项列表
- en: 'In the previous exercise, we used the trendy library known as React.js to load
    more than `37 KB` (in ZIP format) and a couple of hundred bytes for the HTML,
    including the script tags, to create and render a list of three items. In this
    exercise, we are going to do the same thing, except we will utilize all the functionality
    that''s already provided by the browser. Let''s get started:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们使用了流行的库 React.js，加载了超过 `37 KB`（ZIP 格式）以及几百字节的 HTML，包括脚本标签，以创建和渲染三个项目的列表。在这个练习中，我们将做同样的事情，但我们将利用浏览器已经提供的所有功能。让我们开始吧：
- en: 'Create a new empty HTML file with a div tag with an ID of `root` inside the
    HTML body:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空 HTML 文件，并在 HTML 体的内部包含一个具有 `root` ID 的 div 标签：
- en: '[PRE23]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a script tag and write some JS to create three list items and render
    them to the `root` div element:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个脚本标签，并编写一些 JS 代码来创建三个列表项并将它们渲染到 `root` div 元素中：
- en: '[PRE24]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open the HTML page inside your browser and make sure your `todoListItems` are
    presented correctly.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器中的 HTML 页面，确保你的 `todoListItems` 正确显示。
- en: 'Open the network tab of your browser''s dev tools and have a glance at how
    many kilobytes of JavaScript was loaded:![Figure 4.12: Loading the JavaScript''s
    download size without using a library'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器开发者工具的网络标签页，查看加载了多少千字节的 JavaScript：![图 4.12：不使用库加载 JavaScript 的下载大小
- en: '](img/C14377_04_12.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_04_12.jpg)'
- en: 'Figure 4.12: Loading the JavaScript''s download size without using a library'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：不使用库加载 JavaScript 的下载大小
- en: There's exactly no, that is, 0 KB, additional JavaScript. That gives us 37 KB
    of downloading, parsing, and execution advantage over the method using `react.js`,
    all while achieving the same thing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 完全没有，也就是说，0 KB 的额外 JavaScript。这使我们比使用 `react.js` 的方法在下载、解析和执行方面有 37 KB 的优势，同时实现了相同的功能。
- en: Of course, this is a simplified example. In general, real-world applications
    are more complex than our exercise. Nonetheless, you may often find yourself in
    an analogous situation where performance is a thing to consider and the task can
    plausibly be done using `vanilla.js`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个简化的例子。一般来说，现实世界中的应用程序比我们的练习更复杂。尽管如此，你可能会发现自己经常处于类似的情况，其中性能是一个需要考虑的因素，并且可以使用
    `vanilla.js` 合理地完成这项任务。
- en: We have spoken in detail about what libraries and frameworks are and what they
    can help us to do. In order to really grasp what libraries may look like internally
    and how easy it actually is to build one, we'll be creating one ourselves in the
    following exercise.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细讨论了库和框架是什么以及它们可以帮助我们做什么。为了真正理解库可能看起来是什么样的以及构建一个库实际上有多容易，我们将在接下来的练习中自己创建一个。
- en: 'Exercise 4.07: Creating a Library Yourself'
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.07：自己创建一个库
- en: Our library won't be capable of much at first, but you may want to put some
    effort into it and extend it as you wish.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们库最初可能功能有限，但你可以投入一些精力，并根据需要扩展它。
- en: '`HeadlineCreator.js` is our library''s name. It''s a good name because it already
    hints at what it does; that is, it creates headlines. Technically speaking, our
    library will do the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeadlineCreator.js` 是我们库的名称。这是一个好名字，因为它已经暗示了它所做的事情；即创建标题。从技术角度讲，我们的库将执行以下操作：'
- en: 'Be accessible on the global window object of the current browser tab, just
    as we''ve seen with jQuery before: window.headlineCreator.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前浏览器标签的全局窗口对象上可访问，就像我们之前使用 jQuery 时看到的那样：`window.headlineCreator`。
- en: Provide a single method called createHeadline.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个名为 `createHeadline` 的单一方法。
- en: Allow us (through the createHeadline method) to create a headline with the given
    text and append it to a given parent element.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们（通过 `createHeadline` 方法）使用给定的文本创建一个标题，并将其附加到给定的父元素。
- en: Take care of error handling for us, for instance, if we forgot to define some
    text to be displayed or passed an invalid selector for the parent element
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们处理错误处理，例如，如果我们忘记定义要显示的文本或为父元素传递了无效的选择器
- en: To verify that our library is working and having an example of its usage, we
    will create, additional to creating the library itself, an HTML page including
    script tags using our HeadlineCreator.js library.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了验证我们的库是否正常工作，并展示其用法的一个示例，我们将创建一个 HTML 页面，包括使用我们的 HeadlineCreator.js 库的 script
    标签，除了创建库本身之外。
- en: 'Let''s get started:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Create an empty HTML file with a head tag, a body tag, and a div tag with an
    ID of `root` inside it:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 HTML 文件，包含一个 head 标签、一个 body 标签，以及一个 ID 为 `root` 的 div 标签：
- en: '[PRE25]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Load a local JS file with the name `headlineCreator.js` inside a `script` tag:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `script` 标签内加载一个名为 `headlineCreator.js` 的本地 JS 文件：
- en: '[PRE26]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create the `headlineCreator.js` file inside of the same directory you created
    the empty HTML file in.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一目录中创建 `headlineCreator.js` 文件，该目录中创建了空的 HTML 文件。
- en: 'Inside the JavaScript file, create an IIFE and assign it to the `headlineCreator`
    variable:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JavaScript 文件内部，创建一个 IIFE 并将其分配给 `headlineCreator` 变量：
- en: '[PRE27]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: IIFE stands for "immediately invoked function expression." This sounds more
    complicated than it is. IIFEs are functions that are executed at the very same
    moment they are defined. One use case for them in frameworks or libraries is to
    prevent name collisions with variables that are used in the source code. This
    includes the library. For example, using a create function within your library
    can cause weird side effects since this is a very common and ambiguous name. Hence,
    the library could be a different function than it was supposed to be.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IIFE 代表“立即执行函数表达式”。这个名字听起来比实际要复杂。IIFE 是在定义的同时立即执行的功能。在框架或库中，它们的用例之一是防止与源代码中使用的变量发生名称冲突。这包括库。例如，在库中使用创建函数可能会导致奇怪的副作用，因为这是一个非常常见且模糊的名字。因此，库可能是一个与预期不同的不同函数。
- en: 'Within the IIFE, create another function and name it `createHeadline`. This
    function takes two parameters, `text` and `parentElementSelector`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在立即执行函数表达式（IIFE）内部，创建另一个函数并将其命名为 `createHeadline`。这个函数接受两个参数，`text` 和 `parentElementSelector`：
- en: '[PRE28]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside the IIFE `headlineCreator`, add a r`eturn` statement. This `return`
    statement will return an object with a single key named `createHeadline` that
    has the value of the same name (just like the function name we created in the
    previous step):'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IIFE `headlineCreator` 内部添加一个 `return` 语句。这个 `return` 语句将返回一个对象，该对象有一个名为 `createHeadline`
    的唯一键，其值与函数名相同（就像我们在上一步中创建的函数名一样）：
- en: '[PRE29]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Extend the new function with a DOM query to look for an element with the `parentElementSelector`
    that is passed as an argument to the `createHeadline` function.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 DOM 查询扩展新函数，以查找作为 `createHeadline` 函数参数传递的 `parentElementSelector` 指定的元素。
- en: 'Assign the result of the DOM query to a variable called `parentElement`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 DOM 查询的结果分配给一个名为 `parentElement` 的变量：
- en: '[PRE30]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, create an `h1` tag element and set the `innerText` attribute of this
    element to the `text` parameter that is passed to the function:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `h1` 标签元素，并将此元素的 `innerText` 属性设置为传递给函数的 `text` 参数：
- en: '[PRE31]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Lastly, append the created headline to the node that we stored in `parentElement`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将创建的标题附加到我们存储在 `parentElement` 中的节点：
- en: '[PRE32]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Refresh your HTML page and inside the dev tools console, call the `window.headlineCreator.createHeadline`
    function with any parameter you''d like. Then, view the result:![Figure 4.13:
    The window.headlineCreator.createHeadline function in the console and its output'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新你的HTML页面，并在开发者工具的控制台中调用`window.headlineCreator.createHeadline`函数，使用你想要的任何参数。然后，查看结果：![图4.13：控制台中的window.headlineCreator.createHeadline函数及其输出
- en: '](img/C14377_04_13.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_04_13.jpg)'
- en: 'Figure 4.13: The window.headlineCreator.createHeadline function in the console
    and its output'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.13：控制台中的window.headlineCreator.createHeadline函数及其输出
- en: 'If you''d like to, you can add some error handling and return the newly created
    headline element since that''s considered good practice in such a case:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以添加一些错误处理并返回新创建的标题元素，因为在这种情况下这被认为是良好的实践：
- en: '[PRE33]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To test the error handling, simply call the `headlineCreator` function without
    the text parameter:![Figure 4.14: Error message in the console'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试错误处理，只需调用`headlineCreator`函数而不传递文本参数：![图4.14：控制台中的错误信息
- en: '](img/C14377_04_14.jpg)'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_04_14.jpg)'
- en: 'Figure 4.14: Error message in the console'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.14：控制台中的错误信息
- en: 'Last but not least, add a script tag to the HTML file and call the `headlineCreator`
    library from there so that every time the HTML is loaded, a headline is created:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，在HTML文件中添加一个script标签，并从那里调用`headlineCreator`库，这样每次加载HTML时都会创建一个标题：
- en: '[PRE34]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This results in the following output:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Figure 4.15: The HeadlineCreator.js library created'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15：创建的HeadlineCreator.js库'
- en: '](img/C14377_04_15.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_04_15.jpg)'
- en: 'Figure 4.15: The HeadlineCreator.js library created'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：创建的HeadlineCreator.js库
- en: Going through this exercise has taught you that the inner workings of a library
    don't have to be complex and hard to understand. The `headlineCreator` library
    lets the user create and append a headline to a given parent element. Even though
    this is a simplified and almost trivial use case, it demonstrates the basic process
    of building and using a library – that is, having a programmatic problem, finding
    a solution to it, abstracting the complexity, and providing it to others through
    a library.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，你已经了解到库的内部工作原理不必复杂且难以理解。`headlineCreator`库允许用户创建并将标题添加到指定的父元素中。尽管这是一个简化和几乎微不足道的用例，但它展示了构建和使用库的基本过程——即存在一个程序性问题，找到解决它的方法，抽象复杂性，并通过库提供给他人。
- en: 'Activity 4.01: Adding an Animation to the To-Do List Application'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：将动画添加到待办事项应用中
- en: 'In this activity, you have been asked to animate the `todo` list application
    that you have been building in the activities from the preceding chapters. Do
    so using one of the following three libraries:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你被要求使用前面章节中的活动之一来动画化你一直在构建的`todo`列表应用。你可以使用以下三个库中的任何一个来完成此操作：
- en: jQuery
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery
- en: Velocity.js
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Velocity.js
- en: Anime.js
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anime.js
- en: The resulting `todo` list should animate the to-dos whenever you click the Shuffle
    button. It's up to you what exact animation you use, but nonetheless, I advise
    you to start with something simple, such as fading the to-dos.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击Shuffle按钮时，生成的`todo`列表应该会动画化待办事项。你可以使用任何你想要的精确动画，但我建议你从一个简单的动画开始，比如淡入淡出待办事项。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的步骤如下：
- en: 'Choose one of the frameworks. To gain a better understanding of how to use
    them, search for them online and have a look at their documentation ([https://jquery.com](https://jquery.com),
    [http://velocityjs.org](http://velocityjs.org), [https://animejs.com](https://animejs.com)):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '选择一个框架。为了更好地理解如何使用它们，在网上搜索它们并查看它们的文档（[https://jquery.com](https://jquery.com),
    [http://velocityjs.org](http://velocityjs.org), [https://animejs.com](https://animejs.com)):'
- en: Go to [cdnjs.com](http://cdnjs.com) and get the jQuery CDN URL.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[cdnjs.com](http://cdnjs.com)获取jQuery CDN URL。
- en: Load the library into the head tag of your existing Todo-List-HTML using a script
    tag. This will enable you to use jQuery within your code.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用script标签将库加载到现有Todo-List-HTML的head标签中。这将使你能够在代码中使用jQuery。
- en: Inside `activity.js`, you need to change the `todoEle` variable. Change it to
    a jQuery element.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity.js`中，你需要更改`todoEle`变量。将其更改为jQuery元素。
- en: Inside the `replaceListElements` function, you can now use functions on the
    `todoEle` element that jQuery provides to you.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`replaceListElements`函数中，你现在可以使用jQuery为你提供的`todoEle`元素上的函数。
- en: Hide and clear what's inside the element using the jQuery functions.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用jQuery函数隐藏并清除元素内的内容。
- en: Inside the for loop, create the `liEle` list item element, set the text contest,
    and append it to the `listEle` list element.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 for 循环内部，创建 `liEle` 列表项元素，设置文本内容，并将其追加到 `listEle` 列表元素中。
- en: Finally, slowly fade in the new sorted `todo` list, that is, `listEle`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，缓慢地将新的排序好的 `todo` 列表，即 `listEle`，淡入。
- en: Now, open the HTML in your browser and click the `Shuffle` button. The to-do
    list should fade out, shuffle, and fade in again. You will see the expected output.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开 HTML 并点击 `Shuffle` 按钮。待办事项列表应该淡出、打乱顺序，然后再次淡入。你应该看到预期的输出。
- en: Now, we'll use the `Velocity.js` method. Go to [cdnjs.com](http://cdnjs.com)
    and get the `velocity.js` CDN URL.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `Velocity.js` 方法。访问 [cdnjs.com](http://cdnjs.com) 并获取 `velocity.js`
    CDN URL。
- en: Load the library into the head tag of your existing Todo-List-HTML using a script
    tag. This will allow you to use `velocity.js` within your code.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用脚本标签将库加载到现有的 Todo-List-HTML 的 head 标签中。这将允许你在代码中使用 `velocity.js`。
- en: Inside the `replaceListElements` function, you can now use `Velocity.js` to
    hide (by setting opacity to 0) the list element, `listEle`, and then empty the
    elements inside of it.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `replaceListElements` 函数内部，你现在可以使用 `Velocity.js` 将列表元素 `listEle` 隐藏（通过将不透明度设置为
    0），然后清空其内部元素。
- en: To fade the list element back in, animate `listEle` using `Velocity.js` and
    set the opacity to 1\. Set the code after the `for` loop.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将列表元素淡入，使用 `Velocity.js` 动画 `listEle` 并将不透明度设置为 1。在 `for` 循环之后设置代码。
- en: Now, open the HTML in your browser and click the `Shuffle` button. The to-do
    list should fade out, shuffle, and fade in again.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开 HTML 并点击 `Shuffle` 按钮。待办事项列表应该淡出、打乱顺序，然后再次淡入。
- en: Finally, using the `Animae` method, go to [cdnjs.com](http://cdnjs.com) and
    get the `Anime.js` CDN URL.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `Animae` 方法，访问 [cdnjs.com](http://cdnjs.com) 并获取 `Anime.js` CDN URL。
- en: Load the library into the head tag of your existing Todo-List-HTML using a `script`
    tag. This will allow you to use `Anime.js` within your code.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用脚本标签将库加载到现有的 Todo-List-HTML 的 head 标签中。这将允许你在代码中使用 `Anime.js`。
- en: Inside the `replaceListElements` function, you can now use `Anime.js` to move
    (by using `translateX = -1000`) the list element, `listEle`, out of view and then
    empty the elements inside of it.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `replaceListElements` 函数内部，你现在可以使用 `Anime.js` 将列表元素 `listEle` 移出视图（使用 `translateX
    = -1000`），然后清空其内部元素。
- en: To show the newly shuffled to-do list, use Anime.js to animate the `listEle`
    list element back into view (`translateX = 0`). Do so inside a timeout to ensure
    that the shuffling has been done already.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示重新打乱的待办事项列表，使用 Anime.js 动画 `listEle` 列表元素回到视图（`translateX = 0`）。在超时内这样做，以确保打乱操作已经完成。
- en: 'Now, open the HTML in your browser and click the `Shuffle` button. The to-do
    list should fade out, shuffle, and fade in again. It should appear as follows:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开 HTML 并点击 `Shuffle` 按钮。待办事项列表应该淡出、打乱顺序，然后再次淡入。它应该看起来如下：
- en: '![Figure 4.16: Animated todo list on click'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.16：点击时动画待办事项列表'
- en: '](img/C14377_04_16.jpg)'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_04_16.jpg)'
- en: 'Figure 4.16: Animated to-do list on click'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：点击时动画待办事项列表
- en: Note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 719.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 719 页找到。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a dive into the vast world of JavaScript libraries.
    We started with an explanation of the terms library and framework. From there,
    we had a look at a few popular frameworks and what they can help us with. The
    exercises in this chapter demonstrated where we can find external packages and
    how we can make use of them. Some of the things we did with these libraries included
    creating fading effects, removing duplicated entries from a list, and rendering
    DOM elements to the document. We discussed the disadvantages of using external
    source code as well. However, the biggest achievement of this chapter was creating
    our own library that helped us create headlines. We finished this chapter by making
    use of various libraries to enhance our to-do list with some nice UI effects.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探索了 JavaScript 库的广阔世界。我们首先解释了库和框架这两个术语。从那里，我们查看了一些流行的框架以及它们能帮助我们做什么。本章中的练习展示了我们可以在哪里找到外部包以及如何使用它们。我们使用这些库所做的事情包括创建淡入淡出效果、从列表中删除重复条目以及将
    DOM 元素渲染到文档中。我们还讨论了使用外部源代码的缺点。然而，本章最大的成就是创建了我们自己的库，这个库帮助我们创建标题。我们通过利用各种库来增强待办事项列表的
    UI 效果来结束本章。
- en: The next chapter will show us how to work with data in JavaScript. We will gain
    an understanding of how data is represented, how it can be passed around, and
    how specific types can be cast into different types.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将向我们展示如何在 JavaScript 中处理数据。我们将了解数据是如何表示的，它是如何被传递的，以及如何将特定类型转换为不同的类型。
