- en: Introducing Vuex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuex 简介
- en: Vuex is a library that we can use with Vue.js to manage different states in
    an application. If you are building a small application that does not require
    much data exchange between its components, you are better off not using this library.
    However, as your application grows, complexities crawl along with it. There will
    be several components in the application, and, most obviously, you will need to
    exchange data from one component to another or share the same data across multiple
    components. That is when Vuex comes to the rescue.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 是一个库，我们可以与 Vue.js 一起使用来管理应用中的不同状态。如果你正在构建一个不需要组件之间大量数据交换的小型应用，你最好不使用这个库。然而，随着你的应用增长，复杂性也随之增加。应用中将有多个组件，最明显的是，你需要从一个组件交换数据到另一个组件，或者跨多个组件共享相同的数据。这就是
    Vuex 出现的时候。
- en: Vue.js also provides an `emit` method to pass data between different components,
    which we used in previous chapters. As your application grows, you might also
    want to update data across several components when your data gets updated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 还提供了一个 `emit` 方法，用于在不同组件之间传递数据，我们在前面的章节中已经使用过。随着你的应用增长，当数据更新时，你可能还希望更新多个组件中的数据。
- en: So, Vuex provides a centralized place to store all the pieces of data in our
    application. Whenever data changes, this new set of data will be stored in this
    centralized place. Also, all of the components that want to use that data will
    be fetched from the store. This means that we have a single source to store all
    the data, and all the components that we build will be able to access that data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Vuex 提供了一个集中位置来存储我们应用中的所有数据片段。每当数据发生变化时，这个新的数据集将存储在这个集中位置。此外，所有想要使用这些数据的组件都将从存储中获取。这意味着我们有一个单一的数据存储源，我们构建的所有组件都将能够访问这些数据。
- en: 'Let''s first get acquainted with some of the terminology that come with Vuex:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先熟悉一些 Vuex 伴随的术语：
- en: '**State**: This is an object that contains the data. Vuex uses a single state
    tree, which means that it is a single object that contains all the pieces of data
    for the application.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态（State）**：这是一个包含数据的对象。Vuex 使用一个单一的状态树，这意味着它是一个包含应用所有数据片段的单个对象。'
- en: '**Getters**: It is used to fetch data from the state tree.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取器（Getters）**：它用于从状态树中获取数据。'
- en: '**mutations**: They are the methods that change the data in the state tree.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**突变（mutations）**：它们是改变状态树中数据的方法。'
- en: '**Actions**: They are the functions that perform mutations.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作（Actions）**：它们是执行突变（mutations）的函数。'
- en: We will discuss each of these in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中讨论这些内容。
- en: Traditional multi-web page application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统多网页应用
- en: In traditional multi web page application, when we build a web application and
    open a website by navigating to the browser, it requests the web server to fetch
    that page and serve it to the browser. When we click on a button on the same website,
    it again requests the web server to fetch another page and again serve it. This
    process happens for every single interaction we do on the website. So, basically,
    the website gets reloaded on every single interaction, which consumes a lot of
    time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的多网页应用中，当我们构建一个网页应用并通过导航到浏览器打开网站时，它会请求网页服务器获取该页面并将其提供给浏览器。当我们点击同一网站上的按钮时，它再次请求网页服务器获取另一个页面并再次提供。这个过程在我们对网站进行的每一次交互中都会发生。所以，基本上，网站在每次交互时都会重新加载，这消耗了大量的时间。
- en: 'The following is a sample diagram that explains how a multi-page application
    works:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个解释多页面应用工作原理的示例图：
- en: '![](img/358fe12c-59b3-4c01-840a-49d48a1c85b9.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/358fe12c-59b3-4c01-840a-49d48a1c85b9.jpg)'
- en: When a request is sent from the browser, the request is sent to the server.
    The server then returns the HTML content and serves a whole new whole page.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器发送请求时，请求被发送到服务器。然后服务器返回 HTML 内容，并加载一个全新的页面。
- en: '**Multi Page Applications **(**MPA**) can provide several benefits as well.
    It''s not a matter of whether to choose MPA or a **Single Page Application** (**SPA**),
    but it all depends on the content of your application. If your application contains
    a lot of user interaction, you should go for an SPA; however, if the only purpose
    of your application is to serve the users with the content, you can go with an
    MPA. We will explore more about SPAs and MPAs later in this chapter.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**多页面应用（MPA**）同样可以提供一些好处。选择 MPA 还是 **单页面应用（SPA**）并不是问题，关键在于你应用的内容。如果你的应用包含大量的用户交互，你应该选择
    SPA；然而，如果你的应用唯一目的是向用户提供内容，你可以选择 MPA。我们将在本章后面进一步探讨 SPAs 和 MPAs。'
- en: An introduction to SPAs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页面应用（SPA）简介
- en: Contrary to the traditional MPAs, SPAs are designed specifically for web-based applications.
    The SPA fetches all the data when you first load the website in the browser. Once
    all the data is fetched, you don't need to fetch any more data. When any other
    interactions are done, that data is fetched over the internet, without having
    to send a request to the server and without reloading the page. This means that
    SPAs are much faster than the traditional MPAs. However, since SPAs fetch everything
    at once on the first load, the first page load time could be slow. Some applications
    that have SPA integration are Gmail, Facebook, GitHub, Trello, and so on. SPAs
    are all about making the user experience better by putting the content on one
    single page and not making the users wait for the information they want.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的MPAs不同，SPA是专门为基于Web的应用程序设计的。SPA在浏览器中首次加载网站时获取所有数据。一旦所有数据都获取完毕，你就不需要再获取更多数据。当进行任何其他交互时，这些数据将通过互联网获取，无需向服务器发送请求，也不需要重新加载页面。这意味着SPA比传统的MPAs要快得多。然而，由于SPA在首次加载时一次性获取所有数据，因此首次页面加载时间可能会较慢。一些集成了SPA的应用程序包括Gmail、Facebook、GitHub、Trello等等。SPA的核心理念是通过将内容放在一个单独的页面上，并避免让用户等待他们想要的信息，从而提升用户体验。
- en: 'The following is a sample diagram of how SPAs work:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是一个关于SPA工作原理的示例图：
- en: '![](img/ff9dc3a1-41a1-45fd-a694-0fd9084e8584.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff9dc3a1-41a1-45fd-a694-0fd9084e8584.jpg)'
- en: The website has all the content that it needs on the first page-load. When a
    user clicks on something, it just fetches the information for that particular
    area and refreshes only that part of the web page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网站在首次页面加载时就包含了所有需要的内容。当用户点击某个内容时，它只会获取该特定区域的信息，并只刷新网页的该部分。
- en: SPA versus MPA
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPA与MPA的比较
- en: SPA and MPA serve different purposes. You may want to use one over the other,
    depending on your needs. Before you start your application, ensure that you are
    clear about the kind of application that you want to build.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SPA和MPA服务于不同的目的。你可能需要根据你的需求选择使用其中之一。在你开始你的应用之前，确保你清楚你想要构建的应用类型。
- en: Pros of using MPAs
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MPAs的优点
- en: MPAs are the best approach if you want to make your application SEO friendly.
    Google can crawl different pages of your application by searching the keywords
    that you assign on each page, which is not possible in an SPA since it has only
    a single page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让你的应用对搜索引擎优化（SEO）友好，多页面应用（MPAs）是最佳选择。谷歌可以通过搜索你在每个页面分配的关键词来爬取你应用的不同页面，而在单页面应用（SPA）中这是不可能的，因为SPA只有一个页面。
- en: Cons of using MPAs
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MPA的缺点
- en: 'There are a few cons of using MPAs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MPAs有一些缺点：
- en: The development work for an MPA is much greater than for an SPA because the
    frontend and backend are tightly coupled.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MPA的开发工作比SPA要多得多，因为前端和后端是紧密耦合的。
- en: MPAs have tightly coupled frontend and backend, which makes it harder to separate
    the work between frontend and backend developers.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MPAs的前端和后端紧密耦合，这使得前端和后端开发者之间的工作分离变得更加困难。
- en: Pros of using SPAs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SPA的优点
- en: 'SPAs provides a lot of benefits:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SPA提供了许多好处：
- en: '**Reduced server response tim**e: SPAs fetch all the data needed on the first
    load of the website. With such an application, the server does not need to reload
    the resources on the website. If new data needs to be fetched, it only fetches
    the updated piece of information from the server, unlike multi-page apps, decreasing
    the server response time significantly.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少服务器响应时间**：SPA在网站首次加载时获取所有所需数据。使用此类应用，服务器无需重新加载网站上的资源。如果需要获取新数据，它只会从服务器获取更新的信息片段，与多页面应用不同，这显著减少了服务器响应时间。'
- en: '**Better user interaction**: The decrease in server response time ultimately
    improves the user experience. With every interaction, the user gets a more quickly
    rendered page, which means *happy customers*.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的用户交互**：服务器响应时间的减少最终改善了用户体验。每次交互，用户都会得到一个渲染速度更快的页面，这意味着*满意的客户*。'
- en: '**Flexibility to change the UI**: SPAs do not have a coupled frontend and backend.
    This means that we can change the frontend and completely rewrite it without having
    to worry about breaking anything on the server side.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改变UI的灵活性**：SPA没有耦合的前端和后端。这意味着我们可以更改前端并完全重写它，而无需担心服务器端会出问题。'
- en: '**Data caching**: SPAs cache the data in the local storage. It only makes a
    single request the first time and saves the data. This makes the application available
    even when the internet is cut off.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据缓存**：SPA在本地存储中缓存数据。它只在第一次请求时发送一次请求并保存数据。这使得即使在断网的情况下，应用仍然可用。'
- en: Cons of using  SPAs
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SPA的缺点
- en: 'There are few downsides of using SPAs as well:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SPA也有一些缺点：
- en: SPAs are not SEO friendly. Since everything is done on a single page, the crawlability
    is very low.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPA对搜索引擎优化（SEO）不友好。由于所有操作都在单个页面上完成，可爬性非常低。
- en: You cannot share a particular piece of information with others since there is
    the only one link to the page.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于只有一个链接到该页面的链接，因此您无法与他人共享特定的信息。
- en: Security concerns are much greater with SPAs than in MPAs.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与MPA相比，单页应用（SPA）的安全问题更为严重。
- en: An introduction to Vuex
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuex简介
- en: Vuex is a state management library that is specifically designed to work with
    applications built with Vue.js. It is centralized state management for Vuex.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex是一个专为与Vue.js构建的应用程序一起使用的状态管理库。它是Vuex的集中式状态管理。
- en: Core concepts of Vuex
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuex的核心概念
- en: 'We got a glimpse of these core concepts in the introduction. Now, let''s dive
    into a little bit more detail on each of these concepts:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在简介中简要了解了这些核心概念。现在，让我们更详细地探讨每个概念：
- en: '![](img/ed51d06e-04d0-4f06-beee-3a3f7d86ae7f.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed51d06e-04d0-4f06-beee-3a3f7d86ae7f.png)'
- en: 'The preceding diagram is a simple diagram that explains how Vuex works. Initially,
    everything is stored in a state, which is the single source of truth. Every view
    component fetches data from this state. Whenever something needs to be changed,
    actions perform mutations on the data and store it back in the state:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示是一个简单的图解，说明了Vuex是如何工作的。最初，所有内容都存储在状态中，这是唯一的真相来源。每个视图组件都会从这个状态中获取数据。每当需要更改时，动作会在数据上执行变动并将其存储回状态：
- en: '![](img/f4523972-cb5b-4dd8-8639-4bc547976d96.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4523972-cb5b-4dd8-8639-4bc547976d96.png)'
- en: When we open our application in the browser, all the Vue components will be
    loaded. When we click on a button to fetch certain information from a component,
    that component dispatches an action that performs mutations on the data. When
    the mutation is successfully done, the state object is updated and new values
    are used. Then, we can use the new state for our components and display it in
    the browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中打开我们的应用程序时，所有Vue组件都将被加载。当我们点击按钮从组件获取某些信息时，该组件将触发一个执行数据变动的动作。当变动成功完成后，状态对象被更新，并使用新值。然后，我们可以使用新状态来为我们的组件提供数据，并在浏览器中显示。
- en: Creating a simple Vuex application
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的Vuex应用程序
- en: We will start a fresh new application to learn the basics of Vuex. Let's get
    started.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从头开始创建一个新的应用程序来学习Vuex的基础知识。让我们开始吧。
- en: 'Let''s first create a new application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个新的应用程序：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code snippet will ask you few questions about the application
    setup. You can choose what you want to keep. I will go with the following configuration:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将询问您有关应用程序设置的一些问题。您可以选择您想要保留的内容。我将选择以下配置：
- en: '![](img/433b4667-cdfc-434e-ae05-d12d2a43efec.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/433b4667-cdfc-434e-ae05-d12d2a43efec.png)'
- en: 'After the installation, navigate to the project directory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，导航到项目目录：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next thing to do is to run the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是运行以下命令：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, run the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，运行以下命令：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding command will spin up your server and open a port in `localhost:8080`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将在`localhost:8080`上启动服务器并打开一个端口。
- en: Installing Vuex
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Vuex
- en: 'The next step is to install `vuex`. To do that, run the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装`vuex`。为此，请运行以下命令：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting up Vuex
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Vuex
- en: Now, let's create a `store` folder to manage the `vuex` in our application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`store`文件夹来管理我们应用程序中的`vuex`。
- en: Creating a store file
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储文件
- en: 'In the `src` directory, create a `store` folder and `store.js` file. Then,
    add the following to the `store.js` file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`目录中创建一个`store`文件夹和一个`store.js`文件。然后，将以下内容添加到`store.js`文件中：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code block, the line `Vue.use(Vuex)` imports the Vuex library.
    Without this, we will not be able to use any of the `vuex` functionalities. Now,
    let's build a store object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`Vue.use(Vuex)`这一行导入了Vuex库。没有这个，我们将无法使用任何`vuex`功能。现在，让我们构建一个存储对象。
- en: State
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: 'In the same `store.js` file, add the following lines of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的`store.js`文件中，添加以下代码行：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we set the default state for a variable called `count`
    as `0` and exported a Vuex state through the store.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将名为`count`的变量的默认状态设置为`0`，并通过store导出了一个Vuex状态。
- en: 'Now, we will need to modify `src/main.js`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改`src/main.js`：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code imports the store file that we just created, and we can access
    this variable in our vue components.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码导入了我们刚刚创建的存储文件，我们可以在我们的Vue组件中访问这个变量。
- en: Let's move on to creating a component that will fetch this store data. A default
    component is created when we create a new application with Vue. If we look into
    the `src/components` directory, we will find a file called `HelloWorld.vue`. Let's
    use the same component, `HelloWorld.vue`, or you can create a new one. Let's modify
    this file to access the `count`, which we defined in the state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个将获取此存储数据的组件。当我们使用Vue创建一个新应用时，会创建一个默认组件。如果我们查看`src/components`目录，我们会找到一个名为`HelloWorld.vue`的文件。让我们使用相同的组件`HelloWorld.vue`，或者你可以创建一个新的。让我们修改这个文件以访问我们在状态中定义的`count`。
- en: 'In `src/components/HelloWorld.vue`, add the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/components/HelloWorld.vue`中添加以下代码：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the final folder structure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最终的文件夹结构：
- en: '![](img/1eef5543-52e1-4b33-9e48-a7efbc92001a.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1eef5543-52e1-4b33-9e48-a7efbc92001a.png)'
- en: 'The preceding screenshot should print the default value of count in the `HelloWorld.vue`
    component. If you navigate to `http://localhost:8080/#/`, you should see the following
    screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图应该在`HelloWorld.vue`组件中打印出计数的默认值。如果你导航到`http://localhost:8080/#/`，你应该看到以下截图：
- en: '![](img/964f5d82-853f-466c-a069-799ed8e9f367.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/964f5d82-853f-466c-a069-799ed8e9f367.png)'
- en: In the preceding screenshot, we accessed the count variable in the store directly
    using the `$` operator, which is not the preferred way of doing it. We have learned
    the fundamentals of using the state. Now, the proper way to access the variables
    is by using getters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们直接使用`$`运算符访问了存储中的计数变量，这不是首选的方法。我们已经学习了使用状态的基本知识。现在，通过使用`getters`来访问变量是正确的方式。
- en: Getters
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Getters
- en: A `getter` is a function that is used to access the objects from the store.
    Let's create a `getter` method to fetch the count that we have in our store.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`getter`是一个用于从存储中访问对象的函数。让我们创建一个`getter`方法来获取我们在存储中拥有的计数。'
- en: 'In `store.js`, add the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`store.js`中添加以下代码：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we added a method called `fetchCount`, which returns
    the current value of `count`. Now, to access this in our vue component—`HelloWorld.vue`,
    we will need to update the content with the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个名为`fetchCount`的方法，它返回`count`的当前值。现在，为了在我们的vue组件`HelloWorld.vue`中访问这个值，我们需要更新以下代码：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have to import a module called `mapGetters` from Vuex, which is used to
    import the `fetchCount` method that we create as a `getter` method in `store.js`.
    Now, check the number by reloading the browser; this should also print the count
    as `0`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须从Vuex导入一个名为`mapGetters`的模块，它用于导入我们在`store.js`中创建的作为`getter`方法的`fetchCount`函数。现在，通过重新加载浏览器检查数字；这也应该打印出计数为`0`：
- en: '![](img/092909d8-925c-4beb-a34f-525086a77929.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/092909d8-925c-4beb-a34f-525086a77929.png)'
- en: mutations
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mutations
- en: Let's move on to `mutations`. `mutations` are methods that perform modifications
    to the state of the store. We will define the `mutations` just as we defined `getters`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论`mutations`。`mutations`是执行对存储状态修改的方法。我们将像定义`getters`一样定义`mutations`。
- en: 'In `store.js`, add the following lines:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`store.js`中添加以下代码：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added two different `mutation` functions in the preceding code. The `increment`
    method increments the count by 1, whereas the `decrement` method decreases the
    count by 1\. This is where we introduce actions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了两个不同的`mutation`函数。`increment`方法将计数增加1，而`decrement`方法将计数减少1。这就是我们引入行为的地方。
- en: Actions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为
- en: 'Actions are the methods that dispatch mutation functions. Actions perform `mutations`.
    Since `actions` are asynchronous and `mutations` are synchronous, it''s always
    a good practice to use `actions` to mutate the state. Now, just like `getters`
    and `mutations`, let''s define the `actions` as well. In the same file, that is, `store.js`,
    add the following lines of code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 行为是调度变异函数的方法。行为执行`mutations`。由于`actions`是异步的，而`mutations`是同步的，因此始终使用`actions`来变异状态是一个好的实践。现在，就像`getters`和`mutations`一样，让我们也定义`actions`。在同一个文件中，即`store.js`，添加以下代码行：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we added two different functions for incrementing and
    decrementing. Since these methods commit the `mutations`, we will need to pass
    a parameter to make the `commit` method available.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了两个不同的函数用于增加和减少。由于这些方法提交`mutations`，我们需要传递一个参数来使`commit`方法可用。
- en: 'Now we need to use the previously defined `actions` and make them available
    in our vue component, in `HelloWorld.vue`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要使用之前定义的`actions`，并在我们的vue组件`HelloWorld.vue`中使它们可用：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To invoke these actions, let''s create two buttons. In `HelloWorld.vue`, let''s
    add the following lines of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用这些操作，让我们创建两个按钮。在 `HelloWorld.vue` 中，让我们添加以下代码行：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding lines of code add two buttons, which, when clicked, call a method
    to increment or decrement the count. Let''s also import Bootstrap for CSS. In
    `index.html`, add the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行添加了两个按钮，点击这些按钮会调用一个方法来增加或减少计数。让我们也导入 Bootstrap 用于 CSS。在 `index.html` 中，添加以下代码：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That''s it. Now, if you reload the browser, you should be able to see the following
    result:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，如果你重新加载浏览器，你应该能看到以下结果：
- en: '![](img/02e6929a-410b-4b2e-a264-0f595157d624.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02e6929a-410b-4b2e-a264-0f595157d624.png)'
- en: The count should increase or decrease when you click on the relevant button.
    This gives you a basic idea about how to implement Vuex in an application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击相关按钮时，计数应该会增加或减少。这让你对如何在应用程序中实现 Vuex 有一个基本的了解。
- en: Installing and using Vuex in a movie application
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在电影应用程序中安装和使用 Vuex
- en: We covered the basics of Vuex—how it works in an application and the core concepts.
    We covered how to create a store and mutations and how to use actions to dispatch
    them, and also discussed how to use getters to fetch information from the store.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了 Vuex 的基础知识——它在应用程序中的工作原理和核心概念。我们介绍了如何创建存储和突变，以及如何使用操作来分发它们，还讨论了如何使用获取器从存储中获取信息。
- en: 'We built an application in the previous chapters for a movie listing page.
    We will use the same application for Vuex. We will be doing the following actions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们为电影列表页面构建了一个应用程序。我们将使用同一个应用程序来演示 Vuex。我们将执行以下操作：
- en: We will define a store where all the movies will be stored
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将定义一个存储，其中将存储所有电影
- en: When a new movie is added, we will automatically display that to the movie listing
    page without reloading the page
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当添加新电影时，我们将自动将其显示在电影列表页面上，而无需重新加载页面
- en: 'Let''s open the application and run the frontend and backend servers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开应用程序并运行前端和后端服务器：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, run the `mongo` server with the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用以下命令运行 `mongo` 服务器：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The movie listing page should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 电影列表页面应该看起来像这样：
- en: '![](img/2e905eea-dc88-42f3-8715-2cdf705c9317.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e905eea-dc88-42f3-8715-2cdf705c9317.png)'
- en: 'Let''s start by installing `vuex`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装 `vuex` 开始：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check your `package.json` file; `vuex` should be listed on the dependencies:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的 `package.json` 文件；`vuex` 应该列在依赖项中：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, let's create a file, where we will be able to put all our `getters`, `mutations`,
    and `actions` that we will define as we go forward.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个文件，我们将能够将我们定义的所有 `getters`、`mutations` 和 `actions` 放进去。
- en: Defining a store
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个存储
- en: 'Let''s create a folder named `store` inside the `src` directory, and a new
    file called `store.js` inside the `store` directory, and add the following lines
    of code to it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `src` 目录中创建一个名为 `store` 的文件夹，并在 `store` 目录中创建一个名为 `store.js` 的新文件，并将以下代码行添加到其中：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Just like we did in the preceding sample application, let's add a `state` variable
    to store the current state of the application for movies listing page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前面的示例应用程序中所做的那样，让我们添加一个 `state` 变量来存储电影列表页面的当前状态。
- en: 'In `store.js`, add the following lines of code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `store.js` 中添加以下代码行：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This means that the initial state of the application will have an empty movie
    listing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着应用程序的初始状态将有一个空的电影列表。
- en: 'Now, we need to import this `store` into `main.js` so that it is accessible
    throughout the components. Add the following lines of code in `src/main.js`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将此 `store` 导入到 `main.js` 中，以便在整个组件中都可以访问。在 `src/main.js` 中添加以下代码行：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we will need to fetch the movies when we open the location `http://localhost:8081/`
    in the browser. Here is what we will do:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在浏览器中打开位置 `http://localhost:8081/` 时，我们需要获取电影。以下是我们要做的事情：
- en: Modify `Home.vue` to call the action that fetches the movies
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Home.vue` 组件以调用获取电影的行动
- en: Create an action that will fetch all the movies
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个操作来获取所有电影
- en: Create a mutation to store the fetched movies in the movies store
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个突变来存储从状态中获取的电影
- en: Create a getter method to fetch the movies from the state to display on the
    home page
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个获取器方法，从状态中获取电影以在主页上显示
- en: Modifying Home.vue
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 Home.vue
- en: 'Let''s start this section by modifying our `Home.vue` component. Update the
    `script` part of the file with the following lines of code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改我们的 `Home.vue` 组件开始这一部分。更新文件的 `script` 部分，添加以下代码行：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, in the `mounted()` method, we have dispatched an action
    called `fetchMovies`, which we will define in our action.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在 `mounted()` 方法中，我们已派发了一个名为 `fetchMovies` 的操作，我们将在我们的操作中定义它。
- en: 'When the movies are fetched successfully, we will use the `computed` method,
    which will be mapped to the `movies` variable, which we will use in our template:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当电影成功获取时，我们将使用 `computed` 方法，它将被映射到 `movies` 变量，我们将在模板中使用它：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating an action
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个操作
- en: 'Let''s move on to add an action to the `store.js` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加 `store.js` 文件中的操作：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we have moved the `axios` part from the component. When
    we get a successful response, we will commit a mutation called `MOVIES`, which
    then mutates the value of the `movies` in the state.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `axios` 部分从组件中移除。当我们得到成功的响应时，我们将提交一个名为 `MOVIES` 的突变，然后突变状态中的 `movies`
    的值。
- en: Creating a mutation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个突变
- en: 'Let''s go on and add a mutation as well. In `store.js`, replace the contents
    with the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加一个突变。在 `store.js` 中，将内容替换为以下代码：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding `mutations` mutate the state of the movies of the application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `mutations` 突变应用程序中电影的州。
- en: We now have the `action` and the `mutation`. Now, the last part is to add a
    `getter` method, which gets the value of the `movies` from the state.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `action` 和 `mutation`。现在，最后一部分是添加一个 `getter` 方法，它从状态中获取 `movies` 的值。
- en: Creating a getter
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 getter
- en: 'Let''s add the `getter` method in `store.js` that we created to manage the
    state of our application:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `store.js` 中添加我们创建的用于管理应用程序状态的 `getter` 方法：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That's it. When we navigate to `http://localhost:8081/movies/add`, we should
    have a functional Vuex implementation that fetches the movies to the home page.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。当我们导航到 `http://localhost:8081/movies/add` 时，我们应该有一个功能齐全的 Vuex 实现，它将电影数据获取到主页上。
- en: 'Let''s move on to implement the store when we add a movie to the application.
    We will follow the same process as we did earlier:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现当我们在应用程序中添加电影时的存储。我们将遵循之前相同的流程：
- en: Modify `AddMovie.vue` to call the action to create the movie
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `AddMovie.vue` 以调用创建电影的动作
- en: Create an `action` that calls the POST API to create movies
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个调用 POST API 创建电影的 `action`
- en: Create a `mutation` to `store` the added new movie to the `movies` store
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `mutation` 将添加的新电影存储到 `movies` 存储
- en: 'Replace the `script` contents in `AddMovie.vue` with the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `AddMovie.vue` 中的 `script` 内容替换为以下代码：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, add the `action` and `mutations` to the `store.js` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `action` 和 `mutations` 添加到 `store.js` 文件中：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, run the following command to build our static files for Vue components:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行以下命令来构建我们的 Vue 组件的静态文件：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, when we log in and add a movie with the admin user, the movie should be
    added to the database and also be listed on the home page.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们以管理员用户登录并添加电影时，电影应该被添加到数据库中，并且也会列在主页上。
- en: Using Vuex in a small application such as this is overkill. The best use of
    Vuex is in large-scale applications where data needs to be transferred and shared
    among several components. This gives you an idea of how Vuex works and how to
    implement it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样一个小型应用中使用 Vuex 是过度的。Vuex 最好的用途是在需要在不同组件间传输和共享数据的规模较大的应用中。这让你对 Vuex 的工作原理以及如何在应用中实现它有一个了解。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed what Vuex is—the core concepts of Vuex state,
    getters, mutations, actions, and how to use them in an application. We discussed
    how to structure our application to implement Vuex and the benefits it adds when
    the application grows larger.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Vuex 是什么——Vuex 的核心概念，包括状态、getters、mutations、actions 以及如何在应用中使用它们。我们讨论了如何构建我们的应用程序以实现
    Vuex，以及当应用程序规模扩大时它带来的好处。
- en: In the next chapter, we will cover how to write unit tests and integration for
    Vue.js and Node.js application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何为 Vue.js 和 Node.js 应用程序编写单元测试和集成测试。
