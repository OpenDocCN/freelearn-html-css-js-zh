- en: Chapter 5. Asynchronous Actions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。异步动作
- en: In [Chapter 4](ch04.html "Chapter 4. Creating Actions"), *Creating Actions,*
    we examined Flux actions in detail—action creator functions in particular. One
    aspect of action creators we didn't cover was asynchronous behavior. Asynchronicity
    is central to any web application, and in this chapter, we'll think about what
    this means for a Flux architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](ch04.html "第 4 章。创建动作")，“创建动作”中，我们详细考察了 Flux 动作——特别是动作创建函数。动作创建者我们没有涉及的一个方面是异步行为。异步性对于任何
    Web 应用程序都是核心的，在本章中，我们将思考这对于 Flux 架构意味着什么。
- en: We'll start by covering the synchronous nature of Flux, as breaking this synchronicity
    breaks the whole architecture. Next, we'll dive into some code that makes API
    calls and some action creators that need to synchronize multiple API calls before
    actually dispatching the action. Then, we'll introduce promises as return values
    from action creator functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍 Flux 的同步性质，因为打破这种同步性会破坏整个架构。接下来，我们将深入研究一些进行 API 调用的代码和一些在实际上派发动作之前需要同步多个
    API 调用的动作创建者。然后，我们将介绍动作创建函数的返回值作为承诺。
- en: Keeping Flux synchronous
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持 Flux 同步
- en: It may sound strange that we would want to keep an architecture synchronous—especially
    on the web. What about the laggy user experience that happens when everything
    is performed synchronously?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能听起来会想保持架构同步——尤其是在 Web 上。当所有操作都是同步执行时，会发生延迟的用户体验怎么办？
- en: It's just the Flux data-flow that's synchronous, not the entire application.
    In this section, we'll touch upon why keeping the core data-flow mechanisms of
    our architecture synchronous is a good idea. Next, we'll talk about how we should
    encapsulate asynchronous behavior in our application. Finally, we'll go over the
    general semantics of how asynchronous action creator functions work.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就只是 Flux 的数据流是同步的，而不是整个应用程序。在本节中，我们将探讨为什么保持我们架构的核心数据流机制同步是一个好主意。接下来，我们将讨论我们应该如何封装应用程序中的异步行为。最后，我们将概述异步动作创建函数的一般语义。
- en: Why synchronicity?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么是同步的？
- en: The simple answer is that anything that's asynchronous introduces a level of
    uncertainty that wouldn't otherwise be there. It can be tempting, given all the
    new hotness in web browsers, to make everything happen in parallel—to leverage
    as many concurrent web requests and as many processor cores as we possibly can.
    Once we go down this path, it's hard to turn back, and the further down we go,
    the more tangled the synchronization semantics get.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的答案是，任何异步操作都会引入一种不确定性，否则不会存在。鉴于 Web 浏览器中所有的新潮功能，可能会让人想将所有事情都并行执行——尽可能利用尽可能多的并发
    Web 请求和处理器核心。一旦我们走上这条路，就很难回头，而且我们走得越远，同步语义就越复杂。
- en: 'Let''s think about the DOM API for a moment. JavaScript applications use this
    API to change the state of elements on the page. When these changes happen, the
    browser''s rendering engine kicks in and performs an update to the screen so that
    the user can actually see the changes. The DOM API doesn''t directly interface
    with what''s displayed on screen—there''s a whole bunch of nasty details taken
    care of for us by the rendering engine. This idea is illustrated here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时思考一下 DOM API。JavaScript 应用程序使用这个 API 来改变页面上的元素状态。当这些变化发生时，浏览器的渲染引擎会介入并更新屏幕，以便用户实际上可以看到这些变化。DOM
    API 并不直接与屏幕上显示的内容接口——渲染引擎为我们处理了一大堆棘手的细节。这个想法在这里得到了说明：
- en: '![Why synchronicity?](img/B05419_05_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![为什么是同步的？](img/B05419_05_01.jpg)'
- en: The takeaway here is that it's not the individual updates made by our components
    that cause the rendering engine to update the screen. The JavaScript engine is
    run-to-completion, meaning that it waits for all these components to finish making
    their calls to update the DOM (and any other code they're running) before handing
    off control to the rendering engine. This means that any updates the user sees
    are fundamentally synchronous—all the concurrent code in the world doesn't change
    the synchronous communication path between the JavaScript engine and the render
    engine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是，不是我们组件做出的单个更新导致渲染引擎更新屏幕。JavaScript 引擎是运行到完成，这意味着它在将控制权交给渲染引擎之前，会等待所有这些组件完成它们对更新
    DOM（以及它们正在运行的任何其他代码）的调用。这意味着用户看到的任何更新在本质上都是同步的——世界上所有的并发代码都不会改变 JavaScript 引擎和渲染引擎之间的同步通信路径。
- en: You might be wondering what this has to do with Flux at this point. It's actually
    very relevant because the authors of Flux understand this synchronous DOM update
    mechanism, so rather than fight it with complex asynchronous code everywhere,
    they came up with data-flow semantics that embrace the synchronous nature of updating
    the DOM.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在会想知道这与Flux有什么关系。实际上，这非常相关，因为Flux的作者理解这种同步DOM更新机制，所以他们不是在复杂异步代码的每个地方与之抗争，而是提出了拥抱DOM更新同步特性的数据流语义。
- en: The core abstraction Flux uses for synchronous data-flow is the **update round**,
    which was introduced in [Chapter 2](ch02.html "Chapter 2. Principles of Flux"),
    *Principles of Flux*. Nothing can interrupt an update round because every component
    that takes part in it has no asynchronous behavior. If Flux has a killer feature,
    this is it. The update round is such a critical property of Flux architectures
    that we have to be especially careful to maintain it. It's like an umbrella concept—dozens
    of little edge cases caused by asynchronous behavior fall outside of it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Flux用于同步数据流的核心理念是**更新轮次**，这一概念在[第二章](ch02.html "第二章。Flux原理") *Flux原理* 中被引入。没有任何东西可以中断一个更新轮次，因为参与其中的每个组件都没有异步行为。如果Flux有一个杀手级特性，那就是这个。更新轮次是Flux架构的一个关键特性，我们必须特别小心地维护它。它就像一个伞形概念——由异步行为引起的数十个小边缘情况都超出了它的范围。
- en: Encapsulating asynchronous behavior
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装异步行为
- en: With Flux update rounds being synchronous, where should we put our asynchronous
    code? Let's think about this for a moment. Flux architecture aside, any asynchronous
    behavior is going to update the state of the system in some way when the action
    completes and is synchronized with the rest of our code. In some architectures,
    this happens all over the place and there's nothing guarding against these types
    of asynchronous actions from being called from places where they shouldn't.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Flux更新轮次是同步的，我们应该在哪里放置我们的异步代码呢？让我们稍微思考一下。抛开Flux架构不谈，任何异步行为在动作完成并与其他代码同步时，都会以某种方式更新系统的状态。在某些架构中，这种情况无处不在，而且没有任何机制来防止这些类型的异步动作从不应调用它们的地方被调用。
- en: 'For example, a Flux update round should never result in new asynchronous behavior
    running. We know that update rounds are synchronous, so this is a non-starter.
    We do need to encapsulate our asynchronous behavior somehow though. This is what
    action creator functions are really good at—performing the asynchronous work and
    managing the action dispatches once the asynchronous portion has completed. Here
    is a visualization of action creator functions encapsulating asynchronous calls:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Flux更新轮次绝不应该导致新的异步行为运行。我们知道更新轮次是同步的，所以这是一个不可能的情况。尽管如此，我们确实需要以某种方式封装我们的异步行为。这正是动作创建函数擅长的——在异步部分完成后执行异步工作并管理动作派发。以下是一个动作创建函数封装异步调用的可视化：
- en: '![Encapsulating asynchronous behavior](img/B05419_05_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![封装异步行为](img/B05419_05_02.jpg)'
- en: Keeping asynchronous behavior in the action creator functions does two things
    for us. First, we know there's no synchronization semantics involved in calling
    the action creator—this is all handled within the function for us. The second
    advantage is that all of our asynchronous behavior can be found within a single
    architectural layer. That is, if there's something that's asynchronous, such as
    making an API call, we know where to look for this code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将异步行为保持在动作创建函数中有两个好处。首先，我们知道调用动作创建函数时没有涉及任何同步语义——这一切都由函数为我们处理。第二个优点是，我们所有的异步行为都可以在单个架构层中找到。也就是说，如果有什么是异步的，比如进行API调用，我们知道在哪里查找这段代码。
- en: Asynchronous action semantics
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步动作语义
- en: It's up to our action creator functions to perform any synchronizations before
    dispatching any actions. There are two parts to a given action creator function.
    The first is the asynchronous calls, if any, while the second part is the actual
    dispatching of the action. The job of these action creator functions is to synchronize
    the async call with the Flux dispatcher, meaning that the function will have to
    wait for some kind of response before the action can be dispatched.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的动作创建函数负责在派发任何动作之前执行任何同步操作。一个动作创建函数有两个部分。第一部分是异步调用（如果有），第二部分是实际的动作派发。这些动作创建函数的职责是将异步调用与Flux派发器同步，这意味着函数必须在动作可以派发之前等待某种响应。
- en: 'This is because the asynchronous action has payload data. Let''s take a look
    at an example, shall we? Here''s an action creator function that calls an API
    to load a list of user objects:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为异步操作有有效负载数据。让我们看看一个例子，好吗？这里有一个调用API来加载用户对象列表的动作创建函数：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we're using a promise in place of an actual API call. Generally
    speaking, our application will probably have an API function call that returns
    a promise. This is exactly what we're doing here—making it seem like we're talking
    with an API when in reality, it's just a promise. The mechanics are the same,
    regardless of whether `setTimeout()` or an actual AJAX response resolves the promise.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了一个承诺来代替实际的API调用。一般来说，我们的应用程序可能有一个返回承诺的API函数调用。这正是我们在做的事情——在我们实际上只是在处理一个承诺时，让它看起来像我们正在与API交谈。不管`setTimeout()`还是实际的AJAX响应解决了承诺，其机制都是相同的。
- en: 'The important thing to note is that it''s the `loadUsers()` function that takes
    care of dispatching the action after the promise has resolved. Think of it this
    way—the dispatcher is never invoked unless we have new data for the system. The
    waiting part falls outside of the Flux update round, which is why it''s nice to
    keep everything together in a function like this. Here''s how we use the `loadUsers()`
    function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要一点是，`loadUsers()`函数在承诺解决后负责分发动作。可以这样想——除非我们有新数据供系统使用，否则调度器永远不会被调用。等待部分超出了Flux更新轮次，这就是为什么将所有内容都放在这样一个函数中很棒。以下是使用`loadUsers()`函数的方法：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Something that you may have noticed is missing from this example is any kind
    of error handling. For example, it would be unpleasant to call `loadUsers()` and
    have it fail silently because something's wrong with the API. We'll cover error-handling
    in more depth in the final section of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中可能遗漏的是任何错误处理方式。例如，如果API有问题，调用`loadUsers()`而它默默地失败将是不愉快的。我们将在本章的最后部分更深入地讨论错误处理。
- en: Making API calls
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用API
- en: In this section, well go over the common case for asynchronous behavior in Flux
    architectures—making API calls over the network. Then, we'll discuss some the
    implications of asynchronous behavior in the context of user interactivity and
    the Flux tools available to deal with them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍Flux架构中异步行为的常见情况——通过网络调用API。然后，我们将讨论异步行为在用户交互和Flux工具可用性方面的含义。
- en: APIs are the common case
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: APIs are the common case
- en: 'Flux architecture is for the frontend of web applications. That said, there''s
    going to be a lot of network communication between some components of our architecture
    and the backend API. This is the common case for asynchronous behavior, not just
    in Flux, but in the majority of JavaScript applications. Therefore, this is where
    the emphasis should be when designing action creators that directly communicate
    asynchronously with these API endpoints. Here''s what the most common communication
    paths look like in Flux applications:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Flux架构是针对Web应用程序的前端。话虽如此，我们的架构的一些组件和后端API之间将会有大量的网络通信。这是异步行为的常见情况，不仅限于Flux，而且在大多数JavaScript应用程序中都是如此。因此，在设计直接与这些API端点异步通信的动作创建者时，应该在这里强调。以下是Flux应用程序中最常见的通信路径：
- en: '![APIs are the common case](img/B05419_05_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![APIs are the common case](img/B05419_05_03.jpg)'
- en: The stores need to be populated with data, and this is the most common way to
    get data—by fetching it from the API. In fact, the user is likely going to spend
    more time consuming information than interacting with UI elements. As you saw
    in the last section, synchronizing the response with the dispatcher isn't difficult
    to do with promises.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 存储需要填充数据，这是获取数据最常见的方式——通过从API获取。事实上，用户可能花费更多的时间消费信息而不是与UI元素交互。正如您在上一个部分所看到的，使用承诺与调度器同步响应并不困难。
- en: 'These types of API calls aren''t the only source of asynchronous data in Flux
    architectures. For example, reading a file using the file API requires the use
    of an asynchronous function call. Interacting with web workers is another asynchronous
    form of communication—you ask the worker to compute something and get a response
    in the form of a callback function. Although less common than HTTP calls, these
    asynchronous interfaces may be treated in the same way, as illustrated here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的API调用并不是Flux架构中异步数据的唯一来源。例如，使用文件API读取文件需要使用异步函数调用。与Web Workers交互是另一种异步通信形式——你要求工作者计算某些内容，并通过回调函数的形式获得响应。尽管不如HTTP调用常见，但这些异步接口可以像这里所示的那样以相同的方式处理。
- en: '![APIs are the common case](img/B05419_05_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![APIs are the common case](img/B05419_05_04.jpg)'
- en: The same synchronization mechanism—promises—can be used for all of these types
    of asynchronous communication channels. As far as the action creator functions
    are concerned, they all have the same interface—a promised value that's resolved
    at a later time. The dispatcher semantics are the same here as well.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的同步机制——承诺（promises）——可以用于所有这些类型的异步通信通道。就动作创建函数而言，它们都具有相同的接口——一个在稍后时间解决的承诺值。这里的分发语义也是相同的。
- en: There's no asynchronous behavior entering the Flux update round because it's
    all encapsulated within the action creator functions themselves. Additionally,
    it could take more than one API to get all the data needed for an action payload.
    We'll look at this shortly. For now, let's turn our attention to how asynchronous
    action creators impact user interactivity.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有内容都封装在动作创建函数内部，因此Flux更新周期中没有异步行为。此外，可能需要多个API才能获取动作负载所需的所有数据。我们稍后将讨论这个问题。现在，让我们关注异步动作创建者如何影响用户交互。
- en: API calls and user interactivity
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API调用和用户交互
- en: The main challenge with asynchronous calls and user interface elements is that
    we have to manage the state of the request, which in turn reflects the state of
    the UI elements. For example, when the user submits a form, we have to give some
    sort of visual indication that the request has been made and that it's being processed.
    Moreover, we also need to prevent the user from interacting with certain UI elements
    until a response comes back with the state of the request.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 异步调用和用户界面元素的主要挑战是我们必须管理请求的状态，这反过来又反映了UI元素的状态。例如，当用户提交表单时，我们必须提供某种视觉指示，表明请求已被提交并且正在处理。此外，我们还需要防止用户在收到请求状态的响应之前与某些UI元素交互。
- en: 'The stores in a Flux architecture contain all application state, including
    the state of any network requests we want to track. This can help us coordinate
    the state of relevant UI elements with a given request. Let''s look at an action
    creator that sends an asynchronous API request to start something:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flux架构中，存储库包含所有应用程序状态，包括我们想要跟踪的任何网络请求的状态。这可以帮助我们协调与给定请求相关的UI元素的状态。让我们看看一个发送异步API请求以启动某项操作的动作创建者：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, the `start()` function dispatches the `START` action after
    the promise resolves. Just like a real API call, this delay allows the user ample
    time to interact with the UI before the call returns. So, we have to take steps
    to prevent this from happening. Let''s look at another action creator function
    that tells the system about the state of the API request we just made:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`start()` 函数在承诺解决后分发 `START` 动作。就像真正的API调用一样，这种延迟为用户提供了足够的时间在调用返回之前与UI交互。因此，我们必须采取措施防止这种情况发生。让我们看看另一个动作创建函数，它告诉系统我们刚刚发起的API请求的状态：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By calling `starting()`, we can inform any stores that might be listening that
    we're about to make an API call to start something. This could be what we need
    to take care of handling the state of UI elements to inform the user that the
    request is in progress, and to disable elements the user shouldn't touch while
    the request is happening. Let's take a look at a store that processes these types
    of actions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `starting()`，我们可以通知可能正在监听的任何存储库，我们即将发起一个API调用以启动某项操作。这可能包括我们需要处理UI元素的状态，以通知用户请求正在进行中，并在请求发生时禁用用户不应触摸的元素。让我们看看一个处理这些类型操作的存储库。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The store also processes `STOP` and `STOPPING` actions. These modules aren't
    listed separately here because they're nearly identical to the `START` and `STARTING`
    actions, respectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库还处理 `STOP` 和 `STOPPING` 动作。这些模块在这里没有单独列出，因为它们与 `START` 和 `STARTING` 动作几乎相同。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The store has a clear representation of the disabled state for both a `start`
    and a `stop` button. If the `STARTING` or `STOPPING` action is dispatched, then
    we can mark both buttons as disabled. In the case of `START` or `STOP`, we can
    mark the appropriate button as disabled and the other as enabled. Now that the
    stores have all the state that they need, let's now look at a view that actually
    renders the button elements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 存储器对`start`和`stop`按钮的禁用状态有明确的表示。如果`STARTING`或`STOPPING`动作被分发，则可以将两个按钮都标记为禁用。在`START`或`STOP`的情况下，我们可以将适当的按钮标记为禁用，而将另一个标记为启用。现在存储器已经拥有了它们所需的所有状态，让我们现在看看一个实际渲染按钮元素的视图。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You might be wondering why we''ve separated these two actions into two action
    creator functions—`start()` and `starting()`. The reason is simple: one action
    creator dispatches one action. However, this isn''t set in stone and is a matter
    of personal preference. For example, `start()` could have dispatched the `STARTING`
    action before actually making the API call. The upside here is that there''s only
    one function that takes care of everything. On the downside, we lose the one-to-one
    correspondence between action creator and action, raising the potential for confusion.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们将这两个动作分别分离成两个动作创建函数——`start()`和`starting()`。原因很简单：一个动作创建函数分发一个动作。然而，这并不是固定不变的，而是个人偏好的问题。例如，`start()`可以在实际进行API调用之前分发`STARTING`动作。这里的优点是只有一个函数负责所有事情。缺点是我们失去了动作创建函数与动作之间的一对一对应关系，这可能会引起混淆。
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the main job of the click handlers is to call action creator functions.
    They're not performing extra state checking to make sure that the actions can
    be called, and so on. This sort of thing doesn't belong in views, it belongs in
    a store. We're following this tactic here, where we disable the buttons in the
    store by change a particular piece of state. If we check for this sort of thing
    in view event handlers, we end up decoupling the state from the logic that operates
    on it, and in Flux this is not a good thing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，点击处理程序的主要任务是调用动作创建函数。它们不会执行额外的状态检查以确保可以调用动作，等等。这类事情不应该放在视图中，而应该放在存储器中。我们在这里遵循这种策略，通过改变特定状态来禁用存储器中的按钮。如果我们检查视图事件处理程序中的这类事情，最终会导致状态与其操作逻辑解耦，而在Flux中这并不是一个好现象。
- en: Combining API calls
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合API调用
- en: As development moves forward and features become more involved, we're inevitably
    faced with complex API scenarios. This means that there's no longer a simple API
    endpoint that delivers everything the feature needs with one call. Instead, our
    code has to stitch together two or more resources from different endpoints just
    to get the data needed by the feature.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发进程的推进和功能的日益复杂，我们不可避免地面临复杂的API场景。这意味着不再有一个简单的API端点可以通过一次调用提供所有功能所需的数据。相反，我们的代码必须将来自不同端点的两个或多个资源拼接在一起，才能获取功能所需的数据。
- en: In this section, we'll look at action creator functions that fetch data from
    multiple asynchronous resources and pass them to stores as payload data. These
    stores then convert these to information required by features. Then, we'll look
    at an alternative approach, where we compose action creator functions out of smaller
    action creator functions, each pulling data from their own asynchronous resource.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨从多个异步资源获取数据并将其作为有效负载数据传递给存储器的动作创建函数。然后，这些存储器将这些数据转换为功能所需的信息。接下来，我们将探讨一种替代方法，即通过较小的动作创建函数组合动作创建函数，每个函数从自己的异步资源中获取数据。
- en: Complex action creators
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂的动作创建函数
- en: 'Sometimes, a single API endpoint doesn''t have all of the data we need for
    a given store. This means that we have to fetch data from multiple API endpoints.
    The challenge is that these are asynchronous resources, and they need to be synchronized
    before passing them to stores by dispatching them as action payloads. Let''s take
    a look at an action creator that fetches data from three asynchronous API endpoints.
    But first, here''s the API functions we''ll use to simulate asynchronous network
    calls:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，单个API端点可能没有我们为给定存储器所需的所有数据。这意味着我们必须从多个API端点获取数据。挑战在于这些是异步资源，在将它们作为动作有效负载分发之前，需要将它们同步传递给存储器。让我们看看一个从三个异步API端点获取数据的动作创建函数。但首先，这是我们将用于模拟异步网络调用的API函数：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So we have consistent return values from these API functions—promises. Each
    promise that''s returned from a given function is responsible for synchronizing
    that one API call. But what about when our store needs to combine all of these
    resolved values to form the state of a store? Let''s now look at an action creator
    function that handles this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从这些API函数中获得了一致的返回值——承诺。从给定函数返回的每个承诺都负责同步那个API调用。但是，当我们的存储需要将这些已解析的值组合起来形成存储的状态时怎么办呢？现在让我们看看一个处理这个问题的动作创建函数：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The action `MY_ACTION` is only dispatched once all three asynchronous values
    have resolved, because the store depends on all three. All three values are available
    to the store within a single update round when the action is dispatched. Something
    less obvious about this code, but important nonetheless, is the fact that we''re
    not performing any data transformations inside the action creator function before
    dispatching the payload. Instead, we provide the resolved API data as is, in the
    form of payload properties. This ensures that the store is the sole component
    responsible for the state of its information. Let''s look at how a store is now
    able to use this payload:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当所有三个异步值都已解析后，才会分派`MY_ACTION`动作，因为存储依赖于这三个值。当动作被分派时，所有三个值在单个更新轮次内都可用于存储。关于这段代码，虽然不那么明显但同样重要的是，我们在分派有效载荷之前没有在动作创建函数内部执行任何数据转换。相反，我们以有效载荷属性的形式提供已解析的API数据。这确保存储是唯一负责其信息状态的组件。让我们看看存储现在如何使用这个有效载荷：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, the store has everything it needs in the payload to perform
    the necessary transformations. Let''s call the action creator function and see
    if this store behaves as expected:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，存储在有效载荷中拥有执行必要转换所需的一切。让我们调用动作创建函数，看看这个存储是否按预期工作：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Composing action creators
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合动作创建者
- en: As you saw earlier in the chapter, our action creator function calls can get
    quite verbose when user interactivity is involved. This is because we have to
    make two or more calls to action creator functions. One call ensures that the
    UI elements are in a state that's appropriate while the user waits for the asynchronous
    action to complete. The other call invokes the asynchronous behavior. To avoid
    having to make two calls everywhere, we could just have the action creator function
    dispatch two actions. However, this isn't always ideal because we might need to
    call the first action creator without the second action creator at some point.
    It's a granularity problem more than anything.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章前面看到的，当涉及到用户交互时，我们的动作创建函数调用可能会变得相当冗长。这是因为我们必须对动作创建函数进行两个或更多的调用。一个调用确保在用户等待异步操作完成时UI元素处于适当的状态。另一个调用调用异步行为。为了避免在所有地方都进行两次调用，我们可以在动作创建函数中分派两个动作。然而，这并不总是理想的，因为我们可能在某个时候需要调用第一个动作创建函数而不调用第二个动作创建函数。这更多是一个粒度问题。
- en: 'The easy solution is to compose a function out of the two. This way, we keep
    the granularity intact, while reducing the number of functions to call in many
    places. Let''s revisit our code from earlier, where we had to manually call `starting()`
    then `start()`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的解决方案是从两个函数中组合出一个函数。这样，我们保持了粒度，同时减少了在许多地方需要调用的函数数量。让我们回顾一下我们之前的代码，当时我们必须手动调用`starting()`然后`start()`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now our views can simply call `start()` or `stop()` and the necessary state
    changes are applied to the relevant UI elements. This works because the first
    action creator function is synchronous—meaning that the full Flux update round
    takes place before the asynchronous call is made. This behavior is consistent,
    no matter what. Where we start running into problems is when we start composing
    functions out of several asynchronous action creators, as visualized here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在视图可以直接调用`start()`或`stop()`，并将必要的状态更改应用到相关的UI元素上。这是因为第一个动作创建函数是同步的——这意味着在执行异步调用之前，完整的Flux更新轮次就已经完成。这种行为是一致的，无论什么情况。我们开始遇到问题的地方是当我们开始从几个异步动作创建者中组合函数时，如这里所示：
- en: '![Composing action creators](img/B05419_05_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![组合动作创建者](img/B05419_05_05.jpg)'
- en: The problem here is that each of these `asyncAction()` functions we've used
    to compose `action()` results in an update round. The update round that happens
    first is a race condition. We can't combine them into a single action creator
    that makes requests to multiple API endpoints because they service two different
    stores. Flux is all about predictable data flows, and this means always knowing
    the order of update rounds. In the next section, we'll revisit promises in action
    creator functions to help us get around these tricky asynchronous action creator
    scenarios.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，我们用来组合`action()`结果的每个`asyncAction()`函数都会导致一个更新轮次。首先发生的更新轮次是一个竞争条件。我们不能将它们组合成一个对多个API端点发出请求的单个动作创建器，因为它们服务于两个不同的存储。Flux的一切都是关于可预测的数据流，这意味着始终知道更新轮次的顺序。在下一节中，我们将重新审视动作创建器函数中的承诺，以帮助我们解决这些棘手的异步动作创建器场景。
- en: Returning promises
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回承诺
- en: None of the action creator functions we've looked at so far in this chapter
    have returned any values. That's because their main job is to dispatch actions,
    while at the same time hiding any concurrency synchronization semantics. On the
    other hand, action creator functions could return a promise so that we could compose
    more complex asynchronous behavior that spans multiple stores. In the last section,
    we saw that composing asynchronous behavior using action creator functions can
    be difficult if not impossible to do.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到目前为止，我们查看的所有动作创建器函数都没有返回任何值。这是因为它们的主要任务是分发动作，同时隐藏任何并发同步语义。另一方面，动作创建器函数可以返回一个承诺，这样我们就可以组合跨越多个存储的更复杂的异步行为。在上一节中，我们看到了使用动作创建器函数组合异步行为可能会很困难，甚至不可能。
- en: In this section, we'll revisit the challenges posed by asynchronous behavior
    in the context of composing larger functionality. Then, we'll create an example
    implementation with action creators that return promises and use them to synchronize
    with one another. Finally, we'll see whether returning promises from action creators
    can help us deal with errors that happen in the asynchronous resources we're communicating
    with.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新审视在组合更大功能时异步行为带来的挑战。然后，我们将创建一个示例实现，使用返回承诺的动作创建器，并通过它们相互同步。最后，我们将看看从动作创建器返回承诺是否可以帮助我们处理在与我们通信的异步资源中发生的错误。
- en: Synchronizing without promises
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无承诺的同步
- en: One nice aspect of a Flux architecture is the fact that a lot of it is synchronous.
    For example, when we call the dispatcher with a new action and a new payload,
    we can rest assured that the call will block until the update round has completed,
    and everything in the UI is reflecting the current state of things. With asynchronous
    behavior, things are different—especially in a Flux architecture where this type
    of thing is strictly confined to action creator functions. Therefore, we face
    the inevitable challenge of trying to piece together complex systems from an abundance
    of asynchronous resources.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Flux架构的一个优点是它的大部分都是同步的。例如，当我们用一个新动作和一个新有效负载调用分发器时，我们可以确信调用将阻塞，直到更新轮次完成，UI中的所有内容都反映了当前的状态。在异步行为中，情况就不同了——特别是在Flux架构中，这种类型的行为严格限于动作创建器函数。因此，我们面临着从大量的异步资源中拼凑复杂系统的必然挑战。
- en: We saw how to get partway there earlier in the chapter. A single action creator
    function can combine the resolved values of several asynchronous resources into
    a single action and a payload. Then the logic within the store can figure out
    how to make use of the data and update its state. This works fine when single
    stores are in play, but falters when we're trying to synchronize resources across
    several stores and features.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早期看到了如何部分实现这一点。单个动作创建器函数可以将几个异步资源的解决值组合成一个动作和一个有效负载。然后，存储中的逻辑可以找出如何利用这些数据并更新其状态。当只有一个存储参与时，这工作得很好，但当我们试图在多个存储和功能之间同步资源时，就会失败。
- en: 'This is when being able to synchronize the async data and the Flux update round
    becomes important. To do so, our action creator functions need to return promises
    that resolve when both have completed. Here''s an illustration of what we need
    to accomplish:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，能够同步异步数据和Flux更新轮次变得很重要。为了做到这一点，我们的动作创建器函数需要返回在两者都完成时解决的承诺。以下是我们需要完成的工作的说明：
- en: '![Synchronizing without promises](img/B05419_05_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![无承诺的同步](img/B05419_05_06.jpg)'
- en: Composing asynchronous behavior
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合异步行为
- en: 'The way to get around these tricky asynchronous action creator scenarios is
    to have these functions return promises that are resolved after the asynchronous
    behavior and the update round have completed. This lets the caller know that the
    update round is complete and that anything we call now will take place afterward.
    Consistency is what we''re after here, so let''s take a look at an action creator
    function that returns a promise:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要绕过这些棘手的异步动作创建器场景，这些函数应该返回在异步行为和更新轮完成后解决的承诺。这会让调用者知道更新轮已完成，并且我们现在调用的任何内容都将在此之后发生。我们追求的是一致性，所以让我们看看一个返回承诺的动作创建器函数：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So this action creator calls an asynchronous API that resolves after 1.5 seconds,
    at which point the action payload is dispatched and the returned promise is resolved.
    Let''s take a look at another action creator that uses a different API function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个动作创建器调用一个在1.5秒后解决的异步API，此时动作有效载荷被分发，返回的承诺被解决。让我们看看另一个使用不同API函数的动作创建器：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can see that the two action creator functions—`first()` and `last()`—follow
    an identical strategy by returning promises. The API function, however, resolves
    different data, and it takes only 1 second to do so. Let''s see what happens when
    we try to use these two functions together:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这两个动作创建器函数——`first()`和`last()`——通过返回承诺遵循相同的策略。然而，API函数解析不同的数据，并且只需要1秒钟就能完成。让我们看看当我们尝试一起使用这两个函数时会发生什么：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Handling errors
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: What happens when the API that Flux action creators interact with fails? Generally
    speaking, when we make AJAX calls, we supply both success and error callback functions.
    This way, we can fail in a graceful manor. We have to be careful about how we
    handle failure in Flux action creators because, just as stores want to know about
    actions, they want to know about failures too.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当Flux动作创建器交互的API失败时会发生什么？一般来说，当我们进行AJAX调用时，我们提供成功和错误回调函数。这样，我们可以优雅地失败。我们必须小心处理Flux动作创建器中的失败，因为，就像存储需要知道动作一样，他们也需要知道失败。
- en: So the question is—what do we do differently in our action creator functions?
    Do we just dispatch some sort of error action from within the action creator when
    the API fails? We do want to dispatch an error action so that the stores can adjust
    their state accordingly, but what about the caller of the action creator? For
    example, we could have a generic action creator function that's used in many places,
    and the error-handling could be context dependent.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所以问题是——我们在动作创建器函数中做了什么不同的事情？当API失败时，我们只是在动作创建器内部分发某种错误动作吗？我们确实想分发一个错误动作，以便存储可以相应地调整其状态，但动作创建器的调用者怎么办？例如，我们可能有一个通用的动作创建器函数，它在许多地方使用，并且错误处理可能是上下文相关的。
- en: 'The answer is to have the promise that''s returned by the action creator reject.
    This allows the caller to specify their own behavior in the event of a failed
    API call. Let''s look at an action creator function that handles errors this way:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是让动作创建器返回的承诺拒绝。这允许调用者在API调用失败的情况下指定自己的行为。让我们看看一个以这种方式处理错误的动作创建器函数：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let''s call this `updateTask()` function and see if we can assign error
    handling behavior to it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调用这个`updateTask()`函数，看看我们是否可以给它分配错误处理行为：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on asynchronous action creators in Flux architectures.
    These are functions that need to dispatch actions, but before they can, they have
    to wait for some asynchronous resource to resolve. We looked at the synchronous
    update round concept, which is central to any Flux architecture. Then, we discussed
    how action creators encapsulate asynchronous behavior in such a way that they
    preserve the synchronous update rounds.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了Flux架构中的异步动作创建器。这些是需要分发动作的函数，但在它们可以这样做之前，它们必须等待某些异步资源解决。我们探讨了同步更新轮的概念，这是任何Flux架构的核心。然后，我们讨论了动作创建器如何封装异步行为，以便它们保留同步更新轮。
- en: Network calls are the most common form of asynchronous communication in JavaScript
    applications, including Flux architectures. We covered the difference between
    these and other asynchronous channels, and how promises can be used to bridge
    the gap between them. We also looked at how promises can be utilized by action
    creator functions to allow for the composition of more complex functionality.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 网络调用是JavaScript应用程序中最常见的异步通信形式，包括Flux架构。我们涵盖了这些与其他异步通道之间的区别，以及如何使用承诺来弥合它们之间的差距。我们还探讨了承诺如何被动作创建器函数利用，以允许更复杂功能的组合。
- en: In the next chapter, we'll take a deeper look at stores and everything they
    have to do to maintain consistent state in our Flux architectures.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨存储以及它们在保持我们的Flux架构中一致状态所需做的一切。
