- en: Chapter 4. Using Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 使用数据
- en: 'Now that we''ve seen how to process keywords, commands, and API calls, we will
    look at the next logical step in bot building: persistent data storage and retrieval.
    References to data can be kept in JavaScript by assigning said data to a variable;
    however, its use is limited to when the program is running. If the program is
    stopped or restarted, we lose the data. Hence, persistent data storage is required
    for certain tasks.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何处理关键词、命令和 API 调用，我们将探讨构建机器人的下一个逻辑步骤：持久数据存储和检索。可以通过将数据分配给变量来在 JavaScript
    中保留对数据的引用；然而，其使用仅限于程序运行时。如果程序停止或重启，我们就会丢失数据。因此，对于某些任务，需要持久数据存储。
- en: This allows us to build bots that can, for instance, keep track of a leaderboard
    or store a to-do list.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们可以构建能够执行诸如跟踪排行榜或存储待办事项列表等任务的机器人。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Introduction to Redis
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis 简介
- en: Connecting to Redis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到 Redis
- en: Saving and retrieving data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和检索数据
- en: Best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Error handling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Introduction to Redis
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis 简介
- en: In the previous chapter, we discovered how to create a competitive roll bot
    that allows users to play a "Who can roll the highest" game. Although it worked
    admirably, the feature sorely missing is a leaderboard of sorts, where each user's
    wins and losses are stored and an overall winners list is kept.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们发现了如何创建一个具有竞争力的掷骰子机器人，允许用户玩“谁掷得最高”的游戏。尽管它工作得很好，但缺少的功能是某种排行榜，其中存储了每个用户的胜负，并保持了一个总体赢家列表。
- en: Such a feature wouldn't be difficult to produce; however, the largest problem
    comes in storing the data. Any data stored in JavaScript variables would be lost
    once the program ends or crashes. A better solution would then be to maintain
    a persistent database, which our bot can write to and read from.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的功能并不难实现；然而，最大的问题在于数据的存储。任何存储在 JavaScript 变量中的数据，一旦程序结束或崩溃就会丢失。因此，维护一个持久数据库将是一个更好的解决方案，我们的机器人可以从中写入和读取数据。
- en: There is a wide variety of database services to choose from; you might already
    be familiar with MySQL or MongoDB. For the example bots in this chapter, we will
    pick a service that is easy to set up and simple to use.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数据库服务可供选择；你可能已经熟悉 MySQL 或 MongoDB。对于本章中的示例机器人，我们将选择一个易于设置和使用的服务。
- en: 'The database service we will use is Redis: [http://redis.io/](http://redis.io/).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的数据库服务是 Redis：[http://redis.io/](http://redis.io/).
- en: 'The Redis website describes the technology as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 网站对这项技术的描述如下：
- en: '*"Redis is an open source (BSD licensed), in-memory data structure store, used
    as database, cache and message broker. It supports data structures such as strings,
    hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and
    geospatial indexes with radius queries. Redis has built-in replication, Lua scripting,
    LRU eviction, transactions, and different levels of on-disk persistence, and provides
    high availability via Redis Sentinel and automatic partitioning with Redis Cluster."*'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Redis 是一个开源（BSD 许可），内存数据结构存储，用作数据库、缓存和消息代理。它支持字符串、散列、列表、集合、有序集合（带范围查询）、位图、HyperLogLogs
    和地理空间索引（带半径查询）等数据结构。Redis 具有内置的复制、Lua 脚本、LRU 过期、事务和不同级别的磁盘持久性，并通过 Redis Sentinel
    提供高可用性，以及通过 Redis Cluster 自动分区。"*'
- en: A simpler explanation is that Redis is an efficient in-memory key-value store.
    Keys can be simple strings, hashes, lists (an ordered collection), sets (unordered
    collection of non-repeating values), or sorted sets (ordered or ranked collection
    of non-repeating values). Despite the complex official description, setting up
    and using Redis is a quick and painless process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的解释是，Redis 是一个高效的内存键值存储。键可以是简单的字符串、散列、列表（有序集合）、集合（无序的非重复值集合）或有序集合（有序或排名的非重复值集合）。尽管官方描述很复杂，但设置和使用
    Redis 是一个快速且痛苦的过程。
- en: Redis' advantages are its impressive speed, cross-platform communication, and
    simplicity.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 的优势是其令人印象深刻的速度、跨平台通信和简单性。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Getting started with Redis is simple, but we will only be exploring the tip
    of the Redis iceberg. For more information on advanced uses of Redis, visit the
    Redis website.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Redis 简单，但我们只会探索 Redis 冰山一角。有关 Redis 高级使用的更多信息，请访问 Redis 网站。
- en: There are many Redis client implementations written in a wide variety of languages
    ([http://redis.io/clients](http://redis.io/clients)), but we will use a Node-based
    Redis client.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用各种语言编写的 Redis 客户端实现（[http://redis.io/clients](http://redis.io/clients)），但我们将使用基于
    Node 的 Redis 客户端。
- en: Bear in mind that Redis is but one solution to the persistent data problem.
    Other solutions might include the use of a MySQL relational or a MongoDB non-relational
    database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Redis只是持久化数据问题的一个解决方案。其他解决方案可能包括使用MySQL关系型数据库或MongoDB非关系型数据库。
- en: Installing Redis
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Redis
- en: To connect to Redis, we will use the Node Redis package. First, we must install
    and run our Redis server so Node will have something to connect to. Follow the
    instructions for your operating system of choice.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到Redis，我们将使用Node Redis包。首先，我们必须安装并运行我们的Redis服务器，这样Node就有东西可以连接了。请按照您选择的操作系统的说明进行操作。
- en: Mac OS X
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mac OS X
- en: The simplest way to install Redis is through the `homebrew` package manager.
    `homebrew` makes it easy to install applications and services through the command
    line.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Redis最简单的方法是通过`homebrew`包管理器。`homebrew`通过命令行轻松安装应用程序和服务。
- en: 'If you are unable to use `homebrew`, visit the Redis quick start guide to install
    Redis manually: ([http://redis.io/topics/quickstart](http://redis.io/topics/quickstart)).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法使用`homebrew`，请访问Redis快速入门指南以手动安装Redis：([http://redis.io/topics/quickstart](http://redis.io/topics/quickstart))。
- en: 'If you are unsure whether you have Homebrew installed, open a terminal and
    run the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定是否已安装Homebrew，请打开终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If nothing returns, run the following in your terminal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有返回任何内容，请在您的终端中运行以下命令：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Follow the onscreen prompts until `homebrew` is successfully installed. To
    install Redis, run the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按照屏幕提示操作，直到成功安装`homebrew`。要安装Redis，请运行以下命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the installation has completed, you can start a Redis server by using
    the following command in your terminal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以在终端中使用以下命令启动Redis服务器：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Windows
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: 'Visit the official Microsoft GitHub project for Redis and grab the latest release
    here: [https://github.com/MSOpenTech/redis/releases](https://github.com/MSOpenTech/redis/releases).
    Once unzipped, you can run `redis-server.exe` to start the service and `redis-cli.exe`
    to connect to the server through the shell.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Redis的官方Microsoft GitHub项目并在此处获取最新版本：[https://github.com/MSOpenTech/redis/releases](https://github.com/MSOpenTech/redis/releases)。解压后，您可以通过运行`redis-server.exe`来启动服务，并通过shell运行`redis-cli.exe`来连接到服务器。
- en: Unix
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unix
- en: 'Refer to the Redis quickstart page for instructions on how to install on Linux/Unix
    systems: [http://redis.io/topics/quickstart](http://redis.io/topics/quickstart).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考Redis快速入门页面获取在Linux/Unix系统上安装的说明：[http://redis.io/topics/quickstart](http://redis.io/topics/quickstart)。
- en: Once installed, you can start the server with the `redis-server` command and
    connect to the server via `redis-cli`. These commands function in the exact same
    way on OS X.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以使用`redis-server`命令启动服务器，并通过`redis-cli`连接到服务器。这些命令在OS X上以完全相同的方式工作。
- en: 'Now that Redis is installed, start the service and you should see something
    like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Redis已安装，启动服务，您应该会看到类似以下内容：
- en: '![Unix](img/B05384_04_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Unix](img/B05384_04_01.jpg)'
- en: Redis successfully starting a server
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Redis成功启动服务器
- en: Redis is now up and ready to be used on the default port 6379\. Other ports
    may be used instead, but the default port is sufficient for our purposes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Redis现在已在默认端口6379上启动并准备好使用。也可以使用其他端口，但默认端口对于我们的目的来说已经足够。
- en: Connecting to Redis
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到Redis
- en: 'To demonstrate how to connect to Redis, we will create a new bot project (including
    the `Bot` class defined in [Chapter 3](ch03.html "Chapter 3. Adding Complexity"),
    *Adding Complexity*). We''ll start by installing the Redis Node client, executing
    the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何连接到Redis，我们将创建一个新的机器人项目（包括在[第3章](ch03.html "第3章。增加复杂性")中定义的`Bot`类，*增加复杂性*）。我们将首先安装Redis
    Node客户端，执行以下操作：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, create a new `index.js` file and paste in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个新的`index.js`文件，并粘贴以下代码：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This snippet will import the Redis client and connect to the local instance
    running via the `createClient()` method. When not supplied with any arguments,
    the aforementioned method will assume the service is running locally on the default
    port of 6379\. If you wish to connect to a different host and port combination,
    then you can supply them with following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将导入Redis客户端并通过`createClient()`方法连接到本地实例。如果不提供任何参数，上述方法将假定服务在本地默认端口6379上运行。如果您想连接到不同的主机和端口组合，则可以按照以下方式提供：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the purposes of this book, we will be using an unsecure Redis server. Without
    authentication or other security measures, your data could be accessed and edited
    by anyone who connects to your data service. If you intend to use Redis in a production
    environment, it is strongly recommended you read up on Redis security.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我们将使用一个不安全的 Redis 服务器。在没有身份验证或其他安全措施的情况下，任何人都可以访问和编辑连接到您的数据服务的数据。如果您打算在生产环境中使用
    Redis，强烈建议您阅读有关 Redis 安全性的资料。
- en: 'Next, ensure that you have the Redis client running in a different terminal
    window and start up our bot in the usual way:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保您已经在不同的终端窗口中运行了 Redis 客户端，并按照常规方式启动我们的机器人：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If all goes well, you should be greeted by this happy message:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会看到以下快乐的问候信息：
- en: '![Connecting to Redis](img/B05384_04_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![连接到 Redis](img/B05384_04_02.jpg)'
- en: Our Node app has successfully connected to the local Redis server
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Node 应用程序已成功连接到本地 Redis 服务器
- en: As promised, setting up and connecting to Redis was an easy and quick endeavor.
    Next, we will look at actually setting and getting data from our server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，设置和连接到 Redis 是一项简单快捷的任务。接下来，我们将查看如何实际上设置和从我们的服务器获取数据。
- en: Saving and retrieving data
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和检索数据
- en: 'First, let''s look at what the Redis client has to offer us. Add the following
    lines to `index.js`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 Redis 客户端能为我们提供什么。将以下行添加到 `index.js`：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we will set the value "Hello world!" in Redis with the key
    `hello`. In the `get` command, we specify the key we wish to use to retrieve a
    value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用键 `hello` 在 Redis 中设置值 "Hello world!"。在 `get` 命令中，我们指定了我们希望用来检索值的键。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Node Redis client is entirely **asynchronous**. This means that you have
    to supply a callback function with each command if you wish to process data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Node Redis 客户端完全是**异步**的。这意味着如果您希望处理数据，就必须为每个命令提供一个回调函数。
- en: 'A common mistake is to use the Node Redis client in a synchronous way. Here''s
    an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是使用 Node Redis 客户端进行同步操作。以下是一个例子：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This, perhaps confusingly, results in:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这，也许有些令人困惑，结果是：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is because the `get` function will have returned the Boolean `false` before
    the request to the Redis server has been made.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在向 Redis 服务器发出请求之前，`get` 函数将返回布尔值 `false`。
- en: 'Run the correct code and you should see the successful retrieval of the **Hello
    world!** data:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 运行正确的代码，您应该会看到成功检索到 **Hello world!** 数据：
- en: '![Saving and retrieving data](img/B05384_04_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![保存和检索数据](img/B05384_04_03.jpg)'
- en: Our stored value is successfully retrieved
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储的值成功检索
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The maximum file size of a Redis string is 512 megabytes. If you need to store
    something larger than this, consider using multiple key/value pairings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 字符串的最大文件大小为 512 兆字节。如果您需要存储比这更大的内容，请考虑使用多个键/值对。
- en: 'When developing Redis functionality, a good tip is to use the Redis client''s
    built-in `print` command for easy debugging and testing:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Redis 功能时，一个不错的建议是使用 Redis 客户端的内置 `print` 命令来进行简单的调试和测试：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will print the following in the terminal:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在终端中打印以下内容：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we progress through the chapter, we will introduce more useful functions
    and methods provided by the Redis client. For a complete list and documentation,
    visit [https://github.com/NodeRedis/node_redis](https://github.com/NodeRedis/node_redis).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入本章，我们将介绍 Redis 客户端提供的更多有用函数和方法。有关完整列表和文档，请访问 [https://github.com/NodeRedis/node_redis](https://github.com/NodeRedis/node_redis)。
- en: Connecting bots
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接机器人
- en: With our Redis server set up and the basic commands covered, let's apply what
    we've learned to a simple bot. In this example, we will code a bot that instructs
    the bot to *remember* a phrase based on a given key value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Redis 服务器设置完毕并覆盖了基本命令之后，让我们将所学应用到简单的机器人中。在这个例子中，我们将编写一个机器人，它根据给定的键值来*记住*一个短语。
- en: 'Add the following code to your `index.js` file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的 `index.js` 文件中：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using the familiar `respondTo` command introduced in the `Bot` class of the
    previous chapter, we set up our bot to listen for the keyword `store` and then
    set that value in the Redis data store, using the message sender''s name as a
    key. Let''s see this in action:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一章中 `Bot` 类中引入的熟悉 `respondTo` 命令，我们设置我们的机器人监听关键词 `store`，然后使用消息发送者的名字作为键，将该值设置在
    Redis 数据存储中。让我们看看这是如何实现的：
- en: '![Connecting bots](img/B05384_04_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![连接机器人](img/B05384_04_04.jpg)'
- en: Our bot remembers what we told it to
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人记得我们告诉它的
- en: Notice how we use the callback function of the set method to ensure that the
    data was saved correctly, and informing the user if it was not.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用设置方法的回调函数来确保数据被正确保存，并在数据未保存正确时通知用户。
- en: While not terribly impressive behavior, the important thing to realize is that
    our bot has successfully stored values in the Redis data store. Redis will store
    the key value pairing on the local disk, which means that even if the bot and/or
    Redis server are stopped and started again the data will persist.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种行为并不十分令人印象深刻，但重要的是要认识到我们的机器人已经成功地在 Redis 数据存储中存储了值。Redis 将在本地磁盘上存储键值对，这意味着即使机器人或/和
    Redis 服务器停止并重新启动，数据也会持续存在。
- en: Dynamic storage
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态存储
- en: Once again, let's increase the complexity a bit. In the previous example, the
    key used to store data is always the command giver's name. In reality, this is
    impractical as it means a user could only store one thing at a time, overwriting
    the value each time they issued the command. In this next section, we will be
    augmenting our bot to allow the user to specify the key of the value to be stored,
    allowing for the storage of multiple values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们增加一点复杂性。在上一个例子中，用于存储数据的键总是命令发出者的名字。在现实中，这并不实用，因为它意味着用户每次发出命令时只能存储一件事情，每次都会覆盖值。在接下来的这一节中，我们将增强我们的机器人，允许用户指定要存储的值的键，从而允许存储多个值。
- en: 'Delete the previous `respondsTo` commands and paste in the following snippets,
    noting the highlighted code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 删除之前的 `respondsTo` 命令，粘贴以下片段，注意高亮代码：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this interpretation, we expect the user to provide a command in the following
    format:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种解释中，我们期望用户以以下格式提供命令：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To extract the key and value from the command, we first use JavaScript's `Array.shift`
    to remove and return the value at index 0 of the `args` array. Then, it's a simple
    case of collecting the rest of the arguments as the value by using `Array.join`.
    Now, we apply what we learned in the previous section to store the user-defined
    key and value in the Redis instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令中提取键和值，我们首先使用 JavaScript 的 `Array.shift` 来移除并返回 `args` 数组的索引 0 的值。然后，通过使用
    `Array.join` 收集其余的参数作为值。现在，我们将上一节学到的知识应用到存储用户定义的键和值到 Redis 实例中。
- en: 'When the `retrieve` command is given, we use the same `Array.shift` technique
    to extract the key requested. We will then use it to retrieve the stored data.
    Let''s see it is in action:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当给出 `retrieve` 命令时，我们使用相同的 `Array.shift` 技巧来提取请求的键。然后，我们将使用它来检索存储的数据。让我们看看它是如何工作的：
- en: '![Dynamic storage](img/B05384_04_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![动态存储](img/B05384_04_05.jpg)'
- en: Storing and retrieving multiple entities
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和检索多个实体
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Emojis within a message's text are converted into their basic text components.
    For instance, the thumbs up emoji is translated to `:+1`. This conversion works
    both ways, which means that Slack will automatically render any emoji text the
    bot sends.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 消息文本中的表情符号将被转换为它们的文本组件。例如，点赞表情符号被转换为 `:+1`。这种转换是双向的，这意味着 Slack 将自动渲染机器人发送的任何表情文本。
- en: Hashes, lists, and sets
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希、列表和集合
- en: 'So far, we''ve used a single data type for our keys and values: strings. While
    keys are limited to string values, Redis allows for the value to be a variety
    of different data types. The different types are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们为键和值使用了单一的数据类型：字符串。虽然键限制为字符串值，但 Redis 允许值是多种不同的数据类型。不同类型如下：
- en: String
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Hash
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希
- en: List
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Set
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Sorted set
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序集合
- en: We are already familiar with strings, so let's work down the list and explain
    the different data types.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉字符串了，所以让我们继续列表并解释不同的数据类型。
- en: Hashes
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希
- en: 'Hashes are similar to JavaScript objects. However, they differ in that Redis
    hashes do not support nested objects. All the property values of a hash will be
    cast to strings. Take the following JavaScript object:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希类似于 JavaScript 对象。然而，它们在 Redis 哈希不支持嵌套对象方面有所不同。哈希的所有属性值都将转换为字符串。以下是一个 JavaScript
    对象的例子：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `baz` property contains an object, and we can store the `obj` object in
    Redis by using the `hmset` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`baz` 属性包含一个对象，我们可以通过使用 `hmset` 函数将 `obj` 对象存储在 Redis 中：'
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we retrieve the data with `hgetall`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `hgetall` 来检索数据：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will log the following line in our terminal:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的终端中记录以下行：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Redis has stored the nested `baz` object by first calling the `Object.toString()`
    function on it, which means that the string value is returned when we perform
    our `hgetall` function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 首先通过调用 `Object.toString()` 函数来存储嵌套的 `baz` 对象，这意味着当我们执行 `hgetall` 函数时，返回的是字符串值。
- en: 'A workaround is to leverage JavaScript''s `JSON` object to stringify our nested
    object before storing and then parsing the object returned from Redis. Observe
    the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是利用 JavaScript 的 `JSON` 对象在存储之前将嵌套对象序列化，然后解析从 Redis 返回的对象。观察以下示例：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When executed, we see the logged result:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们看到记录的结果：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The examples given here only stringify and parse objects nested one level deep.
    In order to stringify and parse an object of *N* depth, look into the recursion
    programming technique. A good example can be found at [https://msdn.microsoft.com/en-us/library/wwbyhkx4(v=vs.94).aspx](https://msdn.microsoft.com/en-us/library/wwbyhkx4(v=vs.94).aspx).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出的示例仅序列化和解析了一级嵌套的对象。为了序列化和解析深度为 *N* 的对象，请查看递归编程技术。一个很好的例子可以在 [https://msdn.microsoft.com/en-us/library/wwbyhkx4(v=vs.94).aspx](https://msdn.microsoft.com/en-us/library/wwbyhkx4(v=vs.94).aspx)
    找到。
- en: Lists
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: Redis lists are functionally the same as JavaScript arrays. Like with objects,
    the value of every index is converted into a string when storing. When dealing
    with a multidimensional array (for example, an array containing a subset of arrays)
    the `toString` function will be called before storing in Redis. A simple `Array.join(',')`
    can be used to convert this string value back to an array.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 列表在功能上与 JavaScript 数组相同。与对象一样，每个索引的值在存储时都会转换为字符串。当处理多维数组（例如，包含子数组的数组）时，`toString`
    函数将在存储到 Redis 之前被调用。可以使用简单的 `Array.join(',')` 将此字符串值转换回数组。
- en: 'The `lpush` and `rpush` commands can be used to store our list:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `lpush` 和 `rpush` 命令来存储我们的列表：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding snippet, we are pushing our array of heroes to the right of
    the list. This works exactly the same as JavaScript's `Array.push`, where the
    new values are appended to the existing array. In this case, it means that previously
    empty list now contains our `heroes` array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在将英雄数组推送到列表的右侧。这与 JavaScript 的 `Array.push` 完全相同，其中新值被追加到现有数组中。在这种情况下，这意味着之前为空的列表现在包含我们的
    `heroes` 数组。
- en: 'We can push to the left of the array to prepend to the list:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向数组的左侧推送以向列表中添加元素：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will result in our list looking like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的列表看起来像这样：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, to access our Redis list we can use the `lrange` method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要访问我们的 Redis 列表，我们可以使用 `lrange` 方法：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The second and third arguments provided to `lrange` are the selection start
    and end position. To return all the elements in the list rather than a subset,
    we can provide -1 as an end position.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `lrange` 的第二个和第三个参数是选择起始和结束位置。要返回列表中的所有元素而不是子集，我们可以提供 -1 作为结束位置。
- en: Sets
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: 'Sets are similar to Redis lists with one very useful difference: sets do not
    allow duplicates. Consider the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类似于 Redis 列表，但有一个非常有用的区别：集合不允许重复。考虑以下示例：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we use the Redis client''s `sadd` to store the set and `smembers` to
    retrieve it. In the second line, we attempt to add the fruit `''bananas''` to
    the `''fruits''` list, but since the value already exists, the `sadd` call silently
    fails. The retrieved set is as expected:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 Redis 客户端的 `sadd` 来存储集合，并使用 `smembers` 来检索它。在第二行，我们尝试将 `'bananas'`
    水果添加到 `'fruits'` 列表中，但由于该值已存在，`sadd` 调用将静默失败。检索到的集合与预期一致：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might notice that the ordering of the retrieved 'fruits' set is different
    from the order that it was stored in. This is because a set is built using `HashTable`,
    which means there are no guarantees to the order of the elements. If you want
    to store your elements in a particular order, you must use a list or a sorted
    set.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到检索到的 'fruits' 集合的顺序与存储时的顺序不同。这是因为集合是通过 `HashTable` 构建的，这意味着没有保证元素的顺序。如果你想要以特定的顺序存储你的元素，你必须使用列表或有序集合。
- en: Sorted sets
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有序集合
- en: 'Functioning as a sort of hybrid between lists and sets, sorted sets have a
    specific order and cannot contain duplicates. See the following example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列表和集合的某种混合体，有序集合具有特定的顺序且不能包含重复项。以下是一个示例：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using the `zadd` method, we specify the key for our sorted set and an array
    of values. The array indicates the order of the stored set by following this format:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `zadd` 方法，我们指定排序集合的键和值数组。数组通过以下格式指示存储集合的顺序：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `zrange` method uses similar arguments to `lrange`, we specify the start
    and end positions of the set to be returned. This method will return the set in
    ascending order:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`zrange` 方法使用与 `lrange` 相似的参数，我们指定要返回的集合的起始和结束位置。此方法将按升序返回集合：'
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can reverse this by using `zrevrange`. Note how we also provide the `withscores`
    string as an argument. This argument will return the scores of each element:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`zrevrange`来反转这一点。注意我们如何也提供`withscores`字符串作为参数。此参数将返回每个元素的分数：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `withscores` argument can be used for all sorted set retrieval methods.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`withscores`参数来获取所有排序集合的检索方法。
- en: As you might have realized already, sorted sets especially shine when used to
    keep track of game scores or leaderboards. With that in mind, let's revisit our
    "roll" bot from [Chapter 3](ch03.html "Chapter 3. Adding Complexity"), *Adding
    Complexity*, and add a leaderboard of winners.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经意识到的，排序集合在用于跟踪游戏分数或排行榜时特别出色。考虑到这一点，让我们回顾[第3章](ch03.html "第3章。增加复杂性")，*增加复杂性*中的“roll”机器人，并添加一个获胜者排行榜。
- en: Best practices
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Any user should be able to store data in Redis via bot commands; it is however
    recommended you ensure that the data storage methods cannot be easily abused.
    Accidental abuse might happen in the form of many different Redis calls in a short
    amount of time. For more information on Slack channel spam and remedies, revisit
    [Chapter 2](ch02.html "Chapter 2. Your First Bot"), *Your First Bot*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用户都应该能够通过机器人命令在Redis中存储数据；然而，建议您确保数据存储方法不容易被滥用。意外的滥用可能以短时间内大量不同的Redis调用形式发生。有关Slack频道垃圾邮件和补救措施的更多信息，请回顾[第2章](ch02.html
    "第2章。您的第一个机器人")，*您的第一个机器人*。
- en: 'By restricting bot traffic, we can ensure that Redis does not receive an inordinate
    amount of write and retrieve actions. If you ever find that Redis latency is not
    as good as it should be, visit this webpage to help troubleshoot: [http://redis.io/topics/latency](http://redis.io/topics/latency).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过限制机器人流量，我们可以确保Redis不会接收到过多的写入和检索操作。如果您发现Redis延迟不如预期，请访问此网页以帮助排查：[http://redis.io/topics/latency](http://redis.io/topics/latency)。
- en: Let's now look at how we can improve familiar bot behavior with the addition
    of Redis data storage.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看如何通过添加Redis数据存储来改进熟悉的机器人行为。
- en: 'First, here is our `roll` command, with the new Redis store code highlighted:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是我们的`roll`命令，新的Redis存储代码被突出显示：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To store the user's win, we use the Redis client's `zincrby` method, which will
    increment the winner's score by one. Note how we can specify how much to increment
    by in the second argument. If the key (the winner's name here) doesn't exist in
    the set, it is automatically created with the score 0 and then incremented by
    the specified amount.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储用户的胜利，我们使用Redis客户端的`zincrby`方法，该方法将获胜者的分数增加一。注意我们如何在第二个参数中指定增加的数量。如果键（这里的获胜者姓名）在集合中不存在，它将自动创建并带有分数0，然后按指定数量增加。
- en: 'To retrieve the scoreboard, lets add the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索计分板，请添加以下内容：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the `scoreboard` command is given, we immediately look for the reverse
    range by using the `zrevrange` method. This will asynchronously return an array
    in the format:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入`scoreboard`命令，我们立即使用`zrevrange`方法查找反向范围。这将异步返回一个数组，其格式如下：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we transform that array into a two-dimensional array by splitting the
    names and scores into nested arrays, which looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将该数组转换为一个二维数组，通过将名称和分数拆分为嵌套数组，看起来是这样的：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Formatting the data in this way makes it easy for us to send the name and score
    to the channel, preceded by the placing on the scoreboard (the index of the array
    plus one).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式格式化数据使我们能够轻松地将姓名和分数发送到频道，前面是计分板上的位置（数组索引加一）。
- en: 'The final result in Slack shows us a working scoreboard:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Slack中的最终结果显示了一个正常工作的计分板：
- en: '![Best practices](img/B05384_04_06.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![最佳实践](img/B05384_04_06.jpg)'
- en: A scoreboard achieved through persistent data storage
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持久化数据存储实现的计分板
- en: 'Before moving on to another example, let''s look at how to delete a Redis key/value
    pairing. Replace your `scoreboard` command with the following, taking note of
    the highlighted code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个示例之前，让我们看看如何删除Redis键/值对。将您的`scoreboard`命令替换为以下内容，注意突出显示的代码：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now if the command `scoreboard wipe` is given, we use the Redis client's `del`
    function to wipe the key/value pairing by specifying the key.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果输入`scoreboard wipe`命令，我们使用Redis客户端的`del`函数通过指定键来擦除键/值对。
- en: 'We also add in some error handling that sends an error message if there are
    no scores at all:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一些错误处理，如果没有分数，它会发送错误消息：
- en: '![Best practices](img/B05384_04_07.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![最佳实践](img/B05384_04_07.jpg)'
- en: Deleting data should be used with caution
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数据应谨慎使用
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a real-world example, scoreboards and other sensitive data constructs should
    only be deleted by a user with admin rights. Remember that you can check whether
    the command issuer is an admin by checking the `user.is_admin` property.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的例子中，计分板和其他敏感数据结构应该只由具有管理员权限的用户删除。请记住，您可以通过检查 `user.is_admin` 属性来确认命令发送者是否是管理员。
- en: Simple to-do example
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单待办示例
- en: With the basics of Redis covered, we shall now move on to create a simple to-do
    Slack bot. The aim of this bot is to allow users to create a to-do list, allowing
    them to add, complete, and delete a task from this list as they go about their
    day.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 Redis 的基础知识后，我们现在将创建一个简单的待办 Slack 机器人。这个机器人的目的是允许用户创建待办列表，让他们在日常生活中可以添加、完成和删除列表中的任务。
- en: 'This time, we will start with a skeleton of what we want and build each feature
    step by step. Start by adding this new command to your bot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将从一个我们想要的基本框架开始，逐步构建每个功能。首先，将这个新命令添加到您的机器人中：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The bot''s behavior will change depending on the second command given after
    the initial `todo` command. In this instance, a `switch` statement is ideal. We
    allow for five options: `add`, `complete`, `delete`, `help`, and a default option
    that is triggered when anything else is passed in.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人的行为将根据在初始 `todo` 命令之后给出的第二个命令而改变。在这种情况下，使用 `switch` 语句是理想的。我们允许五种选项：`add`、`complete`、`delete`、`help`
    以及一个默认选项，当传递任何其他内容时会被触发。
- en: The `help` and default behaviors have already been completed, as they are fairly
    straightforward. In the latter's case, we retrieve the Redis set, send out an
    error if it doesn't exist or has no items and otherwise send the total to-do list.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`help` 和默认行为已经完成，因为它们相当直接。在后者的例子中，我们检索 Redis 集合，如果它不存在或没有项目，则发送错误，否则发送待办列表的总数。'
- en: '![Simple to-do example](img/B05384_04_08.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![简单待办示例](img/B05384_04_08.jpg)'
- en: Display a message if there are no to-dos
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有待办事项，显示一条消息
- en: 'Adding a to-do task is simple as well. We are using a Redis set, as we do not
    want to allow duplicates in our list. To add an item, we use the previously introduced
    `sadd` command. To make our `switch` statement less cluttered, all the code will
    be moved to a separate function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 添加待办任务是同样简单的。我们使用 Redis 集合，因为我们不希望在列表中允许重复。要添加一个项目，我们使用之前引入的 `sadd` 命令。为了使我们的
    `switch` 语句不那么杂乱，所有代码都将移动到一个单独的函数中：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And the `addTask` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以及 `addTask` 函数：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All arguments after the first two (`todo add`) are joined into a single string
    and added to our set with the user's name as our key. Remember, duplicates are
    not allowed in a Redis set, so it's safe to store the task without doing any prior
    checking. We do check to make sure the task argument is not empty, sending a gentle
    reminder of how to use the "add" function if it is.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前两个参数（`todo add`）之外的所有参数都将合并成一个字符串，并使用用户的名称作为键添加到我们的集合中。记住，Redis 集合中不允许重复，因此可以安全地存储任务而无需进行任何先前的检查。我们确实检查了任务参数是否为空，如果为空，则发送一个关于如何使用
    "add" 函数的温和提醒。
- en: After the task is set, we display a confirmation and the entire to-do list.
    This is behavior that we will implement for every action, as it's a good practice
    to show the user what they've done and how it's impacted the data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务设置之后，我们显示确认信息和整个待办列表。这是我们将为每个动作实现的行为，因为展示用户已经做了什么以及它如何影响数据是一种良好的实践。
- en: 'Here is an example of adding tasks to our to-do list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个向我们的待办列表添加任务的示例：
- en: '![Simple to-do example](img/B05384_04_09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![简单待办示例](img/B05384_04_09.jpg)'
- en: Redis' set takes care of the index for us
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 的集合会为我们处理索引
- en: 'Next up is the `complete` command, which takes the number of a task as an argument:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `complete` 命令，它接受一个任务的编号作为参数：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here''s the accompanying `completeTask` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相应的 `completeTask` 函数：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This action is a little more complicated, as we have to do a little more error
    handling to begin with. First, we make sure that the argument provided is a valid
    number by using the ES6 `Number.isNaN` method.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动作稍微复杂一些，因为我们一开始需要进行一些错误处理。首先，我们确保提供的参数是一个有效的数字，使用 ES6 的 `Number.isNaN` 方法。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful when using ES5's `isNaN` method or ES6's `Number.isNaN` method, as
    they can be confusing. These methods answer the question *is the value equal to
    the type NaN? rather than is the value a number?* For more information, visit
    [https://ponyfoo.com/articles/es6-number-improvements-in-depth#numberisnan](https://ponyfoo.com/articles/es6-number-improvements-in-depth#numberisnan).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ES5的`isNaN`方法或ES6的`Number.isNaN`方法时要小心，因为它们可能会令人困惑。这些方法回答的问题是“值是否等于类型NaN？”而不是“值是否为数字？”更多信息请访问[https://ponyfoo.com/articles/es6-number-improvements-in-depth#numberisnan](https://ponyfoo.com/articles/es6-number-improvements-in-depth#numberisnan)。
- en: After retrieving the set from Redis, we ensure that tasks exist, that the number
    provided makes sense (for example, not less than 1 or more than the length of
    the set), and that the task hasn't already been completed. The latter is determined
    by whether the task has any tilde (`~`) operators contained within. Messages containing
    a tilde as the first and last character will render in strikethrough style within
    Slack.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在从Redis检索集合后，我们确保任务存在，提供的数字有意义（例如，不小于1或大于集合的长度），并且任务尚未完成。后者是通过检查任务是否包含任何波浪号（`~`）操作符来确定的。包含波浪号作为第一个和最后一个字符的消息将在Slack中以删除线样式显示。
- en: To complete a task, we remove the task from the Redis set (using `srem`) after
    assigning it to the `task` variable, and then add it to Redis again with the strikethrough
    style.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成任务，我们在将任务分配给`task`变量后，使用`srem`从Redis集合中删除该任务，然后再次以删除线样式将其添加到Redis中。
- en: '![Simple to-do example](img/B05384_04_10.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![简单的待办事项示例](img/B05384_04_10.jpg)'
- en: Complete a task by referencing its task number
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用任务编号来完成任务
- en: 'Finally, let''s look at the delete function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`delete`函数：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here''s the accompanying function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相应的函数：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first thing to note in this function is how we use a type of function overloading
    to achieve two different outcomes, depending on the arguments passed in.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中需要注意的第一件事是我们如何使用一种类型的函数重载来实现两种不同的结果，这取决于传入的参数。
- en: Because JavaScript is a loosely typed language, we can perform actions depending
    on whether the `target` argument is a string or a number. In the case of a string
    (and provided that that string equals *all*), we delete the entire set from Redis
    using the `del` command, clearing the whole to-do list.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript是一种弱类型语言，我们可以根据`target`参数是字符串还是数字来执行不同的操作。在字符串的情况下（并且假设该字符串等于*all*），我们使用`del`命令从Redis中删除整个集合，清除整个待办事项列表。
- en: In case of a number, we only delete the task specified, provided that the target
    is a valid number we can use (for example, not smaller than 1 and not greater
    than the length of the set).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字的情况下，我们只删除指定的任务，前提是目标是我们可以使用的有效数字（例如，不小于1且不大于集合的长度）。
- en: 'Here''s the multiple functionality of the `delete` command in action:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`delete`命令的多功能演示：
- en: '![Simple to-do example](img/B05384_04_11.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![简单的待办事项示例](img/B05384_04_11.jpg)'
- en: List the to-dos, delete a task, add another, and then delete the whole list
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列出待办事项，删除一个任务，添加另一个，然后删除整个列表
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, the reader has learned the basics of the persistent data storage
    Redis and how to use it through the Node Redis client. We outlined the reasons
    why Redis lends itself well for use with bots, particularly when keeping a score
    list or storing multiple small items.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者已经学习了持久化数据存储Redis的基础知识以及如何通过Node Redis客户端使用它。我们概述了为什么Redis非常适合与机器人一起使用，尤其是在保持分数列表或存储多个小项目时。
- en: In the next chapter, we will introduce the concept of **natural language processing**
    (**NLP**) and see how to evaluate and generate natural language for use in a bot.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍**自然语言处理**（**NLP**）的概念，并了解如何评估和生成用于机器人的自然语言。
