- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Testing with Node.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 进行测试
- en: Testing enables you to identify bugs in your code quickly and efficiently. Test
    cases should be written to verify that each piece of code yields the expected
    output or results. The added benefit is that these tests can act as a form of
    documentation for the expected behaviors of your applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使您能够快速有效地识别代码中的错误。测试用例应编写为验证每段代码是否产生预期的输出或结果。额外的优势是，这些测试可以作为您应用程序预期行为的文档形式。
- en: Unit testing is a type of testing where individual units of code are tested.
    Small unit tests provide a granular specification for your program to test against.
    Ensuring your code base is covered by unit tests aids the development, debugging,
    and refactoring process by providing a baseline measure of behavior and quality.
    Having a comprehensive test suite can lead to identifying bugs sooner, which can
    save time and money since the earlier a bug is found, the cheaper it is to fix.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种测试类型，其中对代码的各个单元进行测试。小型单元测试为您的程序提供了细粒度的规范，以便进行测试。确保您的代码库被单元测试覆盖有助于开发、调试和重构过程，因为它提供了行为和质量的基准度量。拥有全面的测试套件可以更早地发现错误，从而节省时间和金钱，因为错误发现得越早，修复成本就越低。
- en: This chapter will start by introducing some key techniques with the test runner
    built into recent versions of Node.js. We’ll also explore some popular testing
    frameworks. Testing frameworks provide components and utilities such as test runners
    for running automated tests. The later recipes in this chapter will introduce
    other testing concepts – including **stubbing** , **user interface** ( **UI**
    ) testing, and how to configure **continuous integration** ( **CI** ) testing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将首先介绍一些关键技巧，这些技巧包含在Node.js最近版本中内置的测试运行器中。我们还将探索一些流行的测试框架。测试框架提供组件和实用工具，例如测试运行器，用于运行自动化测试。本章后面的食谱将介绍其他测试概念——包括**存根**、**用户界面**（**UI**）测试以及如何配置**持续集成**（**CI**）测试。
- en: 'This chapter will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Testing with **node:test**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **node:test** 进行测试
- en: Testing with Jest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 进行测试
- en: Stubbing HTTP requests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟 HTTP 请求
- en: Using Puppeteer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Puppeteer
- en: Configuring CI tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 CI 测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have Node.js installed, preferably the latest
    version of Node.js 22. You’ll also need access to an editor and browser of your
    choice. Throughout the recipes, we’ll be installing modules from the public **npm**
    registry.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已安装 Node.js，最好是 Node.js 22 的最新版本。您还需要访问您选择的编辑器和浏览器。在整个食谱中，我们将从公共 **npm**
    仓库安装模块。
- en: The code for the recipes is available in the book’s GitHub repository ( [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    ) in the **Chapter08** directory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱的代码可在本书的 GitHub 仓库（[https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)）中的
    **Chapter08** 目录中找到。
- en: Testing with node:test
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 node:test 进行测试
- en: Node.js introduced a built-in test runner in version 18 as an experimental feature,
    subsequently making it stable in version 20. This addition marked a significant
    shift in the Node.js runtime development philosophy away from the “small core”
    to adding more utilities into the runtime itself.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 在版本 18 中引入了内置测试运行器作为实验性功能，随后在版本 20 中将其稳定化。这一添加标志着 Node.js 运行时开发哲学的重大转变，从“小型核心”转向将更多实用工具添加到运行时本身。
- en: The decision to include a built-in test runner was influenced by a broader industry
    trend toward including more built-in tooling in programming languages and runtimes.
    This shift is partly in response to concerns about security, such as the risks
    associated with dependency vulnerabilities. By providing a native test solution,
    Node.js aims to make testing a first-class citizen within its environment, reducing
    the potential attack surface provided by third-party test runners.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 包含内置测试运行器的决定受到了更广泛行业趋势的影响，即向编程语言和运行时中包含更多内置工具。这种转变部分是对安全问题的回应，例如与依赖项漏洞相关的风险。通过提供原生测试解决方案，Node.js旨在使其环境中的测试成为一等公民，减少由第三方测试运行器提供的潜在攻击面。
- en: The built-in test runner in Node.js does not have as extensive an API as is
    provided by the many common and popular test frameworks, such as Jest. It was
    designed to be a minimal and lightweight, yet functional, testing utility without
    the overhead of additional features and configurations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的内置测试运行器没有像Jest等许多常见和流行的测试框架那样广泛的API。它被设计成一个最小化和轻量级的，但功能齐全的测试实用程序，没有额外功能和配置的开销。
- en: This tutorial will guide you through the basics of using the Node.js built-in
    test runner, demonstrating how it can be leveraged to perform effective testing
    in your projects without the need for a third-party test framework.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将指导你了解使用Node.js内置测试运行器的基础知识，演示它如何在不使用第三方测试框架的情况下在你的项目中执行有效的测试。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll create and use a basic calculator application to demonstrate
    the fundamentals of unit testing with the built-in **node:test** module. Throughout
    the recipe, we’ll be using the **ECMAScript Module** ( **ESM** ) syntax covered
    in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139) .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建并使用一个基本的计算器应用程序来演示使用内置的**node:test**模块进行单元测试的基本原理。在整个菜谱中，我们将使用在[*第5章*](B19212_05.xhtml#_idTextAnchor139)中介绍的**ECMAScript
    Module**（**ESM**）语法。
- en: 'Let’s first create a directory to work in and initialize our project directory:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个工作目录并初始化我们的项目目录：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file named **calculator.mjs** :'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**calculator.mjs**的文件：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we can add the following to **calculator.mjs** to create our calculator
    program:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在**calculator.mjs**中添加以下内容来创建我们的计算器程序：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have our project directory set up and an application ready to test,
    we can move on to the recipe steps.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了项目目录并准备好了一个应用程序进行测试，我们可以继续到菜谱步骤。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will be adding unit tests using the built-in **node:test**
    module for the small calculator application we created in the *Getting* *ready*
    section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用在*准备就绪*部分创建的小型计算器应用程序的内置**node:test**模块添加单元测试。
- en: 'The first step is to ensure we’re using a version of Node.js where the **node
    --test** command is available. Enter the following command in your terminal and
    expect to see the test runner execute:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是确保我们使用的是具有**node --test**命令的Node.js版本。在您的终端中输入以下命令，并期望看到测试运行器执行：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we should create a file named **calculator.test.mjs** , which will contain
    our tests:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该创建一个名为**calculator.test.mjs**的文件，它将包含我们的测试：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In **calculator.test.mjs** , we first need to import the **node:test** module:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**calculator.test.mjs**中，我们首先需要导入**node:test**模块：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we can import the **add()** function from our **calculator.js** program.
    We’ll only import and test the **add()** function as an example:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以从我们的**calculator.js**程序中导入**add()**函数。我们将仅导入和测试**add()**函数作为示例：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It can be useful to organize our tests with subtests. To demonstrate this,
    we’ll create a test parent for the **add()** function, which we’ll later add our
    subtests to:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，使用子测试来组织我们的测试是有用的。为了演示这一点，我们将为**add()**函数创建一个测试父级，稍后我们将添加子测试：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can write our first test case as a subtest. Our first test will pass
    integer test values to the **add()** function and confirm that we get the expected
    results. Add the following:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以编写我们的第一个测试用例作为一个子测试。我们的第一个测试将向**add()**函数传递整数测试值，并确认我们得到预期的结果。添加以下内容：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the tests with the **node --test** command in your terminal:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用终端中的**node --test**命令运行测试：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we can add a second subtest. This time, we’ll pass the numbers as strings
    rather than integers. This test is expected to fail as our **calculator.mjs**
    program does not contain logic to transform string input into integers. Add the
    following beneath the first subtest:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加第二个子测试。这次，我们将以字符串的形式传递数字而不是整数。这个测试预计会失败，因为我们的**calculator.mjs**程序不包含将字符串输入转换为整数的逻辑。在第一个子测试下方添加以下内容：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can run the tests by entering the following command in our terminal
    window:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在终端窗口中输入以下命令来运行测试：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Expect to see the following output indicating that the first test passed and
    the second test failed:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到以下输出，表明第一个测试通过，第二个测试失败：
- en: '[PRE12]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ve learned how we can write unit tests for our application using the **node:test**
    module. We’ve executed these tests and produced a **Test Anything Protocol** (
    **TAP** ) summary of the test results.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用**node:test**模块为我们的应用程序编写单元测试。我们已经执行了这些测试，并产生了测试结果的**Test Anything
    Protocol**（**TAP**）摘要。
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the provided example utilizing the **node:test** built-in module for Node.js,
    we start by importing the necessary modules using the ESM syntax. This includes
    **test** from **node:test** for testing framework functionalities, **assert**
    from **node:assert** for assertions, and the **add()** function from a local module,
    **calculator.mjs** , which is the function under test.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的示例中，我们使用Node.js的内置模块**node:test**，首先使用ESM语法导入必要的模块。这包括从**node:test**导入的**test**，用于测试框架功能，从**node:assert**导入的**assert**，用于断言，以及从本地模块**calculator.mjs**导入的**add()**函数，该函数是待测试的函数。
- en: Important note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'It’s crucial to import the **node:test** module by using the **node:** scheme
    prefix, like this: **const test = require(''node:test'');** . This module is one
    of the first to only be exposed via the **node:** prefix. Attempting to import
    it without the **node:** prefix, as in **const test = require(''test'');** , will
    result in an error.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**node:**方案前缀导入**node:test**模块至关重要，如下所示：**const test = require('node:test');**。这个模块是第一个仅通过**node:**前缀暴露的模块之一。尝试不使用**node:**前缀导入它，如**const
    test = require('test');**，将会导致错误。
- en: The tests are structured using the **test()** function, where each test case
    is encapsulated within an asynchronous function. Within each test, subtests are
    defined using **await t.test(...)** , which helps organize the tests hierarchically
    and manage multiple assertions or setup processes cleanly within one test block.
    For asserting conditions, **assert.strictEqual()** is employed to compare the
    expected and actual outcomes, ensuring that both type and value are equal.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是通过**test()**函数构建的，其中每个测试用例都被封装在一个异步函数中。在每个测试中，使用**await t.test(...)**定义子测试，这有助于按层次组织测试，并在一个测试块中干净地管理多个断言或设置过程。对于断言条件，使用**assert.strictEqual()**来比较预期和实际结果，确保类型和值都相等。
- en: 'The **node:assert** module in Node.js provides a set of assertion functions
    for verifying invariants, primarily used for writing tests. Key assertions include
    **assert.strictEqual()** , which checks for strict equality between the expected
    and actual values, and **assert.deepStrictEqual()** , which performs a deep equality
    comparison of objects and arrays. The module also offers **assert.ok()** to test
    if a value is **truthy** and **assert.rejects()** and **assert.doesNotReject()**
    for handling promises that should or should not reject. This suite of assertions
    allows developers to enforce expected behaviors and values in code. A full list
    of available assertions is detailed in the Node.js assert module documentation:
    [https://nodejs.org/docs/latest/api/assert.html#assert](https://nodejs.org/docs/latest/api/assert.html#assert)
    .'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的**node:assert**模块提供了一套断言函数，用于验证不变性，主要用于编写测试。关键断言包括**assert.strictEqual()**，它检查预期值和实际值之间的严格相等性，以及**assert.deepStrictEqual()**，它执行对象和数组的深度相等性比较。该模块还提供了**assert.ok()**来测试一个值是否为**真值**，以及**assert.rejects()**和**assert.doesNotReject()**来处理应该或不应该拒绝的承诺。这个断言套件允许开发者强制执行代码中的预期行为和值。有关可用断言的完整列表，请参阅Node.js
    assert模块文档：[https://nodejs.org/docs/latest/api/assert.html#assert](https://nodejs.org/docs/latest/api/assert.html#assert)。
- en: To run these tests, the script is executed directly with Node.js by running
    **node --test** in the command line. This approach directly outputs the test results
    to the console, indicating which tests have passed or failed. This method of using
    Node.js’s built-in testing tools simplifies the testing process by eliminating
    the need for external libraries – reducing overhead and minimizing third-party
    dependencies.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些测试，可以直接使用Node.js在命令行中执行脚本，运行**node --test**。这种方法直接将测试结果输出到控制台，指示哪些测试已通过或失败。使用Node.js的内置测试工具的方法简化了测试过程，消除了对外部库的需求——减少了开销并最小化了第三方依赖。
- en: In the recipe, our test results were output using the **spec** format. When
    using the **node:test** module with a **terminal interface** ( **TTY** ), the
    default output reporter is set to **spec** . The **spec** reporter formats test
    results in a human-readable manner. If the standard output is not a TTY, the module
    defaults to using the **tap** reporter, which outputs the test results in TAP
    format.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们使用**spec**格式输出了测试结果。当使用**node:test**模块与**终端界面**（**TTY**）一起使用时，默认输出报告器设置为**spec**。**spec**报告器以人类可读的方式格式化测试结果。如果标准输出不是TTY，模块默认使用**tap**报告器，它以TAP格式输出测试结果。
- en: 'It’s possible to specify alternate test reporter output using the **--test-reporter**
    command-line flag. Details of the available reporters can be found in the Node.js
    documentation: [https://nodejs.org/docs/latest-v22.x/api/test.html#test-reporters](https://nodejs.org/docs/latest-v22.x/api/test.html#test-reporters)
    .'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 **--test-reporter** 命令行标志指定替代测试报告输出。有关可用报告器的详细信息，请参阅 Node.js 文档：[https://nodejs.org/docs/latest-v22.x/api/test.html#test-reporters](https://nodejs.org/docs/latest-v22.x/api/test.html#test-reporters)。
- en: There’s more…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: To further enhance your understanding of the core **node:test** module, let’s
    explore the default file patterns the test runner uses to locate and execute tests,
    along with additional features that streamline the testing process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步加深你对核心 **node:test** 模块的理解，让我们探索测试运行器用于定位和执行测试的默认文件模式，以及简化测试过程的附加功能。
- en: Understanding Node.js default test file patterns
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Node.js 默认测试文件模式
- en: The Node.js test runner automatically finds and runs test files based on their
    names by looking for files that match specific patterns – essentially, indicators
    that a file is a test. The patterns use wildcards ( ***** ) and optional groups
    ( **?(...)** ) to include various filenames and extensions. The double asterisk
    ( ****** ) means that Node.js searches all directories and subdirectories, so
    no matter where your test files are, they’ll be found as long as they match the
    patterns.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 测试运行器会自动根据文件名查找并运行测试文件，通过查找匹配特定模式的文件来实现——本质上，这些模式是文件是测试的指示器。这些模式使用通配符（*****）和可选组（**?(...)**）来包含各种文件名和扩展名。双星号（******）表示
    Node.js 搜索所有目录和子目录，因此无论测试文件在哪里，只要它们匹配模式，就会被找到。
- en: 'Here are common patterns the Node.js test runner searches for by default:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Node.js 测试运行器默认搜索的常见模式：
- en: '****/*.test.?(c|m)js** : This finds files ending with **.test.js** , **.test.cjs**
    , or **.test.mjs** in any directory'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****/*.test.?(c|m)js**：这将在任何目录中找到以 **.test.js**、**.test.cjs** 或 **.test.mjs**
    结尾的文件'
- en: '****/*-test.?(c|m)js** : Like the first pattern, but for files ending with
    **-test.js** , **-test.cjs** , or **-test.mjs**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****/*-test.?(c|m)js**：与第一个模式类似，但用于以 **-test.js**、**-test.cjs** 或 **-test.mjs**
    结尾的文件'
- en: '****/*_test.?(c|m)js** catches files ending with **_test.js** , **_test.cjs**
    , or **_test.mjs**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****/*_test.?(c|m)js** 捕获以 **_test.js**、**_test.cjs** 或 **_test.mjs** 结尾的文件'
- en: '****/test-*.?(c|m)js** looks for files starting with **test-** and ending with
    **.js** , **.cjs** , or **.mjs**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****/test-*.?(c|m)js** 查找以 **test-** 开头并以 **.js**、**.cjs** 或 **.mjs** 结尾的文件'
- en: '****/test.?(c|m)js** matches files named exactly **test.js** , **test.cjs**
    , or **test.mjs**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****/test.?(c|m)js** 匹配名为 **test.js**、**test.cjs** 或 **test.mjs** 的文件'
- en: '****/test/**/*.?(c|m)js** digs into any **test** directory and finds files
    with **.js** , **.cjs** , or **.mjs** extensions in any subdirectory'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****/test/**/*.?(c|m)js** 深入任何 **test** 目录并找到任何子目录中具有 **.js**、**.cjs** 或 **.mjs**
    扩展名的文件'
- en: To make sure Node.js can find and run your tests without extra configuration,
    it is advisable to name your test files following these patterns. It keeps your
    project organized and aligns with common Node.js practices.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 Node.js 可以找到并运行你的测试而无需额外配置，建议按照这些模式命名你的测试文件。这有助于保持项目组织并符合常见的 Node.js 实践。
- en: Filtering tests
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤测试
- en: 'With the **node:test** module, there are several options for filtering tests
    to manage which ones are executed during a test run. This flexibility is useful
    for focusing on specific tests during development or debugging:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **node:test** 模块，有多个选项可用于过滤测试，以管理在测试运行期间执行哪些测试。这种灵活性在开发或调试期间专注于特定测试时非常有用：
- en: '**Skipping tests** : Tests can be skipped using the **skip** option or the
    test contexts **skip()** method. This is useful for temporarily disabling a test
    without removing it from the code base. For example, marking a test with **{ skip:
    true }** or using **t.skip()** within the **test()** function will prevent its
    execution:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳过测试**：可以使用 **skip** 选项或测试上下文中的 **skip()** 方法跳过测试。这对于暂时禁用测试而不从代码库中删除它非常有用。例如，使用
    **{ skip: true }** 标记测试或在使用 **test()** 函数时使用 **t.skip()** 将阻止其执行：'
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Marking tests as todo** : When a test is not yet implemented or if it’s known
    to be flaky, it can be marked as **todo** . These tests will still run, but their
    failures won’t count against the test suite’s success. Using the **{ todo: true
    }** option or **t.todo()** can annotate these tests effectively.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记测试为 todo**：当一个测试尚未实现或已知为不可靠时，它可以被标记为 **todo**。这些测试仍然会运行，但它们的失败不会计入测试套件的成功。使用
    **{ todo: true }** 选项或 **t.todo()** 可以有效地注释这些测试。'
- en: '**Focusing on specific tests** : The **{ only: true }** option is used to focus
    on running specific tests, skipping all others not marked with this option. This
    is particularly useful when needing to isolate a test for scrutiny without running
    the entire suite.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专注于特定测试**：使用 **{ only: true }** 选项来专注于运行特定的测试，跳过所有未标记此选项的其他测试。这在需要隔离测试进行审查而不运行整个测试套件时特别有用。'
- en: '**Filtering by test name** : Using the **--test-name-pattern** command-line
    option, tests can be filtered by their names. This is useful when you want to
    run a subset of tests that match a specific naming pattern or convention. Patterns
    are treated as regular expressions. For example, running the test suite with **--test-name-pattern="add"**
    would only execute tests with **"add"** in their name.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按测试名称过滤**：使用 **--test-name-pattern** 命令行选项可以根据测试名称进行过滤。当你想运行匹配特定命名模式或约定的测试子集时，这很有用。模式被视为正则表达式。例如，使用
    **--test-name-pattern="add"** 运行测试套件将仅执行名称中包含 **"add"** 的测试。'
- en: Collecting code coverage
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集代码覆盖率
- en: '**Code coverage** is a key metric used to evaluate the extent to which source
    code is executed during testing, helping developers identify untested parts of
    their code base. In Node.js, enabling code coverage is straightforward, but it’s
    important to note that this feature is currently experimental.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码覆盖率** 是一个关键指标，用于评估在测试期间源代码的执行程度，帮助开发者识别其代码库中未测试的部分。在 Node.js 中，启用代码覆盖率很简单，但请注意，此功能目前是实验性的。'
- en: You can enable it by launching Node.js with the **--experimental-test-coverage**
    command-line flag. This setup automatically collects coverage statistics, which
    are reported after all tests are completed. Coverage for Node.js core modules
    and files within **node_modules** directories is not included in the report.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用带有 **--experimental-test-coverage** 命令行标志启动 Node.js 来启用它。此设置会自动收集覆盖率统计信息，并在所有测试完成后报告。报告不包括
    Node.js 核心模块和 **node_modules** 目录内的文件覆盖率。
- en: 'It’s possible to control which lines are included for code coverage by using
    annotations:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用注解来控制哪些行包含在代码覆盖率中：
- en: '**/* node:coverage disable */** and **/* node:coverage enable */** , which
    exclude specific lines or blocks of code from being counted'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/* node:coverage disable */** 和 **/* node:coverage enable */** ，它们可以排除特定行或代码块不被计数'
- en: '**/* node:coverage ignore next */** to exclude the following line'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/* node:coverage ignore next */** 用于排除以下行'
- en: '**/* node:coverage ignore next n */** to exclude the following **n** lines'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/* node:coverage ignore next n */** 用于排除以下 **n** 行'
- en: Coverage results can be summarized by built-in reporters such as **tap** and
    **spec** , or detailed through the **lcov** reporter, which generates a **lcov**
    file suitable for in-depth analysis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过内置的报告器如 **tap** 和 **spec** 概括覆盖率结果，或通过 **lcov** 报告器详细展示，该报告器生成适合深入分析的 **lcov**
    文件。
- en: Important note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The current implementation of **--experimental-test-coverage** has limitations,
    such as the absence of source map support and the inability to exclude specific
    files or directories from the coverage report.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 **--experimental-test-coverage** 的实现存在限制，例如缺少源映射支持以及无法从覆盖率报告中排除特定文件或目录。
- en: 'To collect code coverage in the example from the recipe, you can run the following
    command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要收集来自食谱示例的代码覆盖率，你可以运行以下命令：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Expect to see output like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 预期将看到以下输出：
- en: '![Figure 8.1 – Terminal window showing a node:test code coverage report](img/B19212_08_01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 显示 node:test 代码覆盖率报告的终端窗口](img/B19212_08_01.jpg)'
- en: Figure 8.1 – Terminal window showing a node:test code coverage report
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 显示 node:test 代码覆盖率报告的终端窗口
- en: See also
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Testing with Jest* recipe in this chapter
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *使用 Jest 进行测试* 食谱
- en: The *Configuring Continuous Integration tests* recipe in this chapter
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *配置持续集成测试* 食谱
- en: The *Writing module code* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写模块代码* 食谱在 [*第五章*](B19212_05.xhtml#_idTextAnchor139)'
- en: Testing with Jest
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jest 进行测试
- en: Jest is a widely adopted open source JavaScript testing framework developed
    by Facebook. It is particularly favored for testing React applications, though
    its versatility extends to Node.js environments. Jest is an opinionated testing
    framework with a host of bundled features.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 是由 Facebook 开发的一个广泛使用的开源 JavaScript 测试框架。它特别适用于测试 React 应用程序，尽管其多功能性也扩展到
    Node.js 环境。Jest 是一个具有众多捆绑功能的具有观点的测试框架。
- en: In this guide, we will explore how to effectively write and structure tests
    using Jest. You’ll learn the key principles of Jest and how to set up your testing
    environment. Additionally, we’ll explore Jest’s capabilities in measuring and
    reporting test coverage to help you understand how well your code base is covered
    by tests.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指南中，我们将探讨如何有效地使用 Jest 编写和结构测试。您将学习 Jest 的关键原则以及如何设置您的测试环境。此外，我们将探索 Jest 在衡量和报告测试覆盖率方面的功能，以帮助您了解您的代码库被测试覆盖得有多好。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using Jest to test a program that provides some text utility functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Jest 测试一个提供一些文本实用函数的程序。
- en: 'First, let’s create and initialize our project directory:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建和初始化我们的项目目录：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need a program to test. Create a file named **textUtils.js** :'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个程序来测试。创建一个名为 **textUtils.js** 的文件：
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code to **textUtils.js** :'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 **textUtils.js** 中：
- en: '[PRE17]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We’ll also create a test file named **textUtils.test.js** :'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建一个名为 **textUtils.test.js** 的测试文件：
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we’ve got our directory and files initialized, we’re ready to move
    on to the recipe steps.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了目录和文件，我们可以继续进行菜谱步骤。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this recipe, we will learn how to write and structure various tests with
    Jest.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 Jest 编写和结构各种测试。
- en: 'First, we need to install Jest as a development dependency:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将 Jest 作为开发依赖项安装：
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We’ll also update our **npm** test script in our **package.json** file to call
    the **jest** test runner. Change the **"test"** script field to the following:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将更新我们的 **package.json** 文件中的 **npm** 测试脚本来调用 **jest** 测试运行器。将 **"test"**
    脚本字段更改为以下内容：
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In **textUtils.test.js** , we first need to import our **textUtils.js** module
    to enable us to test it. Add the following line to the top of the test file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **textUtils.test.js** 中，我们首先需要导入我们的 **textUtils.js** 模块，以便我们可以对其进行测试。将以下行添加到测试文件的顶部：
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a Jest **describe()** block. Jest **describe()** blocks are used to group
    and structure our tests. Add the following:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 Jest **describe()** 块。Jest **describe()** 块用于对测试进行分组和结构。添加以下内容：
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Within the **describe()** block, we can start adding our test cases. We use
    Jest’s **test()** syntax to define each test. Our test will use Jest’s assertion
    syntax to verify that when we call our **lowercase()** and **uppercase()** functions
    they produce the expected results. Add the following code within the **describe()**
    block to create the three test cases:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **describe()** 块内，我们可以开始添加我们的测试用例。我们使用 Jest 的 **test()** 语法来定义每个测试。我们的测试将使用
    Jest 的断言语法来验证当我们调用我们的 **lowercase()** 和 **uppercase()** 函数时，它们会产生预期的结果。在 **describe()**
    块内添加以下代码以创建三个测试用例：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can run our tests. We can run the test by entering the **npm test**
    command in our terminal. Jest will print a summary of our test results:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的测试。我们可以在终端中输入 **npm test** 命令来运行测试。Jest 将打印出我们的测试结果摘要：
- en: '[PRE24]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Jest provides a built-in code coverage feature. Running this will show us which
    lines of our program have been covered by the test case. You can enable coverage
    reporting by passing the **--coverage** flag to the Jest executable. Enter the
    following command in your terminal to reference the installed Jest executable
    and report code coverage:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jest 提供了一个内置的代码覆盖率功能。运行此命令将显示我们的程序中哪些行已被测试用例覆盖。您可以通过将 **--coverage** 标志传递给 Jest
    可执行文件来启用覆盖率报告。在您的终端中输入以下命令以引用已安装的 Jest 可执行文件并报告代码覆盖率：
- en: '[PRE25]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Expect to see the following output:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望看到以下输出：
- en: '![Figure 8.2 – Terminal window showing a Jest code coverage report](img/B19212_08_02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 显示 Jest 代码覆盖率报告的终端窗口](img/B19212_08_02.jpg)'
- en: Figure 8.2 – Terminal window showing a Jest code coverage report
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 显示 Jest 代码覆盖率报告的终端窗口
- en: Note that the code coverage report states we’ve not covered line 8 in textUtils.js.
    Note that depending on your code formatting, the specific line number may change.
    With this information, we can add a test case to satisfy this line.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码覆盖率报告指出我们在 textUtils.js 中没有覆盖第 8 行。注意，根据您的代码格式，具体的行号可能会有所不同。有了这些信息，我们可以添加一个测试用例来满足这一行。
- en: 'Add the following test case to **textUtils.test.js** to cover the missing line:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试用例添加到 **textUtils.test.js** 中以覆盖缺失的行：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, you can rerun the code coverage report with the following command and
    expect to see our code is now 100% covered:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令重新运行代码覆盖率报告，并期望看到我们的代码现在是 100% 覆盖的：
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ve now created a test for our **textUtils.js** module using Jest and learned
    how to generate code coverage reports.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经使用 Jest 为我们的 **textUtils.js** 模块创建了一个测试，并学习了如何生成代码覆盖率报告。
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first line of our **textUtils.test.js** file imports our **textUtils.js**
    module, allowing us to call it when testing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 **textUtils.test.js** 文件的第一行导入了我们的 **textUtils.js** 模块，这使得我们可以在测试时调用它。
- en: We organized our tests using Jest’s **describe()** and **test()** functions.
    The **describe()** function is used to define a collection of tests. The **describe()**
    method takes two parameters. The first is a name for the test group, and the second
    parameter is a callback function, which can contain test cases or nested **describe()**
    blocks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Jest 的 **describe()** 和 **test()** 函数组织了我们的测试。**describe()** 函数用于定义一组测试。**describe()**
    方法接受两个参数。第一个是测试组的名称，第二个参数是一个回调函数，该函数可以包含测试用例或嵌套的 **describe()** 块。
- en: Jest’s **test()** syntax is used to define a test case. The **test()** method
    accepts two parameters. The first is the test name, and the second is a callback
    function that contains the test logic.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 的 **test()** 语法用于定义测试用例。**test()** 方法接受两个参数。第一个是测试名称，第二个是包含测试逻辑的回调函数。
- en: The test logic for this program had just one line, which asserts that when we
    call **uppercase('hello world')** , a **HELLO WORLD** value is returned as expected.
    The assertion uses Jest’s **Expect** bundled assertion library ( [https://www.npmjs.com/package/expect](https://www.npmjs.com/package/expect)
    ). We used the **toBe()** assertion from the **Expect** library to equate the
    two values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的测试逻辑只有一行，它断言当我们调用 **uppercase('hello world')** 时，会返回预期的 **HELLO WORLD**
    值。这个断言使用了 Jest 的 **Expect** 内置断言库 ([https://www.npmjs.com/package/expect](https://www.npmjs.com/package/expect))。我们使用了
    **Expect** 库中的 **toBe()** 断言来比较两个值。
- en: '**Expect** exposes many assertion methods, including **toBe()** , **toContain()**
    , **toThrow()** , and others. A full list of assertions is defined in the **Expect**
    section of Jest’s API documentation [https://jestjs.io/docs/en/expect.html#methods](https://jestjs.io/docs/en/expect.html#methods)
    .'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**Expect** 提供了许多断言方法，包括 **toBe()**、**toContain()**、**toThrow()** 等。断言的完整列表可以在
    Jest 的 API 文档的 **Expect** 部分中找到 [https://jestjs.io/docs/en/expect.html#methods](https://jestjs.io/docs/en/expect.html#methods)
    。'
- en: 'It’s also possible to invert assertions by adding **.not** to our statements,
    as in the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过在我们的语句中添加 **.not** 来反转断言，如下面的示例所示：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To run our test cases, we call the **jest** test runner, which is located within
    our **node_modules** directory. The Jest executable runs the tests, automatically
    looking for files containing **test.js** . The runner executes our tests and then
    generates an output summary of the results.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的测试用例，我们调用位于 **node_modules** 目录中的 **jest** 测试运行器。Jest 可执行文件运行测试，自动查找包含
    **test.js** 的文件。运行器执行我们的测试，然后生成结果摘要。
- en: In the final step of the recipe, we enabled Jest’s code coverage reporting.
    Code coverage is a measure of how many lines of our program code are touched when
    executing our tests. 100% code coverage means that every line of your program
    is covered by the test suite. This helps you easily detect bugs introduced by
    code changes. Some developers and organizations set acceptable thresholds for
    code coverage and put restrictions in place so that the code coverage percentage
    cannot be regressed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱的最后一步，我们启用了 Jest 的代码覆盖率报告。代码覆盖率是衡量在执行测试时我们的程序代码中有多少行被触发的度量。100% 的代码覆盖率意味着你的程序中的每一行都被测试套件所覆盖。这有助于你轻松地检测由代码更改引入的缺陷。一些开发者和组织为代码覆盖率设定了可接受的阈值，并实施限制，以确保代码覆盖率百分比不会下降。
- en: There’s more…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Jest provides more features **out of the box** ( **OOTB** ) than some of the
    other popular Node.js test libraries. Let’s look at a couple of them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 提供的功能比其他一些流行的 Node.js 测试库更多 **out of the box** ( **OOTB** )。让我们看看其中的一些。
- en: Setup and teardown
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置和清理
- en: Jest provides setup and teardown functionality for tests. Setup steps can be
    run before each or all tests using the **beforeEach()** and **beforeAll()** functions
    respectively. Similarly, teardown steps can be run after each or all tests with
    the **afterEach()** and **afterAll()** functions respectively.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 为测试提供了设置和清理功能。可以使用 **beforeEach()** 和 **beforeAll()** 函数分别运行设置步骤，在每次或所有测试之前。同样，可以使用
    **afterEach()** 和 **afterAll()** 函数分别运行清理步骤，在每次或所有测试之后。
- en: 'The following pseudocode demonstrates how these functions can be used:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码演示了这些函数如何使用：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Mocking with Jest
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Jest 进行模拟
- en: Mocks enable you to test the interaction of your code or functions without having
    to execute the code. Mocks are often used in cases where your tests rely on third-party
    services or APIs, and you do not want to send real requests to these services
    when running your test suite. There are benefits to **mocking** , including faster
    execution of test suites and ensuring your tests are not going to be impacted
    by network conditions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟（Mocks）允许你在不执行代码的情况下测试你的代码或函数的交互。模拟通常用于测试依赖于第三方服务或 API 的情况，你不想在运行测试套件时向这些服务发送真实请求。模拟（Mocking）有一些好处，包括测试套件的执行速度更快，并确保你的测试不会受到网络条件的影响。
- en: Jest provides mocking functionality OOTB. We can use a mock to verify that our
    function has been called with the correct parameters, without executing the function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 提供了开箱即用的模拟功能。我们可以使用模拟来验证我们的函数是否以正确的参数被调用，而不需要执行该函数。
- en: 'For example, we could change the test from the recipe to mock the **uppercase()**
    module with the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将菜谱中的测试更改为使用以下代码模拟 **uppercase()** 模块：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The **jest.fn(() => 'HELLO');** method returns a new mock function. We assign
    this to a variable named **uppercase** . The parameter is a callback function
    that returns the string **'HELLO'** – this is to demonstrate how we can simulate
    a function’s return value.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**jest.fn(() => ''HELLO'');** 方法返回一个新的模拟函数。我们将这个函数赋值给一个名为 **uppercase** 的变量。参数是一个返回字符串
    **''HELLO''** 的回调函数——这是为了演示我们如何模拟函数的返回值。'
- en: The **.toHaveBeenCalled()** method from **Expect** verifies that our mock function
    was called with the correct parameter. If, for some reason, you cannot execute
    a function in your test suite, you can use mocks to validate that the function
    is being called with the correct parameters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**Expect** 的 **.toHaveBeenCalled()** 方法验证我们的模拟函数是否以正确的参数被调用。如果你在测试套件中无法执行某个函数，你可以使用模拟来验证该函数是否以正确的参数被调用。'
- en: Testing asynchronous code
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试异步代码
- en: Testing asynchronous code is essential in ensuring that Node.js applications
    perform as expected, especially when dealing with operations such as API calls,
    database transactions, or any processes that depend on promise resolution or callbacks.
    Jest provides a clear and straightforward way to handle these asynchronous operations
    in your tests, ensuring they complete before making assertions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 测试异步代码对于确保 Node.js 应用程序按预期运行至关重要，尤其是在处理 API 调用、数据库事务或任何依赖于承诺解析或回调的过程时。Jest 提供了一种清晰直接的方式来处理测试中的这些异步操作，确保在做出断言之前它们已经完成。
- en: 'One of the most common methods to test asynchronous code in Jest is by using
    the **async** / **await** syntax along with Jest’s **.resolves** and **.rejects**
    matchers. For example, consider a **fetchData()** function that returns a promise
    resolving to some data:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jest 中测试异步代码最常见的方法是使用 **async** / **await** 语法以及 Jest 的 **.resolves** 和 **.rejects**
    匹配器。例如，考虑一个返回承诺解析到一些数据的 **fetchData()** 函数：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can write a Jest test to verify that **fetchData()** resolves to the expected
    value:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写一个 Jest 测试来验证 **fetchData()** 是否解析为预期的值：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This test will wait for the **fetchData()** promise to resolve, thanks to the
    **await** keyword, and then check that the resolved value matches **'hello'**
    .
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将等待 **fetchData()** 承诺解析，多亏了 **await** 关键字，然后检查解析的值是否匹配 **'hello'** 。
- en: 'Alternatively, if you’re working with asynchronous code that uses callbacks,
    you can use Jest’s **done()** callback to handle this pattern:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你正在处理使用回调的异步代码，你可以使用 Jest 的 **done()** 回调来处理这种模式：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this test, **done()** is called once the callback receives data, signaling
    to Jest that the test is complete. If there is an error in your expectation, calling
    **done()** with an **error** argument allows Jest to handle the error properly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，一旦回调接收到数据，**done()** 就会被调用一次，向 Jest 信号测试已完成。如果期望中存在错误，使用带有 **error**
    参数的 **done()** 调用允许 Jest 正确处理错误。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Configuring Continuous Integration tests* recipe in this chapter
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *配置持续集成测试* 菜谱
- en: The *Writing module code* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *编写模块代码* 菜谱 [第 5 章](B19212_05.xhtml#_idTextAnchor139)
- en: Stubbing HTTP requests
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟 HTTP 请求
- en: It is common for the Node.js applications you’re building to rely on and consume
    an external service or API. When unit testing, you do not typically want your
    test to send a request to an external service. Requests to the external service
    you’re consuming are metered or rate-limited, and you do not want your test cases
    to consume the allowance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的 Node.js 应用程序通常依赖于并消耗外部服务或 API。在进行单元测试时，你通常不希望你的测试向外部服务发送请求。你消耗的外部服务的请求是计费或速率限制的，你不想你的测试用例消耗这些配额。
- en: It’s also possible that your tests would require access to service credentials.
    This means every developer on the project would need access to those credentials
    before they could run the test suite.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能你的测试需要访问服务凭证。这意味着项目上的每个开发者都必须在运行测试套件之前访问这些凭证。
- en: To be able to unit test your code without sending a request to an external service,
    you can fake a request and response. This concept is known as stubbing. Stubbing
    can be used to mimic API calls, without sending the request. Stubbing comes with
    the additional benefit of reducing any request latency, potentially making the
    tests run faster than if they were to send real requests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在不向外部服务发送请求的情况下对代码进行单元测试，你可以伪造一个请求和响应。这个概念被称为模拟。模拟可以用来模拟 API 调用，而不发送请求。模拟还有一个额外的优点，即减少任何请求延迟，可能使测试比发送真实请求更快地运行。
- en: The test concepts of stubbing and mocking are often confused. Stubbing provides
    predefined responses to isolate the unit under test, while mocking also verifies
    interactions by ensuring methods are called with certain parameters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和模拟测试的概念经常被混淆。模拟为被测试的单元提供预定义的响应以进行隔离，而模拟也通过确保方法以某些参数被调用来验证交互。
- en: In the recipe, we will be using Sinon.js, which is a library that provides stubbing
    functionality.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 Sinon.js，这是一个提供模拟功能的库。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, let’s set up our directories and files for this recipe.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们为这个菜谱设置我们的目录和文件。
- en: 'Create a directory and initialize the project:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录并初始化项目：
- en: '[PRE34]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we’ll create a program that sends a request to a third-party service.
    Create a file named **github.mjs** :'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个向第三方服务发送请求的程序。创建一个名为 **github.mjs** 的文件：
- en: '[PRE35]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In our **github.mjs** file, we’ll send an HTTP **GET** request to the **https://api.github.com/users/**
    endpoint. Add the following to **github.mjs** :'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 **github.mjs** 文件中，我们将向 **https://api.github.com/users/** 端点发送一个 HTTP **GET**
    请求。将以下内容添加到 **github.mjs**：
- en: '[PRE36]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that we have a program that sends an HTTP request to the GitHub API, we
    can move on to the recipe steps, where we’ll learn how to stub the request.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个向 GitHub API 发送 HTTP 请求的程序，我们可以继续到菜谱步骤，我们将学习如何模拟请求。
- en: How to do it…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this recipe, we’re going to learn how to stub an HTTP request within our
    tests. But we first need to create a test case. We’ll use **node:test** to save
    having to install an additional test framework.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在测试中模拟 HTTP 请求。但首先我们需要创建一个测试用例。我们将使用 **node:test** 以避免安装额外的测试框架。
- en: 'Create a file named **github.test.mjs** :'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **github.test.mjs** 的文件：
- en: '[PRE37]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following to **github.test.mjs** to create a test case using **node:test**
    for the **getGithubUser()** function. This will send a real request to the GitHub
    API:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 **github.test.mjs** 中，以创建一个用于 **getGithubUser()** 函数的测试用例，使用 **node:test**：
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can run the test to check that it passes:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以运行测试来检查它是否通过：
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can move on to the [stubbing. We first need to instal](https://www.npmjs.com/package/sinon)
    l **sinon** ( [https://www.npmjs.com/package/sinon](https://www.npmjs.com/package/sinon)
    ) as a development dependency:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续到 [模拟](https://www.npmjs.com/package/sinon)。我们首先需要安装 l **sinon**（[https://www.npmjs.com/package/sinon](https://www.npmjs.com/package/sinon)）作为开发依赖项：
- en: '[PRE40]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, in **github.test.mjs** , we need to import **sinon** . Add the following
    just below the line where the **node:test** module is imported:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **github.test.mjs** 中，我们需要导入 **sinon**。在导入 **node:test** 模块的那行下面添加以下内容：
- en: '[PRE41]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To be able to stub the request, we need to store the output from the real request
    to the GitHub API. In this case, we’ll create a **fakeResponse** constant to return
    just the values we’re verifying. Add the following to the start of the test case:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够模拟请求，我们需要存储对 GitHub API 的真实请求的输出。在这种情况下，我们将创建一个 **fakeResponse** 常量，只返回我们正在验证的值。将以下内容添加到测试用例的开始部分：
- en: '[PRE42]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we need to add a line that instructs the test to use the stubbed **fetch()**
    function instead of the real function:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一行指令，让测试使用模拟的 **fetch()** 函数而不是真实函数：
- en: '[PRE43]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After we’ve made our **getGitHubUser('octokit')** call in the test case, we
    should restore the original **fetch()** method so that it can be used by other
    tests or code. We can do this using **sinon.restore();** . Add this below the
    line where we call **getGitHubUser('octokit')** .
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试用例中调用我们的 **getGitHubUser('octokit')** 之后，我们应该恢复原始的 **fetch()** 方法，以便其他测试或代码可以使用它。我们可以通过使用
    **sinon.restore();** 来实现这一点。将此行添加到调用 **getGitHubUser('octokit')** 的下方。
- en: 'Your full **github.test.mjs** file should now look like the following:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的完整 **github.test.mjs** 文件现在应该看起来像以下这样：
- en: '[PRE44]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s rerun the tests and check whether they still pass now that we’re mocking
    the request:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重新运行测试并检查在模拟请求后它们是否仍然通过：
- en: '[PRE45]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note the **duration_ms** value of this test run is reduced – this is because
    we are not sending a real request over the network.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次测试运行的 **duration_ms** 值减少了 – 这是因为我们没有通过网络发送真实请求。
- en: We’ve now learned how to stub an API request using Sinon.js.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何使用 Sinon.js 模拟 API 请求。
- en: How it works…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the recipe, Sinon.js is used to simulate the behavior of a function that
    fetches user data from GitHub’s API. Instead of executing an actual network request,
    which can be slow and consume limited API request quotas, we substitute the global
    **fetch()** method with a “stub.” This **stub()** function is designed to resolve
    with a predetermined object that represents a GitHub user’s data.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，Sinon.js 用于模拟从 GitHub API 获取用户数据的函数的行为。我们不是执行实际的网络请求，这可能会很慢并消耗有限的 API 请求配额，而是用“模拟”替换全局的
    **fetch()** 方法。这个 **stub()** 函数旨在解析为一个预定的对象，该对象代表 GitHub 用户的资料。
- en: 'Initially, the necessary modules and utilities are imported: **node:assert**
    for assertions, **node:test** to define the test case, and **sinon** for creating
    a stub. We also import the **getGitHubUser()** function we plan to test.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，必要的模块和实用工具被导入：**node:assert** 用于断言，**node:test** 用于定义测试用例，以及 **sinon** 用于创建模拟。我们还导入了计划要测试的
    **getGitHubUser()** 函数。
- en: Sinon.js is used to create a stub for the global **fetch()** function. The stub
    is designed to return a fake response that resembles what would be expected from
    the actual GitHub API. This fake response is a *promise* that resolves to an object
    with a **json()** method. This, in turn, returns a promise that resolves to an
    object containing the **id** , **login** , and **name** properties of our test
    GitHub user – mimicking the format of the GitHub API response.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.js 用于创建全局 **fetch()** 函数的模拟。该模拟旨在返回一个类似于实际 GitHub API 预期响应的假响应。这个假响应是一个
    *promise*，它解析为一个具有 **json()** 方法的对象。这反过来又返回一个解析为包含我们的测试 GitHub 用户 **id**、**login**
    和 **name** 属性的对象的 *promise* – 模仿 GitHub API 响应的格式。
- en: When **getGitHubUser()** is invoked with the **octokit** username, the stubbed
    **fetch()** function intercepts the call and returns a fake response. As a result,
    **getGitHubUser** **()** processes this response as if it were a real one from
    the API but without incurring network latency. After the simulated API call, the
    actual **user** object is awaited and then checked against the expected values
    to confirm that the **getGitHubUser()** function handles the response as expected.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 **octokit** 用户名调用 **getGitHubUser()** 时，模拟的 **fetch()** 函数拦截调用并返回一个假响应。因此，**getGitHubUser**
    **()** 将此响应处理为如果它是一个来自 API 的真实响应，但不会产生网络延迟。在模拟的 API 调用之后，实际的用户对象被等待并检查与预期值是否一致，以确认
    **getGitHubUser()** 函数按预期处理响应。
- en: After the assertions, **sinon.restore()** is called, which reinstates the original
    **fetch()** method. This ensures that subsequent tests or other parts of the code
    base are not affected by the stubbing of the **fetch()** method in this test.
    This practice ensures the isolation of the test and prevents side effects on other
    tests.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 断言之后，调用 **sinon.restore()**，这将恢复原始的 **fetch()** 方法。这确保了后续的测试或其他代码库的其它部分不会受到此测试中
    **fetch()** 方法模拟的影响。这种做法确保了测试的隔离性，并防止了对其他测试的副作用。
- en: This recipe provided a high-level view of the stubbing process by demonstrating
    how to stub a single method with Sinon.js. Stubbing can be used to replace any
    part of the system under test, from individual functions to entire modules, which
    can be particularly useful in a microservice architecture where services may depend
    on responses from other services.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方通过演示如何使用 Sinon.js 模拟单个方法，提供了一个对模拟过程的概述。模拟可以用来替换测试系统中的任何部分，从单个函数到整个模块，这在微服务架构中尤其有用，因为服务可能依赖于其他服务的响应。
- en: See also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Testing with Jest* recipe in this chapter
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用 Jest 进行测试* 配方
- en: The *Configuring Continuous Integration tests* recipe in this chapter
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *配置持续集成测试* 配方
- en: Using Puppeteer
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Puppeteer
- en: UI testing is a technique used to identify issues with **graphical UIs** ( **GUIs**
    ), particularly in web applications. Although Node.js is primarily a server-side
    platform, it is frequently used to develop web applications, where UI testing
    plays a critical role.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: UI 测试是一种用于识别 **图形用户界面**（**GUIs**）问题的技术，尤其是在网络应用程序中。尽管 Node.js 主要是一个服务器端平台，但它经常被用来开发网络应用程序，其中
    UI 测试发挥着关键作用。
- en: For example, if you have an application containing an HTML form, you could use
    UI testing to validate that the HTML form contains the correct set of input fields.
    UI testing can also validate interactions with the interface – such as simulating
    button clicks or hyperlink activations.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个包含 HTML 表单的应用程序，你可以使用 UI 测试来验证 HTML 表单是否包含正确的输入字段集合。UI 测试还可以验证与界面的交互，例如模拟按钮点击或超链接激活。
- en: Puppeteer is an open source library that provides a headless Chromium instance,
    which can be programmatically interacted with to automate UI tests. It is particularly
    useful for Node.js environments because of its native support and ease of integration.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 是一个开源库，它提供了一个无头 Chromium 实例，可以与它进行程序化交互以自动化 UI 测试。由于其原生支持和易于集成，它特别适用于
    Node.js 环境。
- en: n the recipe, we will use Puppeteer ( [https://pptr.dev/](https://pptr.dev/)
    ) to perform UI testing on the **http://example.com/** website. However, other
    popular alternatives for UI testing in Node.js include Selenium, Cypress, and
    Playwright. While the high-level principle and purpose of each of these tools
    are similar, each tool has its strengths and can be chosen based on specific needs
    such as cross-browser testing, ease of setup, and integration capabilities.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用 Puppeteer ([https://pptr.dev/](https://pptr.dev/)) 对 **http://example.com/**
    网站进行 UI 测试。然而，Node.js 中用于 UI 测试的其他流行替代方案包括 Selenium、Cypress 和 Playwright。虽然这些工具的高层次原理和目的相似，但每个工具都有其优势，可以根据特定的需求（如跨浏览器测试、设置简便性和集成能力）进行选择。
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Prepare your development environment for Puppeteer by setting up a new project
    directory and creating an initial test file.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置一个新的项目目录并创建一个初始测试文件来为 Puppeteer 准备你的开发环境。
- en: 'Create a directory and initialize our project directory:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录并初始化我们的项目目录：
- en: '[PRE46]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we’ll create our UI test file:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的 UI 测试文件：
- en: '[PRE47]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that we have our project directory initialized, we’re ready to move on to
    the recipe steps.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了项目目录，我们准备进入配方步骤。
- en: How to do it…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this recipe, we’ll learn how to test a web page using Puppeteer. We’re going
    to verify that we receive the expected content from **https://example.com** .
    We’ll use the Node.js core **assert** library for the assertion logic.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用 Puppeteer 测试网页。我们将验证我们从 **https://example.com** 收到预期的内容。我们将使用
    Node.js 核心库 **assert** 进行断言逻辑。
- en: 'The first step is to install the **puppeteer** module. We’ll install the **puppeteer**
    module as a development dependency as it’ll only be used for testing:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是安装 **puppeteer** 模块。我们将把 **puppeteer** 模块作为开发依赖项安装，因为它只会在测试中使用：
- en: '[PRE48]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that this may take a long time as it is downloading the Chromium headless
    browser.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这可能需要很长时间，因为它正在下载无头浏览器 Chromium。
- en: 'Next, we’ll open **test.js** and add the following lines to import both the
    **assert** and **puppeteer** modules:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将打开 **test.js** 并添加以下行以导入 **assert** 和 **puppeteer** 模块：
- en: '[PRE49]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we’ll create an asynchronous function named **runTest()** , which will
    hold all our test logic:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为 **runTest()** 的异步函数，它将包含所有的测试逻辑：
- en: '[PRE50]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Within the **runTest()** function, we need to launch Puppeteer. Do this by
    adding the following line, which calls Puppeteer’s **launch()** function:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **runTest()** 函数中，我们需要启动 Puppeteer。通过添加以下行来实现，该行调用 Puppeteer 的 **launch()**
    函数：
- en: '[PRE51]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, also inside the **runTest()** function, we need to create a new Puppeteer
    browser page:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，也在 **runTest()** 函数内部，我们需要创建一个新的 Puppeteer 浏览器页面：
- en: '[PRE52]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can now instruct Puppeteer to load a URL. We do this by calling the **goto()**
    function on the **page** object:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以指示 Puppeteer 加载一个 URL。我们通过在 **page** 对象上调用 **goto()** 函数来实现这一点：
- en: '[PRE53]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that we’ve got a handle to the web page ( **https://example.com** ), we
    can extract values from the web page by calling Puppeteer’s **$eval()** function.
    We supply the **$eval()** function the **h1** tag, indicating that we want to
    abstract the **h1** element and a callback function. The callback function will
    return the **innerText** value of the **h1** element. Add the following line to
    extract the **h1** value:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经获得了网页的句柄（ **https://example.com** ），我们可以通过调用 Puppeteer 的 **$eval()** 函数来从网页中提取值。我们向
    **$eval()** 函数提供了 **h1** 标签，表示我们想要抽象 **h1** 元素和一个回调函数。回调函数将返回 **h1** 元素的 **innerText**
    值。添加以下行以提取 **h1** 值：
- en: '[PRE54]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we can add our assertion. We expect the title to be **"Example Domain"**
    . Add the following assertion statement. We’ll also add a **console.log()** statement
    to output the value – you wouldn’t typically do this in a real test case to avoid
    noise in **STDOUT** , but it will help us see what is happening:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加我们的断言。我们期望标题为 **"Example Domain"** 。添加以下断言语句。我们还将添加一个 **console.log()**
    语句以输出值——你通常不会在真实测试用例中这样做，以避免在 **STDOUT** 中产生噪音，但它将帮助我们了解发生了什么：
- en: '[PRE55]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We need to call **browser.close()** ; otherwise, Puppeteer will continue emulating,
    and the Node.js process will never exit. Within the **runTest()** function, add
    the following line:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要调用 **browser.close()**；否则，Puppeteer 将继续模拟，Node.js 进程将永远不会退出。在 **runTest()**
    函数中，添加以下行：
- en: '[PRE56]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we just need to call our **runTest()** function. Add the following
    to the bottom of **test.js** , outside of the **runTest()** function:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需调用我们的 **runTest()** 函数。将以下内容添加到 **test.js** 的底部，在 **runTest()** 函数外部：
- en: '[PRE57]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We’re now ready to run the test. Enter the following command in your terminal
    to run the test:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以运行测试了。在您的终端中输入以下命令以运行测试：
- en: '[PRE58]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We’ve now created our first UI test using Puppeteer.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用 Puppeteer 创建了我们的第一个 UI 测试。
- en: How it works…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the recipe, we used Puppeteer to create a test that verifies that the **https://example.com**
    web page returns the heading **'Example Domain'** within an **h1** HTML element
    tag. Most of the Puppeteer APIs are asynchronous, so we used the **async** / **await**
    syntax throughout the recipe.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们使用了 Puppeteer 创建了一个测试，以验证 **https://example.com** 网页在 **h1** HTML 元素标签内返回标题
    **'Example Domain'**。大多数 Puppeteer API 都是异步的，因此我们在整个配方中使用了 **async** / **await**
    语法。
- en: When we call **puppeteer.launch()** , Puppeteer initializes a new headless Chrome
    instance that we can interact with via JavaScript. As testing with Puppeteer has
    the overhead of a headless Chrome instance, using it for testing can be less performant
    than other types of tests. However, as Puppeteer is interacting with Chrome under
    the hood, it provides a very close simulation of how end users interact with a
    web application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 **puppeteer.launch()** 时，Puppeteer 初始化了一个新的无头 Chrome 实例，我们可以通过 JavaScript
    与之交互。由于使用 Puppeteer 进行测试具有无头 Chrome 实例的开销，因此它可能不如其他类型的测试性能好。然而，由于 Puppeteer 在底层与
    Chrome 交互，它提供了非常接近最终用户与 Web 应用程序交互的模拟。
- en: Once Puppeteer was launched, we initialized a **page** object by calling the
    **newPage()** method on the **browser** object. The **page** object is used to
    represent a web page. On the **page** object, we then called the **goto()** method,
    which is used to tell Puppeteer which URL should be loaded for that object.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动了 Puppeteer，我们就通过在 **browser** 对象上调用 **newPage()** 方法初始化了一个 **page** 对象。**page**
    对象用于表示一个网页。在 **page** 对象上，我们随后调用了 **goto()** 方法，该方法用于告诉 Puppeteer 应为该对象加载哪个 URL。
- en: The **$eval()** method is called on the **page** object to extract values from
    the web page. In the recipe, we passed the **$eval()** method **h1** as the first
    parameter. This instructs Puppeteer to identify and extract the HTML **<h1>**
    element. The second parameter is a callback function, which extracts the **innerText**
    value of the **<h1>** element. For **http://example.com** , this extracted the
    **'Example** **Domain'** value.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **page** 对象上调用 **$eval()** 方法以从网页中提取值。在配方中，我们将 **$eval()** 方法的 **h1** 作为第一个参数传递。这指示
    Puppeteer 识别并提取 HTML **<h1>** 元素。第二个参数是一个回调函数，它提取 **<h1>** 元素的 **innerText** 值。对于
    **http://example.com** ，这提取了 **'Example Domain'** 值。
- en: At the end of the **runTest()** function, we called the **browser.close()**
    method to instruct Puppeteer to end the Chrome emulation. This was necessary since
    Puppeteer will continue emulating Chrome with the Node.js process never exiting.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **runTest()** 函数的末尾，我们调用了 **browser.close()** 方法来指示 Puppeteer 结束 Chrome 模拟。这是必要的，因为
    Puppeteer 将继续使用 Node.js 进程永不退出来模拟 Chrome。
- en: This is a simplistic example, but it serves as a foundation for understanding
    how UI testing automation works. This test script is easily extendable, allowing
    the simulation of more complex user interactions such as form submissions, navigation,
    and error handling.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但它为理解 UI 测试自动化工作原理奠定了基础。这个测试脚本很容易扩展，允许模拟更复杂用户交互，如表单提交、导航和错误处理。
- en: There’s more…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It’s also possible to run Puppeteer in non-headless mode. You can do this by
    passing a parameter to the **launch()** method:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在非无头模式下运行 Puppeteer。你可以通过向 **launch()** 方法传递一个参数来实现：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this mode, when you run your tests, you will see the Chromium UI and can
    follow your tests while they are executing. This can be useful when debugging
    your Puppeteer tests.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下，当你运行测试时，你会看到 Chromium UI，并且可以在测试执行时跟踪你的测试。这在调试 Puppeteer 测试时可能很有用。
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Testing with Jest* recipe in this chapter
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用 Jest 进行测试* 菜谱
- en: The *Configuring Continuous Integration tests* recipe in this chapter
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *配置持续集成测试* 菜谱
- en: Configuring Continuous Integration tests
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置持续集成测试
- en: CI is a development practice where developers regularly merge their code to
    a source repository. To maintain the integrity of the source code, automated tests
    will often be run before each code change is accepted.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（CI）是一种开发实践，开发者会定期将他们的代码合并到源代码库中。为了保持源代码的完整性，通常在每次代码更改被接受之前都会运行自动化测试。
- en: GitHub is one of the most widely used source code repository hosts. With GitHub,
    when you wish to merge a change into the main Git branch or repository, you open
    a **pull request** ( **PR** ). GitHub provides features for you to configure checks
    that should run on each PR. It’s common, and good practice, to require a PR to
    have a passing run of the application’s or module’s unit tests before it can be
    accepted.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 是最广泛使用的源代码仓库托管平台之一。使用 GitHub，当你希望将更改合并到主 Git 分支或仓库时，你将打开一个 **pull request**（**PR**）。GitHub
    提供了配置每个 PR 应该运行的检查的功能。要求 PR 在接受之前通过应用程序或模块的单元测试是一个常见且良好的实践。
- en: There are many CI products that can enable the execution of your unit tests
    (GitHub Actions, Travis CI, and many others). Most of these programs come with
    a limited free tier for casual developers and paid commercial plans for businesses
    and enterprises.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 CI 产品可以启用你的单元测试执行（GitHub Actions、Travis CI 以及许多其他）。这些程序中的大多数都为休闲开发者提供有限的免费层，为企业和企业提供了付费的商业计划。
- en: In this recipe, we will learn how to configure GitHub Actions to run our Node.js
    tests.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何配置 GitHub Actions 来运行我们的 Node.js 测试。
- en: Getting ready
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you’ll need a GitHub account. If you’re unfamiliar with Git
    and GitHub, refer to the *Scaffolding a module* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
    .
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要一个 GitHub 账户。如果你不熟悉 Git 和 GitHub，请参考 [*第 5 章*](B19212_05.xhtml#_idTextAnchor139)
    中的 *构建模块* 菜谱。
- en: To be able to configure GitHub Actions to run unit tests, we first need to create
    a GitHub repository and some example unit tests.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够配置 GitHub Actions 来运行单元测试，我们首先需要创建一个 GitHub 仓库和一些示例单元测试。
- en: Create a new GitHub repository via [https://github.com/new](https://github.com/new)
    . Name the new repository **enabling-actions** . Also, add the *Node* **.gitignore**
    template via the drop-down menu.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 [https://github.com/new](https://github.com/new) 创建一个新的 GitHub 仓库。将新仓库命名为
    **enabling-actions**。同时，通过下拉菜单添加 *Node* **.gitignore** 模板。
- en: 'Clone your GitHub repository with the following command, replacing **<username>**
    with your GitHub username:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令克隆你的 GitHub 仓库，将 **<username>** 替换为你的 GitHub 用户名：
- en: '[PRE60]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We now need to initialize our project with **npm** and install the **tape**
    test library:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要使用 **npm** 初始化我们的项目并安装 **tape** 测试库：
- en: '[PRE61]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We also need to create a test. Create a file named **test.mjs** :'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建一个测试。创建一个名为 **test.mjs** 的文件：
- en: '[PRE62]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add the following to **test.mjs** to create our unit tests:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 **test.mjs** 中以创建我们的单元测试：
- en: '[PRE63]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that we have our project initialized and some unit tests, we can move on
    to configuring GitHub Actions.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了项目并有一些单元测试，我们可以继续配置 GitHub Actions。
- en: How to do it…
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we’re going to learn how to configure CI to run our unit tests
    when a new change is pushed to our GitHub repository.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何配置 CI，以便在将新更改推送到我们的 GitHub 仓库时运行我们的单元测试。
- en: 'We need to create a GitHub Actions workflow file in our repository. Create
    a **.** **github/workflows** directory:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们的仓库中创建一个 GitHub Actions 工作流程文件。创建一个 **.** **github/workflows** 目录：
- en: '[PRE64]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add the following to the **test.yml** file. This will instruct GitHub Actions
    to run our tests using Node.js 20. Be aware that YAML files are sensitive to both
    whitespace and indentation:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 **test.yml** 文件中。这将指示 GitHub Actions 使用 Node.js 20 运行我们的测试。请注意，YAML
    文件对空白和缩进都很敏感：
- en: '[PRE65]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we’re ready to commit our code. Enter the following in your terminal to
    commit the code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好提交我们的代码。在您的终端中输入以下内容以提交代码：
- en: '[PRE66]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Navigate to **https://github.com/<username>/enabling-actions** in your browser
    and confirm your code has been pushed to the repository. Expect it to look like
    the following:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中导航到 **https://github.com/<username>/enabling-actions** 并确认您的代码已推送到仓库。预期它看起来如下：
- en: '![Figure 8.3 – GitHub UI showing the code in the enabling-actions repository](img/B19212_08_03.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – GitHub UI 显示 enabling-actions 仓库中的代码](img/B19212_08_03.jpg)'
- en: Figure 8.3 – GitHub UI showing the code in the enabling-actions repository
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – GitHub UI 显示 enabling-actions 仓库中的代码
- en: 'Once the test run has completed, GitHub Actions will indicate that the build
    is failing. This is intentional, as we purposely created a test case that is expected
    to fail. This is indicated by a red cross icon. When clicking this icon, we’ll
    see more details about the test run:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦测试运行完成，GitHub Actions 将指示构建失败。这是故意的，因为我们故意创建了一个预期会失败的测试用例。这通过一个红色的叉号图标表示。当点击此图标时，我们将看到有关测试运行的更多详细信息：
- en: '![Figure 8.4 – Failed GitHub Actions build modal](img/B19212_08_04.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 失败的 GitHub Actions 构建模态](img/B19212_08_04.jpg)'
- en: Figure 8.4 – Failed GitHub Actions build modal
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 失败的 GitHub Actions 构建模态
- en: 'Click **Details** , and it’ll take you to the **Actions** tab for that test
    run:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **详情**，它将带您到该测试运行的 **操作** 选项卡：
- en: '![Figure 8.5 – GitHub Actions build log](img/B19212_08_05.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – GitHub Actions 构建日志](img/B19212_08_05.jpg)'
- en: Figure 8.5 – GitHub Actions build log
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – GitHub Actions 构建日志
- en: Observe that we can see the specific step that failed, **Run node --test** .
    You should be able to click on each step to expand and view the logs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以看到具体的失败步骤，**Run node --test**。您应该能够点击每个步骤以展开并查看日志。
- en: We’ve successfully enabled GitHub Actions CI on our GitHub repository.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的 GitHub 仓库中成功启用了 GitHub Actions CI。
- en: How it works…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the GitHub Actions workflow configuration for a Node.js application, we outlined
    a specific CI process designed to automate testing upon commits and PRs to the
    main branch. Here’s a detailed breakdown of how the workflow functions, illustrated
    with code snippets from the **test.yml** file.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 应用程序的 GitHub Actions 工作流程配置中，我们概述了一个特定的 CI 流程，该流程旨在在向主分支提交和 PR 时自动化测试。以下是工作流程如何工作的详细分解，其中包含来自
    **test.yml** 文件的代码片段示例。
- en: 'The workflow starts with the definition of event triggers under the **on**
    key in the YAML file. It is set to activate on **push** and **pull_request** events
    specifically targeting the **main** branch:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程从在 YAML 文件中的 **on** 键下定义事件触发器开始。它被设置为在 **push** 和 **pull_request** 事件上激活，具体针对
    **main** 分支：
- en: '[PRE67]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This snippet ensures that any code pushed to **main** or any PRs made to **main**
    will initiate the CI process.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段确保任何推送到 **main** 或对 **main** 提出任何 PR 的代码都将启动 CI 流程。
- en: 'Next, we define the job environment and specify the Node.js versions to test
    against using a matrix strategy. This approach allows testing across multiple
    versions, enhancing compatibility verification:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义作业环境和指定要测试的 Node.js 版本，使用矩阵策略。这种方法允许跨多个版本进行测试，增强兼容性验证：
- en: '[PRE68]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When we use the test matrix to test across multiple versions, we can expect
    to see an interface similar to the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用测试矩阵跨多个版本进行测试时，我们可能会看到以下类似界面：
- en: '![Figure 8.6 – GitHub Actions jobs showing builds on Node.js 20 and 22](img/B19212_08_06.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – GitHub Actions 作业显示在 Node.js 20 和 22 上的构建](img/B19212_08_06.jpg)'
- en: Figure 8.6 – GitHub Actions jobs showing builds on Node.js 20 and 22
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – GitHub Actions 作业显示在 Node.js 20 和 22 上的构建
- en: 'The **runs-on: ubuntu-latest** step specifies that the job should run on the
    latest available version of Ubuntu. The **matrix.node-version** is initially set
    to test on Node.js 20, but it’s extended to also include Node.js 22, demonstrating
    how easily additional versions can be incorporated into the testing strategy.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**runs-on: ubuntu-latest** 步骤指定作业应在最新可用的 Ubuntu 版本上运行。**matrix.node-version**
    初始设置为测试 Node.js 20，但它被扩展到也包括 Node.js 22，展示了如何轻松地将额外的版本纳入测试策略。'
- en: 'Following the environment setup, the workflow includes steps to check out the
    code, setup Node.js, install dependencies, and run tests:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在环境设置之后，工作流程包括以下步骤：检出代码、设置 Node.js、安装依赖项以及运行测试：
- en: '[PRE69]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The **actions/checkout@v4** step checks out the repository contents into the
    GitHub Actions runner, allowing the workflow to access the code. The **actions/setup-node@v4**
    step configures the runner to use a specific version of Node.js as defined by
    the matrix.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**actions/checkout@v4** 步骤将仓库内容检出至 GitHub Actions 运行器，允许工作流程访问代码。**actions/setup-node@v4**
    步骤配置运行器使用由矩阵定义的特定版本的 Node.js。'
- en: By integrating these steps, the GitHub Actions workflow automates the testing
    process, ensuring that all new code integrated into the **main** branch has passed
    through a rigorous testing process. This not only ensures code quality but also
    helps in identifying issues early in the development cycle, making it easier to
    manage and fix them.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 通过整合这些步骤，GitHub Actions 工作流程自动化了测试过程，确保所有集成到 **main** 分支的新代码都通过了严格的测试流程。这不仅确保了代码质量，还有助于在开发周期早期识别问题，使其更容易管理和修复。
- en: GitHub branch protection
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 分支保护
- en: It’s possible to configure GitHub to block PRs until they have a passing build/CI
    run. This can be configured in the settings of your GitHub repository. For information
    on how to configure branch protection, refer to [https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches)
    .
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置 GitHub 以阻止合并请求（PR）直到它们通过构建/持续集成（CI）运行。这可以在您的 GitHub 仓库设置中进行配置。有关如何配置分支保护的信息，请参阅[https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches)。
- en: GitHub Actions, as with the alternative CI providers, offers a powerful and
    flexible platform for automating workflows across a wide range of development
    tasks. While this tutorial focused on setting up a CI workflow for a typical Node.js
    application, the scope of GitHub Actions extends far beyond this, allowing for
    a multitude of complex workflows.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions，就像其他 CI 提供商一样，提供了一个强大且灵活的平台，用于自动化各种开发任务的流程。虽然本教程侧重于为典型的 Node.js
    应用程序设置 CI 工作流程，但 GitHub Actions 的范围远不止于此，允许实现多种复杂的流程。
- en: See also
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Testing with node:test* recipe in this chapter
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *使用 node:test 进行测试* 菜单
- en: The *Scaffolding a module* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 5 章*](B19212_05.xhtml#_idTextAnchor139) 的 *搭建模块* 菜单'
