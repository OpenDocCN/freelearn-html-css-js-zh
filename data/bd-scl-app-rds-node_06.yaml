- en: '[CHAPTER 7](toc.xhtml#c07)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 7 章](toc.xhtml#c07)'
- en: '[API Caching](toc.xhtml#c07)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[API 缓存](toc.xhtml#c07)'
- en: '[Introduction](toc.xhtml#s196a)'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[简介](toc.xhtml#s196a)'
- en: A user opens the browser and tries to access different parts of the application.
    This causes many API calls to the backend. Normally, with a low count of users,
    the response would be quick. However, when the data grows in the application and
    a significant number of users are accessing the data simultaneously, the response
    time increases. This may lead to poor user experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 用户打开浏览器并尝试访问应用程序的不同部分。这会导致对后端进行许多 API 调用。通常，用户数量较少时，响应会很快。然而，当应用程序中的数据增长并且大量用户同时访问数据时，响应时间会增加。这可能会导致用户体验不佳。
- en: Usually, for a system, when the state of the data does not change frequently,
    for a given input, the output will mostly be the same unless something changes
    in data. Till the time, data does not change, the database query is not necessary
    to fetch the same data repetitively if you can keep a copy of the outcome somewhere.
    The process of storing this outcome and accessing it when needed is a fundamental
    concept of caching.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于一个系统，当数据的状态不经常变化时，对于给定的输入，输出将大部分相同，除非数据发生变化。在数据没有变化之前，如果你可以在某处保留结果的副本，那么就不需要重复从数据库中获取相同的数据。将此结果存储起来并在需要时访问的过程是缓存的基本概念。
- en: In this chapter, we will learn how to cache the data and use the cached data
    to serve APIs or save data of the queries so that we do not have to query the
    database for a certain time or till the time data is unchanged.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何缓存数据，并使用缓存的数据来服务 API 或保存查询数据，这样我们就不必在一定时间内或直到数据发生变化时查询数据库。
- en: '[Structure](toc.xhtml#s197a)'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结构](toc.xhtml#s197a)'
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding Caching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解缓存
- en: Introduction to Redis
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis 简介
- en: Setting Up Redis server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Redis 服务器
- en: Pros and Cons of Redis/Caching
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis/Caching 的优缺点
- en: Using Redis for Caching Data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redis 缓存数据
- en: '[Understanding Caching](toc.xhtml#s198a)'
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[理解缓存](toc.xhtml#s198a)'
- en: 'Consider yourself trying to log in to the application. After entering a username
    and password, the application takes a couple of seconds to validate and then navigate
    to the homepage. At the homepage, there are many things: project list you are
    part of, team activities on the project tasks, your high-priority tasks list,
    and many more. Bringing data for each of them is going to take a good amount of
    time if the system is busy serving too many requests already.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在尝试登录应用程序。在输入用户名和密码后，应用程序需要几秒钟来验证并导航到主页。在主页上，有许多内容：你参与的项目列表、项目任务上的团队活动、你的高优先级任务列表等等。如果系统已经忙于处理过多的请求，那么收集每个部分的数据将需要相当多的时间。
- en: All of these things on the homepage would require some data to be fetched from
    the database. The database queries are going to take time every single time you
    or other users open the application. These database query results can be *cached*.
    If cached, whenever the homepage is requested, the database queries would be avoided,
    and data will be read from the cache and sent in response. This process of caching-retrieving
    data would make responses faster and improve the user experience.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 主页上的所有这些内容都需要从数据库中获取一些数据。每次你或其他用户打开应用程序时，数据库查询都会花费时间。这些数据库查询结果可以被*缓存*。如果被缓存，那么每次请求主页时，就可以避免数据库查询，直接从缓存中读取数据并发送响应。这种缓存-检索数据的过程会使响应更快，并提高用户体验。
- en: By definition, caching is a technique to store fetched data, or calculated results
    in *cache* so that any future request asking for that data can be served faster.
    When we need to access the data, the cache will be checked first to see if the
    desired data is cached or not. If yes, then serve the data from cache. Otherwise,
    fetch the data, process it if needed, and then store it in cache so that the next
    request can be served quicker.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，缓存是一种将获取的数据或计算结果存储在*缓存*中的技术，以便任何未来请求该数据时可以更快地提供服务。当我们需要访问数据时，首先会检查缓存以查看所需数据是否已缓存。如果是的话，则从缓存中提供数据。如果不是，则获取数据，如果需要则处理它，然后将其存储在缓存中，以便下一次请求可以更快地提供服务。
- en: 'Caching is a critical component when it comes to optimization of system performance.
    It helps to lower the response time or latency, and makes the system highly scalable.
    Cache can be considered a high-speed data storage system. There are many types
    of caching: memory cache, disk cache, browser cache, database cache, and so on.
    For our use-case, we will cache the data needed for API response, and database
    query results. For the caching, we will use a software called Redis.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是系统性能优化的关键组件。它有助于降低响应时间或延迟，并使系统具有高度的可扩展性。缓存可以被视为高速数据存储系统。有许多类型的缓存：内存缓存、磁盘缓存、浏览器缓存、数据库缓存等等。对于我们的用例，我们将缓存
    API 响应所需的数据和数据库查询结果。对于缓存，我们将使用名为 Redis 的软件。
- en: '[Introduction to Redis](toc.xhtml#s199a)'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Redis 简介](toc.xhtml#s199a)'
- en: 'Quoting the content from Redis.io website:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 Redis.io 网站的内容：
- en: '*“The open source, in-memory data store used by millions of developers as a
    database, cache, streaming engine, and message broker.”*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*“被数百万开发者用作数据库、缓存、流式引擎和消息代理的开源内存数据存储。”*'
- en: In simple words, Redis can store various types of data. Most of them are simple
    Key-Value pairs. It supports various data structures such as strings, hashes,
    lists, sets, sorted sets, bitmaps, and more. We can store these kinds of data
    in Redis and access via a key.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Redis 可以存储各种类型的数据。其中大多数是简单的键值对。它支持各种数据结构，如字符串、散列、列表、集合、有序集合、位图等。我们可以在 Redis
    中存储这些类型的数据并通过键访问。
- en: Being in-memory by nature makes Redis blazingly fast for read and write operations,
    thus, making it a popular choice for caching.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本质上是内存中的，Redis 在读写操作上非常快，因此成为缓存的热门选择。
- en: Apart from the core data structures which help us store various types of data,
    Redis also offers features including data replication, persistence, sharding,
    and transaction capabilities. Redis is adopted by developers for a variety of
    applications. Redis is used by GitHub, Twitter, snapchat, stackoverflow, and many
    more. Techstacks.io maintains a list of popular websites which utilize Redis for
    their use cases.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助我们存储各种类型数据的核心数据结构外，Redis 还提供了包括数据复制、持久化、分片和事务功能在内的特性。Redis 被开发者用于各种应用。Redis
    被 GitHub、Twitter、snapchat、stackoverflow 以及许多其他公司使用。Techstacks.io 维护了一个使用 Redis
    进行用例的流行网站列表。
- en: More on Redis can be learned at - [https://redis.io](https://redis.io).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Redis 的信息可以在 - [https://redis.io](https://redis.io) 上学习。
- en: '[Setting Up Redis Server](toc.xhtml#s200a)'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[设置 Redis 服务器](toc.xhtml#s200a)'
- en: Let us start by setting up the Redis server. This section will cover the installation
    for MacOS, Ubuntu(debian), and Rocky Linux.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置 Redis 服务器。本节将涵盖 MacOS、Ubuntu(debian) 和 Rocky Linux 的安装。
- en: '[Installing Redis Server on Mac OS](toc.xhtml#s201a)'
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[在 Mac OS 上安装 Redis 服务器](toc.xhtml#s201a)'
- en: 'The easiest way to install most of the softwares on a Mac is to use `**homebrew**`.
    If `**homebrew**` is not installed, it can be installed by running:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上安装大多数软件最简单的方法是使用 `**homebrew**`。如果 `**homebrew**` 没有安装，可以通过运行以下命令进行安装：
- en: '`/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"`'
- en: This will make available a command named `**brew**` which we can use to install
    Redis server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使一个名为 `**brew**` 的命令可用，我们可以使用它来安装 Redis 服务器。
- en: '`brew install redis`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`brew install redis`'
- en: 'Once this completes, the server can be started with:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，可以使用以下命令启动服务器：
- en: '`brew services start redis`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`brew services start redis`'
- en: To verify if Redis is installed or not, we can try running `**redis-cli**` which
    is a command line interface for accessing Redis.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 Redis 是否已安装，我们可以尝试运行 `**redis-cli**`，这是访问 Redis 的命令行界面。
- en: '`redis-cli`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis-cli`'
- en: 'If Redis was successfully installed, it will open a Redis prompt as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Redis 安装成功，它将打开一个 Redis 提示符，如下所示：
- en: '`127.0.0.1:6379>`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`127.0.0.1:6379>`'
- en: If the prompt is visible, Redis is correctly installed and ready for use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提示符可见，Redis 已正确安装并准备好使用。
- en: Further, we can do a command `**ping**` which should respond as `**PONG**`.
    If it does, then everything is working fine.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以执行一个 `**ping**` 命令，它应该响应为 `**PONG**`。如果这样做，那么一切正常。
- en: '`127.0.0.1:6379> ping`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`127.0.0.1:6379> ping`'
- en: '`PONG`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`PONG`'
- en: '[Installing Redis Server on Ubuntu / Linux](toc.xhtml#s202a)'
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[在 Ubuntu / Linux 上安装 Redis 服务器](toc.xhtml#s202a)'
- en: To install the Redis on Ubuntu, we need `**lsb-release**`, `**curl**`, and `**gpg**`.
    If these are not available already, it can be installed using `**apt**`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Ubuntu 上安装 Redis，我们需要 `**lsb-release**`、`**curl**` 和 `**gpg**`。如果这些尚未安装，可以使用
    `**apt**` 进行安装。
- en: '`sudo apt install lsb-release curl gpg`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo apt install lsb-release curl gpg`'
- en: Now, we need to add the repository where the `**redis**` binaries are available.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个仓库，其中包含可用的 `**redis**` 二进制文件。
- en: '`curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg`'
- en: '`echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb
    $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb
    $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list`'
- en: '`Once the repositories are added, we can install Redis:`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`一旦添加了仓库，我们就可以安装 Redis：`'
- en: '`sudo apt-get update`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo apt-get update`'
- en: '`sudo apt-get install redis`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo apt-get install redis`'
- en: 'After this, server can be started using:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以使用以下方式启动服务器：
- en: '`sudo systemctl start redis`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo systemctl start redis`'
- en: Once the server is started, similar to Mac OS, we can verify using `**redis-cli**`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动后，类似于 Mac OS，我们可以使用 `**redis-cli**` 来验证。
- en: '[Installing Redis Server on Rocky (RHEL-based)](toc.xhtml#s203a)'
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[在 Rocky 上安装 Redis 服务器（基于 RHEL）](toc.xhtml#s203a)'
- en: We can simply use the `**dnf**` package manager to install Redis.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `**dnf**` 软件包管理器简单地安装 Redis。
- en: '`sudo dnf update -y`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo dnf update -y`'
- en: '`sudo dnf install -y redis`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo dnf install -y redis`'
- en: 'Once installed, the service can be started as:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，服务可以启动如下：
- en: '`sudo systemctl status redis`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo systemctl status redis`'
- en: Finally, we can verify using `**redis-cli**`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `**redis-cli**` 来验证。
- en: '[Pros and Cons of Caching](toc.xhtml#s204a)'
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[缓存的优缺点](toc.xhtml#s204a)'
- en: Before we proceed to use Redis for our purpose, it is important to know about
    pros and cons that caching brings in. Caching is a crucial technique but it comes
    with certain advantages and disadvantages, which we should keep in mind while
    implementing it in the application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用 Redis 来实现我们的目的之前，了解缓存带来的优缺点是很重要的。缓存是一项关键技术，但它带来了一定的优点和缺点，我们在将其应用于应用时应该牢记在心。
- en: '[Pros of Caching](toc.xhtml#s205a)'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[缓存的优点](toc.xhtml#s205a)'
- en: 'Some of the major benefits of caching are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的一些主要好处如下：
- en: '**Performance improvement**: Caching significantly reduces the time needed
    to access data, which makes the responses to the end user faster. Thus, it provides
    better and faster application performance and an improved user experience.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能提升**：缓存显著减少了访问数据所需的时间，这使得对最终用户的响应更快。因此，它提供了更好的应用性能和改进的用户体验。'
- en: '**Reduced load**: If implemented properly, most of the data is now served from
    cache which reduces the load on the application. This way, the application can
    serve more requests and operate more efficiently.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低负载**：如果正确实施，大部分数据现在都从缓存中提供服务，这减少了应用上的负载。这样，应用可以处理更多的请求并更高效地运行。'
- en: '**Cost effectiveness**: With caching in place, a single server can handle a
    larger number of requests efficiently. Consider if a server without caching was
    able to handle 100 requests per minute, and with caching, it can serve 1000 requests
    per minute. We do not need to put in more servers when the user load increases.
    Not only server costs, but the operational costs are also lowered due to decreased
    load and reduced bandwidth consumption.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本效益**：有了缓存，单个服务器可以高效地处理更多的请求。考虑一下，如果没有缓存的服务器每分钟可以处理 100 个请求，而有了缓存，它可以每分钟处理
    1000 个请求。当用户负载增加时，我们不需要添加更多的服务器。不仅服务器成本降低了，由于负载减少和带宽消耗降低，运营成本也降低了。'
- en: '**Reduced network traffic**: The caching server can be installed locally to
    the application or on another server. If done locally, it can reduce the network
    traffic. However, it must be seen if both application and caching server can stay
    on the same machine, without making the resource consumption high, such as memory
    and CPU.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少网络流量**：缓存服务器可以安装到应用所在的本地服务器上，或者安装到另一台服务器上。如果本地安装，它可以减少网络流量。然而，必须看到应用和缓存服务器是否可以保持在同一台机器上，而不会使资源消耗过高，例如内存和
    CPU。'
- en: '[Cons of Caching](toc.xhtml#s206a)'
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[缓存的缺点](toc.xhtml#s206a)'
- en: 'Some cons to be kept in mind and to be careful while doing development are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中需要注意的一些缺点和要小心的事项如下：
- en: '**Stale data**: It is important to ensure cache consistency. If the data is
    old, there should be effective cache invalidation strategies in place to remove
    old and invalid data from cache. Consider an example where you update your profile
    by updating your phone number. The application had already cached the user entity,
    which keeps your profile data in cache. When there is an update for the cached
    entity, the old data must be removed from cache and the new data must be placed
    in it.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过时数据**：确保缓存一致性很重要。如果数据过时，应该有有效的缓存失效策略来从缓存中删除旧的和无效的数据。考虑这样一个例子，你通过更新电话号码来更新你的个人资料。应用程序已经缓存了用户实体，它将你的个人资料数据保存在缓存中。当缓存的实体有更新时，旧数据必须从缓存中删除，并且新的数据必须放入其中。'
- en: It is very important to be careful while storing data in cache. At all points
    where the data might not be valid anymore, it should either be removed or replaced
    with the updated data. Sometimes, when data update is not always possible, the
    TTL kind of feature can be utilized. TTL stands for time to live. Usually, all
    caching systems provide this feature. This allows us to set a time for which the
    data should be in cache. Once the time expires, the data will be invalidated automatically.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在缓存中存储数据时非常重要的是要小心。在所有数据可能不再有效的地方，应该将其删除或替换为更新后的数据。有时，当数据更新并不总是可能时，可以利用TTL这类功能。TTL代表生存时间。通常，所有缓存系统都提供这一功能。这允许我们设置数据在缓存中应该保留的时间。一旦时间到期，数据将自动失效。
- en: '**Resource consumption**: If there is a lot of data in the application, it
    is important to decide what we are caching. Only the data which is needed most
    frequently should be cached. Otherwise, memory, disk space, and other resources
    can be a concern in a resource-constrained environment.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源消耗**：如果应用程序中有大量数据，重要的是要决定我们缓存什么。只有最常需要的数据才应该被缓存。否则，在资源受限的环境中，内存、磁盘空间和其他资源可能会成为问题。'
- en: '**Cache Miss**: When we try to access some data and it is not found in cache,
    then it is called a Cache Miss. It is important to know how it is handled. If
    data is not found in cache, the application must revert to the original data source.
    Also, when the data is fetched from the original source, it should be placed in
    cache to serve future requests faster.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存未命中**：当我们尝试访问某些数据但未在缓存中找到时，这被称为缓存未命中。了解如何处理它很重要。如果数据在缓存中找不到，应用程序必须回退到原始数据源。此外，当从原始源获取数据时，它应该被放入缓存以更快地服务未来的请求。'
- en: Handling a situation like Cache Miss is critical, as it may be expensive in
    terms of both time and resources. If there are too many requests in place and
    if there are too many Cache Miss, it will lead to an inefficient application.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 处理像缓存未命中这样的情况至关重要，因为它在时间和资源方面可能代价高昂。如果有太多的请求，并且有太多的缓存未命中，这将导致应用程序效率低下。
- en: '**Data synchronization issues**: For distributed environments, keeping the
    cached data and original data source as synchronous can be a challenge. It gets
    bigger if there are multiple caches.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据同步问题**：对于分布式环境，保持缓存数据和原始数据源同步可能是一个挑战。如果有多个缓存，这个问题会更大。'
- en: '**Complexity**: Overall, implementing caching can add more complexity to the
    system. It may also lead to additional development efforts as well as testing
    and maintenance efforts.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：总体而言，实现缓存可能会给系统增加更多的复杂性。它也可能导致额外的开发工作以及测试和维护工作。'
- en: '[Using Redis for Caching](toc.xhtml#s207a)'
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[使用Redis进行缓存](toc.xhtml#s207a)'
- en: 'In our project management system, so far, we have implemented several modules:
    users, roles, projects, and tasks. Consider this application being in use by an
    organization of 100,000 users. At the start of the office, typically 9 am, people
    are going to login and access their projects to learn about their tasks and make
    progress. If we cache a few things, the response time would improve and the user
    experience would be better.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目管理系统中，到目前为止，我们已经实现了几个模块：用户、角色、项目和任务。假设这个应用程序被一个拥有10万名用户的组织使用。在办公时间开始时，通常上午9点，人们将登录并访问他们的项目，了解他们的任务并取得进展。如果我们缓存一些东西，响应时间将得到改善，用户体验将更好。
- en: There are many strategies to caching such as on demand caching, and proactive
    caching. Proactive caching would be when we cache something at the application
    start without any user requests. This caching is done anticipating future requests.
    On the other hand, whenever something is accessed and it is a cache miss situation,
    caching at this moment would be on-demand. In case of on-demand caching, initially
    there would not be any records, and an object would be cached only after a cache
    miss.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存有许多策略，例如按需缓存和主动缓存。主动缓存是指在应用程序启动时缓存某些内容，而不需要任何用户请求。这种缓存是在预期未来请求的情况下进行的。另一方面，每当访问某个内容并且是缓存未命中情况时，此时的缓存就是按需的。在按需缓存的情况下，最初不会有任何记录，只有在缓存未命中后才会缓存对象。
- en: In our application, we could do a mix of both strategies. When the application
    starts, we can cache all users, roles, projects, and their tasks. There could
    be some specific cases when the data we want to cache is not a straightforward
    database query result, for example, if you want a count of projects and similarly
    counts of tasks in all projects, respectively. These values would be results of
    some function which we can cache. In this section, we will see how we can cache
    both types of data we are interested in caching.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们可以混合使用这两种策略。当应用程序启动时，我们可以缓存所有用户、角色、项目及其任务。可能会有一些特定的情况，当我们想要缓存的数据不是直接的数据库查询结果时，例如，如果你想要所有项目的项目计数和相应地所有项目的任务计数。这些值将是某些函数的结果，我们可以将其缓存。在本节中，我们将看到如何缓存我们感兴趣缓存的两类数据。
- en: 'Overall, we want to store the data as:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们希望以以下方式存储数据：
- en: '**Objects**: essentially JSON objects of projects, tasks, users, and so on.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：本质上是指项目的、任务的、用户的等JSON对象。'
- en: '**Numbers**: counts of projects, tasks, users, and so on.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字**：项目、任务、用户等的计数。'
- en: There can be more.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有更多。
- en: '[Updating Project Dependencies](toc.xhtml#s208a)'
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[更新项目依赖](toc.xhtml#s208a)'
- en: 'First of all, we need to update the project dependencies, that is, node modules
    in our case. The only package that we need is Redis. Let us install Redis using
    `**npm**` `**install**`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更新项目依赖，即我们案例中的节点模块。我们只需要一个包，那就是Redis。让我们使用`**npm**` `**install**`来安装Redis：
- en: '`npm install redis`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install redis`'
- en: It is better to install type definitions for Redis as well so that while doing
    development we get proper code hints.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，安装Redis的类型定义会更好，这样我们就能得到适当的代码提示。
- en: '`npm install --save-dev @types/redis`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install --save-dev @types/redis`'
- en: 'After Redis package is available, we can use it as following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当Redis包可用后，我们可以像以下示例那样使用它：
- en: '`import { createClient, RedisClient } from ''redis'';`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { createClient, RedisClient } from ''redis'';`'
- en: '`const client: RedisClient = createClient();`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`const client: RedisClient = createClient();`'
- en: '`client.on(''connect'', () => {`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.on(''connect'', () => {`'
- en: '`console.log(''Connected to Redis'');`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(''Connected to Redis'');`'
- en: '`});`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: '`client.set(''key''`, `''value'', (err, reply) => {`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.set(''key'', ''value'', (err, reply) => {`'
- en: '`if (err) throw err;`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (err) throw err;`'
- en: '`console.log(reply); // OK`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(reply); // OK`'
- en: '`});`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: '`client.get(''key'', (err, reply) => {`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.get(''key'', (err, reply) => {`'
- en: '`if (err) throw err;`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (err) throw err;`'
- en: '`console.log(reply); // value`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(reply); // value`'
- en: '`});`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: '`client.quit();`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.quit();`'
- en: In the preceding example, we are importing the `**createClient**` function and
    `**RedisClient**` for type. Next, a client is created using `**createClient()**`
    function call and using `**client.on()**` function we try to connect to the Redis
    server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们导入了`**createClient**`函数和`**RedisClient**`类型。接下来，我们使用`**createClient()**`函数调用创建了一个客户端，并使用`**client.on()**`函数尝试连接到Redis服务器。
- en: In the example discussed, we used callbacks, but we could also use async-await.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论的例子中，我们使用了回调，但我们也可以使用async-await。
- en: Using `**client.set()**`, we can set a key-value pair. This will store the key-value
    to the Redis server acting as a caching server here. When needed, we can get the
    value of the key using `**client.get()**`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`**client.set()**`，我们可以设置一个键值对。这将把键值对存储到作为缓存服务器的Redis服务器上。当需要时，我们可以使用`**client.get()**`获取键的值。
- en: Here, we are storing a simple string `**'value'**`, and if we want to store
    an object, we will have to convert the object to string using `**JSON.stringify()**`
    and store it as string. All of this is because Redis does not support JSON objects
    as values straightforwardly. To make Redis store JSON objects, we need to set
    up a Redis Module named `**RedisJSON**`. This module provides native JSON capabilities
    to Redis.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们存储了一个简单的字符串 `**'value'**`，如果我们想存储一个对象，我们必须使用 `**JSON.stringify()**` 将对象转换为字符串，并将其作为字符串存储。所有这些都是因为
    Redis 不直接支持 JSON 对象作为值。为了使 Redis 存储 JSON 对象，我们需要设置一个名为 `**RedisJSON**` 的 Redis
    模块。此模块为 Redis 提供了本地的 JSON 功能。
- en: 'The `**RedisJSON**` module is available at GitHub: `**https://github.com/RedisJSON/RedisJSON**`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`**RedisJSON**` 模块可在 GitHub 上找到：`**https://github.com/RedisJSON/RedisJSON**`。'
- en: We need to either clone this repository or download the repository zip file.
    Before continuing further, ensure that Rust is installed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要克隆此仓库或下载仓库的 zip 文件。在继续之前，请确保已安装 Rust。
- en: 'If not available, rust can be installed using:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不可用，可以使用以下方式安装 rust：
- en: '`curl --proto ''=https'' --tlsv1.2 -sSf https://sh.rustup.rs | sh`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl --proto ''=https'' --tlsv1.2 -sSf https://sh.rustup.rs | sh`'
- en: After this step completes, we can verify the installation by checking the rust
    version.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤完成后，我们可以通过检查 rust 版本来验证安装。
- en: '`rustc --version`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustc --version`'
- en: 'Once installed, we can begin building the `**RedisJSON**`. Navigate to the
    downloaded repository and run the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以开始构建 `**RedisJSON**`。导航到下载的仓库并运行以下命令：
- en: '`cargo build –release`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo build –release`'
- en: This will create the module in `**target/release/librejson.so**`. If the file
    is missing, then something went wrong and try building again.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `**target/release/librejson.so**` 中创建模块。如果文件缺失，则表示出了问题，请再次尝试构建。
- en: We need to modify the Redis configuration typically located at `**/etc/redis/redis.conf**`
    or `**/usr/local/etc/redis.conf**` and add enable to the `**redisjson.so**` module.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改 Redis 配置，通常位于 `**/etc/redis/redis.conf**` 或 `**/usr/local/etc/redis.conf**`，并添加对
    `**redisjson.so**` 模块的启用。
- en: '**On linux**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 Linux 上**'
- en: '`loadmodule /path/to/redisjson.so`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadmodule /path/to/redisjson.so`'
- en: '**On Mac**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 Mac 上**'
- en: '`loadmodule /path/to/rejson.dylib`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadmodule /path/to/rejson.dylib`'
- en: Once the module is loaded, restart Redis to enable it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载后，重新启动 Redis 以启用它。
- en: '[Cache Utility](toc.xhtml#s209a)'
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[缓存工具](toc.xhtml#s209a)'
- en: Since we’re dealing with a large number of entities to cache, using a cache
    utility class can be beneficial. This class would ideally provide functions for
    both setting and retrieving cached values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要缓存大量实体，使用缓存工具类可能是有益的。这个类理想情况下应该提供设置和检索缓存值的函数。
- en: 'Once we have the cache utility class, we can simply import it where we need
    and use the functions directly. Let us create a file `**cache_util.ts**` which
    would have the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了缓存工具类，我们就可以直接在需要的地方导入它并使用其功能。让我们创建一个名为 `**cache_util.ts**` 的文件，其中包含以下代码：
- en: '`// cache_util.ts`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`// cache_util.ts`'
- en: '`import * as redis from ''redis'';`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`import * as redis from ''redis'';`'
- en: '`export class CacheUtil {`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`export class CacheUtil {`'
- en: '`// redis client instance`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`// redis client instance`'
- en: '`private static client = redis.createClient();`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`private static client = redis.createClient();`'
- en: '`constructor() {`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor() {`'
- en: '`CacheUtil.client.connect();`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`CacheUtil.client.connect();`'
- en: '`}`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`public static async get(cacheName: string, key: string) {`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static async get(cacheName: string, key: string) {`'
- en: '`try {`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`try {`'
- en: '``const data = await CacheUtil.client.json.get(`${cacheName}:${key}`);``'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '``const data = await CacheUtil.client.json.get(`${cacheName}:${key}`);``'
- en: '`return data;`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`return data;`'
- en: '`} catch (err) {`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`} catch (err) {`'
- en: '``console.error(`Error getting cache: ${err}`);``'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.error(`Error getting cache: ${err}`);``'
- en: '`return null;`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`return null;`'
- en: '`}`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`public static async set(cacheName: string, key: string, value) {`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static async set(cacheName: string, key: string, value) {`'
- en: '`try {`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`try {`'
- en: '``await CacheUtil.client.json.set(`${cacheName}:${key}`, ''.'', value);``'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '``await CacheUtil.client.json.set(`${cacheName}:${key}`, ''.'', value);``'
- en: '`} catch (err) {`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`} catch (err) {`'
- en: '``console.error(`Error setting cache: ${err}`);``'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.error(`Error setting cache: ${err}`);``'
- en: '`}`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`public static async remove(cacheName: string, key: string) {`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static async remove(cacheName: string, key: string) {`'
- en: '`try {`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`try {`'
- en: '``await CacheUtil.client.del(`${cacheName}:${key}`);``'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '``await CacheUtil.client.del(`${cacheName}:${key}`);``'
- en: '`} catch (err) {`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`} catch (err) {`'
- en: '``console.error(`Error deleting cache: ${err}`);``'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.error(`Error deleting cache: ${err}`);``'
- en: '`}`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: The function `**set()**` can be used to set a key-value in cache and the `**get()**`
    function can be used to retrieve the values. Notice how we are using `**client.json.get()**`
    and `**client.json.set()**` to actually get and set the values. Both set and get
    functions are made static so that we can simply use those without initializing
    the class every time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `**set()**` 可以用于在缓存中设置键值对，而 `**get()**` 函数可以用于检索值。注意我们是如何使用 `**client.json.get()**`
    和 `**client.json.set()**` 实际上获取和设置值的。这两个函数都被设置为静态的，这样我们就可以直接使用它们，而无需每次都初始化类。
- en: 'We can now initialize the class once and use it everywhere. We need to do so
    in order to connect the Redis client to the server. Without making a call to `**CacheUtil.client.connect()**`
    the application will throw an error as: The client is closed.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以初始化类一次并在任何地方使用它。我们需要这样做是为了将 Redis 客户端连接到服务器。如果没有调用 `**CacheUtil.client.connect()**`，应用程序将抛出错误：客户端已关闭。
- en: Now, when the cache utility is ready, let us initialize it in `**main.ts**`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当缓存工具准备就绪时，让我们在 `**main.ts**` 中初始化它。
- en: '`// main.ts`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`// main.ts`'
- en: '`// initialise the cache utility`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 初始化缓存工具`'
- en: '`new CacheUtil();`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`new CacheUtil();`'
- en: This will make a call to the constructor and connect the client to the Redis
    server.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用构造函数并将客户端连接到 Redis 服务器。
- en: '[Caching Entities](toc.xhtml#s210a)'
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[缓存实体](toc.xhtml#s210a)'
- en: 'We previously discussed two entity caching approaches: on-demand and proactive.
    For on demand caching, we can update all of our controllers’ functions to first
    check if the data needed is in the cache or not. The following example shows how
    the `**getOneHandler**` of `**users_controller**` which is responsible for returning
    a user for a given user id:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了两种实体缓存方法：按需和主动。对于按需缓存，我们可以更新所有控制器的函数，首先检查所需数据是否在缓存中。以下示例显示了 `**users_controller**`
    的 `**getOneHandler**`，它负责根据给定的用户 ID 返回用户：
- en: '`// users_controller.ts`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`// users_controller.ts`'
- en: '`public async getOneHandler(req: Request, res: Response): Promise<void> {`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`public async getOneHandler(req: Request, res: Response): Promise<void> {`'
- en: '`if (!hasPermission(req.user.rights, ''get_details_user'')) {`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (!hasPermission(req.user.rights, ''get_details_user'')) {`'
- en: '`res.status(403).json({ statusCode: 403, status: ''error'', message: ''Unauthorised''
    });`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.status(403).json({ statusCode: 403, status: ''error'', message: ''Unauthorised''
    });`'
- en: '`return;`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`return;`'
- en: '`}`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`// check user is in cache`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 检查用户是否在缓存中`'
- en: '`**const userFromCache = await CacheUtil.get(**''**User**''**, req.params.id);**`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`**const userFromCache = await CacheUtil.get(**''**User**''**, req.params.id);**`'
- en: '`if (userFromCache) {`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (userFromCache) {`'
- en: '`res.status(200).json({ statusCode: 200, status: ''success'', data: userFromCache
    });`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.status(200).json({ statusCode: 200, status: ''success'', data: userFromCache
    });`'
- en: '`return;`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`return;`'
- en: '`} else {`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`} else {`'
- en: '`// get user from db`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 从数据库获取用户`'
- en: '`const service = new UsersService();`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`const service = new UsersService();`'
- en: '`const result = await service.findOne(req.params.id);`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`const result = await service.findOne(req.params.id);`'
- en: '`if (result.statusCode === 200) {`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (result.statusCode === 200) {`'
- en: '`delete result.data.password;`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete result.data.password;`'
- en: '`// set user in cache`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 在缓存中设置用户`'
- en: '`**CacheUtil.set(**''**User**''**, req.params.id, result.data);**`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`**CacheUtil.set(**''**User**''**, req.params.id, result.data);**`'
- en: '`}`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`res.status(result.statusCode).json(result);`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.status(result.statusCode).json(result);`'
- en: '`return;`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`return;`'
- en: '`}`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'In the function, we are making a call to `**CacheUtil.get()**` for cacheName
    `**''User''**` and the key is the `**user_id**` which is supplied in the request
    parameters. There is a chance that the requested user is not present in the cache
    so it must be checked if the returned value `**userFromCache**` is null or not.
    If it is null, then we should take the regular course and fetch the user from
    the database. If a user is present in the database, then we should also save that
    to the cache. The following line making a call to `**CacheUtil.set()**` is doing
    that for us:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数中，我们调用 `**CacheUtil.get()**` 以 `**'User'**` 作为缓存名称，键是请求参数中提供的 `**user_id**`。有可能请求的用户不在缓存中，因此必须检查返回的值
    `**userFromCache**` 是否为 null。如果是 null，则应采取常规流程并从数据库中获取用户。如果用户存在于数据库中，则还应将其保存到缓存中。以下调用
    `**CacheUtil.set()**` 的行为我们做了这件事：
- en: '`**CacheUtil.set(''User'', req.params.id, result.data);**`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`**CacheUtil.set(''User'', req.params.id, result.data);**`'
- en: This way, all of the functions can be updated to check cache before making an
    actual database query. For cases when delete api is called, the value in cache
    must also be removed. If the value is not removed, future API calls to get the
    user by `**user_id**` will return a value which does not exist in the database
    anymore.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，所有函数都可以更新为在实际数据库查询之前检查缓存。对于删除API被调用的案例，缓存中的值也必须被删除。如果值没有被删除，未来通过`**user_id**`获取用户的API调用将返回一个在数据库中不再存在的值。
- en: 'The `**delete**` function can be updated as:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`The `**delete**` function can be updated as:'
- en: '`public async deleteHandler(req: Request, res: Response): Promise<void> {`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`public async deleteHandler(req: Request, res: Response): Promise<void> {`'
- en: '`if (!hasPermission(req.user.rights, ''delete_user'')) {`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (!hasPermission(req.user.rights, ''delete_user'')) {`'
- en: '`res.status(403).json({ statusCode: 403, status: ''error'', message: ''Unauthorised''
    });`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.status(403).json({ statusCode: 403, status: ''error'', message: ''Unauthorised''
    });`'
- en: '`return;`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`return;`'
- en: '`}`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`const service = new UsersService();`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`const service = new UsersService();`'
- en: '`const result = await service.delete(req.params.id);`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`const result = await service.delete(req.params.id);`'
- en: '`// remove user from cache`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`// remove user from cache`'
- en: '`**CacheUtil.remove(**''**User**''**, req.params.id);**`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`**CacheUtil.remove(**''**User**''**, req.params.id);**`'
- en: '`res.status(result.statusCode).json(result);`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.status(result.statusCode).json(result);`'
- en: '`return;`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`return;`'
- en: '`}`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: A call to `**CacheUtil.remove()**` will remove the user from cache.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`**CacheUtil.remove()**`将从缓存中删除用户。
- en: Caching using this on-demand approach ensures the frequently used data stays
    in cache and the data which is not used does not fill up the cache. However, in
    this case, there will always be a cache miss when the data is requested for the
    first time.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种按需方法进行缓存，确保常用数据保持在缓存中，而未使用的数据不会填满缓存。然而，在这种情况下，当数据第一次被请求时，总会发生缓存未命中。
- en: '[Building Cache at Startup](toc.xhtml#s211a)'
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Building Cache at Startup](toc.xhtml#s211a)'
- en: Sometimes, it is good to fill the cache when the application starts. This may
    help in preventing some cache miss since the data requested will be there in the
    cache. Let us update `**UsersUtil**` to add a function `**putAllUsersInCache()**`
    which will fetch all of the users from the database and put them in the cache.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在应用程序启动时填充缓存是好的。这有助于防止一些缓存未命中，因为请求的数据将存在于缓存中。让我们更新`**UsersUtil**`以添加一个函数`**putAllUsersInCache()**`，该函数将从数据库中检索所有用户并将它们放入缓存。
- en: '`// function to put all users in cache`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`// function to put all users in cache`'
- en: '`public static async putAllUsersInCache() {`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static async putAllUsersInCache() {`'
- en: '`const userService = new UsersService();`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`const userService = new UsersService();`'
- en: '`const result = await userService.findAll({});`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`const result = await userService.findAll({});`'
- en: '`if (result.statusCode === 200) {`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (result.statusCode === 200) {`'
- en: '`const users = result.data;`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`const users = result.data;`'
- en: '`users.forEach(i => {`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`users.forEach(i => {`'
- en: '`CacheUtil.set(''User'', i.user_id, i);`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`CacheUtil.set(''User'', i.user_id, i);`'
- en: '`});`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: '``console.log(`All users are put in cache`);``'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.log(`All users are put in cache`);``'
- en: '`}else{`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`}else{`'
- en: '``console.log(`Error while putAllUsersInCache() => ${result.message}`);``'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.log(`Error while putAllUsersInCache() => ${result.message}`);``'
- en: '`console.log(result);`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(result);`'
- en: '`}`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: This function is making a call to `**findAll()**` using `**userService**` to
    get all of the users from the database and if the result of the query is a success,
    putting the users in the cache using `**forEach**`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数正在使用`**userService**`调用`**findAll()**`来从数据库中获取所有用户，如果查询结果成功，则使用`**forEach**`将用户放入缓存。
- en: We can call this function from `**main.ts**`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`**main.ts**`调用此函数。
- en: '`// Proactive cache update`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`// Proactive cache update`'
- en: '`setTimeout(() => {`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout(() => {`'
- en: '`UsersUtil.putAllUsersInCache();`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsersUtil.putAllUsersInCache();`'
- en: '`}, 1000 * 10 );`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`}, 1000 * 10 );`'
- en: When an application starts, it may require time to establish connections to
    databases, caching servers, and perform other initializations. It is wise to allow
    sufficient time for these connections and initializations to complete before commencing
    other operations to ensure smooth functioning of the application. Hence, we have
    put some delay (10 seconds here) using `**setTimeout**`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序启动时，它可能需要时间来建立与数据库、缓存服务器的连接，并执行其他初始化操作。在开始其他操作之前，为这些连接和初始化操作留出足够的时间是明智的，以确保应用程序的平稳运行。因此，我们使用`**setTimeout**`添加了一些延迟（这里为10秒）。
- en: Similar to `**UsersUtil**`, other entity utils can be modified to add a function
    and then we can make a call to those functions from `**main.ts**`. It is not necessary
    that those functions be called from the `**main.ts**` file. We can put those elsewhere,
    for example, `**CacheUtil**` and call `**CacheUtil**` from `**main.ts**` to `**init**`
    the caching. Likewise, it can be another function than `**putAllXXToCache**`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`**UsersUtil**`，其他实体工具也可以修改以添加一个功能，然后我们可以从`**main.ts**`中调用这些功能。这些功能不一定要从`**main.ts**`文件中调用。我们可以将它们放在其他地方，例如`**CacheUtil**`，然后从`**main.ts**`中调用`**CacheUtil**`来`**init**`缓存。同样，它可以是`**putAllXXToCache**`之外的另一个功能。
- en: '[Consideration when Using Redis](toc.xhtml#s212a)'
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[使用Redis时的注意事项](toc.xhtml#s212a)'
- en: 'Despite being a powerful in-memory data store, there are some challenges when
    it comes to using Redis. The following points discusses some of the challenges:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Redis是一个强大的内存数据存储，但在使用Redis时仍有一些挑战。以下是一些挑战的讨论点：
- en: '**Memory Limitation**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存限制**'
- en: Since it is an in-memory data store, it offers faster access but is limited
    by the system capacity. If you have a large dataset and the target is to minimize
    the cost then it could be a drawback.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于它是一个内存数据存储，它提供了更快的访问速度，但受限于系统容量。如果您有一个大数据集，目标是尽量减少成本，那么这可能会是一个缺点。
- en: '**Data Security**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据安全**'
- en: Redis, by default, is not encrypted. Although, it supports a simple password
    based authentication but does not have built-in support for SSL/TLS encryption.
    Securing data for REST APIs requires additional tools.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，Redis未加密。尽管它支持基于密码的简单认证，但没有内置的SSL/TLS加密支持。为了保护REST API的数据，需要额外的工具。
- en: '**Limited ways to Query data**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询数据的方式有限**'
- en: Redis querying capabilities are limited compared to a traditional database system.
    However, by implementing some additional logic at application level, complex queries
    can be performed.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与传统的数据库系统相比，Redis的查询能力有限。然而，通过在应用层实现一些额外的逻辑，可以执行复杂的查询。
- en: '**Single-threaded nature**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单线程特性**'
- en: Redis servers are single-threaded in nature. Most of the machines these days
    are multi-core and Redis cannot utilize more than one core. However, newer Redis
    versions put slow queries to separate threads but the requests to Redis servers
    are still handled by a single thread only.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Redis服务器本质上是单线程的。如今的大多数机器都是多核的，Redis无法利用超过一个核心。然而，较新的Redis版本将慢查询放到单独的线程中，但Redis服务器的请求仍然只由一个线程处理。
- en: '**Hosting Cost on Cloud**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云上的托管成本**'
- en: All major cloud platforms offer Redis as a service. AWS `**Elasticache**`, Azure
    Cache for Redis are some examples. These offerings can be expensive for large
    datasets.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要云平台都提供Redis作为服务。例如，AWS的`**Elasticache**`、Azure的Redis缓存都是一些例子。对于大数据集，这些服务可能很昂贵。
- en: If Redis does not perform well for your use case, other options such as Memcached,
    Apache Kafka, and others can also be explored.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Redis不适合您的用例，还可以探索其他选项，如Memcached、Apache Kafka等。
- en: '[Conclusion](toc.xhtml#s213a)'
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结论](toc.xhtml#s213a)'
- en: 'Caching can improve the user experience and greatly enhance the performance
    of an application while also making it more stable and scalable. In this chapter,
    we got familiar with the concepts of caching along with setting up Redis, a popular
    choice for caching for any size of the application. We learned and implemented
    the two caching strategies: on demand and proactive caching.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存可以提高用户体验，极大地提升应用程序的性能，同时使其更加稳定和可扩展。在本章中，我们熟悉了缓存的概念，并设置了Redis，它是任何规模应用程序缓存的流行选择。我们学习和实现了两种缓存策略：按需缓存和主动缓存。
- en: 'In the next chapter, we will implement the notification module while learning
    another aspect of Redis: Message Queue.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现通知模块，同时学习Redis的另一个方面：消息队列。
- en: '[Multiple Choice Questions](toc.xhtml#s214a)'
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[多项选择题](toc.xhtml#s214a)'
- en: What is the primary goal of implementing caching in an application?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现应用程序中缓存的 主要目标是什么？
- en: To increase data processing time.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了增加数据处理时间。
- en: To store user passwords securely.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全地存储用户密码。
- en: To reduce the time needed to access data.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了减少访问数据所需的时间。
- en: To increase network traffic.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了增加网络流量。
- en: What is a significant benefit of caching for handling database queries?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓存处理数据库查询的显著好处是什么？
- en: It increases the load on the application server.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它增加了应用服务器的负载。
- en: It helps in avoiding database queries by fetching data from the cache.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过从缓存中获取数据来帮助避免数据库查询。
- en: It decreases the application’s performance.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它降低了应用程序的性能。
- en: It consumes more bandwidth.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它消耗更多的带宽。
- en: Which of the following is not a pro of caching?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项不是缓存的优点？
- en: Performance improvement.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能提升。
- en: Reduced load on the application.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减轻应用程序的负载。
- en: Increased network traffic.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加网络流量。
- en: Cost effectiveness.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成本效益。
- en: What does TTL stand for in the context of caching?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在缓存的环境中，TTL代表什么？
- en: Time To Launch
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动时间
- en: Time To Live
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存活时间
- en: Total Time Limit
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总时间限制
- en: Time To Load
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载时间
- en: What is a ‘*cache miss*’?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是“*缓存未命中*”？
- en: When data is successfully retrieved from the cache.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当数据成功从缓存中检索时。
- en: When data is not found in the cache.
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当数据在缓存中未找到时。
- en: When the cache is fully utilized.
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当缓存被完全利用时。
- en: When the cache fails to save data.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当缓存无法保存数据时。
- en: What is a key challenge in caching for distributed environments?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分布式环境中缓存的关键挑战是什么？
- en: Simplifying user interfaces.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化用户界面。
- en: Reducing the number of users.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少用户数量。
- en: Keeping cached data and original data source synchronized.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持缓存数据和原始数据源同步。
- en: Decreasing the server costs.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 降低服务器成本。
- en: What is an advantage of building cache at startup?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动时构建缓存的优点是什么？
- en: It increases the cache size unnecessarily.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它不必要地增加了缓存大小。
- en: It ensures frequently requested data is immediately available.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它确保频繁请求的数据立即可用。
- en: It slows down the application startup.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会减慢应用程序的启动速度。
- en: It requires less development effort.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要较少的开发工作量。
- en: Which software is used for caching in the described scenario?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在描述的场景中，哪种软件用于缓存？
- en: MySQL
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MySQL
- en: Redis
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redis
- en: MongoDB
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MongoDB
- en: Oracle
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Oracle
- en: '[Answers](toc.xhtml#s215a)'
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[答案](toc.xhtml#s215a)'
- en: c
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: b
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: b
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: '[Further Readings](toc.xhtml#s216a)'
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[进一步阅读](toc.xhtml#s216a)'
- en: '[https://www.geeksforgeeks.org/caching-system-design-concept-for-beginners/](https://www.geeksforgeeks.org/caching-system-design-concept-for-beginners/)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.geeksforgeeks.org/caching-system-design-concept-for-beginners/](https://www.geeksforgeeks.org/caching-system-design-concept-for-beginners/)'
- en: '[https://redis.io](https://redis.io)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redis.io](https://redis.io)'
- en: '[https://redis.io/docs/data-types/json/](https://redis.io/docs/data-types/json/)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redis.io/docs/data-types/json/](https://redis.io/docs/data-types/json/)'
- en: '[https://www.npmjs.com/package/redis](https://www.npmjs.com/package/redis)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.npmjs.com/package/redis](https://www.npmjs.com/package/redis)'
