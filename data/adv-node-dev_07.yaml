- en: Styling Our Chat Page as a Web App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的聊天页面设置为Web应用程序
- en: In the previous chapter, you learned about Socket.io and WebSockets, which enable
    two-way communication between the server and the client. In this chapter, we'll
    continue our discussion on styling our chat page and make it look more like a
    real web app. We'll look into timestamps and formatting time and date using Moment
    methods. We'll create and render templates for `newMessage` and `newLocation`
    messages. We'll also look into auto scrolling, making the chat a little less annoying.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您了解了Socket.io和WebSockets，它们使服务器和客户端之间实现了双向通信。在本章中，我们将继续讨论如何为我们的聊天页面设置样式，使其看起来更像一个真正的Web应用程序。我们将研究时间戳和使用Moment方法格式化时间和日期。我们将创建和渲染`newMessage`和`newLocation`消息的模板。我们还将研究自动滚动，使聊天不那么烦人。
- en: Styling the chat page
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置聊天页面的样式
- en: In this section you're going to get some styles in place so our app looks a
    little less like an unstyled HTML page, and a little more like a real web app.
    Now in the following screenshot, on the left we have People panel, we're not going
    to be wiring that up yet although we are giving it a place inside of our page.
    Eventually this is going to store a list of all the people connected to the individual
    chatroom, that's going to come a bit later.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将设置一些样式，使我们的应用看起来不那么像一个未经样式处理的HTML页面，而更像一个真正的Web应用程序。现在在下面的截图中，左边是People面板，虽然我们还没有连接它，但我们已经在页面中给它了一个位置。最终，这将存储连接到个人聊天室的所有人的列表，这将在稍后完成。
- en: 'Over right side, in the main area is going to be the messages panel:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，主要区域将是消息面板：
- en: '![](img/9a3f33b5-d119-46c8-8f60-fa0e1285ac9c.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a3f33b5-d119-46c8-8f60-fa0e1285ac9c.png)'
- en: Now the individual messages are still unstyled, that's going to come later,
    but we do have a place to put all of that stuff. We have our footer, this includes
    our form for sending a message, the textbox, and the button, and it also includes
    our Send Location button.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在个别的消息仍然没有样式，这将在稍后完成，但我们有一个放置所有这些东西的地方。我们有我们的页脚，这包括我们发送消息的表单，文本框和按钮，还包括我们的发送位置按钮。
- en: Now to get all of this done we're going to add a CSS template that I've created
    for this project. We're also going to be adding some classes to our HTML; this
    is going to let us apply the various styles. Finally we'll be making a few small
    tweaks to our JavaScript to improve the user experience. Let's go ahead and dive
    in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了完成所有这些，我们将添加一个我为这个项目创建的CSS模板。我们还将向我们的HTML添加一些类；这将让我们应用各种样式。最后，我们将对我们的JavaScript进行一些小的调整，以改善用户体验。让我们继续深入。
- en: Storing the template styles
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储模板样式
- en: The first thing we're going to do is make a new folder and a new file to store
    our styles. This is going to be the template styles we'll be grabbing in just
    a moment, then we're going to go ahead and load it into `index.html` so those
    styles are used when we render the chat app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建一个新文件夹和一个新文件来存储我们的样式。这将是我们马上要获取的模板样式，然后我们将加载它到`index.html`中，这样在渲染聊天应用程序时就会使用这些样式。
- en: Now the first thing we're going to do is create a new folder inside of `public`,
    and call this folder `css`. We're going to add just one file to it, a new file
    called `styles.css`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的第一件事是在`public`中创建一个新文件夹，将这个文件夹命名为`css`。我们将向其中添加一个文件，一个名为`styles.css`的新文件。
- en: 'Now before we go off and grab any styles, let''s go ahead and import this file
    into our application, and in order to test and make sure that it''s working what
    we''re going to do is write a very simple selector, we''re going to select everything
    using the `*`, then inside of curly braces we''re going to add a style, setting
    the `color` for everything equal to `red`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们去获取任何样式之前，让我们将这个文件导入到我们的应用程序中，并为了测试和确保它工作，我们将编写一个非常简单的选择器，我们将使用`*`选择所有内容，然后在大括号内添加一个样式，将所有内容的`color`设置为`red`：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Go ahead and make your file just like this one, we''re going to save it and
    then we''ll import it over inside of `index.html`. Right at the bottom of the
    `head` tag following our `meta` tag, we''re going to add a `link` tag, this is
    going to let us link a style sheet. We have to provide two attributes to get that
    done, first off we have to tell HTML exactly what we''re linking to by specifying
    the `rel`, or relation attribute. In this case we''re trying to link a `style
    sheet`, so we''re going to provide that as the value. Now the next thing we need
    to do is provide the `href` attribute. This is similar to the `src` attribute
    for the `script` tag, it''s the path to the file you want to link. In this case
    we have that at `/css` and we just created the file `style.css`, `/styles.css`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 继续制作你的文件，就像这个一样，我们将保存它，然后在`index.html`中导入它。在`head`标签的底部跟随我们的`meta`标签，我们将添加一个`link`标签，这将让我们链接一个样式表。我们必须提供两个属性来完成这个操作，首先我们必须告诉HTML我们要链接到什么，通过指定`rel`或关系属性。在这种情况下，我们要链接一个`style
    sheet`，所以我们将提供它作为值。现在我们需要做的下一件事是提供`href`属性。这类似于`script`标签的`src`属性，它是要链接的文件的路径。在这种情况下，我们在`/css`中有一个`styles.css`文件：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With this in place we can save `index.html` and give our page a refresh over
    inside of the browser or load it up for the very first time, and what we see is
    a hideously ugly page:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存`index.html`，在浏览器中刷新页面或者首次加载页面，我们看到的是一个丑陋的页面：
- en: '![](img/6d31f100-5cd6-410c-bb6c-8d752975e20a.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d31f100-5cd6-410c-bb6c-8d752975e20a.png)'
- en: We've managed to make it even uglier than it was previously, but this is great
    because it means our style sheet file is getting imported correctly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设法使它比以前更丑，但这很好，因为这意味着我们的样式表文件被正确导入了。
- en: 'Now in order to grab the actual template we''re going to be using for the chat
    app, we''re going to visit a URL, [http://links.mead.io/chat-css](http://links.mead.io/chat-css).
    This is just a bitly link that''s going to redirect you over to a Gist, and here
    we have two options, we can grab either the minified style template or the unminified
    one:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取我们将在聊天应用程序中使用的实际模板，我们将访问一个URL，[http://links.mead.io/chat-css](http://links.mead.io/chat-css)。这只是一个将重定向您到一个Gist的bitly链接，这里有两个选项，我们可以获取压缩的样式模板或未压缩的样式模板：
- en: '![](img/4306879d-b4db-4cc9-ad71-c78af27bcbeb.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4306879d-b4db-4cc9-ad71-c78af27bcbeb.png)'
- en: I'm going to go ahead and grab minified one by either highlighting it or clicking
    Raw link which brings us to the file. We're going to grab the entire contents
    we see there, head over into Atom and paste it inside of our `styles.css` file,
    removing obviously the previous selector.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续获取压缩的文件，可以通过高亮它或点击原始链接来获取，这将带我们到文件。我们将获取我们在那里看到的全部内容，然后转到Atom并将其粘贴到我们的`styles.css`文件中，显然删除之前的选择器。
- en: 'Now that we have this in place we can give our page a refresh, although we''re
    not really going to see much improvement. Over inside of `localhost:3000` I''ll
    give the browser a refresh and clearly things are different:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这一步，我们可以刷新页面，尽管我们不会看到太多改进。在`localhost:3000`中，我将刷新浏览器，显然事情已经有所不同：
- en: '![](img/3c2a1846-aa3b-4702-907f-b8890f1494ae.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c2a1846-aa3b-4702-907f-b8890f1494ae.png)'
- en: That is because we need to apply some classes to our HTML in order to get everything
    to work correctly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们需要在我们的HTML中应用一些类，以便一切都能正确工作。
- en: Tweaking the structure for alignment
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整结构以对齐
- en: 'We''re going to need to tweak the structure, adding a few container elements
    to help with alignment. Over inside of Atom we can get this done in just a few
    moments. This template was built around a few key classes. The first one needs
    to get applied to the `body` tag by setting the `class` attribute equal to, inside
    of quotes, `chat`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调整结构，添加一些容器元素来帮助对齐。在Atom中，我们可以在短短几分钟内完成这项工作。这个模板是围绕一些关键类构建的。第一个类需要应用到`body`标签上，通过将`class`属性设置为，引号内的`chat`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This tells the style sheet load these styles for this chat page, and we're going
    to go ahead and remove `Welcome to the chat app`, this is no longer necessary.
    Now the next thing we're going to do is create a `div` tag and this `div` is going
    to house that `People` list we saw on the left-hand side. It's going to be empty
    for the moment but that's fine we can still go ahead and create it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉样式表为这个聊天页面加载这些样式，我们将继续删除`Welcome to the chat app`，这已经不再需要了。现在我们要做的下一件事是创建一个`div`标签，这个`div`将包含我们在左侧看到的`People`列表。目前它是空的，但没关系，我们仍然可以继续创建它。
- en: 'We''re going to make `div` and we''re going to give this `div`&nbsp;class,
    and that `class` is going to get set equal to the following, `chat__sidebar`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`div`，并给这个`div`添加一个类，这个`class`将被设置为`chat__sidebar`：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a naming convention used in some style sheet templates, it's really
    a matter of preference, you could call this whatever you want when you create
    the style sheet, I happen to call it `chat__sidebar`. It's a sub-element inside
    of the greater chat app.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种在一些样式表模板中使用的命名约定，这实际上是一个偏好的问题，当你创建样式表时，你可以随意命名它，我碰巧称它为`chat__sidebar`。这是一个更大的聊天应用程序中的子元素。
- en: 'Now inside the `div` tag, we''re going to add a little title using the `h3`
    tag, we''re going to give this a title of `People`, or whatever you want to call
    that sidebar list, and we''re also going to provide a `div` which will eventually
    house the individual users, although as I mentioned we''re not going to be wiring
    that up yet. Now we can go ahead and give this an `id` setting it equal to `users`
    so we can target it a bit later. And that''s all we need for the chat sidebar
    at the moment:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`div`标签中，我们将使用`h3`标签添加一个小标题，我们将给它一个标题`People`，或者你想给侧边栏列表起的任何名字，我们还将提供一个`div`，最终将包含个人用户，尽管我提到我们暂时不会将其连接起来。现在我们可以给它一个`id`，将其设置为`users`，这样我们稍后就可以定位它。这就是我们目前聊天侧边栏所需要的一切：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now the next thing that we're going to do is create a `div` tag, and this `div`
    is going to house that main area which means it's going to contain not only our
    chat messages, but also the little form at the bottom, everything on the right-hand
    side of the sidebar.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是创建一个`div`标签，这个`div`将包含主要区域，这意味着它不仅包含我们的聊天消息，还包含底部的小表单，以及侧边栏右侧的所有内容。
- en: 'This also is going to require a custom class for some styles, this one is called
    `chat__ main`, and inside of here we''re going to add not only our unordered list,
    but also our `form` and `button`. Let''s go ahead and take all of our current
    markup, the unordered list, down to the Send Location button, cut it out and paste
    it inside of `chat__main`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这也需要为一些样式创建一个自定义类，这个类叫做`chat__main`，在这里我们不仅要添加无序列表，还要添加我们的`form`和`button`。让我们继续拿出我们当前的标记，从无序列表到发送位置按钮，把它剪切出来，粘贴到`chat__main`中：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we''re not quite done yet there are a few more things to tweak. First up
    we have to add a class to our ordered list, we''ll set `class` equal to `chat__messages`,
    this is going to provide the necessary styles, and the last `div` we need to create
    is going to be for that footer. This is going to be the gray bar at the bottom
    that contains both your `form` as well as the `Send Location` button. We''re going
    to make `div` which is going to help with alignment, and we''re going to add the
    `form` and the `button` tag inside of it by cutting it out and pasting it inside
    `div` of ordered list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还没有完成，还有一些需要调整的地方。首先，我们必须为我们的有序列表添加一个类，我们将把`class`设置为`chat__messages`，这将提供必要的样式，我们需要创建的最后一个`div`是底部的灰色条，其中包含`form`和`Send
    Location`按钮。我们将创建一个`div`来帮助对齐，并且我们将把`form`和`button`标签放在里面，通过剪切并粘贴到有序列表的`div`中：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we are going to need a class here too as you might have guessed, setting
    the `class` attribute equal to the string `chat__footer`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也需要在这里添加一个类，正如你可能已经猜到的那样，将`class`属性设置为字符串`chat__footer`：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we have all of our classes in place and we can head over to the browser
    and see what we get when we give the page a refresh:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的类都已经就位，我们可以转到浏览器，看看当我们刷新页面时会得到什么。
- en: '![](img/53cf8f51-0996-4d47-bb0a-6107bcca7226.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53cf8f51-0996-4d47-bb0a-6107bcca7226.png)'
- en: 'We have our styled chat application and we can still do whatever we were able
    to do before. I can send off a message, `Hey this should still work`, hit *enter*
    and `Hey this should still work` shows up to the screen:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们样式化的聊天应用程序，我们仍然可以做以前能做的任何事情。我可以发送一条消息，`嘿，这应该仍然有效`，按*enter*，`嘿，这应该仍然有效`会显示在屏幕上：
- en: '![](img/62ddfd76-dcec-4f81-b919-975b667317d1.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62ddfd76-dcec-4f81-b919-975b667317d1.png)'
- en: 'The same thing is true for Send Location, I can send off my location, this
    is going to send it to the server, it''s going to send it to all the clients,
    and I can click the My current location link and the location is going to show
    up inside of Google Maps. We''ve maintained all of the old functionality while
    adding a nice set of styles:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发送位置也是一样，我可以发送我的位置，这会发送到服务器，发送到所有客户端，我可以点击我的当前位置链接，位置会显示在Google地图上。我们保留了所有旧的功能，同时添加了一套漂亮的样式：
- en: '![](img/789c941c-cddd-4baf-b710-d5bd55b0ff1b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/789c941c-cddd-4baf-b710-d5bd55b0ff1b.png)'
- en: Making user experience improvements
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进用户体验
- en: Now for the second half of this section I want to make some user experience
    improvements to the form next.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在本节的第二部分中，我想对表单进行一些用户体验改进。
- en: One improvement we're going to make is wiping the text value once a message
    was successfully sent. We're also going to do something similar with Send Location.
    As you might have noticed it can take up to a second or two for the Send Location
    geolocation call to actually complete, we're going to set this button to be disabled
    so someone doesn't spam it wondering what's happened. We're also going to update
    the text to say `Sending Location` so someone knows that something is happening
    in the background.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的一个改进是在成功发送消息后清除文本值。我们还将对发送位置做类似的操作。正如你可能已经注意到的，发送位置的地理位置调用实际上可能需要一秒或两秒的时间才能完成，我们将禁用此按钮，以防有人不知道发生了什么而进行垃圾邮件式的点击。我们还将更新文本，以便显示`正在发送位置`，这样某人就知道背景中正在发生一些事情。
- en: In order to get both those things done all we need to do is modify a few lines
    over inside of `index.js`. Near the bottom of the file we have our two jQuery
    event listeners, both of these are going to get changed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这两件事，我们只需要修改`index.js`内的几行。在文件底部附近，我们有两个jQuery事件监听器，这两个都将被更改。
- en: Changing the form submit listener
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改表单提交监听器
- en: 'Now the first thing we''re going to change is going to be the form submit listener.
    In `socket.emit` we fetch the value from the field, and that''s what we pass along.
    What we want to do next inside of the acknowledgment callback is clear the value.
    Once the request has been received by the server there''s no reason to keep it
    around, so what we can do is add the same `jQuery` selector, targeting the field
    where the `name` attribute equals `message`. We''re going to go ahead and clear
    its value by calling `val` once again, but instead of getting a value by providing
    no arguments, we''re going to set the value to an empty string by passing in an
    empty string as the first argument:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要改变的第一件事是表单提交监听器。在`socket.emit`中，我们从字段中获取值，这就是我们传递的值。接下来我们想要做的是在确认回调函数内清除该值。一旦服务器接收到请求，就没有理由继续保留它，所以我们可以添加相同的`jQuery`选择器，定位`name`属性等于`message`的字段。我们将继续通过再次调用`val`来清除它的值，但是不同于不提供参数获取值，我们将通过传递空字符串作为第一个参数来将值设置为空字符串：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You could set the value to anything you like, but in this case we just want
    to clear it so we're going to use the following method call.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将值设置为任何你喜欢的东西，但在这种情况下，我们只想清除它，所以我们将使用以下方法调用。
- en: 'We have the same selector twice to speed things up, we''re going to make a
    variable, we''ll call that variable `messageTextbox`, and then we can go ahead
    and set it equal to the selector we just created, and now we can refer to `messageTextbox`
    anywhere we need access to that input. We can reference it, `messageTextbox` and
    next, `messageTextbox` like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们两次使用相同的选择器以加快速度，我们将创建一个变量，我们将称该变量为`messageTextbox`，然后我们可以将其设置为我们刚刚创建的选择器，现在我们可以在任何需要访问该输入的地方引用`messageTextbox`。我们可以像这样引用它，`messageTextbox`，接下来，`messageTextbox`：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now the listener for `createMessage`, which is over inside of `server.js`,
    and we do indeed call the callback with a string. For now, we''re going to just
    remove that bogus value passing in zero arguments, like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`createMessage`的监听器，位于`server.js`内，我们确实使用一个字符串调用回调函数。现在，我们将只是删除那个虚假的传递零参数的值，就像这样：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This means that the acknowledgement function will still get called but we don''t
    actually need any data we just need to know when the server responded. Now that
    we have this in place we can go ahead and refresh things over inside `localhost:3000`,
    type a message, `Here is a message` and hit the *enter* key and we get the value
    cleared and it was indeed sent:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着确认函数仍然会被调用，但实际上我们不需要任何数据，我们只需要知道服务器何时响应。现在我们已经做好了，我们可以继续在`localhost:3000`内刷新，输入一条消息，`这是一条消息`，然后按下*enter*键，我们会得到清除的值，而且确实已经发送了：
- en: '![](img/bddd95fd-11ce-469d-b628-ccda5ee99506.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bddd95fd-11ce-469d-b628-ccda5ee99506.png)'
- en: The same thing is going to hold true if I type in a message, `Andrew` and click
    the Send button.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我输入一条消息，`安德鲁`，然后点击发送按钮，同样的事情也会发生。
- en: Updating the input tag
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新输入标签
- en: Now one thing we're going to do real quick is update the `input` tag for the
    textbox. If I refresh the page we're currently not brought right into the message
    field, it would be really nice to do that. It would also be really nice to turn
    off autocomplete, as you can see autocomplete isn't really a useful feature and
    the values inside of it are usually trash.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的一件事是快速更新文本框的`input`标签。如果我刷新页面，我们当前并没有直接进入消息字段，这样做会很好。关闭自动完成也会很好，因为你可以看到，自动完成并不是一个有用的功能，里面的值通常都是垃圾。
- en: 'So what we''re going to do over inside of Atom is add two attributes to customize
    the input. The first one is going to be `autofocus` which doesn''t require a value,
    `autofocus` is going to autofocus on the input when the HTML gets rendered, and
    the second one we''re going to add is `autocomplete`, and we''re going to set
    that equal to the string `off`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom内部，我们要做的是添加两个属性来自定义输入。第一个是`autofocus`，它不需要一个值，当HTML被渲染时，`autofocus`会自动对焦在输入上，第二个我们要添加的是`autocomplete`，我们将把它设置为字符串`off`：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this in place we can save `index.html`, head back over to Chrome, refresh
    the page and test things out. I'm going to type in `test`, I have no autocomplete
    which is good we turned that off, and if I click the Send button I am indeed still
    sending the message. I was also brought right into the textbox when I reloaded
    the page, I didn't need to do anything in order to start typing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们可以保存`index.html`，回到Chrome，刷新页面并测试一下。我会输入`test`，我们没有自动完成，这很好，我们关闭了它，如果我点击发送按钮，我确实还在发送消息。当我重新加载页面时，我也直接进入了文本框，我不需要做任何事情就可以开始输入。
- en: Customizing the Send Location
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义发送位置
- en: The next thing we're going to do is customize that Send Location button using
    a bit more jQuery. Now we're new to jQuery and this isn't really a jQuery course.
    The goal here is to change the button text and disable it while the process is
    occurring. When the process is complete, meaning that the location was either
    sent or not sent, we can return the button to its normal state, but while the
    geolocation call is happening we don't want someone spamming away.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是使用更多的jQuery来自定义发送位置按钮。现在我们对jQuery还不太熟悉，这也不是一个jQuery课程。这里的目标是改变按钮文本，并在进行过程时禁用它。当过程完成时，也就是位置被发送或未发送时，我们可以将按钮恢复到正常状态，但在地理位置调用发生时，我们不希望有人不断点击。
- en: To get that done we're going to make some tweaks to the final on listener we
    have inside of `index.js`, just next our on submit listener we have our on click
    listener. Here we're going to need to make some changes to the button, the `locationButton`
    variable we have defined. We're going to set an attribute that's going to disable
    the button.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们将对`index.js`中的最终监听器进行一些调整，在我们的提交监听器旁边，我们有一个点击监听器。在这里，我们需要对按钮进行一些更改，我们定义的`locationButton`变量。我们将设置一个属性来禁用按钮。
- en: To get that done we will reference the selector, `locationButton`, and we're
    going to call a jQuery method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们将引用选择器`locationButton`，并调用一个jQuery方法。
- en: 'Now we''re only going to disable it after we''ve confirmed they even have support
    for it, if they don''t have support for the feature there''s no reason to go ahead
    and disable it. Here `locationButton.attr` is going to let us set an attribute,
    we''re going to set the `disabled` attribute equal to the value `disabled`. Now
    this disabled needs to be in quotes as well:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只会在确认他们甚至支持它之后禁用它，如果他们不支持这个功能，就没有理由去禁用它。在这里，`locationButton.attr`将让我们设置一个属性，我们将把`disabled`属性设置为值`disabled`。现在这个`disabled`也需要加上引号：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have disabled the button we can actually test this out, we never
    undisable it so it''s going to be broken after clicking it once, but we can confirm
    that this line works. Over in the browser I''m going to give things a refresh,
    click Send Location and you can see right away that the button it does get disabled:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经禁用了按钮，我们可以实际测试一下，我们从未取消禁用它，所以在点击一次后它就会出现问题，但我们可以确认这行代码有效。在浏览器中，我将刷新一下，点击发送位置，你会立刻看到按钮被禁用了：
- en: '![](img/c72cf1b4-68f0-40ff-94b9-981ea76ab097.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c72cf1b4-68f0-40ff-94b9-981ea76ab097.png)'
- en: Now it is going to send off the location once but if I try to click it again
    the button is disabled and it's never going to refire the `click` event. The goal
    here is to only disable it while the process is actually occurring, once it's
    sent like it is here we want to re-enable it so someone can send an updated location.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它会发送位置一次，但如果我再试图点击它，按钮就会被禁用，永远不会再次触发`click`事件。这里的目标是只在实际发生过程中禁用它，一旦像这样发送了，我们希望重新启用它，这样别人就可以发送更新的位置。
- en: 'To get that done over inside of Atom we''re going to add a line of jQuery into
    both the success handler and the error handler. If things go well we''re going
    to reference `locationButton` and we''re going to remove the disabled attribute
    by using `removeAttr`. This takes just one argument, the name of the attribute,
    in this case we have that, it''s a string, `disabled`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Atom内部完成这个任务，我们将在成功处理程序和错误处理程序中添加一行jQuery。如果事情进展顺利，我们将引用`locationButton`，并使用`removeAttr`来移除禁用属性。这只需要一个参数，属性的名称，在这种情况下，我们有一个字符串`disabled`：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is going to remove the `disabled` attribute we defined previously re-enabling
    the button. And we can do the exact same thing, literally copying and pasting
    the line next inside `function`. If for some reason we''re not able to fetch the
    location, maybe the user denied the request for `geolocation`, we still want to
    disable that button so they can try again:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移除我们之前定义的`disabled`属性，重新启用按钮。我们可以做完全相同的事情，简单地复制并粘贴下一行到`function`中。如果由于某种原因我们无法获取位置，也许用户拒绝了对地理位置的请求，我们仍然希望禁用该按钮，以便他们可以再次尝试：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have this set up we can test out that code by refreshing the browser
    and trying to send off our location. We should see the button is disabled for
    a little bit and then it gets re-enabled. We can click it to prove that it is
    working as expected, and the button was re-enabled, which means we can go ahead
    and click it at a later time sending our location once again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了，我们可以通过刷新浏览器并尝试发送我们的位置来测试该代码。我们应该看到按钮在一小段时间内被禁用，然后重新启用。我们可以点击它来证明它按预期工作，并且按钮已重新启用，这意味着我们可以在以后的时间再次点击它发送我们的位置。
- en: Updating the button text
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新按钮文本
- en: Now the last thing we're going to do is update the button text while the process
    is occurring. To get that done over inside of Atom we're going to use that `text`
    method we've used in the past.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的最后一件事是在过程发生时更新按钮文本。为了完成这个任务，在Atom中我们将使用过去使用过的`text`方法。
- en: 'In the `locationButton.attr` line, we''re going to set the `text` property
    equal to, by calling text, `Sending location...`. Now, in the `index.js` file,
    the real button text is `Send Location`, I''m going to go ahead and lowercase
    `location` that to keep things uniform:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`locationButton.attr`行中，我们将把`text`属性设置为`Sending location...`。现在，在`index.js`文件中，真正的按钮文本是`Send
    Location`，我将把`location`转换为小写以保持统一。
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have this set up we are updating the text while the process occurs,
    the only thing left to do is tweak it back to its original value next by setting
    `text` equal to the string `Send location`, and we''re going to do the exact same
    thing in error handler, calling `text` passing in the string `Send location`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了，我们正在更新过程发生时的文本，唯一剩下的事情就是通过将`text`设置为字符串`Send location`来将其调整回原始值，我们将在错误处理程序中做完全相同的事情，调用`text`传入字符串`Send
    location`：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we can go ahead and test that this is working as expected, both of these
    lines (in success as well as error handler) are identical, regardless of whether
    it succeeds or fails we're going to do the same thing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续测试这是否按预期工作，这两行（成功和错误处理程序中）是相同的，无论成功与否，我们都会做同样的事情。
- en: 'Over inside of Chrome I''m going to give my page a refresh one more time, we''re
    going to click that Send Location button and you can see the button is disabled
    and the text was changed, Sending location... shows up:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中，我将再次刷新我的页面，我们将点击发送位置按钮，您可以看到按钮被禁用并且文本已更改，显示“正在发送位置...”：
- en: '![](img/5a9f7e91-19f8-4de8-863f-b3c48283d145.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a9f7e91-19f8-4de8-863f-b3c48283d145.png)'
- en: And as soon as the process is complete and the location was actually sent, the
    button returns to its default state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦过程完成并且位置实际上已发送，按钮将返回到其默认状态。
- en: With this in place we now have a much nicer user experience than we had previously.
    Not only do we have a nice set of styles, we also have a better UI for our form
    and the Send location button. That is where we are going to stop for this section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在比以前有了更好的用户体验。我们不仅拥有一套漂亮的样式，还为我们的表单和发送位置按钮提供了更好的UI。这就是我们在本节中要停止的地方。
- en: 'Let''s go ahead and make a quick commit by shutting down the server, running
    `git status`, running `git add .` to add all of those files, and finally we''re
    going to go ahead and run `git commit` with the `-m` flag providing a message,
    `Add css for chat page`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过关闭服务器，运行`git status`，运行`git add .`来快速提交所有这些文件，最后我们将继续运行`git commit`，并使用`-m`标志提供消息，`Add
    css for chat page`：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can go ahead and push this up to GitHub using `git push` and I'm going to
    avoid deploying for Heroku as of now, although you are welcome to deploy and test
    your application live.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`git push`将其推送到GitHub，并且我现在不打算部署到Heroku，尽管您可以部署并测试您的应用程序。
- en: Timestamps and formatting with Moment
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Moment中的时间戳和格式化
- en: Throughout the course we have used timestamps quite a bit, we've generated them
    in the to-do app and we also have them generated for all of our messages in the
    chat app, but we've never gone as far as formatting them to something human-readable.
    That's going to be the topic in this section, and in the next section we'll put
    that into action.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个课程中，我们已经相当多地使用了时间戳，在待办事项应用程序中生成了它们，并且在聊天应用程序中为所有消息生成了它们，但我们从未将它们格式化为可读的形式。这将是本节的主题，在下一节中我们将把它付诸实践。
- en: By the end of the next section we'll have a formatted message area with the
    name, timestamp and message, and we'll have some better styles for it as well.
    Now in this section, it's going to be all about time and timestamp, we're not
    going to make any changes to the frontend of our app, we're simply going to learn
    how time works inside of Node.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到下一节结束时，我们将拥有一个格式化的消息区域，其中包括名称、时间戳和消息，并且我们也将为其提供一些更好的样式。现在在本节中，一切都将围绕时间和时间戳展开，我们不会对应用程序的前端进行任何更改，我们只是要学习Node中的时间是如何工作的。
- en: Timestamps in Node
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node中的时间戳
- en: To explore this we're going to create a new `playground` file, over inside of
    Atom we're going to make a `playground` folder to store this file, and inside
    of the `playground` folder we can make a new file calling it `time.js`. In here
    it will play around with time, and we'll take what we learn here into the frontend
    of the application in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这一点，我们将创建一个新的`playground`文件，在Atom中我们将创建一个`playground`文件夹来存储这个文件，在`playground`文件夹中我们可以创建一个名为`time.js`的新文件。在这里，我们将玩转时间，并将在下一节将我们在这里学到的内容带入应用程序的前端。
- en: 'We are no strangers to timestamps, we know they''re nothing more than just
    integers whether positive or negative, something like `781` is a perfectly valid
    timestamp, so is something like minus a couple of billion or whatever any number
    happens to be, all valid, even `0` is a perfectly valid timestamp. Now all of
    these numbers, they''re all relative to a certain moment in history referred to
    as the Unix epoch, which is January 1,&nbsp;`1970` at midnight 0 hours 0 minutes
    and 0 seconds am. This is stored in UTC which means it''s timezone independent:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对时间戳并不陌生，我们知道它们只是整数，无论是正数还是负数，像`781`这样的数字是一个完全有效的时间戳，就像几十亿或任何数字一样，所有都是有效的，甚至`0`也是一个完全有效的时间戳。现在所有这些数字都是相对于历史上的某一时刻的，这个时刻被称为Unix纪元，即1970年1月1日午夜0时0分0秒。这是存储在UTC中的，这意味着它与时区无关：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now my time stamp `0` actually represents this moment in history perfectly,
    and positive numbers like 1000 head into the future, while negative numbers like
    -1000 head into the past. -1000 as a timestamp would represent December 31,&nbsp;1969
    at 11:59 and 59 seconds, we've gone one second into the past from January 1, `1970`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我的时间戳`0`实际上完美地代表了历史上的这一刻，而像1000这样的正数则表示未来，而像-1000这样的负数则表示过去。时间戳-1000将代表1969年12月31日11点59分59秒，我们已经从1970年1月1日过去了一秒。
- en: Now these timestamps inside of JavaScript, they're stored in milliseconds since
    the Unix epoch inside of regular Unix timestamps, they're actually stored in seconds.
    Since we are using JavaScript in this course, we will always be using milliseconds
    as our timestamp values, which means at a timestamp like this, 1000, represents
    one second into January 1^(st), since there's 1000 milliseconds in a second.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在JavaScript中，这些时间戳以毫秒存储自Unix纪元以来的时间，而在常规的Unix时间戳中，它们实际上是以秒存储的。由于我们在本课程中使用JavaScript，我们将始终使用毫秒作为我们的时间戳值，这意味着像1000这样的时间戳代表了1月1日的一秒，因为一秒钟有1000毫秒。
- en: A value like 10000 would be ten seconds into this day and so on and so forth.
    Now the problem for us was never getting the timestamp, getting the timestamp
    was really easy, all we had to do was call `new Date` calling its `getTime` method.
    Things are going to get a lot harder though and we want to format a human-readable
    value like the one we have earlier.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 像10000这样的值将是这一天的十秒，依此类推。现在对我们来说，问题从来不是获取时间戳，获取时间戳非常容易，我们只需要调用`new Date`调用它的`getTime`方法。然而，当我们想要格式化一个类似于之前的人类可读值时，情况将变得更加困难。
- en: We're going to want to print something to the screen inside of our web app that's
    not just the timestamp, we're going to want to print something like maybe five
    minutes ago, letting a user know the message was sent five minutes ago, or maybe
    you want to print the actual date with the month, day, hour, minute and A.M or
    P.M value. Regardless of what you want to print we are going to need to talk a
    bit about formatting, and this is where the default `Date` object falls short.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要在我们的Web应用程序中打印一些不仅仅是时间戳的东西，我们将要打印一些像五分钟前这样的东西，让用户知道消息是五分钟前发送的，或者你可能想打印实际的日期，包括月份、日期、小时、分钟和上午或下午的值。无论你想打印什么，我们都需要谈一谈格式化，这就是默认的`Date`对象不足的地方。
- en: Yes there are methods that allow you to get the specific values out of a date,
    like the year, the month, or the day of month, but they are very limited and it
    is a huge burden to customize.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有一些方法可以让你从日期中获取特定的值，比如年份、月份或日期，但它们非常有限，定制起来是一个巨大的负担。
- en: The Date object
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期对象
- en: 'To talk about exactly the problem let''s go ahead and pull up the documentation
    for date by Googling `mdn date`, this is going to bring us to the Mozilla Developer
    Network documentation page for *Date*, which is a really great set of documentation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论确切的问题，让我们继续查看日期的文档，通过谷歌搜索`mdn date`，这将带我们到Mozilla开发者网络文档页面上的*Date*，这是一个非常好的文档集：
- en: '![](img/a5e48e45-f523-4562-8de3-e78d4b060e5c.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5e48e45-f523-4562-8de3-e78d4b060e5c.png)'
- en: 'On this page, we have access to all of the methods available, these are all
    methods kind of like `getTime` that return something specific about the date:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，我们可以访问所有可用的方法，这些方法都类似于`getTime`，返回关于日期的特定信息：
- en: '![](img/c353a7e9-2a2a-41e1-862f-cb4f97496086.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c353a7e9-2a2a-41e1-862f-cb4f97496086.png)'
- en: For example, as shown in the previous screenshot, we have a `getDate` method
    that returns the day of the month, a value from 1 to 31\. We have something like
    `getMinutes`, which returns the current minutes for the timestamp. All of these
    exist inside of `Date`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如前面的屏幕截图所示，我们有一个`getDate`方法，返回月份的日期，一个从1到31的值。我们有像`getMinutes`这样的方法，返回时间戳的当前分钟数。所有这些都存在于`Date`中。
- en: 'Now the problem is that these are really unflexible. For example, inside Atom
    we have this little date, `Jan 1st 1970 00:00:10 am`. It''s a shorthand version
    for January. Now we can get the actual month to show you how we''ll create a variable
    called `date`. We''ll go ahead and create `new Date` and then we''re going to
    go ahead and call a method. I''m going to use `console.log` to print the value
    to the screen, and we''re going to call `date.getMonth`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题是这些方法非常不灵活。例如，在Atom中，我们有这个小日期，`1970年1月1日00:00:10`。这是1月的简写版本。现在我们可以获取实际的月份来展示给你，我们将创建一个名为`date`的变量。我们将创建`new
    Date`，然后我们将调用一个方法。我将使用`console.log`将值打印到屏幕上，我们将调用`date.getMonth`：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `getMonth` method, as defined over inside of the documentation, is going
    to return a 0-based month value from 0 to 11, where 0 is January and 11 is December.
    Over inside the Terminal, I''m going to kick off our app using `nodemon`, since
    we''re going to be restarting it quite a bit. Nodemon is in the `playground` folder
    not the `server` folder, and the file itself is called `time.js`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如文档中所定义的`getMonth`方法将返回一个基于0的月份值，从0到11，其中0是一月，11是十二月。在终端中，我将使用`nodemon`启动我们的应用程序，因为我们将经常重启它。Nodemon在`playground`文件夹中而不是`server`文件夹中，文件本身称为`time.js`：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once it''s up and running we see we get `2` back which is expected:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它运行起来，我们看到我们得到了`2`，这是预期的：
- en: '![](img/701c0e5c-0ba2-4507-8477-803d6720a833.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/701c0e5c-0ba2-4507-8477-803d6720a833.png)'
- en: It's currently March 25th 2018 and a `0` index value for March would be `2`,
    even though you commonly think of it as 3.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是2018年3月25日，而3月的`0`索引值将是`2`，尽管你通常认为它是3。
- en: 'Now the previous result is fine. We have the number 2 to represent the month,
    but getting an actual string Jan or January is going to be much more difficult.
    There is no built-in way to get this value. This means if you do want to get that
    value you''re going to have to create an array, maybe you call the array `months`,
    and you store all of the values like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在前面的结果很好。我们有数字2来表示月份，但要获得实际的字符串Jan或January将会更加困难。没有内置的方法来获取这个值。这意味着如果你想要获得这个值，你将不得不创建一个数组，也许你称这个数组为`months`，并且存储所有这样的值：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is going to be fine and it might not seem like that big of a deal for month,
    but things get just as confusing for the day of the month, like the `1st` we have.
    All we can really get back is the number 1\. Actually formatting it to 1st, 2nd,
    or 3rd is going to be much more difficult. There just are not a good set of methods
    for formatting your date.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是很好的，对于月份可能看起来并不是那么重要，但是对于月份的日期，比如我们有的`1st`，我们只能得到数字1。实际上将其格式化为1st、2nd或3rd将会更加困难。对于格式化日期，确实没有一个好的方法集。
- en: Things get even more complex when you want to have a relative time string, something
    like three minutes ago. It would be nice to print that inside the web app alongside
    the message, printing the actual month, the day and the year is not particularly
    useful. It would be cool if we could say hey this message was sent three hours
    ago, three minutes ago, or three years ago like a lot of chat applications do.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要一个相对时间字符串时，事情变得更加复杂，比如三分钟前。在web应用程序中打印这个信息会很好，打印实际的月份、日期和年份并不特别有用。如果我们能够说，嘿，这条消息是三小时前发送的，三分钟前发送的，或者三年前发送的，就像很多聊天应用程序所做的那样，那就太酷了。
- en: Using Moment for timestamps
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Moment进行时间戳
- en: Now when you get into formatting like this, your first instinct is usually to
    create some utility methods that help with formatting a date. But there is no
    need to do that because what we're going to look at in this section is a fantastic
    time library called **Moment**. Moment is pretty much the only library of its
    kind. It is universally accepted as the go-to library for working with time and
    JavaScript, I've never worked on a Node or frontend project that didn't have Moment
    used, it is truly essential when you're working with dates in any capacity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你涉及到这样的格式化时，你的第一反应通常是创建一些实用方法来帮助格式化日期。但是没有必要这样做，因为我们在这一部分要看的是一个名为**Moment**的了不起的时间库。Moment几乎是其类别中唯一的库。它被普遍认为是处理时间和JavaScript的首选库，我从来没有在一个没有使用Moment的Node或前端项目上工作过，当你以任何方式处理日期时，它确实是必不可少的。
- en: 'Now in order to show off why Moment is so great we are going to first install
    it over inside of the Terminal. Then we''re going to play around with all of its
    capabilities, it has a lot. We can install it by running `npm i`, I''m going to
    go ahead and use the current version `moment@` version `2.21.0`, and I will also
    use the `--save` flag to add it as a dependency, a dependency that we''re going
    to need on Heroku as well as locally:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示Moment为什么如此出色，我们首先要在终端内安装它。然后我们将玩弄它的所有功能，它有很多。我们可以通过运行`npm i`来安装它，我将使用当前版本`moment@`版本`2.21.0`，并且我还将使用`--save`标志将其添加为一个依赖项，这是我们在Heroku上以及本地都需要的一个依赖项：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now once it's installed I can use `clear` to clear the Terminal output, and
    we can go ahead and restart `nodemon`. Over inside the `playground` folder it's
    time to require Moment and take a look at exactly what it can do for us.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它安装好了，我可以使用`clear`来清除终端输出，然后我们可以继续重新启动`nodemon`。在`playground`文件夹内，是时候引入Moment并且看看它对我们能做什么。
- en: 'To kick things off, let''s go ahead and try to fix the problem we tried to
    solve with date. We want to print the shorthand version of a month like Jan, Feb,
    and so on. The first step is going to be to comment the previous code out and
    load in Moment previous at the top, requiring it. I''m going to make a variable
    called `moment` and `require` it by requiring the `moment` library:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们试着解决我们之前尝试解决日期问题。我们想要打印月份的简写版本，比如Jan、Feb等。第一步将是将之前的代码注释掉，并在顶部加载之前的Moment，需要它。我将创建一个名为`moment`的变量，并通过`require`来加载`moment`库：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then next to this code, we''ll kick things off by making a new moment. Now
    just like we create a new date to get a specific date object, we''re going to
    do the same thing with moment. I''m going to call this variable `date` and we''re
    going to set it equal to a call to `moment`, the function we loaded in previous,
    without any arguments:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在这段代码旁边，我们将通过创建一个新的moment来开始。现在就像我们创建一个新的日期来获得一个特定的日期对象一样，我们将用moment做同样的事情。我将把这个变量称为`date`，并且我们将把它设置为调用`moment`的结果，之前我们加载的函数，不带任何参数：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This creates a new moment object that represents the current point in time.
    From here we can go ahead and try to format things using its really useful format
    method. The format method is one of the main reasons I just love Moment, it makes
    it dead simple to print whatever you want as a string. Now in this case, we have
    access to our `date` and we''re going to go ahead and call that method I just
    talked about, `format`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个代表当前时间点的新moment对象。从这里，我们可以尝试使用它非常有用的`format`方法来格式化东西。`format`方法是我喜欢Moment的主要原因之一，它使得打印任何你想要的字符串变得非常简单。现在在这种情况下，我们可以访问我们的`date`，然后我们将调用我刚才谈到的方法，`format`：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Before we get into what we pass to format let''s go ahead and run it just like
    this. When we do that over inside the Terminal,&nbsp;`nodemon` is going to go
    ahead and restart itself, and right here we have our formatted date:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论传递给格式的内容之前，让我们继续运行它就像这样。当我们在终端内运行时，`nodemon`将会重新启动自己，然后我们就有了我们格式化后的日期：
- en: '![](img/09dfe202-8b94-4d2e-9148-910bc280f381.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09dfe202-8b94-4d2e-9148-910bc280f381.png)'
- en: We have the year, the month, the day, and other values. It's not still really
    user-friendly but it is a step in the right direction. The real power of the `format`
    method comes when you pass a string inside of it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有年份、月份、日期和其他值。它仍然不是非常用户友好，但这是朝着正确方向迈出的一步。`format`方法的真正威力是当你在其中传递一个字符串时。
- en: 'Now what we pass inside the format method is patterns, which means that we
    have access to a specific set of values we can use to output certain things. We''re
    going to explore all of the patterns available to you in just a second. For now,
    let''s go ahead and just use one; it''s the triple uppercase `M` pattern:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们传递到格式方法中的是模式，这意味着我们可以访问一组特定的值，我们可以用来输出某些东西。我们将在接下来的一秒钟内探索所有可用的模式。现在，让我们继续使用一个；就是三个大写的`M`模式：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When Moment sees this pattern inside, format it''s going to go ahead and grab
    the shorthand version of the month, which means if I save this file and restart
    it over inside the Terminal once again. We should now see the shorthand version
    for the current month September, which would be `Mar`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当Moment看到格式中的这个模式时，它将继续抓取月份的简写版本，这意味着如果我保存这个文件，并再次在终端中重新启动它。我们现在应该看到当前月份九月的简写版本，即`Mar`：
- en: '![](img/7f448c25-b528-4178-a784-c7e91e0edb68.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f448c25-b528-4178-a784-c7e91e0edb68.png)'
- en: 'Right here we have `Sep` just as expected and we were able to do that super
    simply by using the format method. Now format returns a string that has just the
    things you specify. Here we only specified that we want the shorthand version
    of the month, so all we got back was the shorthand version of the month. We can
    also add on another pattern, four Ys, which prints out the full year; in the current
    case, it would print out 2016 in numbers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们得到了`Sep`，正如我们所期望的那样，我们能够通过使用格式方法来简单地实现这一点。现在格式返回一个字符串，其中只包含你指定的内容。在这里，我们只指定了我们想要月份的简写版本，所以我们得到的只是月份的简写版本。我们还可以添加另一个模式，四个Y，它打印出完整的年份；在当前情况下，它将以数字形式打印出2016：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I''m going to go ahead and save time again and right here we get `Mar 2018`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续节省时间，这里我们得到了`Mar 2018`：
- en: '![](img/f4841c9e-078c-442a-aabb-c73d488643ad.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4841c9e-078c-442a-aabb-c73d488643ad.png)'
- en: Now Moment has a fantastic set of documentation so you can use whatever patterns
    you like.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Moment有一套很棒的文档，所以你可以使用任何你喜欢的模式。
- en: The Moment documentation
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Moment文档
- en: 'Over inside the browser we can pull it up by going to [momentjs.com](http://momentjs.com/).
    The documentation for Moment is fantastic. It''s available on the Docs page, and
    to get started in order to figure out how to use format we''re going to go to
    the Display section:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们可以通过访问[momentjs.com](http://momentjs.com/)来查看。Moment的文档非常棒。它可以在文档页面上找到，并且为了开始弄清楚如何使用格式，我们将转到显示部分：
- en: '![](img/42fd1a1c-2659-4e82-8f78-0fe72fb74169.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42fd1a1c-2659-4e82-8f78-0fe72fb74169.png)'
- en: 'The first item in Display is format. There are a few examples about how to
    use format, but the really useful information is what we have here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 显示中的第一项是格式。有一些关于如何使用格式的示例，但真正有用的信息是我们在这里拥有的：
- en: '![](img/391118ab-b11c-4efb-894c-a3aa20754a99.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/391118ab-b11c-4efb-894c-a3aa20754a99.png)'
- en: Here we have all the tokens that we can put inside the string to format our
    day as we like. Up previous you can see you can use as many of these tokens as
    you like to create really complex date outputs. Now we already explored two. We
    explored `MMM`, which is defined right under the Month header, as you can see
    there are five different ways to represent the month.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有我们可以放入字符串中以我们喜欢的方式格式化日期的所有标记。在上面，你可以看到你可以使用尽可能多的这些标记来创建非常复杂的日期输出。现在我们已经探索了两个。我们探索了`MMM`，它就在月份标题下面定义，你可以看到有五种不同的表示月份的方式。
- en: 'The `YYYY` pattern which we used for a year is also defined here. There are
    three ways to use year. We just explored one of them. And there are sections for
    everything, year, day of week, day of month, AM/PM, hour, minute, second, all
    of those are defined, and all of them can be put inside a format just like we
    did for the current values:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于年份的`YYYY`模式也在这里定义了。有三种使用年份的方式。我们刚刚探索了其中一种。每个部分都有，年份、星期几、月份中的日期、上午/下午、小时、分钟、秒，所有这些都有定义，都可以像我们为当前值所做的那样放入格式中：
- en: '![](img/aabd1d7f-6ccc-40dc-bc81-02384046a1c7.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aabd1d7f-6ccc-40dc-bc81-02384046a1c7.png)'
- en: 'Now in order to explore this just a little more, let''s head back into Atom
    and take advantage of some of these. What we''re going to try to do is print the
    date like this: `Jan 1st 1970`, the shorthand month and the year which we already
    have, but now we also need the day of the month formatted like 1st, 2nd, 3rd,
    as opposed to 1, 2, 3.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更深入地探索一下，让我们回到Atom，并利用其中的一些功能。我们要尝试的是打印日期，如`Jan 1st 1970`，我们已经有了简写的月份和年份，但现在我们还需要将月份的日期格式化为1st、2nd、3rd，而不是1、2、3。
- en: Formatting date using Moment
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Moment格式化日期
- en: In order to do that what I would do if I had not used Moment before is I would
    look in the docs for the Day of Month section, and I look at the available options.
    I have the D pattern that prints 1 through 31, Do&nbsp;that prints what we want,
    1st, 2nd, 3rd, so on and so forth, and DD that prints the number with a 0 in front
    of it for the values less than 10.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '为了做到这一点，如果我以前没有使用过Moment，我会在文档中查找日期部分，然后查看可用的选项。我有打印1到31的D模式，打印我们想要的1st、2nd、3rd等的Do模式，以及对于小于10的值，打印带有0的数字的DD模式。 '
- en: 'Now in this case we want to use Do pattern so all we have to do is type it
    over inside format. I''m going to open up the Terminal and Atom so we can see
    it refresh in the background, and we''re going to type:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这种情况下，我们想使用Do模式，所以我们只需要在格式中输入它。我将打开终端和Atom，这样我们就可以看到后台中的刷新，然后我们将输入：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Saving the file, when it starts, we get `March 25th 2018`, which is indeed
    correct:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，当它启动时，我们得到了`March 25th 2018`，这确实是正确的：
- en: '![](img/778ba947-0c63-4da7-bbd9-6b78057a4fb2.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/778ba947-0c63-4da7-bbd9-6b78057a4fb2.png)'
- en: 'Now we can also add other characters like a comma:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还可以添加其他字符，比如逗号：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A comma is not part of the patterns that format expects so it''s simply going
    to pass it through, which means the comma gets shown just as we typed it in `March
    25th, 2018`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号不是格式期望的一部分，所以它只是简单地通过，这意味着逗号会像我们输入的那样显示在 `March 25th, 2018` 中：
- en: '![](img/ebb449d2-2791-4690-ae46-ab4b89d4df45.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebb449d2-2791-4690-ae46-ab4b89d4df45.png)'
- en: Using format in this way gives us a lot of flexibility as to how we want to
    print the date. Now format is just one of the many methods. There are a ton of
    methods on Moment for doing just about anything, although I find I use pretty
    much the same six in most of my projects. There really isn't a lot of need for
    most of them although they do exist because they are useful in certain situations.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用 `format` 给了我们很大的灵活性，以便我们可以打印日期。现在 `format` 只是众多方法中的一个。Moment 有很多方法可以做几乎任何事情，尽管我发现我在大多数项目中使用的方法基本相同。大多数情况下并不需要它们，尽管它们存在是因为它们在某些情况下很有用。
- en: The Manipulate section in Moment
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Moment 中的 Manipulate 部分
- en: 'To take a quick peek at some other things Moment can do, let''s head back into
    the docs and go to the Manipulate section:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速了解 Moment 还能做些什么，让我们回到文档并转到 Manipulate 部分：
- en: '![](img/1f543e15-164e-4eb2-b000-386e09066ace.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f543e15-164e-4eb2-b000-386e09066ace.png)'
- en: 'The first two methods defined under Manipulate are `add` and `subtract`. This
    lets you easily add and subtract time. We can call `add` adding seven days and
    we can call `subtract` subtracting seven months as shown in this example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Manipulate 下定义的前两个方法是 `add` 和 `subtract`。这让你可以轻松地添加和减去时间。我们可以调用 `add` 添加七天，我们可以调用
    `subtract` 减去七个月，就像这个例子中所示的那样：
- en: '![](img/f6c2f71b-2557-4069-957e-110252ce734d.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c2f71b-2557-4069-957e-110252ce734d.png)'
- en: 'To this example, you can get a quick idea about what you can add and subtract,
    years, quarters, months, weeks, pretty much any unit of time can be added or subtracted:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，你可以快速了解你可以添加和减去什么，年份、季度、月份、周数，几乎任何时间单位都可以被添加或减去。
- en: '![](img/8f677abb-6bc9-4411-bd7d-a1e66db606d1.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f677abb-6bc9-4411-bd7d-a1e66db606d1.png)'
- en: 'Now to take a look at what exactly that does to the timestamp, we can go ahead
    and add and subtract some values. I''m going to call `date.add` and we''re going
    to go ahead and add a year by putting `1` in as the value and `year` in as the
    unit:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看这对时间戳的确切影响，我们可以添加和减去一些值。我将调用 `date.add`，然后我们将添加一年，将 `1` 作为值，`year` 作为单位：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now it doesn''t matter if you use the single or plural version, both are going
    to work the same. Here you can see we get `2019` in the Terminal:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在无论你使用单数还是复数版本都没关系，两者都会起同样的作用。在这里你可以看到我们在终端中得到了 `2019`：
- en: '![](img/bbb1d15e-0df1-44ba-a8b4-382c79e6d877.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbb1d15e-0df1-44ba-a8b4-382c79e6d877.png)'
- en: 'If I change it to year singular, I also get that same value. We can add as
    many years as we like, I''m going to go ahead and add `100` years:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将它改为单数形式，我也会得到相同的值。我们可以添加任意多的年份，我将继续添加 `100` 年：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And now we''re at `2118`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们到了 `2118`：
- en: '![](img/817d6368-31ce-4b36-a887-1014350bd131.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/817d6368-31ce-4b36-a887-1014350bd131.png)'
- en: 'The same thing is true with `subtract`. We can chain on the call or we can
    add it as a separate statement. I''m going to subtract just like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`subtract` 也是一样的。我们可以链接调用，也可以将其添加为单独的语句。我要像这样减去：'
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And we are currently in September, and when we subtract 9 months we go back
    to June:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们现在是在九月，当我们减去9个月时，我们回到了六月：
- en: '![](img/1117f12c-1fa8-4385-ae25-7eecc14f2671.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1117f12c-1fa8-4385-ae25-7eecc14f2671.png)'
- en: Now you notice we went from `2118`&nbsp;to `2117`&nbsp;because subtracting those
    9 months required us to change years. Moment is really great at handling just
    about anything you throw at it. Now we're going to be to play around with format
    a little more. I'm going add an output I would like and we'll need to figure out
    which patterns to use over inside of the documentation to get that output.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你会注意到我们从 `2118` 到 `2117`，因为减去那9个月需要我们改变年份。Moment 真的很擅长处理你扔给它的任何事情。现在我们将继续玩一下
    `format`。我要添加一个我想要的输出，然后我们需要在文档内部找出要使用的模式。
- en: Now the current time at the writing, this is 10:35, and it is in the am, so
    I have a lowercase am. Your goal is to print a format like this. Now obviously
    if it's 12:15 when you run the code you're going to see 12:15 as opposed to 10:35;
    it's just the format that matters, the actual values aren't that important. Now
    as you'll see when you try to print hours and minutes, you're going to have a
    lot of options. For both of them you're going to have a padded version like 01
    or an unpadded version like 1.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在写作的当前时间是10:35，而且是上午，所以我有一个小写的上午。你的目标是打印一个这样的格式。现在显然，如果你运行代码时是12:15，你会看到12:15而不是10:35；只有格式很重要，实际值并不那么重要。现在当你尝试打印小时和分钟时，你会有很多选项。对于它们两个，你会有一个像01这样的填充版本，或者像1这样的未填充版本。
- en: I want you to use the padded version for minutes and the unpadded version for
    hours, which would be 6, like this, and 01\. If you padded the hour it looks kind
    of weird, and if you don't pad the minute it looks just terrible. So we would
    want to print something like this if it happened to be 6:01 am. Now for hour,
    you're also going to have the option to do either 1 to 12 or 1 to 24, I usually
    use a 12-hour clock so I'm going to do that using am.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你使用填充版本的分钟和未填充版本的小时，就像这样，6 和 01。如果你填充了小时，它看起来有点奇怪，如果你不填充分钟，它看起来就很糟糕。所以如果碰巧是上午6:01，我们会想要打印出这样的东西。现在对于小时，你也可以选择使用1到12或1到24，我通常使用12小时制，所以我会使用上午。
- en: 'Before we start, I am going to comment out the previous code, I would like
    you to write everything from scratch. I am going to make a new variable `date`
    by calling `moment` with no arguments, and we''re also going to go ahead and call
    format inside `console.log` so we can print that formatted value to the screen,
    `date.format`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我要注释掉之前的代码，我希望你从头开始写。我将通过调用没有参数的 `moment` 来创建一个新变量 `date`，然后我们还将调用 `console.log`
    中的 `format`，这样我们就可以将格式化的值打印到屏幕上，`date.format`：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Inside the quotes, we''re going to provide our pattern and start with the unpadded
    hour and the padded minute. We can grab both of those patterns by heading over
    to the docs, going back to Display, and taking a peek. If we scroll next, the
    first one we''re going to run into is Hour and we have quite a few options:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在引号内，我们将提供我们的模式，并从未填充的小时和填充的分钟开始。我们可以通过查看文档，返回到Display，然后查看一下，来获取这两个模式。如果我们滚动到下一个，我们将遇到的第一个是Hour，我们有很多选项：
- en: '![](img/f836266a-224d-4adf-91c0-01008d912590.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f836266a-224d-4adf-91c0-01008d912590.png)'
- en: 'We have 24-hour options, we have 1 through 12; what we want is lowercase h
    which is 1 through 12 unpadded. The padded version, which is hh, exists right
    next that is not what we want for this one. We''re going to kick things off by
    adding an h:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有24小时制的选项，我们有1到12；我们想要的是小写的h，即1到12不填充。填充版本，即hh，就在旁边，这不是我们想要的。我们将通过添加一个h来开始：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'I''m also going to save the file, check it out in the Terminal:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我也要保存文件，然后在终端中查看：
- en: '![](img/29f7e70c-cfb1-4cb1-ac86-4de5ca809c5b.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29f7e70c-cfb1-4cb1-ac86-4de5ca809c5b.png)'
- en: 'We have `4`, which looks great. Next up is that padded minute, we''re going
    to go ahead and find that pattern just next. For minute we have a lot fewer options,
    either padded or unpadded, we want to use mm. Now before I add mm, I am going
    to add a colon. This is going to get passed through in plain text, meaning it''s
    not going to get changed. We''re going to add our two lowercase ms:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`4`，看起来很好。接下来是填充的分钟，我们将继续找到紧挨着的模式。对于分钟，我们的选择要少得多，要么填充，要么不填充，我们要使用mm。在我添加mm之前，我要添加一个冒号。这将以纯文本形式传递，意味着它不会被更改。我们将添加两个小写的ms：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can then save `time.js` and make sure the correct thing prints in the Terminal,
    and it does, `4:22` shows up:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以保存`time.js`，确保在终端中打印出正确的内容，确实是这样，`4:22`显示出来了：
- en: '![](img/12f27b35-dc2c-4dbc-a5a3-ed7814d0f806.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12f27b35-dc2c-4dbc-a5a3-ed7814d0f806.png)'
- en: 'Next up is going to be grabbing that lowercase am and pm values. We can find
    that pattern over inside&nbsp; Google Chrome just previous to&nbsp;Hour:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是获取小写的am和pm值。我们可以在Google Chrome中找到这个模式，就在小时之前：
- en: '![](img/45ac7096-5808-4b55-b400-7cfbdac0151a.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45ac7096-5808-4b55-b400-7cfbdac0151a.png)'
- en: 'Here we can either use uppercase A for uppercase AM and PM, or lowercase a
    for the lowercase version. I''m going to go ahead and use a lowercase `a` after
    a space to use that lowercase version:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用大写A表示大写的AM和PM，或者使用小写a表示小写的版本。我将在一个空格后面使用小写的`a`来使用小写的版本：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'I can save the file and over inside the Terminal, I do indeed have `4:24` printing
    to the screen, and we have the `pm` after it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以保存文件，然后在终端中，我确实打印出了`4:24`，并且后面有`pm`：
- en: '![](img/62454ab9-24db-4c05-b989-2c76c6b79e69.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62454ab9-24db-4c05-b989-2c76c6b79e69.png)'
- en: Everything looks great. That is it for this section! In the next one, we're
    going to actually integrate Moment into our server and our client rather than
    just having it in a `playground` file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很好。这就是本节的全部内容！在下一节中，我们将实际将Moment集成到我们的服务器和客户端中，而不仅仅是在`playground`文件中。
- en: Printing message timestamps
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印消息时间戳
- en: In this section, you're going to be formatting your timestamps, and you're going
    to be displaying them to the screen along with the chat message. Currently, we
    show who it's from and the text, but the `createdAt` timestamp is not used anywhere.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将格式化时间戳，并将它们与聊天消息一起显示在屏幕上。目前，我们显示了消息的发送者和文本，但`createdAt`时间戳没有被使用。
- en: 'Now the first thing we need to figure out is how we can take that timestamp
    and get a Moment object back, because at the end of the day we want to call the
    `format` method to format it as we like. In order to do that, all you have to
    do is take your timestamp. We''ll make a variable called `createdAt` to represent
    that value, and pass it in as the first argument to `moment`, which means I simply
    pass in `createdAt`, just like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要弄清楚的第一件事是，我们如何将时间戳转换为Moment对象，因为归根结底，我们想要调用`format`方法来按我们的喜好格式化它。为了做到这一点，你所要做的就是拿到你的时间戳。我们将创建一个名为`createdAt`的变量来表示这个值，并将其作为`moment`的第一个参数传递进去，这意味着我只需传入`createdAt`，就像这样：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When I do this, we''re creating a moment with the same methods like format,
    add, and subtract, but it''s representing a different point in time. By default,
    it uses the current time. If you pass in a timestamp, it uses that time. Now this
    number, `1234`, is barely a second past the Unix epoch, but if we go ahead and
    run the file, we should see the correct thing printing. Using the `nodemon` command,
    in the `playground` folder, we''re going to run `time.js`, and we get `5:30 am`
    as shown in the following screenshot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我这样做时，我们创建了一个具有与format、add和subtract相同方法的moment，但它代表的是不同的时间点。默认情况下，它使用当前时间。如果传入一个时间戳，它就使用那个时间。现在这个数字`1234`，只是比Unix纪元晚了一秒，但如果我们运行文件，我们应该看到正确的东西打印出来。使用`nodemon`命令，在`playground`文件夹中，我们将运行`time.js`，并且我们会得到`5:30
    am`，如下面的截图所示：
- en: '![](img/32fec2fc-4e5c-44c0-b210-a86f04340808.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32fec2fc-4e5c-44c0-b210-a86f04340808.png)'
- en: This would be expected since it's taking into account our local timezone.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的，因为它考虑了我们的本地时区。
- en: Getting the formatted values back from timestamps
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从时间戳中获取格式化的值
- en: Now that we have this in place, we have everything we need to actually take
    those timestamps and get back formatted values. The other thing we can do is we
    can create timestamps with Moment, it has the exact same effect as the `new Date().getTime`
    method we've used.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了准备，我们已经拥有了实际获取这些时间戳并返回格式化值所需的一切。我们还可以使用Moment创建时间戳，它的效果与我们使用的`new Date().getTime`方法完全相同。
- en: In order to do this, all we do is we call `moment.valueOf`. For example, we
    can make a variable called `someTimestamp`, setting it equal to a call to `moment`.
    We're going to generate a new moment and we're going to call its `valueOf` method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们只需调用`moment.valueOf`。例如，我们可以创建一个名为`someTimestamp`的变量，将其设置为对`moment`的调用。我们将生成一个新的moment，并调用它的`valueOf`方法。
- en: 'This is going to go ahead and return a timestamp in milliseconds since the
    Unix epoch, `console.log`. We''re going to log out the `someTimestamp` variable
    just to make sure it looks correct, and here we have our timestamp value:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将继续返回自Unix纪元以来的毫秒时间戳，`console.log`。我们将记录`someTimestamp`变量，以确保它看起来正确，这里是我们的时间戳值：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Updating the message.js file
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新message.js文件
- en: 'The first thing we''re going to do is tweak our `message.js` file. Currently
    inside `message.js`, we generate timestamps using `new Date().getTime`. We''re
    going to switch over to Moment, not because it changes anything, I just want to
    be consistent with using Moment everywhere we use time. This is going to make
    it a lot easier to maintain and figure out what''s going on. At the top of the
    `message.js`, I''m going to make a variable called `moment` setting it equal to
    `require(''moment'')`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是调整我们的`message.js`文件。目前在`message.js`中，我们使用`new Date().getTime`生成时间戳。我们将切换到Moment，不是因为它会改变任何东西，而是因为我希望在使用时间时保持一致使用Moment。这将使维护和弄清楚发生了什么变得更容易。在`message.js`的顶部，我将创建一个名为`moment`的变量，将其设置为`require('moment')`：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And we're going to go ahead and replace the `createdAt` property with calls
    to `valueOf`. What I would like you to do is go ahead and do just that, call `moment`,
    call the `valueOf` method in `generateMessage` and in `generateLocationMessage`,
    and then go ahead and run the test suite and make sure both tests pass.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续用`valueOf`替换`createdAt`属性。我希望你继续做到这一点，调用`moment`，在`generateMessage`和`generateLocationMessage`中调用`valueOf`方法，然后继续运行测试套件，确保两个测试都通过。
- en: 'The first thing we need to do is tweak the `createdAt` property for `generateMessage`.
    We''re going to call `moment`, call `valueOf` getting back the timestamp, and
    we''re going to do the same thing for `generateLocationMessage`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是调整`generateMessage`的`createdAt`属性。我们将调用`moment`，调用`valueOf`获取时间戳，对`generateLocationMessage`也是同样的操作：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can go ahead and save `message.js`. Head over into the Terminal and
    run our test suite using the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存`message.js`。进入终端并使用以下命令运行我们的测试套件：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We get two tests and they both still pass, which means the value we''re getting
    back is indeed a number as our tests assert:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了两个测试，它们仍然都通过了，这意味着我们得到的值确实是一个数字，就像我们的测试所断言的那样：
- en: '![](img/0ac0eec6-3999-486a-8592-d06fd9ea1d99.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ac0eec6-3999-486a-8592-d06fd9ea1d99.png)'
- en: Now that we have Moment integrated on the server, we're going to go ahead and
    do the same thing on the client.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在服务器上集成了Moment，我们将继续在客户端上做同样的事情。
- en: Integrating Moment on client
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端集成Moment
- en: The first thing we need to do is load in Moment. Currently, the only library
    we load in on the frontend is jQuery. We can do this a few different ways; I'm
    going to go ahead and actually grab a file out of the&nbsp;`node_modules` folder.
    We've installed Moment, version 2.15.1, and we can actually grab the file we need
    for the frontend, which is sitting inside the `node_modules` folder.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是加载Moment。目前，我们在前端加载的唯一库是jQuery。我们可以通过几种不同的方式来做到这一点；我将实际上从`node_modules`文件夹中获取一个文件。我们已经安装了Moment，版本为2.15.1，我们实际上可以获取我们在前端需要的文件，它位于`node_modules`文件夹中。
- en: 'We''re going to go into `node_modules`, we have a really long list of alphabetical
    folders, I''m looking for the one called `moment`. We''re going to go into `moment`
    and grab `moment.js`. I''m going to right-click to copy it, then I''m going to
    scroll up to the very top, close `node_modules`, and I''m going to paste it right
    inside of our `js` | `libs` directory. We now have `moment.js` and if you open
    it, it''s a really long library file. There''s no need to make any changes to
    that file, all we have to do is load in `index.js`. Just next to our jQuery import,
    we''re going to add a brand new `script` tag, we''ll then provide that `src` attribute
    setting it equal to `/js/js/moment.js`, just like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进入`node_modules`，我们有一个非常长的按字母顺序排列的文件夹列表，我正在寻找一个名为`moment`的文件夹。我们将进入`moment`并获取`moment.js`。我将右键单击复制它，然后向上滚动到最顶部，关闭`node_modules`，然后将其粘贴到我们的`js`
    | `libs`目录中。现在我们有了`moment.js`，如果你打开它，它是一个非常长的库文件。不需要对该文件进行任何更改，我们只需要加载`index.js`。就在我们的jQuery导入旁边，我们将添加一个全新的`script`标签，然后设置`src`属性等于`/js/js/moment.js`，就像这样：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we have this in place, we have access to all those Moment functions
    only on the client side, which means that over inside `index.js` we can properly
    format the timestamp that comes back inside the message. Now before we make any
    changes, let''s go ahead and start up our server using the following command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这个设置，我们在客户端上就可以访问所有这些Moment函数，这意呈现出在`index.js`中可以正确格式化消息中返回的时间戳。在做任何更改之前，让我们使用以下命令启动我们的服务器：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can go ahead and move into the browser, going to `localhost:3000` and giving
    it a refresh, and our app is working as expected. If I open up the Developer Tools,
    inside the Console tab we can actually use Moment. We have it accessible via moment
    just like we did over inside Node. I can use `moment`, calling `format`: `moment().format()`.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续进入浏览器，转到`localhost:3000`并刷新，我们的应用程序正在按预期工作。如果我打开开发者工具，在控制台选项卡中，我们实际上可以使用Moment。我们可以通过moment访问它，就像我们在Node中做的那样。我可以使用`moment`，调用`format`：`moment().format()`。
- en: 'We get back our string:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们的字符串：
- en: '![](img/e5ea026a-c6bd-426b-a078-e17ae6a3d70b.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5ea026a-c6bd-426b-a078-e17ae6a3d70b.png)'
- en: You should be able to make this call if you've successfully imported Moment.
    If you are seeing this, then you are ready to move on to the actual updating of
    `index.js`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功导入了Moment，你应该能够进行这个调用。如果你看到这个，那么你就准备好继续更新`index.js`了。
- en: Updating the newMessage property
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新newMessage属性
- en: If you remember, on message we have a `createdAt` property for both `newMessage`
    and `newLocationMessage`. All we need to do is get that value, pass it in to `moment`,
    and then generate our formatted string.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在message上我们有一个`createdAt`属性，分别用于`newMessage`和`newLocationMessage`。我们所需要做的就是获取该值，传递给`moment`，然后生成我们格式化的字符串。
- en: 'We can make a new variable called `formattedTime`, and we can set this equal
    to a call to `moment` passing in the timestamp, `message.createdAt`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个名为`formattedTime`的新变量，并将其设置为调用`moment`传入时间戳`message.createdAt`的结果：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we can go ahead and do whatever we like. We could call format passing in
    the exact same string we use over in `time.js`, the hour, the minutes and the
    am/pm; `h:`, two lowercase `m`s, followed by a space and a lowercase `a`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续做任何我们喜欢的事情。我们可以调用format，传入我们在`time.js`中使用的完全相同的字符串，小时，分钟和上午/下午；`h:`，两个小写的`m`，后面跟着一个空格和一个小写的`a`：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this in place we now have that formatted time and we can go ahead and
    add it inside&nbsp;`li.text`. Now I know I''m using template strings inside of
    our client-side code. We''ll be removing this pretty soon so there''s no need
    to make that tweak yet since I''m not testing in Internet Explorer or any other
    browser, although the final version of the app will not include template strings.
    Right after the `from` statement, we''re going to go ahead and inject another
    value, the `formattedTime` which we just created previous. So our message should
    read name like Admin, the time followed by the text:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有了格式化的时间，我们可以继续将其添加到`li.text`中。现在我知道我在客户端代码中使用模板字符串。我们很快就会删除这个，所以还不需要进行调整，因为我还没有在Internet
    Explorer或其他浏览器中进行测试，尽管应用程序的最终版本将不包括模板字符串。在`from`语句之后，我们将继续注入另一个值，即我们之前创建的`formattedTime`。因此，我们的消息应该是像Admin这样的名称，后面跟着时间和文本：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'I''m going to go ahead and save `index.js`, and give the browser a refresh
    to load that client-side code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续保存`index.js`，并刷新浏览器以加载客户端代码：
- en: '![](img/560650fc-c7aa-4e9b-9b89-28fe85257516.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/560650fc-c7aa-4e9b-9b89-28fe85257516.png)'
- en: 'As shown in the preceding screenshot, we see Admin 4:49 pm: Welcome to the
    chat app, and that is the correct time. I can go ahead and send a message, `This
    is from a user`, send it off, and we can see it''s now 4:50 pm:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '如前面的屏幕截图所示，我们看到Admin 4:49 pm: 欢迎来到聊天应用程序，这就是正确的时间。我可以发送一条消息，`这是来自用户`，发送出去，我们可以看到现在是下午4:50：'
- en: '![](img/b7c14c75-7f5b-41f5-baf1-4b772a65bcf2.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7c14c75-7f5b-41f5-baf1-4b772a65bcf2.png)'
- en: This is from a user shows up, everything is working great.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自用户的消息，一切都很顺利。
- en: Updating the newLocationMessage property
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新newLocationMessage属性
- en: Now for Send Location, we currently don't use Moment; we only updated the `newMessage`
    event listener. This means that when we print that location message, we don't
    have the timestamp. We're going to modify `newLocationMessage`, you can go ahead
    and use the same techniques we used previously to get the job done. Now in terms
    of where to actually render the formatted time, you can simply put it in `li.text`
    just like we did earlier in case of `newMessage` property.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于发送位置，我们目前不使用Moment；我们只更新了`newMessage`事件监听器。这意味着当我们打印位置消息时，我们没有时间戳。我们将修改`newLocationMessage`，你可以继续使用我们之前使用的相同技术来完成工作。现在在哪里实际上呈现格式化的时间，你可以简单地将其放在`li.text`中，就像我们在`newMessage`属性的情况下所做的那样。
- en: 'Step one in the process is going to be to make that variable called `formattedTime`.
    We can actually go ahead and copy the following line:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 过程中的第一步将是创建名为`formattedTime`的变量。我们实际上可以继续复制以下行：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And pasting it right above the&nbsp;`var li = jQuery(''<li></li>'');` line
    like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其粘贴在`var li = jQuery('<li></li>');`行的上面，就像这样：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We want to do the exact same thing, we want to take that `createdAt` field,
    get a moment object, and call `format`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的事情与之前完全相同，我们想要获取`createdAt`字段，获取一个moment对象，并调用`format`。
- en: 'Next up, we do have to modify what gets displayed, show this `formattedTime`
    variable, and put it right in the&nbsp;`li.text` statement:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须修改显示的内容，显示这个`formattedTime`变量，并将其放在`li.text`语句中：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now we can go ahead and refresh the app, and we should see our timestamp for
    regular messages. We can send off a regular message and everything still works:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续刷新应用程序，我们应该看到我们的时间戳用于常规消息。我们可以发送一条常规消息，一切仍然正常：
- en: '![](img/875b19b5-6d68-4414-bf4f-0d63f1be85f1.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/875b19b5-6d68-4414-bf4f-0d63f1be85f1.png)'
- en: 'Then we can send off a location message, which we just changed. It should take
    just a second to get going and we have our current location link. We have our
    name and we have the timestamp, which is fantastic:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以发送一条我们刚刚更改的位置消息。它应该只需要一秒钟就可以运行起来，我们有我们当前的位置链接。我们有我们的名称和时间戳，这太棒了：
- en: '![](img/f9bd9025-4a9b-4c66-a5a9-8323ba05af08.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9bd9025-4a9b-4c66-a5a9-8323ba05af08.png)'
- en: That is it for this section. Let's go ahead and actually make a commit to save
    our changes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本节的全部内容。让我们继续进行提交以保存我们的更改。
- en: 'Even though we''re not quite done with the message area, we have all the data
    correctly showing up. It''s just showing up in a way that''s not really pleasing
    to the eye. For now though, we will head into the Terminal and shut down the server.
    I''m going to run `git status`, and we have new files as well as some modified
    files:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有完成消息区域，但所有数据都正确显示出来了。只是以一种不太令人愉悦的方式显示出来。不过，现在我们将进入终端并关闭服务器。我将运行`git status`，我们有新文件以及一些修改过的文件：
- en: '![](img/cbf98a1b-c044-416b-bb21-cdf891e495d8.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbf98a1b-c044-416b-bb21-cdf891e495d8.png)'
- en: 'Then, `git add .`&nbsp;is going to take care of all of that. Then we can make
    our commit, `git commit` with the `-m` flag, and a good message for this one is
    `Format with an timestamps using momentjs`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`git add .`将会处理所有这些。然后我们可以进行提交，`git commit`带有`-m`标志，这次的好消息是`使用momentjs格式化时间戳`：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: I am going to go ahead and push this up to GitHub using the&nbsp;`git push`
    command, and we are done.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`git push`命令将其推送到GitHub，然后我们就完成了。
- en: In the next section, we'll talk about a templating engine Mustache.js.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一个模板引擎Mustache.js。
- en: Mustache.js
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mustache.js
- en: Now that we have our timestamps rendering correctly to the screen. We're going
    to go ahead and talk about a templating engine called **Mustache.js**. This is
    going to make it much easier to define some markup and render it multiple times.
    In our case, our messages are going to have the same set of elements in order
    to render properly. We're going to have a header tag for the user's name, we're
    going to add the text into a paragraph, all that sort of stuff.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的时间戳已经正确地呈现在屏幕上。我们将继续讨论一个叫做**Mustache.js**的模板引擎。这将使定义一些标记并多次呈现它变得更容易。在我们的情况下，我们的消息将具有相同的一组元素，以便正确呈现。我们将为用户的名称添加一个标题标记，将文本添加到段落中，所有这些都是一样的。
- en: Now instead of doing that inside `index.js`, like we currently are, we're going
    to create some templates, some markup in `index.html`, and we're going to render
    those, which means we're not going to need to manually create and manipulate these
    elements. This can be a huge burden.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不会像目前在 `index.js` 中那样，而是在 `index.html` 中创建一些模板、一些标记，并渲染它们，这意味着我们不需要手动创建和操作这些元素。这可能是一个巨大的负担。
- en: Adding mustache.js to the directory
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将mustache.js添加到目录
- en: 'Now in order to get started before we actually create any templates or render
    them, we do need to download the library. We can get this by going to Google Chrome
    and Googling `mustache.js`, and we''re looking for the GitHub repository, which
    in this case happens to be the first link. You can also go to [mustache.github.io](http://mustache.github.io/)
    and click on the JavaScript link to get to the same location:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在实际创建任何模板或渲染它们之前开始，我们确实需要下载库。我们可以通过打开谷歌浏览器并搜索 `mustache.js` 来获取它，我们要找的是
    GitHub 仓库，这种情况下恰好是第一个链接。你也可以访问 [mustache.github.io](http://mustache.github.io/)
    并点击 JavaScript 链接以到达相同的位置：
- en: '![](img/6c4e4823-618f-44cd-be84-d04b763563b2.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c4e4823-618f-44cd-be84-d04b763563b2.png)'
- en: 'Now once you''re here, we do want to grab a specific version of the library.
    We can go to the Branch drop-down and switch from Branches to Tags. This is going
    to show us all the versions that were released; the version I''m going to be using
    here is the most recent one 2.3.0\. I''m going to grab that, it''s going to refresh
    the repository next, and we''re looking for a file called `mustache.js`. This
    is the library file we''re going to need to download and add in to `index.html`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一旦你到了这里，我们需要获取库的特定版本。我们可以转到分支下拉菜单，从分支切换到标签。这将显示所有已发布的版本；我将在这里使用的版本是最新的 2.3.0。我会获取它，它会刷新仓库，我们要找的是一个名为
    `mustache.js` 的文件。这是我们需要下载并添加到 `index.html` 中的库文件：
- en: '![](img/919c3e60-a5d3-478a-a403-490897428d4b.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/919c3e60-a5d3-478a-a403-490897428d4b.png)'
- en: I can click on&nbsp;Raw to grab the raw JavaScript file, and I can go ahead
    and save it into the project by right-clicking and clicking on&nbsp;Save As....
    I'm going to go into the project on the desktop, the `public` | `js` | `libs`
    directory, and right there we're going to add the file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以点击&nbsp;Raw 来获取原始的JavaScript文件，并可以右键单击并点击&nbsp;另存为... 将其保存到项目中。我将进入桌面上的项目，`public`
    | `js` | `libs` 目录，然后在那里添加文件。
- en: 'Now once you have the file in place, we can kick things off by importing it
    inside `index.html`. Near the bottom, we currently have `script` tags for `jquery`
    and `moment`. This one is going to look pretty similar. It''s going to be a `script`
    tag, then we''ll add that `src` attribute so we can load in the new file, `/js/libs`,
    and finally it''s `/mustache.js`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一旦你把文件放好了，我们可以通过在 `index.html` 中导入它来开始。在底部附近，我们目前有 `jquery` 和 `moment` 的 `script`
    标签。这个看起来会很相似。它将是一个 `script` 标签，然后我们将添加 `src` 属性，以便加载新文件，`/js/libs`，最后是 `/mustache.js`：
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now with this in place, we can go ahead and create a template and render it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这个，我们可以继续创建一个模板并渲染它。
- en: Creating and rendering template for newMessage
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和渲染newMessage的模板
- en: Creating a template and rendering it, is going to give you a pretty good idea
    about exactly what Mustache can do, then we'll go ahead and actually wire it up
    with our `newMessage` and `newLocationMessage` callbacks. To kick things off over
    inside `index.html` we are going to make a new template by defining a `script`
    tag just next the `chat__footer` div.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个模板并渲染它，这将让你对Mustache能做什么有一个很好的了解，然后我们将继续将其与我们的 `newMessage` 和 `newLocationMessage`
    回调实际连接起来。为了在 `index.html` 中开始，我们将通过在 `chat__footer` div 旁边定义一个 `script` 标签来创建一个新模板。
- en: 'Now inside of the `script` tag, we''re going to add our markup, but before
    we can do that we have to provide a couple of attributes on `script`. First up
    this is going to be a reusable template and we''re going to need a way to access
    it, so we''ll give it an `id`, I''m going to call this one `message-template`,
    and the other property we''re going to define is something called the `type`.
    The `type` property lets your editor and the browser know what''s stored inside
    the `script` tag. We''re going to set the type equal to, inside quotes, `text/template`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`script`标签内，我们将添加我们的标记，但在我们这样做之前，我们必须在`script`上提供一些属性。首先，这将是一个可重用的模板，我们需要一种访问它的方式，所以我们会给它一个
    `id`，我会称这个为 `message-template`，我们要定义的另一个属性是一个叫做 `type` 的东西。`type` 属性让你的编辑器和浏览器知道
    `script` 标签内存储了什么。我们将把 `type` 设置为，引号内，`text/template`：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we can write some markup and it''s going to work as expected. To kick things
    off let''s just go ahead and make a really simple paragraph tag. We''re going
    to make a `p` tag inside of the `script` tag, and we''ll add some text inside
    of it, `This is a template`, and we''re going to go ahead and close the paragraph
    tag, and that is it, this is where we''re going to start:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一些标记，它将按预期工作。让我们首先简单地创建一个段落标记。我们将在 `script` 标签内创建一个 `p` 标签，并在其中添加一些文本，`这是一个模板`，然后我们将关闭段落标记，就是这样，这是我们要开始的地方：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We have a message-template `script` tag. We can go ahead and now render this
    over inside&nbsp;`index.js` by commenting out all the code inside the `newMessage`
    listener. I'm going to comment out all of that code and now we can implement the
    Mustache.js rendering method.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个message-template `script`标签。我们可以通过注释掉`newMessage`监听器内的所有代码，将其渲染到`index.js`中。我将注释掉所有那些代码，现在我们可以实现Mustache.js渲染方法。
- en: Implementing the Mustache.js rendering method
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Mustache.js渲染方法
- en: 'First up, we have to grab the template, make a variable called `template` to
    do just this, and all we''re going to do is select it with `jQuery` using the
    ID we just provided, `#message-template`. Now we need to call the `html` method,
    which is going to return the markup inside `message-template`, which is the template
    code, our paragraph tag in this case:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须获取模板，创建一个名为`template`的变量来做到这一点，我们要做的就是使用我们刚刚提供的ID`#message-template`来用`jQuery`选择它。现在我们需要调用`html`方法，它将返回`message-template`内的标记，也就是模板代码，这种情况下是我们的段落标签：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Once we have that we can go ahead and actually call a method on Mustache, which
    was available to us because we added that `script` tag. Let's make a variable
    called `html`; this is the thing we're eventually going to add it to the browser
    and we're going to set it equal to a call to `Mustache.render`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们可以实际上在Mustache上调用一个方法，这是因为我们添加了那个`script`标签。让我们创建一个名为`html`的变量；这是我们最终要添加到浏览器的东西，我们将其设置为对`Mustache.render`的调用。
- en: 'Now `Mustache.render` takes the `template` you want to render:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Mustache.render`接受你想要渲染的`template`：
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''re going to go ahead and render it and now we can spit it out in the browser
    by adding it to the `messages` ID just like we do earlier. We''re going to select
    the element with an ID of messages, call `append`, and append the template we
    just rendered which we have access to inside of HTML:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续渲染它，现在我们可以通过将其添加到`messages` ID中将其显示在浏览器中，就像我们之前做的那样。我们将选择具有ID为messages的元素，调用`append`，并附加我们刚刚渲染的模板，我们可以在HTML中访问到它：
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now with this in place our server restarted and we can actually play around
    with this by refreshing the browser. I''m going to give the browser a refresh:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这个设置，我们的服务器重新启动了，我们可以通过刷新浏览器来实际操作。我要刷新浏览器：
- en: '![](img/9ec1c84b-571a-4278-b14d-61fe73dee8af.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ec1c84b-571a-4278-b14d-61fe73dee8af.png)'
- en: We get This is a template for our welcome message, and if I type anything else
    we also get This is a template. Not super interesting, not super useful, what
    is cool though is that Mustache lets you inject values, which means we can set
    up places in our template where we expect a value to get passed in.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了这是我们欢迎消息的模板，如果我输入其他内容，我们也会得到这是一个模板。不是很有趣，也不是很有用，但很酷的是Mustache让你注入值，这意味着我们可以设置模板中我们期望传入值的位置。
- en: 'For example, we have that `text` property. In order to reference a value, you
    can use the double curly braces syntax like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有`text`属性。为了引用一个值，你可以使用双大括号的语法，就像这样：
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then you can go ahead and type the name, like `text`. Now in order to actually
    provide this value, we have to send in a second argument to the render method.
    Instead of just passing in the template, we''re going to pass in the template
    and an object:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以继续输入名称，比如`text`。现在为了实际提供这个值，我们必须向render方法发送第二个参数。我们不仅仅传递模板，还要传递模板和一个对象：
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This object is going to have all the properties that you''re going to be allowed
    to render. Now we''re currently expecting the `text` property, so we should probably
    go ahead and provide it. I''m going to set `text` equal to the value that comes
    back on `message.text`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象将拥有你可以渲染的所有属性。现在我们目前期望`text`属性，所以我们应该继续提供它。我将把`text`设置为`message.text`返回的值：
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we''re rendering the template in a dynamic way. The template serves as
    the reusable structure but the data is always going to change because it gets
    passed in when we call render:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们以动态方式渲染模板。模板作为可重用的结构，但数据总是会改变，因为它在调用render时被传递进来：
- en: 'With this in place we can go ahead and refresh Chrome, and right here we see
    Welcome to the chat app, and if I go ahead and type a message, that is going to
    show to the screen, which is fantastic:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们可以继续刷新Chrome，然后在这里我们看到“欢迎来到聊天应用”，如果我输入一条消息，它将显示在屏幕上，这太棒了：
- en: '![](img/7f32c199-d48f-4f28-928b-74fe2fe30fc8.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f32c199-d48f-4f28-928b-74fe2fe30fc8.png)'
- en: Getting all the data showing up
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有显示的数据
- en: Now the next step in the process is going to be to get all the data showing,
    we have a `from` property and a `createdAt` property too. We actually have access
    to that `createdAt` property via `formattedTime`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个过程的下一步是让所有数据显示出来，我们有一个`from`属性和一个`createdAt`属性。我们实际上可以通过`formattedTime`访问到`createdAt`属性。
- en: 'We''re going to go ahead and uncomment the `formattedTime` line, and this is
    the only one we''re actually going to carry over to the new system. I''m going
    to add it up inside `newMessage` callback:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将取消注释`formattedTime`行，这是我们实际要转移到新系统的唯一行。我将把它添加到`newMessage`回调中：
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Because we do still want to use `formattedTime` when we render. Now before
    we do anything else with the template, let''s go ahead and simply pass in the
    values. We already passed the `text` value in. Next up, we can pass in `from`,
    it''s accessible via `message.from`, and we can also pass in a timestamp. You
    can call that property whatever you like, I''m going to continue to call it `createdAt`
    and set it equal to the `formattedTime`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们仍然希望在渲染时使用`formattedTime`。在我们对模板做任何其他操作之前，让我们简单地传递这些值。我们已经传递了`text`值。接下来，我们可以传递`from`，它可以通过`message.from`访问，我们还可以传递一个时间戳。你可以随意命名该属性，我将继续称其为`createdAt`并将其设置为`formattedTime`：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Providing a custom structure
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供自定义结构
- en: Now with this in place all the data is indeed getting passed in. We just need
    to actually go ahead and use it. In `index.html` we can use all of it, and we're
    also going to provide a custom structure. Just like we did when we set up the
    code previously, we're going to be using some classes I've defined inside the
    template for this project.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这个系统，所有的数据确实都被传递了。我们只需要实际使用它。在`index.html`中，我们可以使用所有这些，并且还将提供自定义结构。就像我们之前设置代码时一样，我们将使用我在此项目模板中定义的一些类。
- en: Adding the list item tag
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加列表项标签
- en: 'We''re going to start off with a list item using the `li` tag. We''re going
    to go ahead and add a class, and we''re going to call this class `message`. In
    there, we can add two `div`s. The first `div` is going to be the title area where
    we add the `from` and `createdAt` values, and the second `div` is going to be
    the body of the message:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用`li`标签开始。我们将添加一个类，并将这个类命名为`message`。在其中，我们可以添加两个`div`。第一个`div`将是标题区域，我们在其中添加`from`和`createdAt`的值，第二个`div`将是消息的正文：
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now for the first `div` we are going to provide a class, the class will equal
    `message__title`. This is where the message title information is going to go.
    We''re going to kick things off in here by providing an `h4` tag, which is going
    to render a nice header to the screen, and all we''re going to put inside `h4`
    is the `from` data, which we can do by using those double curly braces, `{{from}}`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个`div`，我们将提供一个类，这个类将等于`message__title`。这是消息标题信息将要放置的地方。我们将在这里开始，通过提供一个`h4`标签，为屏幕呈现一个漂亮的标题，我们将在`h4`内放置`from`数据，我们可以通过使用那些双花括号`{{from}}`来实现：
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The same exact thing holds true for `span`, that''s going to happen next. We''ll
    add a `span` tag, and inside the `span` tag, we''re going to inject `createdAt`,
    adding our double curly braces, and specifying the property name:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`span`，情况完全相同，这将在下一步发生。我们将添加一个`span`标签，在`span`标签内，我们将注入`createdAt`，添加我们的双花括号，并指定属性名称：
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Adding the message body tag
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加消息正文标签
- en: 'Now we can go ahead and move on to the actual message body itself. That''s
    going to happen next inside our second `div`, which we will be giving a class.
    The second `div` is going to have a class equal to `message__body`, and for a
    basic message, a non location-based message. All we''re going to do is add a paragraph
    tag, and we''re going to render our text inside by providing it two curly braces
    followed by `text`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行实际的消息正文。这将在我们的第二个`div`内进行，我们将为其指定一个类。第二个`div`的类将等于`message__body`，对于基本消息，即非基于位置的消息，我们将只需添加一个段落标签，并通过提供两个花括号后跟`text`来在其中呈现我们的文本：
- en: '[PRE65]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: With this in place we actually have a really great system for rendering our
    message template. The code, the markup, it's defined over inside `message-template`,
    which means that it's reusable and inside&nbsp;`index.js`. We just have a little
    bit of code to get everything wired up. This is a much more scalable solution,
    and it's a lot easier than managing the elements like we did next for `newLocationMessage`.
    I'm going to go ahead and save `index.js`, move into the browser, and give things
    a refresh.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个系统，我们实际上有一个非常好的消息模板渲染系统。代码，标记，都在`message-template`内定义，这意味着它是可重用的，而且在`index.js`内。我们只需要一点点代码来把一切都连接起来。这是一个更可扩展的解决方案，比起像我们为`newLocationMessage`那样管理元素要容易得多。我将保存`index.js`，进入浏览器，然后刷新一下。
- en: 'When we do we can see we now have a nice set of styles for the message, `This
    is some message`. I''m going to send that off; we get the name, the timestamp,
    and the text all printing. It looks a lot better than it did earlier:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们现在可以看到消息`This is some message`的样式很好。我将发送它；我们得到了名称，时间戳和文本的打印。它看起来比之前好多了：
- en: '![](img/770a7137-9d6a-47d7-b5cb-e461af13f88c.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/770a7137-9d6a-47d7-b5cb-e461af13f88c.png)'
- en: Creating template for the newLocation message
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为newLocation消息创建模板
- en: Now our send location message is still going to look like trash. If I click
    on&nbsp;Send Location, it's going to take a few seconds to get the job done and
    here it is! It's unstyled because it is not using a template. What we're going
    to do is add a template for the `newLocationMessage`. We're going to set up the
    markup for the template, and then we'll be to render it and pass in the necessary
    values.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的发送位置消息看起来仍然很糟糕。如果我点击发送位置，需要几秒钟才能完成，然后就是这样！它没有样式，因为它没有使用模板。我们要做的是为`newLocationMessage`添加一个模板。我们将为模板设置标记，然后呈现它并传入必要的值。
- en: 'Over inside `index.html` we can get started doing this by creating a second
    template. Now the second template is going to be pretty similar to the first.
    We can actually go ahead and duplicate this template by copying and pasting it
    next. All we need to do is change the `id` attribute from `message-template` to
    `location-message-template`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`内，我们可以通过创建第二个模板来开始这样做。第二个模板将与第一个非常相似。我们实际上可以通过复制并粘贴此模板来创建第二个模板。我们只需要将`id`属性从`message-template`更改为`location-message-template`：
- en: '[PRE66]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now the title area is going to be the same. We're going to have our `from` property
    as well as `createdAt`; it's the body that's going to change.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在标题区域将是相同的。我们将有我们的`from`属性以及`createdAt`；正文将会改变。
- en: 'Instead of rendering a paragraph with the text. We''re going to render a paragraph
    that has the link using an anchor tag. Now to add that anchor tag, we''re going
    to add the `a` tag. Then inside the `href` attribute, we''re going to be injecting
    the value. This is going to be the URL that gets passed from server to client.
    We''re going to add our equal signs, our curly braces, and the value we want to
    add is `url`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是呈现带有文本的段落，我们将呈现带有链接的段落，使用锚标签。现在，我们将添加锚标签。然后在`href`属性内，我们将注入值。这将是从服务器传递到客户端的URL。我们将添加等号，花括号，我们要添加的值是`url`：
- en: '[PRE67]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next up, we are going to carry over that `target` property, setting an equal
    to `_blank`, which will open up the link in a new tab. And finally, we can go
    ahead and close the anchor tag, adding the text for the link inside. Some good
    text for this link would be `My current location`, just like we have right now:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续使用`target`属性，将其设置为`_blank`，这将在新标签页中打开链接。最后，我们可以关闭锚标签，并在其中添加链接的文本。这个链接的好文本可能是`我的当前位置`，就像我们现在的一样：
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is all we need to do for the template. Next, we are going to wire up all
    of this inside of `index.js`, which means inside `newLocationMessage`, you want
    to do something pretty similar to what we have previous in `newMessage`. Instead
    of rendering everything with jQuery, you're going to render the template, passing
    in the necessary data, text, URL, and the formatted timestamp.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为模板需要做的全部。接下来，我们将在`index.js`中连接所有这些内容，这意味着在`newLocationMessage`中，你要做的事情与我们之前在`newMessage`中做的事情非常相似。你不再使用jQuery来渲染所有内容，而是要渲染模板，传入必要的数据、文本、URL和格式化的时间戳。
- en: Rendering the newLocation template
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染newLocation模板
- en: 'The first thing we''re going to do is comment out the code we no longer need;
    that''s everything but the variable `formattedTime`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是注释掉我们不再需要的代码；那就是除了变量`formattedTime`之外的所有内容：
- en: '[PRE69]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next up we''re going to go ahead and grab the template from the HTML by making
    a variable called `template`, and we''re going to use `jQuery` to select it by
    ID. Right inside the quotes, we''ll add our selector. We want to select by ID
    so we''ll add that.&nbsp;`#location-message-template` is the ID we provided, and
    now we want to go ahead and call `html` to get its inner HTML back:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从HTML中获取模板，创建一个名为`template`的变量，并使用`jQuery`通过ID选择它。在引号内部，我们将添加我们的选择器。我们要通过ID选择，所以我们会添加这个。&nbsp;`#location-message-template`是我们提供的ID，现在我们要调用`html`来获取它的内部HTML：
- en: '[PRE70]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next up, we''re going to go ahead and actually render the template by creating
    a variable called `html` to store the return value. We''re going to call `mustache.render`.
    This takes those two arguments, the template you want to render and data you want
    to render into that template. Now the data is optional, but we do indeed need
    to pass some data through so we will be providing that as well. `template` is
    our first argument and the second one is going to be an object:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实际渲染模板，创建一个名为`html`的变量来存储返回值。我们将调用`mustache.render`。这需要两个参数，你要渲染的模板和你要渲染到该模板中的数据。现在数据是可选的，但我们确实需要传递一些数据，所以我们也会提供那个。`template`是我们的第一个参数，第二个参数将是一个对象：
- en: '[PRE71]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'I''m going to start by setting `from` equal to `message.from`, and we can do
    the same thing with `url`, setting it equal to `message.url`. For `createdAt`,
    we''re going to use the `formattedTime` variable instead, `createdAt` gets set
    equal to `formattedTime`, which is defined in case of `newMessage` template:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从`from`设置为`message.from`开始，我们也可以用`url`做同样的事情，将其设置为`message.url`。对于`createdAt`，我们将使用`formattedTime`变量，`createdAt`设置为`formattedTime`，这在`newMessage`模板中已经定义：
- en: '[PRE72]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now that we have access to the HTML we need to render. We can use a jQuery
    selector to select the element with an ID of messages, and we''re going to call
    append to add a new message. The new message we want to add is available via the
    `html` variable:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问我们需要渲染的HTML。我们可以使用jQuery选择器来选择ID为messages的元素，并且我们将调用append来添加一个新消息。我们要添加的新消息可以通过`html`变量获得：
- en: '[PRE73]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now that we have our function completely converted over. We can remove the
    old commented out code, save the file, and test things out over inside Chrome.
    I''m going to give the page a refresh to load that latest code, I''ll send a text
    message to make sure that still works, and now we can go ahead and send a location
    message. We should see in just a second the new data rendering and it is indeed
    working as expected:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完全转换了我们的函数，我们可以删除旧的注释掉的代码，保存文件，并在Chrome中测试一下。我将刷新页面以加载最新的代码，我会发送一条文本消息来确保它仍然有效，现在我们可以发送一个位置消息。我们应该在短短几秒内看到新数据的渲染，它确实按预期工作：
- en: '![](img/588f4431-45f8-4da6-8a3d-e16c1e5d485b.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/588f4431-45f8-4da6-8a3d-e16c1e5d485b.png)'
- en: We have the name, the timestamp, and the link. I can go ahead and click on the
    link to make sure it is still working.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有名字、时间戳和链接。我可以点击链接，确保它仍然有效。
- en: With this in place we now have a much better setup for creating these frontend
    templates. Instead of having to do the heavy lifting inside `index.js`, we can
    do the template inside of `index.html`, simply passing the data in, it's a much
    more scalable solution.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在有了一个更好的前端模板创建设置。我们不再需要在`index.js`中做繁重的工作，我们可以在`index.html`中做模板，只需传入数据，这是一个更可扩展的解决方案。
- en: 'Now that we have this in place we are done, and we can go ahead and commit
    our changes by shutting down the server and running `git status`. We have a new
    file as well as a couple of modified ones, `git add .` is going to take care of
    all of that for us, and we can make our commits, `git commit` with the `-am` flag.
    Actually, we already added it so we can just use the `-m` flag, `Add mustache.js
    for message templates`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了这一切，我们可以关闭服务器并运行`git status`提交我们的更改。我们有一个新文件以及一些修改过的文件，`git add .`会为我们处理所有这些，然后我们可以进行提交，`git
    commit`带有`-am`标志。实际上，我们已经添加了，所以我们可以只使用`-m`标志，`Add mustache.js for message templates`：
- en: '[PRE74]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'I''m going to push this up to GitHub and we can go ahead and take a quick moment
    to deploy to Heroku too using `git push heroku master`. I''m going to push this
    up just to make sure all the templates are rendering properly on Heroku just like
    they are locally. It should take just a second to deploy. Once it''s up, we can
    open it up by either running `heroku open` or grabbing that URL as we''ve done
    before. Here it''s launching the app:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个推送到GitHub，然后我们可以继续快速部署到Heroku，使用`git push heroku master`。我要把这个推上去，只是为了确保所有模板在Heroku上的渲染与本地一样。部署应该只需要一秒钟。一旦部署完成，我们可以通过运行`heroku
    open`或者像以前一样获取URL来打开它。这里正在启动应用程序：
- en: '![](img/ee9cc7c6-6ca7-4b02-879f-4e6640264c8a.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee9cc7c6-6ca7-4b02-879f-4e6640264c8a.png)'
- en: 'It looks like everything did go as expected. I''m going to grab the app URL,
    move into Chrome, and open it up:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都如预期那样进行。我要获取应用程序的URL，切换到Chrome，并打开它：
- en: '![](img/3f3cf584-e3ba-4d58-bea7-d8c10f0fb2da.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f3cf584-e3ba-4d58-bea7-d8c10f0fb2da.png)'
- en: And now we're viewing our application live inside of Heroku, and the message
    data is showing up as expected. The same thing should hold true for sending the
    location, the send location message should use the new setup, and it is indeed
    working as expected.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在实时查看我们的应用程序在Heroku中，消息数据如预期显示出来。发送位置时也应该是如此，发送位置消息应该使用新的设置，而它确实如预期般工作。
- en: Autoscrolling
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动滚动
- en: 'If we''re going to build a frontend we might as well do it right. In this section,
    we''re going to add an autoscrolling feature. So if a new message comes in, it
    is visible inside of the messages panel. Now right away this is not a problem.
    I type an `a`, I hit *enter*, and it shows up. However, as we get further down
    the list, you''ll see the messages start to disappear down the bottom of the bar:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要构建一个前端，我们最好做到完美。在这一部分，我们将添加一个自动滚动功能。所以如果有新消息进来，它会在消息面板中可见。现在立即来看，这并不是问题。我输入一个`a`，按下*enter*，它就出现了。然而，当我们滚动列表到底部时，你会看到消息开始消失在底部的栏中：
- en: '![](img/e37dee8f-f002-4f61-8a4a-c287e11454a9.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e37dee8f-f002-4f61-8a4a-c287e11454a9.png)'
- en: Now I can indeed scroll down to see the most recent messages, but it would be
    nice if I'm automatically scrolled to the most recent message. So if a new message
    comes in like `123`, I'm automatically brought to the bottom.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我确实可以向下滚动查看最近的消息，但如果能自动滚动到最近的消息就更好了。所以如果有新消息进来，比如`123`，我会自动滚动到底部。
- en: Now, obviously, if someone does scroll up to read an old message, we're going
    to want to keep them there; we're not going to want to scroll them to the bottom,
    that would be just as annoying as not being able to see the new messages in the
    first place. This means that we're going to go ahead and calculate a threshold.
    If someone can see that last message, we're going to go ahead and scroll them
    to the bottom when a new message comes in. If I'm previous that message, we're
    going to go ahead and leave them alone, there's no reason to scroll them to the
    bottom if they're digging through the archives.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果有人向上滚动阅读旧消息，我们会希望让他们留在那里；我们不会想要把他们滚动到底部，那会和一开始看不到新消息一样让人讨厌。这意味着我们将继续计算一个阈值。如果有人能看到最后一条消息，我们将在有新消息进来时滚动他们到底部。如果我在那条消息之前，我们将继续让他们保持原样，没有理由在他们查阅档案时把他们滚动到底部。
- en: Running a height properties calculation
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行高度属性计算
- en: 'Now in order to do that we are going to have to run a calculation, grabbing
    a few properties, mostly the height properties, of various things. Now to talk
    about those height properties and figure out exactly how we''re going to run this
    calculation, I''ve put together a really short section. Let''s go ahead and dive
    right in. To illustrate exactly how we''re going to run this calculation, let''s
    take a look at the following example:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将不得不进行计算，获取一些属性，主要是各种东西的高度属性。现在来谈谈这些高度属性，确切地弄清楚我们将如何进行这个计算，我已经准备了一个非常简短的部分。让我们继续深入。为了说明我们将如何进行这个计算，让我们看一下以下示例：
- en: '![](img/c3a1643b-6242-48a0-893a-7c39fe046cc3.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3a1643b-6242-48a0-893a-7c39fe046cc3.png)'
- en: We have this light purple box, it's taller than the dark purple one. This is
    the entire messages container. It's probably going to contain way more messages
    than we can actually see in the browser. The dark purple area is what we actually
    see. As we scroll down the dark purple area is going to move down to the bottom,
    and as we scroll up it's going to shift up to the top.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这个浅紫色的框，比深紫色的要高。这是整个消息容器。它可能包含的消息要比我们在浏览器中实际看到的要多得多。深紫色区域是我们实际看到的部分。当我们向下滚动时，深紫色区域会向下移动到底部，当我们向上滚动时，它会向上移动到顶部。
- en: 'Now we have access to three height properties that are going to let us make
    the calculations necessary to determine whether or not we should scroll down a
    user. These are the following:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问三个高度属性，这些属性将让我们进行必要的计算，以确定是否应该向用户滚动到底部。这些属性如下：
- en: '![](img/b155c03b-f571-4b32-9dcf-3623782a6d28.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b155c03b-f571-4b32-9dcf-3623782a6d28.png)'
- en: First up `scrollHeight`. This is the entire height of our messages container
    regardless of how much is actually visible inside of the browser. This means that
    if we have messages before and after what we can see. They are still going to
    be accounted for in `scrollHeight`.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是`scrollHeight`。这是我们消息容器的整个高度，不管在浏览器中实际可见多少。这意味着如果我们在可见部分之前和之后有消息，它们仍然会在`scrollHeight`中计算。
- en: Next up, we have `clientHeight`. This is the visible height container.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是`clientHeight`。这是可见高度容器。
- en: Finally, we have `scrollTop`. This is the number of pixels we've scrolled down
    into the purple container.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有`scrollTop`。这是我们向紫色容器滚动的像素数。
- en: Now in the current situation what do we want to do? We want to do nothing, the
    user really isn't scrolled that far down. It would be a burden to them if they
    got brought to the bottom every time a new message came in.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前情况下，我们想做什么？我们什么都不想做，用户实际上并没有滚动得那么远。如果每次有新消息进来就把他们带到底部，这对他们来说是一种负担。
- en: 'In the next scenario we scroll down just a little bit more:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个场景中，我们再向下滚动一点：
- en: '![](img/1b5ab944-51fd-4c61-8d9f-cc5ae40fa0e6.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b5ab944-51fd-4c61-8d9f-cc5ae40fa0e6.png)'
- en: 'The `scrollTop` has increased, the `clientHeight` has stayed the same, and
    so has the `scrollHeight`. Now if we keep going down the list, eventually we''re
    going to get to the very bottom. Currently, we should do nothing, but when we
    get to the bottom the calculations look a little different:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrollTop`增加了，`clientHeight`保持不变，`scrollHeight`也是如此。现在如果我们继续向下滚动列表，最终我们会到达底部。目前，我们不应该做任何事情，但当我们到达底部时，计算看起来会有些不同：'
- en: '![](img/c99707bd-fdc8-4a2f-a1b1-4211bfb86e00.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c99707bd-fdc8-4a2f-a1b1-4211bfb86e00.png)'
- en: 'Here you can see the `scrollTop` value, which is the space previous what we
    can see, plus the `clientHeight` value is identical to `scrollHeight`. This is
    going to be the basics of our equation. If the `scrollTop` plus the `clientHeight`
    equals the `scrollHeight`, we do want to scroll the user down when a new message
    comes in, because we know they''re at the very bottom of the panel. So in this
    situation what should we do? We should scroll to the bottom when a new message
    comes in. Now there is one slight little quirk:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到`scrollTop`值，即我们可以看到的前一个空间，加上`clientHeight`值等于`scrollHeight`。这将是我们方程的基础。如果`scrollTop`加上`clientHeight`等于`scrollHeight`，我们确实希望在新消息进来时将用户滚动到底部，因为我们知道他们已经在面板的底部。在这种情况下，我们应该怎么做？当新消息进来时，我们应该滚动到底部。现在有一个小小的怪癖：
- en: '![](img/7d47ee10-2dd8-44cc-9b5a-589951c1f5b7.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d47ee10-2dd8-44cc-9b5a-589951c1f5b7.png)'
- en: We are going to have that message already added so we're going to take into
    account the new `messageHeight` in our calculation, adding up `scrollTop`, `clientHeight`,
    and `messageHeight`, comparing that value to the `scrollHeight`. Using this we
    will once again be able to scroll the user to the bottom.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑到新的`messageHeight`，在我们的计算中添加`scrollTop`，`clientHeight`和`messageHeight`，将该值与`scrollHeight`进行比较。使用这个方法，我们将再次能够将用户滚动到底部。
- en: 'Let''s go ahead and wire this up in Atom. Now that we know how we''re going
    to run that calculation, let''s go ahead and actually do it over inside `index.js`.
    We''re going to make a new function that''s going to do all this heavy lifting
    for us. It''s going to determine whether or not we should scroll the user to the
    bottom depending on their position. Let''s make a function inside at the top `index.js`.
    It''s not going to take any arguments and we''re going to go ahead and call this
    function `scrollToBottom`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在Atom中连接这个。现在我们知道了如何运行这个计算，让我们继续在`index.js`中实际执行。我们将创建一个新的函数，它将为我们完成所有这些繁重的工作。它将根据用户的位置确定是否应该将用户滚动到底部。让我们在`index.js`的顶部创建一个函数。它不会接受任何参数，我们将把这个函数称为`scrollToBottom`：
- en: '[PRE75]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We''re going to call `scrollToBottom` every time we add a new message to the
    chat area, which means we need to do it twice once inside of `newMessage` and
    `newLocationMessage`. Right inside the&nbsp;`newLocationMessage` callback, I can
    call `scrollToBottom` passing in no arguments:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 每次向聊天区域添加新消息时，我们将调用`scrollToBottom`，这意味着我们需要在`newMessage`和`newLocationMessage`中各调用一次。在`newLocationMessage`回调函数中，我可以调用`scrollToBottom`，不传入任何参数：
- en: '[PRE76]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'I''ll do the same thing next when we append `scrollToBottom`:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们附加`scrollToBottom`时，我会做同样的事情：
- en: '[PRE77]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now all we need to do is wire up this function to:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是将这个函数连接起来：
- en: Determine if we should scroll them to the bottom, and
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定是否应该将它们滚动到底部，以及
- en: Scroll them to the bottom if it's necessary.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有必要，将它们滚动到底部。
- en: Creating a new variable to scroll messages to the bottom
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新变量将消息滚动到底部
- en: To get started, we are going to select the messages container creating a new
    variable to store that in. We're going to actually be creating quite a few variables
    to run our calculation, so I'm going to add two comments, `Selectors` and `Heights`.
    This is going to help us just break up the long list of variables.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将选择消息容器，并创建一个新变量来存储它。我们实际上将创建相当多的变量来运行我们的计算，所以我将添加两个注释，`选择器`和`高度`。这将帮助我们分解这长长的变量列表。
- en: 'We can make a variable, we''ll call this variable `messages`, and we''re going
    to set `messages` equal to a `jQuery` selector call. We''re going to select all
    elements with an ID equal to `messages`, which is just our one:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个变量，我们将把这个变量称为`messages`，然后我们将把`messages`设置为一个`jQuery`选择器调用。我们将选择所有ID等于`messages`的元素，这只是我们的一个元素：
- en: '[PRE78]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now that we have messages in place we can focus on getting those heights. We
    are going to go ahead and fetch `clientHeight`, `scrollHeight`, and `scrollTop`.
    First up, we can make a variable called `clientHeight` setting that equal to `messages`,
    and then we''re going to call a `prop` method, which gives us a cross-browser
    way to fetch a property. This is a jQuery alternative to doing it without jQuery.
    This makes sure it works across all browsers regardless of what they call the
    `prop`. We''re going to go ahead and provide, inside quotes, `clientHeight` to
    fetch that `clientHeight` prop:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了消息，我们可以专注于获取这些高度。我们将继续获取`clientHeight`，`scrollHeight`和`scrollTop`。首先，我们可以创建一个名为`clientHeight`的变量，将其设置为`messages`，然后我们将调用`prop`方法，这给了我们一种跨浏览器的方法来获取属性。这是一个没有jQuery的jQuery替代方法。这确保它在所有浏览器中都能正常工作，无论他们如何调用`prop`。我们将继续提供，用引号括起来，`clientHeight`来获取`clientHeight`属性：
- en: '[PRE79]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We''re going to do the exact same thing two more times for the other two values.
    `scrollTop` is going to get set equal to `messages.prop` fetching the prop `scrollTop`,
    and last but not least `scrollHeight`. A new variable called `scrollHeight` will
    store that value and we''re going to set it equal to `messages.prop`, passing
    in the prop we want to fetch `scrollHeight`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为另外两个值做完全相同的事情两次。`scrollTop`将被设置为`messages.prop`获取`scrollTop`属性，最后`scrollHeight`。一个名为`scrollHeight`的新变量将存储该值，我们将把它设置为`messages.prop`，传入我们想要获取的属性`scrollHeight`：
- en: '[PRE80]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now that we have this in place we can get started with our calculation.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪，可以开始计算了。
- en: Determining the calculation
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定计算
- en: 'We want to figure out if the `scrollTop` plus the `clientHeight` is greater
    than or equal to the `scrollHeight`. If it is, then we want to go ahead and scroll
    the user to the bottom because we know they''re already near the bottom, `if (clientHeight
    + scrollTop is >= scrollHeight)`:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要弄清楚`scrollTop`加上`clientHeight`是否大于或等于`scrollHeight`。如果是，那么我们就要滚动用户到底部，因为我们知道他们已经接近底部了，`if
    (clientHeight + scrollTop is >= scrollHeight)`：
- en: '[PRE81]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now if this is the case then, we are going to go ahead and do something. For
    now, we''ll just use `console.log` to print a little message to the screen. We''ll
    just print `Should scroll`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样的话，我们将继续做一些事情。现在，我们将使用`console.log`在屏幕上打印一条小消息。我们将只打印`Should scroll`：
- en: '[PRE82]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now our calculation is not quite complete, since we are running this function.
    After we append the new message, we do need to take that into account also. As
    we saw over inside Atom, if we can see that last message, we do want to scroll
    them to the bottom; if I'm further up the list we won't scroll them. But if I'm
    pretty close to the bottom, a few pixels up previous, we should scroll them to
    the bottom because that's most likely what they want.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的计算还没有完成，因为我们正在运行这个函数。在我们附加新消息之后，我们确实需要考虑到这一点。正如我们在Atom中看到的那样，如果我们可以看到最后一条消息，我们确实希望将它们滚动到底部；如果我在列表中更靠上，我们就不会将它们滚动。但是如果我离底部很近，前面几个像素，我们应该将它们滚动到底部，因为这很可能是他们想要的。
- en: Taking into account the height of new message
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑新消息的高度
- en: In order to get this done, we have to take into account the height of that new
    message and the height of the previous message. Inside Atom, we're going to go
    ahead and get that done, by first up adding a selector.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们必须考虑新消息的高度和上一条消息的高度。在Atom中，我们将首先添加一个选择器。
- en: 'We''re going to make a variable called `newMessage`, and this is going to store
    the selector for the last list item, the one that was just added before the call
    to scroll to bottom. I''m going to use `jQuery` to get this done, but instead
    of creating a new selector, we can actually build off of our previous one, `messages`,
    and we''re going to call its `children` method:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`newMessage`的变量，这将存储最后一个列表项的选择器，在滚动到底部之前刚刚添加的选择器。我将使用`jQuery`来完成这个任务，但我们不需要创建一个新的选择器，实际上我们可以基于之前的选择器`messages`进行构建，然后调用其`children`方法：
- en: '[PRE83]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This lets you write a selector specific to the children of the message, which
    means that we have all our list items so we could select our list items in another
    context, maybe we want to select all the children that are paragraphs. In our
    case, though, we''re going to select the list items that are the last child using
    this `last-child` modifier:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您可以编写一个特定于消息子级的选择器，这意味着我们有了所有的列表项，因此我们可以在另一个上下文中选择我们的列表项，也许我们想选择所有的段落子级。但在我们的情况下，我们将使用`last-child`修饰符选择最后一个子级的列表项：
- en: '[PRE84]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now we have just one item, the last list item in the list, and we can go ahead
    and get its height by making a variable called `newMessageHeight`, just next to
    the `scrollHeight` variable. We''re going to set that equal to `newMessage`, and
    we''re going to call its `innerHeight` method:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只有一个项目，列表中的最后一个列表项，我们可以继续通过创建一个名为`newMessageHeight`的变量来获取其高度，就在`scrollHeight`变量旁边。我们将把它设置为`newMessage`，然后调用其`innerHeight`方法：
- en: '[PRE85]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This is going to calculate the height of the message taking into account the
    padding that we've also applied via CSS.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计算消息的高度，考虑到我们通过CSS应用的填充。
- en: 'Now we need to take into account the height of the second-to-last message as
    well. To do that, we''re going to create a variable `lastMessageHeight`, and we''ll
    set it equal to `newMessage`, and we''re going to call the `prev` method. This
    moves us to the previous child, so if we were at the last list item we are now
    at the second-to-last list item, and we can get its height by once again calling
    `innerHeight`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要考虑第二个到最后一个消息的高度。为此，我们将创建一个名为`lastMessageHeight`的变量，并将其设置为`newMessage`，然后调用`prev`方法。这将使我们移动到上一个子元素，因此如果我们在最后一个列表项，现在我们在倒数第二个列表项，我们可以再次调用`innerHeight`来获取其高度：
- en: '[PRE86]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now we can account for both of these values inside our `if` statement as well.
    We''re going to add them up, `newMessageHeight`, and we''re also going to add
    `lastMessageHeight` taking that into account as we make our calculation:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也可以在`if`语句中考虑这两个值。我们将把它们相加，`newMessageHeight`，我们还将考虑到`lastMessageHeight`，并将其加入我们的计算中：
- en: '[PRE87]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Now that our calculation is complete we can actually test out that things are
    working as expected. We should see `Should scroll` when we should scroll.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的计算完成了，我们可以测试一下是否一切都按预期工作。我们应该在应该滚动时看到`Should scroll`。
- en: Testing the calculations
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试计算
- en: 'Over inside the browser, I''m going to go ahead and give things a refresh,
    and I''m also going to open up the Developer Tools so we can view our `console.log`
    statement. You''ll notice on smaller screens the styles remove the sidebar. Now
    I''m going to hit *enter* a few times. Obviously, we shouldn''t be able to send
    empty messages but we can for the moment, and you can see that `Should scroll`
    is printing:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我将继续刷新，然后打开开发者工具，这样我们就可以查看我们的`console.log`语句。您会注意到在较小的屏幕上，样式会移除侧边栏。现在我要按*enter*几次。显然，我们不应该发送空消息，但现在我们可以，您会看到`Should
    scroll`正在打印：
- en: '![](img/8172b50e-4ce4-401c-b428-cf25b08d83e5.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8172b50e-4ce4-401c-b428-cf25b08d83e5.png)'
- en: It's not actually going to scroll because the height of our messages container
    doesn't actually exceed the height of the browser space given to it, but it does
    indeed pass the condition. Now as we get down further and messages start to drop
    off the bottom of the screen, you'll notice the count in front of the message
    stops going up. The count incremented every time Should scroll printed, but now
    it stays at 2&nbsp;even though I'm adding new messages further.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上不会滚动，因为我们的消息容器的高度实际上并没有超过浏览器空间给定的高度，但它确实满足条件。现在随着我们继续向下滚动，消息开始从屏幕底部消失，您会注意到消息前面的计数停止增加。每次打印`Should
    scroll`时计数都会增加，但现在即使我添加了新消息，它仍然停留在2。
- en: In this case, we can scroll back down to the bottom and add a new message, `abc`.
    This should cause the browser to scroll, we're kind of near the bottom. When I
    do it Should scroll increments to 3, which is fantastic.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以滚动到底部并添加一条新消息`abc`。这应该会导致浏览器滚动，因为我们离底部很近。当我这样做时，`Should scroll`增加到3，这太棒了。
- en: If I scroll up to the top of the list and type `123` and hit *enter*, Should
    scroll does not increment to 4, which would be correct. We do not want to scroll
    a user to the bottom if they're up at the very top.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我滚动到列表顶部，输入`123`并按*回车*键，应该不会滚动到4，这是正确的。如果用户在顶部，我们不希望将其滚动到底部。
- en: Scrolling a user when necessary
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在必要时滚动用户
- en: 'Now the only thing left to do is actually scroll a user when necessary. That''s
    going to happen over inside our `if` statement, we can remove our `console.log(''Should
    scroll'')` call and we''re going to replace it with a call to `messages.scrollTop`,
    which is the jQuery method for setting that `scrollTop` value, and we''re going
    to set it to the `scrollHeight`, which is the total height of the container. This
    means that we''re going to be moving to the bottom of the messages area:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的事情就是在必要时实际滚动用户。这将发生在我们的`if`语句中，我们可以删除`console.log('Should scroll')`的调用，并将其替换为对`messages.scrollTop`的调用，这是设置`scrollTop`值的jQuery方法，我们将其设置为`scrollHeight`，这是容器的总高度。这意味着我们将移动到消息区域的底部：
- en: '[PRE88]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Over inside Google Chrome, we can now refresh the page to grab that latest `index.js`
    file, and I'm just going to hold the *enter* key for a little bit. As you can
    see we are scrolling down the list automatically. If I add a new message, it'll
    show up correctly.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Chrome中，我们现在可以刷新页面以获取最新的`index.js`文件，然后我会按住*回车*键一小会儿。正如你所看到的，我们正在自动滚动列表。如果我添加新消息，它将正确显示。
- en: If I'm up near the top and a new message comes in, like `123`, I am not going
    to scroll down the list, which is correct. Now if I'm not quite at the bottom
    but I'm pretty close, and a new message comes in, I am scrolled to the bottom.
    But if I'm a little past that last message, we're not going to get scrolled to
    the bottom which is exactly what we wanted. This is all happening because of our
    calculations.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我靠近顶部，新消息进来，比如`123`，我不会滚动到列表底部，这是正确的。现在，如果我不是在底部，但很接近，新消息进来，我会滚动到底部。但如果我稍微超过最后一条消息，我们将不会滚动到底部，这正是我们想要的。所有这些都是因为我们的计算。
- en: Committing the calculation-related changes
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交与计算相关的更改
- en: 'Let''s wrap this up with a commit over inside the Terminal. If we run `git
    status`, you''ll see we just have one changed file. I can use `git commit -am`
    to make a commit, `Scroll to bottom if user is close to bottom`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端中用一个提交来结束这一切。如果我们运行`git status`，你会看到我们只有一个更改的文件。我可以使用`git commit -am`来进行提交，`如果用户接近底部，则滚动到底部`：
- en: '[PRE89]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: I'm going to go ahead and push that up to GitHub using the `git push` command,
    and this is considered a wrap on the first part of this project.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续使用`git push`命令将其推送到GitHub，这被认为是项目的第一部分结束。
- en: Summary
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked into styling the basic chat application in the HTML
    format. We also discussed timestamps and formatting the page using the Moment
    method. After that, we went through the concept of the Mustache.js, creating and
    rendering templates for the messages. At last, we learned about autoscrolling
    and running calculations with message height properties. With this, we have a
    basic chat application in place.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了如何在HTML格式中为基本聊天应用程序添加样式。我们还讨论了时间戳和使用Moment方法格式化页面。之后，我们学习了Mustache.js的概念，创建和渲染消息模板。最后，我们了解了自动滚动和使用消息高度属性进行计算。有了这些，我们已经有了一个基本的聊天应用程序。
- en: In the next chapter, the goal is going to be to add chat rooms and names, so
    I go to a signup page. I enter the room, I'd like to join and the name I'd like
    to use. Then I get brought to a chat page, but only for that specific room. So
    if there are two rooms, users in room 1 are not going to be able to talk to users
    in room 2, and vice versa.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，目标是添加聊天室和名称，所以我去注册页面。我输入我想加入的房间和我想使用的名称。然后我被带到一个聊天页面，但只针对特定的房间。因此，如果有两个房间，房间1的用户将无法与房间2的用户交谈，反之亦然。
