- en: Chapter 8. Managing Data Using MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 使用MongoDB管理数据
- en: MongoDB is the database for the MEAN stack, and we have already explored some
    of its more basic features. It is an extremely powerful, scalable, NoSQL database
    that has gained wide popularity for big data and web applications. It happens
    to be open source and supported on a wide variety of operating systems and platforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是MEAN栈的数据库，我们已经探索了一些其更基本的功能。它是一个功能强大、可扩展的NoSQL数据库，因其在大数据和Web应用中的广泛流行而受到青睐。它恰好是开源的，并且支持广泛的操作系统和平台。
- en: MongoDB can be accessed using the MongoDB shell, a command-line interface that
    uses JavaScript-like syntax.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB可以通过MongoDB shell访问，这是一个使用类似JavaScript语法的命令行界面。
- en: In this chapter, we will explore MongoDB in greater depth and begin to incorporate
    it into our SPA. You will explore the various CRUD operations in the MongoDB shell,
    as well as using a Node.js plugin to access a database inside your single page
    application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探索MongoDB，并将其开始整合到我们的SPA中。你将探索MongoDB shell中的各种CRUD操作，以及使用Node.js插件来访问单页应用内的数据库。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: NoSQL databases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: Commanding MongoDB using the shell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用shell命令操作MongoDB
- en: Incorporating MongoDB into the SPA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将MongoDB整合到SPA中
- en: MongoDB performance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB性能
- en: Exploring the NoSQL database model
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索NoSQL数据库模型
- en: MongoDB is one of a number of NoSQL databases. Currently, it happens to be the
    most popular NoSQL database in use, according to statistics gathered by those
    who watch databases. SQL-based, relational databases have served us well for decades,
    so what's the big deal with NoSQL?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是众多NoSQL数据库之一。目前，根据那些关注数据库的人收集的统计数据，它恰好是使用中最受欢迎的NoSQL数据库。基于SQL的关系型数据库已经为我们服务了几十年，那么NoSQL究竟有什么大不了的？
- en: Defining NoSQL
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义NoSQL
- en: MongoDB is often referred to as a NoSQL database. NoSQL is a popular buzzword
    that applies to MongoDB and several other database engines. But what does it mean?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB通常被称为NoSQL数据库。NoSQL是一个流行的术语，适用于MongoDB和其他几个数据库引擎。但这是什么意思呢？
- en: First, there is no standard definition by some governing body defining what
    NoSQL means. The term was first used in 1998 by Carlo Strozzi to describe an open
    source relational database that did not have an SQL interface. However, today
    the term is used differently. NoSQL databases tend to have two defining features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，没有一个权威机构对NoSQL的定义有标准定义。这个术语最早在1998年由Carlo Strozzi提出，用来描述一个没有SQL界面的开源关系型数据库。然而，今天这个术语的使用有所不同。NoSQL数据库通常有两个定义特征。
- en: NoSQL
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NoSQL
- en: As the name might imply, most NoSQL databases do not use SQL to access the database.
    There are some NoSQL databases, however, that allow languages that are SQL-like
    or derived from SQL. Therefore, some take NoSQL to mean *not only SQL*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，大多数NoSQL数据库不使用SQL来访问数据库。然而，也有一些NoSQL数据库允许使用类似SQL或从SQL派生的语言。因此，有些人将NoSQL理解为“不仅限于SQL”。
- en: MongoDB databases are normally accessed through JavaScript-like syntax.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB数据库通常通过类似JavaScript的语法访问。
- en: Non-relational
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非关系型
- en: NoSQL databases do not use the relational model, where data is stored in structured
    tables of columns or rows. In the case of MongoDB, data is stored as documents
    in collections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库不使用关系模型，其中数据存储在结构化的列或行表格中。在MongoDB的情况下，数据作为文档存储在集合中。
- en: In relational databases, data is stored in tables, much like a table in a spreadsheet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中，数据存储在表格中，就像电子表格中的表格一样。
- en: Distributed
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式
- en: MongoDB, and other NoSQL databases, are designed to be distributed to work well
    in clusters. This makes hosting NoSQL databases in the cloud among numerous servers
    easier and provides for security, backup, performance, and scaling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB和其他NoSQL数据库被设计为分布式，以便在集群中良好工作。这使得在云中托管多个服务器上的NoSQL数据库变得更容易，并提供了安全性、备份、性能和扩展性。
- en: MongoDB supports sharding. Sharding is a process where portions of the database
    are hosted on different servers. This can make MongoDB extremely fast and highly
    scalable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB支持分片。分片是一个将数据库的部分托管在不同的服务器上的过程。这使得MongoDB非常快，并且具有高度的可扩展性。
- en: While it's beyond the scope of this book, the distributed nature of MongoDB
    makes it appealing for big data projects. Certainly, it makes MongoDB a compelling
    solution for web applications, which is its most popular use currently.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这超出了本书的范围，但MongoDB的分布式特性使其对大数据项目具有吸引力。当然，它使MongoDB成为Web应用的诱人解决方案，这也是它目前最流行的用途。
- en: Features of MongoDB
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB的特点
- en: Mongo has a number of features you should be aware of that make it different
    from other databases. They are explained as follows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo有一些你应该知道的功能，这些功能使其与其他数据库不同。它们如下所述。
- en: Document model
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档模型
- en: There are a number of models used by NoSQL databases. Some of these include
    the graph model, key-value model, object model, and others. These other models
    are beyond the scope of this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库使用了多种模型。其中一些包括图模型、键值模型、对象模型等。这些其他模型超出了本书的范围。
- en: MongoDB uses the document model. Data is stored in collections of documents
    in a MongoDB database.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB使用文档模型。数据存储在MongoDB数据库中文档的集合中。
- en: 'Here''s an example of a MongoDB document:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个MongoDB文档的例子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, documents in MongoDB are a form of JSON. In this case, the document
    even contains a subdocument, the address.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，MongoDB中的文档是JSON的一种形式。在这种情况下，文档甚至包含一个子文档，即地址。
- en: The database itself binary encodes the documents and stores them in a form referred
    to as BSON. Not to worry, though, you will not have to be concerned about encoding
    or decoding any of the data yourself, that is all handled behind the scenes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库本身以二进制编码文档，并以称为BSON的形式存储。不过，不用担心，你不需要自己关心编码或解码任何数据，这一切都是在幕后处理的。
- en: One of the main differences between JSON and BSON is that BSON supports a number
    of data types not supported by JSON. This includes binary data, regular expressions,
    symbols, dates, and so on. For example, a date may be represented in JSON output
    as a simple string. However, storing a date as date type in BSON allows efficient
    date comparisons and operations as part of queries or insertions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JSON和BSON之间的一大区别是BSON支持许多JSON不支持的数据类型。这包括二进制数据、正则表达式、符号、日期等。例如，日期在JSON输出中可能被表示为一个简单的字符串。然而，将日期作为日期类型存储在BSON中，允许在查询或插入时进行有效的日期比较和操作。
- en: For the most part, this is not something you'll need to worry about. MongoDB
    will seamlessly convert the data into usable JSON. However, when we get to Mongoose,
    data validation will be an important feature that will be handled by middleware.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这并不是你需要担心的事情。MongoDB将无缝地将数据转换为可用的JSON。然而，当我们到达Mongoose时，数据验证将成为一个重要的特性，将由中间件处理。
- en: Schemaless
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无模式
- en: One of the features of MongoDB, and some other NoSQL databases, is that it doesn't
    have a fixed schema.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的一个特性，以及一些其他NoSQL数据库的特性是，它没有固定的模式。
- en: In MongoDB, documents are stored in groups called *collections*. Documents stored
    in a collection should be related conceptually, but there is no restriction in
    the database software itself that enforces this. This is in stark contrast to
    databases where schemas strictly define the data which can be entered into a table.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，文档存储在称为*集合*的组中。存储在集合中的文档在概念上应该是相关的，但数据库软件本身并没有强制执行这一点的限制。这与那些严格定义可以输入到表中的数据的数据库形成鲜明对比。
- en: There is a danger here that random documents can be placed into any collection
    making the organization of the collections meaningless. You could insert a document
    reflecting data for a car into a collection called pets, but this wouldn't make
    much sense and could render the data in that collection difficult to query meaningfully.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在一个风险，即随机文档可以放入任何集合，使得集合的组织变得没有意义。你可以在名为pets的集合中插入反映汽车数据的文档，但这并没有太多意义，并且可能使该集合中的数据难以进行有意义的查询。
- en: It bears some thought.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这值得深思。
- en: Open source
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开源
- en: MongoDB is an open source database. A number of various licenses apply to the
    server itself, the drivers, tools, and the documentation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个开源数据库。服务器本身、驱动程序、工具和文档都适用多种不同的许可证。
- en: Complete licensing information for MongoDB is available at [https://www.mongodb.org/licensing](https://www.mongodb.org/licensing).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的完整许可信息可在[https://www.mongodb.org/licensing](https://www.mongodb.org/licensing)找到。
- en: Why use MongoDB?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用MongoDB？
- en: There are many choices of databases you could use to build a single page web
    application. For example, MySQL is a popular database for web applications overall.
    Why would you want to choose MongoDB over something like MySQL?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择许多数据库来构建一个单页Web应用程序。例如，MySQL是Web应用程序中流行的数据库。你为什么想要选择MongoDB而不是MySQL之类的数据库呢？
- en: Ultimately, almost any database will do the job, but there are certain features
    in MongoDB that make it particularly attractive for use in SPAs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，几乎任何数据库都能完成这项工作，但MongoDB中的一些特性使其特别适合用于单页应用程序（SPAs）。
- en: Well supported
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持良好
- en: MongoDB enjoys wide support on a number of operating systems and platforms.
    MongoDB has downloads and installers for Windows, multiple flavors of Linux, Mac,
    and Solaris.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 在多个操作系统和平台上享有广泛的支持。MongoDB 提供了 Windows、多种 Linux 版本、Mac 和 Solaris 的下载和安装程序。
- en: One of the popular ways to run MongoDB in the cloud is on a **Platform as a
    Service** (**PaaS**). PaaS is a service, normally provided by a vendor such as
    Amazon, that allows developers to build web applications in the cloud without
    the hassle of managing infrastructure. MongoDB maintains a list of supported platforms
    at [https://docs.mongodb.org/ecosystem/platforms/](https://docs.mongodb.org/ecosystem/platforms/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在云端运行 MongoDB 的流行方式之一是在 **平台即服务**（**PaaS**）上。PaaS 是一种服务，通常由亚马逊等供应商提供，允许开发者在云中构建
    Web 应用程序，而无需管理基础设施的麻烦。MongoDB 维护了一个支持平台列表，可在 [https://docs.mongodb.org/ecosystem/platforms/](https://docs.mongodb.org/ecosystem/platforms/)
    查找。
- en: MongoDB is supported in many popular languages. A quick visit to MongoDB's drivers
    page at [https://docs.mongodb.org/ecosystem/drivers/](https://docs.mongodb.org/ecosystem/drivers/)
    shows that, as of the time of writing this book, MongoDB has supported drivers
    for C, C++, C#, Java, Node.js, Perl, PHP, Python, Motor, Ruby, and Scala. Additionally,
    community-supported drivers for Go and Erlang, undoubtedly, may will be on the
    way.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 在许多流行的编程语言中得到支持。快速浏览 MongoDB 的驱动程序页面 [https://docs.mongodb.org/ecosystem/drivers/](https://docs.mongodb.org/ecosystem/drivers/)
    可以看到，截至本书编写时，MongoDB 已经支持 C、C++、C#、Java、Node.js、Perl、PHP、Python、Motor、Ruby 和 Scala
    的驱动程序。此外，社区支持的 Go 和 Erlang 驱动程序无疑也将很快推出。
- en: Data model
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据模型
- en: Because MongoDB's data model is based on JSON, it is ideal for use in web applications.
    JSON output can be consumed directly through frontend JavaScript and JavaScript
    frameworks such as AngularJs and others.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MongoDB 的数据模型基于 JSON，因此它非常适合用于 Web 应用程序。JSON 输出可以直接通过前端 JavaScript 和 AngularJs
    等JavaScript 框架进行消费。
- en: Because JSON is an object-oriented data format, the data works well with languages
    that are object-oriented themselves. The data structures can be modeled in the
    software you're writing very easily.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JSON 是一种面向对象的数据格式，因此数据与自身也是面向对象的编程语言配合得很好。数据结构可以在你编写的软件中非常容易地进行建模。
- en: Popularity
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受欢迎度
- en: As a developer, the popularity of the tools you are using is relatively important.
    For one thing, unpopular frameworks don't get the attention from development communities
    that popular ones get. Using a popular open source tool ensures that there is
    active development going on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你使用的工具的受欢迎程度相对重要。一方面，不受欢迎的框架不会像受欢迎的框架那样得到开发社区的注意。使用流行的开源工具可以确保有活跃的开发正在进行。
- en: This extends to things such as books and learning resources, platform availability,
    and language support.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括书籍和学习资源、平台可用性和语言支持等方面。
- en: Popularity can also be an indication of quality or, at least, the quality of
    fit for popular types of applications. MongoDB has become very popular in **Big
    Data** circles, where unstructured data is the bread and butter or day-to-day
    operation. However, MongoDB really shines when it comes to some of the most popular
    types of web applications - such as CMS and geo-spatial data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 受欢迎度也可以是质量的一个指标，至少可以表明它适合流行的应用程序类型。MongoDB 在 **大数据** 领域非常受欢迎，在那里非结构化数据是日常运营的基础。然而，MongoDB
    在一些最受欢迎的 Web 应用程序类型——如 CMS 和地理空间数据——方面表现得尤为出色。
- en: MongoDB is extremely popular. According to the 2015 press release from MongoDB
    ([https://www.mongodb.com/press/mongodb-overtakes-postgresql-4-most-popular-dbms-db-engines-ranking](https://www.mongodb.com/press/mongodb-overtakes-postgresql-4-most-popular-dbms-db-engines-ranking)),
    MongoDB has surpassed PostgreSQL as the fourth most popular database. As of the
    press release, it was the only non-relational database in the top five. According
    to the same release, MongoDB has grown over 160% in popularity over the previous
    2 years.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 非常受欢迎。根据 MongoDB 2015 年的新闻稿（[https://www.mongodb.com/press/mongodb-overtakes-postgresql-4-most-popular-dbms-db-engines-ranking](https://www.mongodb.com/press/mongodb-overtakes-postgresql-4-most-popular-dbms-db-engines-ranking)），MongoDB
    已经超越了 PostgreSQL，成为第四大最受欢迎的数据库。根据该新闻稿，当时它是前五名中唯一的非关系型数据库。同样，根据该新闻稿，MongoDB 在过去两年中的受欢迎程度增长了超过
    160%。
- en: MongoDB is being used more and more in much wider places than many other databases.
    All indications are that it is going to be around, and be supported on all of
    the most popular platforms, for a long time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 正在越来越多地被用于比许多其他数据库更广泛的地方。所有迹象都表明，它将长期存在，并在所有最受欢迎的平台上得到支持。
- en: Commanding MongoDB
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握 MongoDB
- en: MongoDB comes with an interactive shell, which we have already used briefly
    in the previous chapter. To refresh your memory, after starting the MongoDB daemon
    by typing `mongod`, you access the shell in a separate terminal window by typing
    `mongo`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB附带一个交互式shell，我们在上一章中已经简要使用过。为了刷新你的记忆，在通过输入`mongod`启动MongoDB守护进程后，你可以在单独的终端窗口中通过输入`mongo`来访问shell。
- en: Primarily, you will be accessing MongoDB using native code in your application.
    However, understanding the MongoDB shell is invaluable to using it. There will
    be times when you want to access the shell directly, particularly for debugging.
    You may also need to manage a MongoDB instance in the cloud.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 主要，你将通过在应用程序中使用本地代码来访问MongoDB。然而，了解MongoDB shell对于使用它是无价的。有时你将需要直接访问shell，特别是进行调试。你可能还需要管理云中的MongoDB实例。
- en: You should have a good grasp of the MongoDB shell.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该很好地掌握MongoDB shell。
- en: Getting information
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取信息
- en: One of the most important things you can do in the MongoDB shell is to manage
    your databases. Getting *meta* information out of MongoDB is most easily accomplished
    using shell commands. The following are some of the basic commands you can use
    in the MongoDB shell to get information.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB shell中，你可以做的一件最重要的事情是管理你的数据库。使用shell命令从MongoDB中获取元信息是最容易的。以下是一些你可以在MongoDB
    shell中使用的基本命令，以获取信息。
- en: '`help` - This will output a list of basic commands available in the MongoDB
    shell. For help with methods that operate on a database, you will use the `db.help()`
    method. Typing help into the MongoDB shell outputs the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`help` - 这将输出MongoDB shell中可用的基本命令列表。对于操作数据库的方法的帮助，你将使用`db.help()`方法。在MongoDB
    shell中输入help会输出以下内容：'
- en: '`db.help()`: Help on db methods'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.help()`: db方法帮助'
- en: '`db.mycoll.help()`: Help on collection methods'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.mycoll.help()`: 集合方法帮助'
- en: '`sh.help()`: Sharding helpers'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sh.help()`: 分片辅助工具'
- en: '`rs.help()`: Replica set helpers'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rs.help()`: 副本集辅助工具'
- en: '`help admin`: Administrative help'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help admin`: 管理帮助'
- en: '`help connect`: Connecting to a db help'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help connect`: 连接到数据库的帮助'
- en: '`help keys`: Key shortcuts'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help keys`: 键快捷键'
- en: '`help misc`: Misc things to know'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help misc`: 一些需要知道的事情'
- en: '`help mr`: Mapreduce'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help mr`: Mapreduce'
- en: '`show dbs`: Show database names'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show dbs`: 显示数据库名称'
- en: '`show collection`s: Show collections in current database'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show collections`: 显示当前数据库中的集合'
- en: '`show users`: Show users in current database'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show users`: 显示当前数据库中的用户'
- en: '`show profile`: Show most recent system.profile entries with time *s>= 1 m*'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show profile`: 显示最近系统.profile条目，时间`s>= 1 m*`'
- en: '`show logs`: Show accessible logger names'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show logs`: 显示可访问的记录器名称'
- en: '`show log [name]`: Prints out last segment of log in memory; `global` is default'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show log [name]`: 打印内存中最后一段日志；`global`是默认值'
- en: '`use <db_name>`: Set current database'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use <db_name>`: 设置当前数据库'
- en: '`db.foo.find()`: List objects in the `foo` collection'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.foo.find()`: 列出`foo`集合中的对象'
- en: '`db.foo.find( { a : 1 } )`: List objects in foo where a == 1'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.foo.find( { a : 1 } )`: 列出`foo`集合中a等于1的对象'
- en: '`it`: Result of the last line evaluated; use to further iterate'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it`: 上一条评估的结果；用于进一步迭代'
- en: '`DBQuery.shellBatchSize = x`: Set default number of items to display on shell'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBQuery.shellBatchSize = x`: 设置shell上显示的默认项目数'
- en: '`exit`: Quit Mongo shell'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit`: 退出Mongo shell'
- en: Some of the most important commands for gathering info from a database are the
    commands that begin with `show`. For example, `showdbs` will give you a list of
    the currently accessible database names on the system. `showcollections` will
    list the collections in the current database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中收集信息的最重要命令之一是以`show`开头的命令。例如，`showdbs`将给出系统上当前可访问的数据库名称列表。`showcollections`将列出当前数据库中的集合。
- en: One thing that isn't listed here is a method for retrieving the database on
    which you are currently operating. To do that, simply type `db` and the shell
    will output the name of the current database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有列出的一项是检索你当前操作数据库的方法。要这样做，只需输入`db`，shell就会输出当前数据库的名称。
- en: Inserting and updating data
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入和更新数据
- en: In the last chapter, we inserted some records using the insert method. You're
    going to do that a little differently here so that you can set up and load some
    data into your `giftapp` database, one that we created in the last chapter for
    the SPA you're building.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用insert方法插入了一些记录。在这里，你将稍微不同地做这件事，以便你可以设置并加载一些数据到你的`giftapp`数据库中，这是我们上一章为构建的SPA创建的。
- en: We're going to use two methods to insert data that you haven't used yet. One
    will be to execute a JavaScript file in the MongoDB shell which will set up and
    execute commands. We'll use this to insert some documents. The other method we'll
    use is a bulk operation that will allow us to set up some data and then execute
    and bulk insert it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种方法来插入你尚未使用过的数据。一种方法是在MongoDB shell中执行JavaScript文件，这将设置并执行命令。我们将使用此方法插入一些文档。我们将使用的另一种方法是批量操作，它允许我们设置一些数据，然后执行并批量插入。
- en: Running scripts in the MongoDB shell
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在MongoDB shell中运行脚本
- en: 'The MongoDB shell allows you to load and execute JavaScript files. In your
    `giftapp` directory, create a new folder called `scripts` and create a JavaScript
    file called `db-init.js`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB shell允许你加载和执行JavaScript文件。在你的`giftapp`目录中，创建一个名为`scripts`的新文件夹，并创建一个名为`db-init.js`的JavaScript文件：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line, `db=db.getSiblingDB('giftapp'),` tells the MongoDB shell which
    database to work with in case you haven't already selected the `giftapp` database
    in some way. We need to use this method because the `use` command isn't valid
    JavaScript.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行`db=db.getSiblingDB('giftapp'),`告诉MongoDB shell在未以某种方式选择`giftapp`数据库的情况下，要使用哪个数据库。我们需要使用这个方法，因为`use`命令在JavaScript中是无效的。
- en: Next, you create two objects, `user1` and `user2`, using JavaScript object literal
    notations. These objects represent user data for the users' `Mark Smith` and `Sally
    Jones`. You then create an array called users that contains the two user objects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用JavaScript对象字面量表示法创建了两个对象`user1`和`user2`。这些对象代表`Mark Smith`和`Sally Jones`的用户数据。然后你创建了一个名为`users`的数组，它包含这两个用户对象。
- en: Next, we invoke the `insert` method on the users collection and pass it the
    users array. If there is no users collection in the `giftapp` database, one will
    be created when we execute this script.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`users`集合上调用`insert`方法，并将`users`数组传递给它。如果在`giftapp`数据库中没有`users`集合，当我们执行此脚本时，将会创建一个。
- en: Note that when an array is passed to the insert method, MongoDB will insert
    each document separately. This is a powerful feature allowing for easy and efficient
    multiple document inserts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当将数组传递给`insert`方法时，MongoDB将单独插入每个文档。这是一个强大的功能，允许轻松高效地插入多个文档。
- en: There are two ways we can load and execute this script.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以加载和执行此脚本。
- en: 'From the command-line in a terminal not running the MongoDB shell, navigate
    to the directory where the script is stored and type the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在不运行MongoDB shell的终端的命令行中，导航到脚本存储的目录，并输入以下内容：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Unfortunately, there won''t be any really useful output to tell you that the
    inserts were completed. If you start the MongoDB shell, or use a terminal where
    it''s already running, you can verify by doing the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有真正有用的输出告诉你插入已完成。如果你启动MongoDB shell，或在已运行的终端中使用，你可以通过以下操作进行验证：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The count method returns the number of documents in a collection. Here, there
    are two. We've already explored the find method. Here we invoke find with no arguments,
    which returns all the documents in the collection. You can see that `Mark` and
    `Sally` are now documents stored separately in the users collection.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`方法返回集合中的文档数量。这里有两个。我们已经探讨了`find`方法。这里我们使用不带参数的`find`，它返回集合中的所有文档。你可以看到`Mark`和`Sally`现在作为单独的文档存储在`users`集合中。'
- en: 'If you run this script multiple times, it will create numerous `Mark` and `Sally`
    documents. If you want to clean out the collection and start over, you can use
    the drop method and verify using the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次运行此脚本，将会创建许多`Mark`和`Sally`文档。如果你想清理集合并重新开始，可以使用`drop`方法，并使用以下命令进行验证：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I promised you a second method of running scripts, and we''ll get to that.
    Let''s make a small modification to the script first:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我承诺给你第二种运行脚本的方法，我们将继续探讨。首先，让我们对脚本进行一些小的修改：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We added a variable called `now` that contains a new `Date` object. Creating
    a `Date` object in this way sets the date and time in the object to the current
    date and time. Next, we add a field called `created` to `Mark` and `Sally`, and
    give it the value of now, our date object.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`now`的变量，它包含一个新的`Date`对象。以这种方式创建`Date`对象将对象中的日期和时间设置为当前日期和时间。接下来，我们在`Mark`和`Sally`中添加了一个名为`created`的字段，并将其值设置为`now`，我们的日期对象。
- en: 'In a terminal running the MongoDB shell, do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行MongoDB shell的终端中，执行以下操作：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we use the load method to run the script, passing it the path to the script.
    We see that the two users have been added to the collection, and the find method
    retrieves their documents.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`load`方法运行脚本，传递脚本的路径。我们看到两个用户已经被添加到集合中，并且`find`方法检索了它们的文档。
- en: If you look at the created field on `Mark` and `Sally` documents you'll see
    something new. The `Date` may look a little different. Internally, MongoDB stores
    dates as a 64-bit integer representing the number of milliseconds since January
    1st, 1970\. Negative numbers are used to represent dates before that.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`Mark`和`Sally`文档上创建的字段，你会看到一些新东西。`Date`可能看起来有点不同。内部，MongoDB将日期存储为自1970年1月1日以来的64位整数，表示毫秒数。负数用于表示该日期之前。
- en: Storing dates and times as integers likes this, instead of strings, allows things
    such as date calculations and comparisons.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将日期和时间存储为整数而不是字符串，允许进行日期计算和比较。
- en: Fortunately, MongoDB outputs dates in a somewhat usable and readable format.
    We will explore displaying dates in a more human friendly way in a later chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，MongoDB以某种可使用和可读的格式输出日期。我们将在后面的章节中探索以更人性化的方式显示日期。
- en: Running bulk operations
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行批量操作
- en: Another way to insert multiple documents into a MongoDB collection in a single
    pass is to use MongoDB's `Bulk` API. This allows us to set up a list of ordered
    or unordered operations and then run them all when we choose to execute We can
    experiment with this using the MongoDB shell commands.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在单次传递中将多个文档插入到MongoDB集合中的一种方法是使用MongoDB的`Bulk` API。这允许我们设置一个有序或无序操作的列表，然后在我们选择执行时运行它们。我们可以使用MongoDB
    shell命令来实验这个。
- en: 'Take a look at the following commands:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的命令：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first line, we opened up an unordered bulk operation on users and assigned
    it to the variable called `bulk`. We could also have made that an ordered operation,
    but we don't currently care about the order in which the inserts are executed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们在用户上打开了一个无序批量操作，并将其分配给名为`bulk`的变量。我们也可以将其作为一个有序操作，但我们目前不关心插入执行的顺序。
- en: We then add two `insert` commands to the bulk operation, one for `John Smith`,
    and another for `Jane Smothers`. We can then call execute on the `bulk` operation.
    The returned value tells us that there were no errors and that two documents were
    inserted.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在批量操作中添加两个`insert`命令，一个用于`John Smith`，另一个用于`Jane Smothers`。然后我们可以调用`bulk`操作的`execute`。返回的值告诉我们没有错误，并且插入了两个文档。
- en: 'Let''s have a look at our collection now:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的集合现在：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I added the `pretty` method to the end of the `find` method in order to tidy
    up our output and make it a bit more readable. As you can see, `John` and `Jane`
    have been added to our collection.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`find`方法的末尾添加了`pretty`方法，以便整理我们的输出并使其更易于阅读。正如你所见，`John`和`Jane`已经被添加到我们的集合中。
- en: Finding, modifying, and removing data
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找、修改和删除数据
- en: Queries are how we search for and return data out of our database. We've been
    using queries all along every time we have used the `find` method. We know that
    find, on its own, will return every single document in a collection. That's not
    exactly useful.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是我们如何在数据库中搜索和返回数据的方式。我们一直在使用查询，每次我们使用`find`方法时。我们知道，单独的`find`会返回集合中的每个文档。这并不太有用。
- en: Specific results
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定结果
- en: Generally, we want to query a collection and return specific results. We want
    only those states that export peanuts, or we want a list of customers who live
    in France.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望查询一个集合并返回特定的结果。我们只想那些出口花生或我们想要在法国居住的客户名单。
- en: 'To specify that we want documents where a specific field matches a specific
    value, we do this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定我们想要特定字段与特定值匹配的文档，我们这样做：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, I''ve called the find operation and passed it an object with a single
    field: `lastname`. This is called the criteria. The value of that field is `Smith`.
    As you can see this returned the record for `John Smith`. For more than one field,
    you would separate the fields by commas.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我调用了查找操作，并传递了一个包含单个字段的对象：`lastname`。这被称为条件。该字段的值是`Smith`。正如你所见，这返回了`John
    Smith`的记录。对于多个字段，您可以通过逗号分隔字段。
- en: Wait a minute, shouldn't I also see the document for `Mark Smith`? If you look
    carefully, the documents for `Mark Smith` and `Sally Jones` camelcase `firstName`
    and `lastName`. That is, the `N` is a capital letter. Therefore, MongoDB doesn't
    see this as the same field.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，我不应该也看到`Mark Smith`的文档吗？如果你仔细看，`Mark Smith`和`Sally Jones`的`firstName`和`lastName`是驼峰式命名的。也就是说，`N`是一个大写字母。因此，MongoDB不认为这是一个相同的字段。
- en: This is a good illustration of one of the dangers of schemaless databases, and
    something to keep in mind. We will fix this in the section on updates.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地说明了无模式数据库的一个危险，并且是需要记住的事情。我们将在更新部分修复这个问题。
- en: 'Let''s say that we want to get documents for users with `lastName` fields matching
    `Smith` or `Jones`. There are a couple of ways you could write this query, but
    the best way when comparing the same field is to use the `$in` operator, as shown
    in the following commands:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要获取 `lastName` 字段匹配 `Smith` 或 `Jones` 的用户文档。你可以用几种方式编写这个查询，但在比较相同字段时，最佳方式是使用
    `$in` 运算符，如下面的命令所示：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Query operators
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询运算符
- en: MongoDB comes with a number of operators that all begin with the dollar sign.
    They are used for modifying and comparing within query criteria.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB附带了许多以美元符号开头的运算符。它们用于在查询条件中进行修改和比较。
- en: 'There are a number of types of query operators that include comparison operators
    such as `$eq`: equal to, `$gt`: greater than, and `$lte`: less than or equal to.
    Here''s an example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 查询运算符包括比较运算符，如 `$eq`：等于，`$gt`：大于，和 `$lte`：小于或等于。以下是一个示例：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This would return all documents in the `users` collection that had a `payrate`
    field with a value greater than `45`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 `users` 集合中所有 `payrate` 字段值大于 `45` 的文档。
- en: 'Logical operators include `$or`, `$and`, `$not`, and `$nor`. Each of these
    behaves like you''d expect if you''re used to logical operators. Here''s an example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符包括 `$or`、`$and`、`$not` 和 `$nor`。如果你熟悉逻辑运算符，那么这些运算符的行为就像你预期的那样。以下是一个示例：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This query returns all documents that have a `firstName` field equal to `Steve`
    and a `lastName` field equal to `Smith`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回所有 `firstName` 字段等于 `Steve` 且 `lastName` 字段等于 `Smith` 的文档。
- en: 'MongoDB includes two element operators: `$exists`: to check if a field exists,
    and `$type`: to check the type of a specified file. Take a look at the following
    command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 包含两个元素运算符：`$exists`：检查字段是否存在，和 `$type`：检查指定字段的类型。请查看以下命令：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This query returns all documents in the `users` collection that have a `car`
    field.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回 `users` 集合中所有具有 `car` 字段的文档。
- en: MongoDB includes a number of other operators. These include things such as `regex`
    matching and geospatial comparison. There are also operators comparing arrays.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 包含了许多其他运算符。这些包括正则表达式匹配和地理空间比较等。还有比较数组的运算符。
- en: For a more complete list of operators, see the MongoDB documentation on operators
    at [https://docs.mongodb.org/v3.0/reference/operator/query/](https://docs.mongodb.org/v3.0/reference/operator/query/).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取运算符的更完整列表，请参阅 MongoDB 文档中关于运算符的说明，请参阅[https://docs.mongodb.org/v3.0/reference/operator/query/](https://docs.mongodb.org/v3.0/reference/operator/query/)。
- en: Projections
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影
- en: We covered projections briefly in the previous chapter but, to refresh your
    memory, a projection specifies the fields returned in a query. We don't always
    want all of the fields in the documents that we return, so a projection lets us
    limit the data to the fields we are interested in.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中简要介绍了投影，但为了刷新你的记忆，投影指定了查询中返回的字段。我们并不总是想要返回文档中的所有字段，因此投影允许我们限制数据到我们感兴趣的字段。
- en: 'Projections will be the second argument to the find method, as shown in the
    following commands:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 投影将是 `find` 方法的第二个参数，如下面的命令所示：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We specified that we wanted all documents in the collection by passing an empty
    object as the first argument to find. Then, we used a projection to tell MongoDB
    that we wanted to see the `email` field.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将一个空对象作为 `find` 方法的第一个参数传递来指定我们想要集合中的所有文档。然后，我们使用投影来告诉 MongoDB 我们想要查看 `email`
    字段。
- en: 'You''ll notice that the `_id` field is returned in the results. This is a default.
    To suppress that, we give it a value of `0` in the find in the projection as shown
    in the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 `_id` 字段在结果中返回。这是一个默认值。为了抑制它，我们在投影中的查找操作中将其值设为 `0`，如下面的命令所示：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this query, `email` is included, while `_id` is excluded.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此查询中，`email` 被包含，而 `_id` 被排除。
- en: There are also a number of projection operators. You can find the details for
    those in the MongoDB documentation at [https://docs.mongodb.org/v3.0/reference/operator/query/](https://docs.mongodb.org/v3.0/reference/operator/query/).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多投影运算符。你可以在 MongoDB 文档中找到有关这些运算符的详细信息，请参阅[https://docs.mongodb.org/v3.0/reference/operator/query/](https://docs.mongodb.org/v3.0/reference/operator/query/)。
- en: Query modifiers
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询修饰符
- en: As the name implies, query modifiers are used to modify the data coming back
    from a query. This includes doing things such as sorting, or returning a maximum
    number of results.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，查询修改器用于修改查询返回的数据。这包括执行诸如排序或返回最大结果数等操作。
- en: 'There are two forms of modifiers in Mongo DB (I prefer the first). Take a look
    at the following commands:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中有两种修改器形式（我更喜欢第一种）。看看下面的命令：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let me illustrate with an example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我用一个例子来说明：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, I am selecting all documents in the users collection. I am returning
    only the `email` field (and suppressing the `_id` field). I am then sorting by
    ascending order by `email`. If we wanted to sort the documents by the `email`
    field in descending order, we would make the value in the modifier `-1`, as shown
    in the following commands:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我正在选择用户集合中的所有文档。我只返回`email`字段（并抑制`_id`字段）。然后按`email`的升序排序。如果我们想按`email`字段降序排序文档，我们将在修改器中将值设置为`-1`，如下面的命令所示：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Modifying data
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改数据
- en: To modify MongoDB documents, you generally use the `update` method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改MongoDB文档，你通常使用`update`方法。
- en: 'Take a look at following commands:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的命令：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we do a find just to display the document for `Jane Smothers`. We want
    to change the e-mail address of `Jane`, so we use the `update` method. The first
    argument to the `update` method is the same criteria used in the find method to
    select a document or set of documents. The second argument is the instruction
    for the update.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们执行一个`find`操作只是为了显示`Jane Smothers`的文档。我们想更改`Jane`的电子邮件地址，所以我们使用`update`方法。`update`方法的第一参数与`find`方法中用于选择文档或文档集的相同标准。第二个参数是更新的指令。
- en: Here, we've used the `$set` operator to change the e-mail address. If there
    wasn't an `email` field in the document, the `$set` operator would create a new
    field.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`$set`运算符来更改电子邮件地址。如果文档中没有`email`字段，`$set`运算符将创建一个新的字段。
- en: It's important to note that update, by default, will only update a single document.
    To update multiple documents, you set a multi option as part of a third option
    to update.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，默认情况下，`update`只会更新单个文档。要更新多个文档，你需要在更新选项中设置一个多选项。
- en: 'Let''s fix our users collection to make the fields for `firstname` and `lastname`
    into camelcase:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复用户集合，将`firstname`和`lastname`字段的格式改为驼峰式：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first argument to the `update` method uses the `$exists` operator to select
    any documents without the camelcase `lastname` field. The second argument uses
    the `$rename` operator to change both `firstname` and `lastname` field names to
    camelcase. The final argument sets the multi option to `true`, telling MongoDB
    to update all of the matched documents.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法的第一参数使用`$exists`运算符来选择没有驼峰式`lastname`字段的任何文档。第二个参数使用`$rename`运算符将`firstname`和`lastname`字段名更改为驼峰式。最后一个参数将多选项设置为`true`，告诉MongoDB更新所有匹配的文档。'
- en: The result shows us that two documents were matched and two documents were updated.
    Running the `find` method shows us that all documents now have the same field
    names.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示我们匹配了两个文档，并更新了两个文档。运行`find`方法显示所有文档现在具有相同的字段名。
- en: 'By default, if the query part of the `update` method doesn''t match any documents,
    MongoDB doesn''t do anything. We can tell MongoDB to create a new document if
    none are matched using the `upsert` option:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果`update`方法的查询部分没有匹配任何文档，MongoDB不会做任何事情。我们可以使用`upsert`选项告诉MongoDB如果没有匹配的文档，则创建一个新的文档：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we select documents where an `email` field matches `johnny5@fbz22.com`.
    As we know, there are no documents matching this query. The second argument to
    `update` lists the data we want to change. Finally, we set the `upsert` option
    to `true`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择`email`字段匹配`johnny5@fbz22.com`的文档。正如我们所知，没有文档匹配此查询。`update`方法的第二个参数列出我们想要更改的数据。最后，我们将`upsert`选项设置为`true`。
- en: The write result shows us that no documents were matched or modified, but that
    a single document was upserted.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 写入结果显示没有文档匹配或修改，但有一个文档被插入更新。
- en: Invoking find shows us that the record for `Johnny Fiverton` has been added.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`find`操作显示`Johnny Fiverton`的记录已被添加。
- en: You may have noticed that we did not use the `$set` operator this time around.
    If the second argument in update uses no operators, MongoDB will replace the entire
    document with the data in the second argument. This is something to be careful
    of; use `$set` when you don't want to replace the entire documents.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这次我们没有使用 `$set` 操作符。如果更新中的第二个参数没有使用操作符，MongoDB 将用第二个参数中的数据替换整个文档。这是一件需要注意的事情；当你不希望替换整个文档时，请使用
    `$set`。
- en: 'A list of `update` operators is available in the MongoDB documentation: [https://docs.mongodb.org/v3.0/reference/operator/update/](https://docs.mongodb.org/v3.0/reference/operator/update/).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 文档中提供了 `update` 操作符的列表：[https://docs.mongodb.org/v3.0/reference/operator/update/](https://docs.mongodb.org/v3.0/reference/operator/update/)。
- en: Removing data
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'So far, we have covered the: create, read, and update components of CRUD (create,
    read, update, delete). The remaining part is deleting documents. For deletion,
    MongoDB has the `remove` method.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了 CRUD（创建、读取、更新、删除）的创建、读取和更新组件。剩下的部分是删除文档。对于删除，MongoDB 有 `remove`
    方法。
- en: '`Remove` has a somewhat familiar signature.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Remove` 有一个相当熟悉的签名。'
- en: 'Take a look at the following commands:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下命令：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And it's goodbye `Johnny`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后就是和 `Johnny` 说再见了。
- en: You can probably surmise that the first argument to remove is the query. Here,
    we have selected all documents with an `email` field matching `johnny5@zfb22.com`.
    In this case, there is only one. The write result tells us that the number of
    documents removed is one.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以推断出 `remove` 的第一个参数是查询。在这里，我们选择了所有 `email` 字段匹配 `johnny5@zfb22.com` 的文档。在这种情况下，只有一个。写入结果告诉我们删除的文档数量为一条。
- en: 'A word of caution: by default, remove will delete all matched documents. If
    the query is an empty object, remove will delete everything in the collection.
    The indexes, however, will stay intact. To ensure that you are only removing a
    single document, you set the `justOne` parameter, the second optional argument
    to remove, to `1,` as shown in the following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个注意事项：默认情况下，删除将删除所有匹配的文档。如果查询是一个空对象，删除将删除集合中的所有内容。然而，索引将保持完整。为了确保你只删除单个文档，你需要将
    `justOne` 参数，即删除的第二个可选参数，设置为 `1`，如下面的命令所示：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This would remove a single `Smith` from our users collection.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从一个用户集合中删除单个 `Smith`。
- en: The cursor
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游标
- en: 'In MongoDB, the result of invoking `db.collection.find()` is actually a `cursor`.
    A `cursor` is a pointer to the results of a query. In the MongoDB shell, if you
    do not assign a `cursor` to a variable, the cursor is automatically iterated and
    output. This is what we have been doing so far:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 中，调用 `db.collection.find()` 的结果实际上是一个 `cursor`。游标是查询结果的指针。在 MongoDB
    壳中，如果你没有将 `cursor` 赋值给变量，游标将被自动迭代并输出。这就是我们到目前为止所做的一切：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we create a variable called `cursor` and assign to it the `cursor` returned
    by the `find` method. We then manually iterate the `cursor` simply by typing its
    name and hitting *Enter*. Typing the `cursor` name again and hitting *Enter* does
    nothing because the `cursor` has already been iterated.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `cursor` 的变量，并将其赋值为 `find` 方法返回的 `cursor`。然后我们通过手动输入其名称并按 *Enter*
    键来迭代 `cursor`。再次输入 `cursor` 名称并按 *Enter* 键将不会产生任何作用，因为 `cursor` 已经被迭代过了。
- en: 'This, in itself, isn''t very useful, but we can do all kinds of things with
    the cursor. For example, if we wanted to put all of our documents into an array
    we could do this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身并不是很有用，但我们可以用游标做很多事情。例如，如果我们想将所有文档放入一个数组中，我们可以这样做：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'MongoDB offers a ton of built-in cursor methods. Documentation for MongoDB
    JavaScript cursor methods can be found at: [https://docs.mongodb.org/manual/reference/method/#js-query-cursor-methods](https://docs.mongodb.org/manual/reference/method/#js-query-cursor-methods).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 提供了大量的内置游标方法。MongoDB JavaScript 游标方法的文档可以在以下位置找到：[https://docs.mongodb.org/manual/reference/method/#js-query-cursor-methods](https://docs.mongodb.org/manual/reference/method/#js-query-cursor-methods)。
- en: Incorporating MongoDB into the SPA
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 MongoDB 集成到 SPA 中
- en: All this command-line stuff is great, but we need to start incorporating our
    MongoDB database into our SPA. In a future chapter, we will introduce the `mongoose`
    plugin for node, which will allow us to do data modeling, and which will perform
    a lot of heavy lifting for us.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些命令行操作都很棒，但我们需要开始将我们的 MongoDB 数据库集成到我们的 SPA 中。在未来的章节中，我们将介绍 node 的 `mongoose`
    插件，它将允许我们进行数据建模，并为我们完成大量的繁重工作。
- en: For now, we're going to add a connection to MongoDB into our SPA in a simple
    way, which will highlight how to incorporate our database and display some dynamic
    data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将以简单的方式将MongoDB连接添加到我们的SPA中，这将突出如何集成数据库并显示一些动态数据。
- en: Adding the NPM modules
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加NPM模块
- en: For this chapter, we need two modules to connect and easily access our MongoDB
    database inside our Express application. Those modules are `mongodb` and `monk`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一章节，我们需要两个模块来连接并轻松访问Express应用程序内部的MongoDB数据库。这些模块是`mongodb`和`monk`。
- en: 'In your terminal, navigate to your `giftapp` directory and type the following
    (remember to lead with `sudo` if you''re on a Mac or Linux):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中，导航到你的`giftapp`目录，并输入以下命令（如果你使用的是Mac或Linux，请记住在命令前加上`sudo`）：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The dependencies section of your `package.json` file should now look something
    like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`package.json`文件的依赖关系部分现在应该看起来像这样：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Adding MongoDB into the main application
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将MongoDB添加到主应用程序中
- en: 'Next, we need to make our MongoDB database accessible inside the main application.
    We''re going to add a few lines to our `app.js` file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使MongoDB数据库在主应用程序中可访问。我们将在`app.js`文件中添加几行代码：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the first highlighted section, we load the `mongodb` and `monk` modules using
    the require method. We then instantiate the database connection by invoking `monk`
    and assigning the connection to the variable `db`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个高亮部分，我们使用`require`方法加载`mongodb`和`monk`模块。然后通过调用`monk`并分配连接到变量`db`来实例化数据库连接。
- en: Next, we write a small piece of middleware. Note that it's important that this
    middleware shows up before the routing middleware. The middleware attaches the
    database connection to the request object and then passes it on to the next middleware
    by invoking the next function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写一小段中间件。请注意，这个中间件必须出现在路由中间件之前。中间件将数据库连接附加到请求对象，然后通过调用`next`函数将其传递给下一个中间件。
- en: Writing a query
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写查询
- en: 'Now let''s get some data out of your database and displayed onto the browser.
    For that, we need to add a new route. Open up your `routes/users.js` file and
    we''ll add a few lines:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从你的数据库中获取一些数据并将其显示在浏览器上。为此，我们需要添加一个新的路由。打开你的`routes/users.js`文件，我们将添加几行代码：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will cover Express routing in depth in a later chapter, but what we've done
    here is create a new router for the `/show` path after `/users`. We've aliased
    the database from the request object and set the collection we're interested in
    using the monk `get` method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的章节中深入探讨Express路由，但在这里我们所做的是在`/users`路径之后为`/show`路径创建一个新的路由器。我们使用`monk`的`get`方法将数据库从请求对象中别名化，并设置我们感兴趣的集合。
- en: We then call the `monk` find method on the collection, passing an empty query.
    We know from our command-line experiments that an empty query should return all
    records in the collection.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在集合上调用`monk`的`find`方法，传递一个空查询。根据我们的命令行实验，空查询应该返回集合中的所有记录。
- en: The last argument to find here is a `callback` function, which is executed when
    the query returns. The first argument to this function receives an error if the
    query results in an error. The second argument receives the documents returned
    from the query.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里`find`方法的最后一个参数是一个`callback`函数，当查询返回时执行。该函数的第一个参数接收如果查询导致错误，则接收一个错误。第二个参数接收查询返回的文档。
- en: We check to make sure there's no error, and if there isn't, we output the documents
    using the response object's `json` function. As the name implies, the output is
    returned to the browser as JSON.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查以确保没有错误，如果没有错误，我们使用响应对象的`json`函数输出文档。正如其名所示，输出以JSON格式返回给浏览器。
- en: Ensure that your MongoDB daemon is still running, or restart it in a terminal
    window. In another terminal window, navigate to your `giftapp` directory and type
    `npm start` to start up your server.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的MongoDB守护进程仍在运行，或者在终端窗口中重新启动它。在另一个终端窗口中，导航到你的`giftapp`目录，并输入`npm start`来启动服务器。
- en: 'Navigating to `localhost:3000/users/show` in your browser will display something
    like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中导航到`localhost:3000/users/show`将显示如下内容：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It's not pretty, but it is an array that contains all of our documents in JSON
    format. We could already consume this as a web service, but let's do something
    a little prettier with it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来并不美观，但这是一个包含所有文档的数组，文档格式为JSON。我们本可以将其作为Web服务来消费，但让我们用一种更美观的方式来做这件事。
- en: Displaying data in a page
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在页面上显示数据
- en: 'Let''s format our data and put it into an HTML page to make it a little nicer
    to look at. Inside your `views` folder, create a new folder called `users`. Inside
    there, create a new file called `show.ejs` with the following code in it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们格式化我们的数据并将其放入HTML页面，使其看起来更美观。在你的`views`文件夹中，创建一个名为`users`的新文件夹。在该文件夹内，创建一个名为`show.ejs`的新文件，并在其中包含以下代码：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've created an embedded JavaScript document here that takes a collection of
    items called `users`. We iterate over that using the `forEach` function, assigning
    each instance to a variable called `user`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了一个嵌入的JavaScript文档，它包含一个名为`users`的项目集合。我们使用`forEach`函数遍历它，将每个实例分配给一个名为`user`的变量。
- en: For each pass through we create a table row. That table row contains table data
    elements for the user's first name, last name, and e-mail address.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们创建的每个遍历，我们都会创建一个表格行。该表格行包含用户的首字母、姓氏和电子邮件地址的表格数据元素。
- en: This alone won't work; we have to query the database and pass the data to the
    page. To do that we need to change up the route we just created to render this
    template and pass the docs we retrieve to it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此还不够；我们必须查询数据库并将数据传递到页面。为此，我们需要更改我们刚刚创建的路由以渲染此模板，并将检索到的文档传递给它。
- en: 'Here are the changes to the `users` router file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`users`路由文件的变化：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The only real change here is that we've commented out the line that sent the
    results as JSON back to the browser using the response's `json` method. Instead,
    we use the response's render function to choose the `users/show.ejs` template,
    and pass the retrieved docs as a property called `users`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的实际变化是我们已经注释掉了使用响应的`json`方法将结果作为JSON发送回浏览器的行。相反，我们使用响应的`render`函数来选择`users/show.ejs`模板，并将检索到的文档作为名为`users`的属性传递。
- en: 'Now, if you restart the `giftapp` server and navigate to `localhost:3000/users/show`,
    you should see this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你重新启动`giftapp`服务器并导航到`localhost:3000/users/show`，你应该能看到以下内容：
- en: '![Displaying data in a page](img/image_08_001.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![在页面中显示数据](img/image_08_001.jpg)'
- en: You can see how using Express with MongoDB gives us a lot of ease and flexibility
    in sending data to the browser. It's a simple thing to send JSON formatted data,
    and it is also simple to render pages dynamically.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到使用Express与MongoDB结合使用如何给我们带来很多便利和灵活性，以便将数据发送到浏览器。发送JSON格式的数据很简单，动态渲染页面也很简单。
- en: As we continue to build our SPA, we will rely more on building out web services
    which will return JSON data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续构建我们的SPA，我们将更多地依赖于构建返回JSON数据的Web服务。
- en: MongoDB database performance
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB数据库性能
- en: Topics such as replication and sharding are beyond the scope of this book. However,
    there are a number of things developers can do to optimize the performance of
    your MongoDB database.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如复制和分片等主题超出了本书的范围。然而，开发者可以采取一些措施来优化MongoDB数据库的性能。
- en: Mainly, we'll talk about cover indexing and tuning queries for performance.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 主要，我们将讨论覆盖索引和调整查询以提升性能。
- en: Indexing
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引
- en: In many database systems, adding an `index` in a field when appropriate can
    speed up querying. Queries are optimized when performed on indexed fields. MongoDB
    is no different.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多数据库系统中，当适当的时候，在字段中添加一个`索引`可以加快查询速度。在索引字段上执行查询时，查询会被优化。MongoDB也不例外。
- en: The downside to indexes is that they add some extra time to write operations.
    They also take up extra space in the database. It makes sense to index wisely.
    When considering adding indexes, you want to think about whether you expect more
    read than write operations. This would be a plus for adding additional indexes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的缺点是它们会增加一些额外的写入操作时间。它们也在数据库中占用额外的空间。明智地索引是有意义的。在考虑添加索引时，你想考虑你是否预期读取操作多于写入操作。这将有利于添加额外的索引。
- en: 'Let''s add an index to our user collection. We''ll say that we want to frequently
    look up our users by their last names. It makes sense to add an `index` on the
    `lastname` field, as shown in the following commands:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在用户集合中添加一个索引。我们将说我们经常通过用户的姓氏查找我们的用户。在`lastname`字段上添加一个索引是有意义的，如下面的命令所示：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We use the collection's `createIndex` method command passing it an object containing
    a single field. That field has the key of `lastname` with a value of `1`. This
    tells MongoDB that we want to create an index where we store the `lastname` fields
    in the collection in ascending order.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用集合的`createIndex`方法命令，传递一个包含单个字段的对象。该字段具有`lastname`键和值为`1`。这告诉MongoDB我们想要创建一个索引，在这个索引中，我们将集合中的`lastname`字段以升序存储。
- en: Internally, this creates a list of all the last names in ascending order, with
    pointers to the documents. Read operations keyed to the `lastname` field are efficient
    because the MongoDB engine doesn't have to search through every single document
    in the collection to find matching values, it can just search the list of last
    names.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，这会创建一个所有姓氏按升序排列的列表，以及指向文档的指针。基于`lastname`字段的读取操作是高效的，因为MongoDB引擎不需要搜索集合中的每个文档来找到匹配的值，它只需搜索姓氏列表。
- en: Write operations will be slightly slower, because they will also have to update
    the `index`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 写入操作将会稍微慢一些，因为它们还需要更新`索引`。
- en: Optimizing queries
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化查询
- en: Web application performance can be impacted by slow data read operations. Optimizing
    database operations can help in scaling operations, but also in perceived performance,
    enhancing user satisfaction.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序的性能可能会受到缓慢的数据读取操作的影响。优化数据库操作可以帮助扩展操作，同时也有助于提高感知性能，增强用户满意度。
- en: One of the ways developers can significantly impact performance is by optimizing
    queries. The main methods for reducing the amount of time taken for queries revolve
    around reducing the amount of data returned and by using indexes to make the lookup
    more efficient.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过优化查询显著影响性能。减少查询所需时间的主要方法包括减少返回的数据量以及使用索引来提高查找效率。
- en: Using limit
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用限制
- en: The `limit()` method, when added to a query, limits the number of records returned
    in the query. Limiting the number of records returned means less data transfer
    and thus faster performance and less use of resources.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当`limit()`方法添加到查询中时，它会限制查询返回的记录数。限制返回的记录数意味着更少的数据传输，从而提高性能并减少资源使用。
- en: 'Take a look at the following commands:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下命令：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We've added the `limit` function here to find with no query, giving it an argument
    of 2\. This tells MongoDB to return two documents, which you can see here.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了`limit`函数来执行无查询的查找，并给它一个参数为2。这告诉MongoDB返回两个文档，你可以在这里看到。
- en: Note that we can still add the `pretty()` function onto the end by chaining.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍然可以通过链式调用在末尾添加`pretty()`函数。
- en: Using projections
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用投影
- en: 'We''ve already discussed projections as a way to limit the number of fields
    returned per document. Projections are another tool that reduce data transfer,
    as shown in the following commands:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了投影作为限制每个文档返回的字段数的一种方法。投影是减少数据传输的另一种工具，如下面的命令所示：
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this query, we've added a projection to show `email` and suppress `_id`.
    We've kept the `limit` function. The result is two documents each containing only
    the `email` field.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，我们添加了一个投影来显示`email`并抑制`_id`。我们保留了`limit`函数。结果是两个文档，每个文档只包含`email`字段。
- en: Using hint()
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用提示()
- en: Using the `hint()` function forces MongoDB to use a particular `index` for a
    query.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hint()`函数强制MongoDB使用特定的`索引`进行查询。
- en: 'If you remember, we created an `index` on the `lastname` field of the `users`
    collection earlier. However, this isn''t going to help us, since we changed our
    documents to use the camelCased field name `lastName`. Let''s have a look:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们之前在`users`集合的`lastname`字段上创建了一个`索引`。然而，这不会帮到我们，因为我们已经将文档更改为了使用驼峰式命名的字段名`lastName`。让我们看一下：
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can see that both `_id` and `lastname` are indexes. Let''s drop `lastname`
    and add `lastName`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`_id`和`lastname`都是索引。让我们删除`lastname`并添加`lastName`：
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we can execute our query ensuring we use the `lastName` index:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以执行查询，确保我们使用`lastName`索引：
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Analyzing performance
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析性能
- en: If you'd like to get into the nitty-gritty of a query, you can use the `explain()`
    method tacked onto a query.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解查询，可以在查询上使用附加的`explain()`方法。
- en: 'Take a look at the following commands:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下命令：
- en: '[PRE39]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To make sense of the output, consult the MongoDB documentation at [https://docs.mongodb.org/v3.0/reference/explain-results/](https://docs.mongodb.org/v3.0/reference/explain-results/).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解输出，请查阅MongoDB文档[https://docs.mongodb.org/v3.0/reference/explain-results/](https://docs.mongodb.org/v3.0/reference/explain-results/)。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: MongoDB is a flexible and scalable NoSQL database. It's non-relational, maintaining
    its records as documents in collections as opposed to rows in tables. MongoDB
    is schemaless; its collections are flexible and do not enforce a particular data
    structure.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个灵活且可扩展的NoSQL数据库。它是非关系型的，将记录作为集合中的文档来维护，而不是作为表中的行。MongoDB是无模式的；其集合是灵活的，不强制执行特定的数据结构。
- en: MongoDB documents are stored as binary encoded JSON, or BSON. The object-oriented
    nature of its documents makes MongoDB well suited for use with object-oriented
    languages such as JavaScript.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB文档以二进制编码的JSON或BSON形式存储。其文档的面向对象特性使得MongoDB非常适合与JavaScript等面向对象语言一起使用。
- en: As with all databases, MongoDB offers CRUD operations. Operations on MongoDB
    are carried out using JavaScript-like syntax.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有数据库一样，MongoDB提供CRUD操作。MongoDB的操作使用类似JavaScript的语法执行。
- en: Optimizing MongoDB performance as a developer involves reducing the amount of
    data returned by queries and using indexes well.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，优化MongoDB性能包括减少查询返回的数据量以及有效地使用索引。
- en: In the next chapter, you will begin handling web requests for your SPA using
    the Express web application framework.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将开始使用Express Web应用程序框架处理你的SPA的Web请求。
