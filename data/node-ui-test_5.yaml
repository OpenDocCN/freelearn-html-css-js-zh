- en: Chapter 5. Manipulating the Zombie Browser
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。操纵僵尸浏览器
- en: Now that we have our to-do HTTP application and understand how the Mocha testing
    framework works, we are ready to start creating tests using Zombie.js.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了待办HTTP应用程序，并且了解了Mocha测试框架的工作原理，我们准备开始使用Zombie.js创建测试。
- en: As covered before, Zombie.js allows you to create a simulated browser environment
    and manipulate it. These manipulations are the usual things users do with browsers,
    such as visiting a URL, clicking on links, filling and submitting forms, and others.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Zombie.js允许您创建一个模拟的浏览器环境并对其进行操作。这些操作是用户在浏览器中通常做的事情，比如访问URL，点击链接，填写和提交表单等。
- en: 'This chapter covers the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Visiting a URL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问URL
- en: Filling and submitting a form
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填写和提交表单
- en: Checking for errors in the browser
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查浏览器中的错误
- en: Validating document content
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证文档内容
- en: Understanding CSS selector syntax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解CSS选择器语法
- en: This chapter shows you how you can setup a Zombie.js browser that interacts
    with your web application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了如何设置一个与您的Web应用程序交互的Zombie.js浏览器。
- en: '**Visiting a URL**: First, we are going to pick up our application tests from
    where we left off. The whole app concerns users, but in this part, we''re mainly
    going to focus on functionality that the `Users` routes touch—rendering a signup
    form and actually creating a user record in the database.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问URL**：首先，我们将从上次离开的地方继续进行应用测试。整个应用涉及用户，但在这部分中，我们主要将关注`Users`路由涉及的功能-渲染注册表单和实际在数据库中创建用户记录。'
- en: 'As mentioned, we left off with this single test file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们离开了这个单一的测试文件：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This test simply loaded the user signup form and tested whether the browser
    considered it a success. Let's go through this test to fully understand what is
    going on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试只是加载了用户注册表单，并测试浏览器是否认为它是成功的。让我们通过这个测试来完全理解发生了什么。
- en: 'First we create a new browser by instantiating a new browser object:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过实例化一个新的浏览器对象来创建一个新的浏览器：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This creates a Zombie.js browser, which represents an independent browser process
    that has the main job of maintaining state across requests: the URL history, the
    cookies, and the local storage.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这样创建了一个Zombie.js浏览器，它代表一个独立的浏览器进程，主要工作是在请求之间保持状态：URL历史记录，cookies和本地存储。
- en: 'A browser also has a main window, and you can load a URL in it by using `browser.visit()`,
    like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器还有一个主窗口，你可以使用`browser.visit()`在其中加载一个URL，就像这样：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This makes the browser perform an HTTP `GET` request to load the HTML page from
    that URL. Since Node.js and Zombie.js do asynchronous I/O processing, this only
    makes Zombie.js to start loading the page. Then Zombie.js tries to fetch the URL,
    parse the HTML document, and resolve all the dependencies by loading the referenced
    JavaScript files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得浏览器执行一个HTTP `GET`请求来从该URL加载HTML页面。由于Node.js和Zombie.js进行异步I/O处理，这只会使Zombie.js开始加载页面。然后Zombie.js尝试获取URL，解析HTML文档，并通过加载引用的JavaScript文件来解析所有依赖项。
- en: 'Once all that is done, we can be notified by passing a callback function to
    the `browser.wait()` method, like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些都完成了，我们可以通过将回调函数传递给`browser.wait()`方法来得到通知，就像这样：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of using the `browser.wait` function, we pass a callback directly into
    the `browser.visit()` call, like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用`browser.wait`函数，而是直接将回调传递给`browser.visit()`调用，就像这样：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here you pass in a callback function that gets invoked once there is an error
    or the browser is ready. If an error occurs, it is returned as the first argument—we
    check whether an error exists and throw it if it does, so that the test fails.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您传递一个回调函数，一旦出现错误或浏览器准备好，就会被调用。如果发生错误，它将作为第一个参数返回-我们检查是否存在错误，并在存在时抛出它，以便测试失败。
- en: 'The second argument containing the browser object, which is the same as the
    browser object we already had. This means that we can omit the second argument
    altogether and work with the previous browser reference, like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数包含浏览器对象，与我们已经有的浏览器对象相同。这意味着我们可以完全省略第二个参数，并使用之前的浏览器引用，就像这样：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If it''s the same browser object, you may ask why that object is even passed.
    It''s there to support this form of invocation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是同一个浏览器对象，你可能会问为什么要传递那个对象。它是为了支持这种调用形式：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that here we're using the capitalized pseudo-class `Browser` object; we're
    not instantiating `browser`. Instead, we're leaving that up to the `Browser` module
    to do it and to pass it on to us as the second argument of our callback function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们正在使用大写的伪类`Browser`对象；我们没有实例化`browser`。相反，我们将这个工作留给`Browser`模块来做，并将它作为回调函数的第二个参数传递给我们。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From now on, we will prefer this last succinct form to the others shown here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将更喜欢这种简洁的形式，而不是这里显示的其他形式。
- en: When is the browser ready?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器何时准备好？
- en: When we ask the browser to visit a URL, it calls us back when it's finished,
    but as web developers know, it's tricky to know exactly when a page load can be
    considered fully finished
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要求浏览器访问一个URL时，它在完成时会回调我们，但是正如网页开发者所知，很难准确知道何时可以认为页面加载完全完成
- en: A browser object has its own event loop that handles asynchronous events, such
    as loading resources, events, timeouts, and intervals. After a page is loaded
    and parsed, all the dependencies are loaded and parsed asynchronously—just like
    in real browsers—using this event loop.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器对象有自己的事件循环，处理异步事件，如加载资源、事件、超时和间隔。页面加载和解析完成后，所有依赖项都会异步加载和解析-就像在真实浏览器中一样-使用这个事件循环。
- en: Some of these dependencies may contain JavaScript files that will be loaded,
    parsed, and evaluated. Furthermore, the HTML document may contain some additional
    inline scripts that will be executed. If any of these scripts have a callback
    waiting for the document to be ready, these callbacks will be executed before
    your `browser.visit()` callback fires your test callback. This means that if,
    for instance, you have jQuery code that gets fired when the document is ready,
    it will run before your callback. The same can be said for any subsequent AJAX
    callbacks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些依赖项可能包含将被加载、解析和评估的JavaScript文件。此外，HTML文档可能包含一些额外的内联脚本，将被执行。如果其中任何脚本有一个等待文档准备就绪的回调，这些回调将在您的`browser.visit()`回调触发测试回调之前执行。这意味着，例如，如果您有在文档准备就绪时触发的jQuery代码，它将在您的回调之前运行。对于任何后续的AJAX回调也是如此。
- en: 'To see this in action, try adding the following code immediately before the
    closing `</body>` tag in the `templates/layout.html` file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此操作，请尝试在`templates/layout.html`文件的关闭`</body>`标记之前立即添加以下代码：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then change the test code in `test/users.js` so that it logs when the visit
    callback gets fired:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更改`test/users.js`中的测试代码，以便在访问回调被触发时记录日志：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To analyze this, we are going to run our tests in debug mode. In this mode,
    Zombie.js outputs some useful information, which includes the HTTP request activity
    that the browser is carrying out. To enable this mode, set the `DEBUG` environment
    variable like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析这一点，我们将以调试模式运行我们的测试。在此模式下，Zombie.js输出一些有用的信息，包括浏览器正在执行的HTTP请求活动。要启用此模式，请设置`DEBUG`环境变量，像这样：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should now get the following debug output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该获得以下调试输出：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are a Windows user, this last command will not work. You will need to
    set the `DEBUG` environment variable before running the Mocha command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Windows用户，则最后一个命令将无法工作。在运行Mocha命令之前，您需要设置`DEBUG`环境变量：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will also need to replace the forward slashes (`/`) to backslashes (`\`):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要将正斜杠(`/`)替换为反斜杠(`\`)：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the `LOADED NEW` string is printed before the `VISIT IS DONE`
    string, which means that the browser performed and finished the AJAX request before
    your visit callback fired. You may wish to return to the code now and remove this
    extra console logging.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`LOADED NEW`字符串在`VISIT IS DONE`字符串之前打印，这意味着浏览器在访问回调触发之前执行并完成了AJAX请求。您现在可能希望返回代码并删除这些额外的控制台日志。
- en: Options when visiting URLs
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问URL时的选项
- en: 'You can also pass in some options to the browser, to modify some of the actions
    and conditions regarding how it loads the page. These options come in the form
    of an object that you pass as an argument to the `Browser.visit()` call, right
    before the callback, like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以向浏览器传递一些选项，以修改它加载页面的一些操作和条件。这些选项以对象的形式传递给`Browser.visit()`调用的参数，就在回调之前，像这样：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are the most useful options that we will discuss in detail:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将详细讨论的最有用的选项：
- en: debug
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: headers
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题
- en: maxWait
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: maxWait
- en: debug
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试
- en: 'As we''ve seen, by setting the `DEBUG` environment variable, you can get some
    output from Zombie.js. This feature can also be activated by setting the `debug`
    option to `true`, like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通过设置`DEBUG`环境变量，您可以从Zombie.js获得一些输出。通过将`debug`选项设置为`true`，也可以激活此功能，像这样：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: headers
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标题
- en: 'You can define a set of headers to be sent out on each HTTP request that originates
    from this visit. By default, Zombie.js sends these header values:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义一组标头，以便在每个源自此访问的HTTP请求上发送。默认情况下，Zombie.js发送这些标头值：
- en: '**user-agent**: Mozilla/5.0, Chrome/10.0.613.0, Safari/534.15, or Zombie.js/1.4.1'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户代理**：Mozilla/5.0，Chrome/10.0.613.0，Safari/534.15，或Zombie.js/1.4.1'
- en: '**accept-encoding**: identity'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接受编码**：身份'
- en: '**host**: localhost:3000'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**：localhost:3000'
- en: '**connection**: keep-alive'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：保持连接'
- en: The `user-agent` header defines a fake user agent that somewhat mimics the Mozilla,
    Chrome, and Safari browsers, but you can change that in this setting, as you'll
    see later.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`user-agent`标头定义了一个虚假的用户代理，有些类似于Mozilla，Chrome和Safari浏览器，但您可以在此设置中更改它，稍后会看到。'
- en: The `accept-encoding` header is specifying that no encoding should be done on
    the resulting document.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept-encoding`标头指定结果文档不应进行编码。'
- en: The `host` header is required as of HTTP 1.1 and specifies which hostname you're
    referring to for this request.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`host`标头是HTTP 1.1的必需项，指定了此请求所引用的主机名。'
- en: 'The `connection: keep-alive` header specifies that the connection to the server
    should be kept open after the request is done. This is an internal option that
    allows Node to reuse client-side sockets throughout many HTTP connections, which
    will slightly speed up your tests.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`connection: keep-alive`标头指定在请求完成后应保持与服务器的连接。这是一个内部选项，允许Node在许多HTTP连接中重用客户端套接字，这将略微加快您的测试速度。'
- en: 'To add an additional header value, should your application need any, specify
    them like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加额外的标头值，如果您的应用程序需要任何标头值，请像这样指定它们：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that these values will also be sent for every request when loading dependencies
    such as subsequent CSS and JavaScript files referred to in your HTML document.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些值在加载依赖项时也将发送给每个请求，例如在HTML文档中引用的后续CSS和JavaScript文件。
- en: maxWait
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: maxWait
- en: 'By default, when calling `Browser.visit`, Zombie.js loads the page, parses
    it, loads the dependencies, and runs any pending JavaScript code in the browser.
    If this takes more than 5 seconds, an error will be raised and your test will
    fail. If, for any reason, 5 seconds is not enough for all of this to happen, the
    limit can be increased by changing the `maxWait` option like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，调用`Browser.visit`时，Zombie.js加载页面，解析页面，加载依赖项，并在浏览器中运行任何待处理的JavaScript代码。如果这需要超过5秒，将引发错误并使您的测试失败。如果由于任何原因，5秒不足以完成所有这些操作，则可以通过像这样更改`maxWait`选项来增加限制：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can specify the value as a string as `10ms`, `100ms`, `7.5s`, and so on..
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将值指定为字符串，如`10ms`，`100ms`，`7.5s`等。
- en: Checking the existence of elements
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查元素的存在
- en: When the `Browser.visit()` callback is fired, we check for errors. We also check
    whether the page was successfully loaded if the HTTP response status code was
    between 200 and 299\. These 2XX response codes correspond to the `ok` request
    state and are part of the server's way of telling the user-agent that everything
    went well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Browser.visit()`回调被触发时，我们检查错误。我们还检查页面是否成功加载，如果HTTP响应状态码在200到299之间。这些2XX响应代码对应于`ok`请求状态，并且是服务器告知用户代理一切顺利进行的方式的一部分。
- en: Despite receiving an `ok` response, we shouldn't take the server's word for
    granted. We may have received the response status code and an HTML document, but
    can't be sure that we got the intended document containing the markup for the
    user signup form.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管收到了一个`ok`响应，我们不应该轻信服务器的话。我们可能已经收到了响应状态码和一个HTML文档，但不能确定我们是否得到了包含用户注册表标记的预期文档。
- en: 'In our case, we may wish to verify that the document has a heading element
    containing the `New User` string and that the new user form elements are present.
    Here is the code for the complete test:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们可能希望验证文档是否包含一个包含`New User`字符串的标题元素，并且新用户表单元素是否存在。以下是完整测试的代码：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The new lines on the test are highlighted. Let's go through them now.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中的新行已经突出显示。现在让我们逐个查看它们。
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `browser.text(<selector>)` is being used to extract the text content of
    the `h1` tag if (at least) one exists.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`browser.text(<selector>)`被用来提取`h1`标签的文本内容（如果至少有一个存在）。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a selector matches more than one HTML element (which would happen if you
    had, in this case, more than one `h1` tag in the document), `browser.text(<selector>)`
    will return the concatenated text of all the matched nodes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择器匹配多个HTML元素（如果在文档中有多个`h1`标签），`browser.text(<selector>)`将返回所有匹配节点的连接文本。
- en: Here, the selector is just the tag name, but you can use any Sizzle-valid selector.
    These are similar to CSS3 selectors, which are also used in jQuery. If you're
    not familiar with these, don't worry, we will be seeing more examples of these
    in the future.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，选择器只是标记名称，但您可以使用任何Sizzle有效的选择器。这些类似于CSS3选择器，也用于jQuery。如果您对此不熟悉，不用担心，我们将在未来看到更多这方面的例子。
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The browser (and all browsers) stores the representation of the current document
    in an accessible structure called **Document Object Module** (**DOM**). The HTML
    markup inside a document is parsed by the browser and the DOM tree is built. This
    DOM can be traversed programmatically using JavaScript.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器（以及所有浏览器）将当前文档的表示存储在一个可访问的结构中，称为**文档对象模型**（**DOM**）。文档中的HTML标记由浏览器解析，并构建DOM树。可以使用JavaScript以编程方式遍历此DOM。
- en: 'Here we are using the `browser.query(<selector>)` method to extract the first
    form element. This element is a DOM node, as you would find in the browser, and
    it respects the DOM specification. For now, we''re only testing whether it exists.
    After this, we are going to check whether some attributes are correct:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`browser.query(<selector>)`方法来提取第一个表单元素。这个元素是一个DOM节点，就像您在浏览器中找到的那样，并且符合DOM规范。目前，我们只是测试它是否存在。之后，我们将检查一些属性是否正确：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we're verifying that the form method is `POST` and that, when the user
    submits it, it actually posts to the `/users` URL.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在验证表单方法是否为`POST`，以及当用户提交时，它是否实际上发布到`/users` URL。
- en: 'Next we verify if the form elements that are necessary to create a user are
    present:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们验证是否存在创建用户所需的表单元素：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We're using the `browser.query(<selector>, <context>)` form to retrieve the
    first matching node, but this time, we're restraining the search to the subset
    child of `<context>`, which in our case is our `form` node. We are also using
    more complex selectors here, combining the tag name selector (`form`) with the
    ID selector `#id` and the attribute selector `[type=email]`. For instance, the
    first selector, `input[type=email]#email`, selects inputs that have the attribute
    of type `email` and an ID of the value `email`. This way, we're asserting that
    such an element exists since, if it didn't exist, the `browser.query()` call would
    return `undefined`, breaking the assert call.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`browser.query(<selector>, <context>)`形式来检索第一个匹配的节点，但这次，我们将搜索限制在`<context>`的子集中，这在我们的情况下是我们的`form`节点。我们还在这里使用更复杂的选择器，将标记名称选择器（`form`）与ID选择器`#id`和属性选择器`[type=email]`结合使用。例如，第一个选择器`input[type=email]#email`选择具有类型`email`属性和值`email`的ID的输入。这样，我们断言这样的元素存在，因为如果不存在，`browser.query()`调用将返回`undefined`，破坏断言调用。
- en: Filling a form
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填写表单
- en: 'Once you have loaded a page containing the user subscription form, you can
    fill the form and submit it back to the server. For this, we will use a new test
    case:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了包含用户订阅表单的页面，您就可以填写表单并将其提交回服务器。为此，我们将使用一个新的测试用例：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here we''re revisiting the user creation form, and once the form has loaded,
    we''re filling in the e-mail and password fills by using the `browser.fill(<field>,
    <value>)` method. In this form, `browser.fill()` accepts several types of arguments
    as a field identifier. Here we''re using the label text that precedes the field.
    If you view the source for the empty user creation form, it will be:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重新访问用户创建表单，一旦表单加载完成，我们就使用`browser.fill(<field>, <value>)`方法填写电子邮件和密码填写。在这个表单中，`browser.fill()`接受几种类型的参数作为字段标识符。在这里，我们使用了字段之前的标签文本。如果查看空的用户创建表单的源代码，它将是：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each of the two label tags we are using here has a `for` attribute that indicates
    the `id` attribute of the tag it relates to. This is what Zombie.js uses to match
    the field in `browser.fill()`. Alternatively, we could also specify the field
    name or CSS selector, making the following fill directives equivalent to what
    we have:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的两个标签标签都有一个`for`属性，指示它所关联的标签的`id`属性。这是Zombie.js用来匹配`browser.fill()`中的字段的方法。或者，我们还可以指定字段名称或CSS选择器，使以下填充指令等同于我们所拥有的：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can then run the test by typing on the shell console:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在shell控制台上运行测试：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Provided the CouchDB server is accessible, these tests should then pass:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 只要CouchDB服务器可访问，这些测试就应该通过：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But, if you run the tests again, they should fail. Try it now:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果再次运行测试，它们应该失败。现在试试看：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is because we don't allow two users with the same e-mail address, and the
    browser yields a 409 response code as the result of such a user creation request.
    You could remove the user document from the database by hand before each test,
    but to fully remedy this, we need to automate the process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们不允许使用相同电子邮件地址的两个用户，浏览器会产生409响应代码作为这种用户创建请求的结果。您可以在每次测试之前手动从数据库中删除用户文档，但为了完全解决这个问题，我们需要自动化这个过程。
- en: 'First we''re going to introduce the concept of fixtures. This is where we will
    define the username and password for our user, which will be used in other tests.
    You then need to create a file under `test/fixtures.json` with the following data
    for now:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍固定装置的概念。这是我们将为用户定义用户名和密码的地方，这将在其他测试中使用。然后，您需要创建一个文件，在`test/fixtures.json`下，目前包含以下数据：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This JSON file will then be consumed by the `users` test file by placing `require`
    right at the top:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`users`测试文件将通过在顶部放置`require`来消耗此JSON文件：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then you also need to access the database, and for doing that we use the same
    library that the route listeners use:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您还需要访问数据库，为此我们使用与路由监听器使用相同的库：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we need to add a before hook into the `Signup Form` test description scope:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在`Signup Form`测试描述范围内添加一个before hook：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will make sure there is no such user record in our database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保我们的数据库中没有这样的用户记录。
- en: 'Now that we''re using fixtures, let''s remove those hard-coded username and
    password strings from our test code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用固定装置，让我们从测试代码中删除那些硬编码的用户名和密码字符串：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This would then be the whole assembled user test file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是整个组装的用户测试文件：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When running this test repeatedly, you should always get a success message now.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当重复运行此测试时，现在应该总是会收到成功消息。
- en: Testing the login form
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试登录表单
- en: Now that we have the user creation flow tested, let's test if that user can
    log in.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了用户创建流程，让我们测试一下该用户是否可以登录。
- en: 'Following the test file pattern we have been using, you need to create a file
    under `test/session.js` with the following content:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们一直使用的测试文件模式，您需要创建一个文件，在`test/session.js`下，内容如下：
- en: 'First, import the missing dependencies:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入缺少的依赖项：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That concludes the opening ceremonies!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了开幕式！
- en: 'Now we are ready to start describing the login form:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备开始描述登录表单：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This `before` hook creates the test user document if one doesn't exist (instead
    of removing if it existed).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此`before`钩子将创建测试用户文档（如果不存在）（而不是在存在时删除）。
- en: 'Next, we will test whether the login form loads and contains the relevant elements:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将测试登录表单是否加载并包含相关元素：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The only difference here from the user code is that the heading string should
    be `Log in` instead of `New User`. This happens because we have such a minimal
    user creation form, which suits us for the time being.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里与用户代码的唯一区别是标题字符串应为`登录`，而不是`新用户`。这是因为我们目前使用了这样一个最小的用户创建表单。
- en: 'Next we are testing to see whether the login form actually works:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们正在测试登录表单是否实际有效：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here we're loading and filling in the e-mail and password fields and clicking
    on the **Log In** button. When clicking on the button, the login form is posted,
    the session is initiated, and the user is redirected to the to-do items page.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在加载并填写电子邮件和密码字段，然后单击**登录**按钮。单击按钮后，登录表单将被发布，会话将被启动，并且用户将被重定向到待办事项页面。
- en: 'Now run this test file from the command line:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从命令行运行此测试文件：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This test includes the case for when the user enters the right username and
    password, but what happens when that''s not the case? Let''s create a test case
    for it:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此测试包括用户输入正确用户名和密码的情况，但如果不是这种情况会发生什么？让我们为此创建一个测试用例：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we're loading and filling the login form, but this time we're providing
    a wrong password. After clicking on the **Log In** button, the server should return
    `403 status code`, which will trigger an error passed in to our callback. Then
    we need to check the return status code by inspecting the `browser.statusCode`
    attribute, making sure it's the expected 403 forbidden code. Then we also verify
    that the user did not get redirected to the `/todo` URL and that the response
    document contains an alert message saying `Invalid password`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在加载并填写登录表单，但这次我们提供了错误的密码。单击**登录**按钮后，服务器应返回`403状态码`，这将触发传递给我们回调函数的错误。然后，我们需要通过检查`browser.statusCode`属性来检查返回状态码，确保它是预期的403禁止代码。然后，我们还要验证用户是否没有被重定向到`/todo`
    URL，并且响应文档是否包含一个警报消息，说`无效密码`。
- en: Testing the to-do list
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试待办事项列表
- en: 'Now that we''re done with the user registration and the session initiation,
    we are ready to test the core of our app, which is to manage to-do items. We will
    start by segregating that part of the application tests into a file of their own
    at `test/todos.js`, which may start with the following boilerplate:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了用户注册和会话启动，我们准备测试我们的应用程序的核心，即管理待办事项。我们将首先将应用程序测试的这一部分分离到一个自己的文件中，即`test/todos.js`，它可能以以下样板开始：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here we have similar boilerplate code for the other modules, with the difference
    that now we are dealing with a database named `todos`, not `users`. Another difference
    is that we want to start with a clean to-do list for each test, so we're adding
    a `beforeEach` hook that removes all the to-do items for the test user.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有其他模块的类似样板代码，不同之处在于现在我们处理的是名为`todos`而不是`users`的数据库。另一个不同之处是我们希望每次测试都从一个干净的待办事项列表开始，因此我们添加了一个`beforeEach`钩子，用于删除测试用户的所有待办事项。
- en: 'We are now ready to start carving out some tests, but there is at least one
    cumbersome repetitive task ahead that can be avoided at an early stage: logging
    in. We should assume that each test is individually reproducible and that the
    ordering of the tests doesn''t matter—each test should rely on one browser instance,
    mimicking one individual user session per test. Also, since all the to-do item
    manipulation is scoped to a user and the user session must be initiated, we need
    to abstract that away into its own module inside `test/login.js`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始制定一些测试，但至少有一个繁琐的重复任务可以在早期避免：登录。我们应该假设每个测试都可以单独重现，并且测试的顺序并不重要——每个测试应该依赖于一个浏览器实例，模拟每个测试一个独立的用户会话。此外，由于所有待办事项操作都限定在用户和用户会话中必须初始化，我们需要将其抽象成自己的模块，放在`test/login.js`中：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This module makes sure that a test user exists before loading, filling, and
    posting the user login form. After that it hands off the control to a `next` function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块确保在加载、填写和提交用户登录表单之前存在一个测试用户。之后，它将控制权交给`next`函数。
- en: Testing the to-do list page
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试待办事项列表页面
- en: 'Now we are ready to add further description scopes inside our `todos` scope.
    One of these scopes is the to-do list, which will have this code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在`todos`范围内添加更多的描述范围。其中一个范围是待办事项列表，其中将包含以下代码：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here we can see that that we are making use of our `login` module to abstract
    away the session initiation dance, making sure our callback function only gets
    called once the user is logged in. Here we have three tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们正在使用我们的`login`模块来抽象出会话初始化过程，确保我们的回调函数只有在用户登录后才会被调用。这里有三个测试。
- en: In our first test, named `should have core elements`, we are simply loading
    the empty to-do list and asserting that we have some elements in place, such as
    a heading containing the `Your To-dos` text and a link to create a new to-do item.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个测试中，名为`应该具有核心元素`，我们只是加载空的待办事项列表，并断言我们已经放置了一些元素，例如包含`Your To-dos`文本的标题和创建新待办事项的链接。
- en: In the following test, named `should start with an empty list`, we are simply
    testing whether the to-do list contains zero elements.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下测试中，名为`应该以空列表开始`，我们只是测试待办事项列表是否包含零个元素。
- en: In the last test of this scope, named `should not load when the user is not
    logged in`, we are asserting that this list is inaccessible to the user that has
    not yet initiated the session, making sure he is redirected to `/session/new`
    if we try to load the `To-do list` URL.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在此范围的最后一个测试中，名为`当用户未登录时不应加载`，我们断言该列表对尚未初始化会话的用户是不可访问的，确保如果我们尝试加载`待办事项列表`URL，他会被重定向到`/session/new`。
- en: Testing the to-do item creation
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试待办事项创建
- en: 'Now, we need to test whether the to-do items can really be created. For that,
    follow these steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要测试待办事项是否真的可以创建。为此，请按照以下步骤进行：
- en: 'We need a new description scope that we''ll name `Todo creation form`—which
    will be another subscope of the `Todos` one:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个新的描述范围，我们将其命名为`待办事项创建表单`，这将是`Todos`的另一个子范围：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now test whether the to-do creation form is available for the user who
    is not logged in:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以测试一下，看看未登录的用户是否可以使用待办事项创建表单：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here we are verifying that the user gets redirected to the login screen if an
    attempt is made to load the to-do item creation form without being logged in.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在验证，如果尝试在未登录的情况下加载待办事项创建表单，用户是否会被重定向到登录界面。
- en: 'If the user is logged in, we check whether the page loads with some expected
    elements such as the title and the form elements for creating a new to-do item:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户已登录，我们将检查页面是否加载了一些预期的元素，例如标题和用于创建新待办事项的表单元素：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here we are verifying that the form is present, that it has the necessary attributes
    to make a `POST` request to the `/todos` URL, and that the form has a text area
    input and a button to press.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在验证表单是否存在，它是否具有必要的属性来向`/todos` URL发出`POST`请求，以及表单是否具有文本区输入和按钮。
- en: 'Now we can also test whether we can successfully create a to-do item by filling
    the respective form and submitting it:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还可以测试是否可以通过填写相应的表单并提交来成功创建待办事项：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we are finally testing whether the form allows us to post a new item and
    whether the item gets created. We are doing that by loading and filling in the
    to-do item creation form; verifying that we've been redirected to the to-do item
    list page; and that this page contains the single to-do item that we've just created.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们最终要测试表单是否允许我们发布新项目，以及项目是否已创建。我们通过加载和填写待办事项创建表单来进行测试；验证我们已被重定向到待办事项列表页面；以及该页面是否包含我们刚刚创建的单个待办事项。
- en: Testing to-do item removal
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试待办事项删除
- en: 'Now that we''ve tested to-do item insertion, we can test whether one can actually
    remove these items from one''s list. We will place these tests inside a describe
    scope named `Todo removal form`, inside which we will test for two things: the
    removal of one to-do item when only one exists and the removal of a to-do item
    when more than one item exists.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了待办事项的插入，我们可以测试是否可以从列表中删除这些项目。我们将把这些测试放在一个名为`待办事项删除表单`的描述范围内，在其中我们将测试两件事：当只有一个待办事项存在时删除一个待办事项，以及当存在多个待办事项时删除一个待办事项。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are doing these two tests separately because it's easier to understand the
    one-item test and then move on to the more complex one and also to test separately
    that we are not making off-by-one errors that are so common in programming.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这两个测试分开进行，因为先理解单个项目的测试，然后再进行更复杂的测试，以及分开测试我们是否在编程中常见的一次性错误。
- en: 'Here is the code for the removal from a one-item list:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从一个项目列表中删除的代码：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Before we run the test, there is a `beforeEach` hook that inserts a to-do item
    into the `todo` database for the test user. That''s just one to-do item that''s
    taken from `fixtures.todo`, which is a property we need to add to the `test/fixtures.json`
    file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，有一个`beforeEach`钩子，它会在测试用户的`todo`数据库中插入一个待办事项。这只是从`fixtures.todo`中取出的一个待办事项，这是我们需要添加到`test/fixtures.json`文件的属性：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You may notice that, we're taking the opportunity here to add some additional
    fixtures that will help in future tests.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，我们在这里利用机会添加一些额外的固定装置，这将有助于未来的测试。
- en: 'Continuing analyzing the test code, we see that the test fetches the to-do
    list and then verifies that the number of to-do items is actually one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 继续分析测试代码，我们看到测试获取待办事项列表，然后验证待办事项的数量实际上是一个：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then it goes on to try and press the remove button of that one to-do item:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它继续尝试按下那个待办事项的移除按钮：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The selector assumes that there is one to-do item on the table, which we had
    already verified before.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器假设表格上有一个待办事项，我们之前已经验证过了。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the browser cannot find a button or submit element from the given CSS selector,
    it will throw an error, ending the current test.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器无法从给定的CSS选择器中找到按钮或提交元素，它将抛出错误，结束当前测试。
- en: 'Then, after pressing the button and submitting the removal form, we''re verifying
    that no errors occurred, that the browser was redirected back to the `/todos`
    URL, and that the presented list is now empty:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在按下按钮并提交移除表单后，我们验证没有发生错误，浏览器被重定向回`/todos` URL，并且现在呈现的列表为空：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that we''ve tested that this works well for removing one item from a one-item
    list, let''s create a more evolved test that asserts that we can remove a specific
    item from a list of three items:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了从一个一项列表中移除一项的工作情况，让我们创建一个更进化的测试，断言我们可以从三项列表中移除特定的项目：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This description scope will sit at the same level as the previous one, also
    inserting a document in the `todo` database, but this time the document contains
    a list of three to-do items, taken from the `fixtures.todos` attribute (instead
    of the previously used singular `fixtures.todo` attribute).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个描述范围将与先前的描述范围处于同一级别，还会在`todo`数据库中插入一个文档，但这次文档包含了一个包含三个待办事项的列表，取自`fixtures.todos`属性（而不是先前使用的单数`fixtures.todo`属性）。
- en: 'The test starts by visiting the `todo` list page and building a list of the
    expected to-do items, stored in the variable named `expectedList`. We then retrieve
    all the to-do list items found on the HTML document and verify that the content
    is what is expected:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 测试从访问`todo`列表页面开始，并构建预期待办事项列表，存储在名为`expectedList`的变量中。然后我们检索在HTML文档中找到的所有待办事项，并验证内容是否符合预期：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once we have verified that all the expected to-do items are in place and in
    order, we go on to click on the button for the second item on the list by using
    the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证了所有预期的待办事项都已经就位并且顺序正确，我们继续通过以下代码点击列表中第二个项目的按钮：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we're using the special CSS selector `nth-child` for selecting exactly
    the row for the second do-to item and then fetching the code for removing submit
    button inside it, and finally pressing it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用特殊的CSS选择器`nth-child`来选择第二个待办事项的行，然后获取其中用于移除提交按钮的代码，并最终按下它。
- en: 'Once the button is pressed, the form is submitted, and the browser calls back,
    we verify that there are no errors, that we got redirected back to the `/todos`
    URL, and also that it contains the expected list. We do this last bit by removing
    the second element from the previously used `expectedList` array and verifying
    that this is exactly what is shown in the current page:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦按钮被按下，表单就会被提交，浏览器会回调，我们验证没有错误，我们被重定向回`/todos` URL，并且它包含了预期的列表。我们通过从先前使用的`expectedList`数组中移除第二个元素来做到这一点，并验证这正是当前页面显示的内容：
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Putting it all together
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: 'You can run the tests individually by hand, but you should be able to run them
    all at once. For that, you simply need to call from the shell command line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动逐个运行测试，但应该能够一次运行它们全部。为此，您只需要从shell命令行中调用：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We now need to change `package.json` so that you can inform **node package**
    **manager** (**npm**) how to run the tests:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更改`package.json`，以便您可以告诉**node package** **manager** (**npm**)如何运行测试：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can now run your tests using:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用以下命令运行您的测试：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Zombie.js allows us to visit URLs, load HTML documents, and retrieve HTML elements
    using CSS selectors. It also allows us to easily fill forms and submit them, to
    click on buttons and follow links, to verify the return status code, and to analyze
    the response document in the same way using a terse, convenient API.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Zombie.js允许我们访问URL，加载HTML文档，并使用CSS选择器检索HTML元素。它还允许我们轻松填写表单并提交它们，点击按钮并跟随链接，验证返回状态代码，并使用简洁方便的API以相同的方式分析响应文档。
