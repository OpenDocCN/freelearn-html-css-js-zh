- en: Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: There was a time when most of the web comprised pages with static content—the
    only graphics were embedded images. Over time, however, application requirements
    became more ambitious and began running into limitations. As highly interactive
    applications became an increasingly important part of the user experience, there
    was, eventually, enough demand for a fully programmable graphics **Application
    Programming Interface** (**API**) to address these requirements. In 2006, Vladimir
    Vukicevic, an American-Serbian software engineer, began working on an OpenGL prototype
    for a then-upcoming HTML `<canvas>` element that he called Canvas 3D. In March
    2011, his work would lead to the Kronos Group, the nonprofit organization behind
    OpenGL, to create **WebGL**, a specification to grant internet browsers access
    to **Graphics Processing Units** (**GPUs**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，大部分的网页都是由静态内容组成的——唯一的图形就是嵌入的图片。然而，随着时间的推移，应用需求变得更加雄心勃勃，并开始遇到限制。随着高度交互式应用逐渐成为用户体验的重要组成部分，最终对完全可编程的图形**应用程序编程接口**（**API**）的需求变得足够大，以解决这些需求。2006年，一位美国塞尔维亚软件工程师Vladimir
    Vukicevic开始为当时即将推出的HTML `<canvas>` 元素开发一个OpenGL原型，他称之为Canvas 3D。2011年3月，他的工作将导致OpenGL背后的非营利组织Kronos
    Group创建**WebGL**，这是一个规范，允许互联网浏览器访问**图形处理单元**（**GPU**）。
- en: All of the browser engines collaborated to create WebGL, the standard for rendering
    3D graphics on the web. It was based on OpenGL **Embedded Systems** (**ES**),
    a cross-platform API for graphics targeted at embedded systems. This was the right
    starting place, because it made it possible to easily implement the same API in
    all browsers, especially since most browser engines were running on systems that
    had support for OpenGL.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所有浏览器引擎合作创建了WebGL，这是在网络上渲染3D图形的标准。它基于OpenGL **嵌入式系统**（**ES**），这是一个针对嵌入式系统的跨平台图形API。这是一个正确的起点，因为它使得在所有浏览器中轻松实现相同的API成为可能，特别是由于大多数浏览器引擎都在支持OpenGL的系统上运行。
- en: WebGL was originally based on OpenGL ES 2.0, the OpenGL specification version
    for devices such as Apple's iPhone and iPad. But, as the specification evolved,
    it became independent with the goal of providing portability across various operating
    systems and devices. The idea of web-based, real-time rendering opened a new world
    of possibilities for web-based 3D environments. Due to the pervasiveness of web
    browsers, these and other kinds of 3D applications could now be rendered on desktop
    and mobile devices such as smartphones and tablets. According to the Khronos Group, the
    ability for Web developers to directly access OpenGL-class graphics directly from
    JavaScript, and freely mix 3D with other HTML content, will enable a new wave
    of innovation in Web gaming, educational and training applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL最初基于OpenGL ES 2.0，这是OpenGL规范的一个版本，用于像苹果的iPhone和iPad这样的设备。但随着规范的演变，它变得独立，目标是提供跨各种操作系统和设备的可移植性。基于网络的实时渲染的想法为基于网络的3D环境开辟了一个全新的可能性世界。由于网络浏览器的普遍性，这些以及其他类型的3D应用现在可以在桌面和移动设备上，如智能手机和平板电脑上渲染。根据Khronos
    Group的说法，Web开发者能够直接从JavaScript中访问OpenGL类图形，并且可以自由地将3D与其他HTML内容混合，这将促进Web游戏、教育和培训应用的新一波创新。
- en: Even though WebGL was vastly adopted for many years after it matured into a
    stable release—shipping inside Firefox, Chrome, Opera, IE11, and Android's mobile
    web browsers—Apple still lacked official WebGL support. Neither OS X Safari nor
    Safari Mobile supported WebGL. In fact, it wasn't until 2014, at June's **Worldwide
    Developers Conference** (**WWDC**), that Apple announced that both OS X Yosemite
    and iOS 8 would ship with WebGL support. This became a turning point for 3D graphics
    on the web. With official support from all major browsers, the entire range of
    3D graphics—at native speeds—could be delivered to billions of desktop and mobile
    devices. WebGL unleashed the power of graphics processors to developers on an
    open platform, allowing console-quality application to be built for the web.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管WebGL在成熟并稳定发布后得到了广泛采用——集成在Firefox、Chrome、Opera、IE11和Android的移动网络浏览器中——但苹果仍然缺乏官方的WebGL支持。无论是OS
    X Safari还是Safari Mobile都不支持WebGL。实际上，直到2014年6月的**全球开发者大会**（**WWDC**），苹果才宣布OS X
    Yosemite和iOS 8将内置WebGL支持。这成为了网络3D图形的一个转折点。随着所有主要浏览器的官方支持，整个3D图形范围——以原生速度——可以被发送到数十亿台桌面和移动设备。WebGL释放了图形处理器的力量，为开放平台上的开发者提供了能力，使得可以在网络上构建具有控制台品质的应用程序。
- en: 'In this chapter, we will do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行以下操作：
- en: Understand the necessary system requirements to run WebGL.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解运行 WebGL 所需的系统要求。
- en: Cover the common high-level components of a WebGL application.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖 WebGL 应用程序的高级组件。
- en: Set up a drawing area (`canvas`).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置绘图区域（`canvas`）。
- en: Test your browser's WebGL capabilities.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试您的浏览器 WebGL 功能。
- en: Understand that WebGL acts as a state machine.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 WebGL 作为状态机的角色。
- en: Modify WebGL variables that affect your scene.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改影响您场景的 WebGL 变量。
- en: Load and examine a fully-functional scene.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载并检查一个完全功能的场景。
- en: System Requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统要求
- en: WebGL is a web-based 3D Graphics API. As such, there is *no* installation needed. While
    WebGL 1 is based on the OpenGL ES 2.0 specification, WebGL 2 is based on OpenGL
    ES 3.0, which guarantees the availability of many WebGL 1 extensions along with
    new features.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 是一个基于网络的 3D 图形 API。因此，无需安装。虽然 WebGL 1 基于 OpenGL ES 2.0 规范，但 WebGL 2 基于
    OpenGL ES 3.0，这保证了许多 WebGL 1 扩展和新特性的可用性。
- en: WebGL 2 Versus WebGL 1
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 2 与 WebGL 1 的比较
- en: Given this book covers WebGL 2, all WebGL and WebGL 2 terms reference the WebGL
    2 (OpenGL ES 3.0) specification. Any references to WebGL 1 (OpenGL ES 2.0) will
    be done so explicitly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书涵盖 WebGL 2，所有 WebGL 和 WebGL 2 术语均指 WebGL 2（OpenGL ES 3.0）规范。任何对 WebGL 1（OpenGL
    ES 2.0）的引用都将明确指出。
- en: 'As of January 27, 2016, WebGL 2 is available by default in Firefox and Chrome. You
    will automatically have access to WebGL 2, provided you have one of the following
    web browsers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2016 年 1 月 27 日，Firefox 和 Chrome 默认提供 WebGL 2。如果您使用以下任一网络浏览器，您将自动获得对 WebGL
    2 的访问权限：
- en: Firefox 51 or above
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox 51 或更高版本
- en: Google Chrome 56 or above
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Chrome 56 或更高版本
- en: Chrome for Android 64 or above
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome for Android 64 或更高版本
- en: For an updated list of the web browsers that support WebGL, please visit the
    Khronos Group web page: [http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation](http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有关支持 WebGL 的网络浏览器的最新列表，请访问 Khronos Group 网页：[http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation](http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation)。
- en: Or visit the well-known **CanIUse.com** resource: [https://caniuse.com/#search=WebGL
    2](https://caniuse.com/#search=webgl2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者访问知名的 **CanIUse.com** 资源：[https://caniuse.com/#search=WebGL 2](https://caniuse.com/#search=webgl2)。
- en: Modern Standards
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现代标准
- en: Since we will be using modern browsers to run WebGL 2, we will also leverage
    HTML5, CSS3, and JavaScript ES6 throughout this book. For more information on
    these modern standards, please refer to the following link: [https://developer.mozilla.org/en-US/docs/Web](https://developer.mozilla.org/en-US/docs/Web).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用现代浏览器来运行 WebGL 2，因此本书将全面使用 HTML5、CSS3 和 JavaScript ES6。有关这些现代标准的更多信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Web](https://developer.mozilla.org/en-US/docs/Web)。
- en: At the time of this book's publication, WebGL 2 remains a specification that's
    in flux. Some parts of the specification are considered stable and have been implemented
    in modern browsers; other parts should be considered experimental and have been
    partially implemented to varying degrees. Therefore, you should be familiar with
    how the standardization process works and the levels of implementation for each
    new property. That being said, WebGL 2 is nearly 100% backward compatible with
    WebGL 1\. All exceptions to backward compatibility are recorded in the following
    link: [https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY](https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书出版时，WebGL 2 仍然是一个处于变动中的规范。规范的一些部分被认为是稳定的，并在现代浏览器中实现了；其他部分应被视为实验性的，并且已经以不同程度的程度部分实现。因此，您应该熟悉标准化过程以及每个新属性的实施级别。话虽如此，WebGL
    2 几乎与 WebGL 1 完全向后兼容。所有向后不兼容的例外情况记录在以下链接中：[https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY](https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY)。
- en: Migrating to WebGL 2
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到 WebGL 2
- en: If you have prior experience with WebGL 1 or are curious about migration strategies
    to WebGL 2, you can refer to [Chapter 11](9a56a1ad-908b-4201-b95c-0c811b1bd011.xhtml), *WebGL
    2 Highlights*, where key differences between WebGL 1 and WebGL 2 are highlighted.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有 WebGL 1 的经验或对迁移策略到 WebGL 2 感兴趣，您可以参考第 11 章，*WebGL 2 突出特点*，其中突出了 WebGL 1
    和 WebGL 2 之间的关键差异。
- en: Lastly, you will need to make sure that your computer has an approved graphics
    card. To quickly validate your current configuration for WebGL 2, please visit
    the following link: [https://get.webgl.org/WebGL 2/](https://get.webgl.org/webgl2/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要确保你的计算机有一张经过批准的显卡。为了快速验证你的WebGL 2当前配置，请访问以下链接：[https://get.webgl.org/WebGL
    2/](https://get.webgl.org/webgl2/)。
- en: WebGL Rendering
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL渲染
- en: 'WebGL is a 3D graphics library that enables modern web browsers to render 3D
    scenes in a standard and efficient manner. According to Wikipedia, **rendering** is
    the process of generating an image from a model by means of computer programs.
    Since this is a process executed by a computer, there are different ways to produce
    such images. There are three main distinctions to make when discussing rendering:
    software-based and hardware-based rendering, server-based and client-based rendering,
    and retained-mode and immediate-mode rendering. As we will see, WebGL offers a
    unique approach to hardware and client based rendering with an immediate-mode
    API on the web.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL是一个3D图形库，它使现代网络浏览器能够以标准且高效的方式渲染3D场景。根据维基百科，**渲染**是通过计算机程序从模型生成图像的过程。由于这是一个由计算机执行的过程，因此有不同方式来生成这样的图像。在讨论渲染时，有三个主要区分：基于软件和硬件的渲染、基于服务器和客户端的渲染，以及保留模式与即时模式的渲染。正如我们将看到的，WebGL在Web上提供了一个独特的硬件和客户端基于即时模式API的渲染方法。
- en: Software and Hardware Based Rendering
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于软件和硬件的渲染
- en: The first distinction we should make is whether we are using any special graphics
    hardware. On one hand, we can talk about **software-based rendering** for cases
    where all required calculations to render 3D scenes are performed using the computer's
    **Central Processing Unit** (**CPU**). On the other hand, as is the case with
    WebGL, we use the term **hardware-based rendering** for scenarios where there
    is a GPU performing 3D graphics computations. From a technical standpoint, hardware-based
    rendering is much more efficient than software-based rendering, because the former
    involves dedicated hardware handling the necessary operations. In contrast, a
    software-based rendering solution can be more common due to the lack of hardware
    dependencies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该做的第一个区分是是否使用了任何特殊的图形硬件。一方面，我们可以谈论**基于软件的渲染**，在这种情况下，渲染3D场景所需的所有计算都是使用计算机的**中央处理器**（**CPU**）完成的。另一方面，正如WebGL的情况一样，我们使用**基于硬件的渲染**这个术语，用于有GPU执行3D图形计算的场景。从技术角度来看，基于硬件的渲染比基于软件的渲染更有效率，因为前者涉及专门的硬件处理必要的操作。相比之下，由于缺乏硬件依赖，基于软件的渲染解决方案可能更常见。
- en: Server and Client Based Rendering
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于服务器和客户端的渲染
- en: 'The second distinction to make is whether the rendering process is happening
    locally or remotely. When the image that needs to be rendered is too complex,
    the render will most likely occur remotely. This is the case for 3D animated movies
    where dedicated servers with lots of hardware resources render intricate scenes.
    We call this **server-based rendering**. The opposite of this approach takes place
    when rendering occurs locally. We call this **client-based rendering**. WebGL
    offers a client-based rendering approach: the elements that are a part of the
    3D scene are usually downloaded from a server. However, the processing required
    to obtain an image is all performed locally using the client''s graphics hardware.
    Although this is not a unique solution, compared to other technologies (such as
    Java 3D, Flash, and the Unity Web Player Plugin), WebGL presents several advantages:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的第二个区分是渲染过程是在本地还是远程进行。当需要渲染的图像过于复杂时，渲染最有可能在远程进行。例如，对于3D动画电影，需要使用配备大量硬件资源的专用服务器来渲染复杂的场景，我们称之为**基于服务器的渲染**。与此相反的方法发生在本地渲染时。我们称之为**基于客户端的渲染**。WebGL提供了一种基于客户端的渲染方法：3D场景中的元素通常从服务器下载。然而，获取图像所需的处理都是在客户端的图形硬件上本地完成的。尽管这不是一个独特的解决方案，但与其他技术（如Java
    3D、Flash和Unity Web Player插件）相比，WebGL具有几个优点：
- en: '**JavaScript programming**: JavaScript is a language that is natural to both
    web developers and browsers. Working with JavaScript allows you to access all
    parts of the DOM and easily integrate WebGL applications with other JavaScript
    libraries such as jQuery, React, and Angular.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript编程**：JavaScript是一种对网页开发者和浏览器都自然易用的语言。使用JavaScript可以让你访问DOM的所有部分，并轻松地将WebGL应用程序与其他JavaScript库（如jQuery、React和Angular）集成。'
- en: '**Automatic memory management**: WebGL—unlike other technologies, such as OpenGL,
    where memory allocation and deallocation are handled manually—follows the rules
    for JavaScript variable scoping and automatic memory management. This simplifies
    programming tremendously while reducing the code footprint. Ultimately, this simplification
    makes it easier to understand the application logic.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动内存管理**：WebGL 与其他技术（如 OpenGL，其中内存分配和释放是手动处理的）不同，遵循 JavaScript 变量作用域和自动内存管理的规则。这极大地简化了编程，同时减少了代码体积。最终，这种简化使得理解应用程序逻辑变得更加容易。'
- en: '**Pervasiveness**: Web browsers with JavaScript capabilities are installed
    in smartphones and tablet devices by default. This means you can leverage WebGL
    across a vast ecosystem of desktop and mobile devices.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普及性**：具有 JavaScript 功能的网页浏览器默认安装在智能手机和平板设备上。这意味着您可以在广泛的桌面和移动设备生态系统中利用 WebGL。'
- en: '**Performance**: Performance of WebGL applications is comparable to equivalent
    standalone applications (with some exceptions). This is possible due to WebGL''s
    ability to access the local graphics hardware. Until recently, many 3D web rendering
    technologies used software-based rendering.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：WebGL 应用程序的性能与等效的独立应用程序（有一些例外）相当。这是由于 WebGL 能够访问本地图形硬件的能力。直到最近，许多 3D
    网页渲染技术都使用基于软件的渲染。'
- en: '**Zero compilation**: WebGL is written in JavaScript; therefore, there is no
    need to compile your code before executing it on the web browser. This empowers
    you to make changes in real-time and see how those changes affect your 3D web
    application. Nevertheless, when we cover shader programs, we will understand that
    some compilation is needed. However, this occurs in your graphics hardware and
    not in your browser.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零编译**：WebGL 使用 JavaScript 编写；因此，在网页浏览器上执行之前不需要编译代码。这使得您能够实时进行更改并看到这些更改如何影响您的
    3D 网页应用程序。然而，当我们介绍着色器程序时，我们将了解到需要一些编译。但是，这发生在您的图形硬件上，而不是在您的浏览器上。'
- en: Retained and Immediate Mode Rendering
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留模式和即时模式渲染
- en: The third distinction to make is that WebGL is an immediate mode 3D rendering
    API designed for the web. Graphics APIs can be divided into retained-mode APIs
    and immediate-mode APIs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的第三个区分是 WebGL 是一个为网页设计的即时模式 3D 渲染 API。图形 API 可以分为保留模式 API 和即时模式 API。
- en: Retained-Mode Rendering
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留模式渲染
- en: 'A **retained-mode** API is declarative. The application builds a scene from
    primitives, such as shapes and lines, and then the graphics library maintains
    a scene model in memory. To change what is rendered, the application issues a
    command to update the scene, which could include, for example, adding or removing
    a shape; the library is then responsible for managing and redrawing the scene:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**保留模式** API 是声明式的。应用程序通过原始元素，如形状和线条，构建场景，然后图形库在内存中维护场景模型。要更改渲染内容，应用程序会发出更新场景的命令，例如添加或删除形状；库随后负责管理和重新绘制场景：'
- en: '![](img/20cc3540-9e72-4351-a72e-eb99abfa4bd6.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20cc3540-9e72-4351-a72e-eb99abfa4bd6.png)'
- en: Immediate-Mode Rendering
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时模式渲染
- en: 'An **immediate-mode** API is procedural. Immediate mode rendering requires
    the application to directly manage rendering. In this case, the graphics library
    does not maintain a scene model. Each time a new frame is drawn, the application
    issues all drawing commands required to describe the entire scene, regardless
    of actual changes. This method provides the maximum amount of control and flexibility
    to the application program:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**即时模式** API 是过程式的。即时模式渲染要求应用程序直接管理渲染。在这种情况下，图形库不维护场景模型。每次绘制新帧时，应用程序都会发出所有必要的绘图命令来描述整个场景，而不管实际的变化。这种方法为应用程序程序提供了最大程度的控制和灵活性：'
- en: '![](img/6445c540-8cec-4e28-826d-b4fe1b0e11c5.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6445c540-8cec-4e28-826d-b4fe1b0e11c5.png)'
- en: Retained Versus Immediate Mode Rendering
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留模式与即时模式渲染
- en: Retained-mode rendering can be simpler to use, because the API does more of
    the work for you, such as initialization, state maintenance, and cleanup. However,
    it is often less flexible since the API forces its own particular scene model;
    it can also have higher memory prerequisites because it needs to provide a general-purpose
    scene model. Immediate-mode rendering, on the other hand, as offered with WebGL,
    is much more flexible and can implement targeted optimizations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 保留模式渲染可能更容易使用，因为 API 会为你做更多的工作，例如初始化、状态维护和清理。然而，它通常不太灵活，因为 API 强制使用自己的特定场景模型；它也可能有更高的内存需求，因为它需要提供一个通用的场景模型。另一方面，WebGL
    提供的即时模式渲染则更加灵活，可以实现有针对性的优化。
- en: Elements in a WebGL Application
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL 应用程序中的元素
- en: WebGL, like other 3D graphics libraries, comprises many common 3D elements.
    These fundamental elements will be covered, chapter-by-chapter, throughout this
    book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL，像其他 3D 图形库一样，包含许多常见的 3D 元素。这些基本元素将按章节顺序在本书中进行介绍。
- en: 'Some of these common elements include the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些常见元素包括以下内容：
- en: '`canvas`: It is the placeholder where our scene is rendered. It is a standard
    HTML5 element and as such, can be accessed using the **Document Object Model**
    (**DOM**).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas`：它是我们的场景渲染的占位符。它是一个标准的 HTML5 元素，因此可以使用 **文档对象模型** (**DOM**) 访问。'
- en: '**Objects**: These are the 3D entities that make up the scene. These entities
    are composed of triangles. In the following chapters, we will see how WebGL handles
    and renders geometries using **buffers**.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：这些是构成场景的 3D 实体。这些实体由三角形组成。在接下来的章节中，我们将看到 WebGL 如何使用 **缓冲区** 处理和渲染几何形状。'
- en: '**Lights**: Nothing in a 3D world can be seen without lights. In later chapters,
    we will learn that WebGL uses **shaders **to model lights in the scene. We will
    see how 3D objects reflect or absorb light according to the laws of physics. We
    will also discuss different light models to visualize our objects.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灯光**：在 3D 世界中没有灯光，任何东西都无法被看到。在后面的章节中，我们将了解到 WebGL 使用 **着色器** 来在场景中建模灯光。我们将看到
    3D 对象如何根据物理定律反射或吸收光线。我们还将讨论不同的光照模型来可视化我们的对象。'
- en: '**Camera**: `canvas` acts as the viewport to the 3D world. We see and explore
    a 3D scene through it. In the following chapters, we will understand the different
    matrix operations that are required to produce a view perspective. We will understand
    how these operations can be modeled as a camera.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相机**：`canvas` 作为 3D 世界的视口。我们通过它看到并探索 3D 场景。在接下来的章节中，我们将了解产生视图透视所需的不同矩阵运算。我们将了解这些运算如何被建模为相机。'
- en: 'This chapter will cover the first element of our list: `canvas`. The following
    sections will help us understand how to create a `canvas` element and how to set
    up a WebGL context.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍我们列表中的第一个元素：`canvas`。接下来的部分将帮助我们了解如何创建 `canvas` 元素以及如何设置 WebGL 上下文。
- en: 'Time for Action: Creating an HTML5 Canvas Element'
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：创建 HTML5 Canvas 元素
- en: 'A `canvas` is a rectangular element in your web page where your 3D scene will
    be rendered. Let''s create a web page and add a HTML5 `canvas` element:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas` 是网页中的一个矩形元素，你的 3D 场景将在其中渲染。让我们创建一个网页并添加一个 HTML5 `canvas` 元素：'
- en: 'Using your favorite editor, create a web page with the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器，创建一个包含以下代码的网页：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the file as `ch01_01_canvas.html`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为 `ch01_01_canvas.html`。
- en: Open it with a supported browser.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用支持的浏览器打开它。
- en: 'You should see something similar to the following screenshot:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下截图类似的内容：
- en: '![](img/5b67f2ff-df20-4e1d-b7ed-56d1b62cc618.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b67f2ff-df20-4e1d-b7ed-56d1b62cc618.png)'
- en: '***What just happened? ***'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We created a simple web page containing a `canvas` element. This `canvas` will
    contain our 3D application. Let's go very quickly over some relevant elements
    presented in this example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含 `canvas` 元素的基本网页。这个 `canvas` 将包含我们的 3D 应用程序。让我们快速浏览一下这个例子中展示的相关元素。
- en: Defining a CSS Style
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 CSS 样式
- en: 'This is the piece of code that determines the `canvas` style:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是确定 `canvas` 样式的代码片段：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code is not fundamental to build a WebGL application. Given that the `canvas`
    element is initially empty, a blue-dotted border is a simple way to verify the
    location of the `canvas`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不是构建 WebGL 应用程序的基本部分。鉴于 `canvas` 元素最初是空的，一个蓝色的虚线边框是验证 `canvas` 位置的一种简单方法。
- en: Understanding Canvas Attributes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Canvas 属性
- en: 'There are three attributes in our previous example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，有三个属性：
- en: '`id`: This is the `canvas` identifier in the DOM.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是 DOM 中的 `canvas` 标识符。'
- en: '`width` and `height`: These two attributes determine the size of our `canvas`
    element. When these two attributes are missing, Firefox, Chrome, and WebKit will
    default to using `300px` by `150px`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`和`height`：这两个属性决定了我们的`canvas`元素的大小。当这两个属性缺失时，Firefox、Chrome和WebKit将默认使用`300px`宽度和`150px`高度。'
- en: What If Canvas Is Not Supported?
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果不支持Canvas怎么办？
- en: If you see the following message on your screen, Your browser does not support
    the HTML5 canvas element (which is the message between the `<canvas>` tags), you
    need to make sure that you're using one of the supported web browsers described
    earlier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你屏幕上出现以下消息，`Your browser does not support the HTML5 canvas element`（这是`<canvas>`标签之间的消息），你需要确保你使用的是之前描述的支持的Web浏览器之一。
- en: If you're using Firefox and you still see this message, you may want to check
    whether WebGL is enabled (it is by *default*). To do so, go to Firefox and type `about:config` in
    the address bar. Then, look for the `webgl.disabled` property. If it is set to `true`,
    change it to `false`. When you restart Firefox and load `ch01_01_canvas.html`,
    you should be able to see the dotted border of the `canvas` element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Firefox并且仍然看到这个消息，你可能需要检查WebGL是否已启用（默认情况下是启用的）。要做到这一点，请转到Firefox并在地址栏中输入`about:config`。然后，查找`webgl.disabled`属性。如果它设置为`true`，将其更改为`false`。当你重新启动Firefox并加载`ch01_01_canvas.html`时，你应该能够看到`canvas`元素的虚线边框。
- en: In the remote case that you still do not see `canvas`, it could be because your
    browser has blacklisted your GPU. If this is the case, please use a system with
    the appropriate hardware.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果你仍然看不到`canvas`，可能是因为你的浏览器已经将你的GPU列入了黑名单。如果是这种情况，请使用具有适当硬件的系统。
- en: 'Time for Action: Accessing the WebGL Context'
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：访问 WebGL 上下文
- en: A WebGL context is a handle (more strictly a JavaScript object) through which
    we can access WebGL functions and attributes. These available features constitute
    the WebGL API.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL上下文是一个句柄（更严格地说是一个JavaScript对象），通过它可以访问WebGL函数和属性。这些可用的功能构成了WebGL API。
- en: We are going to create a JavaScript function that will check whether a WebGL
    context can be obtained. Unlike other technologies that need to be downloaded
    into your project, WebGL is *already in your browser*. In other words, if you
    are using one of the supported browsers, you don't need to install or include
    any library.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个JavaScript函数，用于检查是否可以获取WebGL上下文。与其他需要下载到项目中的技术不同，WebGL已经存在于你的浏览器中。换句话说，如果你使用的是支持的浏览器之一，你不需要安装或包含任何库。
- en: 'Let''s modify the previous example to add a JavaScript function to check the
    WebGL availability in your browser. This function is going to be called when the
    page has loaded. For this, we will use the standard DOM `onload` event:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的示例，添加一个JavaScript函数来检查浏览器中的WebGL可用性。这个函数将在页面加载时被调用。为此，我们将使用标准的DOM`onload`事件：
- en: Open the `ch01_01_canvas.html` file in your favorite text editor.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的文本编辑器中打开`ch01_01_canvas.html`文件。
- en: 'Add the following code right below the closing `<style>` tag:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<style>`标签的关闭标签下面添加以下代码：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the file as `ch01_02_context.html`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为`ch01_02_context.html`。
- en: Open the `ch01_02_context.html` file using one of the WebGL 2 supported browsers.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用支持WebGL 2的浏览器打开`ch01_02_context.html`文件。
- en: 'If you can run WebGL 2, you will see a dialog similar to the following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你可以运行WebGL 2，你将看到一个类似于以下对话框的界面：
- en: '![](img/507c43b1-14d5-4db6-b33a-2b3b5459ad76.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/507c43b1-14d5-4db6-b33a-2b3b5459ad76.png)'
- en: Strict Mode
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式
- en: The Strict Mode, declared by `'use strict';`, is a feature that allows you to
    place a program, or a function, in a "strict" operating context. This strict context
    prevents certain actions from being taken and throws more exceptions. For more
    information, please visit the following link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`'use strict';`声明的严格模式是一种特性，它允许你将程序或函数置于一个“严格”的操作环境中。这种严格环境阻止某些操作被执行，并抛出更多的异常。更多信息请访问以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。
- en: '***What just happened? ***'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么事？***'
- en: 'Assigning a JavaScript variable (`gl`), we obtained a reference to a WebGL
    context. Let''s go back and check the code that allows accessing WebGL:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分配一个 JavaScript 变量（`gl`），我们获得了对 WebGL 上下文的引用。让我们回到代码中，检查允许访问 WebGL 的代码：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `canvas.getContext` method gives us access to WebGL. `getContext` also provides
    access to the HTML5 2D graphics library when using `2D` as the context name. The
    HTML5 2D graphics API is completely independent from WebGL and is beyond the scope
    of this book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas.getContext`方法让我们访问WebGL。当使用`2D`作为上下文名称时，`getContext`也提供了对HTML5 2D图形库的访问。HTML5
    2D图形API完全独立于WebGL，并且超出了本书的范围。'
- en: State Machine
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态机
- en: 'A WebGL context can be understood as a state machine: once you modify attributes,
    the modifications persist until later modifications. At any point, you can query
    the state of these attributes to determine the current state of your WebGL context.
    Let''s analyze this behavior with an example.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个WebGL上下文可以被理解为一个状态机：一旦你修改了属性，这些修改将保持直到后续的修改。在任何时候，你都可以查询这些属性的当前状态以确定你的WebGL上下文的当前状态。让我们用一个例子来分析这种行为。
- en: 'Time for Action: Setting up WebGL Context Attributes'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践时间：设置WebGL上下文属性
- en: 'In this example, we are going to learn to modify the color we use to clear
    the `canvas` element:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何修改我们用于清除`canvas`元素的色彩：
- en: 'Using your favorite text editor, open the `ch01_03_attributes.html` file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器打开`ch01_03_attributes.html`文件：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will see that this file is similar to our previous example. However, there
    are new code constructs that we will explain briefly. This file contains three
    JavaScript functions:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到这个文件与我们的前一个例子类似。然而，这里有一些新的代码结构，我们将简要解释。这个文件包含三个JavaScript函数：
- en: '| **Function** | **Description** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `updateClearColor` | Updates `clearColor` and then sets the `canvas` element clear
    color, which is one of the WebGL context attributes. As previously mentioned,
    WebGL works as a state machine. Therefore, it will maintain this color until it''s
    changed using the `gl.clearColor` WebGL function (see the `checkKey` source code).
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `updateClearColor` | 更新`clearColor`并设置`canvas`元素的清除颜色，这是WebGL上下文的一个属性。如前所述，WebGL作为一个状态机工作。因此，它将保持这个颜色，直到使用`gl.clearColor`
    WebGL函数（参见`checkKey`源代码）来改变它。|'
- en: '| `checkKey` | This is an auxiliary function that has been attached to the
    window `onkeydown` event. It captures the keyboard input and executes code depending
    on the key entered. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `checkKey` | 这是一个附加到窗口`onkeydown`事件的辅助函数。它捕获键盘输入并根据输入的键执行代码。|'
- en: '| `init` | This function gets called on the document `onload` event. It obtains
    a WebGL context and sets it to the global `gl` variable. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `init` | 这个函数在文档的`onload`事件中被调用。它获取一个WebGL上下文并将其设置为全局的`gl`变量。|'
- en: Open the `ch01_03_attributes.html` file in your browser.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`ch01_03_attributes.html`文件。
- en: Press *1*. You will see how the `canvas` changes its color to green. If you
    want to query the exact color used, press *4*.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*1*。你会看到`canvas`的颜色变成了绿色。如果你想查询使用的确切颜色，请按*4*。
- en: The `canvas` element will maintain the green color until we change it by calling `gl.clearColor`.
    Let's change it by pressing 2\. If you look at the source code, this will change
    the `canvas` clear color to blue. If you want to know the exact color, press 4.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`canvas`元素将保持绿色，直到我们通过调用`gl.clearColor`来改变它。让我们通过按2来改变它。如果你查看源代码，这将把`canvas`清除颜色改为蓝色。如果你想了解确切的颜色，请按4。'
- en: You can press *3*to set the clear color to a random color. As before, you can
    get the color by pressing *4**:*
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以按*3*来将清除颜色设置为随机颜色。和之前一样，你可以通过按*4*来获取颜色：*
- en: '![](img/1dccfec1-da9e-4bda-bf30-ee51d860a267.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dccfec1-da9e-4bda-bf30-ee51d860a267.png)'
- en: '***What just happened?***'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: In this example, we saw that we can change the color that WebGL uses to clear
    the `canvas` element by calling the `clearColor` function. Correspondingly, we
    used `getParameter(gl.COLOR_CLEAR_VALUE)` to obtain the current value of the `canvas`
    clear color.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了我们可以通过调用`clearColor`函数来改变WebGL用于清除`canvas`元素的色彩。相应地，我们使用`getParameter(gl.COLOR_CLEAR_VALUE)`来获取当前`canvas`清除色彩的值。
- en: Throughout this book, we will encounter similar constructs where specific functions
    establish attributes of the WebGL context while the `getParameter` function retrieves
    the current values for such attributes whenever the respective argument (in our
    example, `COLOR_CLEAR_VALUE`) is used.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将遇到类似的构造，其中特定的函数会设置WebGL上下文的属性，而`getParameter`函数会在使用相应的参数（在我们的例子中是`COLOR_CLEAR_VALUE`）时检索这些属性的当前值。
- en: Using the Context to Access the WebGL API
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文访问WebGL API
- en: It is essential to note that all of the WebGL functions are accessed through
    the WebGL context. In our examples, the context is being held by the `gl` variable.
    Therefore, any call to the WebGL API will be performed using this variable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，所有WebGL函数都是通过WebGL上下文访问的。在我们的示例中，上下文是由`gl`变量持有的。因此，对WebGL API的任何调用都将使用这个变量执行。
- en: Loading a 3D Scene
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载3D场景
- en: So far, we have seen how to set up a `canvas` element and how to obtain a WebGL
    context; the next step is to discuss objects, lights, and cameras. But why wait
    to see what WebGL can do? In this section, we will take a quick peek at a simplified
    version of the final WebGL application that we'll be building in this book.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何设置`canvas`元素以及如何获取WebGL上下文；下一步是讨论对象、灯光和相机。但为什么要等待看到WebGL能做什么呢？在本节中，我们将快速浏览一下本书将要构建的最终WebGL应用程序的简化版本。
- en: Virtual Car Showroom
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟汽车展厅
- en: Through this book, we will develop a virtual car showroom application using
    WebGL. At this point, we will load one simple scene into the `canvas` element.
    This scene will contain a car, some lights, and a camera.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这本书，我们将使用WebGL开发一个虚拟汽车展厅应用程序。在这个阶段，我们将一个简单的场景加载到`canvas`元素中。这个场景将包含一辆车、一些灯光和一个相机。
- en: 'Time for Action: Visualizing a 3D Showroom'
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：可视化3D展厅
- en: 'Once you finish reading this book, you will be able to create compelling 3D
    scenes such as the one we are going to play with next. This scene showcases one
    of the cars from this book''s virtual car showroom:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 读完这本书后，您将能够创建像我们接下来将要玩的那样引人入胜的3D场景。这个场景展示了本书虚拟汽车展厅中的一辆汽车：
- en: Open the `ch01_04_showroom.html` file in your browser.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`ch01_04_showroom.html`文件。
- en: 'You will see a WebGL scene with a car in it, as shown in the following screenshot.
    In the following chapters, we will cover geometry rendering and will see how to
    load and render various 3D models:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个包含汽车的WebGL场景，如下面的截图所示。在接下来的章节中，我们将介绍几何渲染，并了解如何加载和渲染各种3D模型：
- en: '![](img/c3ee1235-04f7-45e7-be3d-02a71bf74ef7.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c3ee1235-04f7-45e7-be3d-02a71bf74ef7.png)'
- en: 'Use the sliders to interactively update the four light sources that have been
    defined for this scene. Each light source has two elements: diffuse and specular
    elements. We have [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml), *Lights*, dedicated
    entirely to lights in a 3D scene.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用滑块来交互式地更新为这个场景定义的四个光源。每个光源有两个元素：漫反射元素和镜面元素。我们已经在[第3章](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml)，*灯光*，中完全介绍了3D场景中的灯光。
- en: Click and drag on `canvas` to rotate the car and visualize it from different
    perspectives. You can zoom by pressing the *Alt*key while dragging the mouse on
    the `canvas`. You can also use the *arrow *keys to rotate the camera around the
    car. Make sure that `canvas` is in focus by clicking on it before using the *arrow*
    keys. In [Chapter 4](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml), *Cameras*, we
    will discuss how to create and operate our own custom cameras in WebGL.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`canvas`上点击并拖动以旋转汽车并从不同的角度可视化它。您可以通过按住*Alt*键并在`canvas`上拖动鼠标来缩放。您还可以使用*箭头*键围绕汽车旋转相机。在使用*箭头*键之前，请确保点击`canvas`以使其获得焦点。在[第4章](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml)，*相机*中，我们将讨论如何在WebGL中创建和操作我们自己的自定义相机。
- en: Use the color selector widget to change the color of the car. The use of colors
    in the scene will be discussed in detail later in this book.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用颜色选择器小部件来改变汽车的颜色。本书稍后将对场景中颜色的使用进行详细讨论。
- en: '***What just happened?***'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: 'We have loaded a simple scene in a browser using WebGL. This scene consists
    of the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用WebGL在浏览器中加载了一个简单的场景。这个场景由以下内容组成：
- en: A `canvas`elementthrough which we see the scene.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个`canvas`元素，我们看到了场景。
- en: 'A series of polygonal meshes (**objects**) that constitute the car: roof, windows,
    headlights, fenders, doors, wheels, spoiler, bumpers, and so on.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列多边形网格（**对象**），它们构成了汽车：车顶、窗户、车灯、保险杠、车门、车轮、尾翼、保险杠等。
- en: '**Light **sources, otherwise everything would appear black.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灯光**源，否则一切都将显得漆黑。'
- en: A **camera **that determines where our viewpoint is in the 3D world. This camera
    is interactive where the viewpoint can change, depending on user input. For example,
    we used various keys and the mouse to move the camera around the car.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**相机**，它决定了我们在3D世界中的视点。这个相机是交互式的，视点可以根据用户输入而改变。例如，我们使用了各种键和鼠标来移动相机。
- en: There are many other elements in this scene such as textures, colors, and special
    light effects (specularity). Do not panic! We will explain each element throughout
    this book. The point here is to identify that the four basic elements we discussed
    previously are present in the scene. That said, feel free to examine the source
    code to get a sense of what's to come.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中还有许多其他元素，如纹理、颜色和特殊的光效（如镜面反射）。不要慌张！我们将在这本书的整个过程中解释每个元素。这里的关键是要识别出我们之前讨论的四个基本元素都存在于场景中。因此，您可以自由地检查源代码，以了解接下来会发生什么。
- en: Architecture Updates
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构更新
- en: As we progress through chapters, we will encounter common functionality (for
    example, design patterns, utility functions, helpers, and data structures) that
    we can build upon. Not only this will serve us in writing **DRY** code, but it
    will also provide a useful architecture to support an advanced 3D WebGL application
    by the end of this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入各个章节，我们将遇到一些常见功能（例如，设计模式、实用函数、辅助函数和数据结构），我们可以在此基础上构建。这不仅将帮助我们编写**DRY**（Don't
    Repeat Yourself，不要重复自己）的代码，而且还将提供一个有用的架构，以支持本书结束时的高级3D WebGL应用程序。
- en: DRY**Don't Repeat Yourself** (**DRY**) is a software development principle,
    the main aim of which is to reduce repetition of code. **Write Everything Twice**
    (**WET**) is a cheeky abbreviation to mean the opposite— code that doesn't adhere
    to the DRY principle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**DRY**（Don''t Repeat Yourself，不要重复自己）是一种软件开发原则，其主要目的是减少代码的重复。**WET**（Write
    Everything Twice，一切都要写两次）是一个俏皮的缩写，表示相反的意思——不遵循DRY原则的代码。'
- en: 'Let''s cover some changes that we will use in future chapters:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一些将在未来章节中使用的更改：
- en: Open `common/js/utils.js` in your editor to see the following code.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开 `common/js/utils.js` 以查看以下代码。
- en: 'We will use `utils` to include many of the utility functions to serve us in
    building our 3D application. The two methods, `getCanvas` and `getGLContent`, inside
    of `utils` are similar to the code we''ve implemented earlier in this chapter:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `utils` 包含许多实用函数，以帮助我们构建我们的3D应用程序。`utils` 中的两个方法，`getCanvas` 和 `getGLContent`，与本章早期实现的方法类似：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`getCanvas` returns the `canvas` element with the provided `id` as the argument.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getCanvas` 返回具有提供的 `id` 作为参数的 `canvas` 元素。'
- en: '`getGLContext` returns a WebGL 2 context for a given `canvas` element.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getGLContext` 为给定的 `canvas` 元素返回一个 WebGL 2 上下文。'
- en: Open up `ch01_05_attributes-final.html` in your editor to see the following
    changes.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开 `ch01_05_attributes-final.html` 以查看以下更改。
- en: We've included `<link rel="stylesheet" href="/common/lib/normalize.css">` in
    the `<head>` of our document that resets many of the inconsistencies across browsers.
    This is an external library to help us normalize CSS styling across browsers.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在文档的 `<head>` 中包含了 `<link rel="stylesheet" href="/common/lib/normalize.css">`，以重置浏览器之间的许多不一致性。这是一个外部库，帮助我们跨浏览器标准化CSS样式。
- en: We've included `<script type="text/javascript" src="img/utils.js"></script>`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经包含了 `<script type="text/javascript" src="img/utils.js"></script>`。
- en: 'Scroll to the `init` function where the necessary changes were made to use
    the `utils.getCanvas` and `utils.getGLContext` functions:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 `init` 函数，其中进行了必要的更改以使用 `utils.getCanvas` 和 `utils.getGLContext` 函数：
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open up `ch01_05_attributes-final.html` in a browser to see these changes in
    action.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `ch01_05_attributes-final.html` 以查看这些更改的实际效果。
- en: '**Example Code Structure** All example code has been structured so that common
    functionality is at the root of the directory ( `common/`), while examples for
    each chapter are categorized under chapter directories (for example, `ch01/`,
    `ch02/`, and `ch03/`). That being said, to view these examples in your browser,
    you will need to start a server at the root of the directory to load all required
    assets for each example. Please refer to the [Preface](0761b7b6-811c-41b8-8345-601dfb43747e.xhtml) of
    this book for more details.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码结构** 所有示例代码都按照常见功能位于目录根目录（`common/`）中，而每个章节的示例则分类在章节目录下（例如，`ch01/`、`ch02/`
    和 `ch03/`）。也就是说，为了在浏览器中查看这些示例，您需要在目录根目录启动一个服务器，以加载每个示例所需的所有资源。请参阅本书的[前言](0761b7b6-811c-41b8-8345-601dfb43747e.xhtml)以获取更多详细信息。'
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Let''s summarize what we''ve learned in this chapter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所学的内容：
- en: We covered the history of WebGL and how it came to fruition.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了WebGL的历史以及它是如何实现的。
- en: We learned about common elements—`canvas`, objects, lights, and camera—that
    are, generally, present in WebGL applications.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了常见元素——`canvas`、对象、灯光和相机——它们通常存在于WebGL应用程序中。
- en: We learned how to add a HTML5 `canvas` element to our web page and how to set
    its `id`, `width`, and `height`.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何将HTML5 `canvas` 元素添加到我们的网页中，以及如何设置其 `id`、`width` 和 `height`。
- en: We implemented the code to obtain a WebGL context.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了获取WebGL上下文的代码。
- en: We covered how WebGL works as a state machine and, as such, we can query any
    of its variables using the `getParameter` function.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了WebGL作为状态机的工作原理，并且因此我们可以使用 `getParameter` 函数查询其任何变量。
- en: We got a glimpse of the interactive 3D application that we'll build by the end
    of this book.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提前看到了这本书结束时我们将构建的交互式3D应用程序。
- en: In the next chapter, we will learn how to define, load, and render objects into
    a WebGL scene.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何定义、加载并将对象渲染到WebGL场景中。
