- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Publishing npm Packages
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布npm包
- en: Before now, our main focus has been to learn everything about improving and
    contributing to existing projects, but quite often, this is not everything. Some
    projects will need to be initiated correctly by you and one part of this process
    is to decide which packages should actually be reused.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们的主要重点是学习如何改进和为现有项目做出贡献，但往往这并不全面。一些项目需要你正确启动，这个过程的一部分是决定哪些包应该被重用。
- en: We’ve already learned that reusability in Node.js is primarily gained through
    the module system, which can be enhanced by third-party dependencies in the form
    of npm packages. In this chapter, you’ll learn how you can publish npm packages
    yourself. This way, a functionality implemented once can be shared among the team
    working on the same project or with anyone.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，在Node.js中，可重用性主要通过模块系统获得，这可以通过npm包形式的第三方依赖来增强。在本章中，你将学习如何自己发布npm包。这样，一旦实现的功能就可以在同一个项目工作的团队或任何人之间共享。
- en: To achieve our goal in this chapter, first, we’ll set up a simple library to
    serve our case well. Then, we publish this library to the official npm registry
    in a way that makes the code available to any Node.js developer. If you want to
    keep your library a bit less exposed, then the following sections will be interesting
    for you. In these, you will first learn how to select other registries before
    you actually select a local registry to use for publishing and installation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现本章的目标，首先，我们将设置一个简单的库来很好地服务于我们的案例。然后，我们将以使代码对任何Node.js开发者都可用的方式将此库发布到官方npm注册库。如果你想让你的库稍微不那么公开，那么以下章节对你来说将很有趣。在这些章节中，你将首先学习如何在实际选择用于发布和安装的本地注册库之前选择其他注册库。
- en: 'Finally, we’ll also look at ways to broaden the scope of our library – by making
    it **isomorphic** or exposing it as a tool. In summary, we’ll cover the following
    key topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将探讨扩大我们库范围的方法——通过使其**同构**或将其作为工具公开。总之，本章将涵盖以下关键主题：
- en: Publishing to the official registry
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到官方注册库
- en: Selecting another npm registry via `.npmrc`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`.npmrc`选择另一个npm注册库
- en: Setting up Verdaccio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Verdaccio
- en: Writing isomorphic libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写同构库
- en: Publishing a cross-platform tool
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布跨平台工具
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter08](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter08).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可在[https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter08](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter08)找到。
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3UmhN4B](https://bit.ly/3UmhN4B).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可通过[https://bit.ly/3UmhN4B](https://bit.ly/3UmhN4B)访问。
- en: Publishing to the official registry
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布到官方注册库
- en: Let’s start by creating a small library that uses a structure that can be seen
    very often in Node.js projects. The structure consists of an `src` folder, where
    the original sources are located, and a `lib` folder, containing the output to
    be used by the target system. The target system could either be something such
    as a bundler for browser applications or a specific version of Node.js.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个小型库开始，这个库使用的是在Node.js项目中非常常见的结构。该结构包括一个`src`文件夹，其中包含原始源代码，以及一个`lib`文件夹，其中包含用于目标系统的输出。目标系统可以是浏览器应用程序的打包器或Node.js的特定版本。
- en: 'To initialize this kind of project, we can use the `npm` command-line utility
    as we did before:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化此类项目，我们可以使用之前使用过的`npm`命令行工具：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we’ll set everything up. First, we will install `esbuild` as a development
    dependency. This can be very helpful for transforming our source files into usable
    library files:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置一切。首先，我们将安装`esbuild`作为开发依赖项。这可以帮助我们将源文件转换为可用的库文件：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we change `package.json` to fit our needs:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`package.json`以适应我们的需求：
- en: package.json
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Importantly, replace the chosen placeholder’s name (`florian-rappl` in the `name`
    field and `Florian Rappl` in the `author` field) with your name. For the `name`
    field, make sure to only use letters allowed for package name identifiers. Also,
    feel free to change the selected license.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，将所选占位符的名称（`name`字段中的`florian-rappl`和`author`字段中的`Florian Rappl`）替换为你的名字。对于`name`字段，请确保只使用允许用于包名称标识符的字母。你也可以随意更改所选许可证。
- en: Licenses
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证
- en: An important piece of information in every `package.json` is the `license` field.
    While the MIT License is a very good choice for many open-source projects, it
    is by no means the only one. Other popular choices include the Apache License
    2.0, BSD 3-Clause, and the ISC License.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`package.json`文件中的一项重要信息是`license`字段。虽然MIT许可证对于许多开源项目来说是一个非常好的选择，但它绝不是唯一的选择。其他流行的选择包括Apache
    License 2.0、BSD 3-Clause和ISC许可证。
- en: 'Now, we’ll add some content to our source file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的源文件中添加一些内容：
- en: src/index.js
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: src/index.js
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This file was written in a way that makes sense for us as developers, but cannot
    be run by Node.js directly. The problem is twofold. First, we are using ESM syntax
    without guaranteeing that Node.js supports this. Second, we are mixing ESM constructs
    such as `import` and `export` with CommonJS constructs such as `__dirname`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是以对我们开发者有意义的方式编写的，但不能直接由Node.js运行。问题有两个方面。首先，我们使用了ESM语法，但没有保证Node.js支持它。其次，我们混合了ESM结构，如`import`和`export`，以及CommonJS结构，如`__dirname`。
- en: 'Luckily, we already installed `esbuild` to take care of this, with the defined
    `build` script actually using it for convenience:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已安装了`esbuild`来处理这个问题，定义的`build`脚本实际上使用了它以便于操作：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, we have two directories in our project: `src`, containing the
    original sources, and `lib`, containing the CommonJS output. This is also reflected
    in `package.json`, where the source field points to `src/index.js` and the `main`
    field points to `lib/index.js`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的项目中已有两个目录：`src`，包含原始源代码，以及`lib`，包含CommonJS输出。这一点也在`package.json`文件中得到了体现，其中源字段指向`src/index.js`，而`main`字段指向`lib/index.js`。
- en: 'Just as a reminder: the `main` field tells Node.js what module to use in case
    the package is included via `require` – for example, `require(''lib-test-florian-rappl'')`
    would reference and evaluate the `lib/index.js` file.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 就此提醒一下：`main`字段告诉Node.js在通过`require`包含包时应使用哪个模块 – 例如，`require('lib-test-florian-rappl')`将引用并评估`lib/index.js`文件。
- en: 'Let’s say you want to publish this package now to the official npm registry.
    For this, you first need an account on [npmjs.com/signup](https://npmjs.com/signup).
    Once successfully registered and logged in, you should see a view similar to that
    in *Figure 8**.1*:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你现在想将这个包发布到官方npm注册库。为此，你首先需要在[npmjs.com/signup](https://npmjs.com/signup)上创建一个账户。一旦成功注册并登录，你应该会看到一个类似于*图8.1*的视图：
- en: '![Figure 8.1 – The view on npmjs.com once logged in ](img/Figure_8.1_B18989.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 登录npmjs.com后的视图](img/Figure_8.1_B18989.jpg)'
- en: Figure 8.1 – The view on npmjs.com once logged in
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 登录npmjs.com后的视图
- en: 'On your own machine, you can now authenticate to the official npm registry
    by running the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的机器上，你现在可以通过运行以下命令来认证官方npm注册库：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will request your username and password. Alternatively, you could authenticate
    using so-called access tokens. This is especially useful for scripts, such as
    automation running in a CI/CD pipeline. To generate a new access token, follow
    the link highlighted in *Figure 8**.1*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求你输入用户名和密码。或者，你也可以使用所谓的访问令牌进行认证。这对于脚本特别有用，例如在CI/CD管道中运行的自动化脚本。要生成一个新的访问令牌，请点击*图8.1*中突出显示的链接。
- en: 'Now that you have authenticated the `npm` utility, you can go ahead and publish
    your package:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经认证了`npm`工具，你可以继续发布你的包：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will package your project as a compressed archive. Then, the utility will
    upload the tarball to the official npm registry.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把你的项目打包成一个压缩归档。然后，该工具将把tarball上传到官方npm注册库。
- en: 'Now, you can go to [npmjs.com](https://npmjs.com) to look for your package
    name. You should see the package info page similar to *Figure 8**.2* with more
    details about the published package. Note that we did not include a `README.md`
    or any keywords:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以前往[npmjs.com](https://npmjs.com)查找你的包名。你应该会看到一个类似于*图8.2*的包信息页面，其中包含更多关于已发布包的详细信息。请注意，我们没有包含`README.md`或任何关键词：
- en: '![Figure 8.2 – The details of the published package ](img/Figure_8.2_B18989.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 已发布包的详细信息](img/Figure_8.2_B18989.jpg)'
- en: Figure 8.2 – The details of the published package
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 已发布包的详细信息
- en: One thing that you might consider is to give your package a scope. When you
    publish a package with a scope, then you’ll need to configure the access settings
    of the package. By default, non-scoped packages are public, and scoped packages
    are private.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能考虑的事情之一是给你的包指定一个作用域。当你发布一个带有作用域的包时，你需要配置包的访问设置。默认情况下，非作用域包是公开的，而作用域包是私有的。
- en: For publishing a scoped package to the official npm registry, you’ll first need
    to be either a member or owner of an organization on the npm website. The organization
    name must match the name of the scope.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将范围包发布到官方npm注册表，你首先需要成为npm网站上某个组织的成员或所有者。组织名称必须与范围名称匹配。
- en: Package scope
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 包范围
- en: A good way to group packages is to put them in a common scope. The scope has
    to start with an “@” symbol, which is followed by the name of the scope. The rules
    for the name of the scope are identical to package names. Besides grouping packages,
    scopes can be used to place certain packages in a different registry without much
    trouble. Most importantly, scopes can be reserved on the official npm registry,
    such that only authorized accounts can publish new packages using a reserved scope.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将包分组的一个好方法是将它们放在一个公共范围内。范围必须以一个“@”符号开头，后面跟着范围名称。范围名称的规则与包名称相同。除了分组包，范围还可以用来将某些包放置在不同的注册表中而不会遇到太多麻烦。最重要的是，范围可以在官方npm注册表中保留，这样只有授权账户才能使用保留范围发布新包。
- en: 'To consistently publish a scoped package such as `@foo/bar` with public access,
    you need to modify the `package.json`. The relevant configuration is stored in
    a property called `publishConfig`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一致地发布具有公共访问权限的范围包，例如`@foo/bar`，你需要修改`package.json`。相关的配置存储在一个名为`publishConfig`的属性中：
- en: package.json
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Alternatively, the access configuration could also be set directly when using
    the `npm publish` command with the `--``access=publish` flag.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，访问配置也可以在执行带有`--access=publish`标志的`npm publish`命令时直接设置。
- en: So far, we have only discussed how we can publish something to the official
    npm registry. What about choosing some other npm registry? For this, we need to
    change the `.``npmrc` file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了如何将内容发布到官方npm注册表。那么，选择其他npm注册表怎么办？为此，我们需要更改`.npmrc`文件。
- en: Selecting another npm registry via .npmrc
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过.npmrc选择其他npm注册表
- en: To configure the behavior of npm, a special file called `.npmrc` is used. We’ve
    already briefly touched on this file in [*Chapter 3*](B18989_03.xhtml#_idTextAnchor033),
    *Choosing a Package Manager*. This file can be used not only to determine the
    source of the packages but also to define where to publish to.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置npm的行为，使用了一个特殊的文件，称为`.npmrc`。我们已经在[*第三章*](B18989_03.xhtml#_idTextAnchor033)，*选择包管理器*中简要提到了这个文件。此文件不仅可以用来确定包的来源，还可以用来定义发布的位置。
- en: 'A simple modification might look as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的修改可能看起来如下：
- en: .npmrc
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: .npmrc
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This way, all installations and publish attempts will be performed at `https://mycustomregistry.example.org`
    instead of the official registry located at `https://registry.npmjs.org`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，所有安装和发布尝试都将执行在`https://mycustomregistry.example.org`，而不是官方注册表`https://registry.npmjs.org`。
- en: Quite often, this extreme approach is unnecessary or even unwanted. Instead,
    you might only want to use another registry for a subset of the packages. In the
    most common case, the subset is already defined by a scope.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，这种极端的方法是不必要的，甚至是不受欢迎的。相反，你可能只想为包的子集使用另一个注册表。在最常见的案例中，子集已经由范围定义。
- en: 'Let’s say the `@foo` scope that we used in the previous section with the `@foo/bar`
    package should be bound to a custom registry, while all the other packages can
    still be resolved by the official one. The following `.npmrc` covers this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在上一节中使用的`@foo`范围，与`@foo/bar`包绑定到一个自定义注册表，而所有其他包仍然可以通过官方注册表解析。以下`.npmrc`涵盖了这一点：
- en: .npmrc
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: .npmrc
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While the local `.npmrc` – that is, the one adjacent to a `package.json` of
    a project – should be used to define the registries, a global `.npmrc` – located
    in your home directory – should be used to provide information regarding authentication.
    Quite often, a private registry can only be used with such authentication information:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当地`.npmrc`——即与项目`package.json`相邻的文件——应用于定义注册表，而全局`.npmrc`——位于你的主目录中——应用于提供有关认证的信息。通常，私有注册表只能与这样的认证信息一起使用：
- en: ~/.npmrc
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ~/.npmrc
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `always-auth` setting is used to tell `npm` that even `GET` requests – that
    is, requests for resolving or downloading packages – need to use the provided
    authentication.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`always-auth`设置用于告诉`npm`，即使是`GET`请求——即请求解析或下载包的请求——也需要使用提供的认证。'
- en: An easy way to test custom configuration is to roll out your own npm registry.
    A good way of doing that locally is to use the open source project **Verdaccio**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自定义配置的一个简单方法是自己搭建一个npm注册表。在本地实现这一点的不错方式是使用开源项目**Verdaccio**。
- en: Setting up Verdaccio
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Verdaccio
- en: There are a couple of commercial registry options out there. Arguably, the most
    popular option is to get a pro plan for the official npm registry. This way, you’ll
    be able to publish and manage private packages. Whatever option you pick, you
    will always have to use a cloud version for publishing your packages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前市面上有几个商业注册表选项。可以说，最受欢迎的选项是为官方 npm 注册表购买专业版。这样，你将能够发布和管理私有包。无论你选择哪种选项，你都将必须使用云版本来发布你的包。
- en: Especially for playing around with the publishing process, having a registry
    locally would be great. A great option is to leverage `npx`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在尝试发布过程时，拥有一个本地注册表会非常好。一个很好的选择是利用 `npx`。
- en: 'Let’s go for the `npx` approach:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采用 `npx` 方法：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that Verdaccio is running, you can go to the URL shown in the console.
    You should see Verdaccio’s home page as shown in *Figure 8**.3*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Verdaccio 已经运行，你可以访问控制台显示的 URL。你应该看到与 *图 8.3* 所示的 Verdaccio 的主页一样：
- en: '![Figure 8.3 – The home page of Verdaccio with publishing instructions ](img/Figure_8.3_B18989.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – Verdaccio 的主页及发布说明](img/Figure_8.3_B18989.jpg)'
- en: Figure 8.3 – The home page of Verdaccio with publishing instructions
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – Verdaccio 的主页及发布说明
- en: 'Let’s say we want to publish the package we created earlier to Verdaccio instead
    of the official npm registry. The steps we need to follow are these:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将我们之前创建的包发布到 Verdaccio 而不是官方的 npm 注册表。我们需要遵循的步骤如下：
- en: Authenticate against the new registry (in Verdaccio, you can use whatever credentials
    you’d like by default, but `npm` requires you to authenticate)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对新注册表进行身份验证（在 Verdaccio 中，默认情况下你可以使用你想要的任何凭证，但 `npm` 要求你进行身份验证）
- en: Either configure the URL to your running instance of Verdaccio via a `.npmrc`
    file or by explicitly using the `--registry` flag with the `npm` `publish` command
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置 Verdaccio 运行实例的 URL，可以通过 `.npmrc` 文件或通过在 `npm publish` 命令中显式使用 `--registry`
    标志来实现
- en: 'In practice, these two steps look as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两个步骤看起来如下：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once published, the package is also listed on the website of the Verdaccio instance
    accessible at http://localhost:4873/. This, of course, is mostly useful for testing
    out a publishing process or for speeding up npm installations with a local cache.
    Most of the time, having a local npm registry is not really necessary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布，该包也会列在可访问于 http://localhost:4873/ 的 Verdaccio 实例网站上。当然，这主要用于测试发布过程或通过本地缓存加速
    npm 安装。大多数时候，拥有本地 npm 注册表并不是真的必要。
- en: 'One question might come up at this point: how can we make sure that a published
    package can be used by most users? What requirements need to be fulfilled for
    actually using a package in a client-based application running in the browser,
    as well as in a server-based application running in Node.js?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此时可能会出现一个问题：我们如何确保发布的包可以被大多数用户使用？在客户端应用程序（在浏览器中运行）以及基于服务器的应用程序（在 Node.js 中运行）中实际使用包需要满足哪些要求？
- en: The concept of being pretty much target-independent is called being isomorphic.
    The terminology itself does not go uncriticized and some people actually prefer
    to call it universal. Having isomorphic code is great for gaining flexibility.
    Let’s see what is needed to deploy isomorphic packages.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 说是基本不受目标依赖的概念被称为同构。这个术语本身也并非没有受到批评，有些人实际上更喜欢称之为通用。拥有同构代码对于获得灵活性是非常好的。让我们看看部署同构包需要什么。
- en: Writing isomorphic libraries
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写同构库
- en: The holy grail of web development is the ability to write code not solely for
    the frontend or the backend but for both parts. Many frameworks and tools try
    to give us this capability.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发的圣杯是能够编写既适用于前端也适用于后端的代码，而不是仅适用于其中一部分。许多框架和工具试图给我们提供这种能力。
- en: To be accessible to multiple platforms, we not only need to ship multiple variants
    of our code but also only use APIs that are available on all supported platforms.
    For instance, if you want to make an HTTP request, then using `fetch` would be
    the right call for modern browsers. However, `fetch` was not available in less
    recent versions of Node.js. Therefore, you might need to solve this differently.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码能够适用于多个平台，我们不仅需要提供我们代码的多个变体，而且还需要只使用所有支持平台上都可用的 API。例如，如果你想发起一个 HTTP 请求，那么对于现代浏览器来说，使用
    `fetch` 就是一个正确的选择。然而，`fetch` 在 Node.js 的较旧版本中是不可用的。因此，你可能需要以不同的方式解决这个问题。
- en: In the case of HTTP requests, there are already isomorphic libraries available
    – that is, libraries that will just do the right thing depending on the target
    runtime. You should only depend on these libraries.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP请求的情况下，已经存在同构库——也就是说，这些库会根据目标运行时做正确的事情。你应该只依赖这些库。
- en: Isomorphic fetch
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同构fetch
- en: The HTTP request problem can be solved in many ways – that is, by choosing an
    isomorphic library such as `axios` or `isomorphic-fetch`, the issue can be delegated
    to a dependency. The advantage of this method is that we do not need to find out
    what ways we need to follow on each platform. Additionally, testing and verification
    are much simpler that way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求问题可以通过多种方式解决——也就是说，通过选择同构库，如`axios`或`isomorphic-fetch`，问题可以委托给依赖项。这种方法的优势在于我们不需要在每个平台上找出我们需要遵循的方式。此外，以这种方式进行测试和验证要简单得多。
- en: For now, we will focus on providing multiple variants. If we want to publish
    our library with support for multiple module formats – say CommonJS and ESM –
    we can do that by extending the `package.json`. Setting `type` to `module` will
    tell Node.js that the module referenced by the `main` field actually follows ESM.
    In addition, we can define all of the package’s exports explicitly – with an additional
    option to define what module to use depending on the used target platform and
    module system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于提供多个变体。如果我们想发布支持多种模块格式的库——比如说CommonJS和ESM——我们可以通过扩展`package.json`来实现。将`type`设置为`module`将告诉Node.js，由`main`字段引用的模块实际上遵循ESM。此外，我们可以明确地定义所有包的导出——还有一个额外的选项来定义根据使用的目标平台和模块系统要使用的模块。
- en: 'Let’s see an example of this kind of configuration:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种配置的一个例子：
- en: package.json
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the case of our small library, there is a significant difference between
    the browser version and the non-browser version. However, for optimization, we’ve
    used minified modules for the browser, while all other platforms including Node.js
    will resolve to non-minified modules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小型库中，浏览器版本和非浏览器版本之间存在显著差异。然而，为了优化，我们在浏览器中使用了压缩模块，而所有其他平台（包括Node.js）都将解析为非压缩模块。
- en: 'To create output suitable for CommonJS, we can use the `build` script that
    we’ve derived already:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建适合CommonJS的输出，我们可以使用我们已推导出的`build`脚本：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output for ESM is similar, but contains one important change:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ESM的输出类似，但包含一个重要的变化：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The crucial change is to avoid using the `__dirname` global variable, which
    only works in Node.js using CommonJS. Instead, we just use the current directory.
    The change is not perfect, but should get the job done.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的改变是避免使用仅在Node.js中使用CommonJS的`__dirname`全局变量，我们只需使用当前目录。这个改变并不完美，但应该能完成这项工作。
- en: 'Right now, everything seems to be well prepared – but actually, it’s not. The
    most important thing is still missing – the removal of the Node.js inbuilt package
    references. Our simple library references `fs` and `path`, but these packages
    do not exist in the browser. They would not know how to work there. Luckily, in
    this case, we have multiple solutions. The best one is arguably to replace the
    dynamic file read with a static import of the package’s `package.json`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，一切似乎都已准备就绪——但实际上并非如此。最重要的是仍然缺失——那就是移除Node.js内置的包引用。我们的简单库引用了`fs`和`path`，但这些包在浏览器中并不存在。它们不知道如何在其中工作。幸运的是，在这种情况下，我们有多个解决方案。其中最好的一个可能是用包的`package.json`的静态导入来替换动态文件读取：
- en: index.js
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: index.js
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, this kind of algorithmic change is not always possible. In the given
    scenario, we also benefit from `esbuild`’s bundle option, which will include the
    necessary parts from the referenced JSON file to produce an output file that matches
    our expectations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种算法上的改变并不总是可能的。在给定场景中，我们还从`esbuild`的捆绑选项中受益，它将包括从引用的JSON文件中必要的部分，以生成符合我们预期的输出文件。
- en: 'With these changes in mind, let’s see how the `build` scripts are defined:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些变化，让我们看看`build`脚本是如何定义的：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It makes sense to define the scripts so that they can be run independently but
    also conveniently together without much effort. In many cases, the tool you’ve
    chosen has to be configured extensively to have the desired behavior. In the case
    of our example, `esbuild` was already quite equipped for the task – everything
    that we needed could be done via the command-line options.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本定义为可以独立运行，也可以方便地一起运行，而不需要太多努力是有意义的。在许多情况下，你选择的工具需要大量配置才能达到预期的行为。在我们的例子中，`esbuild`已经为这项任务做好了充分的准备——我们需要的所有事情都可以通过命令行选项来完成。
- en: One additional case that can be covered with an npm package is to actually provide
    a tool. Ideally, these are tools to be run with Node.js making it a cross-platform
    tool. Let’s see how we can write and publish this kind of tool.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: npm 包可以覆盖的一个额外案例是实际上提供一个工具。理想情况下，这些是用于 Node.js 运行的工具，使其成为跨平台工具。让我们看看我们如何编写和发布这类工具。
- en: Publishing a cross-platform tool
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布跨平台工具
- en: Node.js would not be so powerful without its ecosystem. As we learned in [*Chapter
    1*](B18989_01.xhtml#_idTextAnchor015), *Learning the Internals of Node.js*, relying
    on the power of its ecosystem was an elementary design decision. Here, npm takes
    the leading role by defining the package metadata in `package.json`, as well as
    the installation of packages.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 没有它的生态系统，Node.js 就不会如此强大。正如我们在 [*第1章*](B18989_01.xhtml#_idTextAnchor015) 中学到的，*学习
    Node.js 的内部机制*，依赖其生态系统的力量是一个基本的设计决策。在这里，npm 通过在 `package.json` 中定义包元数据以及包的安装来扮演主导角色。
- en: During the installation of a package, a couple of things are happening. After
    the package has been downloaded, it will be copied to a target directory. For
    a local installation with `npm`, this is the `node_modules` folder. For a global
    installation with `npm`, the target will be globally available in your home directory.
    There is, however, one more thing to do. If the package contains a tool, then
    a reference to the tool will be put into a special directory, which is `node_modules/.bin`
    for a local installation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装包的过程中，会发生几件事情。在包下载完成后，它将被复制到目标目录。对于使用 `npm` 的本地安装，这是 `node_modules` 文件夹。对于使用
    `npm` 的全局安装，目标将在你的主目录中全局可用。然而，还有一件事要做。如果包包含一个工具，那么工具的引用将被放入一个特殊的目录，对于本地安装，这个目录是
    `node_modules/.bin`。
- en: 'If you go back to the code from the previous chapter, you will see that, for
    example, `jest` is available in `node_modules/.bin`. This is the same `jest` executable
    that we started with `npx`. Let’s take the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到上一章的代码，你会看到例如 `jest` 在 `node_modules/.bin` 中可用。这正是我们用 `npx` 启动的同一个 `jest`
    可执行文件。让我们看看以下内容：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can compare it to this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其比作：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both will yield the same result. The reason is that `npx` for local installation
    is just a convenient tool to avoid writing out the path. As a reminder, you should
    opt for local installations over global installations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都将产生相同的结果。原因是本地安装的 `npx` 只是一个方便的工具，用于避免写出路径。作为提醒，你应该选择本地安装而不是全局安装。
- en: npx and npm
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: npx 和 npm
- en: '`npx` is another command that comes together with the installation of npm.
    From a command perspective, `npm` is used to manage the dependencies, while `npx`
    is used to run packages. The `npm` utility also has a `run` subcommand, which
    runs commands that are defined in the `scripts` section of `package.json`, whereas
    `npx` runs commands as defined in the `bin` section of npm packages.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`npx` 是与 npm 安装一起提供的另一个命令。从命令行角度来看，`npm` 用于管理依赖项，而 `npx` 用于运行包。`npm` 工具还有一个
    `run` 子命令，它运行 `package.json` 中 `scripts` 部分定义的命令，而 `npx` 则运行 npm 包中 `bin` 部分定义的命令。'
- en: Now, the question is how can we create a package that also adds a script to
    the `.bin` folder so that it just works when installed? The answer lies in the
    `package.json` of our previous library.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们如何创建一个包，它还向 `.bin` 文件夹添加一个脚本，以便在安装后就能直接使用？答案就在我们之前库的 `package.json`
    中。
- en: 'Let’s modify `package.json` a bit:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微修改一下 `package.json`：
- en: package.json
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We added a `bin` section that defines a single script to be referenced from
    the `.bin` directory. The reference should be called `hello` and pointed to the
    `lib/hello.js` file within this package.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 `bin` 部分，它定义了一个从 `.bin` 目录引用的单个脚本。这个引用应该被称为 `hello`，并指向这个包内的 `lib/hello.js`
    文件。
- en: 'Let’s also add the script to run when `hello` is called:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个在调用 `hello` 时运行的脚本：
- en: hello.js
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: hello.js
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will essentially check whether at least one argument was given and print
    a message in the console using the last argument.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上会检查是否至少提供了一个参数，并使用最后一个参数在控制台打印一条消息。
- en: 'Let’s see the behavior when running directly via `node`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看直接通过 `node` 运行时的行为：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, the package can be published as before – for example, by choosing our
    local Verdaccio instance:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，包可以像以前一样发布——例如，通过选择我们的本地 Verdaccio 实例：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In a new project, you can now install the dependency and run the tool:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新项目中，你现在可以安装依赖项并运行工具：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With that, we have seen the most crucial aspects regarding the publishing process
    of npm packages. Let’s recap what we have learned.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经了解了 npm 包发布过程中的最关键方面。让我们回顾一下我们学到了什么。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned about what it takes to publish a package to
    an npm registry – whether it is an official or private one. You also touched on
    a commonly used npm registry in the form of Verdaccio.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经了解了将软件包发布到npm注册表所需的内容——无论是官方的还是私有的。你也接触到了一个常用的npm注册表形式，即Verdaccio。
- en: Equipped with the knowledge from this chapter, you should now be able to write
    reusable libraries that work in browser-based applications as well as in Node.js-based
    applications. You are also now capable of publishing tools that are based on Node.js.
    In a sense, these tools are just libraries with some additional fields in their
    associated package metadata.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 借助本章的知识，你现在应该能够编写可在基于浏览器的应用程序以及基于Node.js的应用程序中工作的可重用库。你也能够发布基于Node.js的工具。从某种意义上说，这些工具只是具有一些附加字段的关联包元数据中的库。
- en: In the next chapter, we will have a look at a different approach to structuring
    code – placing multiple packages in a single repository known as a monorepo.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一种不同的代码结构方法——将多个软件包放置在一个称为monorepo的单个仓库中。
