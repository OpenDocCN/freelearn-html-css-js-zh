- en: Cameras
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相机
- en: In the previous chapter, we covered the vertex shader, fragment shader, and
    ESSL to a define a lighting model in our 3D scene. In this chapter, we will leverage
    these concepts to learn more about the matrices that we have seen in the source
    code. These matrices represent transformations that, when applied to our scene,
    allow us to display and move things around. In one case, we've already used them
    to set the camera to a distance to see all the objects in our scene, and in another
    case, we've used them to spin our 3D car model.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了顶点着色器、片段着色器和ESSL来定义我们的3D场景中的光照模型。在本章中，我们将利用这些概念来深入了解我们在源代码中看到的矩阵。这些矩阵代表变换，当应用于我们的场景时，使我们能够显示和移动物体。在一种情况下，我们已经使用它们来设置相机距离以查看场景中的所有对象，在另一种情况下，我们使用它们来旋转我们的3D汽车模型。
- en: Even though we have a camera within our 3D application, there is no camera object
    in the WebGL API—only matrices. That is because having matrices instead of a camera
    object gives WebGL the flexibility to represent complex projections and animations.
    In this chapter, we will learn what these matrix transformations mean and how
    we can use them to define and operate a virtual camera.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在3D应用程序中有一个相机，但在WebGL API中没有相机对象——只有矩阵。这是因为使用矩阵而不是相机对象给WebGL提供了表示复杂投影和动画的灵活性。在本章中，我们将学习这些矩阵变换的含义以及我们如何使用它们来定义和操作虚拟相机。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Understanding the transformations that the scene undergoes from a 3D world to
    a 2D screen.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解场景从3D世界到2D屏幕所经历的变换。
- en: Learning about affine transformations.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习仿射变换。
- en: Mapping matrices to ESSL uniforms.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将矩阵映射到ESSL统一变量。
- en: Working with the Model-View and Projection matrix.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型视图和投影矩阵。
- en: Appreciating the value of the Normal matrix.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重视正交矩阵的价值。
- en: Creating a camera and using it to move around a 3D scene.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个相机并使用它来在3D场景中移动。
- en: WebGL Does Not Have Cameras
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL没有相机
- en: 'How is it that there are no cameras in a 3D computer-graphics technology? Well,
    let''s rephrase this: WebGL does not have a camera object that you can manipulate.
    However, we can assume that what we render in the `canvas` is what our camera
    captures. In this chapter, we are going to solve the problem of how to represent
    a camera in WebGL. The short answer is that we need 4x4 matrices.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在3D计算机图形技术中没有相机？好吧，让我们重新措辞：WebGL没有可以操作的相机对象。然而，我们可以假设我们在`canvas`上渲染的内容就是我们的相机捕捉到的。在本章中，我们将解决如何在WebGL中表示相机的问题。简短的答案是，我们需要4x4矩阵。
- en: 'Every time we move our camera around, we will need to update the objects according
    to the new camera position. To do this, we need to systematically process each
    vertex and apply a transformation that produces the new viewing position. Similarly,
    we need to make sure that the object normals and light directions are still consistent
    after the camera has moved. In summary, we need to analyze two different types
    of transformations: vertex (points) and normal (vectors).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们移动我们的相机时，我们都需要根据新的相机位置更新物体。为此，我们需要系统地处理每个顶点并应用一个变换，以产生新的观察位置。同样，我们还需要确保物体法线和光线方向在相机移动后仍然一致。总之，我们需要分析两种不同类型的变换：顶点（点）和法线（向量）。
- en: Vertex Transformations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点变换
- en: Objects in a WebGL scene go through different transformations before we see
    them on our screen. Each transformation is encoded by a 4x4 matrix. How do we
    multiply vertices that have three components, `(x, y, z)`, by a 4x4 matrix? The
    short answer is that we need to augment the cardinality of our tuples by one dimension.
    Each vertex will then have a fourth component called the Homogeneous coordinate.
    Let's see what they are and why they are useful.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL场景中的物体在我们看到它们在屏幕上之前会经历不同的变换。每个变换都由一个4x4矩阵编码。我们如何将具有三个分量`(x, y, z)`的顶点乘以一个4x4矩阵？简短的答案是，我们需要通过一个维度增加我们元组的基数。每个顶点将随后有一个第四个分量，称为齐次坐标。让我们看看它们是什么以及为什么它们是有用的。
- en: Homogeneous Coordinates
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 齐次坐标
- en: '**Homogeneous coordinates** are a key component of any computer-graphics program.
    These coordinates make it possible to represent *affine* transformations (such
    as rotation, scaling, shear, and translation) and *projective* transformations
    as 4x4 matrices.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**齐次坐标**是任何计算机图形程序的关键组成部分。这些坐标使得能够将**仿射**变换（如旋转、缩放、剪切和平移）和**投影**变换表示为4x4矩阵。'
- en: 'In Homogeneous coordinates, vertices have four components: `x`, `y`, `z`, and `w`*.*
    The first three components are the vertex coordinates in **Euclidian Space**.
    The fourth is the perspective component. The four-tuple `(x, y, z, w)` take us
    to a new space: the **Projective Space**.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在齐次坐标中，顶点有四个分量：`x`、`y`、`z`和`w`**。前三个分量是顶点在**欧几里得空间**中的坐标。第四个是透视分量。四元组`(x, y,
    z, w)`带我们进入一个新的空间：**射影空间**。
- en: 'Homogeneous coordinates make it possible to solve a system of linear equations
    where each equation represents a line that is parallel with all the others in
    the system. Remember that in Euclidian Space, a system like that does not have
    solutions, because there are no intersections. However, in Projective Space, this
    system has a solution—the lines will intersect at infinity. This fact is represented
    by the perspective component having a value of `0`. A good analogy of this idea
    is the image of train tracks: parallel lines that converge at the vanishing point
    when you look at them in the distance:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 齐次坐标使得解决一个线性方程组成为可能，其中每个方程代表一条与系统中所有其他线平行的线。记住，在欧几里得空间中，这样的系统没有解，因为没有交点。然而，在射影空间中，这个系统有一个解——这些线将在无穷远处相交。这个事实由透视分量具有`0`值来表示。这个想法的一个很好的类比是火车轨道的图像：当你从远处看时，平行线会在消失点相交：
- en: '![](img/aaaad883-8a76-4af7-bb65-2e4fe9fef713.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaaad883-8a76-4af7-bb65-2e4fe9fef713.png)'
- en: 'It''s easy to convert from Homogeneous coordinates to non-Homogeneous, old-fashioned,
    Euclidean coordinates. All you need to do is divide the coordinate by `w`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从齐次坐标转换到非齐次、传统的欧几里得坐标很容易。你只需要将坐标除以`w`：
- en: 'Consequently, if you want to go from Euclidean to Projective space, you add
    the fourth component, `w`, and make it `1`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你要从欧几里得空间转换到射影空间，你需要添加第四个分量，即`w`，并将其设置为`1`：
- en: 'In fact, this is what we''ve been doing throughout the first three chapters
    of this book! Let''s go back to one of the shaders we discussed in the last chapter:
    the Phong vertex shader. The code looks as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这正是我们在本书的前三章中一直在做的事情！让我们回到上一章中讨论的一个着色器：Phong顶点着色器。代码如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please note that for the `aVertexPosition` attribute, which contains a vertex
    of our geometry, we create a four-tuple from the three-tuple that we receive.
    We do this with the ESSL construct, `vec4()`. ESSL knows that `aVertexPosition` is
    a `vec3` and therefore, we only need the fourth component to create a `vec4`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于包含我们几何体顶点的`aVertexPosition`属性，我们从一个三元组创建一个四元组。我们使用ESSL构造，`vec4()`来完成这个操作。ESSL知道`aVertexPosition`是一个`vec3`，因此我们只需要第四个分量来创建一个`vec4`。
- en: Coordinates Transformations
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标变换
- en: To pass from Homogeneous coordinates to Euclidean coordinates, we divide by `w`*.*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要从齐次坐标转换到欧几里得坐标，我们除以`w`**。
- en: To pass from Euclidean coordinates to Homogeneous coordinates, we add `w = 1`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要从欧几里得坐标转换到齐次坐标，我们添加`w = 1`。
- en: Homogeneous coordinates with `w = 0` represent a point at infinity.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`w = 0`的齐次坐标代表一个无穷远点。'
- en: 'There is one more thing to note about Homogeneous coordinates: while vertices
    have a Homogeneous coordinate, `w = 1`, vectors have a Homogeneous coordinate, `w
    = 0`. This is because in the Phong vertex shader, the line that processes the
    normals looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关于齐次坐标还有一点需要注意：虽然顶点有一个齐次坐标，`w = 1`，但向量有一个齐次坐标，`w = 0`。这是因为，在Phong顶点着色器中，处理法线的线看起来是这样的：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To code vertex transformations, we will use Homogeneous coordinates unless indicated
    otherwise. Now, let's see the different transformations that our geometry undergoes
    to be displayed on screen.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编码顶点变换，我们将使用齐次坐标，除非有其他说明。现在，让我们看看我们的几何体在屏幕上显示之前所经历的不同变换。
- en: Model Transform
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型变换
- en: We start our analysis from the object-coordinate system. This is the space where
    vertex coordinates are specified. If we want to translate or move objects around,
    we use a matrix that encodes these transformations. This matrix is known as the
    **Model matrix**. Once we multiply the vertices of our object by the Model matrix,
    we obtain new vertex coordinates. These new vertices will determine the position
    of the object in our 3D world.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对象坐标系开始分析。这是顶点坐标被指定的空间。如果我们想要平移或移动对象，我们使用一个编码这些变换的矩阵。这个矩阵被称为**模型矩阵**。一旦我们将对象的顶点乘以模型矩阵，我们就得到了新的顶点坐标。这些新的顶点将确定对象在我们3D世界中的位置。
- en: 'In object coordinates, each object is free to define where its origin is and
    to specify where its vertices are with respect to this origin. In world coordinates,
    the origin is shared by all of the objects. World coordinates allow us to know
    where objects are located with respect to each other. It is with the model transform
    that we determine where the objects are in the 3D world:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象坐标系中，每个对象都可以自由定义其原点的位置，并指定其顶点相对于这个原点的位置。在世界坐标系中，所有对象共享同一个原点。世界坐标使我们能够知道对象相对于彼此的位置。正是通过模型变换，我们确定对象在3D世界中的位置：
- en: '![](img/1fb7b0ee-7885-45c3-bae4-9be31fcfa2bc.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fb7b0ee-7885-45c3-bae4-9be31fcfa2bc.png)'
- en: View Transform
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图变换
- en: The next transformation, the view transform, shifts the origin of the coordinate
    system to the view origin. The view origin is where our *eye* or *camera* is located
    with respect to the world origin. In other words, the view transform switches
    world coordinates by view coordinates. This transformation is encoded in the **View
    matrix**. We multiply this matrix by the vertex coordinates obtained by the model
    transform. The result of this operation is a new set of vertex coordinates whose
    origin is the view origin. It is in this coordinate system that our camera is
    going to operate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变换，即视图变换，将坐标系的原点移动到视图原点。视图原点是我们的 *眼睛* 或 *相机* 相对于世界原点的位置。换句话说，视图变换通过视图坐标切换世界坐标。这种变换编码在 **视图矩阵** 中。我们将这个矩阵与模型变换得到的顶点坐标相乘。这个操作的结果是一组新的顶点坐标，其原点是视图原点。我们的相机将在这个坐标系中操作。
- en: '![](img/005ef6cc-2933-4bb1-9153-f40e9ec6ee5d.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/005ef6cc-2933-4bb1-9153-f40e9ec6ee5d.png)'
- en: We will return to this later in the chapter!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面回到这个话题！
- en: Projection Transform
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影变换
- en: 'The next operation is called the **projection transform**. This operation determines
    how much of the view space will be rendered and how it will be mapped onto the
    computer screen. This region is known as the **frustum** and it is defined by
    six planes (near, far, top, bottom, right, and left planes), as shown in the following
    diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个操作称为 **投影变换**。这个操作确定将渲染多少观看空间以及它将如何映射到计算机屏幕上。这个区域被称为 **几何体** ，它由六个平面（近平面、远平面、顶面、底面、右面和左面）定义，如下面的图所示：
- en: '![](img/2385e5e7-aed6-45b2-9087-7baa5b57d092.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2385e5e7-aed6-45b2-9087-7baa5b57d092.png)'
- en: These six planes are encoded in the **Projection matrix**. Any vertices lying
    outside the frustum after applying the transformation are *clipped out* and discarded
    from further processing. Therefore, the frustum *defines* clipping coordinates,
    and the Projection matrix that encodes the frustum *produces* clipping coordinates.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个平面编码在 **投影矩阵** 中。在应用变换后，任何位于几何体之外的顶点将被 *裁剪掉* 并从进一步处理中丢弃。因此，几何体 *定义* 裁剪坐标，而编码几何体的投影矩阵 *产生* 裁剪坐标。
- en: 'The shape and extent of the frustum determines the type of projection from
    the 3D viewing space to the 2D screen. If the far and near planes have the same
    dimensions, the frustum will then determine an *orthographic* projection. Otherwise,
    it will be a *perspective* projection, as shown in the following diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 几何体的形状和范围决定了从3D观看空间到2D屏幕的投影类型。如果远平面和近平面的维度相同，则几何体将决定一个 *正交* 投影。否则，它将是一个 *perspective* 投影，如下面的图所示：
- en: '![](img/5e8adaa6-e7e7-4747-9762-b2903df547a4.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e8adaa6-e7e7-4747-9762-b2903df547a4.png)'
- en: Up to this point, we are still working with Homogeneous coordinates, so the
    clipping coordinates have four components: `x`, `y`, `z`, and `w`. The clipping
    is done by comparing the `x`, `y`, and `z` components against the Homogeneous
    coordinate, `w`. If any of them is more than, `+w`, or less than, `-w`, then that
    vertex lies outside the frustum and is discarded.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仍在使用齐次坐标，因此裁剪坐标有四个分量： `x`， `y`， `z`，和 `w`。裁剪是通过比较 `x`， `y`，和 `z` 分量与齐次坐标 `w` 来完成的。如果其中任何一个大于 `+w`，或小于 `-w`，则该顶点位于几何体之外，将被丢弃。
- en: Perspective Division
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透视除法
- en: Once it has been determined how much of the viewing space will be rendered,
    the frustum is mapped into the *near plane* in order to produce a 2D image. The
    near plane is what is going to be rendered on your computer screen.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了将渲染多少观看空间，几何体就被映射到 *near plane* 以产生一个2D图像。近平面是将在您的计算机屏幕上渲染的内容。
- en: Different operative systems and displaying devices can have mechanisms to represent
    2D information on screen. To provide robustness for all possible cases, WebGL
    and OpenGL ES provide an intermediate coordinate system that is independent from
    any specific hardware. This space is known as the **Normalized Device Coordinates
    (NDC)**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的操作系统和显示设备可能有机制在屏幕上表示2D信息。为了对所有可能的情况提供鲁棒性，WebGL和OpenGL ES提供了一个独立于任何特定硬件的中间坐标系。这个空间被称为**归一化设备坐标（NDC）**。
- en: Normalized device coordinates are obtained by dividing the clipping coordinates
    by the `w` component. This is why this step is known as *perspective division*.
    Also, please remember that when we divide by the Homogeneous coordinate, we go
    from projective space (4 components) to Euclidean space (3 components), so NDC
    only has three components. In the NDC space, the `x` and `y` coordinates represent
    the location of your vertices on a normalized 2D screen, while the z-coordinate
    encodes depth information, which is the relative location of the objects with
    respect to the near and far planes. Although at this point we are working on a
    2D screen, we still keep the depth information. This will allow WebGL to later
    determine how to display overlapping objects based on their distance from the
    nearest plane. When using normalized device coordinates, the depth is encoded
    in the z-component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过除以`w`分量来获得归一化设备坐标。这就是为什么这一步被称为**透视除法**。此外，请记住，当我们除以齐次坐标时，我们是从射影空间（4个分量）到欧几里得空间（3个分量），因此NDC只有三个分量。在NDC空间中，`x`和`y`坐标代表你的顶点在归一化2D屏幕上的位置，而z坐标编码深度信息，这是物体相对于近平面和远平面的相对位置。尽管我们现在在2D屏幕上工作，但我们仍然保留深度信息。这将允许WebGL根据物体与最近平面的距离来确定如何显示重叠的物体。当使用归一化设备坐标时，深度编码在z分量中。
- en: 'The perspective division transforms the viewing frustum into a cube centered
    in the origin with the minimum coordinates of `[-1, -1, -1]` and the maximum coordinates
    of `[1, 1, 1]`. Also, the direction of the z-axis is inverted, as shown in the
    following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 透视除法将视锥体变换为中心在原点的立方体，最小坐标为`[-1, -1, -1]`，最大坐标为`[1, 1, 1]`。同时，z轴的方向被反转，如下面的图所示：
- en: '![](img/4ad69e23-68dd-4781-88f2-974d9c1b4122.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ad69e23-68dd-4781-88f2-974d9c1b4122.png)'
- en: Viewport Transform
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视口变换
- en: 'Finally, NDCs are mapped to **viewport coordinates**. This step maps these
    coordinates to the available space in your screen. In WebGL, this space is provided
    by the HTML5 `canvas`, as shown in the following diagram:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，NDC被映射到**视口坐标**。这一步将这些坐标映射到屏幕上的可用空间。在WebGL中，这个空间由HTML5 `canvas`提供，如下面的图所示：
- en: '![](img/cb84407b-0550-4cff-b474-35d21601c539.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb84407b-0550-4cff-b474-35d21601c539.png)'
- en: Unlike the previous cases, the viewport transform is not generated by a matrix
    transformation. In this case, we use the WebGL viewport function. We will learn
    more about this function later in this chapter. Now, it's time to see how these
    transformations affect normals.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的情况不同，视口变换不是由矩阵变换生成的。在这种情况下，我们使用WebGL的视口函数。我们将在本章后面更多地了解这个函数。现在，是时候看看这些变换如何影响法线了。
- en: Normal Transformations
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法线变换
- en: 'Whenever vertices are transformed, **normal vectors** should also be transformed
    so that they point in the right direction. We could consider using the Model-View
    matrix that transforms vertices to do this, but this approach is problematic:
    the Model-View matrix will not always keep the perpendicularity of normals, as
    illustrated by the following diagram:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每当顶点被变换时，**法线向量**也应该被变换，以便它们指向正确的方向。我们可以考虑使用变换顶点的模型视图矩阵来做这件事，但这种方法是有问题的：模型视图矩阵不会总是保持法线的垂直性，如下面的图所示：
- en: '![](img/df8dc082-2ebd-496e-a8a9-8eddfd3d3304.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df8dc082-2ebd-496e-a8a9-8eddfd3d3304.png)'
- en: This problem occurs if there is a unidirectional (one axis) scaling transformation
    or a shearing transformation in the Model-View matrix. In our example, we have
    a triangle that has undergone a scaling transformation on the y-axis. As you can
    see, the `N'` normal is no longer perpendicular after this kind of transformation.
    How do we solve this?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题发生在模型视图矩阵中存在单向（一个轴）缩放变换或剪切变换时。在我们的例子中，我们有一个在y轴上进行了缩放变换的三角形。正如你所见，经过这种变换后，`N'`法线不再垂直。我们该如何解决这个问题？
- en: Calculating the Normal Matrix
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算法线矩阵
- en: If you are not interested in finding out how we calculate the Normal matrix
    and just want the answer, feel free to jump to the end of this section. Otherwise,
    stick around to see some linear algebra in action!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想了解我们如何计算法线矩阵，只想得到答案，请随时跳到本节的末尾。否则，请留下来看看一些线性代数的实际应用！
- en: 'Let''s start with the mathematical definition of perpendicularity. Two vectors
    are perpendicular if their dot product is `0`. In our example, this will be:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从垂直性的数学定义开始。如果两个向量的点积为 `0`，则这两个向量是垂直的。在我们的例子中，这将如下所示：
- en: Here, *`S`* is the surface vector and can be calculated as the difference of
    two vertices, as shown in the diagram at the beginning of this section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*`S`* 是表面向量，可以计算为两个顶点的差，如本节开头所示的图表所示。
- en: 'Let *`M`* be the Model-View matrix. We can use *`M`* to transform `*S*` as
    follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *`M`* 为模型视图矩阵。我们可以使用 *`M`* 如下变换 `*S*`：
- en: This is because `*S*` is the difference of two vertices. We use `*M*` to transform
    vertices onto the viewing space.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `*S*` 是两个顶点的差。我们使用 `*M*` 来将顶点变换到视图中。
- en: 'We want to find a matrix, `*K*`, that allows us to transform normals in a similar
    way. For the `*N*` normal, we want the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要找到一个矩阵，`*K*`，它允许我们以类似的方式变换法线。对于 `*N*` 法线，我们想要以下内容：
- en: 'For the scene to be consistent after obtaining `*N''*` and `*S''*`, these two
    need to keep the perpendicularity that the original vectors `*N*` and `*S*` had.
    This is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在获得 `*N'*` 和 `*S'*` 后使场景保持一致，这两个向量需要保持原始向量 `*N*` 和 `*S*` 的垂直性。如下所示：
- en: 'Substituting `*N''*` and `*S''*`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代入 `*N'*` 和 `*S'*`：
- en: 'A dot product can also be written as a vector multiplication by transposing
    the first vector so that this still holds:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 点积也可以写成通过转置第一个向量来保持这种关系的向量乘法：
- en: 'The transpose of a product is the product of the transposes in the reverse
    order:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 乘积的转置是转置的逆序乘积：
- en: 'Grouping the inner terms:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将内部项分组：
- en: 'Now, remember that `![](img/00bae9ac-8ccb-4a47-8de1-1af208c087b6.png)` so `![](img/a116585c-c195-4728-9ab9-787eedfce48a.png)` (again,
    a dot product can be written as a vector multiplication). This means that in the
    previous equation, (`![](img/f425b4f3-3626-49fe-9a88-1c4ee7bf9967.png)`) needs
    to be the Identity matrix, `*I*`, so the original condition of `*N*` and `*S*` being
    perpendicular holds:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记住 `![](img/00bae9ac-8ccb-4a47-8de1-1af208c087b6.png)` 所以 `![](img/a116585c-c195-4728-9ab9-787eedfce48a.png)`（再次，点积可以写成向量乘法）。这意味着在之前的方程中，(`![](img/f425b4f3-3626-49fe-9a88-1c4ee7bf9967.png)`)
    需要是单位矩阵，`*I*`，因此 `*N*` 和 `*S*` 的原始垂直条件保持不变：
- en: 'Applying a bit of algebra:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应用一点代数：
- en: '| `![](img/e6602643-ef8e-4240-bc57-034d777c70e3.png)` | Multiply by the inverse
    of `*M*` on both sides. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `![图片](img/e6602643-ef8e-4240-bc57-034d777c70e3.png)` | 在两边乘以 `*M*` 的逆矩阵。|'
- en: '| `![](img/61e70e3d-b8ee-4d60-aa72-7a6524de722e.png)` | Because `![](img/81925c34-d45d-44ae-b40f-e82f8bb46d56.png)`*.*
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `![图片](img/61e70e3d-b8ee-4d60-aa72-7a6524de722e.png)` | 因为 `![图片](img/81925c34-d45d-44ae-b40f-e82f8bb46d56.png)`*.*
    |'
- en: '| `![](img/ca32723e-31ba-411f-bc04-2726d4b085f5.png)` | Transposing on both
    sides. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `![图片](img/ca32723e-31ba-411f-bc04-2726d4b085f5.png)` | 在两边进行转置。|'
- en: '| `![](img/e23e25a6-159e-49a5-8578-2f0e783bc3a0.png)` | Double transpose of `*K*` is
    the original matrix `*K*`. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `![图片](img/e23e25a6-159e-49a5-8578-2f0e783bc3a0.png)` | `*K*` 的双重转置是原始矩阵
    `*K*`。|'
- en: 'Conclusions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结论：
- en: '*`K` *is the correct matrix transform that keeps the normal vectors perpendicular
    to the surface of the object. We call `*K*` the **Normal matrix**.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`K`* 是保持法向量与物体表面垂直的正确矩阵变换。我们称 `*K*` 为**法线矩阵**。'
- en: '*`K` *is obtained by transposing the inverse of the Model-View matrix (`*M*`,
    in this example).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`K`* 是通过转置模型视图矩阵的逆矩阵 (`*M*`，在这个例子中）得到的。'
- en: We need to use *`K` *to multiply the normal vectors so that they keep being
    perpendicular to the surface when transformed.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用 *`K`* 来乘以法向量，以便在变换过程中保持它们与表面的垂直性。
- en: WebGL Implementation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL 实现
- en: 'Now, let''s take a look at how we can implement vertex and normal transformations
    in WebGL. The following diagram shows the theory we have learned so far, along
    with the relationships between the steps in the theory and the implementation
    in WebGL:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在 WebGL 中实现顶点和法线变换。以下图表显示了我们迄今为止学到的理论，以及理论步骤与 WebGL 实现之间的关系：
- en: '![](img/800122be-4528-4269-a431-5e723273c0e0.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/800122be-4528-4269-a431-5e723273c0e0.png)'
- en: 'In WebGL, the five transformations that we apply to object coordinates to obtain
    viewport coordinates are grouped into three matrices and one WebGL method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 中，我们将应用于物体坐标以获得视口坐标的五个变换组合成三个矩阵和一个 WebGL 方法：
- en: The **Model-View **matrix that groups the *model* and *view* transform in one
    single matrix. When we multiply our vertices by this matrix, we end up in view
    coordinates.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型视图矩阵** 将 *模型* 和 *视图* 变换组合在一个单一的矩阵中。当我们用这个矩阵乘以我们的顶点时，我们最终得到视图坐标。'
- en: The **Normal matrix **is obtained by inverting and transposing the Model-View
    matrix. This matrix is applied to normal vectors to ensure that they continue
    to be perpendicular to the surface. This is very important in cases such as lighting.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线矩阵** 是通过反转和转置模型视图矩阵获得的。这个矩阵应用于法线向量，以确保它们继续垂直于表面。这在例如光照的情况下非常重要。'
- en: The **Projection matrix **groups the *projection transformation* and *the perspective
    division*, and as a result, we end up in normalized device coordinates.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投影矩阵** 将 *投影变换* 和 *透视除法* 组合在一起，因此我们最终得到归一化设备坐标。'
- en: 'Finally, we use the `gl.viewport` operation to map NDCs to viewport coordinates:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `gl.viewport` 操作将 NDC 转换为视口坐标：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The viewport coordinates originate in the lower-left corner of the HTML5 `canvas`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 视口坐标起源于 HTML5 `canvas` 的左下角。
- en: JavaScript Matrices
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 矩阵
- en: The WebGL JavaScript API does not provide its own methods to perform operations
    on matrices. WebGL simply provides a way to pass matrices to the shaders (as uniforms).
    So, we need to use a JavaScript library that enables us to manipulate matrices
    in JavaScript. In this book, we have used **glMatrix** for all matrix operations.
    However, there are other libraries available online that can do this for you.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL JavaScript API 不提供自己的方法来执行矩阵操作。WebGL 只提供了一种将矩阵传递给着色器（作为 uniforms）的方式。因此，我们需要使用一个
    JavaScript 库，使我们能够用 JavaScript 操作矩阵。在这本书中，我们使用了 **glMatrix** 来执行所有矩阵操作。然而，还有其他在线库可以为你做这件事。
- en: glMatrix
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: glMatrix
- en: We used **glMatrix** for all matrix operations in this book. You can find more
    information about this library at [https://github.com/toji/gl-matrix.](https://github.com/toji/gl-matrix)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的所有矩阵操作中，我们使用了 **glMatrix**。你可以在 [https://github.com/toji/gl-matrix.](https://github.com/toji/gl-matrix)
    找到关于这个库的更多信息。
- en: 'Here are some of the operations that you can perform with **glMatrix**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以使用 **glMatrix** 执行的操作：
- en: '| **Operation** | **Syntax** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **语法** | **描述** |'
- en: '| Creation | `const m = mat4.create();` | Creates the `m` matrix. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | `const m = mat4.create();` | 创建 `m` 矩阵。|'
- en: '| Identity | `mat4.identity(m);` | Sets `m` as the Identity matrix of rank
    4. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 单位矩阵 | `mat4.identity(m);` | 将 `m` 设置为秩为 4 的单位矩阵。|'
- en: '| Copy | `mat4.copy(target, origin);` | Copies the matrix origin onto the matrix target.
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 复制 | `mat4.copy(target, origin);` | 将矩阵 `origin` 复制到矩阵 `target` 上。|'
- en: '| Transpose | `mat4.transpose(target, m);` | Transposes the `m` matrix onto
    the matrix target. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 转置 | `mat4.transpose(target, m);` | 将 `m` 矩阵转置到矩阵 `target` 上。|'
- en: '| Invert | `mat4.invert(target, m);` | Inverts `m` onto the matrix target.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 反转 | `mat4.invert(target, m);` | 将矩阵 `m` 反转到矩阵 `target` 上。|'
- en: '| Rotate | `mat4.rotate(target, m, r, a);` | Rotates the `m` matrix by `r` radians
    around the `a`  axis (this is a three-element array, `[x, y, z]`) onto the matrix target.
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 旋转 | `mat4.rotate(target, m, r, a);` | 将 `m` 矩阵绕 `a` 轴（这是一个包含三个元素的数组，`[x,
    y, z]`）旋转 `r` 弧度到矩阵 `target` 上。|'
- en: It's important to note that the **glMatrix** provides many more functions to
    perform other linear algebra operations. To get the full list, visit [http://glmatrix.net/docs/](http://glmatrix.net/docs/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，**glMatrix** 提供了许多其他函数来执行其他线性代数操作。要获取完整列表，请访问 [http://glmatrix.net/docs/](http://glmatrix.net/docs/)。
- en: Mapping JavaScript Matrices to ESSL Uniforms
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 JavaScript 矩阵映射到 ESSL Uniforms
- en: Since the Model-View and Perspective matrices do not change during a single
    rendering step, they are passed as *uniforms* to the shaders. For example, if
    we were applying a translation to an object in our scene, we would have to paint
    the whole object in the new coordinates given by the translation. Painting the
    whole object in the new position is achieved in exactly one rendering step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模型视图矩阵和透视矩阵在单个渲染步骤中不会改变，因此它们作为 *uniforms* 传递给着色器。例如，如果我们正在将平移应用于场景中的对象，我们就必须在新坐标下绘制整个对象，这些新坐标由平移给出。在新的位置绘制整个对象是通过恰好一个渲染步骤实现的。
- en: 'However, before the rendering step is invoked (by calling `drawArrays` or `drawElements`),
    we need to make sure that the shaders have an updated version of our matrices.
    We already know how to do that for other uniforms, such as light and color properties.
    The method to map JavaScript matrices to uniforms is similar to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在调用`drawArrays`或`drawElements`来调用渲染步骤之前，我们需要确保着色器有我们矩阵的更新版本。我们已经知道如何为其他uniform，如光和颜色属性，这样做。将JavaScript矩阵映射到uniform的方法与以下类似：
- en: 'Get a JavaScript reference to the uniform with the following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码获取uniform的JavaScript引用：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the reference to pass the matrix to the shader with the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码使用`reference`将矩阵传递到着色器：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As is the case for other uniforms, ESSL supports two-, three-, and four-dimensional
    matrices: `uniformMatrix[234]fv(reference, transpose, matrix)`. This will load
    2x2, 3x3, or 4x4 matrices (corresponding to 2, 3, or 4 in the command name) of
    floating points into the uniform referenced by `reference`. The type of `reference`
    is `WebGLUniformLocation`. For practical purposes, it is an integer number. According
    to the specification, the transpose value must be set to `false`. The matrix uniforms
    are always of the floating point type (`f`). The matrices are passed as `4`, `9`,
    or `16` element vectors (`v`) and are always specified in a column-major order.
    The matrix parameter can also be of the `Float32Array` type. This is one of JavaScript's
    typed arrays. These arrays are included in the language to provide access to and
    the manipulation of raw binary data, and thus increase efficiency.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他uniform，ESSL支持二维、三维和四维矩阵：`uniformMatrix[234]fv(reference, transpose, matrix)`。这将加载2x2、3x3或4x4矩阵（对应于命令名称中的2、3或4），并将浮点数矩阵加载到由`reference`引用的uniform中。`reference`的类型是`WebGLUniformLocation`。出于实际目的，它是一个整数。根据规范，转置值必须设置为`false`。矩阵uniform始终为浮点类型（`f`）。矩阵作为`4`、`9`或`16`元素向量（`v`）传递，并且始终以列主序指定。矩阵参数也可以是`Float32Array`类型。这是JavaScript的一种类型化数组。这些数组被包含在语言中，以提供对原始二进制数据的访问和处理，从而提高效率。
- en: Working with Matrices in ESSL
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ESSL中处理矩阵
- en: Let's revisit the Phong vertex shader, which was introduced in [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml),
    *Lights*. Please remember that matrices are defined as uniform `mat4`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在第3章中介绍的Phong顶点着色器，*光线*。请记住矩阵被定义为uniform `mat4`。
- en: 'In this shader, we have defined three matrices:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个着色器中，我们定义了三个矩阵：
- en: '`uModelViewMatrix`: The Model-View matrix'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uModelViewMatrix`：模型-视图矩阵'
- en: '`uProjectionMatrix`: The Projection matrix'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uProjectionMatrix`：投影矩阵'
- en: '`uNormalMatrix`: The Normal matrix'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uNormalMatrix`：法线矩阵'
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In ESSL, the multiplication of matrices is straightforward; that is, you do
    not need to multiply element by element. ESSL knows that you are working with
    matrices, so it performs the multiplications for you:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在ESSL中，矩阵的乘法很简单；也就是说，你不需要逐元素相乘。ESSL知道你正在处理矩阵，所以它会为你执行乘法：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last line of this shader assigns a value to the predefined `gl_Position` variable.
    This will contain the clipping coordinates for the vertex that is currently being
    processed by the shader. We need to remember that the shaders work in parallel:
    each vertex is processed by an instance of the vertex shader.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器的最后一行将一个值赋给了预定义的`gl_Position`变量。这将包含由着色器正在处理的顶点的裁剪坐标。我们需要记住着色器是并行工作的：每个顶点都由一个顶点着色器的实例处理。
- en: To obtain the clipping coordinates for a given vertex, we first need to multiply
    the Model-View matrix by the Projection matrix. To achieve this, we multiply from
    right to left, because matrix multiplication is not commutative and order matters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得给定顶点的裁剪坐标，我们首先需要将模型-视图矩阵与投影矩阵相乘。为了实现这一点，我们需要从右向左乘，因为矩阵乘法不是交换的，顺序很重要。
- en: Also, notice that we needed to augment the `aVertexPosition` attribute by including
    the Homogeneous coordinate. This is because we have defined our geometry in Euclidean
    space. Luckily, ESSL allows us to do this by simply adding the missing component
    and creating a `vec4` on the fly. We need to do this because both the Model-View
    matrix and the Projection matrix are described in Homogeneous coordinates (`4`
    rows by `4` columns).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们需要通过包括齐次坐标来增强`aVertexPosition`属性。这是因为我们已经在欧几里得空间中定义了我们的几何形状。幸运的是，ESSL允许我们通过简单地添加缺失的组件并在现场创建一个`vec4`来实现这一点。我们需要这样做，因为模型-视图矩阵和投影矩阵都是用齐次坐标描述的（4行4列）。
- en: 'Now that we''ve seen how to map JavaScript matrices to ESSL uniforms in our
    shaders, let''s talk about how to operate with the three matrices: the Model-View
    matrix, the Normal matrix, and the Projection matrix.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在着色器中将JavaScript矩阵映射到ESSL统一变量中，让我们谈谈如何操作这三个矩阵：模型-视图矩阵、法线矩阵和投影矩阵。
- en: The Model-View Matrix
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图矩阵
- en: The **Model-View matrix** allows us to perform *affine transformations* in our
    scene. **Affine** is a mathematical name that describes transformations that do
    *not* change the structure of the object undergoing such transformations. In our
    3D world scene, such transformations are rotation, scaling, reflection shearing,
    and translation. Fortunately, we do not need to understand how to represent such
    transformations with matrices. We just need to use one of the many JavaScript
    matrix libraries that are available online (such as **glMatrix**).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图矩阵**允许我们在场景中执行 *仿射变换*。**仿射**是一个数学术语，描述了不改变经历这种变换的对象结构的变换。在我们的3D世界场景中，这种变换包括旋转、缩放、反射剪切和平移。幸运的是，我们不需要了解如何用矩阵表示这样的变换。我们只需要使用许多可在线获得的JavaScript矩阵库之一（例如 **glMatrix**）。'
- en: Affine Transformations
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换
- en: You can find more information on how transformation matrices work at [https://en.wikipedia.org/wiki/Affine_transformation](https://en.wikipedia.org/wiki/Affine_transformation).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://en.wikipedia.org/wiki/Affine_transformation](https://en.wikipedia.org/wiki/Affine_transformation)上找到更多关于变换矩阵如何工作的信息。
- en: Understanding the structure of the Model-View matrix will not help you if you
    just want to apply transformations to the scene or to objects in the scene. For
    that effect, simply use a library, such as **glMatrix**, to do the transformations
    on your behalf. However, the structure of this matrix could be invaluable information
    when you are trying to troubleshoot your 3D application. Let's take a look at
    how the Model-View matrix is constructed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想对场景或场景中的对象应用变换，理解模型-视图矩阵的结构并不能帮助你。为此，只需使用一个库，例如 **glMatrix**，来代表你进行变换。然而，当你在尝试调试你的3D应用程序时，这个矩阵的结构可能是有价值的。让我们看看模型-视图矩阵是如何构建的。
- en: Spatial Encoding of the World
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 世界的空间编码
- en: 'By default, when you render a scene, you are looking at it from the origin
    of the world in the negative direction of the z-axis. As shown in the following
    diagram, the z-axis is coming out of the screen (which means that you''re looking
    at the negative z-axis):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你渲染一个场景时，你从世界原点沿z轴的负方向观看它。如下所示，z轴从屏幕中出来（这意味着你正在查看负z轴）：
- en: '![](img/2cbdaa70-dc4a-437e-9eee-ca17e62fa791.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cbdaa70-dc4a-437e-9eee-ca17e62fa791.png)'
- en: From the center of the screen to the right, you will have the positive x-axis,
    and from the center of the screen up, you will have the positive y-axis. This
    is the initial configuration and it is the reference for affine transformations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从屏幕中心向右，你将拥有正x轴，从屏幕中心向上，你将拥有正y轴。这是初始配置，也是仿射变换的参考。
- en: In this configuration, the Model-View matrix is the **Identity matrix** of rank
    four.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置中，模型-视图矩阵是四阶的**单位矩阵**。
- en: The first three rows of the Model-View matrix contain information about rotations
    and translations that are affecting the world.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图矩阵的前三行包含影响世界的旋转和平移信息。
- en: Rotation Matrix
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转矩阵
- en: 'The intersection of the first three rows with the first three columns defines
    the 3x3 Rotation matrix. This matrix contains information about rotations around
    the standard axis. In the initial configuration, this corresponds to the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行与前三列的交集定义了3x3的旋转矩阵。这个矩阵包含关于围绕标准轴旋转的信息。在初始配置中，这对应于以下：
- en: '`[m1, m2, m3]` = `[1, 0, 0]` = x-axis'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`[m1, m2, m3]` = `[1, 0, 0]` = x轴'
- en: '`[m5, m6, m7]` = `[0, 1, 0]` = y-axis'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`[m5, m6, m7]` = `[0, 1, 0]` = y轴'
- en: '`[m9, m10, m11]` = `[0, 0, 1]` = z-axis'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`[m9, m10, m11]` = `[0, 0, 1]` = z轴'
- en: Translation Vector
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平移向量
- en: 'The intersection of the first three rows with the last column defines a three-component
    Translation vector. This vector indicates how much the origin, and the world,
    have been translated. In the initial configuration, this corresponds to the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行与最后一列的交集定义了一个三组件的平移向量。这个向量指示原点和世界移动了多少。在初始配置中，这对应于以下：
- en: '`[m13, m14, m15]` = `[0, 0, 0]` = origin (no translation)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`[m13, m14, m15]` = `[0, 0, 0]` = 原点（无平移）'
- en: The Mysterious Fourth Row
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神秘的第四行
- en: The fourth row does not have any special meaning.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第四行没有特殊含义。
- en: The `m4`, `m8`, and `m12`elementsare always `0`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m4`、`m8`和`m12`元素始终为`0`。'
- en: The `m16`element(the Homogeneous coordinate) will always be `1`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m16`元素（齐次坐标）始终为`1`。'
- en: As we described at the beginning of this chapter, there are no cameras in WebGL.
    However, all the information that we need to operate a camera (mainly rotations
    and translations) can be extracted from the Model-View matrix itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，WebGL中没有摄像机。然而，我们需要操作摄像机的所有信息（主要是旋转和平移）都可以从模型视图矩阵本身提取出来。
- en: The Camera Matrix
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像机矩阵
- en: Let's say, for a moment, that we *do* have a camera in WebGL. A camera should
    be able to rotate and translate to explore this 3D world. As we saw in the previous
    section, a 4x4 matrix can encode rotations and translations. Therefore, you should
    use one such matrix to represent our hypothetical camera.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，暂时地，我们在WebGL中确实有一个摄像机。摄像机应该能够旋转和平移来探索这个3D世界。正如我们在上一节中看到的，一个4x4矩阵可以编码旋转和平移。因此，你应该使用这样一个矩阵来表示我们的假设摄像机。
- en: Let's assume that our camera is located at the origin of the world and that
    it's oriented so that it's looking toward the negative z-axis direction. This
    is a good starting point; we already know what transformation represents such
    a configuration in WebGL (Identity matrix of rank four).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的摄像机位于世界原点，并且它朝向负z轴方向对准。这是一个好的起点；我们已经在WebGL中知道了这种配置所代表的变换（四秩单位矩阵）。
- en: 'For the sake of analysis, let''s break the problem down into two subproblems:
    camera-translation and camera-rotation. We will have a practical demo for each
    one.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析，让我们将问题分解为两个子问题：摄像机平移和摄像机旋转。我们将为每个子问题提供一个实际演示。
- en: Camera Translation
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像机平移
- en: 'Let''s move the camera to `[0, 0, 4]` in world coordinates. This means four
    units from the origin on the positive z-axis. Remember, at this point, we do not
    know about a matrix that moves the camera. We only know how to move the *world* (with
    the Model-View matrix). If we applied:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将摄像机移动到世界坐标中的`[0, 0, 4]`。这意味着从原点沿正z轴移动四个单位。记住，在这个时候，我们还不知道如何移动摄像机。我们只知道如何移动*世界*（使用模型视图矩阵）。如果我们应用：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In such a case, the world would be translated `4` units on the positive z-axis,
    and since the camera position has not been changed, it would be located at `[0,
    0, -4]`, which is exactly the opposite of what we want.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，世界将在正z轴上平移`4`个单位，由于摄像机位置没有改变，它将位于`[0, 0, -4]`，这与我们想要的结果正好相反。
- en: 'Now, say that we applied the translation in the opposite direction:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们应用了相反方向的平移：
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In such a case, the world would be moved `4` units on the negative z-axis and
    then the camera would be located at `[0, 0, 4]` in the new world-coordinate system.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，世界将在负z轴上移动`4`个单位，然后摄像机将位于新世界坐标系中的`[0, 0, 4]`位置。
- en: In the following section, we will explore translations in both world space and
    camera space.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨世界空间和摄像机空间中的平移。
- en: 'Time for Action: Translations in World Space vs Camera Space'
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：世界空间与摄像机空间的平移
- en: 'Let''s cover an example showcasing these differences in action:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示这些差异在实际操作中的表现：
- en: 'Open `ch04_01_model-view-translation.html` in your browser:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`ch04_01_model-view-translation.html`：
- en: '![](img/045a2200-5097-476d-aad1-c2d9e1bffa29.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/045a2200-5097-476d-aad1-c2d9e1bffa29.png)'
- en: From a distance, we are looking at the positive z-axis of a cone located at
    the origin of the world. There are three sliders that allow you to translate either
    the world or the camera on the `x`, `y`, and `z` axes, respectively. The world
    space is activated by default.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从远处看，我们正在观察位于世界原点的圆锥体的正z轴。有三个滑块，分别允许你在`x`、`y`和`z`轴上平移世界或摄像机。默认情况下激活的是世界空间。
- en: By looking at the World matrix on the screen, can you tell where the origin
    of the world is? Is it `[0, 0, 0]`?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看屏幕上的世界矩阵，你能说出世界原点在哪里吗？是`[0, 0, 0]`吗？
- en: Hint
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Check where we define translations in the Model-View matrix.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们在模型视图矩阵中定义平移的位置。
- en: We can think of the `canvas` as the image that our camera sees. If the world's
    center is at `[0, -2, -50]`, where is the camera?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将`canvas`视为摄像机看到的图像。如果世界的中心在`[0, -2, -50]`，那么摄像机在哪里？
- en: If we want to get closer to the cone, we need to move the center of the world
    toward the camera. We know that the camera is far on the positive z-axis of the
    world, so the translation will occur on the z-axis. Given that we are on world
    coordinates, do we need to increase or decrease the z-axis slider? Go ahead and
    test your answer.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想靠近圆锥，我们需要将世界中心移向相机。我们知道相机在世界正z轴上很远，所以平移将发生在z轴上。鉴于我们处于世界坐标中，我们需要增加还是减少z轴滑块？去测试你的答案。
- en: Switch to camera coordinates. What is the translation component of this matrix?
    What do you need to do if you want to move the camera closer to the cone? What
    does the final translation look like? What can you conclude?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到相机坐标。这个矩阵的平移分量是什么？如果你想将相机移近圆锥，你需要做什么？最终的平移看起来像什么？你能得出什么结论？
- en: Try to move the camera on the x-axis and the y-axis. Check what the corresponding
    transformations would be on the Model-View matrix.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在x轴和y轴上移动相机。检查相应的变换在模型视图矩阵中会是什么样子。
- en: '***What just happened?***'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We saw that the camera translation is the inverse of the Model-View matrix translation.
    We also learned where to find translation information in a transformation matrix.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到相机平移是模型视图矩阵平移的逆。我们还学习了在变换矩阵中找到平移信息的位置。
- en: Camera Rotation
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相机旋转
- en: 'Similarly, if we want to rotate the camera, say, `45` degrees to the right,
    this would be equivalent to rotating the world `45` degrees to the left. Using **glMatrix** to
    achieve this, we can write the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们想将相机向右旋转 `45` 度，这相当于将世界向左旋转 `45` 度。使用 **glMatrix** 实现这一点，我们可以编写以下代码：
- en: '[PRE9]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similar to the previous section where we explored translations, in the *Time
    for Action: Rotations in World Space vs Camera Space* section, we will experiment
    with rotations in both world and camera spaces. Let''s see this behavior in action!'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前探索平移的章节类似，在 *时间行动：世界空间与相机空间中的旋转* 部分中，我们将实验世界和相机空间中的旋转。让我们看看这个行为是如何实现的！
- en: 'Time for Action: Rotations in World Space vs Camera Space'
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动：世界空间与相机空间中的旋转
- en: 'Let''s cover an example showing the different rotations in different spaces:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来展示不同空间中的不同旋转：
- en: 'Open `ch04_02_model-view-rotation.html` in your browser:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `ch04_02_model-view-rotation.html`：
- en: '![](img/b58a3fc1-8141-4ecf-b641-856e83194a2b.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b58a3fc1-8141-4ecf-b641-856e83194a2b.png)'
- en: 'As we did in the previous example, we will see the following:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在上一个例子中所做的那样，我们将看到以下内容：
- en: A cone at the origin of the world
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆锥位于世界原点
- en: The camera is located at `[0, 2, 50]` in world coordinates
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机位于世界坐标 `[0, 2, 50]`
- en: Three sliders that allow us to rotate either the world or the camera
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个滑块，允许我们旋转世界或相机
- en: A matrix where we can see the result of different rotations
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个矩阵，我们可以看到不同旋转的结果
- en: Let's see what happens to the axis after we apply a rotation. With the **World **coordinates
    selected, rotate the world `90` degrees around the x-axis. What does the Model-View
    matrix look like?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看应用旋转后轴会发生什么。在 **世界** 坐标选择下，围绕x轴旋转世界 `90` 度。模型视图矩阵看起来像什么？
- en: 'Let''s see where the axes end up after a `90` degree rotation around the x-axis:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看在x轴周围旋转 `90` 度后，轴会落在何处：
- en: By looking at the first column, we can see that the x-axis has not changed.
    It's still `[1, 0, 0]`. This makes sense since we are rotating around this axis.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过查看第一列，我们可以看到x轴没有变化。它仍然是 `[1, 0, 0]`。这很有道理，因为我们围绕这个轴旋转。
- en: The second column of the matrix indicates where the y-axis is after the rotation.
    In this case, we went from `[0, 1, 0]`, which is the original configuration, to
    `[0, 0, 1]`, which is the axis that is coming out of the screen. This is the z-axis
    in the initial configuration. This makes sense since we are now looking from above,
    down at the cone.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的第二列指示旋转后y轴的位置。在这种情况下，我们从 `[0, 1, 0]`，即原始配置，变到 `[0, 0, 1]`，这是从屏幕中伸出的轴。这是初始配置中的z轴。这很有道理，因为我们现在是从上方向下看圆锥。
- en: 'The third column of the matrix indicates the new location of the z-axis. It
    changed from `[0, 0, 1]`, which as we know, is the z-axis in the standard spatial
    configuration (without transforms), to `[0, -1, 0]`, which is the negative portion
    of the y-axis in the original configuration. This makes sense since we rotated
    around the x-axis:'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的第三列指示了z轴的新位置。它从 `[0, 0, 1]` 变化，正如我们所知，这是标准空间配置（没有变换）中的z轴，到 `[0, -1, 0]`，这是原始配置中y轴的负部分。这很有道理，因为我们围绕x轴旋转：
- en: '![](img/550f79c0-2aae-40c1-acdd-53533394c9b2.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/550f79c0-2aae-40c1-acdd-53533394c9b2.png)'
- en: 'As we''ve just seen, understanding the rotation matrix (the 3x3 upper-left
    corner of the Model-View matrix) is simple: the first 3 columns always tell us
    where the axis is.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，理解旋转矩阵（模型视图矩阵的左上角3x3部分）很简单：前三个列始终告诉我们轴在哪里。
- en: 'Where are the axes in the following transformation? Take a look at the following
    diagram:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下变换中，坐标轴在哪里？请看下面的图：
- en: '![](img/66b15f33-519b-4d5a-b1f8-e3c1ae04d520.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66b15f33-519b-4d5a-b1f8-e3c1ae04d520.png)'
- en: Check your answer by using the sliders to achieve the rotation that you believe
    produces this matrix.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用滑块来达到你认为产生此矩阵的旋转来检查你的答案。
- en: Let's see how rotations work in **Camera **space by changing the coordinates,
    selection.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看在**摄像机**空间中旋转是如何工作的，通过改变坐标和选择。
- en: Increase the angle of rotation in the x-axis by incrementing the slider position.
    What do you notice?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过增加滑块位置来增加x轴旋转的角度。你注意到什么？
- en: Using the sliders, try different rotations in camera space.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用滑块，在摄像机空间中尝试不同的旋转。
- en: Are the rotations *commutative*? That is, do you get the same result if you
    rotate, for example, `5` degrees on the x-axis and `90` degrees on the z-axis,
    compared to the case where you rotate `90` degrees on the z-axis and then `5`
    degrees on the x-axis?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转是**交换律**的吗？也就是说，如果你在x轴上旋转`5`度，在z轴上旋转`90`度，与先在z轴上旋转`90`度然后在x轴上旋转`5`度相比，你会得到相同的结果吗？
- en: Return to World space. Please remember that when you're in World space, you
    need to reverse the rotations to obtain the same pose, for example, if you were applying
    `5` degrees on the x-axis and `90` degrees on the z-axis, verify that when you
    apply `-5` degrees on the x-axis and `-90` degrees on the z-axis, you obtain the
    same result.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到世界空间。请记住，当你处于世界空间时，你需要反转旋转以获得相同的姿态，例如，如果你在x轴上应用`5`度，在z轴上应用`90`度，验证当你应用`-5`度在x轴上和`-90`度在z轴上时，你获得相同的结果。
- en: '***What just happened?***'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We've just learned that the Camera matrix rotation is the inverse of the Model-View
    matrix rotation. We've also learned how to identify the orientation of our world
    or camera after analyzing the rotation matrix (3x3 upper-left corner of the correspondent
    transformation matrix).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解到摄像机矩阵的旋转是模型视图矩阵旋转的逆。我们还学习了如何通过分析旋转矩阵（相应变换矩阵的左上角3x3部分）来识别我们的世界或摄像机的方向。
- en: 'Have a Go: Combining Rotations and Translations'
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试：结合旋转和变换
- en: 'Let''s see how we can combine rotations and translations together:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何将旋转和变换结合起来：
- en: 'The `ch04_03_model-view.html` file contains the combination of rotations and
    translations. When you open it your browser, you will see something like this:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ch04_03_model-view.html`文件包含了旋转和变换的组合。当你打开它时，你的浏览器将显示如下内容：'
- en: '![](img/3217cdd4-7f3c-4dfe-9a47-8f5ce6254b89.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3217cdd4-7f3c-4dfe-9a47-8f5ce6254b89.png)'
- en: Try different configurations of rotations and translations in both the **World **and **Camera** spaces.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在**世界**和**摄像机**空间中不同的旋转和变换配置。
- en: Camera Matrix Is the Inverse of the Model-View Matrix
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像机矩阵是模型视图矩阵的逆
- en: These two scenarios help us appreciate that a Camera matrix is the exact opposite
    of the Model-View matrix. In linear algebra, this property is known as the **inverse** of
    a matrix.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况帮助我们理解摄像机矩阵是模型视图矩阵的完全相反。在线性代数中，这种性质被称为矩阵的**逆**。
- en: 'The inverse of a matrix is such that when multiplying it by the original matrix,
    we obtain the Identity matrix. In other words, if `M` is the Model-View matrix
    and `C` is the Camera matrix, we get the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的逆是当它与原始矩阵相乘时，我们得到单位矩阵。换句话说，如果`M`是模型视图矩阵，`C`是摄像机矩阵，我们得到以下结果：
- en: 'We can create the Camera matrix using **glMatrix** by writing something like
    the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**glMatrix**编写如下内容来创建摄像机矩阵：
- en: '[PRE10]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Thinking About Matrix Multiplications in WebGL
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考WebGL中的矩阵乘法
- en: Before moving forward, we should note that in WebGL, matrix operations are written
    in the *reverse order* in which they are applied to the vertices. This is an important
    note that's often confusing for developers new to 3D graphics.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，我们应该注意，在WebGL中，矩阵操作是按照它们应用于顶点的**相反顺序**编写的。这是对新手3D图形开发者来说经常令人困惑的重要注意事项。
- en: 'Let''s assume, for a moment, that you are writing the code to rotate/move the
    world; that is, you rotate your vertices around the origin and then you move away.
    The final transformation would look like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时假设你正在编写旋转/移动世界的代码；也就是说，你围绕原点旋转你的顶点，然后移动离开。最终的变换将看起来像这样：
- en: Here, `R` is the 4x4 matrix-encoding pure rotation;  `T` is the 4x4 matrix-encoding
    pure translation, and `v` corresponds to the vertices present in your scene (in
    Homogeneous coordinates).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`R` 是编码纯旋转的 4x4 矩阵；`T` 是编码纯平移的 4x4 矩阵，而 `v` 对应于场景中存在的顶点（在齐次坐标中）。
- en: Now, you should have noticed that the first transformation we apply to the vertices
    is the translation, and then we apply the rotation. Vertices need to be multiplied
    first by the matrix that is to the left. In this scenario, that matrix is `T`.
    Then, the result needs to be multiplied by `R`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经注意到，我们首先应用于顶点的变换是平移，然后是旋转。顶点需要首先乘以左侧的矩阵。在这种情况下，该矩阵是 `T`。然后，结果需要乘以 `R`。
- en: 'This fact is reflected in the order of the operations (here, `modelViewMatrix` is
    the Model-View matrix):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这一事实反映在操作顺序中（这里，`modelViewMatrix` 是模型-视图矩阵）：
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we were working in camera coordinates and we wanted to apply the same transformation
    as before, we need to apply a bit of linear algebra first:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在相机坐标系中工作，并且想要应用之前的相同变换，我们首先需要应用一些线性代数：
- en: '| `![](img/9939b32a-17f2-4507-9908-c217f9f203e7.png)` | The Model-View `M` matrix
    is the result of multiplying rotation and translation together. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `![](img/9939b32a-17f2-4507-9908-c217f9f203e7.png)` | 模型-视图 `M` 矩阵是旋转和平移相乘的结果。|'
- en: '| `![](img/26b36e70-d5d1-4191-aaa2-53d7cf4bbbdf.png)` | We know that the Camera
    matrix is the inverse of the Model-View matrix. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `![](img/26b36e70-d5d1-4191-aaa2-53d7cf4bbbdf.png)` | 我们知道相机矩阵是模型-视图矩阵的逆。|'
- en: '| `![](img/7f5d4ad7-8a38-4b86-ae6d-42d714b82152.png)` | By substitution. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `![](img/7f5d4ad7-8a38-4b86-ae6d-42d714b82152.png)` | 通过代入。|'
- en: '| `![](img/f6ad6044-8aac-4a75-8262-21f97d2c571a.png)` | The inverse of a matrix
    product is the reverse product of the inverses. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `![](img/f6ad6044-8aac-4a75-8262-21f97d2c571a.png)` | 矩阵乘积的逆是逆矩阵的逆序乘积。|'
- en: 'Fortunately, when we''re working in camera coordinates in this chapter''s examples,
    we have the inverse translation and the inverse rotation already calculated in
    the global variables position and rotation. Therefore, we would write something
    such as this in the code (here, `cameraMatrix` is the Camera matrix):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在本章的示例中，当我们使用相机坐标系时，我们已经计算了全局变量 `position` 和 `rotation` 中的逆平移和逆旋转。因此，我们可以在代码中写出如下内容（这里，`cameraMatrix`
    是相机矩阵）：
- en: '[PRE12]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Basic Camera Types
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本相机类型
- en: 'In this chapter, we will discuss the following two camera types:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下两种相机类型：
- en: Orbiting camera
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环绕相机
- en: Tracking camera
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪相机
- en: Orbiting Camera
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环绕相机
- en: So far, we've learned how to generate rotations and translations in either world
    or camera coordinates. In both cases, however, we are always generating the rotations
    around the center of the world. This may be ideal when we're orbiting around a
    3D object, such as our car model. In that example, you put the object at the center
    of the world, and then examine the object at different angles (rotation); after
    that, you can move away (translation) to see the result. We will refer to this
    type of camera as an **orbiting camera**.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何在世界或相机坐标系中生成旋转和平移。然而，在两种情况下，我们总是在世界中心周围生成旋转。当我们围绕一个 3D 对象，如我们的汽车模型旋转时，这可能很理想。在那个例子中，你将对象放在世界中心，然后从不同的角度（旋转）检查对象，之后你可以移动（平移）以查看结果。我们将此类相机称为**环绕相机**。
- en: Tracking Camera
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追踪相机
- en: If we return to the example of the first-person shooting game, we need to have
    a camera that can look up when we want to check whether there are enemies above
    us. We should also be able to look left and right (rotations) and then move in
    the direction in which our camera is pointing (translation). This camera type
    can be designated as a **first-person** camera. This same type is used when the
    game follows the main character. Therefore, it is generally known as a **tracking
    camera**.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到第一人称射击游戏的例子，我们需要有一个相机，当我们想要检查是否有敌人在我们上方时，它可以向上看。我们还应该能够左右旋转（旋转）并沿着相机指向的方向移动（平移）。这种类型的相机可以称为**第一人称**相机。当游戏跟随主要角色时，也使用相同的类型。因此，它通常被称为**追踪相机**。
- en: To implement first-person cameras, we need to set up the rotations on the camera
    axis instead of using the world origin.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现第一人称相机，我们需要在相机轴上设置旋转，而不是使用世界原点。
- en: Rotating the Camera Around Its Location
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 围绕其位置旋转相机
- en: 'When multiplying matrices, the order in which we multiply them is relevant.
    Say, for instance, we have two 4x4 matrices. Let `R` be the first matrix and let''s
    assume that this matrix encodes pure rotation; let `T` be the second matrix and
    let''s assume that `T` encodes pure translation. Now:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在乘矩阵时，乘法的顺序是相关的。比如说，我们有两个4x4矩阵。让`R`是第一个矩阵，假设这个矩阵编码了纯旋转；让`T`是第二个矩阵，假设`T`编码了纯平移。现在：
- en: In other words, the order of the operations affects the result. It is not the
    same to rotate around the origin and then translate away from it (orbiting camera),
    as compared to translating the origin and then rotating around it (tracking camera)!
    Your success depends on understanding this critical difference.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，操作的顺序会影响结果。围绕原点旋转然后远离它（环绕相机）与先平移原点然后围绕它旋转（跟踪相机）是不同的！你的成功取决于理解这个关键的区别。
- en: In order to set the location of the camera as the center for rotations, we need
    to invert the order in which operations are called. This is equivalent to converting
    from an orbiting camera to a tracking camera.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将相机位置设置为旋转的中心，我们需要颠倒操作调用的顺序。这相当于从环绕相机转换为跟踪相机。
- en: Translating the Camera in the Line of Sight
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视线方向上平移相机
- en: With an orbiting camera, the camera will always look toward the center of the
    world. Therefore, we will always use the z-axis to move to and from the object
    we are examining. However, with a tracking camera, since the rotation occurs at
    the camera location, we can end up looking to any position in the world (which
    is ideal if you want to move around and explore it). Thus, we need to know the
    direction in which the camera is pointing in world coordinates (camera axis).
    We will see how to obtain this next.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环绕相机时，相机将始终朝向世界中心。因此，我们将始终使用z轴来移动到和离开我们正在检查的对象。然而，使用跟踪相机时，由于旋转发生在相机位置，我们最终可以看向世界中的任何位置（如果你想要四处移动和探索，这是理想的）。因此，我们需要知道相机在世界坐标中指向的方向（相机轴）。我们将在下一部分看到如何获得这个方向。
- en: The Camera Model
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相机模型
- en: 'Just like its counterpart, the Model-View matrix, the Camera matrix encodes
    information about the camera orientation. As we can see in the following diagram,
    the upper-left 3x3 matrix corresponds to the camera axes:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就像它的对应矩阵，模型视图矩阵一样，相机矩阵编码了相机方向的信息。正如我们可以在以下图中看到的那样，左上角的3x3矩阵对应于相机轴：
- en: The first column corresponds to the x-axis of the camera. We will call it `RightVector`.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一列对应于相机的x轴。我们将它称为`RightVector`。
- en: The second column is the y-axis of the camera. This will be `UpVector`.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二列是相机的y轴。这将是`UpVector`。
- en: The third column determines the vector in which the camera can move back and
    forth. This is the z-axis of the camera and we will call it `CameraAxis`.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三列决定了相机可以前后移动的向量。这是相机的z轴，我们将它称为`CameraAxis`。
- en: 'Because the Camera matrix is the inverse of the Model-View matrix, the upper-left
    3x3 rotation matrix contained in the Camera matrix gives us the orientation of
    the camera axes in world space. This is a plus, because it means that we can tell
    the orientation of our camera in world space just by looking at the columns of
    this 3x3 rotation matrix (and we now know what each column means):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因为相机矩阵是模型视图矩阵的逆矩阵，所以相机矩阵中包含的左上角3x3旋转矩阵给出了相机轴在世界空间中的方向。这是一个优点，因为它意味着我们只需查看这个3x3旋转矩阵的列就可以知道我们相机在世界空间中的方向（我们现在知道每一列代表什么）：
- en: '![](img/eab3b14f-8d24-47d3-b581-e454c012cbc3.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eab3b14f-8d24-47d3-b581-e454c012cbc3.png)'
- en: In the following section, we will play with orbiting and tracking cameras to
    see how we can change the camera position using mouse gestures and sliders. In
    addition, we will look at a graphical representation of the resulting Model-View
    matrix. In this exercise, we will integrate both rotations and translations and
    we will see how they behave under the two basic types of cameras we are studying.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将玩环绕和跟踪相机，看看我们如何使用鼠标手势和滑块来改变相机位置。此外，我们还将查看结果的模型视图矩阵的图形表示。在这个练习中，我们将整合旋转和平移，并观察它们在两种基本类型的相机下如何表现。
- en: 'Time for Action: Exploring the Showroom'
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：探索展厅
- en: 'Let''s cover an example covering various camera types:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个涵盖各种相机类型的例子：
- en: 'Open the `ch04_04_camera-types.html` file in your browser. You will see something
    like the following:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`ch04_04_camera-types.html`文件。你会看到以下类似的内容：
- en: '![](img/fb4de108-cebd-42b7-ac5c-f233ebd5693e.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb4de108-cebd-42b7-ac5c-f233ebd5693e.png)'
- en: Go around the world using the sliders in Trackingmode. Cool, huh?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Trackingmode中的滑块在世界各地环游。酷吧？
- en: Change the camera type to Orbitingmode and do the same.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相机类型更改为Orbitingmode，并执行相同的操作。
- en: Check that besides the slider controls, both in Trackingand Orbiting mode, you
    can use your mouse and keyboard to move around the world.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确认，除了滑块控制外，在Tracking和Orbiting模式下，你还可以使用鼠标和键盘在世界各地移动。
- en: 'In this exercise, we have implemented a camera using two new classes:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用两个新的类实现了相机：
- en: '`Camera`: To manipulate the camera.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Camera`：用于操作相机。'
- en: '`Controls`: To connect the camera to the `canvas`. The `canvas` will now receive
    mouse and keyboard events and pass them along to the camera.'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Controls`：将相机连接到`canvas`。现在`canvas`将接收鼠标和键盘事件并将它们传递给相机。'
- en: If you are curious, you can see the source code of these two classes in the
    `common/js` directory. We have applied the concepts explained in this chapter
    to build these two classes.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你好奇，你可以在`common/js`目录中查看这两个类的源代码。我们已经将本章中解释的概念应用到这两个类的构建中。
- en: So far, we have seen a cone in the center of the world. As we explore, let's
    change it to something more interesting. Open the file `ch04_04_camera-types.html` file
    in your source code editor.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们在世界的中心看到了一个圆锥体。随着我们的探索，让我们将其更改为更有趣的东西。在源代码编辑器中打开`ch04_04_camera-types.html`文件。
- en: 'Go to the `load` function. Let''s add the car to the scene. Rewrite the contents
    of this function to the following:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`load`函数。让我们将汽车添加到场景中。将此函数的内容重写为以下内容：
- en: '[PRE13]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You will see that we've increased the size of the axis and the floor so that
    we can see them. We need to do this because the car model is a much larger object
    than the original cone.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到我们增加了轴和地板的大小，这样我们才能看到它们。我们需要这样做，因为汽车模型比原始的圆锥体大得多。
- en: 'There are a few steps we need to take in order to see the car correctly. We
    need to make sure that we have a large enough view volume. Go to the `updateTransforms`
    function and update this line:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确地看到汽车，我们需要采取几个步骤。我们需要确保我们有一个足够大的视场。前往`updateTransforms`函数并更新此行：
- en: '[PRE14]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Replace it with this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换：
- en: '[PRE15]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Change the type of camera so that when we load the page, we have an orbiting
    camera by default. In the `configure` function, change this line:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相机类型更改为，以便在加载页面时，我们默认有一个环绕相机。在`configure`函数中更改此行：
- en: '[PRE16]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Replace it with this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换：
- en: '[PRE17]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Another thing we must consider is the location of the camera. For a large object
    such as this car, we need to be farther away from the center of the world. For
    that purpose, we need to change the home location of `camera.goHome` from `[0,
    2, 50]` to `[0, 25, 300]`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须考虑相机位置。对于像这样的大型物体，我们需要远离世界的中心。为此，我们需要将`camera.goHome`的默认位置从`[0, 2, 50]`更改为`[0,
    25, 300]`。
- en: 'Let''s modify our scene''s lighting so that it better fits into the model we
    are displaying. In the `configure` function, update the following:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改场景的照明，使其更适合我们正在显示的模型。在`configure`函数中更新以下内容：
- en: '[PRE18]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Replace it with this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换：
- en: '[PRE19]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Save the file with a different name and then load this new file in your browser.
    You should see something like the following screenshot:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的名称保存文件，然后在浏览器中加载这个新文件。你应该会看到以下截图类似的内容：
- en: '![](img/3aed3547-ab9c-46ca-978c-38cb4712309b.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3aed3547-ab9c-46ca-978c-38cb4712309b.png)'
- en: Using the mouse, keyboard, and/or the sliders, explore the new scene.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标、键盘和/或滑块来探索新场景。
- en: Use orbiting mode to explore the car from different angles.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用环绕模式从不同的角度探索汽车。
- en: See how the Camera matrix is updated when you move around the scene.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看当你移动场景时，Camera矩阵是如何更新的。
- en: You can see what the final exercise looks like by opening the `ch04_05_car.html` file.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过打开`ch04_05_car.html`文件来查看最终练习的样子。
- en: '***What just happened?***'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We added mouse and keyboard interaction to our scene. We also experimented with
    the two basic camera types: *tracking* and *orbiting* cameras. Finally, we modified
    the settings of our scene to visualize a complex model.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的场景中添加了鼠标和键盘交互。我们还尝试了两种基本的相机类型：*跟踪*和*环绕*相机。最后，我们修改了场景的设置以可视化复杂模型。
- en: 'Have a Go: Updating Light Positions'
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试更新光源位置
- en: As we've seen, by moving the camera, we're applying the inverse transformation
    to the world. If we do not update the light position, the light source will be
    located at the same static point, regardless of the final transformation applied
    to the world.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通过移动相机，我们正在对世界应用逆变换。如果我们不更新光照位置，无论对世界应用了什么最终变换，光源都将位于相同的静态点。
- en: This is very convenient when we're moving around or exploring an object in the
    scene. We can always see whether the light is located on the same axis of the
    camera. This is the case for the exercises in this chapter. Nevertheless, we can
    also simulate the case when the camera movement is independent from the light
    source. To do so, we need to calculate the new light position whenever we move
    the camera.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在场景中移动或探索对象时，这非常方便。我们总能看到光是否位于与相机相同的轴上。这是本章练习的情况。尽管如此，我们也可以模拟当相机移动与光源独立的情况。为此，我们需要在移动相机时计算新的光照位置。
- en: First, we calculate the light direction. We can do this by simply calculating
    the difference vector between our target and our origin. Say the light source
    is located at `[0, 2, 50]`. If we want to direct our light source toward the origin,
    we calculate the `[0, 0, 0] - [0, 2, 50]` vector *(target - origin)*. This vector
    has the correct orientation of the light when we target the origin. We repeat
    the same procedure if we have a different target that needs to be lit. In that
    case, we just use the coordinates of the target and from them, we subtract the
    location of the light.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算光的方向。我们可以通过简单地计算目标和原点之间的差向量来完成。假设光源位于`[0, 2, 50]`。如果我们想将光源指向原点，我们计算`[0,
    0, 0] - [0, 2, 50]`向量（目标-原点）。当目标为原点时，这个向量具有正确的光方向。如果我们有一个需要照明的不同目标，我们重复相同的程序。在这种情况下，我们只需使用目标的坐标，并从中减去光源的位置。
- en: 'As we are directing our light source toward the origin, we can find the direction
    of the light just by inverting the light position. As you may have noticed, we
    do this in ESSL in the vertex shader:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在将光源指向原点，我们可以通过反转光照位置来找到光的方向。正如你可能已经注意到的，我们在本章节的早期在顶点着色器中这样做：
- en: '[PRE20]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As `light` is a vector, if we want to update the direction of the light, we
    need to use the Normal matrix, discussed earlier in this chapter, to update this
    vector under any world transformation. This step is optional in the vertex shader:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`light`是一个向量，如果我们想更新光的方向，我们需要使用本章前面讨论过的法线矩阵，在任何世界变换下更新这个向量。这一步在顶点着色器中是可选的：
- en: '[PRE21]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous fragment of code, light is augmented to four components, so
    we can use the direct multiplication provided by ESSL. (Remember that `uNormalMatrix` is
    a 4x4 matrix and, as such, the vectors it transforms need to be four-dimensional.)
    Please bear in mind that, as explained at the beginning of this chapter, the Homogeneous
    coordinates of vectors are always set to `0`, while the Homogeneous coordinates
    of vertices are set to `1`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，`light`被扩展为四个分量，因此我们可以使用ESSL提供的直接乘法。（记住，`uNormalMatrix`是一个4x4矩阵，因此它转换的向量需要是四维的。）请记住，正如本章节开头所解释的，向量的齐次坐标始终设置为`0`，而顶点的齐次坐标设置为`1`。
- en: After the multiplication, we reduce the result to three components before assigning
    the result back to light.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在乘法之后，我们将结果减少到三个分量，然后再将结果赋值回`light`。
- en: You can test the effects of updating the light position by using the `Static
    Light Position` button, provided in the `ch04_05_car.html` file.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过使用`ch04_05_car.html`文件中提供的“静态光照位置”按钮来测试更新光照位置的效果。
- en: We connect a global variable that keeps track of the state of this button with
    the `uUpdateLight` uniform.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将跟踪此按钮状态的全局变量与`uUpdateLight`统一变量连接。
- en: 'Edit `ch04_05_car.html` and set the light position to a different location.
    To do this, edit the configure function. Go to the following position:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`ch04_05_car.html`并设置光照位置到不同的位置。为此，编辑`configure`函数。前往以下位置：
- en: '[PRE22]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Try different light positions:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不同的光照位置：
- en: '`[2120, 0, 0]`'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[2120, 0, 0]`'
- en: '`[0, 2120, 0]`'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0, 2120, 0]`'
- en: '`` `[100, 100, 100]` ``'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `[100, 100, 100]` ``'
- en: 'For each option, save the file and try it with and without updating the light
    position (use the `Static Light Position` button):'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个选项，保存文件，并尝试更新和不更新光照位置（使用“静态光照位置”按钮）：
- en: '![](img/e7f5ba57-bda1-4a0f-93c8-fbb99a68b10d.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7f5ba57-bda1-4a0f-93c8-fbb99a68b10d.png)'
- en: For a better visualization, use an **Orbiting **camera.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好的可视化，使用**环绕**相机。
- en: The Projection matrix
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影矩阵
- en: At the beginning of this chapter, we learned that the **Projection matrix**
    combines the projection transformation and the perspective division. These two
    steps take a 3D scene and convert it into a cube, which is then mapped to the
    2D `canvas` by the viewport transformation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们了解到**投影矩阵**结合了投影变换和透视除法。这两个步骤将3D场景转换为立方体，然后通过视口变换将其映射到2D `canvas`。
- en: In practice, the Projection matrix determines the geometry of the image that
    is captured by the camera. In a real-world camera, the lens of the camera would
    determine how distorted the final images are. In a WebGL world, we use the Projection
    matrix to simulate that effect. Also, unlike in the real world where our images
    are always affected by perspective, in WebGL, we can pick a different representation
    (such as the orthographic projection).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，投影矩阵决定了摄像机捕获的图像的几何形状。在现实世界的摄像机中，摄像机的镜头将决定最终图像的扭曲程度。在WebGL世界中，我们使用投影矩阵来模拟这种效果。此外，与在现实世界中我们的图像总是受到透视影响不同，在WebGL中，我们可以选择不同的表示（如正交投影）。
- en: Field of View
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视野
- en: 'The Projection matrix determines the **field of view** (**FOV**) of the camera,
    that is, how much of the 3D space will be captured by the camera. The field of
    view is a measure given in degrees, and the term is used interchangeably with
    the term **angle of view**:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 投影矩阵决定了摄像机的**视野**（**FOV**），即摄像机将捕捉多少3D空间。视野是一个以度为单位给出的度量，该术语与**视场角**一词可以互换使用：
- en: '![](img/f51e256f-69dd-4828-b355-86e1d7969e46.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f51e256f-69dd-4828-b355-86e1d7969e46.png)'
- en: Perspective or Orthogonal Projection
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透视或正交投影
- en: A perspective projection assigns more space to details that are closer to the
    camera than details that are farther away. In other words, the geometry that is
    close to the camera will appear larger than the geometry that is farther from
    it. This is the way our eyes see the real world. Perspective projection allows
    us to assess the distance because it gives our brain a *depth cue*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 透视投影将更多空间分配给靠近摄像机的细节，而不是远离摄像机的细节。换句话说，靠近摄像机的几何形状看起来比远离摄像机的几何形状更大。这是我们眼睛看到现实世界的方式。透视投影使我们能够评估距离，因为它给我们的大脑提供了一个*深度线索*。
- en: In contrast, an orthogonal projection uses parallel lines; this means that lines
    will appear to be the same size, regardless of their distance to the camera. Therefore,
    the depth cue is lost when using orthogonal projection.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，正交投影使用平行线；这意味着线条看起来大小相同，无论它们与摄像机的距离如何。因此，使用正交投影时，深度线索会丢失。
- en: While perspective projection offers a more realistic view of the scene, orthographic
    is commonly used in engineering as a means to produce object specifications that
    communicate dimensions unambiguously. Each line of one unit length (cm, meter)
    will appear to have the same length everywhere on the drawing. This allows the
    drafter to dimension only a subset of lines and let the reader know that other
    lines of that length on the drawing are also that length in reality. Every parallel
    line in the drawing is also parallel in the object.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然透视投影提供了更真实的场景视图，但在工程中通常使用正交投影作为一种产生明确传达尺寸的对象规范的手段。每条单位长度（厘米、米）的线条在图纸上的任何地方看起来长度都相同。这使得绘图员只需标注部分线条，并让读者知道图纸上的其他相同长度的线条在现实中也是相同长度的。图纸上的每条平行线在物体中也是平行的。
- en: If you are looking at a larger scene with buildings, then orthographic rendering
    gives an exact measure of the distance between the buildings and their relative
    sizes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在观察一个包含建筑物的更大场景，那么正交渲染可以给出建筑物之间距离及其相对尺寸的确切测量。
- en: With perspective mode, lines of identical real-world lengths will appear different
    due to foreshortening. It becomes difficult to judge relative dimensions and object
    size in the distance.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在透视模式下，由于透视缩短，相同实际长度的线条看起来会不同。这使判断相对尺寸和物体大小变得困难。
- en: 'Using **glMatrix**, we can set up the perspective or the orthogonal projection
    by calling `mat4.perspective` or `mat4.ortho`, respectively. The signatures for
    these methods are as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**glMatrix**，我们可以通过调用`mat4.perspective`或`mat4.ortho`分别设置透视或正交投影。这些方法的签名如下：
- en: '| **Function** | **Description** |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '|'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| Generates a perspective projection matrix with the given bounds.**Parameters:**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '| 生成具有给定边界的透视投影矩阵。**参数：**'
- en: '`dest`: `mat4` frustum the matrix will be written into'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dest`: 将写入的`mat4`视锥矩阵'
- en: '`fovy`: Vertical field of view'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fovy`: 垂直视野'
- en: '`aspect`: Aspect ratio, typically the `width / height` viewport'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aspect`：宽高比，通常是`width / height`视窗'
- en: '`near`, `far`: Near and far bounds of the frustum'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`near`，`far`：视锥体的近点和远点边界'
- en: '|'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| Generates an orthogonal projection matrix with the given bounds:**Parameters:**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '| 生成具有给定边界的正交投影矩阵：**参数：**'
- en: '`dest`: `mat4` frustum the matrix will be written into'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dest`：将矩阵写入的`mat4`视锥体'
- en: '`left`, `right`: Left and right bounds of the frustum'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`，`right`：视锥体的左侧和右侧边界'
- en: '`bottom`, `top`: Bottom and top bounds of the frustum'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`，`top`：视锥体的底部和顶部边界'
- en: '`near`, `far`: Near and far bounds of the frustum'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`near`，`far`：视锥体的近点和远点边界'
- en: '|'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In the *Time for Action: Orthographic and Perspective Projections* section,
    we will test how the field of view and the perspective projection affect the image
    that our camera captures. We will experiment with perspective and orthographic
    projections for both orbiting and tracking cameras.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在“行动时间：正交和透视投影”部分，我们将测试视野和透视投影如何影响我们的相机捕捉到的图像。我们将对旋转和跟踪相机进行透视和正交投影的实验。
- en: 'Time for Action: Orthographic and Perspective Projections'
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：正交和透视投影
- en: 'Let''s look at an example covering the different types of projections:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个涵盖不同投影类型的例子：
- en: Open the `ch04_06_projection-modes.html` file in your browser.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`ch04_06_projection-modes.html`文件。
- en: 'This exercise is very similar to the previous one. However, there are two new
    options under Projection Mode: Perspective and Orthogonal Projection. As you can
    see, Perspectiveis activated by default.'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个练习与上一个非常相似。然而，在投影模式中有两个新的选项：透视和正交投影。如你所见，透视默认是激活的。
- en: Change the camera type to Orbiting.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相机类型更改为“Orbiting”。
- en: Change the projective mode to Orthographic.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将投影模式更改为正交。
- en: 'Explore the scene. Notice the lack of the depth cues characteristic of orthogonal
    projections:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索场景。注意正交投影缺乏深度提示：
- en: '![](img/d8173bc0-3ec2-4833-85b1-bddb0d1e8d6b.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8173bc0-3ec2-4833-85b1-bddb0d1e8d6b.png)'
- en: 'Switch to Perspective mode:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到透视模式：
- en: '![](img/3c05ed7f-ab40-49e3-8132-904154678bb6.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c05ed7f-ab40-49e3-8132-904154678bb6.png)'
- en: 'Explore the source code. Go to the `updateTransforms` function:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索源代码。转到`updateTransforms`函数：
- en: '[PRE25]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Take a look at the parameters we are using to set up the projective view.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看我们用来设置投影视图的参数。
- en: Notice that as you increase the field of view (`fov`), your camera will capture
    more of the 3D space. Think of this as the lens of a real-world camera. With a
    wide-angle lens, you capture more space with the tradeoff of deforming the objects
    as they move toward the boundaries of your viewing box.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，当你增加视野（`fov`）时，你的相机将捕捉到更多的3D空间。把这想象成现实世界相机的镜头。使用广角镜头，你可以捕捉到更多的空间，但代价是当物体移动到你的视窗边界时，它们会变形。
- en: '***What just happened?***'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We experimented with different configurations for the Projection matrix and
    we saw how these configurations produce different results in the scene.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试了不同的投影矩阵配置，并看到了这些配置如何在场景中产生不同的结果。
- en: 'Have a Go: Integrating the Model-View and the Projective Transform'
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下：整合模型视图和投影变换
- en: 'Recall that once we''ve applied the Model-View transformation to the vertices,
    the next step is to transform the view coordinates to NDC coordinates:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，一旦我们将模型视图变换应用于顶点，下一步就是将视图坐标转换为NDC坐标：
- en: '![](img/d9523810-bf63-4ea2-9b26-7cac86821c59.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9523810-bf63-4ea2-9b26-7cac86821c59.png)'
- en: 'We do this by simple multiplication by using ESSL in the vertex shader:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在顶点着色器中使用ESSL进行简单乘法来完成这个操作：
- en: '[PRE26]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The predefined variable, `gl_Position`, stores the NDC coordinates for each
    vertex of every object defined in the scene.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义变量`gl_Position`存储场景中每个对象的每个顶点的NDC坐标。
- en: In the previous multiplication, we augment the shader attribute, `aVertexPosition`,
    to a 4-component vertex because our matrices are 4x4\. Unlike normals, vertices
    have a Homogeneous coordinate equal to one (`w=1`).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的乘法中，我们将着色器属性`aVertexPosition`扩展为4个分量的顶点，因为我们的矩阵是4x4的。与法线不同，顶点有一个等于一的齐次坐标（`w=1`）。
- en: 'After this step, WebGL will convert the computed clipping coordinates to normalized
    device coordinates and from there to `canvas` coordinates using the WebGL `viewport` function.
    Let''s see what happens when we change this mapping:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步之后，WebGL会将计算出的裁剪坐标转换为归一化设备坐标，然后通过WebGL的`viewport`函数将其转换为`canvas`坐标。让我们看看当我们改变这种映射时会发生什么：
- en: Open the `ch04_06_projection-modes.html` file in your source code editor.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的源代码编辑器中打开`ch04_06_projection-modes.html`文件。
- en: Go to the `draw` function. This is the rendering function that is invoked every
    time we interact with the scene (by using the mouse, the keyboard, or the widgets
    on the page).
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`draw`函数。这是每次我们与场景交互时（通过使用鼠标、键盘或页面上的小部件）调用的渲染函数。
- en: 'Find the following line:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到以下行：
- en: '[PRE27]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Try each of the following three operations:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试以下三个操作：
- en: '[PRE28]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For each option, save the file and open it on your browser.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个选项，保存文件并在浏览器中打开它。
- en: What do you see? Please note that you can interact with the scene just like
    before.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你看到了什么？请注意，你可以像以前一样与场景进行交互。
- en: Structure of the WebGL Examples
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL示例的结构
- en: We have improved the structure of the code examples in this chapter. As the
    complexity of our WebGL applications increases, it is wise to have a good, maintainable,
    and clear design. We have saved this section until the end of this chapter so
    that you can use it as a reference when working on the exercises.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改进了本章中代码示例的结构。随着我们的WebGL应用程序复杂性的增加，拥有一个良好、可维护且清晰的架构是明智的。我们将这一部分留到了本章的末尾，以便你在处理练习时可以作为参考。
- en: Just as in previous exercises, our entry point is the `init` function, which
    is called when the page is loaded. We have included several `scripts` in the `head`
    of our document that point to various components to build our 3D application.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的练习一样，我们的入口点是`init`函数，它在页面加载时被调用。我们在文档的`head`中包含了几个`scripts`，它们指向各种组件以构建我们的3D应用程序。
- en: Supporting Objects
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持对象
- en: 'We have created the following components, each one in its own file inside the
    `common/js` directory:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了以下组件，每个组件都在`common/js`目录下的单独文件中：
- en: '`Program.js`: Creates the program using the shader definitions. Provides the
    mapping between JavaScript variables (`program.*`) and program attributes and
    uniforms.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program.js`：使用着色器定义创建程序。提供JavaScript变量（`program.*`）与程序属性和统一变量的映射。'
- en: '`Scene.js`: Maintains a list of objects to be rendered. Contains the AJAX/JSON
    functionality to retrieve remote objects. It also allows us to add local objects
    to the scene.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scene.js`：维护要渲染的对象列表。包含AJAX/JSON功能，用于检索远程对象。它还允许我们将本地对象添加到场景中。'
- en: '`Floor.js`: Defines a grid on the X-Z plane. This object is added to `scene`
    to have a reference to the floor and its properties'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Floor.js`：在X-Z平面上定义一个网格。此对象添加到`scene`中，以便有对地板及其属性的引用'
- en: '`Axis.js`: Represents the axis in world space. When added to `scene`, we will
    have a reference to the origin.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Axis.js`：表示世界空间中的轴。当添加到`scene`中时，我们将有一个对原点的引用。'
- en: '`Camera.js`: Creates a camera instance to manipulate the various matrices and
    operations covered in this chapter with a simple interface.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Camera.js`：创建一个相机实例，通过简单的接口来操作本章中涵盖的各种矩阵和操作。'
- en: '`EventEmitter.js`: A simple pub-sub event emitter for decoupling various components
    in our WebGL application. Instead of passing hard references around between unrelated
    functionality, we can leverage the pub-sub pattern to emit and listen to actions.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventEmitter.js`：一个简单的发布/订阅事件发射器，用于解耦我们的WebGL应用程序中的各种组件。我们可以在不相关的功能之间传递硬引用的情况下，利用发布/订阅模式来发射和监听动作。'
- en: '`Clock.js`: A simple class that abstracts away the `requestAnimationFrame`
    API to have the entire WebGL application update from a single source of truth
    (such as `clock`).'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clock.js`：一个简单的类，它抽象了`requestAnimationFrame` API，以便整个WebGL应用程序从单一的真实来源（如`clock`）更新。'
- en: requestAnimationFrameThe `window.requestAnimationFrame()` method tells the browser
    that you wish to perform an animation and requests that the browser call a specified
    function to update an animation before the next repaint. This will request that
    your animation function be called before the browser performs the next repaint.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame``window.requestAnimationFrame()`方法告诉浏览器你希望执行动画，并请求浏览器在下次重绘之前调用指定的函数来更新动画。这将请求在浏览器执行下次重绘之前调用你的动画函数。'
- en: '`Controls.js`: Provides the ability to capture various `canvas` DOM events
    to drive interactions.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Controls.js`：提供捕获各种`canvas` DOM事件的能力，以驱动交互。'
- en: '`utils.js`: Utility functions that we covered in earlier chapters.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`utils.js`：我们在前面的章节中介绍过的实用函数。'
- en: Although we have enough foundation to understand how each components works,
    we will cover each component in [Chapter 9](fe7815dc-66ca-4ee5-9d88-9b7d840509a3.xhtml)*,
    Putting It All Together*. That being said, if you can't wait, feel free to inspect
    the source code to get an idea of what's to come.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有足够的基礎来理解每个组件的工作原理，但我们将在[第9章](fe7815dc-66ca-4ee5-9d88-9b7d840509a3.xhtml)*，整合一切*中涵盖每个组件。也就是说，如果你迫不及待，可以自由地检查源代码，以了解接下来会发生什么。
- en: Life Cycle Functions
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期函数
- en: The following functions define the life cycle of a WebGLApp application.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数定义了`WebGLApp`应用程序的生命周期。
- en: The configure Function
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置函数
- en: The `configure` function sets some parameters of our `gl` context, such as the
    color for clearing the `canvas`. After configuring the necessary states.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure`函数设置我们的`gl`上下文的一些参数，例如清除`canvas`的颜色。在配置必要的状态之后。'
- en: The load Function
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载函数
- en: The `load` function sets up objects to be added to our `scene`. For example,
    the two locally-created objects, `floor` and `axis`, are added to `scene` by calling
    the `add` method. After that, a remote object (AJAX call) is loaded using the
    `scene.load` method.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`函数设置要添加到我们的`scene`中的对象。例如，通过调用`add`方法将两个本地创建的对象`floor`和`axis`添加到`scene`中。之后，使用`scene.load`方法通过AJAX调用加载远程对象。'
- en: The draw Function
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制函数
- en: The `draw` function calls `updateTransforms` to calculate the matrices for the
    new position (that is, when we move), and then iterates over the objects in `scene` to
    render them. Inside this loop, it calls `setMatrixUniforms` for every object to
    be rendered.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`函数调用`updateTransforms`来计算新位置（即当我们移动时）的矩阵，然后遍历`scene`中的对象以渲染它们。在这个循环内部，它为每个要渲染的对象调用`setMatrixUniforms`。'
- en: Matrix-Handling Functions
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵处理函数
- en: Open up `ch04_02_model-view-rotation.html` in your editor. The following are
    the functions that initialize, update, and pass matrices to the shaders.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开`ch04_02_model-view-rotation.html`。以下是一些初始化、更新并将矩阵传递给着色器的函数。
- en: initTransforms
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: initTransforms
- en: 'As you can see, the Model-View matrix, the Camera matrix, the Projection matrix,
    and the Normal matrix are set up here:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模型视图矩阵、相机矩阵、投影矩阵和法线矩阵在这里设置：
- en: '[PRE29]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: updateTransforms
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: updateTransforms
- en: 'In `updateTransforms`, we use the contents of the global variables'' position and rotation to
    update the matrices. This is, of course, as follows::'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在`updateTransforms`中，我们使用全局变量的位置和旋转的内容来更新矩阵。这当然是以下内容：
- en: '[PRE30]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: setMatrixUniforms
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setMatrixUniforms
- en: 'This function performs the mapping:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数执行以下映射：
- en: '[PRE31]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Let''s summarize what we''ve learned in this chapter:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所学的内容：
- en: There is no camera object in WebGL. However, we can build one using the Model-View
    matrix.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL中没有相机对象。然而，我们可以使用模型视图矩阵构建一个。
- en: 3D objects undergo several transformations to be displayed on a 2D screen. These
    transformations are represented as 4x4 matrices.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D对象经过几个变换才能在2D屏幕上显示。这些变换表示为4x4矩阵。
- en: 'Scene transformations are affine. Affine transformations are constituted by
    a linear transformation followed by a translation. The WebGL groups affine transforms
    into three matrices: the Model-View matrix, the Projection matrix, and the Normal
    matrix, and one WebGL operation: `gl.viewport()`.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景变换是仿射的。仿射变换由一个线性变换后跟一个平移组成。WebGL将仿射变换组合到三个矩阵中：模型视图矩阵、投影矩阵和法线矩阵，以及一个WebGL操作：`gl.viewport()`。
- en: Affine transforms are applied in projective space, so they can be represented
    by 4x4 matrices. To work in projective space, vertices need to be augmented to
    contain an extra term, namely `w`, which is called the perspective coordinate.
    The four-tuple `(x, y, z, w)` is called Homogeneous coordinates. Homogeneous coordinates
    allow representation of lines that intersect on infinity by making the perspective
    coordinate `w = 0`. Vectors always have a Homogeneous coordinate, `w = 0`, while
    points have a Homogeneous coordinate, namely, `w = 1` (unless they are at infinity,
    in which case `w = 0`).
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仿射变换应用于投影空间，因此可以用4x4矩阵表示。要在投影空间中工作，顶点需要增加一个额外的项，即`w`，称为透视坐标。四元组`(x, y, z, w)`称为齐次坐标。齐次坐标允许通过使透视坐标`w
    = 0`来表示在无穷远处相交的直线。向量始终有一个齐次坐标，`w = 0`，而点有一个齐次坐标，即`w = 1`（除非它们在无穷远处，在这种情况下`w =
    0`）。
- en: By default, a WebGL scene is viewed from the world origin in the negative direction
    of the z-axis. This can be altered by changing the Model-View matrix.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，WebGL场景从z轴负方向的世界原点进行查看。这可以通过更改模型视图矩阵来改变。
- en: The Camera matrix is the inverse of the Model-View matrix. The camera and world
    operations are opposites. There are two basic types of cameras: *orbiting* and
    *tracking*.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像矩阵是模型视图矩阵的逆矩阵。摄像和世界操作是相反的。有两种基本的摄像机类型：*轨道*和*跟踪*。
- en: Normals receive special treatment whenever the object undergoes an affine transform.
    Normals are transformed by the Normal matrix, which can be obtained from the Model-View
    matrix.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象进行仿射变换时，法线会得到特殊处理。法线通过法线矩阵进行变换，该矩阵可以从模型视图矩阵中获得。
- en: The Projection matrix allows us to determine two basic projective modes: *orthographic*
    projection and *perspective* projection.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投影矩阵使我们能够确定两种基本的投影模式：*正交*投影和*透视*投影。
- en: In the next chapter, we will take what we've learned here about transformations
    to distinguish between global and local transformations. We will look at transformations
    that are *global*, as we've covered here, and transformations that are *local* to
    individual objects in our 3D scene.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何区分全局和局部变换。我们将研究那些*全局*变换，正如我们在这里所讨论的，以及那些针对我们3D场景中单个对象的*局部*变换。
