- en: Implementing Web Components using Polymer and Stencil
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Polymer和Stencil实现Web Components
- en: 'Up until now, we have built components using vanilla JavaScript with no dependencies.
    But sometimes, companies make a decision to use libraries that can help ease the
    workflow. In this chapter, we will look into two different libraries: Polymer
    and Stencil. In the background, these two libraries use Web Components, but both
    of them come with their own features. Let''s dive into these libraries.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用纯JavaScript和没有依赖项构建了组件。但有时，公司会做出决定使用可以帮助简化工作流程的库。在本章中，我们将探讨两个不同的库：Polymer和Stencil。在幕后，这两个库都使用了Web
    Components，但它们都带有自己的特性。让我们深入了解这些库。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Polymer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Polymer
- en: Stencil
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stencil
- en: Polymer
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Polymer
- en: Polymer is a library that lets you create custom elements in a really easy way.
    It comes with a set of features that can be used to create shadow DOM, add events,
    and use attributes and properties just like we have learned in previous chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Polymer是一个库，它允许你以非常简单的方式创建自定义元素。它自带了一组功能，可以用来创建shadow DOM，添加事件，以及使用属性和属性，就像我们在前面的章节中学到的那样。
- en: You can find the Polymer project at the following URL: [https://Polymer-library.Polymer-project.org/](https://polymer-library.polymer-project.org/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下URL找到Polymer项目：[https://Polymer-library.Polymer-project.org/](https://polymer-library.polymer-project.org/)。
- en: A major difference between the vanilla Web Components and Polymer is that Polymer
    comes with its own data system. That means you can make various computations and
    manipulations to the component based on this data. You can observe attribute and
    property changes, and you can even do two-way data binding, something that is
    missing from vanilla Web Components. The presence of these features helps with
    a lot of use cases, and helps with making the life of a developer easier.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 纯Web Components和Polymer之间一个主要的不同之处在于，Polymer自带了自己的数据系统。这意味着你可以根据这些数据进行各种计算和操作，以影响组件。你可以观察属性和属性的变化，甚至可以进行双向数据绑定，这是纯Web
    Components所缺少的。这些特性的存在有助于许多用例，并有助于使开发者的生活更加轻松。
- en: We will now take a look at how to use Polymer in more detail.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将详细探讨如何使用Polymer。
- en: Hello World in Polymer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Polymer中的Hello World
- en: 'Unlike vanilla Web Components, Polymer is a library that needs to be installed.
    But before we even have the library installed, we will be needing Polymer''s **Command
    Line Interface** (**CLI**) that come with its own server and testing framework.
    We can install it using the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与纯Web Components不同，Polymer是一个需要安装的库。但在我们安装库之前，我们将需要Polymer的**命令行界面**（**CLI**），它自带服务器和测试框架。我们可以使用以下命令来安装它：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And, once installed, you can check if it is installed by using the following
    command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，你可以使用以下命令来检查是否已安装：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that Polymer is installed, let''s try to create a `<hello-world>` component
    using this library. Let''s create a folder called `HelloWorld` and then create
    a file called `index.html`. The contents of this file can be very basic, like
    the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Polymer已安装，让我们尝试使用这个库创建一个`<hello-world>`组件。让我们创建一个名为`HelloWorld`的文件夹，然后创建一个名为`index.html`的文件。该文件的内容可以非常基础，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to run this file, instead of using `SimpleHTTPServer`, we will use
    a server that is provided by `Polymer-cli` itself. We can run the server by using
    the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此文件，我们不会使用`SimpleHTTPServer`，而是使用由`Polymer-cli`本身提供的服务器。我们可以使用以下命令来运行服务器：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you run this command, you should get a console output this in the Terminal:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行此命令，你应该在终端中看到以下控制台输出：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This shows that the server is running, and you can see the `index.html` file
    running on `http://127.0.0.1:8081/`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明服务器正在运行，你可以看到`index.html`文件正在`http://127.0.0.1:8081/`上运行。
- en: Now that our server is running and Polymer is installed, let's start writing
    our `<hello-world>` Polymer component.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们服务器正在运行，Polymer也已安装，让我们开始编写我们的`<hello-world>` Polymer组件。
- en: 'Since we are going to use the `Polymer` library, let''s install the library
    for this project:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用`Polymer`库，让我们为这个项目安装这个库：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, let''s create a file called `hello-world.js`. The contents of this file
    are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们创建一个名为`hello-world.js`的文件。该文件的如下内容：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are simply importing `Polymer` library that we just installed using `npm`
    command. Also, instead of using `HTMLElement`, we are using `PolymerElement`.
    And then, we are registering the class as a custom element.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是简单地导入我们刚刚使用`npm`命令安装的`Polymer`库。此外，我们不是使用`HTMLElement`，而是使用`PolymerElement`。然后，我们将这个类注册为一个自定义元素。
- en: 'The class definition will be a little bit different than vanilla Web Components:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类的定义将比原生的Web Components稍微复杂一些：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have the `constructor()` method, just like vanilla Web Components,
    but the `super()` method call doesn't have `props` in it. Also, we are not manually
    calling the `render()` method. Instead, the code is rendered automatically from
    the `template()` property.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有`constructor()`方法，就像原生的Web Components一样，但`super()`方法调用中没有`props`。此外，我们没有手动调用`render()`方法。相反，代码是从`template()`属性自动渲染的。
- en: We also need to keep in mind that unlike vanilla Web Components, we are not
    manually creating the shadow DOM for a Polymer element. Here, we use the `html`
    object from the `Polymer` library to stamp the `html` to the element's shadow
    DOM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要记住，与原生的Web Components不同，我们不是手动为Polymer元素创建shadow DOM。在这里，我们使用`Polymer`库中的`html`对象将`html`贴到元素的shadow
    DOM上。
- en: 'Now that the component is created, we can use it in our `index.html` file in
    the following way:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件已经创建，我们可以在`index.html`文件中以以下方式使用它：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we are simply importing the `hello-world.js` file, and then using the
    `<hello-world>` element directly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只是导入`hello-world.js`文件，然后直接使用`<hello-world>`元素。
- en: As you can see, the `Polymer` library helps a lot when it comes to saving the
    lines of code. And, with this example, you now know how to create a Polymer element.
    You can also try creating other elements that we have studied in the previous
    chapters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Polymer`库在节省代码行数方面非常有帮助。而且，通过这个例子，你现在知道如何创建一个Polymer元素。你还可以尝试创建我们在前几章中学到的其他元素。
- en: Nested elements in Polymer
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Polymer中的嵌套元素
- en: In the previous chapters, we looked at how different Web Components are used
    inside other Web Components to create complex and nested components. This methodology
    is not just limited to vanilla Web Components. We can use it inside Polymer components
    as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们探讨了如何在其他Web Components内部使用不同的Web Components来创建复杂和嵌套的组件。这种方法不仅限于原生的Web
    Components。我们也可以在Polymer组件内部使用它。
- en: 'Let''s say we have another `PolymerElement` that looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们还有一个类似这样的`PolymerElement`：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, it is not a complex element. In fact, it looks a lot like the
    `<hello-world>` element. Now, let''s say we want to include this `<second-element>`
    in the `<hello-world>` element. We can do it by changing the `<hello-world>` code
    in the following way:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它不是一个复杂的元素。实际上，它看起来非常像`<hello-world>`元素。现在，假设我们想在`<hello-world>`元素中包含这个`<second-element>`。我们可以通过以下方式更改`<hello-world>`代码来实现：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, you can see that we are importing the code from the `./second-element.js` file.
    And we are simply using it with the help of the `<second-element>` HTML code.
    It is that simple.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到我们正在从`./second-element.js`文件导入代码。我们只是通过`<second-element>`HTML代码简单地使用它。就这么简单。
- en: Also, if you notice the definition of the `<second-element>` class, you can
    see that we have used a style tag as well. We can make use of all the styles that
    we have studied in the previous chapters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你注意到`<second-element>`类的定义，你会发现我们也使用了一个样式标签。我们可以利用我们在前几章中学到的所有样式。
- en: Attributes and properties in Polymer
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Polymer中的属性和属性
- en: In the previous chapters, we saw how attributes and properties help make our
    Web Components better. They help with passing data, as well as keep track of the
    element's state. Similarly, we can do the same for elements built using Polymer
    as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们看到了属性和属性如何帮助我们使Web Components变得更好。它们有助于传递数据，以及跟踪元素的状态。同样，我们也可以为使用Polymer构建的元素做同样的事情。
- en: 'Let''s take a look at how properties work in Polymer. Let''s say we have an
    element that shows the text Hello, Prateek, where the string `Prateek` is a variable.
    The code would look something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看属性在Polymer中是如何工作的。假设我们有一个显示文本“Hello, Prateek”的元素，其中字符串`Prateek`是一个变量。代码看起来可能像这样：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, the only extra thing that we are adding is the `properties` getter function.
    The name of the property is `name`, and the default value is `''No Name Provided
    Yet''`. When you are using the element, you can either simply call the element,
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加的唯一额外内容是`properties`获取函数。属性的名称是`name`，默认值是`'No Name Provided Yet'`。当您使用元素时，您可以简单地调用元素，如下所示：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This would display the text Hello, No Name Provided Yet. Or, you can provide
    the name by adding an attribute like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示文本“Hello, No Name Provided Yet”。或者，您可以通过添加一个属性来提供名称，如下所示：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This would display the text Hello, Prateek. You can add multiple properties
    as well. For example, you can add `lastname` or `age` as properties as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示文本“Hello, Prateek”。您还可以添加多个属性。例如，您可以添加`lastname`或`age`作为属性。
- en: 'But what if you have nested components and this text is a variable coming from
    a parent component? Let''s take a look at what this code would look like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您有嵌套组件，并且这个文本是从父组件传来的变量呢？让我们看看这段代码会是什么样子：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we are passing the `name` property as a variable to the attribute in the
    `<hello-string>` element. This whole process is called **data-bindin****g**. If
    you would like to know more about data-binding in Polymer, you can visit the following
    link: [https://Polymer-library.Polymer-project.org/3.0/docs/devguide/data-binding](https://polymer-library.polymer-project.org/3.0/docs/devguide/data-binding).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`name`属性作为变量传递给`<hello-string>`元素中的属性。整个过程被称为**数据绑定**。如果您想了解更多关于Polymer中的数据绑定信息，可以访问以下链接：[https://Polymer-library.Polymer-project.org/3.0/docs/devguide/data-binding](https://polymer-library.polymer-project.org/3.0/docs/devguide/data-binding)。
- en: With the help of these concepts, you should be able to create Polymer elements
    with ease.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些概念的帮助下，您应该能够轻松地创建Polymer元素。
- en: Stencil
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stencil
- en: Stencil is a compiler for Web Components. It uses TypeScript and JSX to create
    Web Components. It even comes with a lot of features that are missing in the vanilla
    Web Components that can be used to make good single-page web apps.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Stencil是一个Web组件的编译器。它使用TypeScript和JSX来创建Web组件。它甚至包含了许多在vanilla Web组件中缺失的功能，可以用来制作好的单页Web应用。
- en: 'Let''s get a better idea of what Stencil can do with the help of a `<hello-world>` component.
    This component required a little understanding of TypeScript as well as JSX. If
    at any point in time you would like to take a look at the docs, you can find them
    here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个`<hello-world>`组件来更好地了解Stencil能做什么。这个组件需要一点TypeScript和JSX的理解。如果您在任何时候想查看文档，可以在这里找到：[https://Stencil-project.org/docs](https://Stencil-project.org/docs)。
- en: '**TypeScript**: [https://www.typescriptlang.org/](https://www.typescriptlang.org/).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**: [https://www.typescriptlang.org/](https://www.typescriptlang.org/).'
- en: '**JSX**: [https://reactjs.org/docs/introducing-jsx.html](https://reactjs.org/docs/introducing-jsx.html).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSX**: [https://reactjs.org/docs/introducing-jsx.html](https://reactjs.org/docs/introducing-jsx.html).'
- en: I will try to keep my code as simple as possible so that you don't have to look
    at the docs. Now that we have that out of the way, let's create a hello-world
    component using Stencil.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我会尽量使我的代码尽可能简单，这样您就不必查看文档。现在我们已经解决了这个问题，让我们使用Stencil创建一个hello-world组件。
- en: The Hello World Stencil component
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World Stencil组件
- en: 'Stencil comes with a lot of features to build components. Let''s first set
    up our folder to write a component. You can do so by typing the following command
    in the Terminal:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Stencil提供了许多功能来构建组件。让我们首先设置文件夹来编写组件。您可以在终端中输入以下命令来完成此操作：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will be shown a bunch of options, from which you can select the component.
    On selecting the component option, feel free to enter a name for the project.
    I chose `stenciljs-app`. And this would print out an output that looks something
    like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一系列选项，从中您可以选择组件。在选择组件选项后，您可以自由地为项目输入名称。我选择了`stenciljs-app`。这将打印出类似以下内容的输出：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will create a starter project with a default component in it. You can
    run the project by typing the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含默认组件的起始项目。您可以通过输入以下命令来运行项目：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will run the `stenciljs-app` project on `localhost:3333` in the browser.
    It will also show the default component, `<my-component>`, as a part of the output.
    This is technically the `<hello-world>` component provided by default inside our
    project. But we will create our own `<hello-world>` component from scratch.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在浏览器中的`localhost:3333`上运行`stenciljs-app`项目。它还将显示默认组件`<my-component>`作为输出的一部分。从技术上讲，这是我们在项目中默认提供的`<hello-world>`组件。但我们将从头开始创建自己的`<hello-world>`组件。
- en: 'In order to create our `<hello-world>` component, we need to first complete
    some pre-requisites. These are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的 `<hello-world>` 组件，我们首先需要完成一些先决条件。这些如下：
- en: Create a folder called `hello-world` inside the `src/components` folder.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/components` 文件夹内创建一个名为 `hello-world` 的文件夹。
- en: Create a file called `hello-world.tsx` inside this `hello-world` folder. We
    are using the `.tsx` extension because it is a TypeScript file. Stencil will compile
    this file to a `.js` file. We do not have to worry about it.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个 `hello-world` 文件夹内创建一个名为 `hello-world.tsx` 的文件。我们使用 `.tsx` 扩展名，因为它是一个 TypeScript
    文件。Stencil 会将此文件编译为 `.js` 文件。我们不需要担心这一点。
- en: Create another file called `hello-world.css` inside the `hello-world` folder.
    This is where we will be writing the CSS for this component.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `hello-world` 文件夹内创建另一个名为 `hello-world.css` 的文件。这是我们将会为这个组件编写 CSS 的地方。
- en: 'Now that we have the setup complete for the `<hello-world>` component, let''s
    start writing the code for it. This is what `hello-world.tsx` looks like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 `<hello-world>` 组件的设置，让我们开始为其编写代码。这就是 `hello-world.tsx` 的样子：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the first line, we are importing the `Component` and `h` objects from the
    `stencil` library. When we talk about technical jargon, we will be calling this `@Component`
    as `@Component` decorator. As we can see, we are simply stating the tag for the
    component, the CSS it needs to use for styling, and whether the component needs
    to render in a shadow DOM or not. Inside the `HelloWorld` class, we are simply
    returning the JSX for this component. If you are from the React background, then
    it should be pretty straightforward. But if you are new to JSX, for the sake of
    simplicity, you can think of it as a way to write HTML inside JavaScript.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们正在从 `stencil` 库中导入 `Component` 和 `h` 对象。当我们谈论技术术语时，我们将称之为 `@Component`
    装饰器。正如我们所见，我们只是声明了组件的标签、它需要的 CSS 样式以及组件是否需要在阴影 DOM 中渲染。在 `HelloWorld` 类中，我们只是返回这个组件的
    JSX。如果你来自 React 背景，那么这应该非常简单。但如果你是 JSX 新手，为了简单起见，你可以将其视为在 JavaScript 中编写 HTML
    的方式。
- en: So, we have now created our first Stencil component. Now, to see it on the web
    page, you can simply add the `<hello-world>` tag in the `index.html` file inside
    the `src` directory. Stencil will pick it up automatically, create its include,
    and compile it for you. You just have to refresh the page.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经创建了我们的第一个 Stencil 组件。现在，为了在网页上看到它，你只需在 `src` 目录下的 `index.html` 文件中添加
    `<hello-world>` 标签。Stencil 会自动将其拾取，创建其包含文件，并为你编译。你只需要刷新页面。
- en: Now that we know how to create a Stencil component, let's dive into the next
    section where we create nested Stencil Components.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建一个 Stencil 组件，接下来让我们深入下一节，学习如何创建嵌套的 Stencil 组件。
- en: Nested Stencil components
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套的 Stencil 组件
- en: In the last section, we looked into the `@Component` decorator and how it helps
    create a Stencil component. In this section, we will use one more decorator called
    the `@Prop` decorator to declare the variables that will act as properties which
    can be passed onto other components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了 `@Component` 装饰器以及它是如何帮助创建 Stencil 组件的。在本节中，我们将使用另一个名为 `@Prop` 装饰器的装饰器来声明将作为属性传递给其他组件的变量。
- en: 'Let''s create an element that shows us a list of students, called `<student-list>`.
    In Stencil, it would look something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个显示学生列表的元素，称为 `<student-list>`。在 Stencil 中，它看起来像这样：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we are doing the same thing as we have done in the `<hello-world>` component.
    We are simply importing the `stencil` library, then setting the name of the component
    and CSS styles in the `@Component` decorator. And, in the class, we have a component
    called `<student-name>` that has the first and last name as attributes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在做与 `<hello-world>` 组件中相同的事情。我们只是导入 `stencil` 库，然后在 `@Component` 装饰器中设置组件的名称和
    CSS 样式。然后，在类中，我们有一个名为 `<student-name>` 的组件，它将名字和姓氏作为属性。
- en: 'Let''s take a look at the definition of this `<student-name>` component:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `<student-name>` 组件的定义：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, if we look inside the `StudentName` class, we can see that we are using
    the `@Prop` decorator. With the help of this `@Prop` decorator, we are defining
    two properties: `first` and `last`. The `first` property also has `reflectToAttr`
    set to `true`, which means that this property can be seen as an attribute when
    it gets called inside the `<student-list>` component:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们查看 `StudentName` 类，我们可以看到我们正在使用 `@Prop` 装饰器。借助这个 `@Prop` 装饰器，我们定义了两个属性：`first`
    和 `last`。`first` 属性还将 `reflectToAttr` 设置为 `true`，这意味着当它在 `<student-list>` 组件内部调用时，这个属性可以被视为一个属性：
- en: '![](img/da615635-b5bb-4223-a360-b511f4424783.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da615635-b5bb-4223-a360-b511f4424783.png)'
- en: Here, we can see the attribute first in the shadow DOM for this component. But
    since we did not set `reflectToAttr` to `true` for the `last` property, it doesn't
    get reflected in the attribute.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这个组件的阴影 DOM 中首先出现的是属性。但由于我们没有将 `reflectToAttr` 设置为 `true` 对于 `last`
    属性，它不会反映在属性中。
- en: Also, if you notice the definition of the `<student-list>` component, we did
    not import the `<student-name>` component. We simply started using the element.
    Stencil is smart enough to pick up these changes and auto-include them in the
    files. This way, we can create nested elements without worrying about the imports.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你注意到 `<student-list>` 组件的定义，我们没有导入 `<student-name>` 组件。我们只是开始使用这个元素。Stencil
    足够智能，能够捕捉这些变化并自动将它们包含在文件中。这样，我们就可以创建嵌套元素而不用担心导入。
- en: Now that we know how to create nested components using Stencil, let's look at
    one of the ways to achieve performance on to the web page we are trying to create.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何使用 Stencil 创建嵌套组件，让我们来看看实现我们试图创建的网页性能的一种方法。
- en: Pre-rendering for Stencil components
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stencil 组件的预渲染
- en: When we talk about rending a single page web app, we are basically sending all
    the resources onto the page and then letting the client do all the computations
    to build the page. This is a computational-heavy process, which may lead to longer
    times to first meaningful paint on the site.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论渲染单页 Web 应用时，我们基本上是将所有资源发送到页面上，然后让客户端进行所有计算以构建页面。这是一个计算密集型的过程，可能会导致网站首次有意义的绘制时间更长。
- en: To solve this problem, Stencil comes with pre-rendering on by default. Pre-rendering
    lets the server generate static HTML, CSS, and JavaScript files at build time,
    and can then be hydrated with the data for that page. This lets users see the
    page faster, lets the search engine crawlers browse the site for SEO faster, and
    lets the user see the page even when the JavaScript is disabled on the client
    side.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Stencil 默认开启了预渲染功能。预渲染允许服务器在构建时生成静态的 HTML、CSS 和 JavaScript 文件，然后可以用该页面的数据进行激活。这使用户能够更快地看到页面，让搜索引擎爬虫更快地浏览网站以进行
    SEO，即使在客户端禁用了 JavaScript，用户也能看到页面。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create Polymer and Stencil components. We
    looked into how these components can be nested to form more complex elements.
    We also looked into how attributes and properties can be passed into child components
    in both Polymer and Stencil components.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建 Polymer 和 Stencil 组件。我们探讨了这些组件如何嵌套以形成更复杂的元素。我们还研究了如何在 Polymer
    和 Stencil 组件中传递属性和属性到子组件。
- en: We also looked into the pre-rendering feature of Stencil, and how it can be
    used to make a site perform better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了 Stencil 的预渲染功能以及它是如何被用来提高网站性能的。
- en: In the next chapter, we will look into how vanilla Web Components can be used
    in various other libraries and frameworks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨纯 Web 组件如何在各种其他库和框架中使用。
