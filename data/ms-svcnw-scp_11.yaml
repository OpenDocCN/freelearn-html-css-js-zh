- en: Deployments with the Update Sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更新集的部署
- en: In this chapter, we will be looking at how to use update sets. Update sets are
    a big part of ServiceNow and move new functionality from non-production instances
    to production instances with minimal risk. We will look at when and how to use
    update sets, as well as how to use them to transfer functionality from one instance
    to another. After this, we will explore pitfalls to be avoided and best practices
    for update sets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用更新集。更新集是ServiceNow的一个重要部分，以最小的风险将新功能从非生产实例移动到生产实例。我们将探讨何时以及如何使用更新集，以及如何使用它们将功能从一个实例转移到另一个实例。之后，我们将探讨要避免的陷阱和更新集的最佳实践。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: When to use update sets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用更新集
- en: How to use scope with update sets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用范围与更新集一起使用
- en: Transferring update sets between instances
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实例之间传输更新集
- en: Update set pitfalls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新集陷阱
- en: Update set best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新集最佳实践
- en: When to use update sets
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用更新集
- en: Update sets are used in ServiceNow to move functionality from one instance to
    another. If you are making some changes in a development instance which you would
    like to later move to a production instance, then update sets are recommended.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 更新集在ServiceNow中用于将功能从一个实例移动到另一个实例。如果你在开发实例中进行了某些更改，你希望稍后将其移动到生产实例，那么建议使用更新集。
- en: An update set captures changes that you make to an instance, inside the update
    set, while they are being made. Once all the changes that you would like captured
    are finished, the update set is complete and is ready to be moved to another instance.
    When moved to another instance, the update set can be previewed to check that
    the changes are compatible with the instance and committed to apply the changes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 更新集捕捉你在实例内所做的更改，在它们被创建的同时。一旦你想要捕捉的所有更改都完成，更新集就完成了，并准备好移动到另一个实例。当移动到另一个实例时，可以预览更新集以检查更改是否与实例兼容，并提交以应用更改。
- en: Before making any changes that you intend to move to another instance, your
    first task should be to create a new update set to contain those changes. Before
    you start making changes, ensure that you are working inside the update set. Once
    the updates are complete, complete the update set that is ready to move to another
    instance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在对任何打算移动到另一个实例的更改进行更改之前，你的第一个任务应该是创建一个新的更新集来包含这些更改。在你开始进行更改之前，确保你正在更新集内工作。一旦更新完成，完成准备移动到另一个实例的更新集。
- en: How to use scope with update sets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用范围与更新集一起使用
- en: When using update sets, we need to remember what scope we are currently working
    in. Before we use any kind of scope in an instance, we are in the global scope,
    and before we create any update sets in an instance, we are in the default update
    set.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用更新集时，我们需要记住我们当前正在哪个范围内工作。在我们在一个实例中使用任何类型的范围之前，我们处于全局范围，在我们在一个实例中创建任何更新集之前，我们处于默认更新集。
- en: If we are not in a created update set, then we will also be in the default update
    set. However, there is a different default update set for each scope in a ServiceNow
    instance. This is important to know so that if you do switch scopes, then your
    update set automatically changes, as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不在创建的更新集中，那么我们也将处于默认更新集中。然而，ServiceNow实例中的每个范围都有一个不同的默认更新集。了解这一点很重要，这样如果确实切换了范围，那么你的更新集也会自动更改。
- en: 'We can see this change in the update set picker if we change the scope we are
    working on in an instance. In *Figure 11.1*, we can see an instance in the Global
    scope:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在实例中更改我们正在工作的范围，我们可以在更新集选择器中看到这种变化。在*图11.1*中，我们可以看到一个全局范围内的实例：
- en: '![](img/8c514327-d286-4872-8b70-0ce942066cc4.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c514327-d286-4872-8b70-0ce942066cc4.png)'
- en: 'Figure 11.1: Application and update set picker in the global scope'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：全局范围内的应用程序和更新集选择器
- en: Because we are in the Global scope, the default update set selected for us is
    the default update set for the Global scope. We can see that this is shown to
    us by the ServiceNow instance by the text inside the square brackets in the update
    set picker.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们处于全局范围，所以为我们选择的默认更新集是全局范围的默认更新集。我们可以通过服务现在实例在更新集选择器中显示的方括号内的文本看到这一点。
- en: If we change only the application, and, therefore, the scope, we can see the
    change in the update picker, too. Let's change the application to Guided Setup
    as an example, to see the change.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只更改应用程序，因此范围，我们也可以在更新选择器中看到变化。让我们以将应用程序更改为引导设置为例，以查看变化。
- en: 'We can see these changes in *Figure 11.2*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图11.2*中看到这些更改：
- en: '![](img/6f280dff-ef1a-4021-969e-2ff454cedafe.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f280dff-ef1a-4021-969e-2ff454cedafe.png)'
- en: 'Figure 11.2: Application and update set picker in the guided setup scope'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：在引导设置范围内应用和更新集选择器
- en: As you can see, the update set is automatically changed for us. This means that
    there can be a number of different default update sets in an instance, and each
    application will have its own.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，更新集会自动为我们更改。这意味着一个实例中可能有多个不同的默认更新集，并且每个应用程序都将有自己的更新集。
- en: The example brings us nicely on to another point about using update sets in
    different scopes. Each update set can only exist in a single scope. Before creating
    an update set, ensure that you are currently in the correct scope, so that changes
    you make can be added to the update set. Once created, ServiceNow security stops
    anyone from writing to the application field of an update set. This is set by
    a security rule and should not be amended.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很好地引出了关于在不同范围内使用更新集的另一个观点。每个更新集只能存在于一个范围内。在创建更新集之前，请确保您当前处于正确的范围内，以便您所做的更改可以添加到更新集中。一旦创建，ServiceNow
    安全性将阻止任何人向更新集的应用程序字段写入。这是由安全规则设置的，不应修改。
- en: Transferring update sets between instances
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实例之间传输更新集
- en: Once an update set has been completed, it is ready to be transferred to another
    instance.  Transferring update sets between instances takes a few steps, and once
    initially set up, it can be a quick process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新集完成，它就准备好转移到另一个实例。在实例之间传输更新集需要几个步骤，一旦最初设置好，它就可以是一个快速的过程。
- en: To start the process of moving an update set between two instances, we first
    need to log in to the instance we want to move the update set to, or the destination
    instance. Then we navigate to System Update Sets | Update Sources and click New.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在不同实例之间移动更新集的过程，我们首先需要登录到我们想要移动更新集到的实例，即目标实例。然后我们导航到系统更新集 | 更新源并点击新建。
- en: 'We can see the new update source screen in *Figure 11.3*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图 11.3*中看到新的更新源屏幕：
- en: '![](img/cc6f5d76-370e-42e2-8763-bbb75457e2c2.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc6f5d76-370e-42e2-8763-bbb75457e2c2.png)'
- en: 'Figure 11.3: New update source form'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：新的更新源表单
- en: On this form, there are some key fields to fill in. Let's start with the mandatory
    fields first: Name and URL. The Name field is exactly that – a name to give to
    our update source so a system admin can easily recognize this update source. This
    is often the name of the instance we are taking the update set from, or the source
    instance. The URL field needs to be the URL of the source instance in the format
    `<instance_name>.service-now.com`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在此表单中，有一些关键字段需要填写。让我们先从必填字段开始：名称和 URL。名称字段正是如此——为我们的更新源提供一个名称，以便系统管理员可以轻松识别此更新源。这通常是我们要从其中获取更新集的实例名称或源实例。URL
    字段需要是源实例的 URL，格式为 `<instance_name>.service-now.com`。
- en: The other important fields on this form are the Username and Password fields.
    These need to be a username and password for the source instance, and the account
    has to be an admin account for that instance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单上的其他重要字段是用户名和密码字段。这些需要是源实例的用户名和密码，并且该账户必须是该实例的管理员账户。
- en: The Type and Short description fields can also be filled in to add extra labels
    to help identify the update source. Once the form is complete, click Test connection
    to ensure that the source instance can be accessed. If the connection fails, you
    may need to check the information you provided and make sure the source instance
    can be accessed and does not have any IP access controls that could be causing
    a failure.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类型字段和简短描述字段也可以填写以添加额外的标签来帮助识别更新源。一旦表单填写完成，点击测试连接以确保可以访问源实例。如果连接失败，您可能需要检查您提供的信息并确保源实例可以访问且没有可能导致失败的任何
    IP 访问控制。
- en: If the connection is a success, then the form can be saved. Once an update source
    has been saved, we can then start to bring in update sets from the source instance.
    A related link called Retrieve Completed Update Sets is now available to click.
    Once this is selected, all completed update sets will be transferred to the destination
    instance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接成功，则可以保存表单。一旦保存了更新源，我们就可以开始从源实例引入更新集。现在有一个相关的链接“检索完成更新集”可供点击。一旦选择，所有完成的更新集将被转移到目标实例。
- en: Remember to complete any update sets you want to move to another instance, as
    incomplete update sets will not be moved.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住完成您想要移动到另一个实例的所有更新集，因为不完整的更新集将不会移动。
- en: To see the update sets that have been moved to the destination instance, we
    can navigate to System Update Sets | Retrieved Update Sets. Now that the update
    set exists in the destination instance, we need to apply the customization to
    the destination instance, too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看已移动到目标实例的更新集，我们可以导航到系统更新集 | 获取的更新集。现在更新集已存在于目标实例中，我们还需要将自定义更改应用到目标实例。
- en: The update sets that have been retrieved should have been automatically previewed;
    however, in older instances, this may not be the case, and it may need to be done
    manually. Sometimes a preview may bring up some warnings or errors that need to
    be reviewed before an update set can be committed. This can mean that there are
    missing tables or that a newer update for a particular customization exists on
    the destination instance. Most of the time, these errors and warnings still end
    up with the remote update being accepted and committed, but review each one to
    ensure you should be committing all the updates.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 获取的更新集应该已经被自动预览；然而，在较旧的实例中，这可能不是情况，可能需要手动完成。有时预览可能会引发一些警告或错误，在提交更新集之前需要审查。这可能意味着缺少表或目标实例上存在特定自定义的新更新。大多数时候，这些错误和警告最终都会导致远程更新被接受和提交，但请审查每一个以确保您应该提交所有更新。
- en: Once the preview process is complete, you can commit your update set. This will
    add all of the customizations in the update set from the source instance to the
    destination instance, excluding any marked to skip as part of the preview process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 预览过程完成后，您可以提交您的更新集。这将把源实例中的所有自定义更改添加到目标实例中，排除在预览过程中标记为跳过的任何更改。
- en: When the commit is complete, you have successfully transferred an update set
    from one instance to another.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 提交完成后，您已成功将更新集从一个实例转移到另一个实例。
- en: Update set pitfalls
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新集陷阱
- en: Update sets are a great way to move configurations between instances. However,
    when using update sets, there are some pitfalls that can easily be fallen into.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更新集是移动实例之间配置的绝佳方式。然而，在使用更新集时，有一些陷阱很容易陷入。
- en: The main issue that most developers face is what customization will be added
    to an update set. Not all changes to tables are added to update sets. Whether
    changes to a table are added to an update set or not depends on whether the records
    in the table are considered data or not. Tables that are considered as data are
    not added to an update set; as otherwise, update sets would be filled with unnecessary
    records.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者面临的主要问题是更新集中将添加哪些自定义更改。并非所有对表的更改都会添加到更新集中。一个表中的更改是否添加到更新集中取决于表中的记录是否被视为数据。被视为数据的表不会被添加到更新集中；否则，更新集将充满不必要的记录。
- en: For example, if the incident table was included in update sets, any incidents
    modified or created in a development instance would be moved across to a production
    instance, which would not be a good idea. Most tables are included or excluded
    from update sets as you would expect, but some are not always obvious, so it is
    worth checking.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果事件表包含在更新集中，那么在开发实例中修改或创建的事件将被移动到生产实例中，这并不是一个好主意。大多数表如预期的那样包含或排除在更新集中，但有些可能并不总是明显，因此值得检查。
- en: To avoid missing updates in our update sets or including updates we do not want,
    we can check to see which tables we are working with and send updates to an update
    set. To do this, we can look at the dictionary entry of the table we are working
    with.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在我们的更新集中遗漏更新或包含我们不想要的更新，我们可以检查我们正在处理的表，并将更新发送到更新集。为此，我们可以查看我们正在处理的表的字典条目。
- en: From the list of dictionary entries for a table, we are interested in the record
    with a type of Collection. This gives the definition of the table and also holds
    the attributes for the table, which is what we need to look at. The attribute
    that adds updates to a table to update sets is called Update synch, and it needs
    to be true. Usually, if this attribute has been added it will be set to true,
    and if it is omitted then it will be false.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个表的字典条目列表中，我们关注的是类型为集合的记录。这给出了表的定义，并持有表的属性，这是我们需要的。向表中添加更新到更新集的属性称为更新同步，它需要设置为真。通常，如果已添加此属性，它将被设置为真，如果省略则将为假。
- en: 'Let''s have a look at the dictionary entry for the incident table shown in
    *Figure 11.4*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看*图11.4*中所示的事件表的字典条目：
- en: '![](img/e1e6d83e-920f-4947-91ee-e71f8652734e.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1e6d83e-920f-4947-91ee-e71f8652734e.png)'
- en: 'Figure 11.4: Dictionary entry for the incident table'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：事件表的字典条目
- en: As the incident table holds incident data, we do not want incident records in
    our update sets. As we can see, the Update synch attribute does not appear here,
    so any incidents we create or modify will not end up in the update set.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件表包含事件数据，我们不希望我们的更新集中有事件记录。正如我们所见，更新同步属性在这里没有出现，因此我们创建或修改的任何事件都不会出现在更新集中。
- en: 'Now let''s see the dictionary entry for client scripts. We can see this in
    *Figure 11.5*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看客户端脚本的字典条目。我们可以在*图11.5*中看到这一点：
- en: '![](img/55b327eb-c097-4d84-8590-5d3b78c64e9c.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55b327eb-c097-4d84-8590-5d3b78c64e9c.png)'
- en: 'Figure 11.5: Dictionary entry for the client script table'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：客户端脚本表的字典条目
- en: In the Attributes of the client script dictionary entry, we can see the Update
    synch attribute, and it is set to true. This means that client script records
    will be added to update sets.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端脚本字典条目的属性中，我们可以看到更新同步属性，并且它被设置为true。这意味着客户端脚本记录将被添加到更新集中。
- en: One table that is not included in update sets that is often assumed to be included
    is the scheduled job table. Because most records containing script are added to
    update sets, this can often catch developers out. A scheduled job can be moved
    by exporting it to XML and importing it into another instance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通常被认为包含在更新集中但实际不包括的表是计划任务表。由于大多数包含脚本的记录都被添加到更新集中，这往往会让开发者感到意外。可以通过将其导出为XML并将其导入另一个实例来移动计划任务。
- en: In contrast, the table that many developers do not realize will be added to
    update sets is the `System Properties` table. Sometimes settings for developer
    instances, such as notifications set up to stop notifications being sent out,
    can end up being transferred to a production instance by mistake. This is a pitfall
    I have seen a few times over the years.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，许多开发者没有意识到将被添加到更新集中的表是`系统属性`表。有时开发者实例的设置，如设置为停止发送通知的通知，可能会意外地转移到生产实例。这是我多年来看到的一些陷阱。
- en: Update set best practices
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新集最佳实践
- en: When using update sets, there are some best practices we can adhere to to ensure
    we avoid adding bad customizations to our production instance and use update sets
    to their full potential.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用更新集时，有一些最佳实践我们可以遵循，以确保我们不会向我们的生产实例添加不良的自定义设置，并充分利用更新集。
- en: Firstly, it is always a good idea to check the updates contained in your update
    set before completing it. Sometimes a developer can inadvertently add an update
    they did not mean to to their update set. Therefore, it is always a good idea
    to check each individual update contained in your update set. In particular, pay
    special attention to any updates where the action is `DELETE`, as this can be
    harder to undo.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在完成更新集之前检查其中包含的更新总是一个好主意。有时开发者可能会无意中向他们的更新集添加他们本不想添加的更新。因此，检查更新集中包含的每个单独的更新总是一个好主意。特别是，要特别注意任何操作为`DELETE`的更新，因为这可能更难撤销。
- en: 'We can see some example updates in an update set in *Figure 11.6*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图11.6*中的更新集中看到一些示例更新：
- en: '![](img/6188356d-ecac-48f2-a431-7cfc4d37e899.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6188356d-ecac-48f2-a431-7cfc4d37e899.png)'
- en: 'Figure 11.6: Update set containing sample updates'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：包含示例更新的更新集
- en: We can see the updates in this update set in the Customer Updates tab of the
    related lists. We can see three updates in the update set example, including two
    client scripts and a business rule. We need to ensure that every customer update
    we see is a change we want to include in this update set, and no additional updates
    have been included in this update set by mistake.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在相关列表的客户更新选项卡中看到这个更新集中的更新。在更新集示例中，我们可以看到三个更新，包括两个客户端脚本和一个业务规则。我们需要确保我们看到的每个客户更新都是我们想要包含在这个更新集中的更改，并且没有意外包含额外的更新。
- en: In the Action column, the action that will be taken when this update set is
    committed is shown. Of the three updates, we want to pay special attention to
    the one with the DELETE action to ensure this action does indeed need to be taken.
    Once a record is deleted, it can be more difficult to undo the action. An insert
    or update is a much easier update to change or revert to an earlier version.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作列中，显示在提交此更新集时将执行的操作。在三个更新中，我们特别关注具有DELETE操作的更新，以确保确实需要执行此操作。一旦记录被删除，撤销操作可能更困难。插入或更新是一个更容易更改或回滚到早期版本的更新。
- en: It is also a good idea to have a naming convention for your update sets. At
    first ,when update sets are small in number, this seems unnecessary; but as an
    instance matures and the number of update sets grows, it can be extremely helpful.
    The naming convention does not need to be complex, just consistent. Common naming
    conventions can be for releases, sprints, or the record number of stories or defects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的更新集制定一个命名约定也是一个好主意。起初，当更新集数量较少时，这似乎是不必要的；但随着实例的成熟和更新集数量的增加，这可以非常有帮助。命名约定不需要复杂，只需保持一致即可。常见的命名约定可以是发布、冲刺，或者是故事或缺陷的记录编号。
- en: 'Some examples of naming conventions are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定的几个例子包括：
- en: Description - Release - Date
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Description - Release - Date
- en: 'Story/Defect: Developer'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Story/Defect: Developer'
- en: Sprint/Month
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sprint/Month
- en: When deciding on a naming convention, decide on the details that are relevant
    for your process and instance, and make sure the convention is adhered to.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定命名约定时，要确定与你的流程和实例相关的细节，并确保遵守这一约定。
- en: As we saw earlier in this chapter, when setting up an update source, we need
    to provide a username and password for an admin account for the instance we are
    taking update sets from. It is good practice to ensure the account details used
    for the update source are for an account that will not be amended frequently,
    as this will stop the update source from being able to pull update sets from that
    instance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，在设置更新源时，我们需要为从该实例获取更新集的实例提供一个管理员账户的用户名和密码。确保用于更新源的账户细节不会频繁更改是一个好的做法，因为这将阻止更新源从该实例拉取更新集。
- en: With update sets, it is good practice to ensure that update sets being committed
    in a production instance are done so at an appropriate time. As with any change
    to a production system, there is a level of risk associated. This means committing
    update sets should be done outside of business hours if possible, or at least
    at a quiet period of time, in case any problems arise.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新集时，确保在生产实例中提交的更新集是在适当的时间进行的，这是一个好的做法。与对生产系统的任何更改一样，都存在一定程度的风险。这意味着如果可能的话，应该在业务时间之外提交更新集，或者至少在安静的时间段，以防出现任何问题。
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Summary
- en: We looked at update sets in this chapter. We saw how to use update sets and
    how they are used with different application scopes. In this chapter, we also
    explored transferring update sets between instances, avoiding pitfalls for update
    sets, and best practices when using update sets, especially when checking each
    update set update.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们探讨了更新集。我们看到了如何使用更新集以及它们如何与不同的应用程序范围一起使用。在本章中，我们还探讨了在实例之间转移更新集、避免更新集的陷阱以及使用更新集的最佳实践，尤其是在检查每个更新集更新时。
- en: In the final chapter, we will use all that we have learned to build a custom
    application in ServiceNow. We will look at how to create a custom application
    and, specifically, how to use script in a custom application. We will discover
    end-to-end development of a custom application, as well as how to test and deploy
    the custom application we have made.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将利用所学知识在ServiceNow中构建一个自定义应用程序。我们将探讨如何创建自定义应用程序，特别是如何在自定义应用程序中使用脚本。我们将发现自定义应用程序的端到端开发，以及如何测试和部署我们所制作的自定义应用程序。
