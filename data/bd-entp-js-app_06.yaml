- en: Storing Data in Elasticsearch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Elasticsearch 中存储数据
- en: In the previous chapter, we developed the bulk of our Create User feature by
    following a TDD process and writing all our E2E test cases first. The last piece
    of the puzzle is to actually persist the user data into a database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过遵循 TDD 流程并首先编写所有端到端测试用例来开发了大部分的创建用户功能。最后一部分是实际上将用户数据持久化到数据库中。
- en: 'In this chapter, we will install and run **ElasticSearch** on our local development
    machine, and use it as our database. Then, we will implement our last remaining
    step definition, using it to drive the development of our application code. Specifically,
    we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在本地开发机器上安装和运行 **ElasticSearch**，并将其用作我们的数据库。然后，我们将实现我们最后剩余的步骤定义，使用它来驱动我们的应用程序代码的开发。具体来说，我们将涵盖以下内容：
- en: Installing Java and Elasticsearch
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Java 和 Elasticsearch
- en: Understanding Elasticsearch concepts, such as **indices**, **types**, and **documents**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Elasticsearch 概念，例如 **索引**、**类型**和**文档**
- en: Using the Elasticsearch JavaScript client to complete our create user endpoint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Elasticsearch JavaScript 客户端完成我们的创建用户端点
- en: Writing a Bash script to run our E2E tests with a single command
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 Bash 脚本来使用单个命令运行我们的端到端测试
- en: Introduction to Elasticsearch
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elasticsearch 简介
- en: So, what is Elasticsearch? First and foremost, Elasticsearch should not be viewed
    as a single, one-dimensional tool. Rather, it's a suite of tools that consists
    of a **distributed database**, a **full-text search engine**, and also an **analytics
    engine**. We will focus on the "database" part in this chapter, dealing with the
    "distributed" and "full-text search" parts later.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Elasticsearch 是什么呢？首先，Elasticsearch 不应被视为一个单一、一维的工具。相反，它是一套工具，包括一个**分布式数据库**、一个**全文搜索引擎**，以及一个**分析引擎**。在本章中，我们将重点关注“数据库”部分，稍后处理“分布式”和“全文搜索”部分。
- en: At its core, Elasticsearch is a high-level abstraction layer for **Apache Lucene**,
    a full-text search engine. Lucene is arguably the most powerful full-text search
    engine around; it is used by **Apache Solr**, another search platform similar
    to Elasticsearch. However, Lucene is very complex and the barrier to entry is
    high; thus Elasticsearch abstracts that complexity away into a RESTful API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Elasticsearch 是一个针对 Apache Lucene 的高级抽象层，Apache Lucene 是一个全文搜索引擎。Lucene
    可以说是最强大的全文搜索引擎之一；它被 Apache Solr 使用，另一个类似于 Elasticsearch 的搜索平台。然而，Lucene 非常复杂，入门门槛高；因此，Elasticsearch
    将这种复杂性抽象成 RESTful API。
- en: Instead of using Java to interact with Lucene directly, we can instead send
    HTTP requests to the API. Furthermore, Elasticsearch also provides many language-specific
    clients that abstract the API further into nicely-packaged objects and methods.
    We will be making use of Elasticsearch's JavaScript client to interact with our
    database.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用 Java 与 Lucene 交互，而不是发送 HTTP 请求到 API。此外，Elasticsearch 还提供了许多特定语言的客户端，它们将
    API 进一步抽象成包装良好的对象和方法。我们将使用 Elasticsearch 的 JavaScript 客户端来与我们的数据库交互。
- en: You can find the documentation for the most current JavaScript client at [https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html)
    找到最新 JavaScript 客户端的文档。
- en: Elasticsearch versus other distributed document store
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elasticsearch 与其他分布式文档存储的比较
- en: For simple document storage, you'd typically pick a general-purpose database
    like MongoDB, and store **normalized** data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的文档存储，你通常会选择一个通用数据库，如 MongoDB，并存储**规范化**的数据。
- en: Normalization is the process of reducing data redundancy and improving data
    integrity by ensuring components of the data structure are atomic elements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化是通过确保数据结构组件是原子元素来减少数据冗余并提高数据完整性的过程。
- en: Denormalization is the process of introducing data redundancy for other benefits,
    such as performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 反规范化是通过引入数据冗余以获得其他好处的过程，例如性能。
- en: However, searching on normalized data is extremely inefficient. Therefore, to
    perform a full-text search, you would usually **denormalize** the data and replicate
    it onto more specialized database such as Elasticsearch.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在规范化数据上搜索效率极低。因此，为了执行全文搜索，你通常会**反规范化**数据并将其复制到更专业的数据库，如 Elasticsearch。
- en: 'Therefore, in most setups, you would have to run two different databases. However,
    in this book, we will use Elasticsearch for both data storage and search, for
    the following reasons:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在大多数设置中，您可能需要运行两个不同的数据库。然而，在这本书中，我们将使用 Elasticsearch 进行数据存储和搜索，以下是一些原因：
- en: The page count of the book is limited
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这本书的页数有限
- en: Tooling around syncing MongoDB with Elasticsearch is not mature
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MongoDB 与 Elasticsearch 同步方面的工具还不够成熟
- en: Our data requirements are very basic, so it won't make much difference
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的数据需求非常基础，所以这不会造成太大的差异
- en: Installing Java and Elasticsearch
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Java 和 Elasticsearch
- en: First, let's install Elasticsearch and its dependencies. Apache Lucene and Elasticsearch
    are both written in Java, and so we must first install Java.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装 Elasticsearch 和其依赖项。Apache Lucene 和 Elasticsearch 都是用 Java 编写的，因此我们必须首先安装
    Java。
- en: Installing Java
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Java
- en: 'When you install Java, it usually means one of two things: you are installing
    the **Java Runtime Environment** (**JRE**) or the **Java Development Kit** (**JDK**).
    The JRE provides the runtime that allows you to *run* Java programs, whereas the
    JDK contains the JRE, as well as other tools, that allow you to *develop* in Java.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装 Java 时，通常意味着以下两种情况之一：您正在安装 **Java 运行时环境**（**JRE**）或 **Java 开发工具包**（**JDK**）。JRE
    提供了运行 Java 程序所需的运行时，而 JDK 包含了 JRE 以及其他工具，允许您在 Java 中进行开发。
- en: 'We are going to install the JDK here, but to complicate things further, there
    are different implementations of the JDK—OpenJDK, Oracle Java, IBM Java—and the
    one we will be using is the `default-jdk` APT package, which comes with our Ubuntu
    installation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里安装 JDK，但为了使事情更加复杂，JDK 有不同的实现——OpenJDK、Oracle Java、IBM Java——我们将使用的是随 Ubuntu
    安装提供的 `default-jdk` APT 软件包：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to set a system-wide environment variable so that other programs
    using Java (for example, Elasticsearch) know where to find it. Run the following
    command to get a list of Java installations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置一个系统级别的环境变量，以便其他使用 Java 的程序（例如 Elasticsearch）知道它的位置。运行以下命令以获取 Java
    安装列表：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For my machine, there''s only a single Java installation, located at `/usr/lib/jvm/java-8-openjdk-amd64/`.
    However, if you have multiple versions of Java on your machine, you''ll be prompted
    to select the one you prefer:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的机器，只有一个 Java 安装，位于 `/usr/lib/jvm/java-8-openjdk-amd64/`。然而，如果您机器上有多个 Java
    版本，您将被提示选择您喜欢的版本：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, open `/etc/environment` and add the path to the `JAVA_HOME` environment
    variable:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `/etc/environment` 文件并添加 `JAVA_HOME` 环境变量的路径：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`JAVA_HOME` will be set for any user on login; to apply the changes now, we
    need to source the file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`JAVA_HOME` 将在用户登录时为任何用户设置；要立即应用更改，我们需要源文件：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Installing and starting Elasticsearch
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和启动 Elasticsearch
- en: 'Go to [elastic.co/downloads/elasticsearch](https://www.elastic.co/downloads/elasticsearch) and
    download the latest Elasticsearch version for your machine. For Ubuntu, we can
    download the official `.deb` package and install using `dpkg`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [elastic.co/downloads/elasticsearch](https://www.elastic.co/downloads/elasticsearch)
    并下载适合您机器的最新 Elasticsearch 版本。对于 Ubuntu，我们可以下载官方的 `.deb` 软件包并使用 `dpkg` 进行安装：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your version of Elasticsearch might be different from the one here. That's fine.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Elasticsearch 版本可能与这里的不同。这没关系。
- en: 'Next, we need to configure Elasticsearch to use the Java version we just installed.
    We have already done this for the entire system, but Elasticsearch also has its
    own configuration file for specifying the path to the Java binaries. Open up the `/etc/default/elasticsearch` file and
    add an entry for the `JAVA_HOME` variable, just as you did before:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置 Elasticsearch 以使用我们刚刚安装的 Java 版本。我们已经为整个系统做了这件事，但 Elasticsearch 也有自己的配置文件来指定
    Java 二进制文件的路径。打开 `/etc/default/elasticsearch` 文件并添加一个 `JAVA_HOME` 变量的条目，就像之前做的那样：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can start Elasticsearch! Elasticsearch is installed as a service, so
    we can use `systemctl` to start and stop it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始使用 Elasticsearch 了！Elasticsearch 作为服务安装，因此我们可以使用 `systemctl` 来启动和停止它：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To simplify development, we can make Elasticsearch start whenever the system
    is rebooted by enabling it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化开发，我们可以通过启用它来让 Elasticsearch 在系统重启时自动启动：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can check that Elasticsearch is running using `systemctl`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `systemctl` 检查 Elasticsearch 是否正在运行：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, a more direct approach would simply be to send a query to the
    Elasticsearch API on its default port of `9200`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一个更直接的方法就是向 Elasticsearch 默认端口 `9200` 发送查询：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We get a reply, which means Elasticsearch is running on your machine!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了回复，这意味着 Elasticsearch 正在您的机器上运行！
- en: Understanding key concepts in Elasticsearch
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Elasticsearch 的关键概念
- en: We will be sending queries to Elasticsearch very shortly, but it helps if we
    understand a few basic concepts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会向Elasticsearch发送查询，但如果我们理解一些基本概念会很有帮助。
- en: Elasticsearch is a JSON document store
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elasticsearch是一个JSON文档存储
- en: As you might have noticed from the response body of our API call, Elasticsearch
    stores data in **JavaScript Object Notation** (**JSON**) format. This allows developers
    to store objects with more complex (often nested) structures when compared to
    **relational databases** that impose a flat structure with **rows** and **tables**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经从我们的API调用响应体中注意到，Elasticsearch以**JavaScript对象表示法**（**JSON**）格式存储数据。这使得开发者能够存储比**关系型数据库**强加的具有更复杂（通常是嵌套）结构的对象，后者具有**行**和**表**的扁平结构。
- en: That's not to say document databases are better than relational databases, or
    vice versa; they are different and their suitability depends on their use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说文档数据库比关系型数据库更好，或者反之亦然；它们是不同的，它们的适用性取决于它们的使用。
- en: Document vs. relationship data storage
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档与关系数据存储对比
- en: For example, your application may be a school directory, storing information
    about schools, users (including teachers, staff, parents, and students), exams,
    classrooms, classes, and their relations with each other. Given that the data
    structure can be kept relatively flat (that is, mostly simple key-value entries),
    a relational database would be most suitable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你的应用程序可能是一个学校目录，存储有关学校、用户（包括教师、员工、家长和学生）、考试、教室、班级以及它们之间关系的信息。鉴于数据结构可以保持相对扁平（即，主要是简单的键值条目），关系型数据库将是最合适的。
- en: 'On the other hand, if you''re building a social network, and want to store
    a user''s settings, a document database may be more suitable. This is because
    the settings may be quite complex, such as the one shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你正在构建一个社交网络，并想存储用户的设置，文档数据库可能更适合。这是因为设置可能相当复杂，例如这里所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With a relational database, you'll have to establish naming conventions for
    the columns (such as `settings.notification.app.follow`) in order to retain hierarchical
    information. However, to use the settings, you'll have to manually reconstruct
    the object before you can work with it. You'll need to do this each time the entry
    is retrieved.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中，你必须为列（例如`settings.notification.app.follow`）建立命名约定，以便保留层次信息。然而，要使用这些设置，你必须手动在可以处理它之前重建对象。每次检索条目时都需要这样做。
- en: Storing this user information as a document allows you to store objects as they
    are, retaining their structure, and retrieve them as they are, without having
    to do extra work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将此用户信息作为文档存储允许你以对象本身的形式存储它们，保留其结构，并且可以以它们本身的形式检索它们，而无需进行额外的工作。
- en: Several relational databases have started allowing users to store documents
    as values. For example, starting with MySQL 5.7, you can store schema-less documents.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 几个关系型数据库已经开始允许用户将文档作为值存储。例如，从MySQL 5.7开始，你可以存储无模式的文档。
- en: However, if your intention is to structure your data in a non-relational way,
    you'd be better off using a NoSQL database from the start. I'd recommend storing
    documents in a traditional relational database only when you have existing data
    and you are adding a new data structure on top of it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的意图是以非关系型方式结构化你的数据，那么从一开始就使用一个NoSQL数据库会更好。我建议只有在你有现有数据并且在其之上添加新的数据结构时，才将文档存储在传统的数据库中。
- en: Understanding indices, types, documents, and versions
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解索引、类型、文档和版本
- en: 'In Elasticsearch, every document is uniquely identified by four attributes:
    its **index**, **type**, **ID**, and **version**.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Elasticsearch中，每个文档都由四个属性唯一标识：其**索引**、**类型**、**ID**和**版本**。
- en: Related documents should be stored under the same index. Although not equivalent,
    an index is analogous to a database in a relational database. For example, all
    documents used in our user directory API may be stored in the `directory` index, or
    since our platform is called Hobnob, we may also name our index `hobnob`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相关文档应存储在同一个索引下。虽然不完全相同，但索引在关系型数据库中类似于数据库。例如，我们用户目录API中使用的所有文档可能都存储在`directory`索引中，或者由于我们的平台名为Hobnob，我们也可以将我们的索引命名为`hobnob`。
- en: Documents stored within an index must belong to a certain type. For our user
    directory API, you may have documents that belong to the `person` and `company` types. Although
    not equivalent, type is analogous to a table in a relational database.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在索引内的文档必须属于某个类型。对于我们的用户目录API，你可能有一些属于`person`和`company`类型的文档。虽然不完全相同，但类型在关系型数据库中类似于表。
- en: Each document must also have an ID and version. Whenever a document is modified
    in any way, its version increments by a certain amount (usually `1`).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文档也必须有一个 ID 和版本。每当以任何方式修改文档时，其版本都会增加一定量（通常是 `1`）。
- en: Elasticsearch does not store older versions of the document. The version counter
    is there to allow us to perform **concurrent updates** and **optimistic locking**
    (more on these techniques later).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 不存储文档的旧版本。版本计数器存在是为了允许我们执行 **并发更新** 和 **乐观锁定**（稍后详细介绍这些技术）。
- en: Querying Elasticsearch from E2E tests
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从端到端测试中查询 Elasticsearch
- en: 'We now have all the required knowledge in Elasticsearch to implement our last
    undefined step definition, which reads from the database to see if our user document
    has been indexed correctly. We will be using the JavaScript client, which is merely
    a wrapper around the REST API, with a one-to-one mapping to its endpoints. So
    first, let''s install it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在 Elasticsearch 中拥有了实现最后未定义步骤定义所需的所有知识，该步骤定义从数据库读取以查看我们的用户文档是否已正确索引。我们将使用
    JavaScript 客户端，它只是 REST API 的包装器，与其端点一对一映射。因此，首先，让我们安装它：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, import the package into our `spec/cucumber/steps/index.js` file and create
    an instance of `elasticsearch.Client`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将包导入到我们的 `spec/cucumber/steps/index.js` 文件中，并创建一个 `elasticsearch.Client`
    实例：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'By default, Elasticsearch runs on port `9200`. However, to avoid hard-coded
    values, we have explicitly passed in an options object, specifying the `host`
    option, which takes its value from the environment variables. To make this work,
    add these environment variables to our `.env` and `.env.example` files:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Elasticsearch 在端口 `9200` 上运行。然而，为了避免硬编码的值，我们明确传递了一个选项对象，指定了 `host` 选项，其值来自环境变量。为了使这生效，请将这些环境变量添加到我们的
    `.env` 和 `.env.example` 文件中：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For a full list of options that the `elasticsearch.Client` constructor function
    accepts, check out [elastic.co/guide/en/elasticsearch/client/javascript-api/current/configuration.html](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/configuration.html).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `elasticsearch.Client` 构造函数接受的选项的完整列表，请查看 [elastic.co/guide/en/elasticsearch/client/javascript-api/current/configuration.html](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/configuration.html)。
- en: As specified in our Cucumber test scenario, we require the Create User endpoint
    to return a string, which we store in `this.responsePayload`. This should be the
    ID of the user. Therefore, if we can find the user document again using this ID,
    it means the document is in the database and we have completed our feature.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的 Cucumber 测试场景中指定，我们需要创建用户端点返回一个字符串，我们将其存储在 `this.responsePayload` 中。这应该是用户的
    ID。因此，如果我们可以使用此 ID 再次找到用户文档，这意味着文档在数据库中，我们已经完成了我们的特性。
- en: To find the document by ID, we can use the `get` method from the Elasticsearch
    client, which will get a typed JSON document from the index based on its ID. All
    of the methods in the Elasticsearch client are asynchronous—if we provide a callback,
    it will invoke the callback; otherwise, it will return a promise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 ID 查找文档，我们可以使用 Elasticsearch 客户端的 `get` 方法，该方法将根据其 ID 从索引中获取一个类型化的 JSON
    文档。Elasticsearch 客户端中的所有方法都是异步的——如果我们提供了一个回调，它将调用该回调；否则，它将返回一个承诺。
- en: 'The result from Elasticsearch would have the following structure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 的结果将具有以下结构：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `_source` property contains the actual document. To make sure it is the
    same as the one we sent in the request, we can use the `deepEqual` method from
    Node's `assert` module to compare the `_source` document with `this.requestPayload`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`_source` 属性包含实际的文档。为了确保它与请求中发送的相同，我们可以使用 Node 的 `assert` 模块的 `deepEqual` 方法来比较
    `_source` 文档与 `this.requestPayload`。'
- en: 'Given this information, try to implement the final step definition yourself,
    and check back here for the answer:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，尝试自己实现最终步骤定义，并在此处查看答案：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ESLint may complain that `_source` violates the `no-underscore-dangle` rule.
    Traditionally, underscores in an identifier are used to indicate that the variable
    or method should be "private", but since there're no truly private variables in
    JavaScript, this convention is highly controversial.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 可能会抱怨 `_source` 违反了 `no-underscore-dangle` 规则。传统上，标识符中的下划线用于表示变量或方法应该是“私有的”，但由于
    JavaScript 中没有真正的私有变量，这种约定非常具有争议性。
- en: Here, however, we are using the Elasticsearch client and this is their convention.
    Therefore, we should add a rule to the project-level `.eslintrc` file to disable
    this rule.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这里使用的是 Elasticsearch 客户端，这是它们的约定。因此，我们应该在项目级别的 `.eslintrc` 文件中添加一个规则来禁用此规则。
- en: Run the tests again, and there should be no undefined step definitions anymore.
    But, it still fails because we haven't implemented the actual success scenario
    in our `src/index.js` yet. So, let's get down to it!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，应该不再有未定义的步骤定义。但是，它仍然失败，因为我们还没有在我们的`src/index.js`中实现实际的成功场景。所以，让我们开始吧！
- en: Indexing documents to Elasticsearch
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文档索引到Elasticsearch
- en: 'In `src/index.js`, import the Elasticsearch library and initiate a client as
    we did before; then, in the request handler for `POST /users`, use the Elasticsearch
    JavaScript client''s `index` method to add the payload object into the Elasticsearch
    index:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/index.js`中，导入Elasticsearch库并像之前一样初始化客户端；然后在`POST /users`的请求处理器中，使用Elasticsearch
    JavaScript客户端的`index`方法将有效负载对象添加到Elasticsearch索引中：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `index` method returns a promise, which should resolve to something similar
    to this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`index`方法返回一个承诺，它应该解析为类似以下内容：'
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only useful and relevant piece of information we can return to the client
    is the newly auto-generated `_id` field. Therefore, we should extract that information
    and make the function return a promise, which resolves to only the `_id` field
    value. As a last resort, return a `500 Internal Server` error to indicate to the
    client that their request is valid, but our server is experiencing some issues:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向客户端返回的唯一有用且相关的信息是新自动生成的`_id`字段。因此，我们应该提取该信息，并使函数返回一个承诺，该承诺解析为仅`_id`字段值。作为最后的手段，返回一个`500
    内部服务器错误`，以向客户端表明他们的请求是有效的，但我们的服务器遇到了一些问题：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, our E2E tests should all pass again!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的端到端测试应该全部通过！
- en: Cleaning up after our tests
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理测试后的工作
- en: 'When we run our tests, it''ll index user documents into our local development
    database. Over many runs, our database will be filled with a large number of test
    user documents. Ideally, we want all our tests to be self-contained. This means
    with each test run, we should reset the state of the database back to the state
    before the test was run. To achieve this, we must make two further changes to
    our test code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，它将用户文档索引到我们的本地开发数据库。经过多次运行，我们的数据库将充满大量测试用户文档。理想情况下，我们希望所有测试都是自包含的。这意味着每次测试运行时，我们应该将数据库的状态重置到测试运行之前的状态。为了实现这一点，我们必须对我们的测试代码进行两项进一步的修改：
- en: Delete the test user after we have made the necessary assertions
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们做出必要的断言后删除测试用户
- en: Run the tests on a test database; in the case of Elasticsearch, we can simply
    use a different index for our tests
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试数据库上运行测试；在Elasticsearch的情况下，我们可以简单地为我们的测试使用不同的索引
- en: Deleting our test user
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除我们的测试用户
- en: 'First, add a new entry to the list of features in the Cucumber specification:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Cucumber规范的特征列表中添加一个新条目：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, define the corresponding step definition for this step. But first, we
    are going to modify the step definition that indexed the document, and change
    it to persist the document type in the context:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为这个步骤定义相应的步骤定义。但首先，我们将修改索引文档的步骤定义，并将其更改为在上下文中持久化文档类型：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, add a new step definition that uses `client.delete` to delete a document
    by ID:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加一个新的步骤定义，该定义使用`client.delete`通过ID删除文档：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result of the `delete` method looks something like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`方法的输出看起来像这样：'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A successful operation will have its `result` property set to `''deleted''`;
    therefore, we can use it to assert whether the step was successful or not. Update
    the step definition to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 成功操作将将其`result`属性设置为`'deleted'`；因此，我们可以用它来断言步骤是否成功。更新步骤定义如下：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the tests and make sure they pass. We''ve now implemented our happy path/success
    scenario, so it''s a good time to commit our changes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并确保它们通过。我们现在已经实现了我们的快乐路径/成功场景，所以现在是时候提交我们的更改：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Improving our testing experience
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高我们的测试体验
- en: Although we are now cleaning up after ourselves, using the same index for both
    testing and development is not ideal. Instead, we should use one index for development,
    and another for testing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在正在清理自己的事情，但使用相同的索引进行测试和开发并不理想。相反，我们应该为开发使用一个索引，为测试使用另一个索引。
- en: Running tests in a test database
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试数据库中运行测试
- en: 'For our project, let''s use the index name `hobnob` for development, and `test`
    for testing. Instead of hard-coding the index name into our code, we can use an
    environment variable to set it dynamically. Therefore, in both our application
    and test code, replace *all* instances of `index: ''hobnob''` with `index: process.env.ELASTICSEARCH_INDEX`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '对于我们的项目，让我们在开发时使用索引名称 `hobnob`，在测试时使用 `test`。我们不需要将索引名称硬编码到我们的代码中，可以使用环境变量来动态设置它。因此，在我们的应用程序和测试代码中，将所有
    `index: ''hobnob''` 的实例替换为 `index: process.env.ELASTICSEARCH_INDEX`。'
- en: Currently, we are using the `dotenv-cli` package to load our environment variables.
    As it turns out, the package also provides an `-e` flag that allows us to load
    multiple files. This means we can store default environment variables in our `.env`
    file, and create a new `test.env` to store testing-specific environment variables,
    which will override the defaults.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用 `dotenv-cli` 包来加载我们的环境变量。实际上，该包还提供了一个 `-e` 标志，允许我们加载多个文件。这意味着我们可以在
    `.env` 文件中存储默认环境变量，并创建一个新的 `test.env` 来存储特定于测试的环境变量，这将覆盖默认值。
- en: 'Therefore, add the following line to our `.env` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将以下行添加到我们的 `.env` 文件中：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, create two new files—`test.env` and `test.env.example`—and add the following
    line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建两个新文件——`test.env` 和 `test.env.example`——并添加以下行：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lastly, update our `test` script to load the test environment before the default:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新我们的 `test` 脚本，在默认之前加载测试环境。
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Stop the API server and restart it with the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 停止 API 服务器，并使用以下命令重新启动它：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run our E2E tests again, and they should all pass. The only difference now is
    that the tests are not affecting our development index at all!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行我们的端到端测试，它们应该全部通过。现在唯一的区别是测试根本不会影响我们的开发索引！
- en: 'Lastly, just to tidy things up, let''s move all our environment files into
    a new directory called `envs` and update our `.gitignore` to ignore all files
    with the `.env` extension:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了整理一下，让我们将所有环境文件移动到一个名为 `envs` 的新目录中，并更新我们的 `.gitignore` 以忽略所有具有 `.env`
    扩展名的文件：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Of course, you also need to update your `serve` and `test` scripts:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您还需要更新您的 `serve` 和 `test` 脚本：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the tests again and make sure they pass. Once you''re happy, commit these
    changes to Git:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试并确保它们通过。一旦您满意，将这些更改提交到 Git：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Separating development and testing servers
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离开发和测试服务器
- en: Good job. Using a test database is certainly a step forward, but our testing
    workflow is still disjointed. At the moment, to run our tests, we need to stop
    our development API server, set the environment variables, and then restart it.
    Similarly, once the tests are finished, we need to stop and restart it again with
    the development environment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。使用测试数据库确实是一个进步，但我们的测试工作流程仍然不连贯。目前，为了运行我们的测试，我们需要停止我们的开发 API 服务器，设置环境变量，然后重新启动它。同样，一旦测试完成，我们还需要停止并重新启动它，以使用开发环境。
- en: Ideally, we should run two separate instances of the API server—one for development,
    one for testing—each binding to its own port. This way, there's no need to stop
    and restart our server just to run tests.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该运行两个独立的 API 服务器实例——一个用于开发，一个用于测试——每个都绑定到自己的端口。这样，我们就不需要停止和重新启动服务器来运行测试。
- en: 'To achieve this, simply override the `SERVER_PORT` environment variable for
    our test environment by adding the following line to `envs/test.env` and `envs/test.env.example`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，只需通过在 `envs/test.env` 和 `envs/test.env.example` 中添加以下行来覆盖我们的测试环境的 `SERVER_PORT`
    环境变量：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we can run `yarn run watch` to run our development API server, and *at
    the same time*, run `npx dotenv -e envs/test.env yarn run watch` to run our testing
    API server. We no longer need to stop and restart!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `yarn run watch` 来运行我们的开发 API 服务器，并且同时运行 `npx dotenv -e envs/test.env
    yarn run watch` 来运行我们的测试 API 服务器。我们不再需要停止和重新启动！
- en: 'Although this is a minor change, let''s still commit it to our repository:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个小的改动，但让我们仍然将其提交到我们的仓库中：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Making a standalone E2E test script
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建独立的端到端测试脚本
- en: 'But, we''re not done yet! We can definitely improve our testing workflow even
    further. At the moment, to run our E2E test we have to ensure the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但，我们还没有完成！我们绝对可以进一步提高我们的测试工作流程。目前，为了运行我们的端到端测试，我们必须确保以下条件：
- en: An Elasticsearch instance is running
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Elasticsearch 实例正在运行
- en: We use `dotenv-cli` to load our test environment and then run our API server
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `dotenv-cli` 来加载我们的测试环境，然后运行我们的 API 服务器。
- en: While we could simply note down these instructions in a `README.md` file, it'll
    provide a better developer experience if we provide a single command to run, which
    will automatically load up Elasticsearch, set the right environment, run our API
    server, run our tests, and tear everything down once it's done.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在 `README.md` 文件中简单地记录这些说明，但如果我们提供一个单独的命令来运行，这将自动加载 Elasticsearch，设置正确的环境，运行我们的
    API 服务器，运行我们的测试，并在完成后拆毁一切，这将提供更好的开发者体验。
- en: This seems too much logic to fit into one line of npm script; instead, we can
    write a shell script, which allows us to specify this logic inside a file. We
    will use a **Bash** as the shell language, as it is the most popular and widely-supported
    shell.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎逻辑过于复杂，不适合放入一行 npm 脚本；相反，我们可以编写一个 shell 脚本，它允许我们在文件中指定这种逻辑。我们将使用 **Bash**
    作为 shell 语言，因为它是最流行和广泛支持的 shell。
- en: For Windows users, make sure you've installed the *Windows Subsystem for Linux*
    (WSL), which allows you to run GNU/Linux tools and Bash scripts natively on your
    Windows machine. You can find detailed instructions at [docs.microsoft.com/en-us/windows/wsl/](https://docs.microsoft.com/en-us/windows/wsl/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，请确保您已安装 *Windows Subsystem for Linux* (WSL)，它允许您在 Windows 机器上本地运行
    GNU/Linux 工具和 Bash 脚本。您可以在 [docs.microsoft.com/en-us/windows/wsl/](https://docs.microsoft.com/en-us/windows/wsl/)
    找到详细说明。
- en: 'Let''s begin by creating a new directory called `scripts`, adding a new file
    inside it called `e2e.test.sh`, and setting its file permission so it''s executable:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个名为 `scripts` 的新目录，在其内部添加一个名为 `e2e.test.sh` 的新文件，并设置其文件权限以便可执行：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, update our `test:e2e` npm script to execute the shell script instead
    of running the `cucumber-js` command directly:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新我们的 `test:e2e` npm 脚本来执行 shell 脚本而不是直接运行 `cucumber-js` 命令：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The shebang interpreter directive
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shebang 解释器指令
- en: The first line of a shell script is always the **shebang interpreter directive**;
    it basically tells our shell which interpreter it should use to parse and run
    the instructions contained in this script file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本的第一行总是 shebang 解释器指令；它基本上告诉我们的 shell 应该使用哪个解释器来解析和运行此脚本文件中包含的指令。
- en: 'It''s called a *shebang* interpreter directive because it starts with a **shebang**,
    which is simply a sequence of two characters: a hash sign (`#`) followed by an
    exclamation mark (!).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为 *shebang* 解释器指令，因为它以一个 **shebang** 开头，它只是一个由两个字符组成的序列：一个井号 (`#`) 后跟一个感叹号
    (!)。
- en: 'Some scripts might be written in Perl, or Python, or a different flavor of
    the shell; however, our script will be written for the Bash shell, so we should
    set the directive to the location of the `bash` executable, which we can derive
    from running `/usr/bin/env bash`. Therefore, add the following shebang as the
    first line in our `e2e.test.sh` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一些脚本可能用 Perl 或 Python 或其他 shell 变体编写；然而，我们的脚本将用 Bash shell 编写，因此我们应该将指令设置为 `bash`
    可执行文件的位置，我们可以通过运行 `/usr/bin/env bash` 来获取。因此，在 `e2e.test.sh` 文件的第一行添加以下 shebang：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Ensuring Elasticsearch is running
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保 Elasticsearch 正在运行
- en: 'Our API server depends on an active instance of Elasticsearch. Therefore, before
    we start our API server, let''s make sure our Elasticsearch service is active.
    Add the following check under the shebang line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 API 服务器依赖于一个活跃的 Elasticsearch 实例。因此，在我们启动 API 服务器之前，让我们确保 Elasticsearch
    服务是活跃的。在 shebang 行下添加以下检查：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, we use the `is-active` command of `systemctl` to check whether the Elasticsearch
    service is active; the command will exit with a `0` if it is active, and a non-zero
    value if not.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `systemctl` 的 `is-active` 命令来检查 Elasticsearch 服务是否活跃；如果活跃，命令将以 `0` 状态退出，如果不活跃，则以非零值退出。
- en: Generally, when a process successfully executes, it will exit with a status
    of zero (`0`); otherwise, it will exit with a non-zero status code. Inside an
    `if` block, the exit codes have special meaning—a `0` exit code means `true`,
    and a non-zero exit code means `false`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当进程成功执行时，它将以零 (`0`) 状态退出；否则，它将以非零状态码退出。在 `if` 块中，退出代码有特殊含义——`0` 退出代码表示 `true`，非零退出代码表示
    `false`。
- en: This means that if the service is not active, we'd use the `start` command of
    `systemctl` to start it. However, Elasticsearch takes time to initiate before
    it can respond to requests. Therefore, we are polling its endpoint with `curl`,
    and blocking downstream execution until Elasticsearch is ready.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果服务不活跃，我们将使用 `systemctl` 的 `start` 命令来启动它。然而，Elasticsearch 在能够响应请求之前需要一段时间来初始化。因此，我们使用
    `curl` 轮询其端点，并阻塞下游执行，直到 Elasticsearch 准备就绪。
- en: If you're curious what the flags mean on the commands, you can get detailed
    documentation on them by using the `man` command. Try running `man systemctl`,
    `man curl`, and even `man man`! Some commands also support a `-h` or `--help`
    flag, which contains less information but is usually easier to digest.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对命令中的标志感兴趣，可以通过使用 `man` 命令获取它们的详细文档。尝试运行 `man systemctl`、`man curl`，甚至 `man
    man`！一些命令也支持 `-h` 或 `--help` 标志，它包含较少的信息，但通常更容易理解。
- en: We will retry the endpoint every 0.2 seconds. This is set in the `RETRY_INTERVAL`
    environment variable. The `${RETRY_INTERVAL:-0.2}` syntax means we should only
    use the `0.2` value if the environment variable is not already set; in other words,
    the `0.2` value should be used as a default.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每 0.2 秒重试端点一次。这由 `RETRY_INTERVAL` 环境变量设置。`${RETRY_INTERVAL:-0.2}` 语法表示如果环境变量尚未设置，我们应该仅使用
    `0.2` 值；换句话说，`0.2` 值应作为默认值。
- en: Running the test API server in the background
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台运行测试 API 服务器
- en: Next, before we can run our tests, we must run our API server. However, the
    API server and the tests need to run at the same time, but there can only be one
    foreground process group attached to the terminal. We want this to be our test,
    so we can interact with it if required (for example, to stop the test). Therefore,
    we need to run our API server as a background process.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们能够运行测试之前，我们必须运行我们的 API 服务器。然而，API 服务器和测试需要同时运行，但终端只能附加一个前台进程组。我们希望这是我们的测试，以便在需要时与之交互（例如，停止测试）。因此，我们需要将我们的
    API 服务器作为后台进程运行。
- en: 'In Bash (and other shells that support **job control**), we can run a command
    as a background process by appending a single ampersand (`&`) after the command.
    Therefore, add the following lines after our Elasticsearch initiation block:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bash（以及其他支持 **作业控制** 的 shell）中，我们可以通过在命令后附加单个 ampersand (`&`) 来将命令作为后台进程运行。因此，在我们的
    Elasticsearch 初始化块之后添加以下行：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Checking our API server is ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的 API 服务器是否已准备好
- en: 'Next, we need to run our tests. But, if we do it immediately after we execute `yarn
    run serve &`, it will not work:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行我们的测试。但是，如果我们立即在执行 `yarn run serve &` 之后进行，它将不会工作：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is because the tests are run before our API server is ready to handle the
    requests. Therefore, just like we did with the Elasticsearch service, we must
    wait for our API server to be ready before running our tests.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为测试是在我们的 API 服务器准备好处理请求之前运行的。因此，就像我们处理 Elasticsearch 服务一样，我们必须在运行测试之前等待我们的
    API 服务器准备好。
- en: Checking API status using netstat/ss
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 netstat/ss 检查 API 状态
- en: 'But, how do we know when the API is ready? We could send a request to one of
    the API''s endpoints and see if it returns a result. However, this couples our
    script with the implementation of the API. A better way would be to check whether
    the API is actively listening to the server port. We can do this using the `netstat`
    utility, or its replacement, `ss` (which stands for **s**ocket **s**tatistics).
    Both commands are used to display network-related information such as open connections
    and socket ports:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何知道 API 是否已准备好？我们可以向 API 的一个端点发送请求，看看它是否返回结果。然而，这将使我们的脚本与 API 的实现耦合。更好的方法是通过检查
    API 是否正在积极监听服务器端口。我们可以使用 `netstat` 工具或其替代品 `ss`（代表 **s**ocket **s**tatistics）来完成此操作。这两个命令都用于显示与网络相关的信息，例如打开的连接和套接字端口：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For both commands, the `-l` flag will limit the results to only listening sockets,
    the `-n` flag will display all hosts and ports as numeric values (for instance,
    it''ll output `127.0.0.1:631` instead of `127.0.0.1:ipp`), and the `-t` flag will
    filter out non-TCP sockets. The end result is an output that looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个命令，`-l` 标志将结果限制为仅监听套接字，`-n` 标志将显示所有主机和端口号作为数值（例如，它将输出 `127.0.0.1:631` 而不是
    `127.0.0.1:ipp`），而 `-t` 标志将过滤掉非 TCP 套接字。最终的结果看起来像这样：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To check whether a specific port is listening, we can simply run `grep` on the
    output (for instance, `ss -lnt | grep -q 8888`) If `grep` finds a result, it will
    exit with a status code of `0`; if no matches are found, it will exit with a non-zero
    code. We can use this feature of grep to poll `ss` at regular intervals until
    the port is bound.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查特定端口是否正在监听，我们可以在输出上简单地运行 `grep`（例如，`ss -lnt | grep -q 8888`）。如果 `grep` 找到结果，它将以状态码
    `0` 退出；如果没有找到匹配项，它将以非零代码退出。我们可以使用 grep 的这个特性以固定间隔轮询 `ss`，直到端口绑定。
- en: 'Add the following block below our `yarn run serve &` command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `yarn run serve &` 命令下方添加以下块：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Cleaning up the background process
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理后台进程
- en: We need to make a few last changes to our test script before we can run our
    tests. At the moment, we are running our API server in the background. However,
    when our script exits, the API will still keep running; this means we will get
    the `listen EADDRINUSE :::8888` error the next time we run the E2E tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以运行测试之前，我们需要对我们的测试脚本做一些最后的修改。目前，我们正在后台运行API服务器。然而，当我们的脚本退出时，API仍然会继续运行；这意味着我们下次运行E2E测试时将得到`listen
    EADDRINUSE :::8888`错误。
- en: 'Therefore, we need to kill that background process before the test script exits.
    This can be done with the `kill` command. Add the following line at the end of
    the test script:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在测试脚本退出之前，我们需要终止那个后台进程。这可以通过`kill`命令完成。在测试脚本末尾添加以下行：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Process ID** (**PID**) `0` (zero) is a special PID that represents all member
    processes within the same process group as the process that raised the signal.
    Therefore, our previous command sends a `SIGTERM` signal (which has a numeric
    code of `15`) to all processes within the same process group.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程ID**（**PID**）`0`（零）是一个特殊的PID，它代表与触发信号的进程属于同一进程组内的所有进程。因此，我们之前的命令向同一进程组内的所有进程发送了`SIGTERM`信号（其数字代码为`15`）。'
- en: 'And, just to make sure no other process has bound to the same port as our API
    server, let''s add a check at the beginning of our Bash script that''ll exit immediately
    if the port is unavailable:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保没有其他进程绑定到与我们的API服务器相同的端口，让我们在Bash脚本的开头添加一个检查，如果端口不可用，则立即退出：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Running our tests
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的测试
- en: 'Finally, we are able to run our tests! Add the `cucumber-js` command just prior
    to the `kill` command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们能够运行我们的测试！在`kill`命令之前添加`cucumber-js`命令：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Your final `scripts/e2e.test.sh` script should look like this (comments removed):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您最终的`scripts/e2e.test.sh`脚本应如下所示（注释已删除）：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Just to double-check, run the E2E tests to make sure they still pass. Of course, commit
    these changes to Git:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了双重检查，运行E2E测试以确保它们仍然通过。当然，将这些更改提交到Git：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we continued our work on the Create User endpoint. Specifically,
    we implemented the success scenario by persisting data into Elasticsearch. Then,
    we refactored our testing workflow by creating a Bash script that automatically
    loads up all dependencies before running our tests.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续在创建用户端点上的工作。具体来说，我们通过将数据持久化到Elasticsearch实现了成功场景。然后，我们通过创建一个Bash脚本来自动加载所有依赖项，在运行测试之前重构了我们的测试工作流程。
- en: In the next chapter, we will refactor our code further, by breaking it down
    into smaller units, and covering them with unit and integration tests, written
    using Mocha, Chai, and Sinon. We will also continue to implement the rest of the
    endpoints, making sure we follow good API design principles.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步重构我们的代码，将其分解成更小的单元，并使用Mocha、Chai和Sinon编写的单元和集成测试来覆盖它们。我们还将继续实现其余的端点，确保我们遵循良好的API设计原则。
