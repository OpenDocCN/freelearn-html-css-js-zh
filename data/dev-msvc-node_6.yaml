- en: Chapter 6. Testing and Documenting Node.js Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。测试和文档化Node.js微服务
- en: Until now, all that we have done is develop microservices and discuss the frameworks
    around the process of building software components. Now it is time to test all
    of them. Testing is the activity of validating the software that has been built.
    Validating is a very broad term. In this chapter, we are going to learn how to
    test microservices, not only from the functional point of view, but we will also
    learn how to test the performance of our applications, as well as other aspects
    such as integration with different modules. We will also build a proxy using Node.js
    to help us to inspect the inputs and outputs of our services so that we can validate
    that what we have designed is actually happening and, once again, reassure the
    versatility of a language, such as JavaScript, to quickly prototype features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的一切都是开发微服务并讨论围绕构建软件组件的框架。现在是测试它们的时候了。测试是验证已构建软件的活动。验证是一个非常广泛的术语。在本章中，我们将学习如何测试微服务，不仅从功能的角度，还将学习如何测试我们应用的性能，以及与不同模块集成等其他方面。我们还将使用Node.js构建一个代理来帮助我们检查服务的输入和输出，以便验证我们设计的是否真正发生，并再次验证JavaScript等语言的多功能性，以快速原型化功能。
- en: It is also nowadays a trend to release features with an A/B test, where we only
    enable the features for certain type of users, and then we collect metrics to
    see how the changes to our system are performing. In this chapter, we will build
    a microservice that is going to give us the capability of rolling out features
    in a controlled way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，发布带有A/B测试的功能是一种趋势，我们只为某种类型的用户启用功能，然后收集指标来查看我们系统的变化如何执行。在本章中，我们将构建一个微服务，使我们能够以受控的方式推出功能。
- en: 'On the other hand, we are going to document our application, which unfortunately,
    is a forgotten activity in traditional software development: I haven''t found
    a single company where the documentation captures 100% the information needed
    by new developers.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们将记录我们的应用，这在传统软件开发中往往被忽视：我没有找到一家公司的文档能够完全捕捉到新开发人员所需的所有信息。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '**Functional testing**: In this section, we will learn how to test microservices
    and what a good testing strategy is. We will also get to study a tool called Postman
    to manually test our APIs, as well as build a proxy with Node.js to spy our connections.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：在本节中，我们将学习如何测试微服务以及什么是良好的测试策略。我们还将学习一个名为Postman的工具，手动测试我们的API，以及使用Node.js构建代理来监视我们的连接。'
- en: '**Documenting microservices**: We will learn how to use Swagger to document
    our microservices using the open API standard. We will also generate the code
    from the YAML definition using an open source tool.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档化微服务**：我们将学习如何使用Swagger使用开放API标准来记录我们的微服务。我们还将使用开源工具从YAML定义生成代码。'
- en: Functional testing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: Testing is usually a time-consuming activity that does not get all the required
    attention while building a software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常是一个耗时的活动，在构建软件时并没有得到所有必要的关注。
- en: 'Think about how a company evolves:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想想一家公司是如何发展的：
- en: Someone comes up with an idea.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有人想出一个主意。
- en: A few engineers/product people build the system.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些工程师/产品人员构建系统。
- en: The company goes to market.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公司进入市场。
- en: There is no time to test more than the minimal required manual testing. Especially,
    when someone reads on the Internet that testing done right could take up to 40%
    of your development time, and once again, the common sense fails.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 没有时间进行比最低要求的手动测试更多的测试。特别是当有人在互联网上读到测试做对可能需要占用开发时间的40%，而常识再次失败。
- en: Automation is good and unit, integration, and end-to-end tests are a form of
    automation. By letting a computer test our software, we are drastically cutting
    down the human effort required to validate our software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是好的，单元测试、集成测试和端到端测试都是一种自动化形式。通过让计算机测试我们的软件，我们大大减少了验证软件所需的人力。
- en: Think about how the software is developed. Even though our company likes to
    claim that *we are agile*, the truth is that every single software project has
    some level of iterative development, and testing is a part of every cycle, but
    generally, it is overlooked in favour of delivering new features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想想软件是如何开发的。尽管我们的公司喜欢宣称*我们是敏捷的*，但事实上每个软件项目都有一定程度的迭代开发，而测试是每个周期的一部分，但通常为了交付新功能而被忽视。
- en: 'By automating the majority (or a big chunk) of the testing, we are saving money,
    as shown in the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动化大部分（或大部分）测试，我们正在节省金钱，如下图所示：
- en: '![Functional testing](img/B04889_06_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![功能测试](img/B04889_06_01.jpg)'
- en: Costs and Iterations
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 成本和迭代
- en: Testing is actually a cost saver if is done right, and the key is doing it right,
    which is not always easy. How much testing is too much testing? Should we cover
    every single corner of our application? Do we really need deep performance testing?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试做得对，测试实际上是节约成本的，关键是做对，这并不总是容易的。多少测试是过多的测试？我们应该覆盖我们应用的每一个角落吗？我们真的需要深入的性能测试吗？
- en: These questions usually lead to a different stream of opinions, and the interesting
    thing is that there is not a single source of truth. It depends on the nature
    of your system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题通常会引发不同的意见，有趣的是并没有一个真正的答案。这取决于你的系统的性质。
- en: In this chapter, we are going to learn a set of extensive testing techniques,
    which does not mean that we should be including all of them in our test plan,
    but at least we will be aware of the testing methodologies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一套广泛的测试技术，这并不意味着我们应该在我们的测试计划中包括所有这些技术，但至少我们将了解测试方法论。
- en: In the past seven years, Ruby on Rails has created a massive trend towards a
    new paradigm, called **Test-driven development** (**TDD**), up to a point that,
    nowadays, majority of the new development platforms are built with TDD in mind.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的七年里，Ruby on Rails已经创造了一种新的范式的巨大趋势，称为**测试驱动开发**（**TDD**），直到现在，大多数新的开发平台都是以TDD为目标构建的。
- en: Personally, I am not a fierce adopter of TDD, but I like to take the good parts.
    Planning the test before the development helps to create modules with the right
    level of cohesion and define a clear and easy-to-test interface. In this chapter,
    we won't cover the TDD in depth, but we will mention it a few times and explain
    how to apply the exposed techniques to a TDD test plan.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我并不是TDD的坚定支持者，但我喜欢吸收其中的优点。在开发之前规划测试有助于创建具有正确内聚性的模块，并定义一个清晰易测的接口。在本章中，我们不会深入讨论TDD，但我们会提到几次，并解释如何将这些技术应用到TDD测试计划中。
- en: The pyramid of automated testing
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试金字塔
- en: How to lay down your testing plan is a tricky question. No matter what you do,
    you will always end up with the sensation that *this is completely wrong*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如何制定测试计划是一个棘手的问题。无论你做什么，你总会有一种感觉*这完全是错的*。
- en: Before diving into the deep, let's define the different type of tests that we
    are going to be dealing with from the functional point of view, and what should
    they be designed for.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论之前，让我们从功能角度定义我们将要处理的不同类型的测试，以及它们应该设计为什么。
- en: Unit tests
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: A **unit test** is a test that covers individual parts of the application without
    taking into account the integration with different modules. It is also called
    **white box testing** as the aim is to cover and verify as many branches as possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是一种覆盖应用程序各个部分的测试，而不考虑与不同模块的集成。它也被称为**白盒测试**，因为其目的是尽可能覆盖和验证尽可能多的分支。'
- en: Generally, the way to measure the quality of our tests is the test coverage
    and it is measured in percentage. If our code spans over ten branches and our
    tests cover seven branches, our code coverage is 70%. This is a good indication
    of how reliable our test coverage is. However, it could be misleading as the tests
    could be flawed, or even though all the branches are tested, a different input
    would cause a different output that wasn't captured by a test.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，衡量我们测试质量的方法是测试覆盖率，以百分比来衡量。如果我们的代码涵盖了十个分支，而我们的测试覆盖了七个分支，那么我们的代码覆盖率就是70%。这是我们测试覆盖率可靠程度的一个很好的指标。然而，这可能会误导，因为测试可能存在缺陷，或者即使所有分支都经过了测试，不同的输入可能会导致不同的输出，而这并没有被测试捕捉到。
- en: In unit tests, as we don't interact with other modules, we will be making a
    heavy use of mocks and stubs in order to simulate responses from third-party systems
    and control the flow to hit the desired branch.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，由于我们不与其他模块交互，我们将大量使用模拟和存根来模拟第三方系统的响应，并控制流程以命中所需的分支。
- en: Integration tests
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: '**Integration tests**, as the name suggests, are the tests designed to verify
    the integration of our module in the application environment. They are not designed
    to test the branches of our code, but business units, where we will be saving
    the data into databases, calling third-party web services or other microservices
    of our architecture.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**，顾名思义，是设计用来验证我们模块在应用程序环境中的集成的测试。它们不是设计来测试我们代码的分支，而是业务单元，我们将把数据保存到数据库中，调用第三方网络服务或我们架构的其他微服务。'
- en: These tests are the perfect tool for checking whether our service is behaving
    as expected, and sometimes, could be hard to maintain (more often than not).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试是检查我们的服务是否表现如预期的完美工具，有时可能很难维护（往往如此）。
- en: 'During my years of experience, I haven''t found a company where the integration
    testing is done right and there are a number of reasons for this, as stated in
    the following list:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的多年经验中，我还没有找到一家集成测试做得正确的公司，这其中有很多原因，如下列表所述：
- en: Some companies think that integration testing is expensive (and it is true)
    as it requires extra resources (such as databases and extra machines)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些公司认为集成测试很昂贵（这是真的），因为它需要额外的资源（如数据库和额外的机器）。
- en: Some other companies try to cover all the business cases just with unit testing,
    which depending on the business cases, could work, but it is far from ideal as
    unit tests make assumptions (mocks) that could give us a false confidence in our
    test suite
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些其他公司尝试仅通过单元测试覆盖所有业务案例，这取决于业务案例，可能会起作用，但远非理想，因为单元测试会做出假设（模拟），这可能会让我们对我们的测试套件产生错误的信心。
- en: Sometimes, integration tests are used to verify the code branches as if they
    were unit tests, which is time consuming as you need to work out the environment
    to make the integration test to hit the required branch
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，集成测试被用来验证代码分支，就像单元测试一样，这是很耗时的，因为你需要调整环境以使集成测试命中所需的分支。
- en: No matter how smart you want to be, integration testing is something that you
    want to do right, as it is the first real barrier in our software to prevent integration
    bugs from being released into production.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你想变得多聪明，集成测试都是你想要做对的事情，因为它是我们软件中防止集成错误进入生产的第一个真正的屏障。
- en: End-to-end tests
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Here, we will demonstrate that our application actually works. In an integration
    test, we are invoking the services at code level. This means that we need to build
    the context of the service and then issue the call.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将展示我们的应用程序实际上是有效的。在集成测试中，我们在代码级别调用服务。这意味着我们需要构建服务的上下文，然后发出调用。
- en: The difference with end-to-end testing is that, in end-to-end testing, we actually
    fully deploy our application and issue the required calls to execute the target
    code. However, many times, the engineers can decide to bundle both type of tests
    (integration and end-to-end tests) together, as the modern frameworks allow us
    to quickly run E2E tests as if they were integration tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的区别在于，在端到端测试中，我们实际上完全部署我们的应用程序并发出所需的调用来执行目标代码。然而，很多时候，工程师可以决定将两种类型的测试（集成测试和端到端测试）捆绑在一起，因为现代框架允许我们快速运行端到端测试，就像它们是集成测试一样。
- en: As the integration tests, the target of the end-to-end tests is not to test
    all the paths of the application but test the use cases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与集成测试一样，端到端测试的目标不是测试应用程序的所有路径，而是测试用例。
- en: 'In end-to-end tests, we can find a few different modalities (paradigms) of
    testing, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在端到端测试中，我们可以找到一些不同的测试模式，如下所示：
- en: We can test our API issuing JSON requests (or other type of requests)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过发出JSON请求（或其他类型的请求）来测试我们的API
- en: We can test our UI using Selenium to emulate clicks on the DOM
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Selenium来模拟对DOM的点击来测试我们的UI
- en: We can use a new paradigm called **behavior-driven development** (**BDD**) testing,
    where the use cases are mapped into actions in our application (clicks on the
    UI, requests in the API, and so on) and execute the use cases for which the application
    was built
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用一种称为**行为驱动开发**（**BDD**）测试的新范式，其中用例被映射到我们应用程序中的操作（在UI上点击，API中的请求等），并执行应用程序构建的用例
- en: End-to-end tests are usually very fragile and they get broken fairly easy. Depending
    on our application, we might get relaxed about these tests as the cost-value ratio
    is pretty low, but still, I would recommend having some of them covering at least
    the most basic and essential flows.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试通常非常脆弱，很容易出错。根据我们的应用程序，我们可能会对这些测试放松警惕，因为成本价值比相当低，但我仍然建议至少覆盖最基本和必要的流程。
- en: How much testing is too much?
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试过多是多少？
- en: 'Questions such as the following are not easy to answer, especially in fast
    paced businesses, like startups:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 像以下这样的问题并不容易回答，特别是在像初创公司这样的快节奏企业中：
- en: Do we have too many integration tests?
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的集成测试太多了吗？
- en: Should we aim for 100% unit test coverage?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该追求100%的单元测试覆盖率吗？
- en: Why bother with Selenium tests if they break every second day for no reason?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Selenium测试每隔一天就无缘无故失败，为什么还要费心？
- en: There is always a compromise. Test coverage versus time consumed, and also,
    there is no simple and single answer to these questions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一个妥协。测试覆盖率与消耗时间之间的平衡，而且，对于这些问题并没有简单的单一答案。
- en: 'The only useful guideline that I''ve found along the years is what the testing
    world calls the **pyramid of testing**, which is shown in the following figure.
    If you think for a moment, in the projects where you worked before, how many tests
    did you have in total? What percentage of these were integration tests and unit
    tests? What about end-to-end tests?:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来我发现的唯一有用的指导是测试世界所谓的**测试金字塔**，如下图所示。如果你想一下，在你之前工作的项目中，你一共有多少测试？这些中有多少是集成测试和单元测试？端到端测试呢？
- en: '![How much testing is too much?](img/B04889_06_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![测试过多是多少？](img/B04889_06_02.jpg)'
- en: The pyramid of testing
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: 'The preceding pyramid shows the answers for these questions. In a healthy test
    plan, we should have a lot of unit tests: some integration tests and very few
    E2E tests.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的金字塔展示了这些问题的答案。在一个健康的测试计划中，我们应该有很多单元测试：一些集成测试和很少的端到端测试。
- en: The reason for this is very simple, majority of the problems can be caught within
    unit testing. Hitting the different branches of our code will verify the functionality
    of pretty much every functional case in our application, so it makes sense to
    have plenty of them in our test plan. Based on my experience, in a balanced test
    plan, around 70% of our tests should be unit tests. However, in a microservices-oriented
    architecture, especially with a dynamic language such as Node.js, this figure
    can easily go down and still be effective with our testing. The reasoning behind
    it is that Node.js allows you to write integration tests very quickly so that
    we can replace some unit tests by integration tests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单，大多数问题都可以在单元测试中发现。覆盖我们代码的不同分支将验证我们应用程序中几乎每个功能案例的功能，所以在我们的测试计划中有很多这样的测试是有意义的。根据我的经验，在一个平衡的测试计划中，大约70%的测试应该是单元测试。然而，在以微服务为导向的架构中，特别是使用Node.js这样的动态语言，这个数字可以很容易下降，但仍然可以有效地进行测试。其背后的原因是Node.js允许您快速编写集成测试，因此我们可以用集成测试替换一些单元测试。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Testing is a very well-documented, complex process. Trying to outsmart the existing
    methodologies could result in a hard-to-maintain and difficult-to-trust test suite.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个有很多文档记录的复杂过程。试图打破现有的方法可能会导致一个难以维护和难以信任的测试套件。
- en: 'Integration tests are responsible for catching integration problems, as shown
    in the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试负责捕捉集成问题，如下所示：
- en: Can our code call the SMS gateway?
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码能调用短信网关吗？
- en: Would the connection to the database be OK?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到数据库没问题吗？
- en: Are the HTTP headers being sent from our service?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的服务是否发送了HTTP头？
- en: Again, around 20% of our tests, based on my experience, should be integration
    tests; focus on the positive flows and some of the negative that depend on third-party
    modules.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，再次，大约20%的测试应该是集成测试；重点放在正向流程和一些依赖于第三方模块的负向流程上。
- en: 'When it comes down to E2E tests, they should be very limited and only test
    the main flows of the applications without going into too much detail. These details
    should be already captured by the unit and integration tests that are easy to
    fix in an event of failure. However, there is a catch here: when testing microservices
    in Node.js, 90% of the time, integration and E2E tests can be the same thing.
    Due to the dynamic nature of Node.js, we can test the rest API from the integration
    point of view (the full server running), but in reality, we will also be testing
    how our code behaves when integrated with other modules. We will see an example
    later in this chapter.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到E2E测试时，它们应该非常有限，只测试应用程序的主要流程，而不要过多地进入细节。这些细节应该已经被单元测试和集成测试捕获，易于在失败事件中修复。然而，这里有一个问题：在Node.js中测试微服务时，90%的情况下，集成测试和E2E测试可能是一回事。由于Node.js的动态特性，我们可以从集成的角度测试REST
    API（完整的服务器运行），但实际上，我们也将测试我们的代码与其他模块集成时的行为。我们将在本章后面看到一个例子。
- en: Testing microservices in Node.js
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Node.js中测试微服务
- en: Node.js is an impressive language. The amount of libraries around any single
    aspect of the development is amazing. No matter how bizarre the task that you
    want to achieve in Node.js is, there will be always an npm module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一种令人印象深刻的语言。在任何开发方面都有大量的库。无论你想在Node.js中实现多么奇怪的任务，总会有一个npm模块。
- en: 'Regarding the testing, Node.js has a very powerful set of libraries, but two
    of them are especially popular: **Mocha** and **Chai**.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试，Node.js有一套非常强大的库，但其中两个特别受欢迎：**Mocha**和**Chai**。
- en: They are pretty much the industry standard for app testing and are very well
    maintained and upgraded.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在应用测试方面几乎是行业标准，并且得到了很好的维护和升级。
- en: Another interesting library is called **Sinon.JS**, and it is used for mocking,
    spying and stubbing methods. We will come back to these concepts in the following
    sections, but this library is basically used to simulate integrations with third
    parties without interacting with them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的库叫做**Sinon.JS**，它用于模拟、监视和存根方法。我们将在接下来的章节中回到这些概念，但这个库基本上是用来模拟与第三方的集成而不与它们交互。
- en: Chai
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chai
- en: This library is a BDD/TDD assertions library that can be used in conjunction
    with any other library to create high quality tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库是一个可以与任何其他库一起使用的BDD/TDD断言库，用来创建高质量的测试。
- en: 'An assertion is a code statement that will either be fulfilled or throw an
    error, stopping the test and marking it as a failure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是一个代码语句，它要么被满足，要么抛出一个错误，停止测试并标记为失败：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding statement will be correct when the variable `A` contains the
    value `5`. This is a very powerful tool to write easy-to-understand tests, and
    especially with Chai, we have access to assertions making use of the following
    three different interfaces:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量`A`包含值`5`时，前面的语句将是正确的。这是一个非常强大的工具，用于编写易于理解的测试，特别是使用Chai时，我们可以使用以下三种不同的接口来进行断言：
- en: '`should`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should`'
- en: '`expect`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect`'
- en: '`assert`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`'
- en: At the end of the day, every single condition can be checked using a single
    interface, but the fact that the library provides us with such a rich interface
    facilitates the verbosity of the tests in order to write clean, easy, and maintainable
    tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，每个条件都可以使用单个接口进行检查，但是库提供了如此丰富的接口，使得测试的冗长程度减少，从而编写干净、简单和易于维护的测试。
- en: 'Let''s install the library:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装这个库：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will produce the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Chai](img/B04889_06_22.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Chai](img/B04889_06_22.jpg)'
- en: This means that Chai depends on `assertion-error`, `type-detect`, and `deep-eql`.
    As you can see, this is a good indication that we will be able to check, with
    simple instructions, complex statements such as deep equality in objects or type
    matching.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Chai依赖于`assertion-error`、`type-detect`和`deep-eql`。正如你所看到的，这是一个很好的迹象，表明我们可以使用简单的指令来检查复杂的语句，比如对象的深度相等或类型匹配。
- en: 'Testing libraries such as Chai are not a direct dependency of our application,
    but a development dependency. We need them to develop applications, but they should
    not be shipped to production. This is a good reason to restructure our `package.json`
    and add Chai in the `devDependencies` dependency tag, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 像Chai这样的测试库不是我们应用程序的直接依赖，而是开发依赖。我们需要它们来开发应用程序，但它们不应该被发布到生产环境。这是重构我们的`package.json`并将Chai添加到`devDependencies`依赖标签的一个很好的理由，如下所示：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will prevent our software to ship into production libraries such as Chai,
    which has nothing to do with the operation of our application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将阻止我们的软件将Chai等与我们应用程序操作无关的库发布到生产环境。
- en: Once we have installed Chai, we can start playing around with the interfaces.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Chai，我们就可以开始尝试不同的接口。
- en: BDD-style interfaces
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BDD风格的接口
- en: Chai comes with two flavors of BDD interfaces. It is a matter of preference
    which one to use, but my personal recommendation is to use the one that makes
    you feel more comfortable in any situation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Chai有两种BDD接口的风格。使用哪种取决于个人偏好，但我个人建议使用让你在任何情况下感觉更舒适的那种。
- en: 'Let''s start with the `should` Interface. This one is a BDD-style interface,
    using something similar to the natural language, we can create assertions that
    will decide whether our test succeeds or fails:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`should`接口开始。这是一种BDD风格的接口，使用类似自然语言的东西，我们可以创建断言来决定我们的测试是成功还是失败：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to be able to build sentences like the one before, we need to import
    the `should` module in our program:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够构建像前面那样的句子，我们需要在程序中导入`should`模块：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Although it looks like a bit of dark magic, it is really convenient when testing
    our code as we use something similar to the natural language to ensure that our
    code is meeting some criteria: *foo should be equal to ''Hello world''* has a
    direct translation to our test.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来有点像黑魔法，但在测试我们的代码时，使用类似自然语言的东西来确保我们的代码满足某些标准是非常方便的：*foo应该等于'Hello world'*直接翻译成我们的测试。
- en: The second BDD-style interface provided by Chai is `expect`. Although it is
    very similar to `should`, it changes a bit of syntax in order to set expectations
    that the results have to meet.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Chai提供的第二种BDD风格接口是`expect`。虽然它与`should`非常相似，但它改变了一些语法，以便设置结果必须满足的期望。
- en: 'Let''s see the following example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, the style is very similar: a fluent interface that allows us
    to check whether the conditions for the test to succeed are met, but what happens
    if the conditions are not met?'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，风格非常相似：一种流畅的接口，允许我们检查测试成功的条件是否满足，但是如果条件不满足会发生什么呢？
- en: 'Let''s execute a simple Node.js program that fails in one of the conditions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行一个简单的Node.js程序，其中一个条件失败：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s execute the previous script, assuming that you have already installed
    Chai:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行前面的脚本，假设您已经安装了Chai：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An exception is thrown and the test fails. If all the conditions were validated,
    no exception would have been raised and the test would have succeeded.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将引发异常并且测试失败。如果所有条件都得到验证，就不会引发异常，测试就会成功。
- en: 'As you can see, there are a number of natural language words that we can use
    for our tests using both `expect` and `should` interfaces. The full list can be
    found in the Chai documentation ([http://chaijs.com/api/bdd/#-include-value-](http://chaijs.com/api/bdd/#-include-value-)),
    but let''s explain some of the most interesting ones in the following list:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以使用`expect`和`should`接口进行测试的自然语言词汇有很多。完整列表可以在Chai文档中找到（[http://chaijs.com/api/bdd/#-include-value-](http://chaijs.com/api/bdd/#-include-value-)），但让我们在以下列表中解释一些最有趣的内容：
- en: '`not`: This word is used to negate the assertions following in the chain. For
    example, `expect("some string").to.not.equal("Other String")` will pass.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`：这个词用于否定链中的断言。例如，`expect("some string").to.not.equal("Other String")`将通过。'
- en: '`deep`: This word is one of the most interesting of all the collection. It
    is used to deep-compare objects, which is the quickest way to carry on a full
    equal comparison. For example, `expect(foo).to.deep.equal({name: "David"})` will
    succeed if `foo` is a JavaScript object with one property called `name` with the
    `"David"` string value.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deep`：这个词是所有集合中最有趣的之一。它用于深度比较对象，这是进行完全相等比较的最快方法。例如，`expect(foo).to.deep.equal({name:
    "David"})`将在`foo`是一个具有名为`name`且值为`"David"`的属性的JavaScript对象时成功。'
- en: '`any`/`all`: This is used to check whether the dictionary or object contains
    any of the keys in the given list so that `expect(foo).to.have.any.keys("name",
    "surname")` will succeed if `foo` contains any of the given keys, and `expect(foo).to.have.all.keys("name",
    "surname")` will only succeed if it has all of the keys.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`/`all`：这用于检查字典或对象是否包含给定列表中的任何键，因此`expect(foo).to.have.any.keys("name",
    "surname")`将在`foo`包含任何给定键时成功，并且`expect(foo).to.have.all.keys("name", "surname")`只有在它拥有所有键时才会成功。'
- en: '`ok`: This is an interesting one. As you probably know, JavaScript has a few
    pitfalls, and one of them is the true/false evaluation of expressions. With `ok`,
    we can abstract all the mess and do something similar to the following list of
    expressions:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ok`：这是一个有趣的词。您可能知道，JavaScript有一些陷阱，其中之一是表达式的真/假评估。使用`ok`，我们可以抽象出所有混乱，并执行类似于以下表达式列表的操作：'
- en: '`expect(''everything'').to.be.ok`: `''everything''` is a string and it will
    be evaluated to `ok`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect(''everything'').to.be.ok`：`''everything''`是一个字符串，它将被评估为`ok`'
- en: '`expect(undefined).to.not.be.ok`: Undefined is not ok in the JavaScript world,
    so this assertion will succeed'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect(undefined).to.not.be.ok`：在JavaScript世界中，未定义是不好的，因此这个断言将成功'
- en: '`above`: This is a very useful word to check whether an array or collection
    contains a number of elements above a certain threshold, as follows: `expect([1,2,3]).to.have.length.above(2)`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`above`：这是一个非常有用的词，用来检查数组或集合是否包含超过某个阈值的元素数量，如下所示：`expect([1,2,3]).to.have.length.above(2)`'
- en: As you can see, the Chai API for fluent assertions is quite rich and enables
    us to write very descriptive tests that are easy to maintain.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Chai的流畅断言API非常丰富，使我们能够编写非常描述性的测试，易于维护。
- en: 'Now, you may be asking yourself, why have two flavors of the same interface
    that pretty much work the same? Well, they functionally do the same, however,
    take a look at the detail:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能会问自己，为什么有两种基本相同的接口风格？嗯，它们在功能上确实是一样的，但是，看看细节：
- en: '`expect` provides a starting point in your chainable language'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect`提供了链式语言中的起点'
- en: '`should` extends the `Object.prototype` signature to add the chainable language
    to every single object in JavaScript'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should`扩展了`Object.prototype`签名，以在JavaScript中的每个对象上添加可链式调用的语言'
- en: From Node.js' point of view, both of them are fine, although the fact that `should`
    is instrumenting the prototype of `Object` could be a reason to be a bit paranoid
    about using it as it is intrusive.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从Node.js的角度来看，它们两者都可以，尽管`should`仪器化了`Object`的原型，这可能是对使用它有点偏执的原因。
- en: Assertions interface
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断言接口
- en: 'The **assertions** interface matches the most common old-fashioned tests assertion
    library. In this flavor, we need to be specific about what we want to test, and
    there is no such thing as fluent chaining of expressions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言**接口与最常见的老式测试断言库相匹配。在这种风格中，我们需要明确我们要测试什么，没有表达式的流畅链接：'
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is really nothing more to go in depth if you have already used any of
    the existing test libraries in any language.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在任何语言中使用过任何现有的测试库，那么就没有更多的深入了。
- en: Mocha
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mocha
- en: Mocha is, in my opinion, one of the most convenient testing frameworks that
    I have ever used in my professional life. It follows the principles of **behavior-driven**
    **development testing** (**BDDT**), where the test describes a use case of the
    application and uses the assertions from another library to verify the outcome
    of the executed code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha在我看来是我职业生涯中使用过的最方便的测试框架之一。它遵循**行为驱动** **开发测试**（**BDDT**）的原则，其中测试描述了应用程序的用例，并使用另一个库的断言来验证执行代码的结果。
- en: Although it sounds a bit complicated, it is really convenient to ensure that
    our code is covered from the functional and technical point of view, as we will
    be mirroring the requirements used to build the application into automated tests
    that verifies them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来有点复杂，但确保我们的代码从功能和技术角度得到覆盖确实非常方便，因为我们将构建应用程序所使用的要求镜像到自动化测试中来验证它们。
- en: Let's start with a simple example. Mocha is a bit different from any other library,
    as it defines its own **domain-specific language** (**DSL**) that needs to be
    executed with Mocha instead of Node.js. It is an extension of the language.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始。Mocha与任何其他库都有所不同，因为它定义了自己的**领域特定语言**（**DSL**），需要使用Mocha而不是Node.js来执行。这是语言的扩展。
- en: 'First we need to install Mocha in the system:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们需要在系统中安装Mocha：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will produce an output similar to the following image:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似于以下图像的输出：
- en: '![Mocha](img/B04889_06_03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![摩卡](img/B04889_06_03.jpg)'
- en: 'From now on, we have a new command in our system: `mocha`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们的系统中有一个新的命令：`mocha`。
- en: 'The next step is to write a test using Mocha:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用Mocha编写一个测试：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding example is simple. A function that rolls a dice and returns an
    integer number from `1` to `6`. Now we need to think a bit about the use cases
    and the requirements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子很简单。一个掷骰子并返回从`1`到`6`的整数的函数。现在我们需要思考一下使用情况和要求：
- en: The number has to be an integer
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个数字必须是整数
- en: This integer has to be below 7
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个整数必须小于7
- en: It has to be above 0, dice don't have negative numbers
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须大于0，骰子不可能有负数
- en: The function cannot return `null`
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数不能返回`null`
- en: The function cannot return `undefined`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数不能返回`undefined`
- en: This covers pretty much every corner case about rolling a dice in Node.js. What
    we are doing is describing situations that we certainly want to test, in order
    to safely make changes to the software without breaking the existing functionality.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎涵盖了在Node.js中掷骰子的每一个边角案例。我们正在描述我们确实想要测试的情况，以便安全地对软件进行更改而不会破坏现有的功能。
- en: 'These five use cases are an exact map to the tests written earlier:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个用例与之前编写的测试完全吻合：
- en: '**We describe the situation**: *When a customer rolls a dice*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们描述情况**：*当客户掷骰子时*'
- en: '**Conditions get verified**: *It should return an integer number*'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件得到验证**：*它应该返回一个整数*'
- en: 'Let''s run the previous test and check the results:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行之前的测试并检查结果：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should return something similar to the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回类似于以下截图的内容：
- en: '![Mocha](img/B04889_06_04.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![摩卡](img/B04889_06_04.jpg)'
- en: As you can see, Mocha returns a comprehensive report on what is going on in
    the tests. In this case, all of them pass, so we don't need to be worried about
    problems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Mocha对测试中发生的情况进行了全面的报告。在这种情况下，所有测试都通过了，所以我们不需要担心问题。
- en: 'Let''s force some of the tests to fail:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们强制一些测试失败：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Accidentally, someone has bumped a code fragment into the `rollDice()` function,
    which makes the function return a number that does not meet some of the requirements.
    Let''s run Mocha again, as shown in the following image:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不小心，有人把一个代码片段插入了`rollDice()`函数中，这使得函数返回一个不符合一些要求的数字。让我们再次运行Mocha，如下图所示：
- en: '![Mocha](img/B04889_06_05.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![摩卡](img/B04889_06_05.jpg)'
- en: 'Now, we can see the report returning one error: the method is returning `-4`,
    where it should always return a number bigger than `0`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到报告返回了一个错误：该方法返回了`-4`，而它应该始终返回一个大于`0`的数字。
- en: Also, one of the benefits of this type of testing in Node.js using Mocha and
    Chai is the time. Tests run very fast so that it is easy to receive feedback if
    we have broken something. The preceding suite ran in `10ms`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此类测试在Node.js中使用Mocha和Chai的一个好处是时间。测试运行非常快，因此很容易得到反馈，如果我们有破坏的东西。前面的套件运行在`10ms`内。
- en: Sinon.JS – a mocking framework
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sinon.JS - 一个模拟框架
- en: The previous two chapters have been focused on asserting conditions on return
    values of functions, but what happens when our function does not return any value?
    The only correct measurement is to check whether the method was called or not.
    Also, what if one of our modules is calling a third-party web service, but we
    don't want our tests to call the remote server?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前两章已经集中在对函数返回值的断言条件上，但是当我们的函数没有返回任何值时会发生什么呢？唯一正确的衡量标准是检查方法是否被调用。另外，如果我们的模块之一正在调用第三方网络服务，但我们不希望我们的测试调用远程服务器会怎么样呢？
- en: 'For answering these questions, we have two conceptual tools called mocks and
    spies, and Node.js has the perfect library to implement them: Sinon.JS.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们有两个概念工具，称为模拟和间谍，Node.js有一个完美的库来实现它们：Sinon.JS。
- en: 'First install it, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装它，如下所示：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command should produce the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应该产生以下输出：
- en: '![Sinon.JS – a mocking framework](img/B04889_06_06.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Sinon.JS - 一个模拟框架](img/B04889_06_06.jpg)'
- en: 'Now let''s explain how it works through an example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过一个例子来解释它是如何工作的：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This simple script calculates the hypotenuse of a triangle, given the length
    of the other two sides of the triangle. One of the tests that we want to carry
    on is the fact that the callback is executed with the right list of arguments
    supplied. What we need to accomplish such task is what Sinon.JS calls a spy:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的脚本计算三角形的斜边，给定三角形的另外两边的长度。我们想要进行的测试之一是回调是否以正确的参数列表执行。我们需要完成这样的任务的是Sinon.JS称之为间谍：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once again, we are using Mocha to run the script and Chai to verify the results
    in the test through the `should` interface, as shown in the following image:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用Mocha来运行脚本，并使用Chai通过`should`接口验证测试结果，如下图所示：
- en: '![Sinon.JS – a mocking framework](img/B04889_06_23.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Sinon.JS - 一个模拟框架](img/B04889_06_23.jpg)'
- en: 'The important line in the preceding script is:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面脚本中的重要行是：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are creating the spy and injecting it into the function as a callback.
    This function created by Sinon.JS is actually not only a function, but a full
    object with a few interesting points of information. Sinon.JS does that, taking
    advantage of the dynamic nature of JavaScript. You can actually see what is in
    this object by dumping it into the console with `console.log()`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建间谍并将其作为回调注入到函数中。Sinon.JS创建的这个函数实际上不仅是一个函数，而是一个带有一些有趣信息点的完整对象。Sinon.JS利用JavaScript的动态特性来做到这一点。您实际上可以通过将其转储到控制台中的`console.log()`中来查看此对象中的内容。
- en: 'Another very powerful tool in Sinon.JS are the stubs. **Stubs** are very similar
    to mocks (identical at practical effects in JavaScript) and allow us to fake functions
    to simulate the required return:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS中另一个非常强大的工具是存根。**存根**与模拟非常相似（在JavaScript中在实际效果上是相同的），并允许我们伪造函数以模拟所需的返回：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, we have stubbed the `Math#random` method, which causes the method
    to be some sort of overloaded empty function (it does not issue the get call)
    that records stats on what or how it was called.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们对`Math#random`方法进行了存根，这导致该方法成为某种过载的空函数（它不发出get调用），并记录了有关其调用方式或方式的统计信息。
- en: 'There is one catch in the preceding code: we never restored the `random()`
    method back and this is quite dangerous. It has a massive side effect, as other
    tests will see the `Math#random` method as a stub, not as the original one, and
    it can lead to us coding our tests according to invalid information.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中有一个陷阱：我们从未将`random()`方法恢复，这是非常危险的。它具有巨大的副作用，因为其他测试将把`Math#random`方法视为存根，而不是原始方法，这可能导致我们根据无效信息编写测试。
- en: 'In order to prevent this, we need to make use of the `before()` and `after()`
    methods from Mocha:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，我们需要使用Mocha的`before()`和`after()`方法：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you pay attention to the highlighted code, we are telling Sinon.JS to restore
    the original method that was stubbed inside one of the `it` blocks, so that if
    another `describe` block makes use of `http.get`, we won't see the stub, but the
    original method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到突出显示的代码，我们正在告诉Sinon.JS恢复在一个`it`块内部存根的原始方法，以便如果另一个`describe`块使用`http.get`，我们将不会看到存根，而是原始方法。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `before()` and `after()` methods are very helpful to set up and wind down
    the context for the tests. However, you need to be careful with the scope where
    they are executed as it could lead to test interactions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`before()`和`after()`方法非常有助于为测试设置和清理上下文。但是，您需要小心它们执行的范围，因为它可能导致测试相互影响。'
- en: 'Mocha has a few flavors of before and after:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha有几种before和after的变体：
- en: '`before(callback)`: This is executed before the current scope (at the beginning
    of the `describe` block in the preceding code)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before(callback)`: 这在当前范围之前执行（在上述代码中的`describe`块的开头）'
- en: '`after(callback)`: This is executed after the current scope (at the end of
    the `describe` block in the preceding code)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after(callback)`: 这在当前范围之后执行（在上述代码中的`describe`块的末尾）'
- en: '`beforeEach(callback)`: This is executed at the beginning of every element
    in the current scope (before each `it` in the preceding example)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach(callback)`: 这在当前范围的每个元素开始时执行（在上述示例中的每个`it`之前）'
- en: '`afterEach(callback)`: This is executed at the end of every element in the
    current scope (after every `it` in the preceding example)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach(callback)`: 这在当前范围的每个元素结束时执行（在上述示例中的每个`it`之后）'
- en: 'Another interesting feature in Sinon.JS is the time manipulation. Some of the
    tests need to execute periodic tasks or respond after a certain time of an event''s
    occurrence. With Sinon.JS, we can dictate time as one of the parameters of our
    tests:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS中的另一个有趣功能是时间操纵。一些测试需要在事件发生后的一定时间内执行周期性任务或响应。使用Sinon.JS，我们可以将时间作为测试的参数之一来规定时间：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we can now control the time in our tests.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们现在可以在我们的测试中控制时间。
- en: Testing a real microservice
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试一个真实的微服务
- en: Now, it is time to test a real microservice in order to get a general picture
    of the full test suite.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候测试一个真实的微服务，以便对整个测试套件有一个总体了解。
- en: 'Our microservice is going to use Express, and it will filter an input text
    to remove what the search engines call **stop words**: *words with less than three
    characters and words that are banned*.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微服务将使用Express，并将过滤输入文本以删除搜索引擎称为**停用词**的内容：*少于三个字符的单词和被禁止的单词*。
- en: 'Let''s see the code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the service is pretty small, so it is the perfect example for
    explaining how to write unit, integration, and E2E tests. In this case, as we
    stated before, E2E and integration tests are going to be the exact same as testing
    the service through the REST API will be equivalent to testing the system from
    the end-to-end point of view, but also how our component is integrated within
    the system. Given that, if we were to add a UI, we would have to split integration
    tests from E2E in order to ensure the quality.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这项服务非常小，因此它是解释如何编写单元测试、集成测试和端到端测试的完美示例。在这种情况下，正如我们之前所说，端到端和集成测试将与通过REST
    API测试服务等效，这将等同于从端到端的角度测试系统，以及我们的组件如何集成到系统中。鉴于此，如果我们要添加用户界面，我们将不得不将集成测试与端到端测试分开，以确保质量。
- en: TDD – Test-driven development
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TDD – 测试驱动开发
- en: 'Our service is done and working. However, now we want to unit test it, but
    we find some problems:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务已经完成并且正在运行。但是，现在我们想对其进行单元测试，但我们发现了一些问题：
- en: The function that we want to unit test is not visible outside the main `.js`
    file
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要进行单元测试的函数在主`.js`文件之外是不可见的
- en: The server code is tightly coupled to the functional code and has bad cohesion
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器代码与功能代码紧密耦合，内聚性不好
- en: 'Here TDD comes to the rescue; we should always ask ourselves "how am I going
    to test this function when writing software?" It does not mean that we should
    modify our software with the specific purpose of testing, but if you are having
    problems while testing a part of your program, more than likely, you should look
    into cohesion and coupling, as it is a good indication of problems. Let''s take
    a look at the following file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，TDD来拯救；我们应该始终问自己“在编写软件时，我要如何测试这个函数？”这并不意味着我们应该修改我们的软件以进行特定的测试，但如果在测试程序的某个部分时出现问题，很可能应该查看内聚性和耦合性，因为这是问题的一个很好的指示。让我们看看下面的文件：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This file is a module that, in my opinion, is highly reusable and has good
    cohesion:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是一个模块，在我看来，它是高度可重用的，并且具有良好的内聚性：
- en: We can import it everywhere (even in a browser)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在任何地方导入它（甚至在浏览器中）
- en: The banned words can be injected when creating the module (very useful for testing)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止的单词可以在创建模块时注入（非常适用于测试）
- en: It is not tangled with the application code
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有与应用程序代码纠缠在一起
- en: 'Laying down the code this way, our application module will look similar to
    the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写代码，我们的应用程序模块将类似于以下内容：
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, we have clearly separated the business unit (the function that
    captures the business logic) from the operational unit (the setup of the server).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经清楚地将业务单元（捕获业务逻辑的函数）与操作单元（服务器的设置）分开。
- en: As I mentioned before, I am not a big fan of writing the tests prior to the
    code, but they should be written (in my opinion) alongside the code, but always
    having in mind the question mentioned before.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我不是先写测试再写代码的铁杆粉丝，但测试应该（在我看来）与代码一起编写，但始终牢记前面提到的问题。
- en: There seem to be a push in companies to adopt a TDD methodology, but it could
    lead to a significant inefficiency, especially if the business requirements are
    unclear (as they are 90% of the time) and we face changes along the development
    process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 公司似乎在推动采用TDD方法，但这可能导致显着的低效，特别是如果业务需求不清晰（通常情况下是90%），并且我们在开发过程中面临变化。
- en: Unit testing
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Now that our code is in a better shape, we are going to unit test our function.
    We will use Mocha and Chai to accomplish such task:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码形式更好了，我们将对函数进行单元测试。我们将使用Mocha和Chai来完成这样的任务：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we have covered pretty much every single case and branch inside
    our application, but how is our code coverage looking?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经覆盖了几乎每一个在我们应用程序中的情况和分支，但我们的代码覆盖率如何？
- en: 'Until now, we have mentioned it, but never actually measured it. We are going
    to use one tool, called **Istanbul**, to measure the test coverage:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经提到过它，但从未实际测量过。我们将使用一个名为**Istanbul**的工具来测量测试覆盖率：
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should install Istanbul. Now we need to run the coverage report:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该安装Istanbul。现在我们需要运行覆盖率报告：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will produce an output similar to the one shown in the following image:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个类似于下图所示的输出：
- en: '![Unit testing](img/B04889_06_07.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![单元测试](img/B04889_06_07.jpg)'
- en: 'This will also generate a coverage report in HTML, pointing out which lines,
    functions, branches, and statements are not being covered, as shown in the following
    screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将生成一个HTML覆盖率报告，指出哪些行、函数、分支和语句没有被覆盖，如下面的截图所示：
- en: '![Unit testing](img/B04889_06_08.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![单元测试](img/B04889_06_08.jpg)'
- en: 'As you can see, we are looking pretty well. Our code (not the tests) is actually
    well covered, especially if we look into the detailed report for our code file,
    as shown in the following image:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们看起来相当不错。我们的代码（而不是测试）实际上覆盖得很好，特别是如果我们查看我们代码文件的详细报告，如下图所示：
- en: '![Unit testing](img/B04889_06_09.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![单元测试](img/B04889_06_09.jpg)'
- en: We can see that only one branch (the `or` operator in line **7**) is not covered
    and the `if` operator in line **6** never diverted to the `else` operator.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到只有一个分支（第7行的`or`运算符）没有被覆盖，第6行的`if`运算符从未转到`else`运算符。
- en: 'We also got information about the number of times a line is executed: it is
    showing in the vertical bar beside the line number. This information is also very
    useful to spot the hot areas of our application where an optimization will benefit
    the most.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还获得了关于一行代码执行次数的信息：它显示在行号旁边的垂直条中。这些信息对于发现我们应用程序的热点区域非常有用，优化将最有益处。
- en: 'Regarding the right level of coverage, in this example, it is fairly easy to
    go up to 90%+, but unfortunately, it is not that easy in production systems:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 关于正确的覆盖率水平，在这个例子中，很容易达到90%以上，但不幸的是，在生产系统中并非如此容易：
- en: Code is a lot more complex
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码更加复杂
- en: Time is always a constraint
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间总是一个限制
- en: Testing might not be seen as productive time
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试可能不被视为生产时间
- en: However, you should exercise caution when working with a dynamic language. In
    Java or C#, calling a function that does not exist results in a compilation time
    error; whereas in JavaScript, it will result in a runtime error. The only real
    barrier is the testing (manual or automated), so it is a good practice to ensure
    that at least every line is executed once. In general code coverage, over 75%
    should be good enough for the majority of cases.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用动态语言时，需要谨慎。在Java或C#中，调用不存在的函数会导致编译时错误；而在JavaScript中，会导致运行时错误。唯一的真正障碍是测试（手动或自动化），因此最好的做法是确保至少每一行都执行一次。一般来说，代码覆盖率超过75%对于大多数情况应该足够了。
- en: End-to-end testing
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 端到端测试
- en: In order to test our application end to end, we are going to need a server running
    it. Usually, end-to-end tests are executed against a controlled environment, such
    as a QA box or a pre-production machine, to verify that our about-to-be-deployed
    software is behaving as expected.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对我们的应用程序进行端到端测试，我们需要一个运行它的服务器。通常，端到端测试是针对受控环境（如QA盒子或预生产机器）执行的，以验证我们即将部署的软件是否表现如预期。
- en: In this case, our application is an API, so we are going to create the end-to-end
    tests, which at the same time, are going to be used as integration tests.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的应用程序是一个API，因此我们将创建端到端测试，同时也将用作集成测试。
- en: However, in a full application, we might want to have a clear separation between
    the integration and end-to-end tests and use something like Selenium to test our
    application from the UI point of view.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一个完整的应用程序中，我们可能希望在集成和端到端测试之间有明确的分离，并使用类似Selenium的工具来从UI的角度测试我们的应用程序。
- en: 'Selenium is a framework that allows our code to send instructions to the browser,
    as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium是一个允许我们的代码向浏览器发送指令的框架，如下所示：
- en: Click the button with the `button1` ID
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击具有`button1`ID的按钮
- en: Hover over the `div` element with the CSS class `highlighted`
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬停在具有CSS类`highlighted`的`div`元素上
- en: In this way, we can ensure that our app flows work as expected, end to end,
    and our next release is not going to break the key flows of our app.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以确保我们的应用程序流程按预期工作，端到端，我们的下一个发布版本不会破坏应用程序的关键流程。
- en: Let's focus on the end-to-end tests for our microservice. We have been using
    Chai and Mocha with their corresponding assertion interfaces to unit test our
    software, and Sinon.JS to mock services functions and other elements to avoid
    the calls being propagated to third-party web services or get a controlled response
    from one method.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于我们微服务的端到端测试。我们一直在使用Chai和Mocha及其相应的断言接口来对我们的软件进行单元测试，并使用Sinon.JS来模拟服务函数和其他元素，以避免调用传播到第三方网络服务或从一个方法获得受控响应。
- en: Now, in our end-to-end test plan, we actually want to issue the calls to our
    service and get the response to validate the results.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的端到端测试计划中，我们实际上希望发出调用到我们的服务并获取响应以验证结果。
- en: The first thing we need to do is run our microservice somewhere. We are going
    to use our local machine just for convenience, but we can execute these tests
    in a continuous development environment against a QA machine.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在某个地方运行我们的微服务。我们将仅仅使用我们的本地机器出于方便，但我们可以在持续开发环境中针对QA机器执行这些测试。
- en: 'So, let''s start the server:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们启动服务器：
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I call my script `stop-words.js` for convenience. Once the server is running,
    we are ready to start testing. In some situations, we might want our test to start
    and stop the server so that everything is self-contained. Let''s see a small example
    about how to do it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我的脚本称为`stop-words.js`以方便起见。一旦服务器运行，我们就准备开始测试。在某些情况下，我们可能希望我们的测试启动和停止服务器，以便一切都是自包含的。让我们看一个关于如何做到这一点的小例子：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, Express provides a handler to operate the server programmatically,
    so it is as simple as making use of the `before()` and `after()` functions to
    do the trick.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Express提供了一个处理程序来以编程方式操作服务器，因此只需简单地使用`before()`和`after()`函数来实现。
- en: In our example, we are going to assume that the server is running. In order
    to issue the requests, we are going to use a library called `request` to issue
    the calls to the server.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将假设服务器正在运行。为了发出请求，我们将使用一个名为`request`的库来向服务器发出调用。
- en: 'The way to install it, as usual, is to execute `npm install request`. Once
    it is finished, we can make use of this amazing library:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 安装它的方式与往常一样，执行`npm install request`。一旦完成，我们就可以利用这个令人惊叹的库：
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the simple test from earlier, we managed to test our server in a way that
    ensures that every single mobile part of the application has been executed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前的简单测试，我们设法测试了我们的服务器，以确保应用程序的每个移动部分都已执行。
- en: 'There is a particularity here that we didn''t have before:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个我们以前没有的特殊之处：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you take a look at the highlighted code, you can see a new callback called
    `done`. This callback has one mission: prevent the test from finishing until it
    is called, so that the HTTP request has time to be executed and return the appropriated
    value. Remember, Node.js is asynchronous, there is no such thing as a thread being
    blocked until one operation finishes.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下突出显示的代码，你会看到一个叫做`done`的新回调。这个回调有一个任务：防止测试在调用之前结束，以便HTTP请求有时间执行并返回适当的值。记住，Node.js是异步的，没有线程被阻塞直到一个操作完成。
- en: Other than that, we are using a new DSL introduced by `chai-http` to build get
    requests.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们正在使用`chai-http`引入的新DSL来构建get请求。
- en: 'This language allows us to build a large range of combinations, consider the
    following, for example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言允许我们构建大量的组合，例如考虑以下内容：
- en: '[PRE30]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding request, we are submitting a form that looks like a login,
    so that in the `end()` function, we can assert the return from the server.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的请求中，我们正在提交一个看起来像登录的表单，因此在`end()`函数中，我们可以断言来自服务器的返回。
- en: There are an endless number of combinations to test our APIs with `chai-http`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有无数种组合可以使用`chai-http`来测试我们的API。
- en: Manual testing – the necessary evil
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动测试-必要的恶
- en: No matter how much effort we put in to our automated testing, there will always
    be a number of manual tests executed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们对自动化测试付出多少努力，总会有一些手动测试被执行。
- en: Sometimes, we need to do it just when we are developing our API, as we want
    to see the messages going from our client to the server, but some other times,
    we just want to hit our endpoints with a pre-forged request to cause the software
    to execute as we expect.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要在开发API时这样做，因为我们想要看到从客户端到服务器的消息传递，但有时我们只是想用预先制作的请求命中我们的端点，以使软件按我们的预期执行。
- en: In the first case, we are going to take the advantage of Node.js and its dynamic
    nature to build a proxy that will sniff all the requests and log them to a terminal
    so that we can debug what is going on. This technique can be used to leverage
    the communication between two microservices and see what is going on without interrupting
    the flow.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们将利用Node.js及其动态特性来构建一个代理，该代理将嗅探所有请求并将它们记录到终端，以便我们可以调试发生了什么。这种技术可以用来利用两个微服务之间的通信，并查看发生了什么，而不会中断流程。
- en: In the second case, we are going to use software called Postman to issue requests
    against our server in a controlled way.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们将使用名为Postman的软件以受控方式向我们的服务器发出请求。
- en: Building a proxy to debug our microservices
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建一个用于调试我们的微服务的代理
- en: 'My first contact with Node.js was exactly due to this problem: two servers
    sending messages to each other, causing misbehavior without an apparent cause.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次接触Node.js正是因为这个问题：两台服务器彼此发送消息，导致行为异常，没有明显的原因。
- en: 'It is a very common problem that has many already-working solutions (man-in-the-middle
    proxies basically), but we are going to demonstrate how powerful Node.js is:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常见的问题，有许多已经运行的解决方案（基本上是中间人代理），但我们将演示Node.js有多强大：
- en: '[PRE31]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you remember from the previous section, our `stop-words.js` program was running
    on the port `3000`. What we have done with this code is create a proxy using `http-proxy`,
    that tunnels all the requests made on the port `4000` into the port `3000` after
    logging the headers into the console.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得上一节，我们的`stop-words.js`程序是在端口`3000`上运行的。我们用这段代码做的是使用`http-proxy`创建一个代理，将在端口`4000`上发出的所有请求都隧道到端口`3000`，然后将头信息记录到控制台中。
- en: 'If we run the program after installing all the dependencies with the `npm install`
    command in the root of the project, we can see how effectively the proxy is logging
    the requests and tunneling them into the target host:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在项目的根目录中使用`npm install`命令安装了所有依赖项后运行程序，我们可以看到代理如何有效地记录请求并将其隧道到目标主机：
- en: '[PRE32]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will produce the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Building a proxy to debug our microservices](img/B04889_06_10.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![Building a proxy to debug our microservices](img/B04889_06_10.jpg)'
- en: This example is very simplistic, but this small proxy could virtually be deployed
    anywhere in between our microservices and give us very valuable information about
    what is going on in the network.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常简单，但这个小代理可以在我们的微服务之间的任何地方部署，并为我们提供有关网络情况的非常有价值的信息。
- en: Postman
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Postman
- en: Out of all the software that we can find on the Internet for testing APIs, Postman
    is my favorite. It started as a extension for Google Chrome, but nowadays, has
    taken the form of a standalone app built on the Chrome runtime.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上可以找到的所有用于测试API的软件中，Postman是我最喜欢的。它起初是谷歌Chrome的一个扩展，但如今已经成为一个基于Chrome运行时构建的独立应用程序。
- en: It can be found in the Chrome web store, and it is free (so you don't need to
    pay for it), although it has a version for teams with more advanced features that
    is paid.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在Chrome网络商店中找到，而且是免费的（所以你不需要付费），尽管它有一个团队版本，具有更高级功能，是付费的。
- en: 'The interface is very concise and simple, as shown in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 界面非常简洁和简单，如下面的屏幕截图所示：
- en: '![Postman](img/B04889_06_11.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![Postman](img/B04889_06_11.jpg)'
- en: On the left-hand side, we can see the **History** of requests, as well as the
    **Collections** of requests, which will be very handy for when we are working
    on a long-term project and we have some complicated requests to be built.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们可以看到请求的**历史记录**，以及请求的**集合**，这对于我们在长期项目上工作并且需要构建一些复杂请求时非常方便。
- en: We are going to use again our `stop-words.js` microservice to show how powerful
    Postman can be.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用我们的`stop-words.js`微服务来展示Postman有多强大。
- en: 'Therefore, the first thing is to make sure that our microservice is running.
    Once it is, let''s issue a request from Postman, as shown in the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首要任务是确保我们的微服务正在运行。一旦它运行起来，让我们从Postman发出一个请求，如下面的屏幕截图所示：
- en: '![Postman](img/B04889_06_12.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![Postman](img/B04889_06_12.jpg)'
- en: 'As simple as that, we have issued the request for our service (using the **GET**
    verb) and it has replied with the text filtered: very simple and effective.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们已经发出了对我们的服务的请求（使用**GET**动词），它已经回复了过滤后的文本：非常简单而有效。
- en: 'Now imagine that we want to execute that call over Node.js. Postman comes with
    a very interesting feature, which is generating the code for the requests that
    we issue from the interface. If you click on the icon under the save button on
    the right-hand side of the window, the appearing screen will do the magic:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们想要在Node.js上执行该调用。Postman带有一个非常有趣的功能，即生成我们从界面发出的请求的代码。如果你点击窗口右侧保存按钮下面的图标，出现的屏幕将会做魔术：
- en: '![Postman](img/B04889_06_13.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![Postman](img/B04889_06_13.jpg)'
- en: 'Let''s take a look at the generated code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下生成的代码：
- en: '[PRE33]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is quite an easy code to understand, especially if you are familiar with
    the HTTP library.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常容易理解的代码，特别是如果你熟悉HTTP库。
- en: With Postman, we can also send cookies, headers, and forms to the servers in
    order to mimic the authentication that an application will fulfill by sending
    the authentication token or cookie across.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Postman，我们还可以发送cookie、头部和表单到服务器，以模拟应用程序通过发送身份验证令牌或cookie来实现的身份验证。
- en: 'Let''s redirect our request to the proxy that we created in the preceding section,
    as shown in the following screenshot:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们在前一节中创建的代理重定向到代理，如下面的屏幕截图所示：
- en: '![Postman](img/B04889_06_14.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![Postman](img/B04889_06_14.jpg)'
- en: 'If you have the proxy and the `stop-words.js` microservice running, you should
    see something similar to the following output in the proxy:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代理和`stop-words.js`微服务正在运行，你应该在代理中看到类似以下输出：
- en: '![Postman](img/B04889_06_15.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![Postman](img/B04889_06_15.jpg)'
- en: The header that we sent over with Postman, **my-awesome-header**, will show
    up in the list of raw headers.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用Postman发送的头部**my-awesome-header**将显示在原始头部列表中。
- en: Documenting microservices
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录微服务
- en: In this section, we are going to learn how to use Swagger to document APIs.
    Swagger is an API manager that follows the **Open API standard**, so that it is
    a *common language* for all the API creators. We will discuss how to write definitions
    and why it is so important to agree on how to describe resources.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用Swagger来记录API。Swagger是一个遵循**Open API标准**的API管理器，因此它是所有API创建者的*共同语言*。我们将讨论如何编写定义以及为什么就如何描述资源达成一致意见如此重要。
- en: Documenting APIs with Swagger
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Swagger记录API
- en: Documentation is always a problem. No matter how hard you try, it will always
    eventually go out of date. Luckily, in the past few years, there has been a push
    into producing a high quality documentation for REST APIs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 文档一直是一个问题。无论你多努力，它最终都会过时。幸运的是，在过去几年中，人们一直在努力为REST API制作高质量的文档。
- en: API managers have played a key role in it, and Swagger is particularly an interesting
    platform to look at. More than a module for documentation, Swagger manages your
    API in a such way that gives you a holistic view of your work.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: API管理者在其中发挥了关键作用，Swagger特别是一个有趣的平台。Swagger不仅仅是一个文档模块，它以一种使您能够全面了解您的工作的方式来管理您的API。
- en: 'Let''s start installing it:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始安装它：
- en: '[PRE34]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will install Swagger system-wide, so it will be another command in our
    system. Now, we need to create a project using it:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在系统范围内安装Swagger，因此它将成为我们系统中的另一个命令。现在，我们需要使用它创建一个项目：
- en: '[PRE35]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This command will allow you to choose different web frameworks. We are going
    to choose Express, as it is the one that we have already been using. The output
    of the preceding command is shown in the following screenshot:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将允许您选择不同的Web框架。我们将选择Express，因为这是我们已经在使用的框架。上述命令的输出如下截图所示：
- en: '![Documenting APIs with Swagger](img/B04889_06_16.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![使用Swagger记录API](img/B04889_06_16.jpg)'
- en: This screenshot is showing how to start a project with Swagger
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个截图显示了如何使用Swagger启动项目
- en: 'Now we can find a new folder, called `my-project`, that looks like the following
    image:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以找到一个名为`my-project`的新文件夹，看起来像以下图像：
- en: '![Documenting APIs with Swagger](img/B04889_06_17.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![使用Swagger记录API](img/B04889_06_17.jpg)'
- en: 'The structure is self-explanatory and it is the common layout of a Node.js
    application:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 结构是不言自明的，这是一个Node.js应用程序的常见布局：
- en: '`api`: Here, our API code will lay down'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`：这里是我们的API代码'
- en: '`config`: All the configuration sits in here'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：所有的配置都在这里'
- en: '`node_modules`: This is a folder with all the dependencies required to run
    our application'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules`：这是一个包含运行我们应用程序所需的所有依赖项的文件夹'
- en: '`test`: This is where Swagger has generated some dummy tests and where we could
    add our own tests'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：这是Swagger生成一些虚拟测试的地方，我们也可以添加自己的测试'
- en: 'Swagger comes with an impressive feature: an embedded editor that allows you
    to model the endpoints of your API. In order to run it, from within the generated
    folder, execute the following command:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger具有一个令人印象深刻的功能：一个嵌入式编辑器，允许您对API的端点进行建模。为了运行它，从生成的文件夹中执行以下命令：
- en: '[PRE36]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It will open Swagger Editor in the default browser, with a window similar to
    the following image:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在默认浏览器中打开Swagger编辑器，窗口类似于以下图像：
- en: '![Documenting APIs with Swagger](img/B04889_06_18.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![使用Swagger记录API](img/B04889_06_18.jpg)'
- en: Swagger makes use of **Yet Another Markup Language** (**YAML**). It is a language
    that is very similar to **JSON**, but with a different syntax.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger使用**另一种标记语言**（**YAML**）。这是一种与**JSON**非常相似但具有不同语法的语言。
- en: 'In this document, we can customize a number of things, such as paths (routes
    in our application). Let''s take a look at the path generated by Swagger:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文档中，我们可以自定义许多内容，比如路径（我们应用程序中的路由）。让我们看看Swagger生成的路径：
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The definition is self-documented. Basically, we will configure the parameters
    used by our endpoint, but in a declarative way. This endpoint is mapping the incoming
    actions into the `hello_world` controller, and specifically into the `hello` method,
    which is defined by the `id` operation. Let''s see what Swagger has generated
    for us in this controller:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 定义是自我记录的。基本上，我们将以声明方式配置我们的端点使用的参数。此端点将将传入的操作映射到“hello_world”控制器，具体到“hello”方法，该方法由“id”操作定义。让我们看看Swagger在这个控制器中为我们生成了什么：
- en: '[PRE38]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This code can be found in the `api/controllers` folder of the project. As you
    can see, it is a pretty standard Express controller packed as a module (well-cohesioned).
    The only strange line is the first one in the `hello` function, where we pick
    up the parameters from Swagger. We will come back to this later, once we run the
    project.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在项目的`api/controllers`文件夹中找到。正如您所看到的，它是一个作为模块打包的标准Express控制器（高内聚）。唯一奇怪的一行是`hello`函数中的第一行，我们从Swagger中提取参数。一旦我们运行项目，我们将回到这一点。
- en: 'The second part of the endpoint is the responses. As we can see, we are referencing
    two definitions: `HelloWorldResponse` for `http code 200` and `ErrorResponse`
    for the rest of the codes. These objects are defined in the following code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 端点的第二部分是响应。正如我们所看到的，我们引用了两个定义：`HelloWorldResponse`用于`http code 200`，`ErrorResponse`用于其他代码。这些对象在以下代码中定义：
- en: '[PRE39]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is something really interesting, although we are using a dynamic language,
    the contract is being defined by Swagger so that we have a language-agnostic definition
    that can be consumed by a number of different technologies, respecting the principle
    of technology heterogeneity that we were talking about earlier in [Chapter 1](ch01.html
    "Chapter 1. Microservices Architecture"), *Microservices Architecture*, and [Chapter
    2](ch02.html "Chapter 2. Microservices in Node.js – Seneca and PM2 Alternatives"),
    *Microservices in Node.js – Seneca and PM2 Alternatives*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常有趣的一点，尽管我们使用的是动态语言，但合同是由Swagger定义的，因此我们有一个与语言无关的定义，可以被许多不同的技术所消费，尊重我们在[第1章](ch01.html
    "第1章。微服务架构")和[第2章](ch02.html "第2章。Node.js中的微服务-Seneca和PM2替代方案")中谈到的技术异构性原则，*微服务架构*和*Node.js中的微服务-Seneca和PM2替代方案*。
- en: 'After explaining how the definition works, it is time to start the server:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释定义如何工作之后，现在是时候启动服务器了：
- en: '[PRE40]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This should produce an output that is very similar to the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生一个与以下代码非常相似的输出：
- en: '[PRE41]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, if we follow the instructions of the output and execute the curl command,
    we get the following output:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们按照输出的说明执行curl命令，我们将得到以下输出：
- en: '[PRE42]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Swagger is binding the `name` query parameter to the Swagger parameter specified
    in the YAML definition. This may sound bad, as we are coupling our software to
    Swagger, but it gives you an immense benefit: Swagger allows you to test the endpoint
    through the editor. Let''s see how it works.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger将`name`查询参数绑定到YAML定义中指定的Swagger参数。这可能听起来不好，因为我们将软件与Swagger耦合在一起，但它给你带来了巨大的好处：Swagger允许你通过编辑器测试端点。让我们看看它是如何工作的。
- en: 'On the right-hand side of the editor, you can see a button with the **Try this
    operation** label, as shown in the following screenshot:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器的右侧，你可以看到一个带有**尝试此操作**标签的按钮，如下截图所示：
- en: '![Documenting APIs with Swagger](img/B04889_06_19.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![使用Swagger记录API](img/B04889_06_19.jpg)'
- en: 'Once you click it, it will present you a form that allows you to test the endpoint,
    as shown in the following screenshot:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击它，它将呈现一个表单，允许你测试端点，如下截图所示：
- en: '![Documenting APIs with Swagger](img/B04889_06_20.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![使用Swagger记录API](img/B04889_06_20.jpg)'
- en: There is a warning message on this form about cross-origin requests. We don't
    need to worry about it when developing in our local machine; however, we could
    have problems when testing other hosts using the Swagger Editor.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单上有一个关于跨域请求的警告消息。在我们本地开发时，我们不需要担心它；然而，当使用Swagger Editor测试其他主机时，我们可能会遇到问题。
- en: Note
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information, visit the following URL:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网址：
- en: '[https://en.wikipedia.org/wiki/Cross-origin_resource_sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Cross-origin_resource_sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)'
- en: 'Enter a value for the **name** parameter, and after that, click on **Send Request**,
    as shown in the following image:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为**name**参数输入一个值，然后点击**发送请求**，如下图所示：
- en: '![Documenting APIs with Swagger](img/B04889_06_21.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![使用Swagger记录API](img/B04889_06_21.jpg)'
- en: This is a response example using Swagger Editor to test the endpoint
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Swagger Editor测试端点的响应示例
- en: Be aware that, for this test to work, our app server has to be up and running.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使此测试工作，我们的应用服务器必须处于运行状态。
- en: Generating a project from the Swagger definition
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Swagger定义生成项目
- en: 'Until now, we have been playing with Swagger and the generated project, but
    we are now going to generate the project from the `swagger.yaml` file. We will
    use the already generated project as a starting point, but we will add a new endpoint:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Swagger和生成的项目进行操作，但现在我们将从`swagger.yaml`文件中生成项目。我们将使用已生成的项目作为起点，但我们将添加一个新的端点：
- en: '[PRE43]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This endpoint might sound very familiar to you, as we unit tested it earlier
    in this chapter. As you probably know by now, the Swagger Editor is quite cool:
    it provides feedback as you type on, about what is going on in the YAML file,
    as well as saves the changes.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点可能对你来说非常熟悉，因为在本章的早些时候我们对其进行了单元测试。你现在可能已经知道，Swagger Editor非常酷：它会在你输入时提供关于YAML文件中正在进行的操作的反馈，同时保存更改。
- en: 'The next step is to download the Swagger code generator from [https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen).
    It is a Java project, so we are going to need the Java SDK and Maven to build
    it, as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从[https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen)下载Swagger代码生成器。这是一个Java项目，所以我们需要Java
    SDK和Maven来构建它，如下所示：
- en: '[PRE44]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Codegen is a tool that allow us to read the API definition from the Swagger
    YAML and build the basic structure for a project in a language of our choice,
    in this case, Node.js.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Codegen是一个工具，允许我们从Swagger YAML中读取API定义，并在我们选择的语言中构建项目的基本结构，本例中是Node.js。
- en: 'The preceding command in the root of the project should build all the submodules.
    Now, it is as easy as executing the following command in the root of the `swagger-codegen`
    folder:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录中执行上述命令应该构建所有子模块。现在，只需在`swagger-codegen`文件夹的根目录中执行以下命令即可：
- en: '[PRE45]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The Swagger code generator supports a number of languages. Here, the trick is
    that when using it for microservices, we can define the interface and then use
    the most appropriate technology to build our service.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger代码生成器支持多种语言。在这里，关键是当用于微服务时，我们可以定义接口，然后使用最合适的技术来构建我们的服务。
- en: If you go to the `my-project` folder, you should find the full structure of
    the project in there, ready to start coding.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入`my-project`文件夹，你应该会在那里找到项目的完整结构，准备开始编码。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to test and document microservices. It is usually
    the forgotten activity in software development, due to the pressures to deliver
    new functionalities, but in my opinion, it is a risky decision. We have to find
    the balance between too much and very little testing. In general, we will always
    try to find the right proportion for unit, integration and end-to-end tests.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何测试和记录微服务。这通常是软件开发中被遗忘的活动，因为要交付新功能的压力，但在我看来，这是一个冒险的决定。我们必须在单元测试、集成测试和端到端测试之间找到平衡。总的来说，我们将始终努力找到适当的比例。
- en: You also learned about manual testing and the tools to efficiently test our
    software manually (there is always a component of manual testing).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解了手动测试以及有效测试我们的软件的工具（手动测试总是有一部分组成）。
- en: Another interesting point is the documentation and API management. In this case,
    we got to know Swagger, which is probably the most popular API manager that led
    to the creation of the Open API standard.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的点是文档和API管理。在这种情况下，我们了解了Swagger，这可能是最流行的API管理器，导致了Open API标准的创建。
- en: If you want to go deeper in to the API world (there is a lot to learn in order
    to build a practical and efficient API), you should probably browse [http://apigee.com](http://apigee.com).
    Apigee are a company expert on building APIs and providing tools for developers
    and enterprises that could help you to build a better API.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更深入地了解API世界（构建实用和高效的API需要学习的东西很多），你可能应该浏览[http://apigee.com](http://apigee.com)。Apigee是一家专门构建API并为开发人员和企业提供工具的公司，可以帮助你构建更好的API。
