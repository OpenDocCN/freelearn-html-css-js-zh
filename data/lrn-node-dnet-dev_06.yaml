- en: Chapter 6. Testing Node.js Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。测试 Node.js 应用程序
- en: So far, we have only been testing our code by exercising it manually. This isn't
    a very sustainable approach as our application becomes larger. Ideally, we should
    regularly exercise all the functionality of our application to check for regressions.
    This would quickly become prohibitively time-consuming if we continued to use
    only manual testing. It is much more effective to maintain a suite of automated
    tests. These also bring many other benefits, for example, acting as documentation
    of our code for other developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是通过手动执行来测试我们的代码。随着应用程序的增大，这不是一个可持续的方法。理想情况下，我们应该定期测试我们应用程序的所有功能以检查回归。如果我们继续仅使用手动测试，这将迅速变得耗时且难以承受。维护一系列自动化测试要有效得多。这些测试还带来了许多其他好处，例如，作为我们代码的其他开发者的文档。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing automated unit tests for our application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序编写自动单元测试
- en: Introducing new libraries to help us write more descriptive tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍新的库来帮助我们编写更详细的测试
- en: Seeing how to create and use test doubles in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在 JavaScript 中创建和使用测试替身
- en: Exercising our application's web interface using HTTP client tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 客户端测试来锻炼我们的应用程序的 Web 界面
- en: Adding full-stack integration tests using browser automation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器自动化添加全栈集成测试
- en: Establishing a structure for writing further tests as we expand our codebase
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在扩展我们的代码库时，为编写进一步的测试建立结构
- en: Writing a simple test in Node.js
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Node.js 中编写一个简单的测试
- en: 'Node.js comes with a built-in module called `assert` that can be used for testing.
    We can use it to write a simple test for the games service that we wrote in [Chapter
    5](part0030.xhtml#aid-SJGS1 "Chapter 5. Creating Dynamic Websites") *, Building
    Dynamic Websites*. We add the following code under `gameServiceTest.js`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 内置了一个名为 `assert` 的模块，可用于测试。我们可以使用它为我们在 [第 5 章](part0030.xhtml#aid-SJGS1
    "第 5 章。构建动态网站") 中编写的游戏服务编写一个简单的测试，即 *Building Dynamic Websites*。我们在 `gameServiceTest.js`
    下添加以下代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the `assert.equal` function takes the actual value as the first argument
    and the expected value as the second argument. This is the opposite way around
    to JUnit's built-in `Assert.Equals`, and the classic-style `Assert.AreEqual` in
    NUnit. It's important to get these parameters the right way around so that they
    appear correctly in error messages when an assertion fails.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`assert.equal` 函数将实际值作为第一个参数，将预期值作为第二个参数。这与 JUnit 的内置 `Assert.Equals` 和 NUnit
    的经典样式 `Assert.AreEqual` 方向相反。正确地处理这些参数很重要，这样当断言失败时，它们会在错误消息中正确显示。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Given, When, Then**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Given, When, Then**'
- en: The *Given*, *When*, and *Then* comments in the preceding test are not specific
    to JavaScript or any of the test frameworks we'll be using, but are generally
    a good tool for structuring tests to keep them focused and readable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中的 *Given*、*When* 和 *Then* 注释并不特定于 JavaScript 或我们将要使用的任何测试框架，但它们通常是一个很好的工具，用于构建测试以保持其专注和可读性。
- en: 'We can now verify our code using the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令验证我们的代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An exit code of `0` indicates that our test completed successfully without any
    errors. Although we haven't been following test-driven development (writing a
    failing test first before adding any new code), it's still important to see each
    test fail to confirm that it's testing something. Try altering the `availableTo`
    function in `services/games.js` to return an empty array, and run the test again.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 退出代码为 `0` 表示我们的测试成功完成，没有任何错误。尽管我们还没有遵循测试驱动开发（先编写一个失败的测试，然后再添加任何新代码），但仍然很重要，要看到每个测试失败以确认它在测试某些内容。尝试修改
    `services/games.js` 中的 `availableTo` 函数以返回一个空数组，然后再次运行测试。
- en: Not only do we now get a non-zero exit code, but we also get an error containing
    our assertion failure. Our test output still isn't particular compelling, though.
    Also, the lack of structure in our test script will make it harder to navigate
    as we add more tests. We can address both of these issues by making use of one
    of the testing libraries available for JavaScript.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅我们现在得到了一个非零的退出代码，我们还得到了一个包含我们的断言失败错误的消息。尽管如此，我们的测试输出仍然并不特别吸引人。此外，我们测试脚本中的结构缺失将使得随着测试的增加而难以导航。我们可以通过使用
    JavaScript 可用的测试库之一来解决这两个问题。
- en: Structuring the codebase for tests
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试构建代码库的结构
- en: As we write more tests for our application, we'll benefit from having more structure
    to our tests. It's common to have at least one test file per production module.
    It will also be useful to have a way of running all of our tests and seeing the
    overall result.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们为应用程序编写更多的测试，我们将从测试的结构化中受益。通常，每个生产模块至少有一个测试文件。同时运行所有测试并查看整体结果也将很有用。
- en: We're going to start adding tests under a `test` directory. From this point
    on in the book, we're also going to keep all of our application code under a `src`
    directory. This will make it easier to navigate our codebase and to keep production
    and test code separate.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始在 `test` 目录下添加测试。从本书的这一部分开始，我们也将把所有应用程序代码放在一个 `src` 目录下。这将使导航我们的代码库和保持生产代码与测试代码分离变得更加容易。
- en: 'If you''re following along with the book at this point, you should move `app.js`
    and all the folders (apart from the `bin` folder) under a new `src` directory,
    and update the startup script as follows in `bin/www`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这一部分跟随本书，你应该将 `app.js` 和所有文件夹（除了 `bin` 文件夹）移动到一个新的 `src` 目录下，并在 `bin/www`
    中更新启动脚本如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Writing BDD-style tests with Mocha
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mocha 编写 BDD 风格的测试
- en: From C# or Java, you may be most familiar with the xUnit-style of tests used
    by NUnit, JUnit, and so on. This style structures tests into classes, and turns
    method names into test names. This can be a bit restrictive, and isn't common
    in JavaScript testing. JavaScript test frameworks make use of the less structured,
    and more dynamic, nature of the language to allow more flexibility.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 或 Java，你可能最熟悉 NUnit、JUnit 等使用的 xUnit 风格的测试。这种风格将测试结构化为类，并将方法名称转换为测试名称。这可能有点限制性，在
    JavaScript 测试中并不常见。JavaScript 测试框架利用语言更不结构化和更动态的特性，以提供更大的灵活性。
- en: There are several different styles for writing tests in JavaScript. The most
    common is the so-called **behavior-driven development** (**BDD**) style in which
    we describe the behavior of our application in plain English. This is the default
    style of the most popular JavaScript testing frameworks. It is also common in
    frameworks for other programming platforms, most notably RSpec for Ruby.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中编写测试有几种不同的风格。最常见的是所谓的**行为驱动开发**（**BDD**）风格，其中我们用普通的英语描述我们应用程序的行为。这是最受欢迎的
    JavaScript 测试框架的默认风格。在其他编程平台的框架中也很常见，尤其是 Ruby 的 RSpec。
- en: 'We''ll be using a popular test framework named Mocha. Let''s first add this
    to our application:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个流行的测试框架，名为 Mocha。首先，让我们将其添加到我们的应用程序中：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that `--save-dev` adds Mocha to our `package.json` file as a **development
    dependency**. This indicates that it''s not needed in our production code, and
    `npm` doesn''t need to install it in production environments. We''ll also update
    this file to let `npm` run our tests using Mocha, by adding a test script as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`--save-dev` 将 Mocha 添加到我们的 `package.json` 文件中作为**开发依赖项**。这表示它不需要在我们的生产代码中，并且
    `npm` 不需要在生产环境中安装它。我们还将更新此文件，让 `npm` 使用 Mocha 运行我们的测试，如下添加测试脚本：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This tells `npm` to execute scripts under the `/test/` directory as tests using
    Mocha when we run `npm test` from the command line.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 `npm` 当我们从命令行运行 `npm test` 时，使用 Mocha 执行 `/test/` 目录下的脚本作为测试。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Mocha and Jasmine**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mocha 和 Jasmine**'
- en: There are a large number of different testing frameworks available for JavaScript.
    The most well-established are Jasmine and Mocha. They have comparable features
    and both support the same syntax for writing tests. They are both well-documented,
    and switching between the two is easy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于 JavaScript 的测试框架有很多。最著名的是 Jasmine 和 Mocha。它们具有相似的功能，并且都支持相同的测试编写语法。它们都有很好的文档，两者之间的切换也很容易。
- en: Jasmine was originally aimed more at testing client-side JavaScript in the browser.
    Mocha was originally more focused on testing server-side Node.js code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 最初旨在测试浏览器中的客户端 JavaScript。Mocha 最初更多地关注测试服务器端 Node.js 代码。
- en: Nowadays, both frameworks are well-suited for either environment. Jasmine also
    has more *batteries included*, which can make it quicker to get started with.
    Mocha delegates more features to other libraries, giving the user more choice
    about how they prefer to write tests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这两个框架都适合任何环境。Jasmine 还包含更多的“电池”，这可以使开始使用它更快。Mocha 将更多功能委托给其他库，使用户能够有更多选择，关于他们更喜欢如何编写测试。
- en: 'Now we just need to add some tests! Mocha provides global functions named `describe`
    and `it` for structuring our tests. These functions each take two arguments: a
    string describing the behavior of our application and a callback defining the
    tests for that behavior. The following code snippet shows our previous test rewritten
    using Mocha. We add the following code under `test/services/games.js`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要添加一些测试！Mocha提供了名为`describe`和`it`的全局函数来结构化我们的测试。这些函数各自接受两个参数：一个描述我们应用程序行为的字符串和一个定义该行为的回调函数。以下代码片段展示了使用Mocha重写的我们之前的测试。我们在`test/services/games.js`下添加以下代码：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now try running the previous test using `npm test`. You should see output like
    the following (the exact appearance will depend on what console you are using):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用`npm test`运行之前的测试。你应该会看到如下输出（确切的外观取决于你使用的控制台）：
- en: '![Writing BDD-style tests with Mocha](img/image00217.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![使用Mocha编写BDD风格的测试](img/image00217.jpeg)'
- en: 'Note how we get a much more descriptive output of our tests. Also note the
    use of nested describe callbacks in our test to build up a description of our
    application. The benefit of this becomes clearer as we add more tests. Try adding
    the following test after the first test:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何得到一个更详细的测试输出。同时注意我们在测试中使用嵌套的describe回调来构建应用程序的描述。随着我们添加更多的测试，这个优势变得更加明显。尝试在第一个测试之后添加以下测试：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the tests again using `npm test`. This time, we get a test failure from
    Mocha:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`npm test`运行测试。这次，我们从Mocha那里得到了一个测试失败：
- en: '![Writing BDD-style tests with Mocha](img/image00218.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![使用Mocha编写BDD风格的测试](img/image00218.jpeg)'
- en: Resetting state between tests
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试之间的状态重置
- en: Our second test fails because it retrieves two games from the service. But this
    is not because our production code is failing to filter games correctly. In fact,
    there are two games created by the first user. One of these has been carried over
    from the previous test.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个测试失败了，因为它从服务中检索了两个游戏。但这并不是因为我们的生产代码未能正确过滤游戏。实际上，有两个是由第一个用户创建的游戏。其中一个在之前的测试中被保留了下来。
- en: 'It''s important for tests to be independent and isolated from each other. To
    this end, we need to clean up any state between tests. In this case, we want to
    delete all the games we created. The games service doesn''t give us a method for
    clearing all games. We can only remove individual games after retrieving them.
    There are a few options available to us here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试来说，它们之间独立且相互隔离是很重要的。为此，我们需要在测试之间清理任何状态。在这种情况下，我们想要删除我们创建的所有游戏。游戏服务没有提供清除所有游戏的方法。我们只能在检索到它们之后逐个删除游戏。这里有几个可供我们选择的方法：
- en: We could keep track of all the games we create during each test and delete them
    all at the end. This might seem the most obvious solution, but it's a bit fragile.
    It would be easy to miss a single game that might cause confusing test failures
    later.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在每个测试期间跟踪我们创建的所有游戏，并在结束时删除它们。这似乎是最明显的解决方案，但它有点脆弱。可能会错过一个游戏，这可能导致后续的测试失败变得令人困惑。
- en: We could rewrite the games service module to export a function for creating
    a new service, and instantiate a new service for each test. In general, it's a
    good idea to try and isolate tests by creating fresh objects under each test.
    However, this is only useful if the object doesn't store any external state. We
    may well want to change the implementation of the games service later, to store
    data externally in a persistent datastore.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将游戏服务模块重写为导出一个创建新服务函数，并为每个测试实例化一个新的服务。一般来说，尝试在每个测试下创建新的对象以隔离测试是一个好主意。然而，这只有在对象不存储任何外部状态时才有用。我们可能会在以后更改游戏服务的实现，以便将数据存储在外部持久数据存储中。
- en: We could add a clear method to the games service to wipe out all its data. It's
    not wrong to create methods like this for the purposes of supporting tests. However,
    it's preferable to interact with the application via its existing API if possible.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在游戏服务中添加一个清除方法来清除所有数据。为了支持测试而创建这样的方法并没有错。然而，如果可能的话，最好通过应用程序现有的API与之交互。
- en: 'The games service does offer a way of retrieving all current games. We just
    need to pass in a user ID that doesn''t match the setter of any game. We can then
    go through and delete all games. We want to do this before every test, which we
    can do using Mocha''s `beforeEach` hook:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏服务确实提供了一种检索所有当前游戏的方法。我们只需要传入一个与任何游戏设置者不匹配的用户ID。然后我们可以遍历并删除所有游戏。我们希望在每次测试之前做这件事，可以使用Mocha的`beforeEach`钩子：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we re-run our tests, they now both pass correctly. There is also an `afterEach`
    hook in Mocha, which we could have used instead. This would have worked, but it's
    safer for tests to defend themselves by cleaning up first, rather than relying
    on other tests to clean up after themselves.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行我们的测试，它们现在都正确通过。Mocha还有一个`afterEach`钩子，我们可以用它来代替。这会起作用，但测试通过先清理来保护自己比依赖其他测试来清理自己更安全。
- en: Using Chai for assertions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Chai进行断言
- en: Another way to make our tests more descriptive is how we write our assertions.
    Although the built-in Node.js assert module has been useful so far, it is a bit
    limited. It only contains a small number of simple methods for basic assertions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的测试更具描述性的另一种方法是编写我们的断言。尽管内置的Node.js断言模块到目前为止很有用，但它有点有限。它只包含少量简单方法来进行基本断言。
- en: You may have experience of Fluent Assertions or NUnit's Constraint model in
    .NET, or AssertJ in Java. Compared to these, the Node.js assert module might seem
    quite primitive.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对Fluent Assertions或.NET的NUnit约束模型，或者Java的AssertJ有所了解。与这些相比，Node.js断言模块可能看起来相当原始。
- en: There are several assertion frameworks available for JavaScript. We'll be using
    Chai ([http://chaijs.com](http://chaijs.com)), which supports three different
    styles for writing assertions. The `assert` style follows the traditional xUnit
    assertions, as in JUnit, or the classic model of NUnit. The `should` and `expect`
    styles provide a natural language interface for building more descriptive assertions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个断言框架可用于JavaScript。我们将使用Chai ([http://chaijs.com](http://chaijs.com))，它支持编写断言的三个不同风格。`assert`风格遵循传统的xUnit断言，如JUnit或NUnit的经典模型。`should`和`expect`风格提供了自然语言界面来构建更具描述性的断言。
- en: Any of these styles is a perfectly valid choice for writing test assertions.
    The important thing is to pick a style for your codebase and use it consistently.
    We will be using Chai's `expect` syntax throughout this book. This is one of the
    more common styles in JavaScript testing. The Jasmine test framework has built-in
    assertions that follow a similar style.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任何风格都是编写测试断言的有效选择。重要的是为你的代码库选择一种风格并始终如一地使用它。我们将在这本书中使用Chai的`expect`语法。这是JavaScript测试中更常见的风格之一。Jasmine测试框架内置了遵循类似风格的断言。
- en: 'Let''s first install Chai by running the following on the command line:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过在命令行运行以下命令来安装Chai：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then update our tests to use it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新我们的测试以使用它：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The change isn't particularly dramatic at this point as we're only making simple
    assertions. But the natural language interface will allow us to specify more detailed
    assertions in a descriptive way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前只进行简单的断言，所以这个变化并不特别引人注目。但自然语言界面将允许我们以描述性的方式指定更详细的断言。
- en: Creating test doubles
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建测试替身
- en: 'There are more tests we could write for the games service, but let''s look
    at a different module for now. How would we go about testing our `users` middleware?
    The following code is from `middleware/users.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为游戏服务编写更多的测试，但现在让我们看看不同的模块。我们如何测试我们的`users`中间件呢？以下代码来自`middleware/users.js`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to test this class, we will need to pass in arguments for the `req`,
    `res`, and `next` parameters with which our code interacts. We don''t have a real
    request, response, or middleware pipeline available, so we need to create some
    stand-in values instead. Stand-in values such as this are generally called **test
    doubles**. Our code reads an attribute from the request and calls the cookie method
    on the response. We can create test doubles for these as follows, in a new test
    script under `test/middleware/users.js`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个类，我们需要为与我们的代码交互的`req`、`res`和`next`参数传递参数。我们没有真实的请求、响应或中间件管道可用，因此我们需要创建一些替代值。这样的替代值通常被称为**测试替身**。我们的代码从请求中读取一个属性，并在响应上调用cookie方法。我们可以在`test/middleware/users.js`下的新测试脚本中创建这些测试替身，如下所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we simply create a plain JavaScript object to represent the request. This
    allows us to verify that the production code reads from, and writes to, the request
    properties correctly. We just pass in the minimum possible input for the response
    object and the `next` function to allow the code to execute. This is very easy
    to do in JavaScript, partly because it is not statically typed. Creating test
    doubles like this in C# or Java can be a lot more work as the compiler will insist
    on the test doubles matching the corresponding parameter types.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仅仅创建一个普通的 JavaScript 对象来表示请求。这允许我们验证生产代码是否正确地从请求属性中读取和写入。我们只传递响应对象的最小可能输入和
    `next` 函数，以允许代码执行。这在 JavaScript 中非常容易做到，部分原因是因为它不是静态类型。在 C# 或 Java 中创建这样的测试替身可能会更加费力，因为编译器会坚持测试替身与相应的参数类型匹配。
- en: 'We also need to test that our middleware calls the next middleware in the chain,
    as this is important behavior. This is slightly more complex than just creating
    an object with simple properties. We can still create a suitable test double by
    defining a new function that records when it is called (this kind of test double
    is called a **spy**):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要测试我们的中间件是否调用了链中的下一个中间件，因为这是一个重要的行为。这比仅仅创建一个具有简单属性的对象要复杂一些。我们仍然可以通过定义一个新的函数来创建一个合适的测试替身，该函数记录何时被调用（这种类型的测试替身被称为
    **间谍**）：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This works perfectly well, but will become more cumbersome if we want to test
    more complex calls, for example, if we want to check for multiple calls or make
    further assertions about the arguments passed in. We can simplify this by making
    use of a framework to create test doubles for us.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得非常好，但如果我们要测试更复杂的调用，例如，如果我们想检查多个调用或对传入的参数进行进一步的断言，将会变得比较繁琐。我们可以通过使用一个框架来为我们创建测试替身来简化这个过程。
- en: Creating test doubles using Sinon.JS
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Sinon.JS 创建测试替身
- en: 'Sinon.JS is a framework for creating all kinds of test doubles. Let''s first
    install it into our application by running the following on the command line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 是一个用于创建各种测试替身的框架。让我们首先通过在命令行运行以下命令将其安装到我们的应用程序中：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s simplify our previous test and write a more complex test using test
    doubles created by Sinon.JS:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简化之前的测试，并使用 Sinon.JS 创建的测试替身编写一个更复杂的测试：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Sinon.JS spies keep track of the details of all calls made to them and provide
    a convenient API for checking these. This allows us to keep our test code simple
    and readable. There are many more properties than just the `called` and `calledWith`
    user here. Take a look at the Sinon.JS documentation at [http://sinonjs.org/docs/#spies-api](http://sinonjs.org/docs/#spies-api)
    to see some of the other ways we can verify the calls made against a spy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 间谍会跟踪所有对其发出的调用的详细信息，并提供一个方便的 API 来检查这些信息。这使得我们能够保持测试代码简单易读。除了 `called`
    和 `calledWith` 用户属性之外，还有许多其他属性。请查看 Sinon.JS 文档 [http://sinonjs.org/docs/#spies-api](http://sinonjs.org/docs/#spies-api)，以了解我们可以验证间谍所发出的调用的其他方式。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Spies, stubs, and mocks**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**间谍、存根和模拟**'
- en: If you read more of the Sinon.JS documentation, you'll see that it's very explicit
    about the difference between spies, stubs, and mocks. This is in contrast to most
    popular test double frameworks in Java and .NET, which tend to call all test doubles
    by the same name (typically mock or fake). In reality though, most instances of
    test doubles typically only act as a spy (used for verifying side-effects) or
    a stub (used for providing data, or throwing exceptions to test error-handling).
    A true mock verifies a specific sequence of calls and returns specific data to
    the code under test. Although some of the early mocking frameworks in Java and
    .NET only supported this type of test double (now sometimes called a *strict mock*),
    it isn't common practice anymore. This is because it quite tightly couples test
    and production code and makes refactoring more difficult. It's especially rare
    to have more than one mock (as opposed to just a stub or spy) in a single test.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读更多 Sinon.JS 的文档，你会看到它非常明确地说明了间谍、存根和模拟之间的区别。这与 Java 和 .NET 中大多数流行的测试替身框架形成对比，这些框架倾向于用相同的名称（通常是模拟或伪造）来调用所有的测试替身。然而，在现实中，大多数测试替身实例通常只充当间谍（用于验证副作用）或存根（用于提供数据或抛出异常以测试错误处理）。真正的模拟会验证特定的调用序列，并返回特定的数据给被测试的代码。尽管
    Java 和 .NET 中的一些早期模拟框架只支持这种类型的测试替身（现在有时称为 *严格模拟*），但这不再是常见的做法。这是因为它非常紧密地将测试和生产代码耦合在一起，使得重构变得更加困难。在一个单独的测试中，拥有多个模拟（而不是仅仅一个存根或间谍）的情况尤其罕见。
- en: Testing an Express application
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Express 应用程序
- en: While using Sinon.JS makes our tests neater, they still depend on the details
    of the Express middleware API and how we're using it. This might be appropriate
    for our middleware module as we want to ensure that it fulfills a particular contract
    (especially calling `next` and setting `request.user`). For most middleware, though,
    especially our routes, this approach would couple our tests too closely to our
    implementation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用Sinon.JS可以使我们的测试更整洁，但它们仍然依赖于Express中间件API的细节以及我们如何使用它。这可能适合我们的中间件模块，因为我们想确保它满足特定的契约（特别是调用`next`和设置`request.user`）。但对于大多数中间件来说，尤其是我们的路由，这种方法可能会使我们的测试过于紧密地耦合到我们的实现。
- en: It would be better to test the actual behavior of each route by making HTTP
    requests to it and examining the responses, rather than checking for specific
    low-level interactions with the request and response objects. This gives us more
    flexibility to change our implementation and refactor our code, without needing
    to change the tests. Thus, our tests can support this process (by catching regressions)
    rather than hindering it (by having to be updated to match our implementation).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向它发送HTTP请求并检查响应来测试每个路由的实际行为，而不是检查与请求和响应对象的特定低级交互，会更好。这使我们能够更灵活地更改我们的实现和重构我们的代码，而无需更改测试。因此，我们的测试可以支持这个过程（通过捕获回归），而不是阻碍它（需要更新以匹配我们的实现）。
- en: On other platforms, testing a whole application can be quite a heavyweight process.
    It is possible to start up a server in process, for example, using Jetty in Java
    or Katana in .NET. Newer application frameworks, such as Spring Boot or NancyFx,
    also make this process easier. These are still likely to be relatively slow and
    resource-intensive tests, though.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他平台上，测试整个应用程序可能是一个相当重量级的流程。例如，在Java中使用Jetty或在.NET中使用Katana，可以在进程中启动服务器。较新的应用程序框架，如Spring
    Boot或NancyFx，也使这个过程更容易。尽管如此，这些测试仍然可能是相对缓慢和资源密集型的。
- en: 'In Node.js, starting up an application server is easy and very lightweight.
    We just use the same `http.createServer` call as we''ve seen before, and pass
    it an application. To test our route in isolation, we''ll bootstrap a new application
    containing just this route. Let''s see how we can use this to test the delete
    endpoint of our games route. We add the following code under `test/routes/games.js`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，启动应用程序服务器既简单又轻量级。我们只是使用之前看到的相同的`http.createServer`调用，并传递一个应用程序。为了单独测试我们的路由，我们将启动一个新的应用程序，其中只包含这个路由。让我们看看我们如何使用它来测试游戏路由的删除端点。我们在`test/routes/games.js`下添加以下代码：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This might seem like quite a lot of code, but remember that we're firing up
    an entire application here. Also, most of this code will be reused for multiple
    tests. Let's work through what it does.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是相当多的代码，但请记住，我们在这里启动的是一个完整的应用程序。此外，大部分的代码将会在多个测试中重复使用。让我们看看它具体做了什么。
- en: The `before` callback creates our server, just as we saw in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Getting Started with Node.js") *, Getting Started with Node.js*, listening
    on a special port for use by our tests. It also sets up some stub middleware to
    simulate a current user on the request. The `afterEach` callback clears up any
    created games (as we saw before in the test of the games service). Note that since
    we're running in the same process, we can trivially interact with the same data
    layer that our application is using. Finally, the `after` function asks the server
    to stop listening for connections.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`before`回调创建我们的服务器，正如我们在[第2章](part0018.xhtml#aid-H5A41 "第2章。Node.js入门") *“Node.js入门”*中看到的，监听一个特殊端口供我们的测试使用。它还设置了一些存根中间件来模拟请求中的当前用户。`afterEach`回调清除创建的任何游戏（正如我们在游戏服务测试中之前看到的）。请注意，由于我们运行在同一个进程中，我们可以轻易地与我们的应用程序使用的相同数据层进行交互。最后，`after`函数请求服务器停止监听连接。'
- en: 'The test itself is very simple: we just create a game set by the current user
    (as in our service tests before) and then issue a request to delete it. This makes
    use of our own `makeRequest` function, which simply calls through to Node''s `http.request`.
    We can then inspect the response object to check for the appropriate status code,
    and check the service for the desired effect.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本身非常简单：我们只是创建一个当前用户（如我们之前的服务测试中所述）的游戏设置，然后发出一个删除它的请求。这使用了我们自己的`makeRequest`函数，该函数简单地调用Node的`http.request`。然后我们可以检查响应对象以查找适当的状态码，并检查服务以查看期望的效果。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Writing asynchronous tests in Mocha**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Mocha中编写异步测试**'
- en: 'Notice that our test and all of the callbacks to Mocha''s hook functions discussed
    above (except for afterEach) take a `done` parameter. This is because all of these
    tests perform some asynchronous work. Mocha makes it very easy to write asynchronous
    tests or hooks: you just make your callback function take a single parameter (called
    `done` by convention), and call it when processing is complete. If it''s not called
    within a timeout (which defaults to 2 seconds but can be changed), then Mocha
    fails the test.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的测试以及上面讨论的所有对 Mocha 的钩子函数的回调（除了 afterEach）都接受一个 `done` 参数。这是因为所有这些测试都执行了一些异步操作。Mocha
    使得编写异步测试或钩子变得非常简单：你只需让你的回调函数接受一个参数（按照惯例称为 `done`），并在处理完成后调用它。如果在超时时间内（默认为 2 秒，但可以更改）没有调用，那么
    Mocha 会判定测试失败。
- en: 'Let''s run our tests again using the `npm test` command. Notice that all of
    the tests still finish very quickly (tens of milliseconds on my machine), even
    though we''re starting up our whole server-side application. You may also notice
    the output is a bit messy due to log output from the server. We can easily suppress
    this by updating app.js as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用 `npm test` 命令运行我们的测试。注意，尽管我们正在启动整个服务器端应用程序，但所有测试仍然完成得非常快（在我的机器上为数十毫秒）。你可能还会注意到输出有些混乱，这是由于服务器日志输出造成的。我们可以通过以下方式轻松地抑制这种输出：更新
    app.js 如下：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `''env''` property of an Express application comes from the `NODE_ENV`
    environment variable (or defaults to development if this is not present). This
    is useful for differentiating between production and development environments.
    Since it defaults to `development`, we also need to set it to something else in
    order to suppress this logging in our tests. We can do this by updating our test
    script in `package.json` as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Express 应用程序的 `'env'` 属性来自 `NODE_ENV` 环境变量（如果不存在，则默认为开发环境）。这对于区分生产环境和开发环境非常有用。由于它默认为
    `development`，因此我们还需要将其设置为其他值，以便在我们的测试中抑制此日志记录。我们可以通过以下方式更新我们的测试脚本 `package.json`：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Simplifying tests using SuperAgent
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SuperAgent 简化测试
- en: While our tests are fast, and setting up the server is quite straightforward,
    we do have quite a lot of code for making requests to the server and handling
    responses. This would become more complex if we needed to make a wider variety
    of requests, or were interested in more than just the response status code or
    headers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的测试速度快，设置服务器也很直接，但我们确实有很多用于向服务器发送请求和处理响应的代码。如果我们需要制作更多种类的请求，或者对响应状态码或头信息以外的内容感兴趣，这将会变得更加复杂。
- en: We can simplify our tests by using a library that provides a simpler API for
    communicating with the server. SuperAgent ([https://visionmedia.github.io/superagent/](https://visionmedia.github.io/superagent/))
    is a JavaScript library that provides a fluent, readable syntax for making HTTP
    requests. This can be used for Ajax requests in the browser, or for requests in
    a Node.js application as we're doing here.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用提供更简单服务器通信 API 的库来简化我们的测试。SuperAgent ([https://visionmedia.github.io/superagent/](https://visionmedia.github.io/superagent/))
    是一个 JavaScript 库，它提供了一种流畅、易读的语法来制作 HTTP 请求。这可以用于浏览器中的 Ajax 请求，或者像我们在这里所做的那样在 Node.js
    应用程序中进行请求。
- en: We'll make use of SuperAgent through a lightweight wrapper called SuperTest
    ([https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest)),
    which makes testing Node.js-based HTTP applications even more convenient.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 SuperTest 的轻量级包装器通过 SuperAgent 来利用它，这使得测试基于 Node.js 的 HTTP 应用程序变得更加方便。
- en: 'First, we add SuperTest into our application using `npm`, by running the following
    on the command line:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `npm` 将 SuperTest 添加到我们的应用程序中，通过在命令行运行以下命令：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can rewrite our tests as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的测试重写如下：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: SuperTest and SuperAgent take care of starting up the server for our application,
    and provide a much simpler API for making requests. Note the use of a request
    **agent**, which represents a single browser session.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SuperTest 和 SuperAgent 负责启动我们的应用程序服务器，并提供一个更简单的 API 来制作请求。注意使用了一个请求 **代理**，它代表一个单独的浏览器会话。
- en: SuperAgent provides a number of functions (`get`, `post`, `delete`, and so on)
    for making HTTP requests. These can be chained with calls to the `expect` function
    (not to be confused with Chai's `expect`) to verify properties of the response,
    such as the status code. We can also pass in a callback to make specific checks
    about the response, or verify side-effects (as we do in the previous example).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SuperAgent 提供了多个函数（`get`、`post`、`delete` 等）用于发起 HTTP 请求。这些可以通过对 `expect` 函数的调用进行链式调用（不要与
    Chai 的 `expect` 混淆）来验证响应的属性，例如状态码。我们还可以传递一个回调来对响应进行特定检查，或验证副作用（就像我们在前面的例子中所做的那样）。
- en: Note that it is important to always call the `end` function to make sure any
    expectation errors are thrown and fail the test. We can pass Mocha's `done` callback
    to end the test when the request is completed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，始终调用 `end` 函数以确保抛出任何期望错误并使测试失败是很重要的。当请求完成时，我们可以传递 Mocha 的 `done` 回调来结束测试。
- en: 'Now that we''ve simplified our test code, we can easily add more tests for
    our routes. For example, let''s add some tests to cover the negative cases of
    our delete endpoint:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简化了测试代码，我们可以轻松地为我们的路由添加更多测试。例如，让我们添加一些测试来覆盖删除端点的负面情况：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Full-stack testing with PhantomJS
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PhantomJS 进行全栈测试
- en: We have now written unit tests for logic at the core of our application and
    integration tests for our server-side routes. We don't yet have any automated
    tests that cover our views and client-side scripts as our manual testing throughout
    the previous chapters did.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为应用程序核心的逻辑编写了单元测试，并为服务器端路由编写了集成测试。我们还没有任何自动化测试覆盖我们的视图和客户端脚本，正如我们在前几章中的手动测试所做的那样。
- en: We can write unit tests for client-side scripts using Mocha. However, all of
    our current client-side scripts interact with the server, so aren't good candidates
    for unit testing. Our manual tests are really full-stack tests of our whole application,
    including the interaction between the server and the client.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Mocha 为客户端脚本编写单元测试。然而，我们当前的所有客户端脚本都与服务器交互，因此不是单元测试的理想候选者。我们的手动测试实际上是整个应用程序的全栈测试，包括服务器和客户端之间的交互。
- en: In order to achieve this in an automated test, we will need to use some form
    of browser automation. **PhantomJS** is a headless browser with a JavaScript API
    that allows us to automate it directly. We can write a simple test for our game
    page using this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在自动化测试中实现这一点，我们需要使用某种形式的浏览器自动化。**PhantomJS** 是一个具有 JavaScript API 的无头浏览器，它允许我们直接自动化它。我们可以使用这个
    API 为我们的游戏页面编写一个简单的测试。
- en: 'First, we''ll install PhantomJS within our project by running the following
    on the command line:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在命令行中运行以下命令，在我们的项目中安装 PhantomJS：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PhantomJS is not a Node.js module. It is a standalone, headless web browser.
    The npm module is just a convenient way of installing it and making it a dependency
    of the project. PhantomJS cannot be invoked from Node.js, except to execute it
    as a separate child process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS 不是一个 Node.js 模块。它是一个独立的、无头浏览器。npm 模块只是安装它的方便方式，并使其成为项目的依赖项。PhantomJS
    不能从 Node.js 中调用，除非作为单独的子进程执行。
- en: 'Now we can implement a test as follows, under `integration-test/game.js`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `integration-test/game.js` 下实现以下测试：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Make sure the application is running (using `npm start`), then execute the
    test by running the following on the command line:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 确保应用程序正在运行（使用 `npm start`），然后在命令行中运行以下命令来执行测试：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's take a look through the code to understand how it works. Note that we're
    running in the browser environment here rather than Node.js, so fall back to the
    ECMAScript 5 syntax (for example, `var` instead of `let`, and no arrow functions).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下代码，了解它是如何工作的。注意，我们在这里是在浏览器环境中运行，而不是 Node.js，因此回退到 ECMAScript 5 语法（例如，使用
    `var` 而不是 `let`，以及没有箭头函数）。
- en: The omitted `withGame` method (which you can find in the book's companion code)
    uses PhantomJS to load the index view and submit a new game, then clears PhantomJS's
    cookies and opens the game as a new user, before invoking the callback passed
    to `withGame`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 被省略的 `withGame` 方法（你可以在书的配套代码中找到）使用 PhantomJS 加载索引视图并提交一个新的游戏，然后清除 PhantomJS
    的 Cookie 并以新用户身份打开游戏，在调用传递给 `withGame` 的回调之前。
- en: In our test, we create a game to guess the word *example*, then invoke JavaScript
    within the page to make assertions about its contents. The `getText` function
    uses PhantomJS's `page.evaluate` function to run some JavaScript within the context
    of the page, and return a value. Note that the callback function passed to `page.evaluate`
    does not have access to the wider execution context of our script. We can, however,
    specify additional arguments to the `page.evaluate` call, which is how we pass
    in the selector for jQuery.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们创建了一个猜单词 *example* 的游戏，然后在页面中调用JavaScript来对其内容进行断言。`getText` 函数使用PhantomJS的
    `page.evaluate` 函数在页面上下文中运行一些JavaScript，并返回一个值。请注意，传递给 `page.evaluate` 的回调函数没有访问我们脚本更广泛的执行上下文。然而，我们可以为
    `page.evaluate` 调用指定额外的参数，这就是我们如何传递jQuery选择器的方式。
- en: We then use `page.evaluate` again to set up a callback each time an Ajax request
    completes. Here, we use `window.callPhantom`, which executes within the context
    of the page, and triggers `page.onCallback`, which executes within the context
    of our test.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次使用 `page.evaluate` 来设置一个回调，每次Ajax请求完成时都会调用。在这里，我们使用 `window.callPhantom`，它在页面上下文中执行，并触发
    `page.onCallback`，它在我们的测试上下文中执行。
- en: Finally, we use `page.sendEvent` to trigger a keyboard event in the browser.
    Note that this is not the same as using pure JavaScript within the browser to
    trigger a DOM event, but is an instruction directly to PhantomJS to simulate the
    `keypress` event as if it had come from the user.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `page.sendEvent` 来在浏览器中触发一个键盘事件。请注意，这不同于在浏览器中使用纯JavaScript触发DOM事件，而是直接向PhantomJS发送指令来模拟
    `keypress` 事件，就像它来自用户一样。
- en: 'If we put all this together, we get the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有这些放在一起，我们得到以下结果：
- en: We use `page.sendEvent` to simulate pressing a keyboard key
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `page.sendEvent` 来模拟按下一个键盘键
- en: This causes our production code to send off an Ajax request
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这导致我们的生产代码发送一个Ajax请求
- en: When this request completes, `window.callPhantom` is invoked in the context
    of the browser
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当这个请求完成时，在浏览器上下文中调用 `window.callPhantom`
- en: This causes PhantomJS to invoke our `page.onCallback` function
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这导致PhantomJS调用我们的 `page.onCallback` 函数
- en: We then use jQuery within `page.evaluate` (via `getText`) to retrieve values
    from the page
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们在 `page.evaluate` 中使用jQuery（通过 `getText`）来从页面检索值
- en: The remaining contents of the file (`verify` and `handleError`) ensure that
    PhantomJS writes all errors to the console and sets an appropriate exit code in
    the case of a failure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 文件剩余的内容（`verify` 和 `handleError`）确保PhantomJS将所有错误写入控制台，并在失败的情况下设置适当的退出代码。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to write unit tests in Node.js, used Mocha
    and Chai to write more descriptive tests, created test doubles using Sinon.JS,
    written application level tests using SuperAgent and SuperTest, and implemented
    a full-stack test in PhantomJS.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Node.js中编写单元测试，使用Mocha和Chai编写更详细的测试，使用Sinon.JS创建测试双胞胎，使用SuperAgent和SuperTest编写应用级别的测试，并在PhantomJS中实现全栈测试。
- en: Although we have tests at each layer of our application now, we haven't yet
    covered all of our code. It would be useful to find any gaps where we should write
    more tests. We also have to invoke a few different commands to run all of our
    unit and integration tests. In the next chapter, we'll see how to automate these
    and other processes as part of a continuous integration build.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在已经在应用的每一层都有测试，但我们还没有涵盖所有的代码。找到我们应该编写更多测试的任何差距将是有用的。我们还需要调用几个不同的命令来运行所有的单元和集成测试。在下一章中，我们将看到如何将这些和其他过程自动化，作为持续集成构建的一部分。
