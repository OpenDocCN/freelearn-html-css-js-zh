- en: Chapter 1. What Are Modules and Their Advantages?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：模块及其优势是什么？
- en: In this very first chapter, I will provide you with an overview of the modular
    design approach in application development as it relates to JavaScript applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我将为你提供有关应用程序开发中模块化设计方法的概述，特别是与JavaScript应用程序相关的内容。
- en: I will also mention parallels between the modular style of application architecture
    and the real-life examples of this conceptual design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将提及应用程序架构的模块化风格与这种概念设计的现实生活示例之间的相似之处。
- en: Hopefully, as you read along, you'll be able to relate to at least some aspects
    of the modular design approach and start to see why this style of organizing your
    code can be extremely beneficial.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在你阅读的过程中，你能够至少与模块化设计方法的一些方面产生共鸣，并开始看到为什么这种组织代码的风格可以极为有益。
- en: The main objective of this chapter is to create a familiar context for you,
    and to get you started on thinking the modular way as you create and organize
    your code. Soon, you will see that this approach can organically grow into a well-defined
    application architecture methodology.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是为你创造一个熟悉的环境，并让你在创建和组织代码时开始以模块化的方式思考。很快，你就会发现这种方法可以自然地发展成为一套定义良好的应用程序架构方法。
- en: We will start the chapter with a brief discussion on how we can organize our
    code based on specialization. Then we will look at how we can define modules based
    on the functionality that they provide.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章的开头部分用于简要讨论我们如何根据专业化来组织我们的代码。然后，我们将探讨如何根据它们提供的功能来定义模块。
- en: 'The topics that are covered in this chapter are:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: The simple rule to creating modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模块的简单规则
- en: A real life example of modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的实际生活示例
- en: A look at a non-modular example
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非模块化示例的审视
- en: Re-factoring into a more modular approach
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以更模块化的方式重构
- en: Designing in a modular way
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以模块化方式进行设计
- en: Prelude to modular programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化编程的序言
- en: Many years ago, when I was taking my first computer programming course at college,
    I found myself having having difficulty organizing organizing my code into functions
    and classes. I always wondered what kind of criteria I needed to keep in mind
    to qualify a chunk of code to belong to a function or to a class or a subclass.
    When should I break down one function into multiple functions or a class into
    multiple classes?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，当我上大学上第一门计算机编程课时，我发现自己在将代码组织成函数和类方面遇到了困难。我总是想知道我需要记住什么样的标准来判断一段代码是否属于一个函数、一个类或一个子类。我应该什么时候将一个函数分解成多个函数，或者将一个类分解成多个类？
- en: Of course, there were some rules and guidelines that I was familiar with such
    as "a function should not be too long or should not do too many things; a class
    should be a blueprint of a data type" and so on. However, such rules and guidelines
    seemed abstract to me and I wanted to find a rule that was precise and applicable
    in all situations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我熟悉一些规则和指南，例如“函数不应该太长或不应该做太多事情；类应该是一个数据类型的蓝图”等等。然而，这样的规则和指南对我来说似乎很抽象，我想要找到一个精确且适用于所有情况的规则。
- en: As I became more knowledgeable in programming concepts and gained more experience
    in application design, I was able to write more sophisticated code and organize
    my code better into functions and classes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我编程概念的深入和应用程序设计经验的增加，我能够编写更复杂的代码，并将我的代码更好地组织到函数和类中。
- en: However, while my code was organized into well-defined functions and classes,
    such functions and classes still seemed scattered in different parts of the application.
    When I needed to make modifications to one piece of the application, I would be
    concerned about the impact that the change would have on other pieces and the
    functionality of the application as a whole.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管我的代码被组织成定义良好的函数和类，但这些函数和类在应用程序的不同部分仍然显得分散。当我需要修改应用程序的一部分时，我会担心这种变化会对其他部分以及整个应用程序的功能产生什么影响。
- en: As my applications grew larger and became more complex, the impact of the changes
    and enhancements became even more pronounced. There were more things things that
    could adversely affect the application if the application pieces were not designed
    properly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我的应用程序变得更大、更复杂，变化和改进的影响变得更加明显。如果应用程序的各个部分没有设计得当，会有更多的事情对应用程序产生不利影响。
- en: Browser-based applications were particularly vulnerable to such impacts as different
    parts of the application could be manipulating the same element in the browser,
    which would produce unexpected behaviors and effects in other parts of the application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基于浏览器的应用程序尤其容易受到这种影响，因为应用程序的不同部分可能会在浏览器中操作同一个元素，这会导致应用程序的其他部分出现意外的行为和效果。
- en: On the other hand, making small changes to the application was a challenge on
    its own, as finding the best place to make such small changes was not always very
    obvious. Each piece of the application could be performing many different activities
    from manipulation DOM to writing to cookie to making AJAX calls.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对应用程序进行小的改动本身就是一项挑战，因为找到进行这种小改动最佳位置并不总是非常明显。应用程序的每一部分都可能执行许多不同的活动，从操作DOM到写入cookie，再到发起AJAX调用。
- en: What if I could make one part of the application responsible for only one type
    of functionality? What if only one part of the application was responsible for
    all cookie-related functionality? What if only one piece would make AJAX calls
    to the server and provide the other pieces of the application with the returned
    data?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我能让应用程序的某一部分只负责一种功能类型会怎样？如果只有应用程序的一部分负责所有与cookie相关的功能会怎样？如果只有一部分会向服务器发起AJAX调用并提供其他应用程序部分返回的数据会怎样？
- en: As we design functions and classes to specialize in doing very specific tasks,
    we can also bundle such functions and classes together to act as a specialized
    piece of the application responsible for providing one particular functionality.
    The key point here is to create specialized code packages.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计函数和类以专门执行非常具体的任务时，我们也可以将这些函数和类捆绑在一起，作为专门的应用程序部分，负责提供特定的功能。关键点在于创建专门的代码包。
- en: This would mean that changes in how we read and write to cookies would only
    take place in the package that is responsible for cookie operations and such changes
    would have no impact on how AJAX calls are made to the server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，我们对cookie的读写方式的变化只会发生在负责cookie操作的包中，这样的变化不会影响对服务器的AJAX调用方式。
- en: If we organize our code into specialized packages, (or modules as we will call
    them) we can easily achieve this goal of separation of concerns and responsibilities
    among our application pieces.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将代码组织成专门的包（或者我们称之为模块），我们就可以轻松实现应用程序各个部分之间关注点和责任分离的目标。
- en: But before we can organize our code into modules, we need to see how we decide
    that a chunk of code should be a module.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们能够将代码组织成模块之前，我们需要了解我们如何决定一块代码应该是一个模块。
- en: The simple rule for creating modules
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块的简单规则
- en: I need to emphasize on the fact that modular programming is not some magical
    and mystical design concept and pattern that is hard to grasp and even harder
    to implement. It is really just a practical approach to organizing our code in
    such a way that each chunk of code only does a very specific and specialized task.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要强调的是，模块化编程并不是某种难以掌握且难以实现的神奇和神秘的设计概念和模式。它实际上只是组织我们代码的一种实用方法，使得每一块代码只执行一个非常具体和专业的任务。
- en: The idea is that each module is a loosely coupled piece of the application,
    a building block that, along with other pieces (and other modules), creates an
    ecosystem, that is your application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是，每个模块都是应用程序的一个松散耦合的部分，一个构建块，它与其他部分（和其他模块）一起创建了一个生态系统，即你的应用程序。
- en: 'So here is the simple rule for creating modules: "If a piece of your application
    provides a specialized functionality, it can be made into a module that can also
    be reused in other applications."'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里有一个创建模块的简单规则：“如果你的应用程序的一部分提供了专门的功能，它可以被制作成一个模块，也可以在其他应用程序中重用。”
- en: I mentioned previously that I was looking for a "precise" rule to help me organize
    my application code but as my experience has shown, there is no such precise rule
    other than what I mentioned above, which is in fact not a rule but a guideline.
    And as a guideline, there is flexibility in what can be considered a module or
    not. This can be best decided both at the design time and as the application evolves
    since the application needs can change over time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，我在寻找一个“精确”的规则来帮助我组织应用程序代码，但正如我的经验所表明的，除了我上面提到的之外，没有这样的精确规则，而这实际上不是一个规则，而是一个指导方针。作为一个指导方针，在考虑一个模块或不是模块时有一定的灵活性。这最好在设计时间和应用程序演变过程中决定，因为应用程序的需求会随时间变化。
- en: A real-life example of modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的真实生活示例
- en: Let's consider a familiar modular system. You are most likely reading this book
    in a place that has electricity and there are many electric outlets in the walls
    surrounding you. This system enables you to plug in various electrical devices
    into the outlets and each one of these devices is designed to do a very specific
    task.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个熟悉的模块化系统。你很可能在拥有电力并且周围墙壁上有许多电源插座的地方阅读这本书。这个系统使你能够将各种电器插入插座，而这些设备每一个都是设计来执行一个非常具体的任务的。
- en: 'Consider the electrical devices that are plugged into some of these outlets:
    microwaves, electric kettles, washers, dryers, and so on.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑插在这些插座中的电器：微波炉、电热水壶、洗衣机、烘干机等等。
- en: None of these devices care if they are plugged into the electrical outlet in
    your house or your neighbor's house. They are designed to do their specific task
    and functionality when they are plugged in and when the power is on, regardless
    of whose house they are in.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备都不在乎它们是否插在你家的电源插座或邻居家的电源插座上。它们被设计成在插入并接通电源时执行它们的具体任务和功能，无论它们在哪个房子里。
- en: Our application modules should follow the same philosophy. This means, regardless
    of where in the application they are plugged in and even regardless of what application
    they are plugged into, they should do their specific task and only their specific
    task.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序模块应该遵循相同的理念。这意味着，无论它们在应用程序中的哪个位置插入，甚至无论它们插入到哪个应用程序中，它们都应该执行它们的具体任务，并且只执行它们的具体任务。
- en: Also, in exactly the same way that an electrical device can easily be unplugged
    from the wall outlet, a code module should be designed in such a way that it can
    easily be decoupled and removed from your application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，就像电器可以很容易地从墙上拔掉一样，代码模块也应该设计成可以轻松解耦并从你的应用程序中移除。
- en: Furthermore, as the removal of one electrical device has no impact on the functionality
    of other devices that are plugged into your electrical system, the removal of
    a code module or a series of code modules from your application should not have
    any effect on the functionality of the other parts of your application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于移除一个电器不会影响你电系统中其他插上电器的功能，从你的应用程序中移除一个代码模块或一系列代码模块也不应该影响应用程序其他部分的功能。
- en: This decoupling should also have no effect on the application as a whole, other
    than perhaps just losing the specific functionality that was provided by that
    particular module or group of modules in your application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解耦不应该对整个应用程序产生任何影响，除了可能只是失去由该特定模块或模块组在应用程序中提供的特定功能。
- en: In this book, we will explore how creating modules will help in designing better
    specialized code pieces that can easily be plugged into and unplugged from our
    applications. We will also see how modular architecture provides for a more robust
    and flexible application as a whole.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将探讨创建模块如何帮助我们设计更好的专用代码片段，这些代码片段可以轻松地插入和从我们的应用程序中拔出。我们还将看到模块化架构如何为整体提供更健壮和灵活的应用程序。
- en: We will discover how this kind of architectural approach leads to huge advantages
    in many aspects of our application fundamentals such as code usability, maintainability,
    testability, and many more.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发现这种类型的架构方法如何在许多方面为我们的应用程序基础带来巨大的优势，例如代码可用性、可维护性、可测试性以及更多。
- en: I hope now you are curious enough to at least consider modular programming in
    general and JavaScript modular programming in particular as a possible approach
    for your future application design.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望现在你已经足够好奇，至少考虑模块化编程，特别是JavaScript模块化编程，作为你未来应用程序设计的可能方法。
- en: In further chapters, we will apply the same principles that we discussed regarding
    electrical outlets and appliances to our code modules, in both the design and
    implementation phases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将应用我们讨论过的关于电源插座和电器的相同原则，应用到我们的代码模块的设计和实现阶段。
- en: A look at a non-modular example
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看一个非模块化示例
- en: Let's consider an extremely simple example and see how the (somehow) **specialized**
    modular approach differs from a non-modular one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个非常简单的例子，看看这种（某种方式）**专业化的**模块化方法与非模块化方法有何不同。
- en: 'We start by writing a couple of functions in the traditional way, as following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先以传统的方式编写几个函数，如下所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the above code, we have two independent functions for doing
    simple additions and subtractions and there is no relation between the two, other
    than the fact that they both operate on the two passed-in numbers (numeric values).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上面的代码中所见，我们有两个独立的功能用于执行简单的加法和减法，它们之间没有关系，除了它们都操作于传入的两个数字（数值）之外。
- en: If we had implemented these functions in an application and were to do the identical
    operations in a different application, we most likely would either rewrite the
    same functions in that application from scratch or we would copy/paste the code
    from this application into the other one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个应用程序中实现了这些功能，然后在不同的应用程序中执行相同的操作，我们很可能会要么在该应用程序中从头开始重新编写相同的函数，要么将此应用程序中的代码复制/粘贴到另一个应用程序中。
- en: What if we now decided to also do multiplication, division, and other related
    calculations in our application using the same approach?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在决定在应用程序中使用相同的方法进行乘法、除法和其他相关计算，那会怎样呢？
- en: Well, one way would be to just continue writing independent functions as above
    and add them to our application. This approach could work and would get the job
    done, but probably not in the best way, since as the code grows it will become
    more disorganized and chaotic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，一种方法就是继续像上面那样编写独立的函数，并将它们添加到我们的应用程序中。这种方法可能可行，并且能够完成任务，但可能不是最佳方式，因为随着代码的增长，它将变得更加混乱和杂乱。
- en: By using this approach, not only would we be polluting the global namespace
    with a bunch of global functions that could possibly collide with other global
    functions of the same name. We would also end up with scattered pieces of code
    that had not been packaged together based on their functionality and specialization.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种方法，我们不仅会将大量可能与其他同名全局函数冲突的全局函数污染全局命名空间。我们最终还会得到一些散乱的代码片段，这些代码片段没有根据其功能和专业性打包在一起。
- en: If all such functions do mathematical calculations of one kind or another and
    that is the commonality that they all have, how about if we create a **package**
    (module) that specializes in mathematical calculations?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些函数都进行一种或多种数学计算，并且这是它们共有的共性，那么我们是否可以创建一个**包**（模块）来专门进行数学计算呢？
- en: This would allow us to have a specialized package that regardless of the application
    that it is hosted in, would always provide the same specialized functionality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够拥有一个专门的包，无论它托管在哪个应用程序中，都会始终提供相同的专业功能。
- en: Let's even imagine a step further and assume that we created this package in
    a separate JavaScript file that can be added as an independent module to any application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，假设我们在一个单独的JavaScript文件中创建了此包，该文件可以作为独立模块添加到任何应用程序中。
- en: Even better, how about if this module only would get added (requested from the
    server, in the case of a client side web application) to the application at runtime,
    and only when needed?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 更好一点，如果这个模块只会在运行时添加（在客户端Web应用程序的情况下，从服务器请求）到应用程序中，并且只有在需要时才添加，那会怎样？
- en: This type of implementation would give us the ability to load chunks, pieces,
    or modules of the code when needed at runtime and then unload them when the application
    does not need them anymore. This would enable us to cut down on the footprint
    of our application on the client side while providing all the necessary functionality
    as needed and on demand.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的实现将使我们能够在运行时根据需要加载代码的块、部分或模块，然后在应用程序不再需要它们时卸载它们。这将使我们能够减少应用程序在客户端的占用空间，同时按需提供所有必要的功能。
- en: Such an approach can also be very useful on mobile devices which have limited
    bandwidth and resources to be leveraged.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在带宽和资源有限的移动设备上也非常有用。
- en: Rest assured that I do intend to explore all such possibilities with you in
    the later chapters of this book.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请放心，我确实打算在本书的后续章节中与您探讨所有这些可能性。
- en: Re-factoring to a more modularized approach
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构为更模块化的方法
- en: 'Let''s consider re-factoring the two functions that we looked at previously
    and putting them together in a more specialized package (class or module) called,
    `CalculationHandler`, as shown below:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑重构之前查看的两个函数，并将它们组合在一个更专业的包（类或模块）中，称为`CalculationHandler`，如下所示：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in this "module" (and I use the term loosely here; you will see
    why in later chapters), I am using a function object and adding properties (methods)
    to this object. This methods do specialized tasks related to the overall functionality
    of the object (module), such as addition and subtraction.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在“模块”中可以看到的（我在这里使用这个术语比较宽松；你将在后面的章节中看到原因），我正在使用一个函数对象，并向这个对象添加属性（方法）。这些方法执行与对象（模块）的整体功能相关的特定任务，例如加法和减法。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A note about our module here**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于我们模块的注意事项**'
- en: If you are more experienced in JavaScript programming, you are probably thinking
    that the way I have created this module is probably not the best way to create
    a real module in JavaScript, and you are right! But for now, the big idea here
    is that any piece of code that does a specialized task can be tagged as a module,
    for the most part.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更熟悉JavaScript编程，你可能认为我创建这个模块的方式可能不是在JavaScript中创建真实模块的最佳方式，你是对的！但就目前而言，这里的主要思想是，任何执行特定任务的代码片段都可以被标记为模块，在大多数情况下。
- en: However, there are certainly better ways to write more robust and extensible
    modules in JavaScript. For instance, creating a module can be accomplished much
    better by using the **Module Design Pattern**, which we will get to explore a
    lot further in later chapters of this book.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在JavaScript中编写更健壮和可扩展的模块肯定有更好的方法。例如，通过使用**模块设计模式**（Module Design Pattern）来创建模块可以做得更好，我们将在本书的后续章节中深入探讨这一点。
- en: Designing in a modular way
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以模块化的方式进行设计
- en: In the early stages of designing an application, one of the most important steps
    is to decide on the functionality that the application needs to provide. This
    of course, is based on the overall purpose of the application and the type of
    application that you are designing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用的早期阶段，最重要的步骤之一是确定应用需要提供的功能。这当然基于应用的整体目的和你要设计的应用类型。
- en: Based on such requirements, in the design phase, you should try to break down
    the overall functionality (the big picture) of the application into smaller and
    specialized pieces. Then, you can determine if such pieces already exist, either
    in the form of third-party libraries or the code that you have already written
    for a different application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这样的要求，在设计阶段，你应该尝试将应用的整体功能（大局）分解成更小、更专业的部分。然后，你可以确定这些部分是否已经存在，无论是以第三方库的形式还是以你为其他应用编写的代码的形式。
- en: If you already have your own chunks of reusable code designed in a modular fashion
    (most third-party libraries are designed in such a way too), it would be much
    easier and quicker to connect these pieces together and use them in your new application.
    This would be the same as putting various Lego blocks together to create a play
    structure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经以模块化的方式设计了自己的可重用代码块（大多数第三方库也是这样设计的），那么将这些部分连接起来并在新应用中使用它们将会容易得多，也快得多。这就像把各种乐高积木组合起来创建一个游乐结构一样。
- en: This type of approach is very important and fits quite well within an **Agile**
    development environment. This enables you to work on well defined, specialized
    modules as you need them and as new application requirements are defined. Also,
    as you create your code based on modules, you are able to prevent tight coupling
    among your application pieces.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常重要，并且非常适合**敏捷**开发环境。这使你能够在需要时以及当新的应用需求被定义时，工作在定义良好、专业的模块上。此外，当你基于模块创建代码时，你能够防止应用各个部分之间出现紧密耦合。
- en: On the other hand, this approach allows different developers to work on different
    pieces (modules) of the same application, independently of each other. Another
    advantage is that modules can be tested separately and in different environments
    before being added to the application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这种方法允许不同的开发者独立地工作在相同应用的各个部分（模块）上。另一个优点是，模块可以在被添加到应用之前单独并在不同的环境中进行测试。
- en: In time and with more experience in modular application design and implementation,
    you will become better at deciding how to distinguish and design your modules.
    However, it is not realistic to think you can come up with the complete list of
    all the modules that you could ever need in your application, in the first attempt.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移和更多在模块化应用设计和实现方面的经验，你将更好地决定如何区分和设计你的模块。然而，认为你可以在第一次尝试中就提出应用中可能需要的所有模块的完整列表是不现实的。
- en: That is because applications evolve and requirements change over time. You may
    need to create new modules, or modify current ones, or decide to use a different
    module or library altogether to accommodate such changes in the requirements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为应用程序会发展，需求会随时间变化。你可能需要创建新的模块，或修改现有的模块，或者决定使用不同的模块或库来适应需求的变化。
- en: The key advantage of modular design is the flexibility that is provides. Dealing
    with all the situations mentioned above is a lot easier and requires a lot less
    effort in a modular architecture. It will also mitigate the impact that adding,
    removing, or modifying a module could possibly have on the application as a whole.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化设计的关键优势是它提供的灵活性。在模块化架构中处理上述所有情况要容易得多，并且需要付出更少的努力。它还将减轻添加、删除或修改模块可能对整个应用程序产生的影响。
- en: In the following chapters, you will see how we can create simple and complex
    modules and how they will be added to our application as loosely coupled pieces.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将看到我们如何创建简单和复杂的模块，以及它们将以松散耦合的方式添加到我们的应用程序中。
- en: You will also see how we can load such modules dynamically and on demand when
    we need them in our application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将看到我们如何在需要时动态和按需加载这些模块到我们的应用程序中。
- en: So, let's get ready for an exciting journey into our future application design,
    using modular architecture.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们为进入未来应用程序设计的激动人心的旅程做好准备，使用模块化架构。
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we tried to get an overview of the concepts behind modular
    programming in general and how such concepts can be used in JavaScript applications
    in particular.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们试图概述模块化编程背后的概念，以及这些概念如何在JavaScript应用程序中特别使用。
- en: We saw that this approach is essentially based on creating packages of specialized
    code that do very specific tasks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，这种方法本质上基于创建执行非常特定任务的专用代码包。
- en: We also made parallels between how modules are designed in real life and our
    application modules, so that we can translate the similarities into our own application
    design approach.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还比较了现实生活中模块的设计方式以及我们的应用程序模块，以便将相似之处转化为我们自己的应用程序设计方法。
- en: While the term "module" can be used to refer to different things in the code,
    we will take this terminology to refer to a certain style of programming and architecture
    in our JavaScript application design approach in later chapters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然术语“模块”可以在代码中指代不同的事物，但我们将在后续章节中将这个术语用于指代我们JavaScript应用程序设计方法中的一种编程和架构风格。
- en: However, before we completely dive into the more technical aspects of JavaScript
    modular programming, it is a good idea to review the fundamentals of object-oriented
    programming in JavaScript in the next chapter. This will allow us to establish
    a solid foundation for more technical chapters as we move forward.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们完全深入JavaScript模块化编程的更技术方面之前，回顾下一章中JavaScript面向对象编程的基础知识是个好主意。这将为我们前进过程中更技术性的章节建立一个坚实的基础。
