- en: Advanced Features on Aurelia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Aurelia 的高级功能
- en: 'Congratulations! Finally, we are here. Welcome to the last chapter of the second
    section of this book! At this point, we are really sure that you know how to plan
    and develop, and now we will add some cool features to make our application more
    interesting and scalable. Maybe you were thinking about how to share some properties
    or trigger events across all the components, or make your application understandable
    for people from different countries speaking different languages. Well, internationalization
    is a great concept that you are going to meet in this chapter. What if you need
    to perform operations to convert dates, numbers, or currency? Well, these kinds
    of situations (and so much more) are very common in a real application, so you
    need to be prepared to deal with it. You know what? We have good news! Aurelia
    is prepared with a great solution for every case (and so much more too!). In this
    chapter, you will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！终于，我们到了这里。欢迎来到本书第二部分的最后一章！在这个时候，我们真的确信你知道如何规划和开发，现在我们将添加一些酷炫的功能，使我们的应用程序更加有趣和可扩展。也许你在想如何共享一些属性或触发所有组件的事件，或者使你的应用程序对不同国家讲不同语言的人可理解。好吧，国际化是一个你将在本章中遇到的好概念。如果你需要执行转换日期、数字或货币的操作呢？好吧，这类情况（以及更多）在真实的应用程序中非常常见，所以你需要准备好处理它。你知道吗？我们有好消息！Aurelia为每种情况（以及更多）都准备好了出色的解决方案。在本章中，你将学习以下主题：
- en: Event Aggregator
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件聚合器
- en: Internationalization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化
- en: Logging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Aurelia dialog
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aurelia 对话框
- en: Value converters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值转换器
- en: Custom binding behaviors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义绑定行为
- en: Validators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证器
- en: Custom attributes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义属性
- en: Computed properties
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性
- en: Let's start with this awesome chapter; I assure you that you will find it very
    useful and interesting. We promise.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个精彩的章节开始；我保证你会发现它非常有用和有趣。我们保证。
- en: Subscribing and publishing events – Event Aggregator at the rescue!
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅和发布事件 – 事件聚合器来拯救！
- en: In our current application, we have different components and views. Some of
    them need to retrieve data from the server, others just need to process data provided
    for other components, and yet others just help our user interface be more elegant
    and understandable. Okay, all looks good at this point. Note that at this point,
    our application supports different kinds of processing—data load, transformation,
    and how this is displayed. Each one implies a different cost of performance, and
    because of that one could take longer than others. That being said, let's describe
    a common scenario—the user enters our application and navigates to the page listing
    all the matches for this month. There is a lot of data to be retrieved, and you
    need to calculate the time between today and the match date (for each one).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的应用程序中，我们有不同的组件和视图。其中一些需要从服务器检索数据，其他一些只需要处理为其他组件提供的数据，还有一些只是帮助我们的用户界面更加优雅和易于理解。好吧，到目前为止一切看起来都很好。请注意，到目前为止，我们的应用程序支持不同类型的处理——数据加载、转换以及如何显示。每一项都意味着不同的性能成本，因此可能比其他情况花费更长的时间。话虽如此，让我们描述一个常见的场景——用户进入我们的应用程序并导航到显示本月所有比赛的页面。有大量的数据需要检索，你需要计算今天和比赛日期之间的时间（针对每一个）。
- en: The time remaining for the cost of all of this operation will depend on the
    amount of data returned by the server, so you need to remember something—when
    you design an application, design it while taking into consideration the most
    extreme cases.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作的成本剩余时间将取决于服务器返回的数据量，所以你需要记住——当你设计一个应用程序时，要考虑到最极端的情况。
- en: 'Getting back to our application case, we can find two scenarios:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的应用程序案例，我们可以找到两种情况：
- en: The most convenient one is where the user knows that the application is retrieving
    data and waits patiently until the page is completely loaded. Honestly, based
    on our experience, this scenario represents 5% of the common user behaviors with
    digital applications.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最方便的情况是用户知道应用程序正在检索数据，并耐心地等待页面完全加载。老实说，根据我们的经验，这种场景代表了数字应用程序中常见用户行为的5%。
- en: The second and most probable scenario is an impatient user, who thinking that
    their internet connection is lost, refreshes the page constantly, or presses some
    button, or, worse yet, leaves our application forever.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个且最可能的情况是一个没有耐心的用户，他们认为自己的互联网连接丢失，不断地刷新页面，或者按下某个按钮，或者更糟糕的是，永远离开我们的应用程序。
- en: We need to take action to tell the user "Hey! I'm working on something, please
    wait!" and at the same time, block every button that can trigger an event causing
    more waiting time. We are sure you know the answer, the famous loading bar icon.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取行动告诉用户“嘿！我正在处理某事，请稍等！”同时，阻止任何可以触发事件导致更多等待时间的按钮。我们确信你知道答案，那就是著名的加载条图标。
- en: '![](img/2a0f994f-c817-4178-be27-e0981dceecaf.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a0f994f-c817-4178-be27-e0981dceecaf.png)'
- en: 'We have two options to implement it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种实现它的方法：
- en: Put a loading bar icon on every view/component and manage its behavior inside
    each one
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个视图/组件上放置一个加载条图标，并在其中管理其行为
- en: Put just one loading bar icon in our main application template and call it from
    other components
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的主应用程序模板中只放置一个加载条图标，并从其他组件调用它
- en: Maybe you are wondering, how can I call one event from another child component?
    Well, without Aurelia, of course, it could be a hard task to perform, but luckily,
    it won't be that case. Aurelia comes with an incredible and easy-to-learn/understand
    feature—Event Aggregator.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你会想知道，我如何从一个子组件调用另一个事件？好吧，当然，没有Aurelia，这可能是一个困难的任务，但幸运的是，情况不会是这样。Aurelia附带了一个令人难以置信的、易于学习和理解的功能——事件聚合器。
- en: Like choosing to use anything, the decision to use the Event Aggregator module
    should be dictated by your application requirements. In most cases, it's for dealing
    with *cross-cutting concerns.*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像选择使用任何东西一样，使用事件聚合器模块的决定应该由你的应用程序需求来决定。在大多数情况下，它是为了处理*横切关注点*。
- en: Let's take an over view of what cross-cutting concerns are.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们概述一下什么是横切关注点。
- en: 'If there is some method that should be triggered at some event of the application/components
    lifetime and not have any relationship with it, we are talking about a cross-cutting
    concern. Some generic examples are as listed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一些方法应该在应用程序/组件的生命周期中的某个事件被触发，并且与它没有任何关系，我们就是在谈论横切关注点。一些通用的例子如下所示：
- en: Application loading
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序加载
- en: Session validation
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话验证
- en: Logging
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Configuring Event Aggregator
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置事件聚合器
- en: 'The Event Aggregator class is not hard to understand. Incredibly, it just has
    three exposed methods. Like any other Aurelia module, you just need to import
    and inject it into your view model before using it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 事件聚合器类不难理解。令人难以置信的是，它只有三个公开的方法。像任何其他Aurelia模块一样，你只需要在使用它之前将其导入并注入到你的视图模型中：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's explore the Event Aggregator methods in detail.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细探索事件聚合器的方法。
- en: publish(event, data)
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: publish(event, data)
- en: This method allows you to fire events. Remember that our `EventAggregator` will
    be placed in some parent component, so you know which components will be subscribed
    to it. So, because of that, this method does not have a specific target; they
    are just events triggered to space and doesn't matter if they have zero or more
    subscribers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许你触发事件。记住，我们的`EventAggregator`将被放置在某个父组件中，所以你知道哪些组件将订阅它。因此，由于这个原因，这个方法没有特定的目标；它们只是触发到空间的事件，不管是否有零个或多个订阅者。
- en: The first argument is the event name. You can choose any name for this, as it
    is your custom event. It will be used as an identifier to call it from external
    components across our application. In this case, you can use `EventAggregator`
    to configure our loading bar, so it would be right to name our event according
    to it. We will call it `dataRetrievingEvent`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是事件名称。你可以为这个选择任何名字，因为这是你的自定义事件。它将被用作标识符，以便从应用程序的外部组件调用它。在这种情况下，你可以使用`EventAggregator`来配置我们的加载条，所以按照它来命名是正确的。我们将称之为`dataRetrievingEvent`。
- en: The second argument is the data you want to pass to the event (to supply some
    data, for example) and it's completely optional. Most of the time, it will be
    an array or an object of data. You can even pass through a string value if you
    like. However, not all events need to receive new data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是你想要传递给事件的数据（例如提供一些数据），这是完全可选的。大多数情况下，它将是一个数组或数据对象。如果你愿意，甚至可以传递一个字符串值。然而，并不是所有事件都需要接收新数据。
- en: 'We will call this method using our class definition variable for `EventAggregator`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的`EventAggregator`类定义变量来调用此方法：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That was very easy. We have our first custom event configured and ready to be
    called from any component in our application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。我们已经配置并准备好了我们的第一个自定义事件，可以从应用程序中的任何组件调用它。
- en: subscribe(event, callbackFunction)
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: subscribe(event, callbackFunction)
- en: If we published an event at the first method, now it's time to listen to it.
    The first parameter is the event name we want to subscribe, and the second is
    a callback function that can be used to get the value sent by the event publisher.
    This data can be a simple string, or, like in our case, an object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在第一个方法中发布了一个事件，现在就是时候监听它了。第一个参数是我们想要订阅的事件名称，第二个参数是一个回调函数，可以用来获取事件发布者发送的值。这些数据可以是一个简单的字符串，或者，就像在我们的例子中，是一个对象。
- en: 'Like the preceding example, we can access this method through our `EventAggregator`
    class instance in our component:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的例子一样，我们可以在我们的组件中通过`EventAggregator`类实例访问这个方法：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have defined a `subscriber` object which is basically a method call. This
    object will make a direct reference to the subscribed event and allows us to execute
    directly a child function called `dispose`. This function is used to delete the
    existing subscription, generally used when our component is destroyed. Keep in
    mind that even the Event Aggregator is a great feature; a little cost in performance
    will be paid, so don't abuse it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`subscriber`对象，这基本上是一个方法调用。这个对象将直接引用订阅的事件，并允许我们直接执行一个名为`dispose`的子函数。这个函数用于删除现有的订阅，通常用于我们的组件被销毁时。请记住，即使事件聚合器是一个很棒的功能，也会付出一点性能上的代价，所以不要滥用它。
- en: 'Here''s an example of a subscription that is removed when the view model is
    detached:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，当视图模型被分离时，订阅会被移除：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a garbage collection measure and ensures that your app does not use
    resources that it no longer requires.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个垃圾回收措施，确保您的应用程序不会使用它不再需要的资源。
- en: subscribeOnce(event, callbackFunction)
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: subscribeOnce(event, callbackFunction)
- en: 'This method is exactly the same as the `subscribe()` method, but with just
    one difference—it automatically unsubscribes the event once the callback is raised.
    Maybe in some cases, you will find some situations that just require a *one-time* subscription,
    such as our loading bar. The example is very similar to the `subscribe()` method
    example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与`subscribe()`方法完全相同，但只有一个区别——一旦回调被触发，它会自动取消订阅事件。也许在某些情况下，您会发现一些只需要*一次性*订阅的情况，比如我们的加载条。这个例子与`subscribe()`方法的例子非常相似：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are sure that you will find this feature really useful. This is just the
    beginning! Let's explore other awesome APIs!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确信您会发现这个功能非常有用。这只是开始！让我们探索其他令人惊叹的API！
- en: Adding more languages to our application – Internationalization!
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序添加更多语言——国际化！
- en: One of the more interesting (and useful) features for every web application
    is internationalization. We are developing an application for the FIFA World Cup
    Russia 2018, so, based on that, it would be awesome if our application supported multiple
    languages for all the users worldwide.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个Web应用程序来说，国际化是更有趣（和有用）的功能之一。我们正在开发一个用于2018年俄罗斯FIFA世界杯的应用程序，因此，基于这一点，如果我们的应用程序能够支持全球所有用户的多种语言，那就太棒了。
- en: 'For this purpose, we will use the official `aurelia-i18n` plugin; this will
    be used to get the current app location. This plugin is based on the `i18next`
    library, with some very interesting characteristics such as those listed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将使用官方的`aurelia-i18n`插件；这将用于获取当前应用程序的位置。这个插件基于`i18next`库，具有一些非常有趣的特性，如下列所示：
- en: Translation loaders
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译加载器
- en: Language detection
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言检测
- en: Product localization
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品本地化
- en: Flexibility and scalability
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性和可扩展性
- en: The last one is the most important feature. With scalability in mind, you can
    implement internationalization with just one configuration file for smaller projects,
    and if you need to implement it on a bigger project, just create multiple translation
    files and load them according to the user's need.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是最重要的功能。考虑到可扩展性，您只需一个配置文件就可以为较小的项目实现国际化，如果您需要在较大的项目上实现它，只需创建多个翻译文件并根据用户的需求加载它们。
- en: Installation and configuration
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置
- en: Depending on which build tool you've chosen to create and configure your application,
    you will find many ways to install and get ready with the `aurelia-i18n` plugin.
    At this point, we've used the Aurelia CLI, but let's explore how to configure
    it in case we had chosen a different option, remember them?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您选择的构建工具来创建和配置您的应用程序，您会发现许多安装和准备`aurelia-i18n`插件的方法。到目前为止，我们已经使用了Aurelia CLI，但让我们探索一下如果我们选择了不同的选项，如何配置它，还记得吗？
- en: Webpack
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack
- en: JSPM
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSPM
- en: Aurelia CLI
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aurelia CLI
- en: For Webpack users
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于Webpack用户
- en: 'We need to retrieve the plugin from the `npm` repository, so just type the
    following command to get the latest:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从`npm`仓库检索插件，所以只需输入以下命令以获取最新版本：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It will download and save the plugin in your project dependencies. As we said
    earlier, `aurelia-i18n` is based on `i18n` framework, so you should install a
    backend plugin. One of the most famous is `i18next-xhr-backend`, a simple `i18next`
    backend to be used in the browser. How does it work? Easy, using `XHR`, it will
    load resources from some backend server. Yes, your translation files! If you want
    to use the built-in `aurelia-loader` backend, the same plugin Aurelia use to get
    resources, it's okay, you can ignore the next step.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它将下载并保存插件到您的项目依赖项中。正如我们之前所说的，`aurelia-i18n`基于`i18n`框架，因此您应该安装一个后端插件。其中最著名的是`i18next-xhr-backend`，一个简单的用于浏览器的`i18next`后端。它是如何工作的？简单，使用`XHR`，它将从某些后端服务器加载资源。是的，您的翻译文件！如果您想使用内置的`aurelia-loader`后端，即Aurelia用来获取资源的相同插件，那么可以忽略下一步。
- en: You know what to do now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道该怎么做。
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We are almost ready. In your Webpack configuration file, you must add `aurelia-i18n` to
    your project''s Aurelia bundles list (on the Aurelia section):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好了。在您的Webpack配置文件中，您必须在项目的Aurelia捆绑列表（在Aurelia部分）中添加`aurelia-i18n`。
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JSPM users
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSPM用户
- en: 'Similar way as the first two steps, but instead of using the known NPM, we
    will use JSPM. First, we will download the `aurelia-i18n` plugins:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两步类似，但我们将使用JSPM而不是已知的NPM。首先，我们将下载`aurelia-i18n`插件：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the backend, type this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后端，请输入以下内容：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we will use the built-in `aurelia-i18n-loader`, we don't need to add any additional
    configuration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用内置的`aurelia-i18n-loader`，因此我们不需要添加任何额外的配置。
- en: Aurelia CLI users
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Aurelia CLI用户
- en: 'Almost the same as we explained in the Webpack user section, we need to retrieve
    the `aurelia-i18n` plugin and backend server from the `npm` repositories:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在Webpack用户部分解释的几乎相同，我们需要从`npm`仓库检索`aurelia-i18n`插件和后端服务器：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we need to tell our project that we have new dependencies to be configured.
    Open your Aurelia configuration file (`aurelia.json`) and look for the `dependencies` section.
    You must add the following entries:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉我们的项目我们有一些新的依赖项需要配置。打开您的Aurelia配置文件（`aurelia.json`），查找`dependencies`部分。您必须添加以下条目：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If your application was created using the `Aurelia CLI 0.33.1`, you can omit
    this last step.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序是使用`Aurelia CLI 0.33.1`创建的，您可以省略此最后一步。
- en: Finally, we are done with the plugins. Now, let's configure it to our application!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了插件的配置。现在，让我们将其配置到我们的应用程序中！
- en: Configuring and defining our first translation files
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和定义我们的第一个翻译文件
- en: Our application is ready to start using the `i18n` framework. There are some
    steps to get ready with the plugin, so let's explore them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已准备好开始使用`i18n`框架。有一些步骤需要准备插件，让我们来探索它们。
- en: 'The first thing we need is to locate our `index.html` file. This should be
    located in our main root application folder. Ensure that your `<body>` section
    is the same as the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是定位我们的`index.html`文件。它应该位于我们的主要根应用程序文件夹中。确保您的`<body>`部分与以下相同：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you are a `Webpack` user, locate the `index.js` file instead of `index.html`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是`Webpack`用户，请定位`index.js`文件而不是`index.html`。
- en: Then, in your root app location, create a folder called `locales`. It will be
    used to store all your location files. Create one folder per language you want
    to support. Then, inside each folder, create a file called `translation.json`.
    This file will contain all your text translation structures, depending on your
    application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的根应用程序位置，创建一个名为`locales`的文件夹。它将用于存储所有位置文件。为要支持的语言创建一个文件夹。然后，在每个文件夹内部，创建一个名为`translation.json`的文件。此文件将包含所有您的文本翻译结构，具体取决于您的应用程序。
- en: 'Your application folder structure must look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序文件夹结构必须如下所示：
- en: '![](img/72d55340-b07d-4dd7-9e9e-d1edb6a939f5.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72d55340-b07d-4dd7-9e9e-d1edb6a939f5.png)'
- en: '`i18next` works based on a predefined transaction-file schema. Look at the
    following example of our en-EN transaction file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`i18next`基于预定义的事务文件模式工作。查看以下我们的en-EN事务文件示例：'
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, one for es-ES language support:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个用于es-ES语言支持：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So these are simply for example purposes and very useful to understand how this
    plugin works. Now, it's time to configure the plugin backend. Do you remember
    that we created the `src/main.js` file to define our configuration function? Well,
    it's time to open this file and add some new configuration. If you haven't created
    this file yet, this is a good time to do that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些只是为了示例目的，并且非常有用，可以帮助你理解这个插件的工作方式。现在，是时候配置插件后端了。你还记得我们创建的 `src/main.js` 文件来定义我们的配置函数吗？好吧，现在是打开这个文件并添加一些新配置的时候了。如果你还没有创建这个文件，这是一个很好的时机去做这件事。
- en: 'For those who have chosen the `i18next-xhr-backend` support, first of all,
    open the `main.js` file and find the Aurelia''s configuration section. In the
    first lines of the file, you must import the following files:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择 `i18next-xhr-backend` 支持的人来说，首先，打开 `main.js` 文件并找到 Aurelia 的配置部分。在文件的第一行，你必须导入以下文件：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, create a new plugin pipe:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个新的插件管道：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, inside the new plugin pipe, add the following configuration:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在新的插件管道内部，添加以下配置：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's explain a little of what are we doing in this file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单解释一下我们在该文件中做了什么。
- en: 'First, we need to configure our `i18n` aliases, so just declare them on a simple
    string array and pass it as a parameter to the static `configureAliases()` method.
    This will map the defined values in our `<html>` tags to call the correct values.
    It may sound a little confusing at this time, but don''t worry, you are very near
    to seeing the whole picture:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要配置我们的 `i18n` 别名，所以只需在简单的字符串数组中声明它们，并将它们作为参数传递给静态的 `configureAliases()`
    方法。这将把定义的值映射到 `<html>` 标签中，以调用正确的值。现在可能听起来有点令人困惑，但别担心，你很快就能看到整个画面：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we register the imported backend plugin (`i18next-xhr-backend`) into
    our `aurelia-i18n` instance:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将导入的后端插件（`i18next-xhr-backend`）注册到我们的 `aurelia-i18n` 实例中：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we need to add some configuration. This is completely based on the
    `i18n` configuration documents, so you can find more information about this at [http://i18next.com/docs/options](https://www.i18next.com/configuration-options.html).
    That `promise` configuration must be returned; because of that, we are adding
    the `return` statement before the `instance.setup()` declaration:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一些配置。这完全基于 `i18n` 配置文档，所以你可以在 [http://i18next.com/docs/options](https://www.i18next.com/configuration-options.html)
    找到更多关于这方面的信息。那个 `promise` 配置必须返回；正因为如此，我们在 `instance.setup()` 声明之前添加了 `return`
    语句：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last options are used to map fallback language, default language and so
    on:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的选项用于映射后备语言、默认语言等：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are ready to start using the plugin. Good job!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始使用这个插件了。做得好！
- en: 'If your are a Webpack user, don''t forget to put the PLATFORM prefix before
    the plugin name. Example:    .plugin(PLATFORM.moduleName(''aurelia-i18n''), (instance)
    => {......});'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个 Webpack 用户，别忘了在插件名称前加上 PLATFORM 前缀。例如：  `.plugin(PLATFORM.moduleName('aurelia-i18n'),
    (instance) => {......});`
- en: Using the plugin – Multilanguage support!
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插件 – 多语言支持！
- en: 'To start using our files, you must tell your `ViewModel` components which language
    to use. We will perform this operation at constructor method; check out this example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用我们的文件，你必须告诉你的 `ViewModel` 组件使用哪种语言。我们将在构造函数方法中执行此操作；查看以下示例：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What if you want to get the active locale? Easy, change the configuration file
    to look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取活动区域设置，很简单，将配置文件修改如下：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similar to `setLocale()`, we have the `getLocale()` method. You can retrieve
    the active locale by typing the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `setLocale()` 类似，我们还有 `getLocale()` 方法。你可以通过输入以下内容来检索活动区域设置：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, on the HTML file, we just need to call our translation aliases to map
    the properties we have defined in our `translation.json` files:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 HTML 文件中，我们只需要调用我们的翻译别名来映射我们在 `translation.json` 文件中定义的属性：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Optionally, we are able to use our second alias to map values:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们能够使用我们的第二个别名来映射值：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now you are ready to start adding multiple language support for your application!
    There are so many other advanced hints to get the best results using this plugin.
    We will show you one of them up next.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好开始为你的应用程序添加多语言支持了！使用这个插件还有很多其他高级提示可以帮助你获得最佳效果。我们将在下一个示例中展示其中之一。
- en: 'Imagine that you need to map `<html>` tags in your translation files. Is that
    possible? Yes. Imagine you need to render some long test (a product description,
    for example) and need to bold just a few words like price or discount. What do
    we need to do? Very easy, just add the HTML tag you need:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你需要在你翻译文件中映射`<html>`标签。这是可能的吗？是的。想象一下，你需要渲染一些长的测试（例如产品描述），并且需要加粗一些单词，比如价格或折扣。我们需要做什么？非常简单，只需添加你需要的HTML标签：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s use this in our `View` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的`View`文件中使用它：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you look at your window, you''ll see something like `&lt;b&gt;bold&lt;/b&gt;`;
    don''t be scared, it''s normal. It''s because we didn''t set the correct markup
    to make our HTML tag correctly interpreted. You must know that there are four
    main attributes to add custom behavior to our translation file variables:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看你的窗口，你会看到类似`&lt;b&gt;bold&lt;/b&gt;`的东西，不要害怕，这是正常的。这是因为我们没有设置正确的标记来正确解释我们的HTML标签。你必须知道，有四个主要属性可以添加自定义行为到我们的翻译文件变量：
- en: '`[text]`: Default attribute, escapes the tag value as simple text'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[text]`: 默认属性，将标签值转义为纯文本'
- en: '`[html]`: Tells our translation file "Hey, this contains HTML tags, render
    it as them!"'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[html]`: 告诉我们的翻译文件“嘿，这包含HTML标签，将其渲染为它们！”'
- en: '`[append]`: Appends the translation to the current content already present
    in the element (allows HTML)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[append]`: 将翻译添加到元素中已存在的当前内容（允许HTML）'
- en: '`[prepend]`: Prepends the translation to the current content already present
    in the element (allows HTML)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[prepend]`: 将翻译添加到元素中已存在的当前内容之前（允许HTML）'
- en: 'This attribute has to be before our translation identifier key. You know what
    to do next:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性必须在我们翻译标识符键之前。你知道接下来要做什么：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Awesome? Yes, it is. It's up to you to research about other more advanced features;
    we are very sure you will enjoy all the options that `i18n` offers. That's all
    for this chapter? Of course, no. Let's keep exploring!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了？是的，确实如此。至于其他更高级的功能，我们非常确信你会喜欢`i18n`提供的所有选项。这就是这一章的全部内容吗？当然不是。让我们继续探索！
- en: Tracking method calls and user actions – Logging
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪方法调用和用户行为——日志记录
- en: As a developer, you know how important it is to know what is happening in your
    application. Some information about the user clicks, event triggers, or error
    messages, having a good logging tool by your side telling you whether your application
    is okay (or really bad) is good practice. Commonly, developers use the common
    `console.log()` statement and when it's time to deploy it to UAT or production,
    they comment all these lines.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你知道了解你的应用程序正在发生什么非常重要。一些关于用户点击、事件触发或错误消息的信息，有一个好的日志工具在你身边告诉你应用程序是否正常（或者真的很糟糕）是良好的实践。通常，开发者使用常见的`console.log()`语句，当它部署到UAT或生产环境时，他们会注释掉所有这些行。
- en: Aurelia knows how important this feature is, and guess what—yes, it has its
    own plugin for this purpose. Let's explore!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia知道这个功能有多重要，猜猜看——是的，它为此目的有自己的插件。让我们来探索一下！
- en: Configuring your log manager
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置你的日志管理器
- en: By default, Aurelia has the logging API already in their dependencies, so you
    don't need to run any `npm` command at this point. Of course, if for some reason
    that library is missing, you know how to deal with it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Aurelia已经在他们的依赖项中有了日志API，所以你在这个时候不需要运行任何`npm`命令。当然，如果由于某种原因该库缺失，你知道如何处理它。
- en: First, we need to create a file to configure our log levels. In the `resources`
    folder, create a file called `custom-log-appender.js`. This name is completely
    optional; you can name it in the most convenient way.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个文件来配置我们的日志级别。在`resources`文件夹中，创建一个名为`custom-log-appender.js`的文件。这个名字完全可选；你可以以最方便的方式命名它。
- en: 'First, let''s configure all our log levels:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们配置所有我们的日志级别：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We are almost ready. Now, open the main configuration file (`main.js`) and
    import the logging dependencies from Aurelia:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好了。现在，打开主配置文件（`main.js`）并从Aurelia导入日志依赖项：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also, import our recently created `CustomLogAppender`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，导入我们最近创建的`CustomLogAppender`：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, configure the Aurelia''s `LogManager` with your created `CustomLogAppender`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用你创建的`CustomLogAppender`配置Aurelia的`LogManager`：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Look for the `configure()` function. Just need to add one single line:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 查找`configure()`函数。只需添加一行：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that this kind of configuration will apply for all the environments (dev,
    test, prod). Commonly, logging is most used to detect error on development phase,
    so let''s add some improvement to the previous configuration:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种配置将适用于所有环境（dev、test、prod）。通常，日志记录在开发阶段最常用于检测错误，所以让我们对之前的配置做一些改进：
- en: 'First, let''s create a file called `environment.js`. This file will contain
    our current activated environments:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 `environment.js` 的文件。这个文件将包含我们的当前激活环境：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we need to import that file into our `src/main.js` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将此文件导入我们的 `src/main.js` 文件：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You are ready to start using the logger! Let''s open one `ViewModel` file and
    start recording what is happening inside:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好开始使用日志记录器了！让我们打开一个 `ViewModel` 文件，开始记录内部发生的事情：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is so easy and so useful. Of course, we have so many more special features
    to show you. Keep reading man!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单且非常有用。当然，我们还有更多特殊功能要展示给你。继续阅读吧！
- en: Modal configuration – Aurelia dialog at rescue!
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态配置 - Aurelia 对话框来拯救！
- en: Every application needs to show different kinds of information to the final
    user. Does that information need to be displayed on one page? Not necessarily.
    The final user is very familiarized with the bootstrap dialog (commonly called
    `Modal`), which is a custom JavaScript `alert()` element. More elegant and more
    friendly to add custom behavior, it could now be used only to show alerts information,
    also you can configure entire forms or confirmation dialogs. In our FIFA World
    Cup application, the `Aurelia-materialize` plugin has already configured this
    feature for the modal component, but let's explore how this works and how we can
    improve it. Let's go!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都需要向最终用户展示不同类型的信息。这些信息需要显示在单个页面上吗？不一定。最终用户非常熟悉 bootstrap 对话框（通常称为 `Modal`），这是一个自定义的
    JavaScript `alert()` 元素。它更加优雅，更易于添加自定义行为，现在它可以用来显示警报信息，你也可以配置整个表单或确认对话框。在我们的 FIFA
    世界杯应用程序中，`Aurelia-materialize` 插件已经为模态组件配置了这个功能，但让我们探索它是如何工作的以及我们如何可以改进它。让我们开始吧！
- en: Getting the Aurelia-dialog plugin
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取 Aurelia-dialog 插件
- en: 'If you are using JSPM manager, type the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 JSPM 管理器，请输入以下命令：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Else, for `Webpack` / `Aurelia CLI` users, use the known `npm install` command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，对于 `Webpack` / `Aurelia CLI` 用户，使用已知的 `npm install` 命令：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Remember to save this dependency into your `project dependencies` section. It's
    very important, because it will be used in the final application build.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将这个依赖项保存到你的 `项目依赖项` 部分。这非常重要，因为它将在最终应用程序构建中使用。
- en: 'Now, let''s tell our application that we have a new plugin. Like other plugins
    seen earlier, open your Aurelia configuration file (`aurelia.json`) and add a
    new plugin section:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们告诉我们的应用程序我们有一个新的插件。像之前看到的其他插件一样，打开你的 Aurelia 配置文件 (`aurelia.json`) 并添加一个新的插件部分：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have already configured our `index.html` file to use manual bootstrapping;
    if not, just ensure that it has the `<body>` element with the `aurelia-app="main"`
    tag inside:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了我们的 `index.html` 文件以使用手动引导；如果没有，请确保它有一个包含 `aurelia-app="main"` 标签的 `<body>`
    元素：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In your application config file (`main.js`), add a new `plugin()` entry:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序配置文件 (`main.js`) 中，添加一个新的 `plugin()` 条目：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Also, if you want to add a more customized behavior to your `modal`, you can
    implement some configuration inside this `plugin()` pipe. Optionally, you can
    configure the `aurelia-dialog` plugin as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想给你的 `modal` 添加更定制的行为，你可以在 `plugin()` 管道中实现一些配置。可选地，你可以按照以下方式配置 `aurelia-dialog`
    插件：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You are ready! Now, it's time to listen to our plugin!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好了！现在，是时候倾听我们的插件了！
- en: Adding dialog components to our application
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对话框组件添加到我们的应用程序中
- en: 'Let''s create a `UserRegister` modal for our application. This will look something
    like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的应用程序创建一个 `UserRegister` 模态。这看起来可能像这样：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is very simple by now. Remember that this component will be the modal itself.
    The modals are displayed over the main content, so now we will configure this
    behavior into our `Home` component. Pay attention to this section; it's a little
    tricky, but we are sure that you will find it easy to implement.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在非常简单。记住，这个组件将是模态本身。模态是在主要内容之上显示的，所以现在我们将配置这个行为到我们的 `Home` 组件中。注意这个部分；它有点棘手，但我们确信你会觉得实现起来很容易。
- en: 'First, let''s import `DialogService` from our recently imported `aurelia-dialog`
    plugin:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从我们最近导入的 `aurelia-dialog` 插件中导入 `DialogService`：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Also, let''s import our recently created `UserForm` component:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们导入我们最近创建的 `UserForm` 组件：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, let''s configure the dialog behavior:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置对话框行为：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In addition, the `<template>` file needs to contain one `<button>` to trigger
    the `openModal()` method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`<template>` 文件需要包含一个 `<button>` 来触发 `openModal()` 方法：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s explain the `openModal()` method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下 `openModal()` 方法：
- en: 'First, we need to open the modal. We will set some default values for our recently
    created user object. This method will return a `promise` object. Why? So simple,
    with this `promise`, we will be able to handle any event triggered inside the
    modal:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要打开模态框。我们将为最近创建的用户对象设置一些默认值。此方法将返回一个 `promise` 对象。为什么？很简单，有了这个 `promise`，我们就能处理模态框内部触发的任何事件：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Inside the `then()` statement, our `promise` will be defined in such a way:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `then()` 语句内部，我们的 `promise` 将被定义为以下方式：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, let''s look at our `<template>` file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的 `<template>` 文件：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Of course, we can customize how our modal is displayed. For example, bootstrap
    by default adds 50% opacity in the modal background. To get the same result, include
    this CSS class in an existing or new style sheet. Depending on which CSS preprocessor
    you are using, don''t forget to import it if necessary:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以自定义模态框的显示方式。例如，bootstrap 默认在模态框背景中添加 50% 的不透明度。为了得到相同的结果，将此 CSS 类包含在现有的或新的样式表中。根据你使用的
    CSS 预处理器，如果需要，不要忘记导入：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Remember that we are overwriting an existing class from Aurelia dialog, so you
    don't need to specify this class in the `<html>` component.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们正在覆盖来自 Aurelia 对话的现有类，所以你不需要在 `<html>` 组件中指定此类。
- en: Now, you are ready to add a more user-friendly behavior to your application
    with the use of dynamic dialogs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好使用动态对话框为你的应用程序添加更友好的行为。
- en: Dynamic value converters – Less code, more functionality
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态值转换器 - 更少的代码，更多的功能
- en: As we said at the beginning of this chapter, our application should be available
    for all the users worldwide. You are completely free to model the application
    according to your own purposes. Maybe you want to implement premium features that
    would need you to pay to access them, so you will need to express the cost in
    the user currency. Another good thing could be to have a custom formatted date,
    or simply add some number conversion, decimal rounds, and so on.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所说的，我们的应用程序应该对全球所有用户都可用。你可以完全自由地根据你自己的目的来建模应用程序。也许你想实现需要付费才能访问的付费功能，因此你需要用用户的货币来表示成本。另一件好事是有一个自定义格式的日期，或者简单地添加一些数字转换、小数四舍五入等等。
- en: You already know how to bind and interpolate values between Aurelia `View` and
    `ViewModel` components. Now we will see how to improve that data binding. Come
    on!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何将 Aurelia `View` 和 `ViewModel` 组件之间的值绑定和插值。现在我们将看到如何改进数据绑定。加油！
- en: The problem – Data is not exposed as we need
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 - 数据没有按照我们的需求暴露
- en: One of the common problems we could have is the date formatting. In other code
    languages such as Java, you have a utility class like `SimpleDateFormat`, which
    converts the `Date()` object to a more friendly human reading format. In JavaScript,
    we have some libraries to do that job, but they are not so simple to call. Let's
    see an example.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遇到的一个常见问题是日期格式化。在其他代码语言，如 Java 中，你有一个像 `SimpleDateFormat` 这样的实用工具类，它将 `Date()`
    对象转换为更友好的可读格式。在 JavaScript 中，我们有几个库来做这个工作，但它们并不容易调用。让我们看一个例子。
- en: 'You get the current date in your `ViewModel` component; then, you pass that
    value to the `View` layer:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 `ViewModel` 组件中获取当前日期；然后，你将这个值传递到 `View` 层：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In our `View` file, we map the `currentDate` value to be displayed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `View` 文件中，我们将 `currentDate` 的值映射为要显示的内容：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When you run the example, you will be displayed in your screen the following
    output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行示例时，你将在屏幕上看到以下输出：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Okay, we can do better; it''s time to call our value-converters, but exactly,
    what is a value converter? The Aurelia documents explain it really good:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们可以做得更好；现在是时候调用我们的值转换器了，但究竟什么是值转换器？Aurelia 文档解释得很好：
- en: '"A value converter is a class whose responsibility is to convert view-model
    values into values that are appropriate to display in the view and vice versa."'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '"值转换器是一个类，其责任是将视图模型值转换为适合在视图中显示的值，反之亦然。"'
- en: That being said, let's create one value-converter file just for example purposes.
    Since we are working with a `Date()` value, we will work with the `moment` plugin.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们为了示例目的创建一个值转换器文件。由于我们正在处理 `Date()` 值，我们将使用 `moment` 插件。
- en: 'If you don''t have it in your dependencies tree, just import it from `npm`
    repositories:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在依赖树中找到它，只需从 `npm` 存储库导入它：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, first of all, import this library in our value-converter file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，首先，在我们的值转换器文件中导入这个库：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Okay, now let''s explain how this works:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们解释一下它是如何工作的：
- en: You know that Aurelia is a convention over configuration-based framework. With
    that being said, if you name this class terminating it `ValueConverter`, the framework
    will use this class as a custom value converter without any more configuration.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道Aurelia是一个基于约定的配置框架。换句话说，如果你以`ValueConverter`结尾命名这个类，框架将使用这个类作为自定义值转换器，而无需任何更多配置。
- en: The `toView()` method is inherited from the Aurelia `ValueConverter` interface.
    It defines the data flow direction, if it comes to `ViewModel` to `View`, or vice
    versa, you have the `fromView()` method.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toView()`方法是从Aurelia的`ValueConverter`接口继承的。它定义了数据流向的方向，如果是从`ViewModel`到`View`，或者相反，你有`fromView()`方法。'
- en: Those value-converter methods could receive more than one parameter.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些值转换方法可以接收多个参数。
- en: 'Now, we just need to import this value-converter in our `View` file like any
    other dependency, using the `<require>` tag:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要像导入其他依赖项一样在我们的`View`文件中导入这个值转换器，使用`<require>`标签：
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we need to add the converter to our binding syntax:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将转换器添加到我们的绑定语法中：
- en: '[PRE59]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, refresh your browser window:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，刷新你的浏览器窗口：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'So much better, right? Well, this same dynamic can be applied to number format
    converters, currency, and so on. Let''s make the example a little more advanced—what
    if we need to show multiple date formats across our entire application? Should
    we define a value-converter file per format we need? It''s a valid option, but
    not the most effective. Do you remember when we said that value-converter interface
    methods can receive more than one parameter? Well, what if we send the date format
    as parameter too? Let''s try to see what happens:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了，对吧？嗯，同样的动态也可以应用到数字格式转换器、货币等。让我们使例子更复杂一些——如果我们需要在整个应用程序中显示多种日期格式怎么办？我们应该为每个需要的格式定义一个值转换器文件吗？这是一个有效的选项，但不是最有效的方法。你还记得我们说过值转换器接口方法可以接收多个参数吗？那么，如果我们把日期格式也作为参数发送会怎样呢？让我们尝试看看会发生什么：
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can specify a default format in case no one was provided: `toView(value,
    format = ''M/D/YYYY''){ ... }`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供，你可以指定一个默认格式：`toView(value, format = 'M/D/YYYY'){ ... }`
- en: Nice, our formatter now accepts the `format` pattern as a parameter. It's not
    the magic of Aurelia; it's because we are using `moment.js` a nice JavaScript
    library, which allows us to perform this kind of operations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们的格式化器现在接受`format`模式作为参数。这不是Aurelia的魔法；这是因为我们正在使用一个很好的JavaScript库`moment.js`，它允许我们执行这类操作。
- en: 'Now, in our `View` file, we can add as many time formats as we need:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`View`文件中，我们可以添加我们需要的任何时间格式：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, look at your browser window:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看你的浏览器窗口：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: That was very nice. Now it's time to take a look at a little more complicated
    example but with a more common usage—arrays order.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好。现在，让我们看看一个更复杂但更常见用法的例子——数组排序。
- en: 'You know how to retrieve data from one backend service; often this data is
    retrieved as an `array` object and shown as a list in the `View` file. That''s
    all okay, but what if we need to order these values according to some property?
    Look at the code example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何从一个后端服务检索数据；通常，这些数据作为`array`对象检索，并在`View`文件中显示为列表。这都很好，但如果我们需要根据某些属性对这些值进行排序怎么办？看看代码示例：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: What are we doing? Let's explain.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在做什么？让我们来解释一下。
- en: 'We are receiving two parameters, one array, and one config property. The config
    property is an object with two values: `config.direction`, which can be one of
    these two options: ascending or any other string. Depending on that, the sorter
    can order the list incrementing values `1`, or decreasing with `-1` in descending
    order. Then, in the return statement, we are using the sort function of the array
    itself, and we are sending as parameter the anonymous function to compare the
    mapped `config.propertyName` values in the config object.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接收两个参数，一个是数组，另一个是配置属性。配置属性是一个包含两个值的对象：`config.direction`，它可以取这两个选项之一：升序或任何其他字符串。根据这个，排序器可以按递增的值`1`或按递减的`-1`进行降序排序。然后，在返回语句中，我们使用数组本身的排序函数，并将匿名函数作为参数发送，用于比较配置对象中映射的`config.propertyName`值。
- en: 'This is how we are retrieving the data from some backend service:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从某些后端服务检索数据的方式：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'There''s nothing weird at this point. Now, let''s check the `View` file:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有什么奇怪的地方。现在，让我们检查一下`View`文件：
- en: '[PRE66]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It's beautiful. We don't need to add any JavaScript function or weird configuration
    to start using this very useful functionality.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这很美。我们不需要添加任何JavaScript函数或奇怪的配置来开始使用这个非常有用的功能。
- en: Binding custom behaviors to our application
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义行为绑定到我们的应用程序
- en: Let's continue with our Aurelia special features exploration. In the last section,
    we saw value-converters, and it's impossible to not make a relationship between
    this feature and the binding engine of Aurelia framework. Maybe you think that
    both features have much in common, well, not so much really. Let's start explaining
    how the binding engine works.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索Aurelia的特殊功能。在上一个部分中，我们看到了值转换器，并且很难不将这个功能与Aurelia框架的绑定引擎联系起来。也许你认为这两个功能有很多共同之处，好吧，实际上并不是很多。让我们开始解释绑定引擎是如何工作的。
- en: 'The view resources in Aurelia framework can be divided into four categories:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia框架中的视图资源可以分为四个类别：
- en: Value converters
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值转换器
- en: Custom attributes
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义属性
- en: Custom elements
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义元素
- en: Binding behaviors
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定行为
- en: We will focus only on the last one. It's not because the others are less important
    but because it will be better for us to understand how this works first and then
    explore the other categories. Don't worry, value-converters are already covered,
    and you will have a clearer idea about the difference between both features.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只关注最后一个。这并不是因为其他的不重要，而是因为我们首先了解它是如何工作的，然后再探索其他类别会更好。不用担心，值转换器已经涵盖了，你将对这两个功能之间的区别有一个更清晰的认识。
- en: The value-converter acts just as a bridge interceptor between `View` and `ViewModel`
    (or vice versa). The binding behavior goes beyond—it has full access to the binding
    instance across the complete component life-cycle. This allows us to make changes
    in the binding behavior, such as modifying the binding throttle time, or adding
    customization to how the values are updated.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器在`View`和`ViewModel`（或反之）之间充当着桥梁拦截器的角色。绑定行为超越了这一点——它在整个组件生命周期中完全访问绑定实例。这使得我们可以修改绑定行为，例如修改绑定节流时间，或者添加对值更新的自定义。
- en: 'Remember that Aurelia is a two-way binding framework, so you don''t need to
    worry about the data synchronization between `View` and `ViewModel`. How is this
    performed? Aurelia has a predefined throttle mechanism that updates values each
    200 ms, by default. Could it be updated? Yes, Aurelia left us free to manage this
    value according to our needs. Similar to the `value-converters` syntax, we need
    to call the binding behavior in the `<template>` file, where we need it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Aurelia是一个双向绑定框架，所以你不需要担心`View`和`ViewModel`之间的数据同步。这是如何完成的？Aurelia有一个预定义的节流机制，默认情况下每200毫秒更新一次值。可以更新吗？是的，Aurelia让我们可以自由地根据我们的需求管理这个值。类似于`value-converters`的语法，我们需要在需要的地方调用绑定行为，即在`<template>`文件中：
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Did you note the `&` symbol? It''s the first difference with the already covered
    value-converters. When we need to define a binding behavior, we tell this to the
    framework using the `&` wildcard. Another thing you must note is that we can send
    parameters to the binding behaviors. Just need to add the `:` symbol after the
    behavior declaration and send the value. Its possible to send multiple params?
    Yes. How? Look at the example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到`&`符号了吗？这是与已涵盖的值转换器的第一个区别。当我们需要定义一个绑定行为时，我们使用`&`通配符告诉框架。还有一点你必须注意，我们可以向绑定行为发送参数。只需在行为声明后添加`:`符号并发送值即可。是否可以发送多个参数？是的。如何？看看例子：
- en: '[PRE68]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Also, you are allowed to declare more than one behavior in one element:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以在一个元素中声明多个行为：
- en: '[PRE69]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the same way, you can define the updating time period between `View` and
    `ViewModel`; you have another interesting binding behavior called **debounce**.
    We can refer to this behavior in the same category of *throttle*, but the difference
    is that instead of calculating updating time, it prevents the binding from being
    updated until a specified interval has passed without any changes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以在`View`和`ViewModel`之间定义更新时间间隔；你还有一个有趣的绑定行为称为**防抖**。我们可以将这个行为与*节流*放在同一类别中，但区别在于它不是计算更新时间，而是在指定的时间间隔内没有变化时，防止绑定更新。
- en: Maybe you will find this feature more useful; let's explain it through a real
    use case.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得这个功能更有用；让我们通过一个实际用例来解释它。
- en: In our FIFA World Cup application, one of the most demanded features could be
    a search input, more specifically, an autocomplete. You already know that autocomplete
    component should retrieve data according to the users' input value. The big question
    when you develop this feature is "when should we trigger the `searchByKey()` method
    of the autocomplete? On every keypress? When the input length is greater than
    `2` or `3`?". Really, this is a hard question; your application performance is
    directly compromised.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的FIFA世界杯应用程序中，最被需求的功能之一可能是一个搜索输入，更具体地说，是一个自动完成。你已经知道自动完成组件应该根据用户的输入值检索数据。当你开发这个功能时，最大的问题是“我们应该在何时触发自动完成的`searchByKey()`方法？在每次按键时？当输入长度大于`2`或`3`时？”。真的，这是一个难题；你的应用性能直接受到影响。
- en: 'This is a good moment to think about *debounce*. Instead of triggering the
    `searchByKey()` method each time the user enters a value, trigger it some time
    after the user enters their search key:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是思考*防抖*的好时机。与其每次用户输入值时都触发`searchByKey()`方法，不如在用户输入搜索键后的一段时间内触发它：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Other really useful binding behavior you can use is `oneTime`. By default,
    Aurelia set the preconfigured two-way binding to each `ViewModel` property. The
    big question is "do we really need this two-way binding activated for each property
    in our components?". Most of the time, the answer is no. Here''s where `oneTime`
    comes and becomes our performance optimization partner. Really, it has a direct
    impact on application performance? Yes. To enable double binding, Aurelia needs
    to implement multiple observers looking for any changes in your component properties.
    With `oneTime`, we just tell the app—map this property to my view and forget it:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用其他非常有用的绑定行为，比如`oneTime`。默认情况下，Aurelia将预配置的双向绑定设置到每个`ViewModel`属性上。最大的问题是“我们是否真的需要在组件的每个属性上激活双向绑定？”大多数情况下，答案是“不”。这就是`oneTime`出现并成为我们的性能优化伙伴的地方。真的，它对应用性能有直接影响吗？是的。为了启用双重绑定，Aurelia需要实现多个观察者来寻找组件属性中的任何变化。使用`oneTime`，我们只需告诉应用——将这个属性映射到我的视图并忘记它：
- en: '[PRE71]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Of course, there are many more predefined binding behaviors to explore, but
    if you remember, we used one binding behavior defined as `customBehavior` in our
    first example. Did you note that? Guess what, Aurelia allows you to define your
    own binding behavior, and now it's time to learn how.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多更多的预定义绑定行为可以探索，但如果你记得，我们在第一个例子中使用了定义为`customBehavior`的一个绑定行为。你注意到这一点了吗？猜猜看，Aurelia允许你定义自己的绑定行为，现在是时候学习了。
- en: 'Similar to custom value-converters, you can create custom binding behaviors.
    Check the following example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义值转换器类似，你可以创建自定义绑定行为。查看以下示例：
- en: '[PRE72]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Like the last examples, let's explain what the code is doing.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 就像最后的例子一样，让我们解释一下代码在做什么。
- en: 'First, you must know that similar to the `toView()` and `fromView()` methods
    from value-converters, custom binding behaviors need to implement two methods:
    `bind(binding, src, expressions...)` and `unbind(binding, src)`.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须知道，与值转换器中的`toView()`和`fromView()`方法类似，自定义绑定行为需要实现两个方法：`bind(binding, src,
    expressions...)`和`unbind(binding, src)`。
- en: On the `bind()` method, we are manipulating the user input value passed as a
    parameter. Something you must know is that on the `bind()` method, the first two
    parameters are sent by Aurelia. The other params can be one or more custom parameters;
    in this case, `rawExpresions`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bind()`方法中，我们正在操作作为参数传递的用户输入值。你必须知道的是，在`bind()`方法中，前两个参数是由Aurelia发送的。其他参数可以是一个或多个自定义参数；在这种情况下，`rawExpresions`。
- en: The `unbind()` method just ensures that our binding behavior returns to normal
    when our data processing ends.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`unbind()`方法只是确保当我们的数据处理结束时，我们的绑定行为返回到正常状态。'
- en: Looks simple? Yes, the example looks easy, but a real implementation will be
    harder to understand. Don't worry, the predefined set of binding behavior commonly provided
    by Aurelia framework is enough for every application's purposes.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单？是的，例子看起来很简单，但实际实现会更难理解。别担心，Aurelia框架通常提供的预定义绑定行为集合对于每个应用程序的目的来说已经足够了。
- en: Improving our application forms – Validators
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高我们的应用程序表单 – 验证器
- en: 'We know how the binding engine of Aurelia works. Also, we know how to intercept
    and customize that binding behavior. We know too how to transform data between
    `View`-`ViewModel` layer according to our needs. Just some things are pending,
    and the `aurelia-validation` plugin is one of them. When you need data provided
    by the user, you have to expect anything. The user didn''t know your app. He will
    do anything he wants, and you need to be prepared for that. You need to ensure
    that data provided by the user is, at least, in the right format your back service
    is expecting. You need to filter just the right values and send alerts to the
    user telling which values are wrong and how they can fix it. We often need to
    put ourselves on the user''s side. Software development is more than just programming,
    more than just creating forms and storing/retrieving data. We need to make our
    application fault-tolerant and as we said earlier, think always in the worst case.
    Just imagine something like this—you are developing an application that needs
    to perform some calculations. You have three inputs: `a`, `b`, and `c`; you need
    to calculate the sum. Well, that sounds easy, right? We have two users who type
    the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Aurelia的绑定引擎是如何工作的。我们也知道如何拦截和自定义绑定行为。我们还知道如何根据我们的需求在`View`-`ViewModel`层之间转换数据。只是还有一些事情悬而未决，`aurelia-validation`插件就是其中之一。当你需要用户提供的数据时，你必须预期任何情况。用户不了解你的应用。他会做任何他想做的事情，你需要为此做好准备。你需要确保用户提供的数据至少是后端服务期望的正确格式。你需要过滤正确的值，并向用户发送警报，告诉他们哪些值是错误的以及如何修复它们。我们经常需要站在用户的角度思考。软件开发不仅仅是编程，不仅仅是创建表单和存储/检索数据。我们需要使我们的应用具有容错性，就像我们之前说的那样，总是考虑最坏的情况。只需想象一下——你正在开发一个需要执行某些计算的应用。你有三个输入：`a`、`b`和`c`；你需要计算总和。听起来很简单，对吧？我们有两个用户输入了以下内容：
- en: '[PRE73]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You press the Submit button and get the correct sum—`88`. Fine, the application
    accomplished their purpose. Let''s see what second user puts:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你按下提交按钮，得到正确的总和——`88`。很好，应用完成了它的目的。让我们看看第二个用户会输入什么：
- en: '[PRE74]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As you can see, the last user presses by error the `j` character. Will it rely
    on an application error? No. Our operation will be performed, JavaScript is not
    a typed language, so it will operate in the following way:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，最后一个用户错误地按下了`j`字符。它会依赖于应用错误吗？不。我们的操作将会执行，JavaScript不是一种强类型语言，所以它会以以下方式操作：
- en: '[PRE75]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The user will see that value, and we are sure they will never use your application
    again.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将看到这个值，我们确信他们永远不会再次使用你的应用。
- en: Preparing for war – Getting the validation plugin
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备战斗——获取验证插件
- en: 'Like other plugins we could have installed, the installation and configuration
    steps are very similar. If this is the first time you are performing this operation,
    just carry out the following steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可能安装的其他插件一样，安装和配置步骤非常相似。如果你是第一次执行此操作，只需执行以下步骤：
- en: 'If you are using NPM as package manager, use this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用NPM作为包管理器，使用以下方法：
- en: '[PRE76]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Alternatively, if you are a JSPM user, use this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你是JSPM用户，使用以下方法：
- en: '[PRE77]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, open your `main.js` file where we had configured our application plugins.
    In the `configure()` function, add the new plugin:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开我们配置应用插件的`main.js`文件。在`configure()`函数中，添加新的插件：
- en: '[PRE78]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Finally, open your `aurelia.json` file and add the following plugin declaration:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开你的`aurelia.json`文件并添加以下插件声明：
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We are ready. Let's go!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好了。让我们开始吧！
- en: First steps – Defining our rules
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一步——定义我们的规则
- en: 'The Aurelia validation plugin is based on standard rules. We need to define
    our own set of rules using the `ValidationRules` class. This class has some static
    methods that receive our values and verify that the input value meet our requirements.
    Also, one validation rule must have one predefined format. The first method we
    will explain is `ensure()`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia验证插件基于标准规则。我们需要使用`ValidationRules`类定义我们自己的规则集。这个类有一些静态方法，接收我们的值并验证输入值是否符合我们的要求。此外，一个验证规则必须有一个预定义的格式。我们将解释的第一个方法是`ensure()`：
- en: '[PRE80]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This method accepts one argument that will be our property name that we want
    to validate. Also, in case you were validating an object, you are allowed to pass
    anonymous functions as a parameter:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个参数，即我们想要验证的属性名。此外，如果你正在验证一个对象，你可以传递匿名函数作为参数：
- en: '[PRE81]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The second method we will explain is `displayName()`. This is not required
    but is useful if you need to show this property in one predefined format in your
    validation messages; consider this example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解释的第二种方法是 `displayName()`。这不是必需的，但如果需要在验证信息中以一种预定义的格式显示此属性，则很有用；考虑以下示例：
- en: '[PRE82]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, we need to define our set of rules that will apply to that field;
    some of the most used are as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义将应用于该字段的规则集；以下是一些最常用的规则：
- en: '`required()` prevents the user from submitting null or blank values'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required()` 阻止用户提交空或空白值'
- en: '`matches(regex)` helps us ensure that the input value meets a predefined format,
    and is common on date fields'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matches(regex)` 帮助我们确保输入值符合预定义的格式，这在日期字段中很常见'
- en: '`email()` is an easy way to ensure that the email is in the right format'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email()` 是确保电子邮件格式正确的一种简单方法'
- en: '`minLength(length)` and `maxLength(length)` validate the length of string properties'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minLength(length)` 和 `maxLength(length)` 验证字符串属性的长度'
- en: 'If our user''s first name should never be null, the validation rule will be
    this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的用户名不能为空，验证规则将是这样的：
- en: '[PRE83]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Did you note something different? Yes, we are using the `withMessage()` method
    to customize our validation error message. The thing becomes more interesting.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到有什么不同吗？是的，我们正在使用 `withMessage()` 方法来自定义我们的验证错误信息。事情变得更有趣了。
- en: 'What if you need these validation rules to apply just for one object? Don''t
    worry, Aurelia has the problem solved. You need to tag the object you want to
    apply the rule on; the example is self-explanatory:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要这些验证规则仅适用于一个对象，请不要担心，Aurelia 已经解决了这个问题。您需要标记您想要应用规则的对象；示例是自解释的：
- en: '[PRE84]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We are almost ready. Now, we need to configure our form controller with the
    recently created validation rules:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好了。现在，我们需要使用最近创建的验证规则来配置我们的表单控制器：
- en: '[PRE85]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Maybe you are wondering why we need this `NewInstance.of()` statement? Well,
    for each validation rule we are applying, we need a single controller to validate
    it. So, with this statement, we just ensure that a new `ValidationController`
    instance is created.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们需要这个 `NewInstance.of()` 语句？嗯，对于每个我们应用的验证规则，我们需要一个单独的控制器来验证它。所以，通过这个语句，我们只是确保创建了一个新的
    `ValidationController` 实例。
- en: 'Now let''s explain what is occurring inside our constructor method:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解释一下构造函数方法内部发生的事情：
- en: 'Line 1: We are creating a new instance of the `User` object to use his properties
    in our form.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1行：我们正在创建一个新的 `User` 对象实例，以便在我们的表单中使用其属性。
- en: 'Line 2: We are assigning the new `ValidatorController` instance into our `formValidator`
    object.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2行：我们将新的 `ValidatorController` 实例分配给我们的 `formValidator` 对象。
- en: 'Line 3: We are saying to our `formValidator` that the evaluated object is our
    user instance, and will use the imported `UserRules`.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3行：我们告诉 `formValidator`，评估的对象是我们的用户实例，并将使用导入的 `UserRules`。
- en: 'Other way to configure our `formValidator` is defining the properties and rules
    inside the `validate()` method:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 配置我们的 `formValidator` 的另一种方法是定义 `validate()` 方法内部的属性和规则：
- en: '[PRE86]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In our `submit()` method, we just need to add the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `submit()` 方法中，我们只需要添加以下内容：
- en: '[PRE87]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Lastly, we need to tell our template where the validators will be placed:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要告诉我们的模板验证器将被放置在哪里：
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The first value will be passed as a parameter to the `ensure()` function. Hey,
    wait a second! We need to specify where our error messages will be placed! Well,
    that''s really simple, we would implement an error list like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值将被传递给 `ensure()` 函数作为参数。嘿，等一下！我们需要指定错误信息将放置的位置！嗯，这真的很简单，我们会实现一个错误列表如下：
- en: '[PRE90]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Alternatively, if you want to display the message beside the wrong `input`
    element, you can use the `<span>` tag and other very interesting custom attribute:
    `validation-errors`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想在错误的 `input` 元素旁边显示消息，您可以使用 `<span>` 标签和其他非常有趣的自定义属性：`validation-errors`
- en: '[PRE91]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `validation-errors` attribute contains all validation errors regarding to
    the specified element (in this case `firstNameErrors`).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`validation-errors` 属性包含有关指定元素（在这种情况下为 `firstNameErrors`）的所有验证错误。'
- en: Now, start putting validation rules across your application forms! See you in
    the next section!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始在您的应用程序表单中添加验证规则吧！下一节见！
- en: Manipulating the DOM – Custom attributes
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作 DOM – 自定义属性
- en: We are almost done with the most used advanced features of Aurelia. Now, it's
    time to explore other categories belonging to binding engine plugins—what exactly are
    custom attributes? Let's explain that in a very easy way—you know the `HTML` tags,
    such as `<div>`, `<input>`, and `<span>`. Also, you know that each element has
    attributes such as `class`, `type`, and `style`. Well, now we can add more attributes
    to make the element more customizable and add a more advanced behavior. Let's
    look at an example.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了 Aurelia 最常用的高级功能。现在，是时候探索属于绑定引擎插件的其它类别了——自定义属性究竟是什么？让我们用一种非常简单的方式来解释——你知道
    `HTML` 标签，例如 `<div>`、`<input>` 和 `<span>`。你也知道每个元素都有属性，如 `class`、`type` 和 `style`。现在，我们可以添加更多属性来使元素更可定制，并添加更高级的行为。让我们看一个例子。
- en: 'We had also seen the value-converters, but don''t you think it would be awesome
    if we implement a custom attribute to perform this operation on any element? Consider
    something like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了值转换器，但你难道不认为如果我们为任何元素实现一个自定义属性来执行这个操作会非常酷吗？考虑一下这个：
- en: '[PRE92]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Also, `match.date` will be a simple `Date()` JavaScript object without any format.
    Why do we need to accomplish this? Pay attention, we are sure that at this point,
    knowing the basic binding concepts, you will find it very easy.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`match.date` 将是一个简单的 `Date()` JavaScript 对象，没有任何格式。为什么我们需要完成这个？请注意，我们确信，到这一点，了解基本的绑定概念，你会发现它非常容易。
- en: 'First, create a class to configure your `customAttribute`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个类来配置你的 `customAttribute`：
- en: '[PRE93]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: What is `Element` doing? That's simple—it helps us point to the right element
    we want to apply the custom attribute to. Next, we just need to call our file
    into the template we need.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`Element` 正在做什么？很简单——它帮助我们指向我们想要应用自定义属性的正确元素。接下来，我们只需要将我们的文件调用到所需的模板中。'
- en: 'Another very interesting way to define your custom attribute is using the already
    known convention over configuration feature:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义属性的另一种非常有趣的方法是使用已知的约定优于配置功能：
- en: '[PRE94]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, in our `View` file:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `View` 文件中：
- en: '[PRE95]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: What if we need this custom attribute available for all my application components?
    Well, we have a very good news—you can configure it as a global resource into
    your application configuration file (`main.js`).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要这个自定义属性对所有我的应用程序组件都可用怎么办？好消息是——你可以在应用程序配置文件（`main.js`）中将它配置为全局资源。
- en: 'Identify the `configure` method and add a global resource pointing to our recently
    created custom attribute:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 识别 `configure` 方法并添加一个指向我们最近创建的自定义属性的全局资源：
- en: '[PRE96]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: At this time, you must find all these features very easy to learn, and this
    is because you know more advanced features that helped us understand how the framework
    works. See you in the last section!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你必须觉得这些功能非常容易学习，这是因为你了解更多帮助理解框架工作原理的高级功能。最后一节再见！
- en: Understanding how computed properties work
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解计算属性的工作原理
- en: Welcome to the last section of this chapter! You can consider yourself a full
    stack programmer with strong knowledge on frontend technologies. If you note,
    the concepts that Aurelia uses to implement the different features are based on
    common problems that every web application needs to deal with, no matter which
    framework it is using. Also, as open source tools, the different plugins are based
    on other tools that actually give support to other framework plugins, such as
    Angular.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本章的最后一节！你可以认为自己是一个具有强大前端技术知识的全栈程序员。如果你注意到，Aurelia 用于实现不同功能的理念是基于每个网络应用都需要处理的常见问题，无论它使用的是哪个框架。此外，作为开源工具，不同的插件基于其他工具，这些工具实际上支持其他框架插件，如
    Angular。
- en: 'Now, the last feature that we will explain is about computed properties. We
    can resume it in a single line:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解释的最后一个特性是关于计算属性。我们可以用一句话来总结它：
- en: Computed properties are those that are preprocessed on the `ViewModel` layer
    in a JavaScript function.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性是在 `ViewModel` 层通过 JavaScript 函数预先处理的属性。
- en: Let's see a very simple practical use—you are developing a page that shows the
    `${firstName}` and `${lastName}` as a single value—`${completeName}`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的实际应用——你正在开发一个页面，该页面将 `${firstName}` 和 `${lastName}` 作为单个值——`${completeName}`
    显示。
- en: A common solution should create a JavaScript function to concatenate both values
    and map it into a `ViewModel` property. This is valid, but Aurelia comes with
    a better solution—the `aurelia-computed` plugin. This improves the efficiency
    of data-binding computed properties.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的解决方案是创建一个 JavaScript 函数来连接这两个值并将其映射到 `ViewModel` 属性。这是有效的，但 Aurelia 提供了一个更好的解决方案——`aurelia-computed`
    插件。这个插件提高了数据绑定计算属性的性能。
- en: Do you remember the `getter`/`setter` function we mentioned in the first chapter?
    Well, it's time to use them.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在第一章中提到的`getter`/`setter`函数吗？现在是时候使用它们了。
- en: This plugin uses Aurelia's JavaScript parser to parse the body of the property's
    getter function and check the result for observability purposes. If the getter
    function is observable, a specialized observer is returned to Aurelia's binding
    system. The observer publishes change events when properties accessed by the getter
    function change.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件使用Aurelia的JavaScript解析器来解析属性的getter函数体，并检查结果以进行可观察性检查。如果getter函数是可观察的，则返回一个专门的观察者给Aurelia的绑定系统。当getter函数访问的属性发生变化时，观察者会发布更改事件。
- en: 'Let''s look at an example:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE97]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: There's nothing special yet. This function is using `dirty-checking` to bind
    the `completeName` computed property.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有什么特别之处。这个函数正在使用`dirty-checking`来绑定`completeName`计算属性。
- en: 'Why dirty? It''s because the observer strategy wont be waiting for any change
    performed in the two values needed to retrieve the `completeName` property. It
    means the getter function will be executed many times across your component life
    cycle. Should we consider it as an issue? Really no, but if your application is
    becoming bigger and you have many computed properties, your performance could
    be directly impacted. So, what''s Aurelia''s solution? Just one annotation—`@computedFrom`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是脏的？这是因为观察者策略不会等待用于检索`completeName`属性的两个值所做的任何更改。这意味着getter函数将在你的组件生命周期中多次执行。我们应该将其视为一个问题吗？实际上不是，但如果你的应用程序变得更大，并且你有许多计算属性，你的性能可能会直接受到影响。那么，Aurelia的解决方案是什么？只是一个注解——`@computedFrom`：
- en: '[PRE98]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Aurelia's binding system will observe the specified properties and reevaluate
    bindings when any of the properties change. The `aurelia-computed` plugin simply
    automates the dependency identification and is able to support more complex scenarios
    such as observing property paths.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia的绑定系统会观察指定的属性，并在任何属性发生变化时重新评估绑定。`aurelia-computed`插件简单地自动化依赖识别，并且能够支持更复杂的场景，例如观察属性路径。
- en: 'Another common use for this feature is to retrieve the current logged user
    data. We can define a Boolean property to tell our component whether the user
    is logged in or not, and based on this, show the real username or just `Visitor`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能的另一个常见用途是检索当前登录用户的数据。我们可以定义一个布尔属性来告诉我们组件用户是否已登录，并根据此信息显示真实用户名或只是`访客`：
- en: '[PRE99]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Definitely this was a very extensive chapter. We recommend to have a second
    read in the topics you consider more important, also as be said before, remember
    that if you want a complete understanding of each feature explained, you must
    research and do proof of concept to get the best option and experience. Due to
    the nature of our application, the FIFA World Cup is a worldwide event, so you
    need to make it available for all countries, `i18n` help us a lot to deal with
    internationalization with a very easy implementation. If you need to share properties
    or trigger events between your components, `EventAggregator` is the best choice.
    Aurelia offers a very usable variety of binding behaviors, making your code more
    clean, understandable and maintainable. Value converters, validators, computed
    properties are just a few binding behaviors that allows developer to reduce code.
    Remember that many of these features have dependence on third party libraries,
    so don't forget to download them and configure it into your project bundle.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一章非常广泛的章节。我们建议对认为更重要的主题进行第二次阅读，正如之前所说，记住如果你想对每个解释的功能有一个完整的理解，你必须进行研究并做概念验证，以获得最佳选项和体验。由于我们应用程序的性质，FIFA世界杯是一个全球性事件，因此你需要使其对所有国家都可用，`i18n`帮助我们非常容易地处理国际化。如果你需要在组件之间共享属性或触发事件，`EventAggregator`是最佳选择。Aurelia提供了一系列非常实用的绑定行为，使你的代码更加整洁、易于理解和维护。值转换器、验证器、计算属性只是允许开发者减少代码的几个绑定行为。记住，许多这些功能依赖于第三方库，所以不要忘记下载它们并将它们配置到你的项目包中。
- en: We are really sure that this chapter was the most interesting...until this moment!
    See you in the next chapter!
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的确信这一章是最有趣的...直到现在！下一章见！
