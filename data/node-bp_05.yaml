- en: Chapter 5. Creating a To-do Application with Backbone.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：使用 Backbone.js 创建待办事项应用程序
- en: In the previous chapters, we learned how to create real-time chat with Socket.IO.
    We made a blog application with AngularJS and used Express to create a simple
    website. This chapter is dedicated to another popular framework—Backbone.js. Backbone.js
    is one of the first JavaScript frameworks that gained popularity. There are models
    that deal with the data, views that control the logic and the user interface,
    and the built-in router that handles the changes in the browser's address. The
    framework plays really well with jQuery, which makes it attractive to almost every
    JavaScript developer. In this chapter, we are going to build a simple application
    for storing short tasks. At the end, we will be able to create, edit, delete tasks,
    and mark them as finished.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用 Socket.IO 创建实时聊天。我们使用 AngularJS 制作了一个博客应用程序，并使用 Express 创建了一个简单的网站。本章专门介绍另一个流行的框架——Backbone.js。Backbone.js
    是最早获得广泛认可的 JavaScript 框架之一。它有处理数据的模型、控制逻辑和用户界面的视图，以及处理浏览器地址变化的自带路由器。该框架与 jQuery
    非常兼容，这使得它对几乎每一位 JavaScript 开发者都具有吸引力。在本章中，我们将构建一个简单的应用程序来存储短任务。最后，我们将能够创建、编辑、删除任务，并将它们标记为完成。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basics of Backbone.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Backbone.js 的基础知识
- en: Writing the Node.js code that manages the to-do lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写管理待办事项列表的 Node.js 代码
- en: Coding the frontend using Backbone.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Backbone.js 编写前端代码
- en: Exploring the Backbone.js framework
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Backbone.js 框架
- en: Before starting with the example's application, we should check out the main
    features of the framework. Sometimes, it's good to know what is going on under
    the hood. So, let's dive in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始示例应用程序之前，我们应该检查框架的主要功能。有时候，了解底层发生了什么是有好处的。所以，让我们深入探讨。
- en: Recognizing the framework dependency
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别框架依赖项
- en: Most of the software that we use nowadays is built on top of other libraries
    or tools. Normally, they are called **dependencies**. Backbone.js has only one
    hard dependency—that's Underscore.js, which is a library full of utility functions.
    There are functions such as `forEach`, `map`, or `union` for arrays. We can extend
    an object and retrieve its keys or values. All these are functionalities we need
    sometimes, but they are missing in the built-in JavaScript objects. So, we should
    include the library in our page. Otherwise, Backbone.js will throw an error because
    of the missing functionalities.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用的绝大多数软件都是建立在其他库或工具之上的。通常，它们被称为**依赖项**。Backbone.js 只有一个硬依赖项——那就是 Underscore.js，这是一个充满实用函数的库。例如，有
    `forEach`、`map` 或 `union` 等数组函数。我们可以扩展一个对象并检索其键或值。所有这些都是在某些时候需要的功能，但它们在内置的 JavaScript
    对象中缺失。因此，我们应该在我们的页面上包含这个库。否则，Backbone.js 将会因为缺少功能而抛出错误。
- en: Backbone.js works really well with jQuery. It checks whether the library is
    available and starts using it right away. It's a nice collaboration because we
    can speed up our work with the various jQuery methods. It's not a must-have dependency
    and the framework still works without it, but it simplifies the DOM manipulations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js 与 jQuery 非常兼容。它会检查库是否可用，并立即开始使用它。这是一个很好的合作，因为我们可以用各种 jQuery 方法加快我们的工作速度。它不是必须的依赖项，框架在没有它的情况下仍然可以工作，但它简化了
    DOM 操作。
- en: Extending the functionality
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展功能
- en: 'The framework has a few independent components that we will use. So, the idea
    is that we will create new classes that inherit the functionality of the base
    implementations. These components have the `extend` method, which accepts an object—our
    custom logic. At the end, our properties will overwrite the original code. The
    following is a new view class that we will create:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 框架有几个独立的组件，我们将使用它们。所以，我们的想法是创建新的类，这些类继承基本实现的功能。这些组件有 `extend` 方法，它接受一个对象——我们的自定义逻辑。最后，我们的属性将覆盖原始代码。以下是我们将创建的新视图类：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are no mandatory modules. There is no strictly defined central entry point
    of our application. Everything is up to us, which is good. All the parts are so
    decoupled, which makes Backbone.js easy to work with.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 没有强制性的模块。我们的应用程序没有严格定义的中心入口点。一切都在我们的掌控之中，这是好事。所有部分都如此解耦，这使得 Backbone.js 很容易使用。
- en: Understanding Backbone.js as an event-driven framework
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Backbone.js 作为事件驱动框架
- en: 'By event driven, we mean that the application flow is determined by events,
    that is, every class/object in the framework dispatches messages that notify the
    rest of the components about some action. In other words, every object we create
    can accept listeners and can trigger events. This makes our application extremely
    flexible and communicative. This approach encourages modular programming, and
    it really helps in building solid architectures. The `Backbone.Events` module
    is a module that delivers this functionality. The following example code explains
    how we can extend the `Backbone.Events` module:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过事件驱动，我们指的是应用程序流程由事件决定，也就是说，框架中的每个类/对象都会派发消息，通知其他组件关于某些动作。换句话说，我们创建的每个对象都可以接受监听器并触发事件。这使得我们的应用程序非常灵活和易于沟通。这种方法鼓励模块化编程，并真正有助于构建坚实的架构。`Backbone.Events`模块是一个提供这种功能的模块。以下示例代码解释了如何扩展`Backbone.Events`模块：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Underscore.js `extend` method merges the passed objects into one. In our case,
    we will produce an object that has the observer pattern implemented. This leads
    us to conclude that every view, model, or collection produced by Backbone.js has
    the `on` and `trigger` methods available.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js的`extend`方法将传递的对象合并成一个。在我们的情况下，我们将生成一个实现了观察者模式的对象。这导致我们得出结论，Backbone.js产生的每个视图、模型或集合都具有`on`和`trigger`方法。
- en: Using models
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模型
- en: 'The model is an important part of every Backbone.js project. Its primary function
    is to hold our data. The model keeps, validates, and synchronizes data with the
    server. Together with this, the model can notify the outside world of the events
    that happen inside the module. The following example code explains how we can
    extend the `Backbone.Model` module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是每个Backbone.js项目的核心部分。它的主要功能是保存我们的数据。模型保存、验证并同步数据与服务器。与此相关，模型可以通知外部世界模块内部发生的事件。以下示例代码解释了如何扩展`Backbone.Model`模块：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The information in the model is kept in a hash table. There are properties and
    values. We have the `set` and `get` methods to access the data. Once something
    is changed, the model triggers an event. You may wonder why we need to wrap the
    data into a class. In the beginning, `Backbone.Model` looks like an unnecessary
    abstraction. However, very soon you will realize that such a concept is really
    powerful. First, we can attach as many views as we want to the same model, and
    by attach we mean listening to a `change` event. We can update the model and change
    the user interface as well. The second thing is that we can connect the model
    to a server-side API and immediately synchronize the information via an Ajax request.
    We will do this in an example application later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模型中的信息被保存在哈希表中。这里有属性和值。我们拥有`set`和`get`方法来访问数据。一旦有东西被改变，模型就会触发一个事件。你可能想知道为什么我们需要将数据封装成一个类。一开始，`Backbone.Model`看起来像是一个不必要的抽象。然而，很快你就会意识到这个概念真的很强大。首先，我们可以将尽可能多的视图附加到同一个模型上，这里的附加意味着监听一个`change`事件。我们可以更新模型并改变用户界面。第二件事是，我们可以将模型连接到服务器端API，并通过Ajax请求立即同步信息。我们将在后面的示例应用程序中这样做。
- en: Using collections
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集合
- en: 'Very often, we will need to store the models in an array. The collections are
    made for such cases. The `Backbone.Collection` module has methods such as `add`,
    `remove`, and `forEach` for interaction with the stored items. It can also fetch
    multiple models from an external source and that''s what it is used mostly for.
    Of course, the collection needs to know what is the type of the model. The following
    example code explains how we can extend the `Backbone.Collection` module:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的情况是我们需要将模型存储在数组中。集合就是为了这种情况而设计的。`Backbone.Collection`模块具有`add`、`remove`和`forEach`等方法，用于与存储的项目交互。它还可以从外部源获取多个模型，这就是它主要被用于的地方。当然，集合需要知道模型的数据类型。以下示例代码解释了如何扩展`Backbone.Collection`模块：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The example shows the same `User` model class, but this is placed inside a collection.
    We can easily add new users and retrieve their names. Similar to the `Backbone.Model`
    module, every collection can sync our data with an external server via HTTP requests.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 示例显示了相同的`User`模型类，但这个类被放置在一个集合中。我们可以轻松地添加新用户并检索他们的名字。类似于`Backbone.Model`模块，每个集合都可以通过HTTP请求与外部服务器同步我们的数据。
- en: Implementing views
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现视图
- en: The views in Backbone.js take care of the user interface and its business logic,
    that is, when compared to the usual **Model-View-Controller** (**MVC**) pattern,
    here, the view and the controller are merged in one place. Again, there is a base
    class that we have to extend. An interesting thing is that a DOM element is automatically
    created for us. We can control its type, class, or ID, and it is always there.
    This is really handy because we can build our interface dynamically behind the
    scenes and add it to the page only once, avoiding the multiple reflows and repaints
    of the browser. This can increase the performance of our application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js 中的视图负责用户界面及其业务逻辑，即与通常的 **模型-视图-控制器**（**MVC**）模式相比，在这里，视图和控制器合并在一个地方。再次强调，我们必须扩展一个基类。有趣的是，一个
    DOM 元素会自动为我们创建。我们可以控制其类型、类或 ID，并且它始终存在。这非常方便，因为我们可以在幕后动态构建我们的界面，并且只需将其添加到页面一次，从而避免浏览器多次重排和重绘。这可以提高我们应用程序的性能。
- en: 'There is a certain popular wrong implementation of Backbone.js views. I myself
    made a lot of mistakes till I understood how everything is supposed to work. The
    idea is to bind the view''s `render` method to a change in the model. By doing
    this, the interface will be automatically updated. It is also important to find
    the balance and keep the classes short. Sometimes, we may end up with a really
    long view, which controls a big portion of our page. A good practice is to divide
    the parts into smaller pieces. It''s just a lot easier for maintenance and testing.
    The following example code explains how we can extend the `Backbone.View` module:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js 视图存在一种流行的错误实现。我自己在理解了如何正确工作之前犯了很多错误。想法是将视图的 `render` 方法绑定到模型的变化上。通过这样做，界面将自动更新。保持类短小也很重要。有时，我们可能会得到一个非常长的视图，它控制了我们页面的大部分内容。一种良好的实践是将部分划分为更小的块。这只是为了维护和测试而变得更容易。以下示例代码解释了我们可以如何扩展
    `Backbone.View` 模块：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `tagName` property determines the type of the generated DOM element. It's
    a good practice to operate only with that created element. It's not a good idea
    to attach it to another view or somewhere in the DOM tree. This should happen
    outside the class. There are some tricky sections we must watch out for when we
    need to attach event listeners, for example, `click`. However, the framework has
    a solution for such cases. We will see it later in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`tagName` 属性决定了生成的 DOM 元素的类型。只操作创建的元素是一种良好的实践。将其附加到另一个视图或 DOM 树中的某个位置并不是一个好主意。这应该在类外部完成。在需要附加事件监听器，例如
    `click` 时，有一些棘手的部分我们必须注意。然而，框架为这种情况提供了解决方案。我们将在本章后面看到它。'
- en: Using the router
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用路由器
- en: So far, we learned about models, collections, and views. There is one more thing
    that is widely used, especially when we need to build a single-page application
    like ours—the router. It's a module that maps a function to a specific URL. It
    supports the new history API so that it can handle addresses such as `/page/action/32`.
    The HTML5 history API is a standardized way to manipulate the browser history
    via a script. If the browser doesn't support this API, then it works with the
    good old fragment version, that is, `#page/action/32`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学习了关于模型、集合和视图的内容。还有另一件广泛使用的事情，尤其是在我们需要构建像我们这样的单页应用程序时——那就是路由器。这是一个将函数映射到特定
    URL 的模块。它支持新的历史 API，因此它可以处理像 `/page/action/32` 这样的地址。HTML5 历史API 是一种通过脚本操作浏览器历史的标准化的方式。如果浏览器不支持此
    API，则它将使用良好的旧片段版本，即 `#page/action/32`。
- en: 'The following example code explains how we can extend the `Backbone.Router`
    module:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码解释了我们可以如何扩展 `Backbone.Router` 模块：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We just have to define our routes and the module is responsible for the rest.
    Keep in mind that we may use dynamic URLs, that is, URLs that contain dynamic
    parts, like with the `search` route in the preceding code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要定义我们的路由，模块就会负责其余部分。记住，我们可能使用动态 URL，即包含动态部分的 URL，就像前面代码中的 `search` 路由一样。
- en: The router itself collaborates with another module called `Backbone.history`.
    This is the class that listens to `hashchange` events or `pushState` events triggered
    by the browser. So, once the routes are initialized, we should run `Backbone.history.start()`
    in order to fire the matched route handler. We will see this in action while writing
    the client-side part of the application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器本身与另一个名为 `Backbone.history` 的模块协作。这是一个监听浏览器触发的 `hashchange` 事件或 `pushState`
    事件的类。因此，一旦初始化了路由，我们应该运行 `Backbone.history.start()` 来触发匹配的路由处理程序。我们将在编写应用程序的客户端部分时看到这一点。
- en: Talking to the backend
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与后端通信
- en: As we mentioned, Backbone.js offers automatic synchronization with the server-side
    data. This, of course, needs some efforts from our side, and they are more like
    the things we need to do at the backend part of the application. The client-side
    JavaScript makes **CRUD** (**create**, **read**, **update**, and **delete**) HTTP
    requests and the server will process them. Every model and collection should have
    a `url` property (or method) set, and we will send the information to this address.
    It's only one URL, so the different operations are using different request methods—`GET`,
    `POST`, `PUT`, and `DELETE`. In our example, the key moment is to wire Backbone.js's
    objects to the Node.js server. Once this is done, we will be able to manage the
    to-do lists easily directly from the browser.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，Backbone.js 提供了与服务器端数据的自动同步。当然，这需要我们这边的一些努力，而且这些努力更像是我们需要在应用程序的后端部分完成的事情。客户端
    JavaScript 会发送 **CRUD**（**创建**、**读取**、**更新**和**删除**）HTTP 请求，服务器将处理它们。每个模型和集合都应该设置一个
    `url` 属性（或方法），我们将信息发送到这个地址。只有一个 URL，所以不同的操作使用不同的请求方法——`GET`、`POST`、`PUT` 和 `DELETE`。在我们的例子中，关键的时刻是将
    Backbone.js 的对象连接到 Node.js 服务器。一旦完成这个步骤，我们就能直接从浏览器中轻松地管理待办事项列表。
- en: Writing the backend of the application
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写应用程序的后端
- en: The backend is the Node.js part, which will take care of the data delivery and
    will serve the necessary HTML, CSS, and JavaScript functionalities. In order to
    learn something new in every chapter, we will use different approaches for the
    common tasks. For sure, there are things that we need to do every time, for example,
    running a server that listens on a particular port. JavaScript is a really interesting
    language, and in most cases, we can solve the same problems in completely different
    ways. In the previous chapters, we used Express to send assets to the users. In
    addition, there were examples where we did this directly by reading the files
    with the filesystem API. However, this time, we will combine the ideas of the
    two methods, that is, the code that we will use will read the resources from the
    hard disk and we will work with dynamic paths.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 后端是 Node.js 部分，它将负责数据传输并提供必要的 HTML、CSS 和 JavaScript 功能。为了在每一章中学习新知识，我们将使用不同的方法来完成常见任务。当然，有些事情我们每次都需要做，例如，运行监听特定端口的服务器。JavaScript
    是一种非常有趣的语言，在大多数情况下，我们可以用完全不同的方式解决相同的问题。在前面的章节中，我们使用了 Express 向用户发送资源。此外，还有一些例子，我们直接通过文件系统
    API 读取文件来完成这项工作。然而，这次，我们将结合两种方法的思想，也就是说，我们将使用的代码将从硬盘读取资源，我们将处理动态路径。
- en: Running the Node.js server
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Node.js 服务器
- en: 'We will start the project in an empty directory. In the beginning, we need
    an empty `index.js` file that will host the Node.js server. Let''s put the following
    content in the `index.js` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个空目录中启动项目。一开始，我们需要一个空的 `index.js` 文件，它将托管 Node.js 服务器。让我们在 `index.js` 文件中放入以下内容：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The script starts with the definition of some global variables. The `http`
    module is used to run the Node.js server and `fs` is run to access the files.
    The `files` object acts as a cache for already requested files. Reading the files
    from the hard disk can be a very expensive operation, so there is really no need
    to do this in every single request. It''s a good practice to cache the content
    whenever possible. The `debug` variable is set to `true` while we are developing
    the application. This actually turns off our caching mechanisms because otherwise,
    we need to restart the server every time we make changes to some of the HTML,
    CSS, or JavaScript files. There is a short `respond` method, which accepts an
    object with the following format:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本从定义一些全局变量开始。使用 `http` 模块运行 Node.js 服务器，使用 `fs` 访问文件。`files` 对象充当已请求文件的缓存。从硬盘读取文件可能是一个非常昂贵的操作，所以真的没有必要在每次请求中都这样做。尽可能缓存内容是一个好的实践。当我们在开发应用程序时，`debug`
    变量设置为 `true`。这实际上关闭了我们的缓存机制，因为否则，每次我们更改一些 HTML、CSS 或 JavaScript 文件时，都需要重新启动服务器。有一个简短的
    `respond` 方法，它接受以下格式的对象：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `content` property is the actual file's content and the `ext` property represents
    the file's extension. The same method also needs the `response` object, so it
    can send information to the browser. Based on the file's type, we set the proper
    `Content-Type` header. This is important because if we skip this, the browser
    may not process the resource correctly. Next, the `serveAssets` method gets the
    current requested path and tries to read the actual file from the system. It also
    checks whether the file is not in the cache or whether we are in the debug mode.
    If the file is missing, it sends a 404 error page to the browser. The last lines
    simply run the server and pass the `request` and `response` objects to `serveAssets`.
    With this code, we are able to request files with URLs that match their actual
    directory path.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`content` 属性是实际文件的文件内容，而 `ext` 属性表示文件的扩展名。同样的方法也需要 `response` 对象，以便它能向浏览器发送信息。根据文件的类型，我们设置适当的
    `Content-Type` 头部。这很重要，因为我们如果跳过这一步，浏览器可能无法正确处理资源。接下来，`serveAssets` 方法获取当前请求的路径，并尝试从系统中读取实际文件。它还会检查文件是否不在缓存中，或者我们是否处于调试模式。如果文件缺失，它将向浏览器发送
    404 错误页面。最后几行代码简单地运行服务器，并将 `request` 和 `response` 对象传递给 `serveAssets`。有了这段代码，我们就能通过匹配实际目录路径的
    URL 请求文件。'
- en: Managing the to-do lists
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理待办列表
- en: 'We have set up the server, so we can now continue writing the business logic,
    that is, the logic that will manage the tasks from our to-do list. Let''s define
    the following two new variables at the top of the file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了服务器，现在我们可以继续编写业务逻辑，即管理待办列表的任务的逻辑。让我们在文件顶部定义以下两个新变量：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `todos` array will keep our tasks. Every task will be a simple JavaScript
    object, as shown in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`todos` 数组将保存我们的任务。每个任务都将是一个简单的 JavaScript 对象，如下面的代码所示：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will increment the `ids` variable every time we need to add a new to-do
    activity. So, every object in the array will have a unique ID attached to it.
    Of course, normally, we will not rely on a single number to identify the different
    tasks, but the `ids` variable will work for our little experiment. The following
    is the function that will add a new element to the `todos` array:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们需要添加一个新的待办活动时，我们将增加 `ids` 变量。因此，数组中的每个对象都将附加一个唯一的 ID。当然，通常我们不会依赖单个数字来识别不同的任务，但
    `ids` 变量将适用于我们的小型实验。以下是将新元素添加到 `todos` 数组的函数：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We should have two other methods for deleting and editing a to-do list. They
    are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该有另外两个方法用于删除和编辑待办列表。它们如下所示：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `deleteToDo` function loops through the elements and skips the one that
    matches the passed ID. The `editToDo` function is almost the same, except that
    it updates the properties of the stored object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteToDo` 函数遍历元素，跳过与传递的 ID 匹配的元素。`editToDo` 函数几乎相同，只是它更新存储对象的属性。'
- en: 'We have methods to manage the data; now, we have to write the part that will
    use them. In general, our server has two roles. The first one is to deliver the
    usual HTML, CSS, and JavaScript functionalities to the browser. The other one
    is to act as a REST service, that is, accept the CRUD type of requests and respond
    to them. Backbone.js will send JSON objects and will expect to receive resources
    in the same format. So, we have the `respond` function and the following code
    defines the `respondJSON` function, which will send the data to the browser:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有管理数据的方法；现在，我们必须编写使用它们的部分。一般来说，我们的服务器有两个角色。第一个是向浏览器提供常规的 HTML、CSS 和 JavaScript
    功能。另一个是作为 REST 服务，即接受 CRUD 类型的请求并对其做出响应。Backbone.js 将发送 JSON 对象，并期望以相同的格式接收资源。因此，我们有
    `respond` 函数，以下代码定义了 `respondJSON` 函数，该函数将数据发送到浏览器：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The entry point of our server is the handler of the `http.createServer` method.
    This is where we need to divide the application''s flow, as shown in the following
    code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务器的入口点是 `http.createServer` 方法的处理器。这就是我们需要划分应用程序流程的地方，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will check whether the current URL starts with `/api`. If not, then we serve
    the assets. Otherwise, the request is considered as a CRUD operation, as shown
    in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查当前 URL 是否以 `/api` 开头。如果不是，那么我们提供资源。否则，请求被视为 CRUD 操作，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are two paths that control everything. The `/api/all` path responds with
    a JSON code that contains all the to-do lists available. The next `/api/todo`
    path is responsible for creating, editing, and deleting a task. The actual address
    that is used is `http://localhost:3000/api/todo/4`, where the number at the end
    is the ID of an element in the `todos` array. That''s why we need `req.url.split("/").pop()`,
    which extracts the number from the URL. There is one additional function called
    `processPOSTRequest`. It''s a helper that gets the data sent via the `POST` or
    `PUT` methods. In Express, the same functionality is provided by the `bodyParser`
    middleware. The `processPOSTRequest` function is given in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个路径控制着一切。`/api/all`路径响应包含所有可用待办事项列表的JSON代码。下一个`/api/todo`路径负责创建、编辑和删除任务。实际使用的地址是`http://localhost:3000/api/todo/4`，其中末尾的数字是`todos`数组中元素的ID。这就是为什么我们需要`req.url.split("/").pop()`，它从URL中提取数字。还有一个额外的函数叫做`processPOSTRequest`。它是一个辅助函数，用于获取通过`POST`或`PUT`方法发送的数据。在Express中，相同的功能由`bodyParser`中间件提供。`processPOSTRequest`函数的代码如下：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At the end, maybe it''s a good idea to fill the `todos` array with some tasks.
    Add the following methods just to have something to display once we build the
    frontend:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也许填充`todos`数组一些任务是个好主意。添加以下方法只是为了在我们构建前端时有一些内容可以显示：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Writing the frontend
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写前端
- en: In this section, we will develop the client-side logic—the code that will run
    in the browser of the users. This includes the listing and managing of the to-do
    lists delivered by the Node.js part.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发客户端逻辑——将在用户的浏览器中运行的代码。这包括由Node.js部分提供的待办事项列表的列出和管理。
- en: Looking into the base of the application
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看应用程序的基础
- en: 'Before we start coding, let''s have a look at the file structure. The following
    figure shows how our project should look:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们看一下文件结构。以下图显示了我们的项目应该如何看起来：
- en: '![Looking into the base of the application](img/00010.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![查看应用程序的基础](img/00010.jpeg)'
- en: 'The `index.js` file contains the Node.js code that we already wrote. The `.css`
    and `.html` directories hold the styles and the HTML markup of the page. In the
    `.js` folder, we will put the collection, model, and views of Backbone.js. Along
    with that, there are the framework''s dependencies and the main application''s
    `app.js` file. Let''s start with the `page.html` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js`文件包含我们已编写的Node.js代码。`.css`和`.html`目录包含页面的样式和HTML标记。在`.js`文件夹中，我们将放置Backbone.js的集合、模型和视图。此外，还有框架的依赖项和主应用程序的`app.js`文件。让我们从`page.html`文件开始：'
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The styles are added to the `head` tag of the page. The scripts are put at the
    end, just before closing the `body` tag. We do this because the JavaScript files
    usually block the rendering of the page. Adding them at the top of the page means
    that the browser will not get the necessary styles and HTML markup and will not
    display anything to the user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 样式被添加到页面的`head`标签中。脚本被放置在末尾，就在关闭`body`标签之前。我们这样做是因为JavaScript文件通常会阻止页面的渲染。将它们添加到页面顶部意味着浏览器将无法获取必要的样式和HTML标记，并且不会向用户显示任何内容。
- en: 'We have a menu with two buttons. The first one will show a form where the user
    can add a new to-do list. The second one shows the home page, that is, a list
    with all the tasks. The content `div` element will be the host container where
    we will render Backbone.js''s views. The bootstrapping of the application is done
    in the `init` method of the `app` object as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个带有两个按钮的菜单。第一个按钮将显示一个表单，用户可以在其中添加新的待办事项列表。第二个按钮显示主页，即包含所有任务的列表。内容`div`元素将是承载容器，我们将在这里渲染Backbone.js的视图。应用程序的引导过程是在`app`对象的`init`方法中完成的，如下所示：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will use the **Revealing Module** pattern. The `app` object has its own private
    scope. Its public API consists of namespaces for the models, collections, and
    views. The last thing is the `init` method. It's a good practice to use namespaces.
    They encapsulate our application and prevent collisions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Revealing Module**模式。`app`对象拥有其自己的私有作用域。它的公共API包括模型、集合和视图的命名空间。最后是`init`方法。使用命名空间是一个好的实践。它们封装了我们的应用程序并防止了冲突。
- en: 'The first thing we want to do is to display the current available tasks. Let''s
    write a few things in advance. It is clear that we will put the user interface
    in the content `div` element. So, it is a good idea to cache a reference to that
    element because we will use it multiple times. We can define a variable and assign
    a jQuery object to it as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想做的事情是显示当前可用的任务。让我们提前写一些东西。很明显，我们将把用户界面放在内容`div`元素中。所以，缓存对该元素的引用是一个好主意，因为我们将会多次使用它。我们可以定义一个变量并将jQuery对象分配给它，如下所示：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need a view class that will list the data. However, the view itself
    should not make requests to the backend. That''s the job of the model—`/js/models/ToDo.js`;
    its code is given as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个视图类来列出数据。然而，视图本身不应该向后端发送请求。这是模型的工作——`/js/models/ToDo.js`；其代码如下：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are using the namespace created in `/js/app.js`. Backbone.js offers the `defaults`
    property, which we may use to define the initial values. Here, the `url` method
    is very important. Without it, the framework can't send requests to the server.
    The logic that manages the to-do lists at the backend requires an ID. That's why
    we need to construct the URL dynamically.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用在`/js/app.js`中创建的命名空间。Backbone.js提供了`defaults`属性，我们可以用它来定义初始值。在这里，`url`方法非常重要。没有它，框架无法向服务器发送请求。后端管理待办事项的逻辑需要一个ID。这就是为什么我们需要动态构建URL的原因。
- en: 'And, of course, we may have a lot of tasks, so we need a`/js/collections/ToDos.js`
    collection, and its code is given as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可能会有很多任务，所以我们需要一个`/js/collections/ToDos.js`集合，其代码如下：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We set up the URL directly as a string. The collection should also know what
    kind of models are stored in it and we pass the model''s class. Keep in mind that
    we actually extended the classes here. In the following code, we will create an
    instance of the collection class and call the `fetch` method, which gets the to-do
    lists stored in the Node.js part:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接将URL设置为字符串。集合也应该知道其中存储了什么类型的模型，我们传递了模型的类。记住，我们实际上在这里扩展了类。在下面的代码中，我们将创建集合类的实例并调用`fetch`方法，该方法从Node.js部分获取存储的待办事项列表：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our application is useless without the data. We will use the `success` callback
    and will render the list view once the information arrives.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 没有数据，我们的应用程序就没有用。我们将使用`success`回调，并在信息到达后渲染列表视图。
- en: 'Before we proceed with the code of the /`js/views/list.js` file, we will clarify
    a few things about the Backbone.js''s views. We mentioned in the beginning of
    the chapter that there is a DOM element that is automatically created for us.
    It''s available as a `.el` property of the view. There are a few common tasks
    that we will probably do. The first one is binding DOM events to functions inside
    the view class. This can happen by applying a value to the `events` property,
    as shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续`/js/views/list.js`文件的代码之前，我们将澄清关于Backbone.js视图的一些事情。我们在本章开头提到，有一个DOM元素是自动为我们创建的。它作为视图的`.el`属性可用。我们将可能执行一些常见任务。第一个任务是绑定DOM事件到视图类内部的函数。这可以通过将值应用到`events`属性来实现，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We start with the type of the event followed by an element selector. The value
    is a function of the view. A big advantage of this technique for event handling
    is that the `this` keyword in the handler points to the right place, that is,
    the view. We may need to call `delegateEvents` to reassign the listeners. This
    is needed when we update the HTML code of the view's DOM element.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从事件的类型开始，然后是一个元素选择器。值是视图的一个函数。这种事件处理技术的一个大优点是，处理程序中的`this`关键字指向正确的位置，即视图。我们可能需要调用`delegateEvents`来重新分配监听器。当我们更新视图的DOM元素的HTML代码时，这很有必要。
- en: 'The other interesting thing regarding Backbone.js''s views is the `render`
    method. What we normally do there is update the content of the `.el` object. We
    can use any code we like, but it is good practice to avoid placing HTML tags.
    That''s the function where most developers use a template engine. In our example,
    we will use the Underscore.js template. It accepts a string and an object with
    data. As we don''t want to place the HTML as a string inside the view, we will
    add it to the `page.html` file. The markup will be placed inside a script tag,
    so it doesn''t mess up the rest of the valid HTML code. The good news is that
    we could still get it via jQuery by simply querying the tag. For example, the
    following is the template used in `/js/views/list.js`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Backbone.js 视图的另一个有趣之处是 `render` 方法。我们通常在那里更新 `.el` 对象的内容。我们可以使用任何我们喜欢的代码，但避免放置
    HTML 标签是良好的实践。这是大多数开发者使用模板引擎的地方。在我们的例子中，我们将使用 Underscore.js 模板。它接受一个字符串和一个包含数据的对象。由于我们不想在视图中放置
    HTML 字符串，我们将它添加到 `page.html` 文件中。标记将被放置在脚本标签内，这样就不会弄乱其余的有效 HTML 代码。好消息是，我们仍然可以通过简单地查询标签来获取它。例如，以下是在
    `/js/views/list.js` 中使用的模板：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are data placeholders for the item's index, text, and status. We will
    replace them with actual values during the rendering.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有数据占位符用于项目的索引、文本和状态。我们将在渲染过程中用实际值替换它们。
- en: Listing the to-do activities
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出待办活动
- en: 'Let''s continue with the code of the list view. The one that will show the
    current added to-do activity is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续列表视图的代码。以下是将显示当前添加的待办活动的代码：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We define the view class in the correct namespace. We will pass the collection
    of to-do activities as a model, so the `this.model` statement will give us an
    access to all the tasks. In the `render` method, we loop through every model and
    construct an unordered list, which is at the end and appended to the DOM element.
    We are using `$el` instead of `el` because our project has jQuery included, and
    Backbone.js automatically starts working with it. Note that we are sending different
    values of `done` and `statusLabel` based on the status of the task. If we check
    the preceding template, we will see that `done` is actually a CSS class. Applying
    a different class will allow us to distinguish the items in the list. We should
    not forget to run the `delegateEvents` method at the end. We are updating the
    children elements of `$el`, so every event listener that is attached is removed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在正确的命名空间中定义了视图类。我们将传递待办活动的集合作为模型，因此 `this.model` 语句将使我们能够访问所有任务。在 `render`
    方法中，我们遍历每个模型并构建一个无序列表，该列表位于末尾并附加到 DOM 元素上。我们使用 `$el` 而不是 `el`，因为我们的项目包含了 jQuery，Backbone.js
    会自动开始与它一起工作。请注意，我们根据任务的状态发送不同的 `done` 和 `statusLabel` 值。如果我们检查前面的模板，我们会看到 `done`
    实际上是一个 CSS 类。应用不同的类将允许我们区分列表中的项目。我们不应该忘记在最后运行 `delegateEvents` 方法。我们正在更新 `$el`
    的子元素，因此每个附加的事件监听器都会被移除。
- en: In the beginning of the class, we define two events. The first one deletes a
    to-do activity from the system. Backbone.js has a destroy method for such cases.
    However, to reach the exact model from the collection, we need its index (ID).
    If we check the HTML template, will see that every `li` tag has a `data-index`
    attribute that contains exactly what we need. That's what the `getIndex` helper
    does—it gets the value of that attribute. Similarly, `changeStatus` updates the
    `done` field of the to-do lists. After every modification, we call the `render`
    method. This is quite important for the users because they have to see that the
    change is done.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在课程开始时，我们定义了两个事件。第一个事件是从系统中删除一个待办活动。Backbone.js 有一个用于此类情况的 destroy 方法。然而，为了到达集合中的确切模型，我们需要它的索引（ID）。如果我们检查
    HTML 模板，我们会看到每个 `li` 标签都有一个 `data-index` 属性，它包含我们需要的确切内容。这就是 `getIndex` 辅助函数的作用——它获取该属性的值。同样，`changeStatus`
    更新待办列表的 `done` 字段。每次修改后，我们都调用 `render` 方法。这对用户来说非常重要，因为他们必须看到变化已经完成。
- en: 'Now, let''s change the `app.js` file a bit and render the view, as shown in
    the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微修改一下 `app.js` 文件并渲染视图，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is one new method, `showList`, which triggers the rendering of the view
    and appends its DOM element to the content `div` element. Now, if we run the application
    by typing `node ./index.js` in our console, we will see the three to-do activities,
    which we added, being displayed on the screen.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个新方法 `showList`，它触发视图的渲染并将它的 DOM 元素附加到内容 `div` 元素上。现在，如果我们通过在控制台中键入 `node
    ./index.js` 来运行应用程序，我们将看到我们添加的三个待办活动在屏幕上显示。
- en: Adding, deleting, and editing the to-do lists
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加、删除和编辑待办事项列表
- en: 'The next logical step is to develop the code for the adding, editing, and deleting
    of tasks. So, we need two new pages, additional logic to show the two new views,
    and a few lines that will remove tasks. We will also need a router that will handle
    the new content. To simplify the process, let''s directly see how the final `/js/app.js`
    file looks:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤是开发添加、编辑和删除任务的代码。因此，我们需要两个新的页面，额外的逻辑来显示两个新的视图，以及几行用于删除任务的代码。我们还需要一个处理新内容的路由器。为了简化过程，让我们直接看看最终的
    `/js/app.js` 文件看起来是什么样子：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have put a few new variables at the top. The `add` and `edit` variables
    represent the two new views. There are two new functions that change the content
    `div` element. Note that we are not calling the `render` method of the `add` view.
    This is because there is nothing dynamic in it, which means that there is no need
    to render it repeatedly. It''s just a form that submits data. The `showEditToDoForm`
    function is almost the same as the `showList` function, except that we expect
    one additional parameter—`data`. This should be an object with a format `{index:
    <number>}`. Once we have the index of the to-do list, we can easily get its fields.
    We will need these fields because we have to fill the form for editing.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在顶部添加了一些新的变量。`add` 和 `edit` 变量代表了两个新的视图。有两个新的函数会改变内容 `div` 元素。请注意，我们并没有调用
    `add` 视图的 `render` 方法。这是因为其中没有动态内容，也就是说没有必要重复渲染它。它只是一个提交数据的表单。`showEditToDoForm`
    函数几乎与 `showList` 函数相同，只是我们期望一个额外的参数——`data`。这应该是一个格式为 `{index: <number>}` 的对象。一旦我们有了待办事项列表的索引，我们就可以轻松地获取其字段。我们需要这些字段，因为我们必须填写用于编辑的表单。'
- en: Next, the home method simply uses the `navigate` method of the router and returns
    the user to the `list` view. The next thing in the script is the definition of
    the router. The described paths call the functions that we just went through.
    It's the mapping of URL addresses to JavaScript functions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`home` 方法简单地使用路由器的 `navigate` 方法，并将用户返回到 `list` 视图。脚本中的下一件事是路由器的定义。描述的路径调用我们刚刚经过的函数。这是
    URL 地址到 JavaScript 函数的映射。
- en: There are quite a few new things inside the `init` method, so let's have a closer
    look. The two new views, `add` and `edit`, are initialized, and again they accept
    the collection's to-do activities. We will also start listening for two events.
    The views dispatch the `saved` event when a new to-do activity is added and the
    `edited` event when some of the tasks are updated.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init` 方法中有很多新的内容，让我们仔细看看。两个新的视图，`add` 和 `edit`，被初始化了，并且它们再次接受集合的待办活动。我们还将开始监听两个事件。当添加新的待办活动时，视图会触发
    `saved` 事件，当一些任务被更新时，会触发 `edited` 事件。
- en: 'The view for adding new tasks is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新任务的视图如下：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is validation of the user''s input. If there is text entered in the `textarea`
    element, we call the `create` method of the collection that initializes a new
    model. It also sends a `POST` request to the server. Once the operation finishes,
    we empty the textbox and trigger the `saved` event so that the code in `/js/app.js`
    can forward the user to the home page. The views for adding and editing need a
    separate template. The following is the code of that template:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有用户输入的验证。如果在 `textarea` 元素中输入了文本，我们调用集合的 `create` 方法初始化一个新的模型。它还会向服务器发送一个 `POST`
    请求。一旦操作完成，我们清空文本框并触发 `saved` 事件，以便 `/js/app.js` 中的代码可以将用户转发到主页。添加和编辑视图需要单独的模板。以下是该模板的代码：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `/js/views/edit.js` file has almost the same code, which is given as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`/js/views/edit.js` 文件中的代码几乎相同，如下所示：'
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The difference is that it puts a value in the `textarea` element and calls the
    `save` method of the edited model instead of the `create` function of the whole
    collection.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于它在 `textarea` 元素中放入一个值，并调用已编辑模型的 `save` 方法，而不是整个集合的 `create` 函数。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to work with Backbone.js. We used a model, collection,
    router, and several views to implement a simple to-do application. Thankfully,
    due to the event-driven nature of the framework, we bound everything together.
    Node.js took an interesting and important part in this small project. It handled
    the requests from the client-side's JavaScript and acted as a REST service.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Backbone.js。我们使用模型、集合、路由器和几个视图来实现一个简单的待办事项应用。幸运的是，由于框架的事件驱动特性，我们将所有内容绑定在一起。Node.js
    在这个小型项目中扮演了一个有趣且重要的角色。它处理来自客户端 JavaScript 的请求，并充当 REST 服务。
- en: The next chapter is dedicated to command-line programming. We will see how to
    use Node.js from the command line and will develop a script that uploads our photos
    to Flickr.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专门介绍命令行编程。我们将学习如何从命令行使用Node.js，并开发一个脚本，用于将我们的照片上传到Flickr。
