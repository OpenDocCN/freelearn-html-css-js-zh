- en: Understanding the Runtime
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解运行时
- en: After reading this book, you will probably be eager to start a new project to
    put into practice everything that you have learned so far. At this point, you
    should be able to write a small web application using TypeScript and resolve the
    potential design-time issues that you might encounter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书之后，你可能会渴望开始一个新的项目，将你迄今为止所学的一切付诸实践。在这个时候，你应该能够编写一个使用 TypeScript 的小型网络应用程序，并解决你可能会遇到的潜在设计时问题。
- en: However, as your new project grows, and you develop more complex features, you
    might encounter some runtime issues. This chapter should provide you with the
    missing knowledge that will help you to resolve runtime issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着你的新项目不断发展，你开发了更多复杂的功能，你可能会遇到一些运行时问题。本章应该为你提供解决运行时问题的缺失知识。
- en: We have only briefly mentioned the TypeScript runtime in the preceding chapters,
    but depending on your background, you may already know a lot about it, because
    the TypeScript runtime is the JavaScript runtime.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中只是简要地提到了 TypeScript 运行时，但根据你的背景，你可能已经对它有了很多了解，因为 TypeScript 运行时是 JavaScript
    运行时。
- en: TypeScript is only used at design time; the TypeScript code is then compiled
    into JavaScript and finally executed at runtime. The JavaScript runtime oversees
    the execution of the JavaScript code. It is important to understand that we will
    never execute TypeScript code and we will always execute JavaScript code; for
    this reason, when we refer to the TypeScript runtime, we will, in fact, be talking
    about the JavaScript runtime.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 仅用于设计时；TypeScript 代码随后被编译成 JavaScript，并在运行时执行。JavaScript 运行时负责监督
    JavaScript 代码的执行。重要的是要理解我们永远不会执行 TypeScript 代码，我们总是执行 JavaScript 代码；因此，当我们提到 TypeScript
    运行时，我们实际上是在谈论 JavaScript 运行时。
- en: When we compile our TypeScript code, we will generate JavaScript code, which
    will be executed on the server side or the client side. It is then that we may
    encounter some challenging runtime issues.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译 TypeScript 代码时，我们将生成 JavaScript 代码，该代码将在服务器端或客户端执行。那时，我们可能会遇到一些具有挑战性的运行时问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The execution environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行环境
- en: The event loop
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环
- en: The `this` operator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this` 操作符'
- en: Prototypes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: Closures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Let's start by learning about the execution environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解执行环境开始。
- en: The execution environment
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行环境
- en: The execution environment is one of the first things that we must think about
    before we can start developing a TypeScript application. Once we have compiled
    our TypeScript code into JavaScript, it can be executed in many different environments.
    While most of those environments will be part of a web browser such as Chrome,
    Internet Explorer, or Firefox, we might also want to be able to run our code on
    the server side or in a desktop application in environments such as Node.js, RingoJS,
    or Electron.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 执行环境是我们开始开发 TypeScript 应用程序之前必须考虑的第一件事之一。一旦我们将 TypeScript 代码编译成 JavaScript，它就可以在许多不同的环境中执行。虽然这些环境中的大多数将是网络浏览器的一部分，如
    Chrome、Internet Explorer 或 Firefox，但我们可能还希望能够在 Node.js、RingoJS 或 Electron 等环境中的服务器端或桌面应用程序上运行我们的代码。
- en: It is important to keep in mind that there are some variables and objects available
    at runtime that are environment-specific. For example, we could create a library
    and access the `document.layers` variable. While `document` is part of the W3C
    **Document Object Model** (**DOM**) standard, the layers property is only available
    in Internet Explorer and is not part of the W3C DOM standard.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在运行时有一些变量和对象是特定于环境的。例如，我们可以创建一个库并访问 `document.layers` 变量。虽然 `document`
    是 W3C **文档对象模型**（**DOM**）标准的一部分，但 layers 属性仅在 Internet Explorer 中可用，并且不是 W3C DOM
    标准的一部分。
- en: 'The W3C defines the DOM as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: W3C 如下定义 DOM：
- en: '"The Document Object Model is a platform- and language-neutral interface that
    will allow programs and scripts to dynamically access and update the content,
    structure, and style of documents. The document can be further processed, and
    the results of that processing can be incorporated back into the presented page".'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “文档对象模型是一个平台和语言中立的接口，它将允许程序和脚本动态地访问和更新文档的内容、结构和样式。文档可以进一步处理，处理结果可以合并回显示的页面”。
- en: Similarly, we can also access a set of objects known as the **Browser Object
    Model** (**BOM**) from a web browser runtime environment. The BOM consists of
    the objects `navigator`, `history`, `screen`, `location`, and `document`, which
    are properties of the `window` object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也可以从浏览器运行时环境中访问一组称为**浏览器对象模型**（**BOM**）的对象。BOM 包括 `navigator`、`history`、`screen`、`location`
    和 `document` 这些对象，它们是 `window` 对象的属性。
- en: We need to keep in mind that the DOM is only available in web browsers. If we
    want to run our application in a web browser, we will be able to access the DOM
    and BOM. However, in environments such as Node.js or RingoJS, these APIs will
    not be available since they are standalone JavaScript environments completely
    independent of a web browser. We can also find other objects in the server-side
    environments (such as `process.stdin` in Node.js) that will not be available if
    we attempt to execute our code in a web browser.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，DOM 只在网页浏览器中可用。如果我们想在网页浏览器中运行我们的应用程序，我们将能够访问 DOM 和 BOM。然而，在 Node.js 或
    RingoJS 等环境中，这些 API 将不可用，因为它们是完全独立于网页浏览器的独立 JavaScript 环境。我们还可以在服务器端环境中找到其他对象（如
    Node.js 中的 `process.stdin`），如果我们尝试在网页浏览器中执行我们的代码，这些对象将不可用。
- en: We also need to keep in mind the existence of multiple versions of these JavaScript
    environments. In some cases, we will have to support multiple browsers and multiple
    versions of Node.js. The recommended practice when dealing with this problem is
    to add conditional statements that check for the availability of features rather
    than the availability of an environment or version.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要牢记这些 JavaScript 环境存在多个版本。在某些情况下，我们可能需要支持多个浏览器和多个版本的 Node.js。处理此类问题时，建议的做法是添加条件语句来检查功能的可用性，而不是检查环境或版本的可用性。
- en: A really good library is available that can help us to implement feature detection
    when developing for web browsers. The library is called **Modernizr** and can
    be downloaded at [http://modernizr.com/](http://modernizr.com/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常好的库可以帮助我们在为网页浏览器开发时实现功能检测。这个库叫做 **Modernizr**，可以在 [http://modernizr.com/](http://modernizr.com/)
    下载。
- en: Understanding the event loop
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: The TypeScript runtime (JavaScript) has a concurrency model based on an **event
    loop**. This model is quite different from the model in other languages, such
    as C or Java. Before we focus on the event loop itself, we must understand some
    runtime concepts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 运行时（JavaScript）基于**事件循环**的并发模型。这种模型与其他语言（如 C 或 Java）中的模型相当不同。在我们专注于事件循环本身之前，我们必须了解一些运行时概念。
- en: 'What follows is a visual representation of some important runtime concepts:
    heap, stack, queue, and frame:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示是一些重要的运行时概念：堆、栈、队列和帧：
- en: '![](img/9abf1c82-6d70-49f1-8ff4-3bf634ab7389.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9abf1c82-6d70-49f1-8ff4-3bf634ab7389.png)'
- en: We will now look at the role of each of these concepts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨每个这些概念的作用。
- en: Frames
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧结构
- en: A frame is a sequential unit of work. In the preceding diagram, the frames are
    represented by the blocks inside the stack.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个帧是工作的一个连续单元。在上面的图中，帧由栈内的块表示。
- en: 'When a function is invoked in JavaScript, the runtime creates a frame in the
    stack. The frame holds that function''s arguments and local variables. When the
    function returns, the frame is removed from the stack. Let''s look at an example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 JavaScript 中调用一个函数时，运行时会创建一个帧在栈中。帧包含该函数的参数和局部变量。当函数返回时，帧从栈中移除。让我们看一个例子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After declaring the `foo` and `bar` functions, we will invoke the `bar` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明 `foo` 和 `bar` 函数之后，我们将调用 `bar` 函数：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When `bar` is executed, the runtime will create a new frame containing the arguments
    of `bar` and all its local variables (value). The frame (represented as blocks
    inside the stack) is then added to the top of the stack.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `bar` 执行时，运行时会创建一个新的帧，包含 `bar` 的参数以及所有其局部变量（值）。然后，这个帧（在栈内表示为块）被添加到栈顶。
- en: Internally, `bar` invokes `foo`. When `foo` is invoked, a new frame is created
    and allocated to the top of the stack. When the execution of `foo` is finished
    (`foo` has returned), the top frame is removed from the stack. When the execution
    of `bar` is also completed, it is removed from the stack as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`bar` 调用 `foo`。当 `foo` 被调用时，会创建一个新的帧并将其分配到栈顶。当 `foo` 的执行完成（`foo` 已返回）时，栈顶的帧被移除。当
    `bar` 的执行也完成时，它也会从栈中移除。
- en: 'Now, let''s try to imagine what would happen if the `foo` function invoked
    the `bar` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试想象如果 `foo` 函数调用了 `bar` 函数会发生什么：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We would create a never-ending function call loop. With each function call,
    a new frame would be added to the stack, and eventually there would be no more
    space in the stack, and an error would be thrown. Most software engineers are
    familiar with this error, known as a *stack overflow* error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会创建一个永无止境的函数调用循环。每次函数调用都会在栈中添加一个新的帧，最终栈中可能没有更多空间，并抛出错误。大多数软件工程师都熟悉这种错误，称为
    *栈溢出* 错误。
- en: Stack
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: The stack contains sequential steps (frames). A stack is a data structure that
    represents a simple **last-in-first-out** (**LIFO**) collection of objects. Therefore,
    when a frame is added to the stack, it is always added to the top of the stack.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 栈包含一系列步骤（帧）。栈是一种表示简单 **后进先出** （**LIFO**）对象集合的数据结构。因此，当帧添加到栈中时，它总是添加到栈顶。
- en: Since the stack is a LIFO collection, the event loop processes the frames stored
    in it from top to bottom. The dependencies of a frame are added to the top of
    it in the stack to ensure that all the dependencies of each of the frames are
    met.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于栈是一个 LIFO 集合，事件循环从栈顶到底部处理其中存储的帧。帧的依赖项被添加到栈顶，以确保每个帧的所有依赖项都得到满足。
- en: Queue
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: The queue contains a list of messages waiting to be processed. Each message
    is associated with a function. When the stack is empty, a message is taken out
    of the queue and processed. The processing consists of calling the associated
    function and adding the frames to the stack. The message processing ends when
    the stack becomes empty again.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 队列包含一个等待处理的消息列表。每个消息都与一个函数相关联。当栈为空时，从队列中取出一条消息并处理。处理包括调用相关函数并将帧添加到栈中。当栈再次变为空时，消息处理结束。
- en: In the previous runtime diagram, the blocks inside the queue represent the messages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的运行时图中，队列内的块代表消息。
- en: Heap
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: The heap is a memory container that is not aware of the order of the items stored
    in it. The heap contains all the variables and objects currently in use. It may
    also contain frames that are currently out of scope but have not yet been removed
    from memory by the garbage collector.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一个不知道存储在其中的项目顺序的内存容器。堆包含当前正在使用的所有变量和对象。它还可能包含当前不在作用域内但尚未被垃圾收集器从内存中移除的帧。
- en: The event loop
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环
- en: Concurrency is the ability for two or more operations to be executed simultaneously.
    The runtime execution takes place on one single thread, which means that we cannot
    achieve real concurrency.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是指两个或更多操作可以同时执行的能力。运行时执行在一个单独的线程上发生，这意味着我们无法实现真正的并发。
- en: The event loop follows a run-to-completion approach, which means that it will
    process a message from beginning to end before any other message is processed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环遵循运行至完成的方法，这意味着它会在处理任何其他消息之前，从开始到结束处理一条消息。
- en: Every time a function is invoked, a new message is added to the queue. If the
    stack is empty, the function is processed (the frames are added to the stack).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用函数时，都会将一条新消息添加到队列中。如果栈为空，则处理该函数（将帧添加到栈中）。
- en: When all the frames have been added to the stack, the stack is cleared from
    top to bottom. At the end of the process, the stack is empty, and the next message
    is processed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有帧都添加到栈中后，从栈顶到底部清除栈。在处理过程的末尾，栈为空，并处理下一条消息。
- en: Web workers can perform background tasks in a different thread. They use a separated
    queue, heap, and stack.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Web 工作者可以在不同的线程中执行后台任务。它们使用一个分离的队列、堆和栈。
- en: One of the advantages of the `event loop` is that the execution order is quite
    predictable and easy to follow. Another important advantage of the `event loop`
    approach is that it features non-blocking I/O. This means that when the application
    is waiting for an input and output (I/O) operation to finish, it can still process
    other things, such as user input.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`事件循环` 的一大优点是执行顺序非常可预测且易于跟踪。`事件循环` 方法的重要优点之一是它具有非阻塞 I/O。这意味着当应用程序等待输入和输出（I/O）操作完成时，它仍然可以处理其他事情，例如用户输入。'
- en: A disadvantage of this approach is that, if a message (function) takes too long
    to complete, the application becomes unresponsive. A good practice to follow is
    to make message processing short and, if possible, split one message into several
    messages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，如果一条消息（函数）执行时间过长，应用程序就会变得无响应。遵循的良好实践是使消息处理尽可能短，如果可能的话，将一条消息拆分成几条消息。
- en: The this operator
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`this` 操作符'
- en: In JavaScript, the `this` operator behaves a little differently compared to
    other languages. The value of the `this` operator is often determined by the way
    a function is invoked. Its value cannot be set by assignment during execution,
    and it may be different each time a function is invoked.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`this` 操作符的行为与其他语言略有不同。`this` 操作符的值通常由函数的调用方式决定。它的值在执行过程中不能通过赋值来设置，并且每次调用函数时可能不同。
- en: The `this` operator also has some differences when using the strict mode and
    non-strict mode. To learn more about the strict mode, refer to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用严格模式和非严格模式时，`this` 操作符也有一些不同之处。要了解更多关于严格模式的信息，请参阅 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。
- en: The this operator in the global context
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局上下文中的 `this` 操作符
- en: 'In the global context, the `this` operator will always point to the global
    object. In a web browser, the `window` object is the global object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局上下文中，`this` 操作符始终指向全局对象。在网页浏览器中，`window` 对象就是全局对象：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding example is a JavaScript example, not a TypeScript example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子是一个 JavaScript 示例，而不是 TypeScript 示例。
- en: The this operator in a function context
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数上下文中的 `this` 操作符
- en: 'The value of `this` inside a function depends on how the function is invoked.
    If we simply invoke a function in non-strict mode, the value of `this` within
    the function will point to the global object as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内部 `this` 的值取决于函数的调用方式。如果我们以非严格模式简单地调用一个函数，函数内部的 `this` 值将指向全局对象，如下所示：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All examples in this sub section (that is, the `this` operator in a function
    context) are JavaScript examples, not TypeScript examples.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有示例（即函数上下文中的 `this` 操作符）都是 JavaScript 示例，而不是 TypeScript 示例。
- en: 'However, if we invoke a function in strict mode, the value of `this` within
    the function''s body will point to `undefined` as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们以严格模式调用一个函数，函数体内的 `this` 值将指向 `undefined`，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ECMAScript 5's strict mode is a way to opt in to a restricted variant of JavaScript.
    You can learn more about the strict mode at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5 的严格模式是一种选择进入 JavaScript 限制变体的方式。你可以在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
    了解更多关于严格模式的信息。
- en: 'However, the value of the `this` operator inside a function invoked as an instance
    method points to the instance. In other words, the value of the `this` operator
    within a function that is part of a class points to that class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将函数作为实例方法调用时，函数内部的 `this` 操作符的值指向实例。换句话说，函数上下文中的 `this` 操作符（该函数是类的一部分）指向那个类：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we have used object literal notation to define an
    object named `p`, but the same applies when declaring objects using prototypes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了对象字面量表示法来定义一个名为 `p` 的对象，但使用原型声明对象时也适用同样的规则：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When a function is used as a constructor (with the `new` keyword), the `this`
    operator points to the object being constructed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数用作构造函数（使用 `new` 关键字）时，`this` 操作符指向正在构造的对象：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The call, apply, and bind methods
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用、应用和绑定方法
- en: All functions inherit the `call`, `apply`, and `bind` methods from `Function.prototype`.
    We can use these methods to set the value of `this`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数都从 `Function.prototype` 继承了 `call`、`apply` 和 `bind` 方法。我们可以使用这些方法来设置 `this`
    的值。
- en: The `call` and `apply` methods are almost identical; both methods allow us to
    invoke a function and set the value of the `this` operator within the function.
    The main difference between `call` and `apply` is that, while `apply` lets us
    invoke the function with arguments as an array, `call` requires the function parameters
    to be listed explicitly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`call` 和 `apply` 方法几乎相同；两种方法都允许我们调用一个函数并设置函数内部的 `this` 操作符的值。`call` 和 `apply`
    之间的主要区别在于，虽然 `apply` 允许我们将参数作为数组传递给函数，但 `call` 需要显式列出函数参数。'
- en: A useful mnemonic is *A (*`apply`*) for an array and C (*`call`*) for a comma*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的记忆法是：A (*`apply`*) 代表数组，C (*`call`*) 代表逗号*。
- en: 'Let''s look at an example. We will start by declaring a class named `Person`.
    This class has two properties (`name` and `surname`) and one method (`greet`).
    The `greet` method uses the `this` operator to access the `name` and `surname`
    instance properties:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我们首先声明一个名为 `Person` 的类。这个类有两个属性（`name` 和 `surname`）和一个方法（`greet`）。`greet`
    方法使用 `this` 操作符来访问 `name` 和 `surname` 实例属性：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After declaring the `Person` class, we will create an instance:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了 `Person` 类之后，我们将创建一个实例：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we invoke the `greet` method, it will work as expected:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `greet` 方法，它将按预期工作：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, we can invoke the method using the `call` and `apply` functions.
    We have supplied the `person` object as the first parameter of both functions
    because we want the `this` operator (inside the `greet` method) to take person
    as its value:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `call` 和 `apply` 函数来调用该方法。我们在两个函数中提供了 `person` 对象作为第一个参数，因为我们想让 `this`
    操作符（在 `greet` 方法内部）的值是 person：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we provide a different value to be used as the value of `this`, we will
    not be able to access the `name` and `surname` properties within the `greet` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供一个不同的值作为 `this` 的值，我们就无法在 `greet` 函数内访问 `name` 和 `surname` 属性：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The two preceding examples may seem useless, because the first one invoked
    the function directly and the second one caused unexpected behavior. The `apply`
    and `call` methods make sense only when we want the `this` operator to take a
    different value when a function is invoked:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子可能看起来没有用，因为第一个直接调用了函数，而第二个导致了意外的行为。`apply` 和 `call` 方法只有在我们需要在函数调用时改变 `this`
    操作符的值时才有意义：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `bind` method can be used to set the value of the `this` operator (within
    a function), regardless of how it is invoked.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind` 方法可以用来设置 `this` 操作符（在函数内部）的值，无论它是如何被调用的。'
- en: When we invoke a function's `bind` method, it returns a new function with the
    same body and scope as the original function, but the `this` operator (within
    the body function) is permanently bound to the first argument of `bind`, regardless
    of how the function is being used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个函数的 `bind` 方法时，它返回一个与原始函数具有相同体和作用域的新函数，但 `this` 操作符（在函数体内部）将永久绑定到 `bind`
    的第一个参数，无论函数是如何被使用的。
- en: 'Let''s look at an example. We will start by creating an instance of the `Person`
    class that we declared in the previous example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我们首先创建一个 `Person` 类的实例，这个类是我们之前声明的：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we can use bind to set the `greet` function to be a new function with
    the same scope and body:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `bind` 将 `greet` 函数设置为具有相同作用域和体的新函数：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we try to invoke the `greet` function using `bind` and `apply`, just like
    we did in the previous example, we will be able to observe that, this time, the
    `this` operator will always point to the object instance  regardless of how the
    function is invoked:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用 `bind` 和 `apply` 来调用 `greet` 函数，就像我们在上一个示例中所做的那样，我们将能够观察到，这次，`this`
    操作符将始终指向对象实例，无论函数是如何被调用的：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once we bind an object to a function with `bind`, we cannot override it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 `bind` 将一个对象绑定到一个函数上，我们就无法覆盖它：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using the `bind`, `apply`, and `call` methods is often discouraged because it
    can lead to confusion. Modifying the default behavior of the `this` operator can
    lead to unexpected results. Remember to use these methods only when strictly necessary
    and to document your code properly to reduce the risk caused by potential maintainability
    issues.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `bind`、`apply` 和 `call` 方法通常是不被推荐的，因为这可能会导致混淆。修改 `this` 操作符的默认行为可能会导致意外的结果。请记住，仅在绝对必要时使用这些方法，并适当地记录代码以减少潜在的可维护性问题带来的风险。
- en: Prototypes
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型
- en: When we compile a TypeScript program, all classes and objects become JavaScript
    objects. However, sometimes we may encounter an unexpected behavior at runtime,
    even if the compilation was completed without errors. To be able to identify and
    understand the cause of this behavior, we need a good understanding of the JavaScript
    runtime. One of the main concepts that we need to understand is how inheritance
    works at runtime.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译 TypeScript 程序时，所有的类和对象都变成了 JavaScript 对象。然而，有时即使编译没有错误，我们可能在运行时遇到意外的行为。为了能够识别和理解这种行为的起因，我们需要对
    JavaScript 运行时有一个很好的理解。我们需要理解的主要概念之一是运行时的继承是如何工作的。
- en: The runtime inheritance system uses a prototypal inheritance model. In a prototypal
    inheritance model, objects inherit from objects, and there are no classes available.
    However, we can use prototypes to simulate classes. Let's see how it works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时继承系统使用原型继承模型。在原型继承模型中，对象从对象继承，没有类可用。然而，我们可以使用原型来模拟类。让我们看看它是如何工作的。
- en: At runtime, every JavaScript object has an internal property called prototype.
    The value of the prototype attribute is an object, which contains some attributes
    (data) and methods (behavior).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，每个JavaScript对象都有一个名为`prototype`的内部属性。`prototype`属性的值是一个对象，它包含一些属性（数据）和方法（行为）。
- en: 'In TypeScript, we can use a class-based inheritance system:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，我们可以使用基于类的继承系统：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have defined a class named `Person`. At runtime, this class is declared
    using prototypes instead of classes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Person`的类。在运行时，这个类使用原型而不是类来声明：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code is emitted by TypeScript when we target ES5\. The `class`
    keyword is supported by ES6 at runtime, but it is syntactic sugar. In computer
    science, syntactic sugar is syntax within a programming language that is designed
    to make things easier to read or to express. This means that the `class` keyword
    is just a helper to make our lives as software engineers easier and, internally,
    prototypes are always used.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是TypeScript在针对ES5时输出的。`class`关键字在ES6运行时得到支持，但它只是语法糖。在计算机科学中，语法糖是编程语言中设计来使事物更容易阅读或表达的语言。这意味着`class`关键字只是一个帮助我们作为软件工程师更容易生活的助手，并且内部始终使用原型。
- en: The TypeScript compiler wraps the object definition (we will not refer to it
    as a class definition because, technically, it is not a class) with an **immediately
    invoked function expression** (**IIFE**). Inside the IIFE, we can find a function
    named `Person`. If we examine the function and compare it with the TypeScript
    class, we will notice that it takes the same parameters that the class constructor
    takes in the TypeScript class. This function is used to create new instances of
    the `Person` class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器将对象定义（我们不会将其称为类定义，因为技术上它不是类）用立即执行函数表达式（**IIFE**）包装起来。在IIFE内部，我们可以找到一个名为`Person`的函数。如果我们检查这个函数并与TypeScript类进行比较，我们会注意到它接受与TypeScript类构造函数相同的参数。这个函数用于创建`Person`类的新实例。
- en: After the constructor, we can see the definition of the `greet` method. As we
    can see, the `prototype` attribute is used to attach the `greet` method to the
    `Person` class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数之后，我们可以看到`greet`方法的定义。正如我们所见，`prototype`属性被用来将`greet`方法附加到`Person`类上。
- en: Instance properties versus class properties
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例属性与类属性
- en: 'Because JavaScript is a dynamic programming language, we can add properties
    and methods to an instance of an object at runtime, and they don''t need to be
    part of the object (class) itself. Let''s look at an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JavaScript是一种动态编程语言，我们可以在运行时向对象的实例添加属性和方法，它们不需要是对象（类）本身的一部分。让我们看看一个例子：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have defined a constructor function for an object named `person`, which
    takes two variables (`name` and `surname`) as arguments. Then, we have created
    an instance of the `Person` object and added a new property named `age` to it.
    We can use a `for...in` statement to check the properties of `person` at runtime:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为名为`person`的对象定义了一个构造函数，它接受两个变量（`name`和`surname`）作为参数。然后，我们创建了一个`Person`对象的实例，并给它添加了一个名为`age`的新属性。我们可以使用`for...in`语句在运行时检查`person`的属性：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All these properties are **instance properties** because they hold a value
    for each new instance. If, for example, we create a new instance of `Person`,
    both instances will hold their own values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性都是**实例属性**，因为它们为每个新实例持有值。例如，如果我们创建一个`Person`的新实例，这两个实例都将持有它们自己的值：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have defined these instance properties using the `this` operator, because
    when a function is used as a constructor (with the `new` keyword), the `this`
    operator is bound to the new object being constructed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`this`运算符定义了这些实例属性，因为在函数用作构造函数（使用`new`关键字）时，`this`运算符绑定到正在构造的新对象上。
- en: 'This also explains why we can alternatively define instance properties through
    the object''s prototype:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这也解释了为什么我们可以通过对象的原型来定义实例属性：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can also declare class-level properties and methods (also known as static
    properties). The main difference is that the values of class properties and methods
    are shared between all instances of an object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以声明类级别的属性和方法（也称为静态属性）。主要区别是类属性和方法的值在对象的各个实例之间是共享的。
- en: 'Class properties are often used to store static values:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性通常用于存储静态值：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Class methods are also often used as utility functions that perform calculations
    upon supplied parameters and return a result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法也经常被用作执行计算并返回结果的实用函数：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding example, we have accessed a class attribute (`PI`) from a
    class method (`areaOfCircle`). We can access class properties from instance methods,
    but we cannot access instance properties or methods from class properties or methods.
    We can demonstrate this by declaring `PI` as an instance property instead of a
    class property:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们从类方法（`areaOfCircle`）中访问了一个类属性（`PI`）。我们可以从实例方法中访问类属性，但不能从类属性或方法中访问实例属性或方法。我们可以通过将
    `PI` 声明为实例属性而不是类属性来演示这一点：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we then attempt to access `PI` from a class method, it will be undefined:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从一个类方法中访问 `PI`，它将是未定义的：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are not supposed to access class methods or properties from instance methods,
    but there is a way to do it. We can achieve it by using the prototype''s constructor
    property as demonstrated in the following example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该从实例方法中访问类方法或属性，但有一种方法可以做到。我们可以通过使用原型构造函数属性，如以下示例所示来实现它：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can access the `PI` class property from the `areaOfCircle` instance method
    using the prototype's constructor property, because this property returns a reference
    to the object's constructor.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用原型构造函数属性从 `areaOfCircle` 实例方法中访问 `PI` 类属性，因为这个属性返回对对象构造函数的引用。
- en: 'Inside `areaOfCircle`, the `this` operator returns a reference to the object''s
    prototype:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `areaOfCircle` 内部，`this` 操作符返回对对象原型的引用：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The value of `this.constructor` is equal to `MathHelper.prototype.constructor`
    and, therefore, `MathHelper.prototype.constructor` is equal to `MathHelper`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.constructor` 的值等于 `MathHelper.prototype.constructor`，因此 `MathHelper.prototype.constructor`
    等于 `MathHelper`。'
- en: Prototypal inheritance
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型继承
- en: 'We might be wondering how the `extends` keyword works. Let''s create a new
    TypeScript class, which inherits from the `Person` class, to understand it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会想知道 `extends` 关键字是如何工作的。让我们创建一个新的 TypeScript 类，它从 `Person` 类继承，以理解它：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding class is named `SuperHero` and extends the `Person` class. It
    has one extra attribute (`superpower`) and method (`useSuperPower`). If we compile
    the code, we will notice the following piece of code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个类被命名为 `SuperHero` 并扩展了 `Person` 类。它有一个额外的属性（`superpower`）和一个方法（`useSuperPower`）。如果我们编译代码，我们会注意到以下代码片段：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Please note that the preceding code snippet is slightly more complicated in
    TypeScript 2.8\. We will use the code from the previous versions here because
    it contains fewer conditions and is easier to understand.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码片段在 TypeScript 2.8 中稍微复杂一些。在这里我们将使用之前版本的代码，因为它包含的条件较少，更容易理解。
- en: This piece of code is generated by TypeScript. Even though it is a small piece
    of code, it showcases almost every concept contained in this chapter, and understanding
    it can be quite challenging.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是由 TypeScript 生成的。尽管它是一小段代码，但它展示了本章几乎包含的每一个概念，理解它可能相当具有挑战性。
- en: Before the function expression is evaluated for the first time, the `this` operator
    points to the global object, which does not contain a method named `__extends`.
    This means that the `__extends` variable is undefined.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数表达式第一次评估之前，`this` 操作符指向全局对象，它不包含名为 `__extends` 的方法。这意味着 `__extends` 变量是未定义的。
- en: When the function expression is evaluated for the first time, the value of the
    function expression (an anonymous function) is assigned to the `__extends` property
    in the global scope.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数表达式第一次评估时，函数表达式的值（一个匿名函数）被分配给全局作用域中的 `__extends` 属性。
- en: 'TypeScript generates the function expression one time for each TypeScript file
    containing the `extends` keyword. However, the function expression is only evaluated
    once (when the `__extends` variable is undefined). This behavior is implemented
    by the conditional statement in the first line:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 为包含 `extends` 关键字的每个 TypeScript 文件生成一次函数表达式。然而，函数表达式只评估一次（当 `__extends`
    变量未定义时）。这种行为是通过第一行的条件语句实现的：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first time this line of code is executed, the function expression is evaluated.
    The value of the function expression is an anonymous function, which is assigned
    to the `__extends` variable in the global scope. Because we are in the global
    scope, `var __extends` and `this. __extends` refer to the same variable at this
    point.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一行代码第一次执行时，函数表达式会被评估。函数表达式的值是一个匿名函数，它被分配给全局作用域中的 `__extends` 变量。因为我们在全局作用域中，`var
    __extends` 和 `this. __extends` 在这个点上指向同一个变量。
- en: When a new file is executed, the `__extends` variable is already available in
    the global scope, and the function expression is not evaluated. This means that
    the value of the function expression is only assigned to the `__extends` variable
    once, even if the snippet is executed multiple times.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新文件执行时，`__extends` 变量已经在全局作用域中可用，函数表达式不会被评估。这意味着函数表达式的值只被分配给 `__extends`
    变量一次，即使代码片段被多次执行。
- en: 'Let''s focus now on the `__extends` variable (the anonymous function):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注一下 `__extends` 变量（匿名函数）：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function takes two arguments, named `d` and `b`. When we invoke it, we
    should pass a derived object constructor (`d`) and a base object constructor (`b`).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个参数，分别命名为 `d` 和 `b`。当我们调用它时，我们应该传递一个派生对象构造函数（`d`）和一个基对象构造函数（`b`）。
- en: 'The first line inside the anonymous function iterates each class property and
    method from the base class and creates their copy in the derived class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数内的第一行遍历基类的每个属性和方法，并在派生类中创建它们的副本：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When we use a `for...in` statement to iterate an instance of an object to `a`,
    it will iterate the object's instance properties. However, if we use a `for...in`
    statement to iterate the properties of an object's constructor, the statement
    will iterate its class properties. In the preceding example, the `for...in` statement
    is used to inherit the object's class properties and methods. To inherit the instance
    properties, we will copy the object's prototype.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `for...in` 语句迭代对象的实例到 `a` 时，它将迭代对象的实例属性。然而，如果我们使用 `for...in` 语句迭代对象构造函数的属性，该语句将迭代其类属性。在前面的例子中，`for...in`
    语句被用来继承对象的类属性和方法。为了继承实例属性，我们将复制对象的原型。
- en: 'The second line declares a new constructor function named `__`, and inside
    it, the `this` operator is used to access its prototype:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行声明了一个新的构造函数 `__`，并在其中使用 `this` 操作符来访问其原型：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The prototype contains a special property named `constructor`, which returns
    a reference to the object's constructor. The function named `__` and `this.constructor`
    are pointing to the same variable at this point. The value of the derived object
    constructor (`d`) is then assigned to the `__` constructor.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 原型包含一个名为 `constructor` 的特殊属性，它返回对对象构造函数的引用。在这个点上，名为 `__` 的函数和 `this.constructor`
    指向同一个变量。然后，派生对象构造函数（`d`）的值被分配给 `__` 构造函数。
- en: 'In the third line, the value of the prototype object from the base object constructor
    is assigned to the prototype of the `__` object constructor:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，基对象构造函数的原型对象的值被分配给 `__` 对象构造函数的原型：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the last line, `new __()` is invoked, and the result is assigned to the
    derived class (`d`) prototype. By performing all these steps, we can invoke the
    following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，调用了 `new __()`，并将结果分配给派生类（`d`）的原型。通过执行所有这些步骤，我们可以调用以下内容：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Upon doing so, we will get an object that contains all the properties from both
    the derived class (`d`) and the base class (`b`). Furthermore, any instance objects
    constructed by the derived constructor (`d`) will be instances of the derived
    class while inheriting both the class and instance properties and methods from
    the base class (`b`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做之后，我们将得到一个包含派生类（`d`）和基类（`b`）所有属性的对象。此外，由派生构造函数（`d`）构建的任何实例对象都将作为派生类的实例，同时继承自基类（`b`）的类和实例属性和方法。
- en: 'We can see the function in action by examining the runtime code that defines
    the `SuperHero` class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查定义 `SuperHero` 类的运行时代码来查看这个函数的实际效果：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can see an IIFE here again. This time, the IIFE takes the `Person` object
    constructor as the argument. Inside the function, we will refer to this argument
    using the name `_super`. Inside the IIFE, the `__extends` function is invoked
    and the `SuperHero` (derived class) and `_super` (base class) arguments are passed
    to it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里再次看到了立即执行函数表达式（IIFE）。这次，IIFE 将 `Person` 对象构造函数作为参数。在函数内部，我们将使用 `_super`
    这个名字来引用这个参数。在 IIFE 内部，调用了 `__extends` 函数，并将 `SuperHero`（派生类）和 `_super`（基类）参数传递给它。
- en: In the next line, we can find the declaration of the `SuperHero` object constructor
    and the `useSuperPower` function. We can use `SuperHero` as an argument of `__extend`
    before it is declared because function declarations are hoisted to the top of
    the scope.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们可以找到 `SuperHero` 对象构造函数和 `useSuperPower` 函数的声明。我们可以在声明之前使用 `SuperHero`
    作为 `__extend` 的参数，因为函数声明会被提升到作用域的顶部。
- en: Function expressions are not hoisted. When we assign a function to a variable
    in a function expression, the variable is hoisted, but its value (the function
    itself) is not hoisted.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式不会被提升。当我们在一个函数表达式中将函数赋给一个变量时，变量会被提升，但它的值（函数本身）不会被提升。
- en: 'Inside the `SuperHero` constructor, the base class (`Person`) constructor is
    invoked using the `call` method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SuperHero` 构造函数内部，使用 `call` 方法调用基类（`Person`）的构造函数：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As we discovered previously in this chapter, we can use `call` to set the value
    of the `this` operator in a function context. In this case, we are passing the
    `this` operator, which points to the instance of `SuperHero` being created:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所发现的，我们可以使用 `call` 来设置函数上下文中 `this` 操作符的值。在这种情况下，我们传递了 `this` 操作符，它指向正在创建的
    `SuperHero` 实例：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The prototype chain and property shadowing
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型链和属性遮蔽
- en: When we try to access a property or a method of an object, the runtime will
    search for that property or method in the object's properties and methods. If
    it is not found, the runtime will continue searching through the object's inherited
    properties by navigating the entire inheritance tree. Because a derived object
    is linked to its base object through the `prototype` property, we refer to this
    inheritance tree as **the prototype chain**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试访问一个对象的属性或方法时，运行时会搜索该对象属性和方法。如果找不到，运行时会继续通过遍历整个继承树来搜索对象的继承属性。因为派生对象通过 `prototype`
    属性与其基对象链接，所以我们称这个继承树为 **原型链**。
- en: 'Let''s look at an example. We will declare two simple TypeScript classes named
    `Base` and `Derived`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。我们将声明两个简单的 TypeScript 类，分别命名为 `Base` 和 `Derived`：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we will examine the JavaScript code generated by TypeScript:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将检查 TypeScript 生成的 JavaScript 代码：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can then create an instance of the `Derived` class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建 `Derived` 类的一个实例：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we try to access the method named `method1`, the runtime will find it in
    the instance''s properties:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试访问名为 `method1` 的方法，运行时会在实例属性中找到它：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The instance also has an own property named `method2` (with value 2), but there
    is also an inherited property named `method2` (with value 3). The object''s property
    (`method2` with value 3) prevents the access to the `prototype` property (`method2`
    with value 2). This is known as **property shadowing**:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实例还有一个名为 `method2` 的自有属性（值为 2），但还有一个继承的属性名为 `method2`（值为 3）。对象的属性（值为 3 的 `method2`）阻止了对原型属性（值为
    2 的 `method2`）的访问。这被称为 **属性遮蔽**：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The instance does not have an own property named `method3`, but it has a property
    named `method3` in its prototype:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 实例没有名为 `method3` 的自有属性，但在其原型中有一个名为 `method3` 的属性：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Neither the instance nor the objects in the prototype chain (the `Base` class)
    have a property named `method4`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 实例或原型链中的对象（`Base` 类）都没有名为 `method4` 的属性：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Accessing the prototype of an object
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问对象的原型
- en: 'Prototypes can be accessed in three different ways:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 原型可以通过三种不同的方式访问：
- en: '`Person.prototype`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.prototype`'
- en: '`Object.getPrototypeOf(person)`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getPrototypeOf(person)`'
- en: '`person.__proto__`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person.__proto__`'
- en: The use of `__proto__` is controversial and has been discouraged by many experienced
    software engineers. It was never originally included in the ECMAScript language
    specification, but modern browsers decided to implement it anyway. Today, the
    `__proto__` property has been standardized in the ECMAScript 6 language specification
    and will be supported in the future, but it is still a slow operation that should
    be avoided if performance is a concern.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `__proto__` 是有争议的，并且被许多经验丰富的软件工程师所反对。它从未被最初包含在 ECMAScript 语言规范中，但现代浏览器决定无论如何都要实现它。今天，`__proto__`
    属性已经被标准化在 ECMAScript 6 语言规范中，并将得到未来的支持，但它仍然是一个应该避免的慢操作，如果性能是一个关注点的话。
- en: The new operator
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新操作符
- en: 'We can use the `new` operator to generate an instance of `Person`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `new` 操作符来生成 `Person` 的一个实例：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When we use the new operator, the runtime creates a new object that inherits
    from the `Person` class prototype.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用新操作符时，运行时会创建一个新的对象，该对象继承自 `Person` 类的原型。
- en: Closures
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Closures are one of the most powerful features available at runtime, but they
    are also one of the most misunderstood. The Mozilla developer network defines
    closures as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是运行时可用功能中最强大之一，但它们也是最容易误解的。Mozilla开发者网络将闭包定义为如下：
- en: '"Closures are functions that refer to independent (free) variables. In other
    words, the function defined in the closure ''remembers'' the environment in which
    it was created".'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: “闭包是引用独立（自由）变量的函数。换句话说，闭包中定义的函数‘记得’它被创建的环境”。
- en: 'We understand independent (free) variables as variables that persist beyond
    the lexical scope from which they were created. Let''s look at an example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将独立（自由）变量理解为在创建它们的词法作用域之外持续存在的变量。让我们看一个例子：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding example is a JavaScript example, not a TypeScript example.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个JavaScript示例，而不是TypeScript示例。
- en: 'We have declared a function named `makeArmy`. Inside the function, we have
    created an array of functions named `shooters`. Each function in the `shooters`
    array will display a number, the value of which was set from the variable `i`
    inside a `for` statement. We will now invoke the `makeArmy` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`makeArmy`的函数。在函数内部，我们创建了一个名为`shooters`的函数数组。`shooters`数组中的每个函数将显示一个数字，其值是从`for`语句内部的变量`i`设置的。现在我们将调用`makeArmy`函数：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The variable `army` should now contain the array of the function''s `shooters`.
    However, we will notice a problem if we execute the following piece of code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`army`现在应该包含函数的`shooters`数组。然而，如果我们执行以下代码，我们会注意到一个问题：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding code snippet does not work as expected because we made one of
    the most common mistakes related to closures. When we declared the `shooter` function
    inside the `makeArmy` function, we created a closure without being aware of it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段没有按预期工作，因为我们犯了一个与闭包相关的最常见错误。当我们将在`makeArmy`函数内部声明的`shooter`函数时，我们没有意识到我们创建了一个闭包。
- en: The reason for this is that the functions assigned to `shooter` are closures;
    they consist of the function definition and the captured environment from the
    `makeArmy` function's scope. We have created ten closures, but all of them the
    same environment. By the time the `shooter` functions are executed, the loop has
    run its course, and the `i` variable (shared by all the closures) has been left
    pointing to the last entry (`10`).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的原因是分配给`shooter`的函数是闭包；它们由函数定义和从`makeArmy`函数作用域捕获的环境组成。我们创建了十个闭包，但它们都具有相同的环境。当`shooter`函数执行时，循环已经完成，共享于所有闭包的`i`变量（指向最后一个条目`10`）。
- en: 'One solution, in this case, is to use more closures:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个解决方案是使用更多的闭包：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding example is a TypeScript example, not a JavaScript example.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个TypeScript示例，而不是JavaScript示例。
- en: This works as expected. Rather than the shooter functions sharing a single environment,
    the immediately invoked function creates a new environment for each one in which
    `i` refers to the corresponding value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如预期的那样工作。而不是让`shooter`函数共享一个单一的环境，立即调用的函数为每个函数创建一个新的环境，其中`i`指向相应的值。
- en: Static variables powered by closures
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由闭包驱动的静态变量
- en: In the previous section, we learned that when a variable in a closure context
    is shared between multiple instances of a class, the variable behaves like a static
    variable.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到当闭包上下文中的变量在类的多个实例之间共享时，该变量表现得像静态变量。
- en: 'We will now see how we can create variables and methods that behave like a
    static variables. Let''s start by declaring a TypeScript class named `Counter`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何创建表现像静态变量一样的变量和方法。让我们首先声明一个名为`Counter`的TypeScript类：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding example is a TypeScript example, not a JavaScript example.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个TypeScript示例，而不是JavaScript示例。
- en: 'The preceding class contains a static member named `_COUNTER`. The TypeScript
    compiler transforms it into the resultant code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类包含一个名为`_COUNTER`的静态成员。TypeScript编译器将其转换为以下代码：
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding example is a JavaScript example, not a TypeScript example.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个JavaScript示例，而不是TypeScript示例。
- en: As we can observe, the static variable is declared by the TypeScript compiler
    as a class property (as opposed to an `instance` property). The compiler uses
    a class property because class properties are shared across all instances of a
    class. The problem is that the private variable is not private at runtime.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所观察到的，TypeScript编译器将静态变量声明为类属性（而不是`instance`属性）。编译器使用类属性，因为类属性在类的所有实例之间共享。问题是私有变量在运行时并不是私有的。
- en: 'Alternatively, we could write some JavaScript (remember that all valid JavaScript
    is valid TypeScript) code to emulate static properties at runtime using closures:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以编写一些JavaScript（记住，所有有效的JavaScript都是有效的TypeScript）代码来使用闭包在运行时模拟静态属性：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding example is a JavaScript example, not a TypeScript example.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个JavaScript示例，而不是TypeScript示例。
- en: The preceding code snippet declares a class named `Counter`. The class has some
    methods used to increment, decrement, and read the variable named `_COUNTER`.
    The `_COUNTER` variable itself is not part of the object prototype.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段声明了一个名为 `Counter` 的类。该类有一些用于增加、减少和读取名为 `_COUNTER` 的变量的方法。`_COUNTER` 变量本身不是对象原型的部分。
- en: All the instances of the `Counter` class will share the same context, which
    means that the context (the variable `counter` and the function `changeBy`) will
    behave as a singleton.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 类的所有实例将共享相同的上下文，这意味着上下文（变量 `counter` 和函数 `changeBy`）将表现得像一个单例。'
- en: The singleton pattern requires an object to be declared as a static variable
    to avoid the need to create its instance whenever it is required. The object instance
    is, therefore, shared by all the components in the application. The singleton
    pattern is frequently used in scenarios where it is not beneficial, introducing
    unnecessary restrictions in situations where a unique instance of a class is not
    required and introduces global state into an application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式要求将对象声明为静态变量以避免在需要时创建其实例。因此，对象实例由应用程序的所有组件共享。单例模式在不需要类唯一实例的情况下经常被使用，在不必要的情况下引入全局状态到应用程序中。
- en: 'Now we know how to use closures to emulate static variables:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用闭包来模拟静态变量：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Private members powered by closures
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由闭包驱动的私有成员
- en: In the previous section, we learned that closures can access variables that
    persist beyond the lexical scope from which they were created. These variables
    are not part of the function prototype or body, but they are part of the function
    context.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到闭包可以访问它们创建的词法作用域之外持续存在的变量。这些变量不是函数原型或主体的部分，但它们是函数上下文的一部分。
- en: Because there is no way we can directly invoke the function context, the context
    variables and methods can be used to emulate private members at runtime. The main
    advantage of using closures to emulate private members (instead of the TypeScript
    private access modifier) is that closures will prevent access to private members
    at runtime.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法直接调用函数上下文，上下文变量和方法可以用来在运行时模拟私有成员。使用闭包来模拟私有成员（而不是TypeScript私有访问修饰符）的主要优势是闭包将在运行时阻止对私有成员的访问。
- en: TypeScript avoids emulating private properties at runtime because the compiler
    will throw an error at compilation time if we attempt to access a private member.
    TypeScript avoids the use of closures to emulate private members to improve the
    application performance. If we add or remove an access modifier to or from one
    of our classes, the resultant JavaScript code will not change at all. This means
    that the private members of a class (at design time) become public members at
    runtime.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 避免在运行时模拟私有属性，因为如果我们在编译时尝试访问私有成员，编译器将抛出错误。TypeScript 避免使用闭包来模拟私有成员以提高应用程序性能。如果我们向我们的类之一添加或删除访问修饰符，生成的JavaScript代码将完全不会改变。这意味着类（在设计时）的私有成员在运行时成为公共成员。
- en: 'However, it is possible to use closures to emulate private properties at runtime.
    Let''s look at an example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以在运行时使用闭包来模拟私有属性。让我们看一个例子：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding example is a TypeScript example, not a JavaScript example.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个TypeScript示例，而不是JavaScript示例。
- en: The preceding class is almost identical to the class that we previously declared
    to demonstrate how to emulate static variables at runtime using closures.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类几乎与我们之前声明的类相同，以演示如何使用闭包在运行时模拟静态变量。
- en: 'This time, a new closure context is created every time we invoke the `makeCounter`
    function, so each new instance of `Counter` will remember an independent context
    (`counter` and `changeBy`):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，每次我们调用 `makeCounter` 函数时，都会创建一个新的闭包上下文，因此每个新的 `Counter` 实例都将记住一个独立上下文（`counter`
    和 `changeBy`）：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Since the context cannot be accessed directly, we can say that the variable
    `counter` and the `changeBy` function are private members:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上下文不能直接访问，我们可以说变量 `counter` 和函数 `changeBy` 是私有成员：
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have acquired a better understanding of the runtime, which
    allows us not only to resolve runtime issues with ease but also to be able to
    write better TypeScript code. A deep understanding of closures and prototypes
    will allow us to develop some complex features that would have not been possible
    to develop without this knowledge.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对运行时有了更深入的理解，这使我们不仅能够轻松解决运行时问题，而且能够编写更好的TypeScript代码。对闭包和原型的深入理解将使我们能够开发一些没有这种知识就无法实现的复杂功能。
- en: In the next chapter, we will learn about the **functional programming** (**FP**)
    paradigm.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习**函数式编程**（**FP**）范式。
